~AI.COM.AIP.UPD~
*CODE.SEGMENT: AI.COM.AIP.UPD*
*
*
*
*
** AI.SRCE = "U"
** HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
** *
COM.AI.ID = "AI.TYPE.":AI.CODE
* MAT COM.AI S/D ALREADY PRESENT
** READV COMMPORT FROM COM.FILE,COM.AI.ID,12 ELSE COMMPORT = 999
COMMPORT = COM.AI$COMMPORT
*
COM.AIP.PORT = PORT
LOOP WHILE LEN(COM.AIP.PORT) LT 3 DO COM.AIP.PORT = ZERO:COM.AIP.PORT REPEAT
AI.DVC.NEXT.FOUND = TRUE
*
!
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND)
*
*
COM.AIP.ID = "AI*":AI.CODE:"*":COM.AIP.PORT:"*":AI.DVC.NEXT.CN
DT = DATE(); TM = TIME(); ELP = ZERO
*
LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LOCK.STAT AND ELP LT LOCK.ELP.MAX DO REPEAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
*
* SEND.STATUS = FALSE
AI.COM.FLAG = FALSE
DT = DATE(); TM = TIME()
*
IF CNT.TST$ID THEN
PRINT CLB:"Updating COM.AIP$INTFC.STAT. Enter <cr>: ":; INPUT TMP:
END
*
!
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
*
OK = TRUE
IF INDEX("#AIDVC#PVI#PVD#IVI#IVD#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE) THEN
IF WKO$STAT NE "C" AND WKO$STAT NE "D" THEN OK = FALSE
END ELSE
IF NOT(INDEX("#SEQ#UPB#DLE#SET#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE)) THEN OK = FALSE
END
*
IF NOT(OK) THEN
*
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 605
*
END ELSE
*
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
END; * OF NOT OK
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
* "TOUT" BEFORE COM.AIP$ERR.TYPE<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
SEND.STATUS = 601
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
* INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
* INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
SEND.STATUS = 602
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 603
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
SEND.STATUS = 604
*
CASE TRUE
* PRINT CLB:">>":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"<<":; INPUT TMP:
SEND.STATUS = 606
*
END CASE
*
*
!
*
IF SEND.STATUS THEN
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
*
IF COM.AIP$LOG.REQD OR SEND.STATUS THEN
OPEN "AIL" TO AIL.FILE THEN
AIL.SEQ.ID = "AI.LOG*":AI.CODE
* $INCLUDE IBP AI.LOG.WRITE
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LOG.REQUIRED,SYS.PROG,HANDLER.COMMAND,LOCKS.FILE,LOCK.TYPE)
END ELSE PRINT CLB:"AIL file missing! Enter <cr> . . . "; INPUT RSP; STAT = 999
END
*
*
NEXT SEND.COMM.CN
*
!
*
SEND.COMM.CN = ONE
*
*
***IF AI.COM.FLAG THEN
***MAT COM.AI = EMPTY
***HANDLER.COMMAND = COM.AIP$COMM; AI.TMP.STAT = EMPTY; SEND.TMP.STAT = EMPTY
**** CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
***CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.TMP.STAT,SEND.TMP.STAT,AI.CODE,AI.SRCE,LOCK.COM.AI,LOCK.COM.AIP,LOCK.TYPE)
***TMP.STAT = AI.TMP.STAT
**** IF TMP.STAT THEN
**** PRINT BELL:CLB:"Addressable interface error (":TMP.STAT:") - Press <cr>":
**** INPUT TMP.RSP:; IF TMP.RSP = "KILL" THEN STAT = 999
**** END
***END ELSE
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
* CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
*
***END
*
END ELSE
*
* CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
AI.DVC.NEXT.FOUND = FALSE
*
END; * OF READ
*
*
IF AI.DVC.NEXT.FOUND THEN
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
*
*
NEXT AI.DVC.NEXT.CN
*
!
*
* IF SEND.STATUS AND NOT(AUTO.RUN) THEN
* PRINT BELL:CLB:"Addressable interface error (":SEND.STATUS:") - Press <cr>":
* INPUT TMP.RSP:; * IF TMP.RSP = "KILL" THEN STAT = 999; RETURN
* END
*
~AI.ERR.INIT~
*CODE.SEGMENT: AI.ERR.INIT
* USED BY: AI.HANDLER
*          AI.TALKER
*
* DAVID HORSMAN
*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
PORT.NUM = PORT.KEY
PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORTS.LIST.BUILD = 9
PORT.CONT = FALSE; PORT.TYPE = EMPTY; PORT.ON = FALSE
PORT.LOC = ONE; PORT.VC = ONE
*
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
TMP = EMPTY; TMP0 = EMPTY; TPM1 = EMPTY; TMP2 = EMPTY
*
AI.STATUS = FALSE; SEND.STATUS = FALSE
COMMPORT = EMPTY; HEADEND = EMPTY
AI.CODE = EMPTY; INTFC.CODE = EMPTY; INTFC.TYPE = EMPTY
AI.DOWN = FALSE; AI.RESET = FALSE; AI.SRCE = "?"
AI.SCAN = TRUE; AI.SCAN.DT = DATE(); AI.SCAN.TM = TIME()
AI.SLEEP = EMPTY; AI.ERRORS = EMPTY; AI.CHK.ERR = EMPTY
TEXT = EMPTY; OUTPUTS = EMPTY
STATUS.CYCLE = FALSE; OFF.FLAG = FALSE
MSG.DISP = FALSE; MSG = EMPTY; MSG.N = ZERO
*
COM.ID = EMPTY; COM.ID.LIST = EMPTY
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY; COM.AI.ERR.TYPE = EMPTY
COM.AI.ERR.FUNC = EMPTY; COM.AI.ERR.DISP = ONE
COM.AI.RUN.ELP = ZERO; COM.AI.ON = EMPTY; COM.AI.UP = EMPTY
*
COM.AI.ID = EMPTY; LOCK.COM.AI = FALSE; COM.AI.ON.FILE = FALSE
COM.AI.PORT = EMPTY; COM.AI.ELP = ZERO; NEXT.COM.AI.ID = EMPTY
COM.AI.ON = FALSE; COM.AI.UP = FALSE
*
COM.AIP.ID = EMPTY; LOCK.COM.AIP = FALSE; COM.AIP.ON.FILE = FALSE
COM.AIP.PORT = EMPTY; COM.AIP.PORT.FIRST = TRUE
COM.AIP.ELP = ZERO; NEXT.COM.AIP.ID = EMPTY
*
ERR.DISP.ONLY = FALSE; ERR.CLB = FALSE
ERR.CL = 31; ERR.LN = 5; ERR.LEN = 48; ERR.FMT = EMPTY
ERR.LN.MIN = 5; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CLS = FALSE; ERR.BELL = FALSE; ERR.CR = FALSE
ERR.HDR = "Error Messages "; ERR.TEXT = EMPTY
ERR.LAST = EMPTY; ERR.TMP = EMPTY
*
CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 18
CHECK.LEN = 33; CHECK.LN.HI = ZERO
*
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
MAT COM.AI = EMPTY; MAT COM.AIP = EMPTY
*
LOCK.ELP.MAX = 60
*
~AI.ERR.VAR.EQUATES~
*CODE.SEGMENT: AI.ERR.VAR.EQUATES
*
*
* ERRORS
*
EQU ERR$OK           TO 0
EQU ERR$TRANS.NEXT   TO 701
EQU ERR$SYSTEM.BAD   TO 702
EQU ERR$PCK.END      TO 703
EQU ERR$COMMPORT.BAD TO 704
EQU ERR$CMD.FUTR     TO 705
EQU ERR$PPV.DATA.BAD TO 706
EQU ERR$DVC.MISSING  TO 707
EQU ERR$TABLE.FULL   TO 708
EQU ERR$DVC.EXISTS   TO 709
EQU ERR$NO.UNIT      TO 711
EQU ERR$CMD.BAD      TO 719
EQU ERR$EVNT.BAD     TO 722
EQU ERR$EVNT.EXISTS  TO 723
EQU ERR$SEND.LRC     TO 731
EQU ERR$RECV.PCK.STX TO 732
EQU ERR$RECV.LRC     TO 733
EQU ERR$COLL         TO 734; * Collection Status Error
EQU ERR$TRANS.NEXT.RECV TO 740; * MISMATCH ON PKT TRANS SEQ VS FILE
EQU ERR$BUF.OVFL     TO 760
EQU ERR$ENBL.BAD     TO 771
EQU ERR$RSP.LEN      TO 777
EQU ERR$CMD.LEN      TO 778
EQU ERR$SEND.PCK.STX TO 779
EQU ERR$HE.BUSY      TO 785
EQU ERR$POC.BUSY     TO 786
EQU ERR$CHAN.DN      TO 100
EQU ERR$CHAN.UP      TO 200
EQU ERR$NOT.SENT     TO 300
EQU ERR$NO.DVC.TYPE  TO 301
EQU ERR$TYPE.NOT.POC TO 302
EQU ERR$CHECK.TOUT   TO 371
EQU ERR$TOUT         TO 201
EQU ERR$DATA.BAD     TO 361
EQU ERR$RETRY.MAX    TO 400
EQU ERR$NO.RSP       TO 500
EQU ERR$HANDLER.ERR  TO 800
EQU ERR$HANDLER.MSG  TO 801
EQU ERR$FAILED       TO 900
EQU ERR$BAD.RSP      TO 910
EQU ERR$UNKNOWN      TO 991
EQU ERR$OPER.KILL    TO 999
*
~AI.HERROR.XREF~
*CODE.SEGMENT: AI.HERROR.XREF
* USED.BY: AI.HANDLER
*          AI.CHECK.HANDLER - 29 MAR 94
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
*
!
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
*
LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
*
COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
*
TMP2 = COM.AIHERR$DESC<ONE,ERR.LOC>
LOOP WHILE INDEX(TMP2,"@",ONE) DO
TMP = FIELD(TMP2,"@",ONE)
TMP0 = FIELD(TMP2,"@",TWO)
TMP1 = FIELD(TMP2,"@",3)
TMP1 = TMP2[COL1()+ONE,9999]
TMP.VAR = EMPTY
BEGIN CASE
CASE TMP0 EQ "COM.AI.RUN.ELP"
TMP.VAR = COM.AI.RUN.ELP
CASE TMP0 EQ "COM.AI$ON.OFF"
TMP.VAR = COM.AI$ON.OFF
CASE TMP0 EQ "COM.AI.ON.OFF.ELP"
TMP.VAR = COM.AI.ON.OFF.ELP
CASE TMP0 EQ "COM.AI$UP.DN"
TMP.VAR = COM.AI$UP.DN
CASE TMP0 EQ "COM.AI.UP.DN.ELP"
TMP.VAR = COM.AI.UP.DN.ELP
CASE TMP0 EQ "COM.AIP.ELP"
TMP.VAR = COM.AIP.ELP
CASE TMP0 EQ "COM.AIP.PORT"
TMP.VAR = COM.AIP.PORT
CASE TMP0 EQ "COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>"
TMP.VAR = COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
END CASE
TMP2 = TMP:TMP.VAR:TMP1
REPEAT
COM.AI.ERR.TEXT<-ONE> = TMP2
*
COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP
END
*
DEL AI.CHK.ERR<ONE>
REPEAT
*
END
*
**** ##### ***** End of AI.HERROR.XREF
~AI.INCL.WAITFOR.COMMAND~
*CODE.SEGMENT: AI.INCL.WAITFOR.COMMAND
* VERSION: 940130 1.1  COM.AI.ID CHANGED.
* USED BY: AI.TALKER
*          AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*   1990        ALL RIGHTS RESERVED
*
!
*
IF DISP.ONLY THEN RETURN
*
***NUM.TRIES = ZERO; MAX.PAUSE = 120; STD.PAUSE = 5
NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = COM.AI$MAX.PAUSE; STD.PAUSE = COM.AI$STD.PAUSE
***NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = 30; STD.PAUSE = ONE
IF NOT(MAX.PAUSE) THEN MAX.PAUSE = 30
IF NOT(STD.PAUSE) THEN STD.PAUSE = ONE
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF ELP.MAX LT 60 THEN ELP.MAX = 60
ELP.MAX = 15
WF.DT = DT; WF.TM = TM
* WF.C.LOC = HANDLER.COMMAND<ONE,ONE> (FUNC OR COMMAND) ( NOT USED )
* STAT = 0;  WF.C.FUNC = PORT NUMBER
WF.C.FUNC = PORT.KEY
COM.AI.ON.FILE = FALSE; HANDLER.DONE = FALSE
COM.AI.ID = "AI.TYPE.":AI.CODE; COM.ID = COM.AI.ID
*
LOOP
*
EXEC.VERB = "SLEEP ":STD.PAUSE
IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:EXEC.VERB "L#19":RVE:
IF NOT(SYSTEM(11)) THEN
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
END
*
*@*LOOP
*
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF NOT(LOCK.STAT) THEN LOCK.COM.AI = TRUE
IF LOCK.STAT GT 900 AND NOT(STAT) THEN STAT = LOCK.STAT
*
HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
IF HANDLER.ELP GT MAX.PAUSE + COM.AIP$MAX.PAUSE THEN
TEXT<-ONE> = "Can't wait longer than ":MAX.PAUSE + COM.AIP$MAX.PAUSE:" seconds."
AI.STATUS = 201
****INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
****INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
END
*
*@*WHILE (LOCK.STAT AND LOCK.STAT LT 900) AND AI.STATUS NE 201 DO REPEAT
*
*
* IF NOT(LOCK.STAT) THEN
*@*IF LOCK.COM.AI THEN
* IF AI.STATUS NE 201 THEN
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN
COM.AI.ON.FILE = TRUE
IF COM.AI$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AI$MAX.PAUSE
STD.PAUSE = COM.AI$STD.PAUSE
END ELSE
COM.AI.ON.FILE = FALSE; STAT = 998; MAT COM.AI = EMPTY
END
*
LOOP WHILE LEN(COM.AI$FUNC.PORT) AND COM.AI$FUNC.PORT<ONE,ONE> EQ EMPTY DO
DEL COM.AI$FUNC.PORT<ONE,ONE>
REPEAT
*
IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:COM.AI$FUNC.PORT<ONE> "L#19":RVE:
LOCATE WF.C.FUNC IN COM.AI$FUNC.PORT<ONE> SETTING COM.AI.LOC THEN
*
HANDLER.DONE = FALSE
*
IF AI.STATUS EQ 201 THEN
IF LOCK.COM.AI THEN
DEL COM.AI$FUNC.PORT<ONE,COM.AI.LOC>
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
END
END
*
IF COM.AI.LOC GT ONE THEN
WF.DT = DATE(); WF.TM = TIME()
END
*
*@*IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Not Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,ONE):RVB:"Comm. Not Done" "L#19":RVE:
*
END ELSE
*
HANDLER.DONE = TRUE; **** ???? *****
COM.AI.LOC = ONE
*@*IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,ONE):RVB:"Comm. Done" "L#19":RVE:
*
END
*
PORT.LOC = COM.AI.LOC
*
IF LOCK.COM.AI THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
*
* END ELSE
* HANDLER.DONE = FALSE
* END
*
UNTIL AI.STATUS EQ 201 OR HANDLER.DONE OR SYSTEM(11) GT 3 DO
*
*
**SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
***
**FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
***
*** PRINT @(0,20):CLL:@(0,21):CLL:@(20,21):
**PRINT @(0,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):CLL:@(15,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):
**TMP = REM(NUM.TRIES,TWO)
**IF NOT(TMP) THEN PRINT RVB:
**PRINT "waiting on the handler . . . ":
**HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
**IF NOT(TMP) THEN PRINT RVE: ELSE PRINT RVB:
***@*PRINT @(46,23):(" [":COM.AIP$COMM.PORT<ONE,SEND.COMM.CN>:"]") "L#8":(" (":MAX.PAUSE - HANDLER.ELP:")") "L#10":RVE:@(ZERO,ONE):
**PRINT @(46,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):(" [":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:"]") "L#22":(" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":RVE:@(ZERO,ONE):
***
**NEXT SEND.COMM.CN
*
*
* TMP = REM(NUM.TRIES,3)
TMP = FALSE
IF NOT(TMP) THEN
IF FAST.DISPLAY OR COM.AI.ERR.DISP THEN
TEXT = EMPTY; OUTPUTS = EMPTY
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
LOCK.ELP.MAX = 10
IF COM.AI$GENIE.WINDOW EQ "Y" AND AI.SRCE EQ "T" THEN PORTS.LIST.BUILD = 7
GOSUB INTFC.CHECK
GOSUB INTFC.MESSAGES
IF LEN(OUTPUTS) THEN TEXT = OUTPUTS:AM:TEXT
ERR.DISP.ONLY = TWO
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE
END
END
*
!
*
AI.DVC.NEXT.FOUND = TRUE; AI.DVC.DONE = TRUE
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND) OR DONE
AI.DVC.NEXT.CN = ONE
*
*
*
DT = DATE(); TM = TIME(); ELP = ZERO
COM.AIP.ID = "AI*":AI.CODE:"*":PORT:"*":AI.DVC.NEXT.CN
*#*LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
** HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
** IF HANDLER.ELP GT MAX.PAUSE + COM.AIP$MAX.PAUSE THEN
** TEXT<-ONE> = "Can't wait longer than ":MAX.PAUSE + COM.AIP$MAX.PAUSE:" seconds."
** AI.STATUS = 201
*****INS  "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
*****INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
** * COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
** END
*#*UNTIL NOT(LOCK.STAT) OR ELP GT ELP.MAX DO REPEAT
IF NOT(LOCK.STAT) THEN LOCK.COM.AIP = TRUE
IF LOCK.STAT GT 900 AND NOT(STAT) THEN STAT = LOCK.STAT
*
*#*IF LOCK.COM.AIP THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; AI.DVC.NEXT.FOUND = FALSE
*
*
IF AI.DVC.NEXT.FOUND THEN
*
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
* PRINT @(0,20):CLL:@(0,21):CLL:@(20,21):
* - ((AI.DVC.NEXT.CN-1) * 2)
PRINT @(0,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN - ((AI.DVC.NEXT.CN-1) * 2))):CLL:@(15,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN - ((AI.DVC.NEXT.CN-1) * 2))):
TMP = REM(NUM.TRIES,TWO)
IF NOT(TMP) THEN PRINT RVB:
PRINT "waiting on the handler . . . ":
HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
IF NOT(TMP) THEN PRINT RVE: ELSE PRINT RVB:
*@*PRINT @(46,23):(" [":COM.AIP$COMM.PORT<ONE,SEND.COMM.CN>:"]") "L#8":(" (":MAX.PAUSE - HANDLER.ELP:")") "L#10":RVE:@(ZERO,ONE):
PRINT @(46,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):(" [":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:"]") "L#22":(" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":RVE:@(ZERO,ONE):
*
NEXT SEND.COMM.CN
*
*
END; * of ON.FILE
*
!
*
IF LOCK.COM.AIP THEN
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
IF COM.AIP$RETRY LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY
*
IF COM.AI.LOC GT ONE AND AI.DVC.NEXT.FOUND THEN
WF.DT = DATE(); WF.TM = TIME()
COM.AIP$COMM.DT = WF.DT; COM.AIP$COMM.TM = WF.TM
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
*
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
LOCK.COM.AIP = FALSE
*
END; * OF LOCKED
*
*
NEXT AI.DVC.NEXT.CN
***
**!
***
AI.DVC.NEXT.CN = ONE
SEND.COMM.CN = ONE
NUM.TRIES = NUM.TRIES + ONE
*
REPEAT
*
PRINT @(20,23):CLL:
LOCATE WF.C.FUNC IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
HANDLER.DONE = FALSE
IF COM.AI.ERR.DISP OR CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Not Done" "L#19":RVE:
END ELSE
HANDLER.DONE = TRUE
PORT.LOC = ONE
IF COM.AI.ERR.DISP OR CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Done" "L#19":RVE:
END
*
IF NOT(STAT) AND LOCK.STAT GT 900 THEN STAT = LOCK.STAT
IF STAT THEN
IF STAT GT AI.STATUS THEN AI.STATUS = STAT
TEXT<-ONE> = "Status ":STAT:" error in wait routine."
END
*
DT = DATE(); TM = TIME(); ELP = ZERO
*#*LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*#*UNTIL NOT(LOCK.STAT) OR ELP GT ELP.MAX DO REPEAT
IF NOT(LOCK.STAT) THEN LOCK.COM.AIP = TRUE
IF LOCK.STAT GT 900 AND NOT(STAT) THEN STAT = LOCK.STAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
IF COM.AIP$RETRY LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY
*
IF LOCK.COM.AIP THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
LOCK.COM.AIP = FALSE
END
*
IF NOT(AI.STATUS) THEN
IF COM.AIP$ERR<ONE,ONE,ONE> LT 299 THEN
AI.STATUS = COM.AIP$ERR<ONE,ONE,ONE>
IF AI.STATUS = ERR$NOT.SENT THEN AI.STATUS = FALSE
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
END
END
*
* IF NOT(SEND.STATUS) THEN
** IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> THEN
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> NE EMPTY THEN
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> LT 800 OR COM.AIP$INTFC.ERR<ONE,ONE,ONE> GT 899 THEN
SEND.STATUS = COM.AIP$INTFC.ERR<ONE,ONE,ONE>
IF SEND.STATUS = ERR$NOT.SENT THEN SEND.STATUS = FALSE
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
END
END
* END
*
IF LEN(TEXT) AND (SEND.STATUS OR AI.STATUS OR NOT(ERR.CLB)) THEN GOSUB ERROR
*
~AI.INCL.WRITE.LOG~
*CODE.SEGMENT: AI.INCL.WRITE.LOG
* USED BY: AI.SUBR.WRITE.LOG
*          AI.HANDLER
*          AI.TALKER
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
AIL.SEQ.ID = "AI.LOG*":AI.CODE
*
LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",AIL.SEQ.ID,LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT DO REPEAT
*
READ AIL.SEQ FROM COM.FILE,AIL.SEQ.ID ELSE AIL.SEQ = ZERO
*
AIL.SEQ = AIL.SEQ + ONE
IF AIL.SEQ GT 999 THEN AIL.SEQ = ONE
*
WRITE AIL.SEQ ON COM.FILE,AIL.SEQ.ID
*
CALL UNLOCK.ITEM(COM.FILE,"COM",AIL.SEQ.ID,LOCKS.FILE)
*
AIL.ID = "AI*":AI.CODE:"*":("0000":AIL.SEQ) "R#4":"*LOG"
* COM.AIP$WKO.ID = AIL.NEXT.ID
IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
COM.AIP$LOG.TRAN.AIL = AIL.SEQ
AIL.NEXT.ID = AIL.SEQ
END
MAT AIL = MAT COM.AIP
IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
AIL$COMM.SRCE = AI.SRCE
END
IF AIL$PORT EQ EMPTY THEN AIL$PORT = PORT
IF AIL$ACCT.ID EQ EMPTY THEN AIL$ACCT.ID = ACCT
IF AIL$COMM.SRCE EQ EMPTY THEN AIL$COMM.SRCE = AI.SRCE
INS COM.AIP.ID BEFORE AIL$LOG.PORT<ONE,ONE>
INS WHO BEFORE AIL$LOG.ACCT<ONE,ONE>
INS SYS.PROG BEFORE AIL$LOG.PROG<ONE,ONE>
INS AI.SRCE BEFORE AIL$LOG.SRCE<ONE,ONE>
INS LOG.REQUIRED BEFORE AIL$LOG.LOC<ONE,ONE>
*
COM.AIP$LOG.REQD = TRUE
*
MATWRITE AIL ON AIL.FILE,AIL.ID
*
~AI.INCL.INTFC.CHECK~
*CODE.SEGMENT: AI.INCL.INTFC.CHECK
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* * COM.AI.ERR.TEXT<-ONE> = "The AI Handler is ok."
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF ELP.MAX LT 60 THEN ELP.MAX = 60
ELP.MAX = 15
IF ERR.DISP.ONLY THEN STATUS.CYCLE = ERR.DISP.ONLY
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
*   8640 86200     8641 01000  CURR DT/TM
*   8640 86000     8640 86200  FUNC DT/TM
*   ---- -----     ---- -----
*      0   200        1 85200-
*                 86400
*                 85200-
*                  1200
*
AI.CHK.ERR = EMPTY; COM.AI.ON = FALSE; COM.AI.UP = FALSE
* LOCK.COM.AIP = FALSE; LOCK.COM.AI = FALSE
*
BEGIN CASE
*
CASE COM.AI$ON.OFF.STAT EQ AI.ON
COM.AI.ON = TRUE
!
*
IF COM.AI$MAX.PAUSE + 4 * COM.AI$STD.PAUSE LE COM.AI.RUN.ELP THEN
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, AI hung for ":OCONV(COM.AI.RUN.ELP,"MTS"):" hours!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT EQ AI.UP THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* *COM.AI.ON = FALSE
* END
COM.AI.UP = FALSE
END ELSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.UP = TRUE
AI.CHK.ERR<-ONE> = ZERO
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and UP."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 3
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 191
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END CASE
*
END
*
!
*
CASE COM.AI$ON.OFF.STAT EQ AI.OFF
COM.AI.ON = FALSE
COM.AI.UP = FALSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
AI.CHK.ERR<-ONE> = 102
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and UP!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
AI.CHK.ERR<-ONE> = TWO
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
AI.CHK.ERR<-ONE> = 192
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
*
CASE TRUE
AI.CHK.ERR<-ONE> = 181
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither ON nor OFF!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$ON.OFF.STAT NE AI.OFF THEN COM.AI.ERR.FUNC<-ONE> = AI.OFF ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
BEGIN CASE
*
CASE COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, No (":COM.AI.RUN.ELP:") Acknowledgment!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
!
*
CASE COM.AI$ON.OFF.STAT NE COM.AI$ON.OFF
COM.AI.ON.OFF.ELP = ((DT - COM.AI$ON.OFF.DT) * 86400) + (TM - COM.AI$ON.OFF.TM)
IF COM.AI.ON.OFF.ELP GT COM.AI$MAX.PAUSE + 3 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 111
* COM.AI.ERR.TEXT<-ONE> = "Failure logging ":COM.AI$ON.OFF:"! (":COM.AI.ON.OFF.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* COM.AI.ERR.FUNC<-ONE> = COM.AI$ON.OFF
END ELSE
AI.CHK.ERR<-ONE> = 11
* COM.AI.ERR.TEXT<-ONE> = "The AI is logging ":COM.AI$ON.OFF:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$UP.DN.STAT NE COM.AI$UP.DN
COM.AI.UP.DN.ELP = ((DT - COM.AI$UP.DN.DT) * 86400) + (TM - COM.AI$UP.DN.TM)
IF COM.AI.UP.DN.ELP GT COM.AI$MAX.PAUSE + 2 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 121
* COM.AI.ERR.TEXT<-ONE> = "Failure going ":COM.AI$UP.DN:"! (":COM.AI.UP.DN.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* * COM.AI.ERR.FUNC<-ONE> = COM.AI$UP.DN
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END ELSE
AI.CHK.ERR<-ONE> = 12
* COM.AI.ERR.TEXT<-ONE> = "The AI is going ":COM.AI$UP.DN:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
READV OFF.FLAG FROM COM.FILE,"AI.OFF.":PORT.KEY,ONE ELSE
READV OFF.FLAG FROM COM.FILE,"AI.OFF.ALL",ONE ELSE OFF.FLAG = FALSE
END
*
IF OFF.FLAG THEN
WRITE FALSE:AM:"Done ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS") ON COM.FILE,"AI.OFF.":PORT.KEY
AI.CHK.ERR<-ONE> = 131
* COM.AI.ERR.TEXT<-ONE> = "Interface Off Flag is set!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
** IF AI.CHK.ERR NE EMPTY THEN
** *
** TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
** *
** LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
** COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
** LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
** COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
** COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
** TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
** IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE
** COM.AI.ERR.FUNC<-ONE> = TMP
** END
** DEL AI.CHK.ERR<ONE>
** REPEAT
** *
** END; * of AI.CHK.ERR ne empty
*
!
*
*
*  IF NOT(LEN(COM.AI.ERR)) THEN
*
CHECK.FMT = "L#":CHECK.LEN
*
*
EXEC.IN = EMPTY; EXEC.OUT = EMPTY; EXEC.VERB = EMPTY
CHECK.DVC.NEXT.FOUND = FALSE; COM.ID = "###"
*
IF (FAST.DISPLAY EQ TWO OR PORTS.LIST.BUILD EQ 9) AND AI.SCAN THEN
*
PORTS.LIST = EMPTY
EXEC.VERB = 'SSELECT COM EQ "AI*]" BY COMM.DT BY COMM.TM'
*
IF COM.AI.ERR.DISP THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Selecting Active Ports" CHECK.FMT:RVE
END
*
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > COM.ID.LIST, //OUT. > EXEC.OUT
*
* REV ONLY
* PERFORM EXEC.VERB
*
END ELSE IF PORTS.LIST.BUILD EQ 8 THEN
*
COM.ID.LIST = PORT.KEY
CHECK.DVC.NEXT.FOUND = TRUE; CHECK.DVC.NEXT.CN = ZERO
*
END ELSE
*
COM.ID.LIST = COM.AI$FUNC.PORT
CHECK.DVC.NEXT.FOUND = TRUE; CHECK.DVC.NEXT.CN = ZERO
IF COM.ID.LIST EQ EMPTY THEN COM.ID.LIST = PORTS.LIST
IF COM.ID.LIST EQ EMPTY THEN COM.ID.LIST = PORT.KEY
*
END; * of ports list build
*
IF COM.AI.ERR.DISP THEN
*
CHECK.LN = CHECK.LN.MIN
*
IF (PORTS.LIST.BUILD) AND AI.SCAN THEN
PRINT STR(".",CHECK.LEN) CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT EXEC.VERB CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF LEN(EXEC.OUT) THEN
IF NOT(FAST.DISPLAY) THEN
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE> CHECK.FMT; CHECK.LN = CHECK.LN + ONE
DEL EXEC.OUT<ONE>
REPEAT
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
END ELSE EXEC.OUT = EMPTY
END
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END; * of ports list build
*
IF NOT(FAST.DISPLAY) THEN
IF CHECK.LN.HI GT CHECK.LN THEN
IF CHECK.LN.HI GT CHECK.LN.MAX THEN CHECK.LN.HI = CHECK.LN.MAX
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT
NEXT TMP
END
END
*
CHECK.LN.HI = CHECK.LN; CHECK.LN = CHECK.LN.MIN
*
* EXECUTE "SLEEP 1"
*
END; * OF COM.AI.ERR.DISP
*
*
COM.AI.PORT.REC = EMPTY
COM.AIP.PORT.FIRST = TRUE; PORT.CONT = TRUE
* PORTS.LIST = EMPTY
CHECK.DVC.NEXT.FOUND = FALSE; COM.ID = "###"
*
LOOP
*
IF (FAST.DISPLAY EQ TWO OR PORTS.LIST.BUILD) AND AI.SCAN THEN
*
COM.ID = EMPTY
* ULT ONLY
READNEXT COM.ID FROM COM.ID.LIST ELSE COM.ID = "@@@"
*
* REV ONLY
* READNEXT COM.ID ELSE COM.ID = "@@@"
*
* COM.AIP.ID = COM.ID
COM.AIP.PORT = FIELD(COM.ID,"*",3)
*
*
END ELSE
*
IF NOT(COM.AIP.PORT.FIRST) AND COM.ID.LIST EQ EMPTY AND COM.ID EQ "###" THEN COM.ID = "@@@" ELSE
IF COM.ID NE "###" THEN
CHECK.DVC.NEXT.CN = CHECK.DVC.NEXT.CN + ONE
END ELSE
* COM.AIP.ID = COM.ID
COM.AIP.PORT = COM.ID.LIST<ONE,ONE>
DEL COM.ID.LIST<ONE,ONE>
CHECK.DVC.NEXT.CN = ONE
CHECK.DVC.NEXT.FOUND = TRUE
END
COM.ID = "AI*":AI.CODE:"*":COM.AIP.PORT:"*":CHECK.DVC.NEXT.CN
* COM.AIP.ID = COM.ID
*LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
*PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
*IF COM.AI.ERR.DISP THEN PRINT BELL:
*END
END
*
END; * of ports list build
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
IF COM.AI.ERR.DISP THEN PRINT BELL:
END
*
IF COM.AIP.PORT.FIRST THEN
CHECK.LN = CHECK.LN.MAX
COM.AIP.PORT.FIRST = FALSE
END
*
**
*WHILE COM.ID NE "@@@" DO
**
IF COM.ID NE "@@@" THEN
** ** ** IF COM.ID MATCHES '"AI*"3N"*"3N' THEN
IF FIELD(COM.ID,"*",ONE) EQ "AI" AND FIELD(COM.ID,"*",TWO) EQ AI.CODE AND NUM(FIELD(COM.ID,"*",3)) THEN
*
IF AI.SCAN THEN
DT = DATE(); TM = TIME(); ELP = ZERO
IF CNT.TST$ID THEN PRINT @(50,20):("Lock Cnt Aip ":COM.ID) "L#28":
LOOP
LOCK.STAT = LOCK.TYPE; CALL LOCK.ITEM(COM.FILE,"COM",COM.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
UNTIL NOT(LOCK.STAT) OR ELP GT ELP.MAX DO REPEAT
IF NOT(LOCK.STAT) THEN LOCK.COM.AIP = TRUE
* LOCK.COM.AIP = TRUE
* END ELSE LOCK.COM.AIP = FALSE
END
* END ELSE LOCK.COM.AIP = FALSE
END
END; * of not @@@
*
*
IF COM.ID NE "@@@" THEN
IF CNT.TST$ID THEN PRINT @(50,20):("Read Cnt Aip ":COM.ID) "L#28":
MATREAD COM.AIP FROM COM.FILE,COM.ID THEN
*
COM.AIP.ON.FILE = TRUE
CHECK.DVC.NEXT.FOUND = TRUE
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
* READ COM.AI.COMMANDS FROM COM.FILE,"AI.COMMANDS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE COM.AI.COMMANDS = EMPTY
*
IF CNT.TST$ID THEN PRINT @(50,20):("Anal Cnt Aip ":COM.ID) "L#28":
*
*@@@ LOOP FOR MULTI COMMANDS
*
LP0.FLG = ""; LP1.FLG = ""; SEND.COMM.CN.TMP.MAX = DCOUNT(COM.AIP$COMM<ONE>,VM)
*
*@@*FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL CHECK.LN GE CHECK.LN.MAX OR SYSTEM(11) GE 3
FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL SYSTEM(11) GE 3
*
*
IF CNT.TST$ID THEN PRINT @(50,20):("Loop Cnt Aip ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*@@@ BUILD PORT RECORD
*
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
LP0.FLG = FALSE
IF (PORTS.LIST.BUILD OR FIELD(COM.ID,"*",3) EQ PORT) AND COM.AI.ERR.DISP THEN LP0.FLG = TRUE
IF (FAST.DISPLAY OR PORTS.LIST.BUILD OR COM.AI.ERR.DISP) AND AI.SCAN THEN
LP0.FLG = TRUE
END
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE)) THEN LP0.FLG = TRUE
IF ((COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND COM.AIP.ELP LT 300) THEN LP0.FLG = TRUE
*
IF CNT.TST$ID THEN PRINT @(50,20):("Chck Cnt Aip (":LP0.FLG:") ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*
IF LP0.FLG THEN
**IF CNT.TST$ID THEN PRINT @(50,20):("Disp Cnt Aip ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*
IF PORT.CONT THEN
*
IF COM.AI.ERR.DISP THEN
*
IF COM.AIP.PORT.FIRST OR CHECK.LN GE CHECK.LN.MAX THEN
COM.AIP.PORT.FIRST = FALSE
IF SYSTEM(11) LT 3 THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Opr Po n Device Comm. Stat AIt Dvc. Fnc .Elp." CHECK.FMT:RVE:
END
END
*
*
IF CHECK.LN GE CHECK.LN.MAX THEN
CHECK.LN = CHECK.LN.MIN
IF STATUS.CYCLE THEN
IF SYSTEM(11) LT 3 THEN
EXECUTE "SLEEP 3"
END
RSP = "Y"
END ELSE
LOOP
PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(ZERO,23):" " CHECK.FMT:
IF RSP EQ EMPTY THEN PORT.CONT = FALSE ELSE ALREADY.DISPLAYED = TRUE
END; * OF STATUS CYCLE
END; * OF CHECK.LN GE CHECK.LN.MAX
*
END; * OF COM.AI.ERR.DISP
*
!
*
IF PORT.CONT THEN
*
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE MAT COM.AIIERR = EMPTY
END
*
*
**TMP1 = ""; VC.CN.MAX = DCOUNT(COM.AIP$COMM<ONE>,VM)
***
**FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL CHECK.LN GE CHECK.LN.MAX OR SYSTEM(11) GE 3
TMP1 = ""
*
*
IF COM.AI.ERR.DISP THEN
IF SYSTEM(11) LT 3 THEN
TMP1 = OCONV(COM.AIP.ELP,"MTS")
TMP = COM.AIP$OPER "L#3":" ":FIELD(COM.ID,"*",3) "R#2":" ":FIELD(COM.ID,"*",4):" ":COM.AIP$DVC.ID "L#6":" ":COM.AIP$COMM<ONE,SEND.COMM.CN.TMP,ONE> "L#5":" ":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> "L#4":" ":COM.AIP$INTFC.CODE "L#2":COM.AIP$INTFC.TYPE "L#1":" ":COM.AIP$DVC.TYPE "L#4":" ":COM.AIP$SVC.FUNC "L#3":" ":TMP1 "R#5"
PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
END
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
*
!
*
IF COM.AIP$INTFC.ERR<ONE> NE EMPTY THEN
***
**IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
**INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
**MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE MAT COM.AIIERR = EMPTY
**END
***
***
**TMP1 = ""; SEND.COMM.CN.TMP.MAX = DCOUNT(COM.AIP$INTFC.ERR<ONE>,VM)
***
**FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL CHECK.LN GE CHECK.LN.MAX OR SYSTEM(11) GE 3
*
SVC.CN = ZERO
*
LOOP
*
SVC.CN = SVC.CN + ONE
IF CNT.TST$ID THEN PRINT @(50,20):("Loop Cnt Aip ":COM.ID:"+":SEND.COMM.CN.TMP:"+":SVC.CN) "L#28":
TMP1 = COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN.TMP,SVC.CN>
* TMP1 = COM.AIP$ERR<ONE,SEND.COMM.CN.TMP,ONE>
*
*@*WHILE TMP1 NE EMPTY AND CHECK.LN LT CHECK.LN.MAX DO
WHILE TMP1 AND NOT(SYSTEM(11) GE 3) DO
*
LOCATE TMP1 IN COM.AIIERR$STD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
*
TMP = ("[":TMP1:"]") "R#5":" ":COM.AIIERR$DESC<ONE,ERR.LOC> "L#17":" (":COM.AIIERR$TYPE<ONE,ERR.LOC>:")"
* TMP = ("[":TMP1:"]") "R#5":" ":COM.AIP$COMM<ONE,SEND.COMM.CN.TMP> "L#5":" ":COM.AIIERR$DESC<ONE,ERR.LOC> "L#17":" (":COM.AIIERR$TYPE<ONE,ERR.LOC>:")"
*
* COM.AI.ERR<-ONE> = COM.AIIERR$STD<ONE,ERR.LOC>
COM.AI.ERR<-ONE> = TMP1
COM.AI.ERR.TEXT<-ONE> = "p":FIELD(COM.ID,"*",3):" c":COM.AIP$COMM<ONE,SEND.COMM.CN.TMP>:" ":COM.AIIERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIIERR$TYPE<ONE,ERR.LOC>
TMP4 = COM.AIIERR$FUNC<ONE,ERR.LOC>
IF TMP4 EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP4 EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP4
END
* DEL AI.CHK.ERR<ONE>
*
IF COM.AI.ERR.DISP THEN
IF SYSTEM(11) LT 3 THEN
PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
END
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
*
** for locate END ELSE NULL
*
REPEAT
*
**NEXT SEND.COMM.CN.TMP
*
END; * OF ERR NOT EMPTY
*
**NEXT SEND.COMM.CN.TMP
***
*
END; * OF PORT.CONT
*
END; * OF PORT.CONT AND ERR.DISP
*
*
**IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE)) THEN
**IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> NE EMPTY AND INDEX("*COMP*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE) THEN
LP1.FLG = FALSE
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*XCEL*RVRS*DONE*WAIT*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE)) THEN LP1.FLG = TRUE
IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND INDEX("*RVRS*DONE*WAIT*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE) THEN LP1.FLG = TRUE
**IF INDEX("*RVRS*DONE*WAIT*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE) THEN LP1.FLG = TRUE
*
IF LP1.FLG THEN
*
IF CNT.TST$ID THEN PRINT @(50,20):("Chck Cnt Aip (":LP9.FLG:") ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*
DT = DATE(); TM = TIME(); ELP = ZERO
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
*
IF COM.AIP.ELP GT 5 * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
*
IF AI.SCAN THEN
*
LOCK.STAT = LOCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LOCKS.FILE,LOCK.STAT)
*
IF NOT(LOCK.STAT) THEN
*
* AI.CHK.ERR<-ONE> = 371
* COM.AI.ERR<-ONE> = 371
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "DONE"
FOR TMP = ONE TO SEND.COMM.CN.TMP.MAX 
IF COM.AIP$INTFC.STAT<ONE,TMP,ONE> EQ "DONE" THEN
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
END
NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "WAIT"
FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
COM.AIP$COMM.PORT<ONE,TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "RVRS"
* FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
* INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
*INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
* COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
* COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"
* NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "COMP"
* FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
* Should never happen
* INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
* INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
* COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.PORT<ONE,TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
* NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "XCEL"
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE TRUE
FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
COM.AIP$COMM.PORT<ONE,TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
NEXT TMP
*
END CASE
*
IF COM.AIP.PORT EQ PORT THEN
TMP0 = 201
TMP1 = 801
END ELSE
TMP0 = 371
TMP1 = 800
END
*
IF LEN(AI.CHK.ERR) THEN
AI.CHK.ERR = TMP0:AM:AI.CHK.ERR
END ELSE AI.CHK.ERR = TMP0
*
* COM.AI.ERR.TEXT<-ONE> = "Failure at (@COM.AIP.ELP@) Port @COM.AIP.PORT@ @COM.AIP$INTFC.STAT@!"
*
* COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP,ONE> = EMPTY
* COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
**COM.AIP$ERR = TMP1:SVM:COM.AIP$ERR
**COM.AIP$INTFC.ERR = TMP0:SVM:COM.AIP$INTFC.ERR
INS TMP1 BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN.TMP,ONE>
INS TMP0 BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN.TMP,ONE>
*
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.ID,AI.CODE,AI.SRCE,11001,SYS.PROG,HANDLER.COMMAND,LOCKS.FILE,LOCK.TYPE)
*
IF LOCK.COM.AIP THEN
MATWRITE COM.AIP ON COM.FILE,COM.ID
END
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LOCKS.FILE)
*
END; * OF LOCK.STAT
*
END ; * OF AI.SCAN
*
END; * OF ELP
*
END ELSE IF COM.AIP.ELP GT 7200 AND (COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "COMP" OR COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "XCEL") THEN
*
IF LOCK.COM.AIP AND AI.SCAN THEN
IF CNT.TST$ID THEN PRINT @(50,20):("Delete Aip ":COM.ID) "L#28":
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.ID,AI.CODE,AI.SRCE,11002,SYS.PROG,HANDLER.COMMAND,LOCKS.FILE,LOCK.TYPE)
DELETE COM.FILE,COM.ID
END
*
END; * OF NO C.DT OR C.TM
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST<ONE> SETTING TMP ELSE
PORTS.LIST<ONE,-ONE> = COM.AIP.PORT
END
*
END; * OF NO C.DT OR C.TM
*
*
NEXT SEND.COMM.CN.TMP
*
!
*
*
END ELSE
CHECK.DVC.NEXT.FOUND = FALSE; * COM.ID = "###"
* NOT ON FILE
COM.AIP.ON.FILE = FALSE
MAT COM.AIP = EMPTY
END
END; * of not @@@
*
** ** ** IF AI.SCAN AND NOT(LOCK.STAT) THEN
* * * IF AI.SCAN AND NOT(LOCK.COM.AIP) THEN
IF LOCK.COM.AIP THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.ID,LOCKS.FILE)
LOCK.COM.AIP = FALSE
END
*
IF NOT(CHECK.DVC.NEXT.FOUND) AND COM.ID NE "@@@" THEN COM.ID = "###"
*
** ** ** END; * OF MATCHES AI*XX*999
*
*REPEAT
WHILE COM.ID NE "@@@" AND SYSTEM(11) LT 3 DO REPEAT
*
IF COM.AI.ERR.DISP THEN
** IF CHECK.LN.HI GT CHECK.LN THEN
** IF NOT(FAST.DISPLAY) THEN
** FOR TMP = CHECK.LN TO CHECK.LN.HI
** PRINT @(ZERO,TMP):" " CHECK.FMT:
** NEXT TMP
** CHECK.LN.HI = CHECK.LN
** END
** END
IF CHECK.LN LE CHECK.LN.MAX THEN PRINT @(ZERO,CHECK.LN):RVB:STR("-",CHECK.LEN) CHECK.FMT:RVE:
END
*
*  END; * OF NOT(COM.AI.ERR)
*
PORTS.LIST.BUILD = FALSE
*
*
*** $INCLUDE IBP AI.HERROR.XREF
*CODE.SEGMENT: AI.HERROR.XREF
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
* COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP
END
DEL AI.CHK.ERR<ONE>
REPEAT
*
END; * of AI.CHK.ERR ne empty
*
!
*
IF COM.AI.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(COM.AI.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
*
LOCATE COM.AI.ERR<TMP.CN> IN COM.AIHERR$STD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
* COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
*
*
* TMP2 = COM.AIHERR$DESC<ONE,ERR.LOC>
*
TMP2 = COM.AI.ERR.TEXT<TMP.CN>
*
LOOP WHILE INDEX(TMP2,"@",ONE) DO
TMP = FIELD(TMP2,"@",ONE)
TMP0 = FIELD(TMP2,"@",TWO)
TMP1 = FIELD(TMP2,"@",3)
TMP1 = TMP2[COL1()+ONE,9999]
TMP.VAR = EMPTY
BEGIN CASE
CASE TMP0 EQ "COM.AI.RUN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
* 999.9 Hours
CASE TMP0 EQ "COM.AI$ON.OFF"
TMP.VAR = COM.AI$ON.OFF
CASE TMP0 EQ "COM.AI.ON.OFF.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AI$UP.DN"
TMP.VAR = COM.AI$UP.DN
CASE TMP0 EQ "COM.AI.UP.DN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.PORT"
TMP.VAR = COM.AIP.PORT
CASE TMP0 EQ "COM.AIP$INTFC.STAT"
TMP.VAR = COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>
CASE TMP0 EQ "COM.AIP$ERR"
TMP.VAR = COM.AIP$ERR<ONE,ONE,ONE>
CASE TMP0 EQ "AI.STATUS"
TMP.VAR = AI.STATUS
CASE TMP0 EQ "SEND.STATUS"
TMP.VAR = SEND.STATUS
END CASE
TMP2 = TMP:TMP.VAR:TMP1
REPEAT
*
COM.AI.ERR.TEXT<TMP.CN> = TMP2
*
* COM.AI.ERR.TYPE<TMP.CN> = COM.AIHERR$TYPE<ONE,ERR.LOC>
* TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
TMP = COM.AI.ERR.TYPE<TMP.CN>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE
* COM.AI.ERR.FUNC<TMP.CN> = TMP
COM.AI.ERR.FUNC<TMP.CN> = COM.AIHERR$FUNC<ONE,ERR.LOC>
END
*
* DEL AI.CHK.ERR<ONE>
*
REPEAT
*
END
*
*
*** @@@
~AI.INCL.WRITE.XPV~
*CODE.SEGMENT: AI.INCL.WRITE.XPV
* NODATA.CTR = ZERO; NOCALL.CTR = ZERO; OTHER.CTR = ZERO; OKCOLL.CTR = ZERO; UPLOADED.CTR = ZERO
* EMPEV.CTR = ZERO; DUMP.CTR = ZERO
* PREV.DVC.ID = EMPTY; TMP.ID = EMPTY
* AI.STATUS = ZERO; SEND.STATUS = ZERO; COLL.STATUS = ZERO
* VALID.CTR = ZERO; EVENT.CTR = ZERO
* ERROR.CTR = ZERO; ERROR.EVENT.CTR = ZERO
* COMM.CTR = ZERO
* OVER = EMPTY; OVER.SKIP = EMPTY
* AI.COS = EMPTY
*
*
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*
IF COM.AIP$END.OF.UPLOAD NE "z" THEN
*
MAT XPV = ""
* not last terminal
*
EVENT.NUMS =     COM.AIP$EVENT
EVENT.DUR =      COM.AIP$EVENT.DUR
DVC.ID =         COM.AIP$DVC.ID
COLL.STATUS =    COM.AIP$GROUP.RSLT
*9503*DGH** IF EVENT.NUMS = "" THEN COLL.STATUS = "0D"
*
* validate the terminal id
*
MATREAD AIX FROM AIX.FILE,DVC.ID THEN INVALID.DVC = 0 ELSE INVALID.DVC =1; MAT AIX = ""
IF COUNT(AIX$ACT.ID,VM) THEN TMP.ID = "MULT" ELSE TMP.ID = AIX$ACT.ID
* prepare next terminal id'
NEXT.DVC.ID = "XXXXXX"
*
*@@@**** MOVE ABOVE READ
IF DVC.ID EQ PREV.DVC.ID THEN
DUPE.CTR = DUPE.CTR + 1
END ELSE
*
PREV.DVC.ID = DVC.ID
*
IF INVALID.DVC THEN
*
* Unknown Device Serial Number
*
XPV$ACT.ID = "000000"
XPV$ACC=     ""
XPV$ERROR = 1
*
END ELSE
*
*
* Validate Company
*
CO.PREFIX =  TMP.ID[1,1]
LOCATE CO.PREFIX IN AI.COS<1> BY "AR" SETTING LOC THEN
*
* Good Company
*
XPV$ACC = AI.COS<2,LOC>
*
END ELSE
*
* Bad Company Number
*
XPV$ACC = ""
XPV$ERROR = 2
*
END; * of locate
END; * of valid dvc
*
*950322*DGH*IF COLL.STATUS EQ "00" OR XPV$EVENT.NUMS NE "" THEN   *v
IF EVENT.NUMS NE "" THEN
*
IF COLL.STATUS NE "00" THEN ERREV.CTR = ERREV.CTR + 1
*950322*DGH*^
*
IF XPV$ERROR THEN
ERROR.CTR = ERROR.CTR + 1
ERROR.EVENT.CTR = ERROR.EVENT.CTR+(COUNT(EVENT.NUMS,VM)+1)
END ELSE
VALID.CTR = VALID.CTR + 1
EVENT.CTR = EVENT.CTR+(COUNT(EVENT.NUMS,VM)+1)
END
*
TRANS.NUM = COM.AIP$TRAN.SEQ
*
XPV.ID = DATE():"*":TRANS.NUM:"*":DVC.ID
XPV$AI.CODE =    AI.CODE
XPV$EVENT.NUMS = EVENT.NUMS
XPV$DUR    =     EVENT.DUR
XPV$ACCOUNT    = TMP.ID
XPV$GROUP      = GROUP
XPV(10)        = TIME()
*
MATWRITE XPV ON XPV.FILE,XPV.ID
*
*
END ELSE
EMPEV.CTR = EMPEV.CTR + 1
*950322*DGH*END ELSE   *v
END; * OF EVENT NUMS PRESENT
*
IF COLL.STATUS NE "00" THEN
*950322*DGH*^
*
*950322*DGH*IF COLL.STATUS = "0E" AND EVENT.NUMS = "" THEN NOCALL.CTR = NOCALL.CTR + 1   *v
*950322*DGH*IF COLL.STATUS = "0D" THEN NODATA.CTR = NODATA.CTR + 1
IF COLL.STATUS = "0E" THEN NOCALL.CTR = NOCALL.CTR + 1 ELSE
IF COLL.STATUS = "0D" THEN NODATA.CTR = NODATA.CTR + 1 ELSE
OTHER.CTR = OTHER.CTR + 1
END
END
*950322*DGH*^
*
END ELSE
OKCOLL.CTR = OKCOLL.CTR + 1
END; * of collection status not "00"
*
UPLOADED.CTR =   UPLOADED.CTR + 1
*
END; * of duplicate device
*
!
*
*950106*END ELSE OVER = TRUE; * Last terminal has been received
END ELSE
*
IF UPLOADED.CTR GT ZERO OR OVER.SKIP GT 2 THEN
OVER = TRUE
PRINT CLB:"Finished.":BELL:
END ELSE
OVER.SKIP = OVER.SKIP + ONE
PRINT CLB:"POC says we are finished.  Double checking.":BELL:
END
*
COMM.CTR = COMM.CTR + 1
*
END; * Last terminal has been received
*
*
END ELSE
PRINT CLB:"Trans error (":AI.STATUS:",":SEND.STATUS:")!!!":BELL:
COMM.CTR = COMM.CTR + 1
END; * of transmission error
~AI.INCL.RELS.XPV~
*CODE.SEGMENT: CASH.INCL.RELS.XPV
*
*
IF LOCK.ITM THEN
CALL UNLOCK.ITEM(LOCKS.FILE,"CNT","XPV.CTL",LOCKS.FILE)
END
*
*
~AI.INCL.LOCK.XPV~
*CODE.SEGMENT: AI.INCL.LOCK.XPV
*
*
IF LOCK.ITM THEN
LOCK.DT = DATE(); LOCK.TM = TIME()
LOOP
IF NOT(STAT) THEN
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(XPV.FILE,"CNT","XPV.CTL",LOCKS.FILE,LOCK.STAT)
IF LOCK.STAT THEN
EXECUTE "SLEEP 5"
IF LOCK.STAT GT 900 THEN STAT = 999
END
END
WHILE NOT(STAT) AND LOCK.STAT DO
DT = DATE(); TM = TIME()
IF ((DT - LOCK.DT) * 86400) + (TM - LOCK.TM) GT 15 THEN
EXEC.VERB = "BLOCK-PRINT CASH IN ":ACCT:" XPV LOCKED AT ":LOCK.STAT:" (P)"
STAT = 999
END
REPEAT
END
*
*
~AI.INCL.TALKER.INIT~
*CODE.SEGMENT: AI.INCL.TALKER.INIT
*
*
AUTO.RUN = FALSE; DISP.ONLY = FALSE; MSG.DISP = FALSE
LOCK.ELP = ZERO; LOCK.ELP.MAX = 60
LOCK.TYPE = -8; LOCK.ITM = TRUE; LOCK.RELS = FALSE; LOCK.STAT = FALSE
*
****COM.AI.ERR.DISP = TWO
COM.AI.ERR.DISP = ZERO
FUNC.CHNG = EMPTY; AIL.NEXT.ID = AIL.ID
*
ERR.LN.MIN = TWO; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CL = 43; ERR.LN = ERR.LN.MIN; ERR.LEN = 36; ERR.CLB = FALSE
ERR.DISP.ONLY = 3; ERR.HDR = "Interface Messages"
*
CHECK.LN.MIN = 13; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
CHECK.LEN = 48; CHECK.LN.HI = ZERO
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
CHAN.ALL = FALSE
OPER = ""; HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
EQUIP.TYPE = ""
*
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "T"; LOG.REQUIRED = FALSE
SEND.STATUS = FALSE
OFF.FLAG = FALSE
CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
!
*
GOSUB LOAD.TST
*
*
FAST.DISPLAY = FALSE; PORTS.LIST.BUILD = ZERO; AI.SCAN = TRUE
AI.SCAN = FALSE; ************
IF AI.TALK<OP.MULTI> THEN SINGLE = 0 ELSE SINGLE = 1
*
*
IF CNT.TST$RTN THEN PRINT CLB:"Entering AI.TALKER for ":AI.ACTN:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
LOCK.ITM = FALSE; LOCK.RELS = FALSE
GOSUB READ.COM.AI
IF COM.AI.NOT.ON.FILE THEN RETURN
*
*
IF NOT(AI.TALK<INTERFACE.MSG>) THEN AI.ACTN = FN$CHECK.INTFC:AM:AI.ACTN
*
IF NOT(AI.TALK<DISPATCHER.MSG>) THEN AI.ACTN = FN$CHECK.DISPATCHER:AM:AI.ACTN
*
IF AIX.ID NE EMPTY OR (AI.TALK<AI.DVC.NEXT> AND AI.TALK<AI.DVC.IDS> NE EMPTY) THEN DVC.ON.FILE = TRUE ELSE DVC.ON.FILE = FALSE
*
!
*
~AI.INTFC.DISPLAY~
*CODE.SEGMENT: AI.INTFC.DISPLAY
* VERSION: 940201 1.1  HEADEND TO AI.CODE, COM.AI$PORT TO COM.AI$COMMPORT.
* USED BY: AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS
*   1990        ALL RIGHTS RESERVED
*
!
*
GOSUB DISPLAY.TITLE
*
PRINT @(ZERO,3):CLL:RVB:"   Handler Status":RVE:" ":
IF COM.AI$ON.OFF.STAT NE "ON" THEN PRINT "OFF": ELSE PRINT "ON":
IF COM.AI$UP.DN.STAT NE "UP"  THEN PRINT " DOWN": ELSE PRINT " UP":
*
*
** 23APR94 ** OPER.LN = 3; OPER.CL = 31; OPER.DESC.LN = 3; OPER.DESC.CL = 49
** 23APR94 ** OPER.DESC.FMT = "L#15"; OPER.STAT = EMPTY; OPER.DISP = TRUE
** 23APR94 ** OPER.RVB = TRUE; OPER.TEXT = "Operator: "
** 23APR94 ** OPER.POSN = EMPTY
** 23APR94 ** LN = 9
OPER.DISP = TRUE
CALL INPUT.OPERATOR(OPER,OPER.POSN,OPER.LN,OPER.CL,OPER.TEXT,OPER.DESC.LN,OPER.DESC.CL,OPER.DESC.FMT,OPER.RVB,RUN.TYPE,OPER.DISP,OPER.STAT)
** 23APR94 ** IF OPER.STAT THEN CHAIN "FREEZE.PORT"
*
!
*
PRINT @(ZERO,4):CLL:RVB:"        Test Flag":RVE:" ":COM.AI$TEST.MODE:
PRINT @(31,4):RVB:"Handler Logging and Error Messages" "L#48":RVE:
*
PRINT @(ZERO,5):CLL:RVB:"  Command Logging":RVE:" ":
IF COM.AI$LOGGING EQ "Y" THEN PRINT "ON": ELSE PRINT "OFF":
*
PRINT @(ZERO,6):CLL:RVB:"      Port Number":RVE:" ":COM.AI$COMMPORT
*
!
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK
*
IF PORTS.LIST NE PORTS.LIST.PREV THEN
*COM.AI$FUNC.PORT<ONE,-ONE> = PORTS.LIST
PORTS.LIST.PREV = PORTS.LIST
END
*
!
*
IF LEN(COM.AI.ERR.TEXT) THEN
PRINT @(ZERO,7):CLL:RVB:COM.AI.ERR.TEXT<ONE> "L#30":RVE:
END
IF ERR.BELL AND LEN(COM.AI.ERR) AND (COM.AI.ERR.FUNC<ONE> NE OLD.FUNC<ONE> AND COM.AI.ERR.FUNC NE EMPTY) THEN PRINT BELL:; RQM
*
PRINT @(35,10):RVB:" He*Ch# Srvc. Description...... Last.Change... ST       " "L#48":RVE:
LN = 10; VC = ONE
*
LOOP
*
MLE.NUM = STL<STATUS.CHANNEL,VC>
MLE.HE = FIELD(MLE.NUM,"*",ONE)
IF MLE.HE NE HEADEND THEN
HEADEND = MLE.HE
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE NULL
END
*
UNTIL MLE.NUM EQ EMPTY DO
*
REASON = STL<STATUS.CHAN.STAT,VC>
*
IF LEN(REASON) OR CHAN.ALL THEN
*
LN = LN + ONE
*
IF LN GT 20 THEN
PRINT @(ZERO,LN):CLL:
IF STATUS.CYCLE THEN
LN = 11
RQM; RQM
END ELSE
LOOP
PRINT @(35,23):CLL: "Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(35,23):CLL:
IF RSP EQ EMPTY THEN RETURN ELSE LN = 11; ALREADY.DISPLAYED = TRUE
END
END; * of pg
*
* SDATE = OCONV(FIELD(STL<STATUS.DESC,VC>,"*",ONE),"D2")
* STIME = OCONV(FIELD(STL<STATUS.DESC,VC>,"*",TWO),"MT")
SDESC = STL<STATUS.DESC,VC>
RDATE = OCONV(FIELD(STL<STATUS.CHECKED,VC>,"*",ONE),"D2")
*TMP = INDEX(RDATE," ",TWO)
*IF TMP THEN RDATE = RDATE[ONE,TMP - ONE]
RDATE = FIELD(RDATE," ",ONE):FIELD(RDATE," ",TWO)
RTIME = OCONV(FIELD(STL<STATUS.CHECKED,VC>,"*",TWO),"MTH")
RDT = RDATE:" ":RTIME
SSRVC = STL<STATUS.SRVC,VC>
*
IF LEN(REASON) THEN
PRINT @(35,LN):(" ":MLE.NUM "L#6":" ":SSRVC "L#5":" ":SDESC "L#17":" ":RDT "L#11":" ":REASON "L#2") "L#44":
LOCATE REASON IN AI.ERRORS<ONE> BY "AR" SETTING LOC THEN
REASON = AI.ERRORS<3,LOC>
LN = LN + ONE
PRINT @(35,LN):CLL:RVB:(SPACE(12):REASON) "L#44":RVE:
END
END ELSE
PRINT @(35,LN):(" ":MLE.NUM "L#6":" ":SSRVC "L#5":" ":SDESC "L#17":" ":RDT "L#11":" ":REASON "L#2") "L#44":
END; * of reason
*
END; * of reason or all flag
*
VC = VC + ONE
*
REPEAT
*
IF ALREADY.DISPLAYED THEN
LOOP
LN = LN + ONE
UNTIL LN GT 22 DO
PRINT @(35,LN):CLL:
REPEAT
ALREADY.DISPLAYED = EMPTY
END
*
*
~AI.INTFC.MESSAGES~
*CODE.SEGMENT: AI.INTFC.MESSAGES
* USED BY: AI.CONTROL.UTILITY
*          AI.TALKER
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
!
*
IF LEN(COM.AI.ERR.TEXT) THEN
*
COM.AI.ERR.CN.MAX = DCOUNT(COM.AI.ERR,AM)
COM.AI.ERR.CN = ONE; TMP = FALSE
LOOP WHILE COM.AI.ERR.CN LE COM.AI.ERR.CN.MAX DO
TMP = COM.AI.ERR<COM.AI.ERR.CN>
IF NUM(TMP) THEN
IF TMP THEN
TEXT<-ONE> = "[":COM.AI.ERR.TYPE<COM.AI.ERR.CN>:" ":("000":TMP) "R#3":"] ":COM.AI.ERR.TEXT<COM.AI.ERR.CN>
IF (TMP NE 71 AND TMP GT AI.STATUS) AND TMP LT 300 THEN AI.STATUS = TMP
IF TMP NE 71 AND TMP GT SEND.STATUS THEN SEND.STATUS = TMP
END
END ELSE TMP = TRUE
IF NOT(TMP) THEN TEXT<-ONE> = COM.AI.ERR.TEXT<COM.AI.ERR.CN>
* DEL COM.AI.ERR<ONE>
* DEL COM.AI.ERR.TEXT<ONE>
COM.AI.ERR.CN = COM.AI.ERR.CN + ONE
REPEAT
*
END
*
~AI.INTFC.READ~
*CODE.SEGMENT: AI.INTFC.READ
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
READ.COM.AI: *
*
COM.ID = "AI.TYPE.":AI.CODE
COM.AI.ID = COM.ID
STAT = FALSE
*
IF LOCK.ITM THEN
LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.ID,LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT DO REPEAT
IF LOCK.STAT THEN STAT = LOCK.STAT; RETURN
LOCK.COM.AI = TRUE
END ELSE LOCK.STAT = FALSE
*
MATREAD COM.AI FROM COM.FILE,COM.ID THEN COM.ID.ON.FILE = TRUE ELSE COM.ID.ON.FILE = FALSE; STAT = 998; MAT COM.AI = ""; GOTO READ.COM.AI.UNLOCK
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = AI.CODE
LOCATE AI.CODE IN AI.TYPES<ONE> SETTING AI.CODE.LOC ELSE AI.CODE.LOC = ONE
HEADENDS = AI.TYPES<4,AI.CODE.LOC>
*
HEADEND = HEADENDS<ONE,ONE,ONE>
HE.CN.MAX = DCOUNT(HEADENDS,SVM)
*
STL.ID = "AI.STATUS.CH.":AI.CODE
READ STL FROM COM.FILE,STL.ID ELSE STL = ""
*
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = ""
*
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE AI.ERRORS = ""
*
FOR HE.CN = ONE TO HE.CN.MAX
HEADEND = HEADENDS<ONE,ONE,HE.CN>
READ COMPONENTS FROM COM.FILE,"COMPONENTS.":HEADEND ELSE COMPONENTS = EMPTY
CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES)
STL<STATUS.FLAGGED> = ""; TMP = 1
MVC = 1
LOOP MLE.NUM = CHANNEL.MLES<1,MVC> UNTIL MLE.NUM EQ "" DO
TMP = HEADEND:"*":MLE.NUM
LOCATE TMP IN STL<STATUS.CHANNEL> BY "AR" SETTING LOC ELSE
INS TMP BEFORE STL<STATUS.CHANNEL,LOC>
INS "" BEFORE STL<STATUS.CHAN.STAT,LOC>
INS "" BEFORE STL<STATUS.DESC,LOC>
INS "" BEFORE STL<STATUS.CHECKED,LOC>
INS "" BEFORE STL<STATUS.SRVC,LOC>
INS "" BEFORE STL<STATUS.FLAGGED,LOC>
END
STL<STATUS.DESC,LOC> = CHANNEL.MLES<2,MVC>
STL<STATUS.SRVC,LOC> = CHANNEL.MLES<3,MVC>
STL<STATUS.FLAGGED,LOC> = 1; * ?????
MVC = MVC + 1
REPEAT
ST.VC = 1
LOOP UNTIL STL<STATUS.CHANNEL,ST.VC> EQ "" DO
IF STL<STATUS.FLAGGED,ST.VC> THEN ST.VC = ST.VC + 1 ELSE
DEL STL<STATUS.CHANNEL,ST.VC>
DEL STL<STATUS.CHAN.STAT,ST.VC>
DEL STL<STATUS.DESC,ST.VC>
DEL STL<STATUS.CHECKED,ST.VC>
DEL STL<STATUS.SRVC,ST.VC>
DEL STL<STATUS.FLAGGED,ST.VC>
END
REPEAT
DEL STL<STATUS.FLAGGED>
NEXT HE.CN
*
READ.COM.AI.UNLOCK: *
IF LOCK.RELS THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
*
~AI.INTFC.STL~
*CODE.SEGMENT: AI.INTFC.STL
* VERSION: 940130 1.1  Changed refs of 'COMMPORT' and 'HEADEND' to 'AI.CODE', HEADENDS now in AI.TYPES.
* DESCRIPTION: LOAD CHANNEL STATUSES FOR THE AI.TYPE.
* USED BY: AI.HANDLER
*          AI.CHANNEL.UP
*          AI.CHANNEL.DN
*          AI.CONTROL.UTILITY
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = AI.CODE
LOCATE AI.CODE IN AI.TYPES<1> SETTING COMMPORT.LOC ELSE COMMPORT.LOC = ONE
HEADENDS = AI.TYPES<4,COMMPORT.LOC>
CHANNEL.MLES = EMPTY; STL.ID = "AI.STATUS.CH.":AI.CODE
*
*22MAR94*IF COMPONENTS.DFLT EQ EMPTY THEN
READ COMPONENTS.DFLT FROM COM.FILE,"COMPONENTS" ELSE NULL
*22MAR94*END
*
HE.CN.MAX = DCOUNT(HEADENDS,SVM)
*
IF LOCK.ITM THEN
LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",STL.ID,LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT AND LOCK.STAT NE 999 DO REPEAT
END ELSE LOCK.STAT = FALSE
*
READ STL FROM COM.FILE,STL.ID ELSE STL = EMPTY
*
* READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE AI.ERRORS = EMPTY
*
STL<STATUS.FLAGGED> = EMPTY; TMP = ONE; WRITE.FLAG = FALSE
SAVE.HEADEND = HEADEND
*
FOR HE.CN = ONE TO HE.CN.MAX
*
**IF HEADENDS<ONE,ONE,HE.CN> NE HEADEND THEN
READ COMPONENTS FROM COM.FILE,"COMPONENTS.":HEADENDS<ONE,ONE,HE.CN> ELSE COMPONENTS = EMPTY
**END
*
HEADEND = HEADENDS<ONE,ONE,HE.CN>
*
CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES)
*
MVC = ONE
LOOP MLE.NUM = CHANNEL.MLES<ONE,MVC> UNTIL MLE.NUM EQ EMPTY DO
*
MLE.NUM = ("000":MLE.NUM) "R#3"; TMP = HEADEND:"*":MLE.NUM
LOCATE TMP IN STL<STATUS.CHANNEL> BY "AL" SETTING STL.LOC ELSE
INS TMP BEFORE STL<STATUS.CHANNEL,STL.LOC>
INS EMPTY BEFORE STL<STATUS.CHAN.STAT,STL.LOC>
INS CHANNEL.MLES<TWO,MVC> BEFORE STL<STATUS.DESC,STL.LOC>
INS EMPTY BEFORE STL<STATUS.CHECKED,STL.LOC>
INS CHANNEL.MLES<3,MVC> BEFORE STL<STATUS.SRVC,STL.LOC>
INS EMPTY BEFORE STL<STATUS.FLAGGED,STL.LOC>
WRITE.FLAG = TRUE
END
*
IF STL<STATUS.DESC,STL.LOC> EQ EMPTY THEN
LOCATE STL<STATUS.SRVC,STL.LOC> IN COMPONENTS.DFLT<ONE> SETTING TMP.LOC THEN
STL<STATUS.DESC,STL.LOC> = COMPONENTS.DFLT<TWO,TMP.LOC>
WRITE.FLAG = TRUE
END ELSE NULL
END
*
STL<STATUS.FLAGGED,STL.LOC> = ONE
MVC = MVC + ONE
*
REPEAT
*
NEXT HE.CN
*
HEADEND = SAVE.HEADEND
COMPONENTS = COMPONENTS.DFLT
*
!
*
ST.VC = ONE
*
LOOP UNTIL STL<STATUS.CHANNEL,ST.VC> EQ EMPTY DO
IF STL<STATUS.FLAGGED,ST.VC> THEN ST.VC = ST.VC + ONE ELSE
DEL STL<STATUS.CHANNEL,ST.VC>
DEL STL<STATUS.CHAN.STAT,ST.VC>
DEL STL<STATUS.DESC,ST.VC>
DEL STL<STATUS.CHECKED,ST.VC>
DEL STL<STATUS.SRVC,ST.VC>
DEL STL<STATUS.FLAGGED,ST.VC>
WRITE.FLAG = TRUE
END
REPEAT
*
DEL STL<STATUS.FLAGGED>
*
*
IF WRITE.FLAG AND LOCK.ITM AND NOT(LOCK.STAT) THEN
WRITE STL ON COM.FILE,STL.ID
END
*
IF LOCK.ITM AND LOCK.RELS THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",STL.ID,LOCKS.FILE)
END
*
*
~AI.LOAD.COM.AIP~
*CODE.SEGMENT: AI.LOAD.COM.AIP
* VERSION: 940221 1.1  NEXT.AI.TRAN CHANGED TO NEXT.AIL.TRAN
* PRIOR: 940219 1.1  ADDED TEST OF AI.TALK NE "", RE WKOs and DVCs.
* USED BY: AI.TALKER
*          DOWNLOAD.PPV.EVENTS.PA
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT AXION COMPUTER SYSTEMS LTD
*   1990       ALL RIGHTS RESERVED
*
!
*
COM.AIP.PORT = PORT.KEY
*
LOCATE COM.AIP.PORT IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
IF COM.AI$FUNC.PORT NE EMPTY THEN COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:COM.AIP.PORT
END
COM.AIP$RETRY         = EMPTY
COM.AIP$MAX.PAUSE     = EMPTY
*
!
*
* COM.AIP$SVC.ID      = DVC$SERVICE
* COM.AIP$TIERS       = DVC$TIERS
* COM.AIP$TSTAT       = DVC$TSTAT
COM.AIP$SVC.CHAN      = "?"
*
TMP = OPT.COMM<ONE,ONE>[ONE,TWO]
IF INDEX("#AI#PV#IV#","#":TMP:"#",ONE) THEN
*
COM.AIP$SVC.FUNC      = WOF
COM.AIP$DVC.TYPE      = DVC$TYPE
COM.AIP$GROUP         = DVC$INSTALLED.ADD.ID
COM.AIP$HEADEND       = HEADEND
COM.AIP$OPER          = WKO$OPERATOR
IF COM.AIP$OPER EQ EMPTY THEN COM.AIP$OPER = OPER
*
COM.AIP$ACCT.ID       = WKO$ACT.ID
COM.AIP$ADD.ID        = WKO$ADD.ID
COM.AIP$DVC.ID        = AIX.ID
*@*IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = AI.TALK<ADDRESSABLE>
IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>>
IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = DVC.ID
IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = DVC$SERIAL.NUM
COM.AIP$AIX.ID        = AIX.ID
COM.AIP$AIX.LOCATION  = ADD$AIX.LOCATION 
IF NOT(COM.AIP$AIX.LOCATION) THEN COM.AIP$AIX.LOCATION = ONE
*
COM.AIP$WKO.ID        = WKO.ID
* IF COM.AIP$WKO.ID EQ EMPTY THEN COM.AIP$WKO.ID = AIL.NEXT.ID 
COM.AIP$WKO.TYPE      = WKO$TYPE
COM.AIP$WKO.STAT      = WKO$STAT
COM.AIP$WKO.SCH.DT    = WKO$SCH.DATE
COM.AIP$WKO.SCH.TM    = WKO$SCH.TIME
COM.AIP$WKO.SCH.TYPE  = WKO$SCH.TYPE
COM.AIP$WKO.INST      = WKO$INSTALLER
COM.AIP$WKO.FUNC      = WOF
*
END ELSE
COM.AIP$SVC.FUNC       = "SYS"
COM.AIP$DVC.TYPE       = ""
COM.AIP$HEADEND        = "ALL"
COM.AIP$GROUP           = EMPTY
COM.AIP$OPER          = OPER
END; * of not AIDVC
*
* COM.AIP$INTFC.CODE  = COM.AI$DB.PREFIX
COM.AIP$INTFC.TYPE    = COM.AI$TYPE
COM.AIP$CTLR.PORT     = COM.AI$CTLR.PORT
*
*
COM.AIP$COMM          = OPT.COMM
TMP = DCOUNT(COM.AIP$COMM,VM)
*
* INS "WAIT" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
* INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
FOR SEND.COMM.CN.TMP = ONE TO TMP
INS "WAIT" BEFORE     COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP,ONE> = OPT.COMM<ONE,SEND.COMM.CN.TMP,ONE>
COM.AIP$COMM.CN<ONE,SEND.COMM.CN.TMP,ONE> = ZERO
NEXT SEND.COMM.CN.TMP
*
*
COM.AIP$COMM.DT       = OPT.DT
COM.AIP$COMM.TM       = OPT.TM
COM.AIP$COMM.C.DT     = EMPTY
COM.AIP$COMM.C.TM     = EMPTY
COM.AIP$COMM.PORT     = OPT.COMM<ONE,ONE>
COM.AIP$COMM.CN       = ZERO
COM.AIP$PORT          = PORT.KEY
*
COM.AIP$HEX.COMM      = EMPTY
COM.AIP$HEX.RSLT      = EMPTY
COM.AIP$COMM.RSLT     = EMPTY
COM.AIP$ERR           = EMPTY
COM.AIP$GROUP.RSLT    = EMPTY
*
* COM.AIP$LOG.DISPL     = FALSE
* COM.AIP$LOG.PRINT     = FALSE
* COM.AIP$LOG.ACK.DISP  = FALSE
* COM.AIP$LOG.ACK.BRMNGR = FALSE
COM.AIP$LOG.REQD      = LOG.REQUIRED
COM.AIP$LOG.SRCE      = AI.SRCE
COM.AIP$COMM.SRCE     = AI.SRCE
* COM.AIP$LOG.TRAN.AIL  = AIL.NEXT.ID
AIL.NEXT.ID = COM.AIP$LOG.TRAN.AIL
COM.AIP$TRAN.SEQ  = EMPTY; * This is set by AI.PARSE.OUTPUT
*
~AI.LOAD.COM.AIP.TIERS~
*CODE.SEGMENT: AI.LOAD.COM.AIP.TIERS
* USED BY: AI.TALKER
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT AXION COMPUTER SYSTEMS LTD.
*   1990       ALL RIGHTS RESERVED
*
*
* FILE 'COM.AIP' EQUATES
*
*  Note that this algorythm assumes that an omitted service will autom-
*     matically be turned off if not sent
*
*  Also note that (BASIC) is not properly provided for as a special case
*
*
!
*
SYS.LOC = "TIERS"; IF CNT.TST$LBL THEN PRINT @(60,20):"Load Device Tiers in AIPs" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
AIX.RESET = FALSE; IF WKO.ID EQ EMPTY THEN AIX.RESET = TRUE
MAT COM.AIP = EMPTY
*
*5APR94* IF OPT.COMM<ONE,ONE> EQ "AIDVC" THEN
LOCATE "AIDVC" IN OPT.COMM<ONE> SETTING TMP3 THEN
*
* Locate the device type to load # of addrs/unit & # of tiers/addr
LOCATE DVC$TYPE IN COM.AI$DVC.UNIT SETTING DVC.LOC ELSE DVC.LOC = ONE
*
AIX.LOC = ADD$AIX.LOCATION
IF NOT(AIX.LOC) THEN AIX.LOC = ONE
IF AI.TALK<ADDRESSABLE> NE EMPTY THEN AIX.LOC = ONE
*
COM.AIP$INTFC.CODE  = COM.AI$DB.PREFIX<ONE,DVC.LOC>
COM.AIP$SVC.ID.FUTR = EMPTY
*
* Set the current service levels on the port control record
IF AIX.ID NE EMPTY THEN
*
COM.AIP$SVC.ID      = DVC$TSVCS
COM.AIP$TIERS       = DVC$TIERS
COM.AIP$TSTAT       = DVC$TSTAT
*
END ELSE
*
COM.AIP$SVC.ID      = COM.AI$DF.SVCS.ONE<ONE,DVC.LOC>
COM.AIP$SVC.ID.FUTR = COM.AI$DF.SVCS.ONE<ONE,DVC.LOC>
COM.AIP$TIERS       = COM.AI$DF.TIER.ONE<ONE,DVC.LOC>
COM.AIP$TIERS.FUTR  = COM.AI$DF.TIER.ONE<ONE,DVC.LOC>
COM.AIP$TSTAT       = EMPTY
COM.AIP$TSTAT.FUTR  = EMPTY
*
SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID,SVM)
*
FOR SVC.CN = ONE TO SVC.CN.MAX
*
TMP = COM.AIP$SVC.ID<ONE,ONE,SVC.CN>
*
LOCATE TMP IN SAVE.ACT$SERVICES<ONE> SETTING SVC.VC THEN
IF SAVE.ACT$QNTYS<ONE,SVC.VC> GT 0 THEN
COM.AIP$TSTAT<ONE,ONE,SVC.CN> = "1"
END ELSE
COM.AIP$TSTAT<ONE,ONE,SVC.CN> = "0"
END
END ELSE
COM.AIP$TSTAT<ONE,ONE,SVC.CN> = "0"
SVC.VC = ZERO
END
*
* IF NOT(SVC.VC) OR (WOF EQ "D" AND WKO$STAT NE "X") THEN
IF (WKO$STAT NE "X" AND WKO$STAT NE "C") OR (WOF EQ "D" AND WKO$STAT NE "X") THEN
TMP1 = WKO$ACTIV.SERVICES
TMP2 = WKO$ACTIV.QNTYS
END ELSE
TMP1 = ACT$SERVICES
TMP2 = ACT$QNTYS
END
*
LOCATE TMP IN TMP1<ONE> SETTING FUTR.VC THEN
*
IF SVC.VC THEN
*
IF SAVE.ACT$QNTYS<ONE,SVC.VC> + TMP2<ONE,FUTR.VC> GT ZERO THEN
* IF TMP2<ONE,FUTR.VC> GT ZERO THEN
* IF ABS(TMP2<ONE,FUTR.VC>) NE 0 THEN
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "1"
END ELSE
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "0"
END
*
END ELSE
*
IF TMP2<ONE,FUTR.VC> GT ZERO THEN
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "1"
END ELSE
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "0"
END
*
END; * OF SVC.VC
*
* END ELSE COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "0"
END ELSE COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = COM.AIP$TSTAT<ONE,ONE,SVC.CN>
*
NEXT SVC.CN
*
END; * OF AI.TALK<ADDRESSABLE>
*
!
*
COM.AIP$TINDEX      = EMPTY
*
IF AIX.ID NE EMPTY THEN
*
ACT.SVC.CN.MAX = DCOUNT(ACT$SERVICES,VM)
WKO.SVC.CN.MAX = DCOUNT(WKO$ACTIV.SERVICES,VM)
*
* This loop happens # of addr/unit times (1 or 8)
*       note the # of Connected OUTlets is ignored on the AIP rec.
* Services are subvalued within this location
*   they are in alphabetical order.
FOR AIX.VC = ONE TO COM.AI$ADDR.PER.UNIT<ONE,DVC.LOC>
*
COM.AIP$SVC.ID.FUTR<ONE,AIX.VC> = DVC$TSVCS<ONE,AIX.VC>
COM.AIP$TIERS.FUTR<ONE,AIX.VC>  = DVC$TIERS<ONE,AIX.VC>
COM.AIP$TSTAT.FUTR<ONE,AIX.VC>  = DVC$TSTAT<ONE,AIX.VC>
*
IF AIX.VC EQ AIX.LOC THEN
*
AIX.SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID.FUTR<ONE,AIX.VC>,SVM)
*
FOR SVC.CN = ONE TO AIX.SVC.CN.MAX
IF WOF EQ "D" AND WKO$STAT NE "X" THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,SVC.CN> = ZERO
END ELSE
LOCATE COM.AIP$SVC.ID.FUTR<ONE,AIX.VC,SVC.CN> IN ACT$SERVICES<ONE> SETTING ACT.LOC THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,SVC.CN> = ONE
END ELSE
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,SVC.CN> = ZERO
END
END; * Of WKO is "D" & -"X"
NEXT SVC.CN
*
FOR SVC.CN = ONE TO WKO.SVC.CN.MAX
* The service from the act is located in cnt.aip and added if missing
*
*27MAR94*IF INDEX("#H#S#A#","#":WKO$ACTIVS<ONE,SVC.CN>:"#",ONE) THEN
IF WKO$ACTIVS<ONE,SVC.CN> EQ "S" THEN
*
*27MAR94*TMP = ACT$SERVICES<ONE,SVC.CN>
TMP = WKO$ACTIV.SERVICES<ONE,SVC.CN>
TMP1 = WKO$ACTIV.QNTYS<ONE,SVC.CN>
LOCATE TMP IN ACT$SERVICES<ONE> SETTING ACT.LOC THEN
TMP1 = TMP1 + ACT$QNTYS<ONE,ACT.LOC>
END
*
LOCATE TMP IN COM.AIP$SVC.ID.FUTR<ONE,AIX.VC> SETTING AIX.SC ELSE
INS TMP BEFORE COM.AIP$SVC.ID.FUTR<ONE,AIX.VC,AIX.SC>
INS "0" BEFORE COM.AIP$TIERS.FUTR<ONE,AIX.VC,AIX.SC>
INS "0" BEFORE COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC>
AIX.SVC.CN.MAX = AIX.SVC.CN.MAX + ONE
END
*
* The tier is unknown and is set below
* The tier status is on if the qnty is not zero
*27MAR94*IF ACT$QNTYS<ONE,SVC.CN> THEN
*27MAR94*COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ONE
*27MAR94*END
IF WOF EQ "D" AND WKO$STAT NE "X" THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ZERO
END ELSE
IF TMP1 GT ZERO THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ONE
END ELSE
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ZERO
END
END; * of "D" & -"X"
*
END; * Of WKO is AHS
*
NEXT SVC.CN
*
END
*
NEXT AIX.VC
*
!
*
* Do not remove this code, it is for future use. These variables can be
*  used to validate tier #'s.
* IF AI.TALK<OP.MULTI> THEN
* AIX.CN.MIN = (AIX.LOC - ONE) * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC> + ONE
* AIX.CN.MAX = AIX.CN.MIN - ONE  + COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* END ELSE
* AIX.CN.MIN = ONE
* AIX.CN.MAX = COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* END
*
* AIX.TIER.HI = COM.AI$ADDR.PER.UNIT<ONE,DVC.LOC> * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* (LOC - 1) * TIERS.PER.UNIT + TIER
*
* Load the default settings (note that in future these sub-values
*  should be multivalued by being tied directly to the device type).
* IF AI.TALK<OP.MULTI> THEN
* COM.AI.DF.SVCS = COM.AI$DF.SVCS.EIGHT
* COM.AI.DF.TIER = COM.AI$DF.TIER.EIGHT
* COM.AI.DF.XREF = COM.AI$DF.XREF.EIGHT
* END ELSE
COM.AI.DF.SVCS = COM.AI$DF.SVCS.ONE
COM.AI.DF.TIER = COM.AI$DF.TIER.ONE
COM.AI.DF.XREF = COM.AI$DF.XREF.ONE
* END
*
* Loop through the future services setting tier number
AIX.SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID.FUTR<ONE,AIX.LOC>,SVM)
FOR AIX.CN = ONE TO AIX.SVC.CN.MAX
*
SVC.ID = COM.AIP$SVC.ID.FUTR<ONE,AIX.LOC,AIX.CN>
*
* The AIX service tier location is used first
LOCATE SVC.ID IN DVC$TSVCS<ONE,AIX.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = DVC$TIERS<ONE,AIX.LOC,SVC.LOC>
END ELSE
*
* Otherwise the default service tier location is used
*LOCATE SVC.ID IN COM.AI$DFLTS<ONE,DVC.LOC> SETTING SVC.LOC THEN
*COM.AI.TIER = COM.AI$DF.TIER<ONE,DVC.LOC,SVC.LOC>
LOCATE SVC.ID IN COM.AI.DF.SVCS<ONE,DVC.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = COM.AI.DF.TIER<ONE,DVC.LOC,SVC.LOC>
COM.AI.TIER = (AIX.LOC - ONE) * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC> + COM.AI.TIER
END ELSE
*
* Otherwise the location of (BASIC) will be used
*   this would normally be the wrong thing to do but would test
*   wether the device works
LOCATE "(BASIC)" IN DVC$TSVCS<ONE,AIX.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = DVC$TIERS<ONE,AIX.LOC,SVC.LOC>
END ELSE
*
* we can't turn on an unknown tier number
SVC.LOC = ZERO
COM.AI.TIER = ZERO
END
*
END
*
END
*
* Only turn on known tiers
IF COM.AI.TIER THEN
*
*
* This is the provision for indexed or labelled tiers
* COM.AI$INDEXED
*
* X - Service name is sent to device.
* R - Use then relative (numbered) location as the tier number.
* N - Use the tier number off of the AIX as the tier (spiggot) number.
* Y - Use the ONE/EIGHT default svcs as an index.
*
IF COM.AI$INDEXED EQ "N" THEN
*
* This is the normal condition (used by Eagle)
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = COM.AI.TIER
*
END ELSE IF COM.AI$INDEXED EQ "X" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = SVC.ID
*
END ELSE IF COM.AI$INDEXED EQ "Y" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = COM.AI.DF.XREF<ONE,COM.AI.TIER>
*
END ELSE IF COM.AI$INDEXED EQ "R" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = AIX.CN
*
END; * of indexing
*
END; * of tier found
*
NEXT AIX.CN
*
END; * OF AIX.ID NE EMPTY
*
END ELSE
* LOCATE "AIDVC"
NULL
END; * of AIDVC
*
* End of tier processing
*
~AI.LOG.KEY.SET~
*CODE.SEGMENT: AI.LOG.KEY.SET
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: FEB 91
*
* COMPANY: AXION COMPUTER SYSTEMS
*
* REQUIRED: AIL.DISP.TYPE
*           AIL.SEQ.DISP.MAX
*           AIL.SEQ.DISP.MIN
*           AIL.SEQ
*           AI.CODE
*
!
*
BEGIN CASE
*
CASE AIL.DISP.TYPE EQ ONE; * FULL HISTORY DISPLAY
*
AIL.SEQ.END = AIL.SEQ - ((AIL.SEQ.CN.MAX - AIL.SEQ.CN.MIN) * 3)
AIL.SEQ.DISP = AIL.SEQ - 5
*
LOOP
AIL.ID = "AI*":AI.CODE:"*":AIL.SEQ.DISP:"*LOG"
MATREAD AIL FROM AIL.FILE,AIL.ID THEN
AIL.ON.FILE = TRUE
END ELSE
AIL.ON.FILE = FALSE
END
WHILE AIL.ON.FILE AND AIL.SEQ.DISP GT AIL.SEQ.END DO
AIL.SEQ.DISP = AIL.SEQ.DISP - 5
REPEAT
*
*
CASE AIL.DISP.TYPE EQ TWO; * UNDISPLAYED LINES DISPLAY
*
LOOP
*
AIL.ID = "AI*":AI.CODE:"*":AIL.SEQ.DISP:"*LOG"
*
MATREAD AIL FROM AIL.FILE,AIL.ID THEN
AIL.ON.FILE = TRUE
END ELSE
MAT AIL = EMPTY
AIL.ON.FILE = FALSE
END
*
WHILE NOT(AIL$LOG.DISPL) AND AIL.ON.FILE DO
AIL.SEQ.DISP = AIL.SEQ.DISP - 5
IF AIL.SEQ.DISP LE ZERO THEN AIL.SEQ.DISP = AIL.SEQ.DISP + 999
REPEAT
*
*
END CASE
*
!
*
AIL.SEQ.CONT = 6
*
LOOP
*
AIL.ID = "AI*":AI.CODE:"*":AIL.SEQ.DISP:"*LOG"
*
MATREAD AIL FROM AIL.FILE,AIL.ID THEN
AIL.ON.FILE = TRUE
END ELSE
MAT AIL = EMPTY
AIL.ON.FILE = FALSE
AIL.SEQ.CONT = AIL.SEQ.CONT - ONE
END
*
WHILE (NOT(AIL.ON.FILE) AND (AIL.SEQ.CONT AND AIL.DISP.TYPE EQ ONE)) OR (AIL.ON.FILE AND NOT(AIL$LOG.DISPL) AND AIL.DISP.TYPE EQ TWO) DO
AIL.SEQ.DISP = AIL.SEQ.DISP + ONE
IF AIL.SEQ.DISP GT 999 THEN AIL.SEQ.DISP = ONE
REPEAT
*
~AI.LOG.WRITE~
*CODE.SEGMENT: AI.LOG.WRITE
* USED BY: AI.WRITE.LOG
*          AI.HANDLER
*          AI.TALKER
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
AIL.SEQ.ID = "AI.LOG*":AI.CODE
*
LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",AIL.SEQ.ID,LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT DO REPEAT
*
READ AIL.SEQ FROM COM.FILE,AIL.SEQ.ID ELSE AIL.SEQ = ZERO
*
AIL.SEQ = AIL.SEQ + ONE
IF AIL.SEQ GT 999 THEN AIL.SEQ = ONE
*
WRITE AIL.SEQ ON COM.FILE,AIL.SEQ.ID
*
CALL UNLOCK.ITEM(COM.FILE,"COM",AIL.SEQ.ID,LOCKS.FILE)
*
AIL.ID = "AI*":AI.CODE:"*":("0000":AIL.SEQ) "R#4":"*LOG"
* COM.AIP$WKO.ID = AIL.NEXT.ID
IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
COM.AIP$LOG.TRAN.AIL = AIL.SEQ
AIL.NEXT.ID = AIL.SEQ
END
MAT AIL = MAT COM.AIP
IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
AIL$COMM.SRCE = AI.SRCE
END
IF AIL$PORT EQ EMPTY THEN AIL$PORT = PORT
IF AIL$ACCT.ID EQ EMPTY THEN AIL$ACCT.ID = ACCT
IF AIL$COMM.SRCE EQ EMPTY THEN AIL$COMM.SRCE = AI.SRCE
INS PORT BEFORE AIL$LOG.PORT<ONE,ONE>
INS ACCT BEFORE AIL$LOG.ACCT<ONE,ONE>
INS SYS.PROG BEFORE AIL$LOG.PROG<ONE,ONE>
INS AI.SRCE BEFORE AIL$LOG.SRCE<ONE,ONE>
INS LOG.REQUIRED BEFORE AIL$LOG.LOC<ONE,ONE>
*
COM.AIP$LOG.REQD = TRUE
*
MATWRITE AIL ON AIL.FILE,AIL.ID
*
~AI.READ.COM.AI~
*CODE.SEGMENT: AI.READ.COM.AI
* VERSION: 940130 1.1  COM.AI.ID CHANGED.
* USED BY: AI.HANDLER
*          AI.TALKER
*          AI.CONTROL.UTILITY
*          AI.WRITE.COMMAND
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*               ALL RIGHTS RESERVED
*
COM.AI.ID = "AI.TYPE.":AI.CODE
LOCK.STAT = FALSE
*
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF NOT(ELP.MAX) THEN ELP.MAX = 60
***ELP.MAX = 30
TMP2 = LOCK.TYPE
*
IF LOCK.ITM THEN
LOOP
LOCK.STAT = TMP2
CALL LOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF LOCK.STAT AND ELP GT LOCK.ELP.MAX - 5 AND (AI.SRCE EQ "C" OR AI.SRCE EQ "H") THEN
TMP2 = -6
END
UNTIL NOT(LOCK.STAT) OR ELP GT LOCK.ELP.MAX DO REPEAT
IF NOT(LOCK.STAT) THEN LOCK.COM.AI = TRUE
END ELSE LOCK.STAT = FALSE
*
*** IF NOT(LOCK.STAT) THEN
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN
*
COMMPORT = COM.AI$COMMPORT
COM.AI.ON.FILE = TRUE
*
*
!
*
END ELSE
* Not on file
COM.AI.ON.FILE = FALSE
STAT = 998
MAT COM.AI = EMPTY
END; * of on file/ not on file
*
*
*** END ELSE
*** COM.AI.ON.FILE = FALSE
*** LOCK.STAT = 997
*** END; * of not stat
IF LOCK.STAT THEN AI.STATUS = 101; COM.AI.RUN.ELP = ELP
*
!
*
READ.COM.AI.UNLOCK: *
*
IF LOCK.COM.AI AND LOCK.RELS THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
*
~AI.READ.COM.AIP~
*CODE.SEGMENT: AI.READ.COM.AIP
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS LTD.
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
LOCK.STAT = FALSE
*
IF LOCK.ITM THEN
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF NOT(ELP.MAX) THEN ELP.MAX = 60
ELP.MAX = 30
LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LOCK.STAT AND ELP LT ELP.MAX DO REPEAT
IF NOT(LOCK.STAT) THEN LOCK.COM.AIP = TRUE
END
*
** IF NOT(LOCK.STAT) THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN COM.AIP.ID.ON.FILE = TRUE ELSE COM.AIP.ID.ON.FILE = FALSE; LOCK.STAT = 998; MAT COM.AIP = ""
*
** END ELSE
** LOCK.STAT = 997
** IF NOT(STAT) THEN STAT = LOCK.STAT
** END; * of not stat
*
!
*
READ.COM.AIP.UNLOCK: *
*
IF LOCK.COM.AIP AND LOCK.RELS THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
LOCK.COM.AIP = FALSE
END
*
~AI.COM.AIP.UPD~
*CODE.SEGMENT: AI.COM.AIP.UPD*
*
*
*
*
** AI.SRCE = "U"
** HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
** *
COM.AI.ID = "AI.TYPE.":AI.CODE
* MAT COM.AI S/D ALREADY PRESENT
** READV COMMPORT FROM COM.FILE,COM.AI.ID,12 ELSE COMMPORT = 999
COMMPORT = COM.AI$COMMPORT
*
COM.AIP.PORT = PORT
LOOP WHILE LEN(COM.AIP.PORT) LT 3 DO COM.AIP.PORT = ZERO:COM.AIP.PORT REPEAT
AI.DVC.NEXT.FOUND = TRUE
*
!
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND)
*
*
COM.AIP.ID = "AI*":AI.CODE:"*":COM.AIP.PORT:"*":AI.DVC.NEXT.CN
DT = DATE(); TM = TIME(); ELP = ZERO
*
LOOP
LOCK.STAT = LOCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LOCK.STAT AND ELP LT LOCK.ELP.MAX DO REPEAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
*
* SEND.STATUS = FALSE
AI.COM.FLAG = FALSE
DT = DATE(); TM = TIME()
*
IF CNT.TST$ID THEN
PRINT CLB:"Updating COM.AIP$INTFC.STAT. Enter <cr>: ":; INPUT TMP:
END
*
!
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
*
OK = TRUE
IF INDEX("#AIDVC#PVI#PVD#IVI#IVD#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE) THEN
IF WKO$STAT NE "C" AND WKO$STAT NE "D" THEN OK = FALSE
END ELSE
IF NOT(INDEX("#SEQ#UPB#DLE#SET#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE)) THEN OK = FALSE
END
*
IF NOT(OK) THEN
*
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 605
*
END ELSE
*
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
END; * OF NOT OK
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
* "TOUT" BEFORE COM.AIP$ERR.TYPE<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
SEND.STATUS = 601
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
* INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
* INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
SEND.STATUS = 602
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 603
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
SEND.STATUS = 604
*
CASE TRUE
* PRINT CLB:">>":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"<<":; INPUT TMP:
SEND.STATUS = 606
*
END CASE
*
*
!
*
IF SEND.STATUS THEN
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
*
IF COM.AIP$LOG.REQD OR SEND.STATUS THEN
OPEN "AIL" TO AIL.FILE THEN
AIL.SEQ.ID = "AI.LOG*":AI.CODE
* $INCLUDE IBP AI.LOG.WRITE
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LOG.REQUIRED,SYS.PROG,HANDLER.COMMAND,LOCKS.FILE,LOCK.TYPE)
END ELSE PRINT CLB:"AIL file missing! Enter <cr> . . . "; INPUT RSP; STAT = 999
END
*
*
NEXT SEND.COMM.CN
*
!
*
SEND.COMM.CN = ONE
*
*
***IF AI.COM.FLAG THEN
***MAT COM.AI = EMPTY
***HANDLER.COMMAND = COM.AIP$COMM; AI.TMP.STAT = EMPTY; SEND.TMP.STAT = EMPTY
**** CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
***CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.TMP.STAT,SEND.TMP.STAT,AI.CODE,AI.SRCE,LOCK.COM.AI,LOCK.COM.AIP,LOCK.TYPE)
***TMP.STAT = AI.TMP.STAT
**** IF TMP.STAT THEN
**** PRINT BELL:CLB:"Addressable interface error (":TMP.STAT:") - Press <cr>":
**** INPUT TMP.RSP:; IF TMP.RSP = "KILL" THEN STAT = 999
**** END
***END ELSE
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
* CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
*
***END
*
END ELSE
*
* CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
AI.DVC.NEXT.FOUND = FALSE
*
END; * OF READ
*
*
IF AI.DVC.NEXT.FOUND THEN
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
*
*
NEXT AI.DVC.NEXT.CN
*
!
*
* IF SEND.STATUS AND NOT(AUTO.RUN) THEN
* PRINT BELL:CLB:"Addressable interface error (":SEND.STATUS:") - Press <cr>":
* INPUT TMP.RSP:; * IF TMP.RSP = "KILL" THEN STAT = 999; RETURN
* END
*
~AI.STATUS.VAR.EQUATES~
*CODE.SEGMENT: AI.STATUS.VAR.EQUATES
*
* FILE: STL      ID: STATUS.LOG
EQU STATUS.CHANNEL     TO 1; * CHANNEL #
EQU STATUS.CHAN.STAT   TO 2; * CHANNEL STATUS
EQU STATUS.DESC        TO 3; * CHANNEL DESCRIPTION
EQU STATUS.CHECKED     TO 4; * DT*TM OF LAST STATUS CHECK
EQU STATUS.SRVC        TO 5; * SERVICE ASSOC'T W THIS CHANNEL
EQU STATUS.FLAGGED     TO 6; * FLAG
*
*
EQU AI.UP TO "UP"
EQU AI.DN TO "DN"
EQU AI.ON TO "ON"
EQU AI.OFF TO "OFF"
*
~AI.TALK.VAR.EQUATES~
*CODE.SEGMENT: AI.TALK.VAR.EQUATES
*
*
*
EQU OP.MULTI TO 1;           * ADDRESS IS SERVED BY A MULTI ADDRESS DEVICE
EQU TALKING TO 2;            * CSR IS TALKING TO SOMEONE ON SITE
EQU DO.SEND TO 3;            * DO SEND TO ACTIVATE/DEACTIVATE SERVICES
EQU DISPATCHER.MSG TO 4;     * DISPATCHER MESSAGE HAS BEEN DISPLAYED
EQU INTERFACE.MSG TO 5;      * INTERFACE MESSAGE HAS BEEN DISPLAYED
EQU OP.STAT TO 6;            * THE INTERFACE IS ACTIVE
EQU OP.UP TO 7;              * THE INTERFACE IS UP
EQU VERIFIED.HOT TO 8;       * SERVICES HAVE BEEN VERIFIED AS ACTIVE
EQU VERIFIED.COLD TO 9;      * SERVICES HAVE BEEN VERIFIED AS INACTIVE
EQU VERIFIED.CHANGED TO 10;  * SERVICES HAVE BEEN VERIFIED AS CHANGED
EQU SENT TO 11;              * SEND HAS BEEN DONE
EQU PRIOR.TNT.ADD TO 12;     * ADDRESS IS PRIOR TENANT
EQU STOP.PRIOR.TNT TO 13;    * STOP SERVICE OF PRIOR TENANT
EQU PRIOR.ADD TO 14;         * ADDR IS THE PRIOR ADDR OF THE CURRENT TENANT
EQU PRIOR.ADD.HOT TO 15;     * PRIOR ADDRESS IS HOT
EQU PRINT.WO TO 16;          * WORK ORDER TO BE PRINTED (CHANGES BEING MADE)
EQU BUILD.WO TO 17;          * BUILD A WKO
EQU NOT.SCHEDULED TO 18;     * ON.PREMISE WO HAS BEEN UNSCHEDULED
EQU WKO.STAT TO 19;          * WKO STATUS PASSED BACK TO MAINT.WORK.ORDER
EQU TRAN.LOG TO 20;          * RECORD LOG FLAG
EQU ADDRESSABLE TO 21;       * THE ACCOUNT HAS AN ADDRESSABLE DEVICE
EQU PAY.PER.VIEW TO 22;      * THERE IS A DEVICE WITH PAY PER VIEW
EQU IMPULSE.PPV  TO 23;      * THERE IS A DEVICE WITH IMPULSE PAY PER VIEW
EQU AI.PRESENT   TO 24;      * FUTR FUNCTION OF GENERAL.OPEN (IN PAR)
EQU AI.DVC.IDS   TO 25;      * ITEM IDS OF ADDRESSABLE DEVICES
EQU AI.DVC.LOCS  TO 26;      * LOCATION OF DEVICE
EQU AI.DVC.ADDR  TO 28;      * ADDR ON DVC
EQU AI.DVC.PPV   TO 28;      * PPV  ON DEVICE
EQU AI.DVC.IPPV  TO 29;      * IPPV ON DEVCE
EQU AI.DVC.DIR   TO 30;      * DIRECTION (1 IS ACTIV / -1 IS DEACTIV)
EQU AI.DVC.SRCE  TO 31;      * DEVICE FOUND BY ACT/WKO/DVC
EQU AI.DVC.WKO   TO 32;      * WORK ORDER FOR DEVCIE
EQU AI.DVC.NEXT  TO 33;      * NEXT DVC TO BE ACTIVATED BY AI
~AI.TALKER.TOP~
*CODE.SEGMENT: AI.TALKER.TOP
*PROGRAM:           AI.TALKER
* VERSION: 940301 1.2  SET AI.TYPE IN COMMN.AREA TO COM.AI$(AI.CODE:VM:DB.PREFIX).
* PRIOR: 940216 1.1  CHANGE COM.AI.ID FROM HEADEND TO AI.CODE.
* EQU VS TO "901018 NEW"
* DESCRIPTION:  INTERFACE BETWEEN CSR AND AI SYSTEMS
*
* COPYRIGHT      AXION COMPUTER SYSTEMS LTD.
* 1990                 ALL RIGHTS RESERVED
*
* AI.RSLT IS EQUIVALENT TO STAT
* 99 - NOT A VALID ACTION TYPE
* 1  - SERVICES MISMATCH
* 2  - SERVICE QUANTITIES MISMATCH
* 3  - CONNECTED OUTLETS MISMATCH (EQUIVALENT TO 2)
*
* CHECK THAT THE INSTALLER & INTERFACE MESSAGES HAVE BEEN DISPLAYED
*
* AI.ACTN IS A MULTI-VALUED STRING OF NUMBERED FUNCTIONS TO BE PERFORMED
*
~AI.CNTRL.UTIL.DOC.TOP~
*CODE.SEGMENT: AI.CNTRL.UTIL.DOC.TOP
* USED BY: AI.CONTROL.UTILITY
*
*
*:  Multifunction utility program...
*
*: The function performed is input through the menu handler
*: parameter:
*
*: DI     Display handler status
*: START  Start the handler
*:    ON    "    "     "
*: STOP   Stop the handler at the head end
*:  OFF     "   "    "     "   "    "   "
*: DN     Down the handler
*: UP     Up the handler
*: DC     Down channel(s)
*: UC     Up channel(s)
*
~AI.CNTRL.UTIL.DOC.START~
*CODE.SEGMENT: AI.CNTRL.UTIL.DOC.START
* USED BY AI.CONTROL.UTILITY
*: end of INIT
*
!
*
*: Program Mainline -  MAIN Section
*
*: *Consists of two functions:
*
*:  Primary - Process requested and resultant command functions
*:   (Stacked functions and error analysis)
*
*: *Secondary - Display Handler Status in a Monitor Mode
*: Includes : Handler Queue, Channel Status
*:     Error Messages, Handler Log
*:     Handler Status
*
SYS.LOC = "START"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOC) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
*: LOOP BACK ON ERROR
*
~AI.CNTRL.UTIL.DOC.SCNDRY~
*CODE.SEGMENT: AI.CNTRL.UTIL.DOC.SCNDRY
* USED BY: AI.CONTROL.UTILITY
*
*: end of Main LOOP (function stack exausted) * Main 1
*
*: End of primary function * Main 1
*
*: Start of secondary cyclic DISPLAY function * Main 2
*:     note: quits on any keyboard character
*
*
~AI.CNTRL.UTIL.DISP.HDR~
*CODE.SEGMENT: AI.CNTRL.UTIL.DISP.HDR
* USED BY: AI.CONTROL.UTILITY
*
LOAD.TITLE: *
*
* : * Init DISPlay settings
BEGIN CASE
CASE FUNC EQ "DI"; TITLE = "Display handler status"; DISP.ONLY = TRUE
CASE FUNC EQ AI.ON; TITLE = "Turn ON the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ AI.OFF; TITLE = "Turn OFF the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ AI.DN; TITLE = "Down the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ AI.UP; TITLE = "Up the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ "DC"; TITLE = "Down channel(s)"; DISP.ONLY = ZERO 
CASE FUNC EQ "UC"; TITLE = "Up channel(s)"; DISP.ONLY = ZERO 
CASE TRUE; TITLE = "Unknown function"; DISP.ONLY = ZERO 
END CASE
*
TITLE = "Addressable Interface - ":TITLE
*
RETURN
*
*
DISPLAY.TITLE: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Display Title" "L#19":RVE:; RQM
IF NOT(ERR.DISP.ONLY) THEN
PRINT @(ZERO,ZERO):CLS:
END ELSE
PRINT @(ZERO,ZERO):CLL:@(ZERO,ONE):CLL:@(ZERO,TWO):CLL:@(ZERO,3):CLL:@(ZERO,4):CLL:@(ZERO,22):CLL:@(ZERO,23):CLL:
END
ALREADY.DISPLAYED = EMPTY
PRINT @(ZERO,ZERO):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE) / TWO))):CO.NAME) "L#56":("Who: ":WHO) "L#12":
PRINT @(ZERO,ONE):OCONV(TIME(),"MTS") "L#12":(SPACE(28-LEN(TITLE) / TWO):TITLE) "L#56":("Oper: ":OPER) "L#12":RVE:
*
RETURN
*
*
~AI.CU.TOP~
*CODE.SEGMENT: AI.CU.TOP
* USED BY: AI.CONTROL.UTILITY
*
* DAVID HORSMAN (C) 1992
*
*
!: * Input Parameters
*
INPUT FUNC:
INPUT RUN.TYPE:
INPUT FAST.DISPLAY:
*
*
!: * System Control
*
*: * System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CONTROL.UTILITY"; SYS.LOC = EMPTY
SYS.APPL.LOC = ONE
VERSION = VS; AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE; DISP.ONLY = FALSE
*
*
LOCK.TYPE = -8
LOCK.ELP = ZERO; LOCK.ELP.MAX = 60
LOCK.ITM = TRUE; LOCK.RELS = TRUE; LOCK.STAT = LOCK.TYPE
*
!: * System Files
SYS.LOC = "SF"; * IF CNT.TST$LBL THEN PRINT @(60,20):"System Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "CNT" TO CNT.FILE ELSE TEXT<-ONE> = "Can't open CNT"; GOSUB ERROR; STOP
READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.DATA<ONE,ONE> ELSE CO.NAME = EMPTY; CO.DATA = EMPTY
OPEN "PAR" TO PAR.FILE ELSE TEXT<-ONE> = "Can't open PAR"; GOSUB ERROR; STOP
*
* ULT ONLY
OPEN "LOCKS" TO LOCKS.FILE ELSE TEXT<-ONE> = "Can't open LOCKS"; GOSUB ERROR; STOP
* LOCKS.FILE = ZERO; * REV ONLY
*
COMPONENTS.DFLT = EMPTY
*
~AI.CU.TOP.A~
*CODE.SEGMENT: AI.CU.TOP.A
* VERSION: 940117 1.1  CHANGED 'Comm Port' to 'AI Code' to FUNC.
* USED BY: AI.CONTROL.UTILITY
*
* DAVID HORSMAN (C) 1992
*
*
COMPONENTS = EMPTY; CHANNEL.MLES = EMPTY; CHAN.ALL = FALSE
STATUS.LOC = ONE; STATUS.CYCLE = FALSE
STVC = ZERO; BVC = ZERO; ACTIONS = EMPTY; PRIOR.CHANNEL.MLES = EMPTY
STL = EMPTY; MVC = ZERO; MLE.NUM = ZERO; STL.LOC = ZERO; ST.VC = ZERO
DOWNED.CHANNELS.CHANGED = EMPTY
*
!: * System Files
SYS.LOC = "SF"; IF CNT.TST$LBL THEN PRINT @(60,20):"System Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "COM" TO COM.FILE ELSE TEXT<-ONE> = "Can't open COM"; GOSUB ERROR; STOP
*
*
!: * Application Files
SYS.LOC = "AF"; IF CNT.TST$LBL THEN PRINT @(60,20):"Appl Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "AIX" TO AIX.FILE ELSE TEXT<-ONE> = "Can't open AIX"; GOSUB ERROR; STOP
*
OPEN "ACT" TO ACT.FILE ELSE TEXT<-ONE> = "Can't open ACT"; GOSUB ERROR; STOP
*
*: * Init INternal VARiables
SYS.LOC = "VAR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Variables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
AI.SRCE = "C"
PORTS.LIST.BUILD = 9; AI.SCAN = TRUE
AI.SCAN.DT = DATE(); AI.SCAN.TM = TIME(); STAT = FALSE
MSG.DISP = FALSE; FUNC.CHNG = EMPTY
STATUS.CYCLE = FALSE
*
******
*
ERR.CL = 31; ERR.LN = 5; ERR.LEN = 48
ERR.LN.MIN = ERR.LN; ERR.LN.MAX = 9
ERR.HDR = "Handler Messages "; ERR.BELL = TRUE
*
IF ERR.CLB THEN ERR.CL = ZERO; ERR.LEN = 68
*
******
*
CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 18
CHECK.LEN = 35; CHECK.LN.HI = ZERO
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
*
******
*
*: * Func
IF FUNC EQ "START" THEN FUNC = AI.ON
IF FUNC EQ "STOP" THEN  FUNC = AI.OFF
IF FUNC EQ "DC" OR FUNC EQ "UC" THEN CHAN.ALL = TRUE
*
*: * Run Type
IF RUN.TYPE NE "1" AND RUN.TYPE NE "2" THEN RUN.TYPE = "1"
IF RUN.TYPE EQ TWO THEN ERR.DISP.ONLY = 3
*
*: * Fast.Display
* IF FAST.DISPLAY NE "0" AND FAST.DISPLAY NE "1" THEN FAST.DISPLAY = "0"
*
*: * Control
OLD.FUNC = EMPTY; SAVE.FUNC = EMPTY; ORIG.FUNC = FUNC
UP.ALL.CHANNELS = FALSE; HANDLER.COMMAND = EMPTY
ON.TRIED = ZERO; OFF.TRIED = ZERO; UP.TRIED = ZERO; DN.TRIED = ZERO
*
*: * Operator
OPER = EMPTY; OPER.LN = 10; OPER.CL = 10; OPER.DESC.LN = 10
OPER.DESC.CL = 40; OPER.DESC.FMT = "L#20"; OPER.STAT = FALSE
OPER.DISP = FALSE; OPER.RVB = TRUE; OPER.TEXT = "Your operator ID is: "
IF RUN.TYPE EQ TWO THEN OPER.DISP = TRUE
*
*
!: * Init Tables
SYS.LOC = "TBL"; IF CNT.TST$LBL THEN PRINT @(60,20):"Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
*
** ** ** READV OFF.FLAG FROM COM.FILE,"AI.OFF.":PORT.KEY,ONE THEN
** ** ** DELETE COM.FILE,"AI.OFF.":PORT.KEY
** ** ** END
** ** ** READV OFF.FLAG FROM COM.FILE,"AI.OFF.ALL",ONE THEN
** ** ** DELETE COM.FILE,"AI.OFF.ALL"
** ** ** END
EXEC.VERB = 'EQ "AI.OFF.]"'
TMP = EMPTY
EXECUTE "SELECT COM ":EXEC.VERB, //SELECT. > COM.ID.LIST, //OUT. > TMP
TMP = EMPTY
CONT = TRUE
LOOP
READNEXT COM.ID FROM COM.ID.LIST ELSE CONT = FALSE
WHILE CONT DO
DELETE COM.FILE,COM.ID
* PRINT "Off Flag ":COM.ID:" Cleared!"
REPEAT
OFF.FLAG = FALSE
*
COMPONENTS = EMPTY
*
PRINT @(ZERO,3):CLS:
*
*: * Init CALLs
*
*CALL INPUT.OPERATOR: *
CALL INPUT.OPERATOR(OPER,OPER.POSN,OPER.LN,OPER.CL,OPER.TEXT,OPER.DESC.LN,OPER.DESC.CL,OPER.DESC.FMT,OPER.RVB,RUN.TYPE,OPER.DISP,OPER.STAT)
*
IF OPER.STAT THEN STOP
OPER.DISP = TRUE
OPER.LN = 3; OPER.CL = 31; OPER.DESC.LN = 3; OPER.DESC.CL = 49
OPER.DESC.FMT = "L#15"; OPER.STAT = EMPTY; OPER.DISP = TRUE
OPER.RVB = TRUE; OPER.TEXT = "Operator: "
OPER.POSN = EMPTY
*
*: * Init DISPlay settings
*
PRINT @(ZERO,ZERO):CLS:
GOSUB LOAD.TITLE; * : *
ORIG.TITLE = TITLE
GOSUB DISPLAY.TITLE; * : *
*
*: * Init SUBject INPut loop
*
DT = DATE(); TM = TIME()
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
LOCK.COM.AI = FALSE; COM.AI.ON.FILE = FALSE; LOCK.STAT = FALSE
LOCK.COM.AIP = FALSE; COM.AIP.ON.FILE = FALSE
*
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
AI.TYPES.CTR = (COUNT(AI.TYPES,VM))
*
LOOP
*
IF NOT(AI.TYPES.CTR) THEN
AI.CODE = AI.TYPES<1>
TMP.LOC = 1
END ELSE
*
LOOP
PRINT @(10,11):BELL:"Enter the Code of the Interface to ":FUNC:": ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP
LOCATE AI.CODE IN AI.TYPES<1> SETTING TMP.LOC ELSE AI.CODE = ""
UNTIL AI.CODE NE "" DO PRINT BELL REPEAT
*
END
*
* LOOP
* IF NOT(LOCK.STAT) THEN
* PRINT CLB:"Enter the AI Code to ":FUNC:": ":
* INPUT COMMPORT:
* END
* IF NUM(COMMPORT) THEN
* LOOP WHILE LEN(COMMPORT) LT 3 DO COMMPORT = "0":COMMPORT REPEAT
* END
* *
*: * Init READ subject
LOCK.ITM = FALSE; LOCK.RELS = TRUE; LOCK.STAT = LOCK.TYPE; WRITE.FLAG = FALSE
*
LOCK.ITM = TRUE; LOCK.RELS = TRUE; GOSUB READ.COM.AI; * : *
*
TMP.DESC = AI.TYPES<2,TMP.LOC>
TMP.MODEL = AI.TYPES<3,TMP.LOC>
HEADENDS = AI.TYPES<4,TMP.LOC>
HEADEND  = HEADENDS<ONE,ONE,ONE>
IF COM.AI$MONITOR.PORT = "" THEN TMP.PORT = "<NONE>" ELSE TMP.PORT = COM.AI$MONITOR.PORT
*
PRINT @(27,12):" AI Description:  ":TMP.DESC:
PRINT @(27,13):"    Equipment:    ":TMP.MODEL:
PRINT @(27,14):"    Handler Port: ":COM.AI$COMMPORT:
PRINT @(27,15):"    Monitor Port: ":TMP.PORT:
EXECUTE "SLEEP 3"
*
WHILE LOCK.STAT OR NOT(COM.AI.ON.FILE) DO
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF ELP GT 90 THEN STOP
REPEAT
*
IF LOCK.STAT THEN AI.RESET = TRUE
*
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE AI.ERRORS = EMPTY
DVC.LOC = ONE
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE MAT COM.AIIERR = EMPTY
*
GOSUB READ.STL; * : *
*
* repeat until valid subject
*
IF FUNC EQ AI.OFF AND COM.AI$UP.DN.STAT EQ AI.UP THEN
INS 391 BEFORE COM.AI.ERR<ONE>
INS "Requested OFF needs a DN first" BEFORE COM.AI.ERR.TEXT<ONE>
INS "FUNC" BEFORE COM.AI.ERR.TYPE<ONE>
INS AI.DN BEFORE COM.AI.ERR.FUNC<ONE>
INS AI.DN BEFORE FUNC.CHNG<ONE>
END
*
IF FUNC EQ AI.UP AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
INS 491 BEFORE COM.AI.ERR<ONE>
INS "Requested UP needs a ON first" BEFORE COM.AI.ERR.TEXT<ONE>
INS "FUNC" BEFORE COM.AI.ERR.TYPE<ONE>
INS AI.ON BEFORE COM.AI.ERR.FUNC<ONE>
INS AI.ON BEFORE FUNC.CHNG<ONE>
END
*
IF FUNC EQ AI.DN OR FUNC EQ AI.UP THEN
IF FUNC EQ COM.AI$UP.DN.STAT THEN INS "DI" BEFORE FUNC.CHNG<ONE>
END
*
