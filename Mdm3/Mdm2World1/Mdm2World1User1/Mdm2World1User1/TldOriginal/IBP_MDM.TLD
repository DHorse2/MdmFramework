~STANDARD.FUNCTIONS.SUBR~
*CODE.SEGMENT: STANDARD.FUNCTIONS.SUBR
*
* WARNING: STANDARD.FUNCTIONS is to be INCLUDED in programs only.
*          Subroutines INCLUDE the code segment STANDARD.FUNCTIONS.SUBR
*          Device Control Subroutines INCLUDE STANDARD.FUNCTIONS.DVC
*
*          The .DVC routine was designed for communications
*           and printer sub-routine calls.
*
*          The .SUBR extension is now used in all called sub-routines.
*
*          One difference between the three code segments
*           being .DVC and .SUBR do not output screen escape
*           sequences. They also expect system controls and
*           screen escape sequences to be passed unchanged
*           either in the CALL or thru COMMON area.
*
*          It is especially important to use the .DVC version when
*          working with programs in Axion's K-bil Sub-Applications such as
*             - Counter Cash
*             - Addressable Interface
*             - Work Order Printing
*             - EFT Communication Programs
*             - Genie (by its open structure)
*
*          And Utility Routines such as
*              -Communications
*              -Auxilary Port Handling/Printing
*              -Menus
*              -Screen Handling
*              -Functions like Unpack Number, Lock.Item, MOD11.DIGIT
*
*
*
! Standard characters
*
*%%MDD%%=**
EMPTY = ""; ZERO = 0; ONE = 1; TWO = 2
FALSE = ""; TRUE = 1; STAT = ""
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254); ESC = CHAR(27)
*
! Screen Escape Sequences
*
RVB = EMPTY; RVE = EMPTY; RVH = EMPTY
CLL = EMPTY; CLS = EMPTY; CLB = EMPTY
AUX.ON = EMPTY; AUX.OFF = EMPTY
COL.ON = EMPTY; COL.OFF = EMPTY
CLB0 = EMPTY; CLB1 = EMPTY; CLB2 = EMPTY; CLB3 = EMPTY; * 20,21,22,23
*
! System Information
*
WHO = ICONV(0,"U50BB"); * ULT ONLY
* WHO = @USER0; * REV ONLY
PORT = (FIELD(WHO," ",ONE)+1000)[TWO,3]; ACCT = FIELD(WHO," ",TWO)
OPSYS = "U"; * ULT ONLY
* OPSYS = "P"; PCK ONLY
* OPSYS = "R"; * REV ONLY
*%%MDD%%=OPSYS = "M"; * MDD ONLY
TT = SYSTEM(7); * INST SUPP; * ULT ONLY
* TT = EMPTY; * REV ONLY
PT = EMPTY; AT = EMPTY
*
! Software Control
*
* RSP = EMPTY; RSPBUF = EMPTY; * SUBR
* SUBR
GENERIC = FALSE; * ULT ONLY
* SUBR
* GENERIC = FIELD(@USER0," ",3); * REV ONLY
* TYPE.RUN = "S"; AUTO.RUN = EMPTY; PHAN.RUN = EMPTY; * SUBR
* DISP.ONLY = EMPTY; REDISP = EMPTY; * SUBR
* TRC = EMPTY; TM.MAX = 0; * SUBR
* PROCBUF = EMPTY; RSPLOG = EMPTY; * SUBR
*
! Screen Attributes
*
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN
CLB = @(ZERO,23); CLB0 = @(ZERO,20); CLB1 = @(ZERO,21); CLB2 = @(ZERO,22); CLB3 = @(ZERO,23)
END ELSE
CLB = @(ZERO,23):CLL; CLB0 = @(ZERO,20):CLL; CLB1 = @(ZERO,21):CLL; CLB2 = @(ZERO,22):CLL; CLB3 = @(ZERO,23):CLL
END
*
BEGIN CASE
*
CASE OPSYS EQ "R"
RVB = CHAR(27):"00"; RVE = CHAR(27):"0A"; RVH = CHAR(27):"01"
AUX.ON = EMPTY; AUX.OFF = EMPTY
*
CASE TT EQ "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
CASE TT EQ "R" AND OPSYS EQ "M"
RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TT EQ "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(18):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):3; AUX.OFF = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(20):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):4
* SUBR
* IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":; * ULT ONLY
*
CASE TT EQ "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
*
CASE TT EQ "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TT EQ "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TT EQ "E"
RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TT EQ "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TRUE; RVB = EMPTY; RVE = EMPTY; RVH = EMPTY; AUX.ON = EMPTY; AUX.OFF = EMPTY
END CASE
*
! Software Location Information
*
SYS.SYST = EMPTY; SYS.APPL = EMPTY; SYS.APPL.SUB = EMPTY
* SYS.PROG = EMPTY; SYS.LOCT = EMPTY; SYS.LOCT.SUB = EMPTY
SYS.ID = EMPTY ; REL.ID = EMPTY ; VER.ID = EMPTY
*
! SUBROUTINE INPUT.DATA.SG1(
*
* FILE.NAME = EMPTY; ITEM.NAME = EMPTY; ITEM = EMPTY
* CL = EMPTY; LN = EMPTY; LH = EMPTY; LHM = EMPTY
* LOCN = EMPTY; CONV = EMPTY; EDITS = EMPTY; EDIT.FILE = EMPTY
* SEC.USER.ID = EMPTY; CURSOR.KEYS = EMPTY
* NUMC = EMPTY; FIXED = EMPTY; DEF.SUPP = EMPTY; TC.FUNC = EMPTY
* RSP.CL = EMPTY; RSP.LN = EMPTY; TC.FILL = EMPTY
* STD.SUBR.NAME = EMPTY
* )
*
! Temporary & Other
*
* PG = EMPTY; LINE = EMPTY; TEXT = EMPTY; TMP = EMPTY
* DT = EMPTY; TM = EMPTY
* CN = EMPTY; LOC = EMPTY
* MAX = EMPTY
*
~STAT.BEGIN~
*CODE.SEGMENT: STAT.BEGIN
*
* EMPTY
*
~STAT.CRITERIA~
*CODE.SEGMENT:      STAT.CRITERIA
* VERSION: 920410 263 REGF&LPI6-PASSED-TO-GENERATE.STMT.MASK
* PRIOR: 911008 263  ANNUAL.NOTICE.MONTH.RECEIVED.FROM.STAT.SUB.INPUT
* PRIOR: 910801 263  PRINT.MASK.IS.NOW.IN.CALL.TO.'GENERATE.STMT.MASK'
* PRIOR: 910724 263  IF.GET.LIST.THEN.BYPASS.ALL.EXLN.CODE
* PRIOR: 900124
* PRIOR: 890725
* DESCRIPTION:       PRINT STATEMENTS
*
* AUTHOR:            31 MAY 87  D. HORSMAN  FROM STATEMENTS.9.5X7.3
*                               Split off validation and
*                               standardize all statement formats.
!
REJECTED.DESC = ""
*
CTR = 0; STMT.COUNT = 0; ACR = 1; FR.FLAG = 0; TO.FLAG = 0
STMT.COUNT.MPG = 0; ACT.ID = ""
FR.ACT = STR("0",6); TO.ACT = STR("9",6); SINGLE = 0
INPUTS = ''; LPI6 = ''; LPI8 = ''
*
LN = 4; RNTP.RSP = ""
INPUT AUTO.RUN
IF AUTO.RUN THEN READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
*
CALL STAT.SUBR.INPUT(PAR.FILE,MXACR,PMT.N.S,RECALC.DISC,PCODE.SORT,SYS.PROG,CNT.FILE,RQC,DBTW,TT.PMT,TT.ADJ,TT.DEP,CCR,MDQA,MDQS,MDD,DCR,PYM,SYS.TST,MTP,MAT MG,MAT MG.LGTH,CO.NAME,RNTP.RSP,ST.IDATE,PYDD,FR.ACT,TO.ACT,LFL,HF,HC,AUTO.RUN,MAT BMG,REJECTED.DESC,FCV,FCN,CLC,LN,BFS,BFS.ANN,MAT TDSC,ST.PRDT,DISC.DATE,TM,RPR,RNTP,BILLING.CYCLES,CYCSEL,MXPRT,INRNG,SINGLE,INPUTS,CURRENT.RUN,GEN,AN.NO,DFL)
*
IF HF AND NOT(AUTO.RUN OR SINGLE) THEN CALL AUTO.LOADER(SYS.PROG,INPUTS,"Statements")
!
*
IF DISC.DATE EQ "CALC" THEN DISC.DATE = ""
IF NOT(RPR) THEN FR.FLAG = 1
IF SYS.TST<8> AND SYS.TST<1> THEN
TDY = ICONV(SYS.TST<6>,"D")
IF OCONV(TDY,'D2') = '' THEN TDY = DATE()
IF OCONV(TDY,'D2') = '31 DEC 67' THEN TDY = DATE()
END
IF OPSYS = "R" THEN HOLD.FILES = 0 ELSE READV HOLD.FILES FROM PAR.FILE, "STATEMENT.HOLD.FILES",1 ELSE HOLD.FILES = 0
READ CITIES FROM PAR.FILE,"CITIES" ELSE CITIES = ""
READ WOT FROM PAR.FILE,"WORK.ORDER.TYPES" ELSE WOT = ""
*
LN = LN+2
DISP.LN = LN
CLS.COL = 0; CLS.ROW = DISP.LN; GOSUB CLS.ROUTINE 
*
SELECT SVC.FILE
MSG.SVC.ID = ""; MSG.SVC.CODE = ""
LOOP
READNEXT SVC.ID ELSE SVC.ID = ""
UNTIL SVC.ID = "" DO
READ SVC FROM SVC.FILE,SVC.ID THEN
IF SVC<10> # "" THEN
LOCATE SVC<10> IN MTP<1> SETTING MN THEN
IF MG(MN) # "" THEN MSG.SVC.ID<-1> = SVC.ID; MSG.SVC.CODE<-1> = SVC<10>
END
END
END
REPEAT
*#
LATE.BAL = "Previous balance"
LOCATE "B" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN LATE.BAL = TMP
END
TMP = ""; THIRTY.D.MG = ""
LOCATE "T" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN THIRTY.D.MG = TMP
END
*#
IF FR.ACT EQ TO.ACT AND FR.ACT # "000000" THEN SINGLE = 1
IF FR.ACT EQ "000000" THEN FR.FLAG = 1
*
PTY = EMPTY; PQUE = EMPTY; PQUE.FUNC = "START"
CALL STAT.SUBR.PTR(PAR.FILE,PTY,PQUE,PQUE.FUNC,PTR.ON,PTR.OFF,REGF,COMF,C12.FONT,C12.FONT.CR,CRCOM78,CRCOM72,CRCOMF,LPI6,LPI8)
*
IF FIRST AND NOT(SINGLE OR GEN) THEN
IF OPSYS = "R" THEN PRINT CLB:RVB:"Now printing Statement Mask":RVE:
CALL GENERATE.STMT.MASK(REGF,LPI6,COMF,CRCOM78,THIRTY.D.MG,SYS.TST,SYS.PROG,VERSION,MXACR,ACR,PMT.N.S,FIRST,SINGLE,MAT PL)
GOSUB PSTMTS; FIRST = ""; PRINT CLB:
END
IF NOT(SINGLE) THEN
PRINT @(0,DISP.LN):"Now selecting accounts":@(0,DISP.LN+1)
*
IF SYS.TST<1> AND SYS.TST<5> # "" THEN
* EXLN = 'GET-LIST ':SYS.TST<5>; * REV ONLY
* ULT ONLY
EXLN = 'GET-LIST ':SYS.TST<5>:', //SELECT. > ACT.ID.LIST'
EXECUTE EXLN
END ELSE
EXLN = ''
IF PCODE.SORT THEN EXLN = EXLN:"BY SORT.PCODE "
IF NOT(FR.ACT EQ "000000" AND TO.ACT EQ "999999") THEN
EXLN = EXLN:'WITH ID >= "':FR.ACT:'" AND WITH ID <= "':TO.ACT:'" AND '
END
IF RPR THEN
EXLN = EXLN:'WITH LAST.STMT.DATE = "':OCONV(ST.PRDT,'D2'):'" AND WITH BAL >= "':OCONV(MDQA,"MR2"):'"'
END ELSE
EXLN = EXLN:'WITH STAT # "C" AND WITH BAL >= "':OCONV(MDQA,"MR2"):'"'
IF RNTP = 1 THEN
EXLN = EXLN:' AND WITH CS GE "':MDQS:'" OR WITH STAT EQ "D" AND WITH BAL >= "':OCONV(MDQA,"MR2"):'"'
END ELSE
IF COUNT(BFS,",") < 5 THEN
TEMP = 1
CN = 1
LOOP BF = BFS[CN,1] WHILE BF # '' DO
IF (LFL OR RNTP.RSP = 'SELECT') AND BF # '' THEN
IF TEMP THEN EXLN = EXLN:' AND WITH BILL.FREQS '; TEMP = '' ELSE
EXLN = EXLN:' OR '
END
IF BF EQ "^" THEN BF = ""
EXLN = EXLN:'"':BF:'"'
END
CN = CN + 2
REPEAT
END
END
END
PRINT
IF SYS.TST<1> THEN PRINT EXLN
PRINT
EXECUTE "SSELECT ACT ":EXLN
END
*
PRINT BELL:
RQM; RQM; RQM; RQM
PRINT BELL:
PRINT @(0,DISP.LN):CLL:"Selection of accounts completed":@(0,DISP.LN):
*
END ELSE
PRINT @(0,DISP.LN)
PRINT
PRINT "Print the account ":FR.ACT:"."
PRINT
END
MPG.RUN = ""; MPG.IDS = ""
OLCA = ""; RTO.ADD = ""; MXPRT.ABORT = ""
RTO.ADD1 = ""; RTO.ADD2 = ""; RTO.ADD3 = ""; RTO.ADD4 = ""
IF MXPRT THEN MXPRT = MXPRT - 2
*
* INTERUPT.LINE = "Use ":RVB:"F1":RVE:" to INTERUPT after next statement, then ":RVB:"F3":RVE:" to CONTINUE statement printing"; * REV ONLY
* IF NOT(SINGLE) THEN PRINT @(0,23):INTERUPT.LINE:; * REV ONLY
!
*#
~STAT.MAIN.LOOP~
*CODE.SEGMENT:      STAT.MAIN.LOOP
* VERSION: 920128 263  MOVE-SETTING-OF-STAT.TY-TO-B4-IF-RPR
* PRIOR: 911009 2.6  MATREAD.CHANGED.TO.READ.OF.STT.AND.EFT
* PRIOR: 910513 2.6  TO.FORCE.PRINTING.OF.ALL.INACTIVE.EFTS
* PRIOR: 900211 2.6 ADDED.ATR.TYPE.T-TAX.CHANGE
* PRIOR: 910116 2.6  WAS.NOT.UNLOCKING.IF.NOT.STATEMENT.CYCLE
* PRIOR: 900719 2.1
* PRIOR: 890818
* COPYRIGHT          AXION COMPUTER SYSTEMS LTD.
*   1984                 ALL RIGHTS RESERVED
*
* DESCRIPTION:       PRINT STATEMENTS
*                      PROCESS ACT FILE
*                      ANALYZE ACTS FOR STMT GENERATION
*                      MOVE ATR TO ATH
*                      GET.NADDS: BUILD MAILING NAME AND ADDRESS
*                      RUN MODES FROM MENU:
*                          REGULAR = RTNP 0, LFL 0
*                          LATES          1      1
*                          BOTH           2      1
*
*                    SYS.TST<6> TIMING ON
*                    SYS.TST<9> PRINT SUPPRESSION
*                    SYS.TST<8> SETS DISPLAY ON IN GET.NADDS
!
IF SYS.TST<1> THEN TEST.ON = 1 ELSE TEST.ON = 0
IF SYS.TST<2> AND TEST.ON THEN DSR = 1 ELSE DSR = 0
IF RNTP = 1 THEN LFL = 1
*
!
*
NXT: *
*
RJT.FL = ""
*
IF MXPRT AND STMT.COUNT GE MXPRT AND NOT(MPG.RUN) THEN GOTO FINISH
*
IF TO.FLAG THEN MPG.RUN = 1
*
IF MPG.RUN THEN
ACT.ID = MPG.IDS<1>
IF ACT.ID = "" THEN GOTO FINISH
DEL MPG.IDS<1,0,0>
STMT.COUNT.MPG = STMT.COUNT.MPG + 1
END ELSE
*
IF SINGLE THEN ACT.ID = FR.ACT ELSE
READNEXT ACT.ID ELSE MPG.RUN = 1; GOTO NXT
END
IF ACT.ID = TO.ACT AND TO.ACT # "999999" THEN TO.FLAG = 1
IF ACT.ID = FR.ACT AND FR.ACT # "000000" THEN FR.FLAG = 1
END
*
IF NOT(SINGLE) THEN
*
GOSUB STD.DELAY
*
END
*
*
IF OPSYS = "R" THEN
INPUT ALERT,-1
INPUTCLEAR
IF ALERT = CHAR(0):CHAR(59) THEN GOSUB CALL.MENU
END
*
IF NOT(RPR) OR RECALC.DISC THEN
LOOP STAT = -1; CALL LOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE,STAT) WHILE STAT DO REPEAT
END
SKIP.FLAG = 0
MATREAD ACT FROM ACT.FILE,ACT.ID THEN
IF NOT(SINGLE) AND BILLING.CYCLES # "" THEN
TMP = ACT$BILL.DAY+0
LOCATE TMP IN BILLING.CYCLES<1> BY "AR" SETTING CYC.NUM ELSE NULL
IF BILLING.CYCLES<1,CYC.NUM> = "" THEN CYC.NUM = 1
IF FIELD(CYCSEL,"*",CYC.NUM) # "Y" THEN SKIP.FLAG = 1
END
IF NOT(SKIP.FLAG) THEN
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = ""
MATREAD ADD FROM ADD.FILE,ACT$ADD.ID THEN
GOSUB EXDATA
END ELSE RJT.FL = 1; *** Address data is missing
END; * OF SKIP.FLAG
END ELSE RJT.FL = 2; *** Account data is missing
IF NOT(RPR) OR RECALC.DISC THEN CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
IF RJT.FL THEN
IF TEST.ON THEN REJECTED.ACCTS<-1> = ACT.ID:VM:RJT.FL
IF SINGLE OR SYS.TST<1> THEN
IF SINGLE AND (RJT.FL = 12 OR RJT.FL = 11) AND NOT(RPR) THEN
IF SYS.TST<1> THEN PRINT CLB:"Rejected -  (":REJECTED.DESC<RJT.FL>:"). Trying a reprint! ":
RPR = 1; RECALC.DISC = 0; TO.FLAG = 0
GOTO NXT
END
IF SYS.TST<1> THEN PRINT CLB:"Rejected - Reason: ":RJT.FL:". Enter <cr> ":; INPUT TMP:
END
END
IF SYS.TST<2> = "2" AND TEST.ON THEN
PRINT CLB:"Exiting NXT":; INPUT TMP:
END
IF SINGLE THEN MPG.RUN = 1
GOTO NXT
!
EXDATA: *
IF DSR THEN
PRINT CLB:"EXDATA":; INPUT TMP:
END
IF (ACT$STAT = "C"  OR ACT$CREDIT.STATUS GE 9) THEN RJT.FL = 3; RETURN; *** Account Status is in collections
* RJT.FL 7 IS NOW AVAILABLE
*
BFS.FL = ""
ANN.FL = ""
STAT.TY = RNTP+1
STAT.TY.CN = 0
LOOP STAT.TY.CN = STAT.TY.CN + 1 WHILE ACT$BILL.FREQS<1,STAT.TY.CN> # "" DO
IF NOT(BFS.FL) THEN
IF ACT$BILL.FROM.DATES<1,STAT.TY.CN> GT ACT$LAST.STMT.DATE AND INDEX(BFS,ACT$BILL.FREQS<1,STAT.TY.CN>,1) # 0 AND ACT$EFT.BILLING<1,STAT.TY.CN> # "Y" THEN BFS.FL = 1
END
IF ACT$BILL.FROM.DATES<1,STAT.TY.CN> GT ACT$LAST.STMT.DATE AND ACT$BILL.FREQS<1,STAT.TY.CN> = "Y" AND ACT$EFT.BILLING<1,STAT.TY.CN> # "Y" THEN ANN.FL = 1
REPEAT
IF BFS.ANN THEN
IF ANN.FL THEN STAT.TY = 3 ELSE STAT.TY = 2
END
*
IF RPR THEN
LAST.VC = ""
VC = 1
LOOP
TTY = ATR$TYPES<1,VC>
IF TTY = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
IF SINGLE OR EDT = ST.PRDT THEN
MGI = ATR$REFS<1,VC>; IF MGI # "" AND MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
IF LAST.VC = "" THEN LAST.VC = VC+1
END ELSE IF EDT LT ST.PRDT THEN TTY = ""
END
UNTIL TTY = "" DO VC = VC+1 REPEAT
IF NOT(LAST.VC) THEN RJT.FL = 8; RETURN; *** No statement to reprint
PST.VC = VC
IF ACT$LAST.STMT.DATE # ST.PRDT THEN RJT.FL = 12; RETURN; *** Not a reprint
IF FR.FLAG THEN GOSUB GEN.STMT; RETURN
END ELSE
LOCATE "S" IN ATR$TYPES<1> SETTING PST.VC ELSE LOCATE "" IN ATR$TYPES<1> SETTING PST.VC ELSE NULL
IF ATR$EFF.DATES = "" THEN RJT.FL = 9; RETURN; *** Account was never billed (not trans.)
LAST.VC = 1
END
*
CDEB = 0; TFL = ""; BFL = ""; FND = ""
FOR VC = LAST.VC TO PST.VC-1 UNTIL FND
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
IF TMT GT 0 THEN TFL = 1; CDEB = CDEB+TMT
IF COUNT("BRTW",TTY) THEN TFL = 1
IF TTY = "B" THEN
IF NOT(BFL) THEN BFL = VC ELSE FND = 1
END
NEXT VC
*
IF LFL AND NOT(ACT$STAT = "D" AND INDEX(BFS,"^",1)) AND NOT(TFL) THEN STAT.TY = 1
IF ACT$STAT = "D" AND ACT$CREDIT.STATUS LT MDQS THEN STAT.TY = 4
*
AGD = FIELD(ACT$AGED.AMTS,"*",1)
AGD<2> = FIELD(ACT$AGED.AMTS,"*",2)
AGD<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGD<4> = FIELD(ACT$AGED.AMTS,"*",4)
AGT = AGD<2>+AGD<3>+AGD<4>; IF CDEB THEN AGT = AGT+AGD<1>
*
IF NOT(ACT$STAT = "D" AND INDEX(BFS,"^",1)) THEN
EFT.BILLING = 0
TMP = ACT$PAY.METHOD; IF TMP[1,3] = "CUP" THEN TMP = "CUP"
IF TMP = "CUP" AND NOT(LFL) THEN RJT.FL = 4; RETURN; *** Account pays with coupons
IF TMP = "EFT" THEN
READ EFT FROM EFT.FILE,ACT.ID THEN
IF EFT<1> = "Y" THEN
EFT.BILLING = 1; TM.CN = 0
LOOP TM.CN = TM.CN + 1 WHILE ACT$BILL.FREQS<1,TM.CN> # "" AND EFT.BILLING DO
IF NOT(ACT$EFT.BILLING<0,TM.CN> = "Y" OR ACT$EFT.BILLING<0,TM.CN> = "B") THEN EFT.BILLING = 0
REPEAT
* END ELSE
* IF (EFT$STAT # "C" AND EFT$ERROR.FLAG # "E") AND NOT(SINGLE) THEN RJT.FL = 5; RETURN; *** No EFT NSFs or Errors found
* IF (EFT$ERROR.FLAG = "E" AND NOT(LFL)) AND NOT(SINGLE) THEN RJT.FL = 6; RETURN; *** NSF or Error found but not a late run
END
END
END
LOCATE TMP IN PYM<1> SETTING LOC THEN
IF PYM<7,LOC> # "N" THEN
*** Not a reprint, valid Bill Freq, due annual, late notice, or $ amt on trans.
IF NOT(TFL) AND NOT(LFL) AND NOT(SINGLE) THEN RJT.FL = 11; RETURN
END ELSE
IF (NOT(TMP = "EFT" AND NOT(EFT.BILLING))) OR (TMP = "EFT" AND EFT.BILLING) THEN
IF (RNTP = 2 AND NOT(LFL)) AND NOT(SINGLE) THEN RJT.FL = 13; RETURN; *** No statement for this Pay Method
END
END
IF RNTP = 1 OR (RNTP = 2 AND LFL) THEN
IF (NOT(TMP = "EFT" AND NOT(EFT.BILLING))) OR (TMP = "EFT" AND EFT.BILLING) OR TMP # "EFT" THEN
IF PYM<8,LOC> # "Y" THEN RJT.FL = 10; RETURN; *** No Late Notice for this Pay Method
END
*** Credit Status less than Min Delinq Credit Status
IF PYM<7,LOC> # "Y" AND PYM<8,LOC> = "Y" AND ABS(ACT$CREDIT.STATUS) LT MDQS AND NOT(SINGLE) THEN RJT.FL = 15; RETURN
END
END
END
IF NOT(SINGLE) THEN
*** Bal. less than Min Bal or less than Min days between Statements
IF ((AGT LT MDQA) OR (TDY-ACT$LAST.STMT.DATE LE DBTW)) AND NOT(RPR) THEN RJT.FL = 14; RETURN
END
*** Not a reprint, valid Bill Freq, due annual, late notice, or $ amt on trans.
IF NOT(RPR) AND NOT(BFS.FL) AND NOT(ANN.FL) AND NOT(LFL) AND NOT(ACT$STAT = "D" AND INDEX(BFS,"^",1)) AND NOT(CDEB) THEN RJT.FL = 11; RETURN
GOSUB GEN.STMT; RJT.FL = 0; * IF RPR OR (CDEB) OR SINGLE THEN GOSUB GEN.STMT; RJT.FL = 0
*
ACT.WRITE: *
IF MPG.RUN = -1 THEN MPG.RUN = "" ELSE IF (NOT(RPR) OR RECALC.DISC) AND NOT(RJT.FL) THEN MATWRITE ACT ON ACT.FILE,ACT.ID
RETURN
!
GEN.STMT: *
*
IF DSR THEN
PRINT CLB:"GEN.STMT":; INPUT TMP:
END
*
IF FIRST AND DISC.DATE = "CALC" THEN DISC.DATE = ""
*
IF NOT(DISC.DATE) THEN
L.B.DATE = ""; VC = 1
LOOP UNTIL ACT$BILL.FROM.DATES<1,VC> = "" DO
IF ACT$BILL.FROM.DATES<1,VC> GT L.B.DATE THEN L.B.DATE = ACT$BILL.FROM.DATES<1,VC>
VC = VC + 1
REPEAT
IF RPR AND NOT(RECALC.DISC) THEN L.B.MONTH = ST.PRDT ELSE L.B.MONTH = TDY
IF NOT(L.B.DATE) THEN L.B.DATE = L.B.MONTH
L.B.DAY = OCONV(L.B.DATE,"D2-")
L.B.DAY = L.B.DAY[4,2]
TMP1 = OCONV(L.B.MONTH,"D2-")
L.B.MONTH = TMP1[1,2]; CURR.YR = TMP1[7,2]
L.B.MONTH = L.B.MONTH-ACT$CREDIT.STATUS+1
IF L.B.MONTH LT 1 THEN L.B.MONTH = L.B.MONTH+12; CURR.YR = CURR.YR-1
L.B.DAY = ICONV(L.B.MONTH:"/":L.B.DAY:"/":CURR.YR,"D")
DISC.DATE = L.B.DAY+MDD
END
*
CALL MOD11.DIGIT(ACT.ID,CD); FID = ACT.ID:"-":CD
CLS.COL = 0; CLS.ROW = DISP.LN - 2; GOSUB CLS.ROUTINE
STMT.COUNT = STMT.COUNT + 1
PRINT @(0,DISP.LN):"Generating statement # ":STMT.COUNT:" for acct # no. ":ACT.ID:"-":CD:@(0,DISP.LN):
*
GOSUB SU.PL
IF MPG.RUN = -1 THEN STMT.COUNT = STMT.COUNT - 1
*
IF RPR OR MPG.RUN = -1 THEN RETURN
*
* SEND OLD TRANS. TO HISTORY
* IF STAT.TY # 1 AND NOT(SINGLE) THEN
IF STAT.TY # 1 THEN
LOCATE "S" IN ATR$TYPES<1> SETTING VC THEN
IF ATR$EFF.DATES<1,VC+1> # "" THEN
LOW.VC = VC+1
VC = COUNT(ATR$EFF.DATES,VM)+1; IF ATR$EFF.DATES<1,VC> = "" THEN VC = VC-1
MATREAD SAVE.ATR FROM ATH.FILE,ACT.ID ELSE MAT SAVE.ATR = ""
FOR VC = VC TO LOW.VC STEP -1
TM = ATR$EFF.DATES<1,VC>
DEL ATR$EFF.DATES<1,VC,0>
INS TM BEFORE SAVE.ATR$EFF.DATES<1,1>
TM = ATR$ENTRY.DATES<1,VC>; DEL ATR$ENTRY.DATES<1,VC,0>; INS TM BEFORE SAVE.ATR$ENTRY.DATES<1,1>
TM = ATR$ENTRY.PERIODS<1,VC>; DEL ATR$ENTRY.PERIODS<1,VC,0>; INS TM BEFORE SAVE.ATR$ENTRY.PERIODS<1,1>
TM = ATR$TYPES<1,VC>; DEL ATR$TYPES<1,VC,0>; INS TM BEFORE SAVE.ATR$TYPES<1,1>
TM = ATR$REFS<1,VC>; DEL ATR$REFS<1,VC,0>; INS TM BEFORE SAVE.ATR$REFS<1,1>
TM = ATR$TOTAL.AMTS<1,VC>; DEL ATR$TOTAL.AMTS<1,VC,0>; INS TM BEFORE SAVE.ATR$TOTAL.AMTS<1,1>
TM = ATR$DESCS<1,VC>; DEL ATR$DESCS<1,VC,0>; INS TM BEFORE SAVE.ATR$DESCS<1,1>
TM = ATR$SVC.TYPES<1,VC>; DEL ATR$SVC.TYPES<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.TYPES<1,1>
TM = ATR$SVC.QNTYS<1,VC>; DEL ATR$SVC.QNTYS<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.QNTYS<1,1>
TM = ATR$SVC.AMTS<1,VC>; DEL ATR$SVC.AMTS<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.AMTS<1,1>
TM = ATR$SVC.FROM.DATES<1,VC>; DEL ATR$SVC.FROM.DATES<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.FROM.DATES<1,1>
TM = ATR$SVC.TO.DATES<1,VC>; DEL ATR$SVC.TO.DATES<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.TO.DATES<1,1>
NEXT VC
MATWRITE SAVE.ATR ON ATH.FILE,ACT.ID
END
END
END
*
IF ACT$LAST.BILL.DATE THEN ADJ.BDT = ACT$LAST.BILL.DATE ELSE ADJ.BDT = TDY
CALL PACK.NUMBER(ADJ.BDT,TM); INS TM BEFORE ATR$EFF.DATES<1,1>
CALL PACK.NUMBER(TDY,TM); INS TM BEFORE ATR$ENTRY.DATES<1,1>
INS "" BEFORE ATR$ENTRY.PERIODS<1,1>
* IF SINGLE THEN DOCK = "I" ELSE DOCK = "S"; INS DOCK BEFORE ATR$TYPES<1,1>
INS "S" BEFORE ATR$TYPES<1,1>
TM = MGI[5,99]; INS TM BEFORE ATR$REFS<1,1>
CALL PACK.NUMBER(BLN,TM); INS TM BEFORE ATR$TOTAL.AMTS<1,1>
* TM = ""; IF SINGLE THEN TM = "Special Statement" ELSE IF STAT.TY = 1 THEN TM = "Late Notice"
IF STAT.TY = 1 THEN TM = "A" ELSE TM = ""
INS TM BEFORE ATR$DESCS<1,1>
INS "" BEFORE ATR$SVC.TYPES<1,1>
INS "" BEFORE ATR$SVC.QNTYS<1,1>
INS "" BEFORE ATR$SVC.AMTS<1,1>
INS "" BEFORE ATR$SVC.FROM.DATES<1,1>
INS "" BEFORE ATR$SVC.TO.DATES<1,1>
MATWRITE ATR ON ATR.FILE,ACT.ID
*
ACT$LAST.STMT.DATE = TDY
RETURN
!
GET.ADDRESSES: *
IF DSR THEN
PRINT CLB:"GET.ADDRESS":; INPUT TMP:
END
LCA = FIELD(ADD$GEOGRAPHIC.DATA,"*",4)
IF LCA # OLCA THEN
READ RTO.ADD FROM PAR.FILE,"REMIT.TO*":LCA ELSE RTO.ADD = ""
RTO.ADD1 = RTO.ADD<1>
RTO.ADD2 = RTO.ADD<2>
RTO.ADD3 = RTO.ADD<3>
OLCA = LCA
END
IF OPSYS = "R" THEN
IF SYS.TST<8> THEN DISPLAY = 1 ELSE DISPLAY = 0
CALL GET.NADDS(SYS.TST,DISPLAY,MAX.LINES,MAT ACT,MAT ADD,ACT.ID,ACT$ADD.ID,NAMES,SVC.ADD,SVC.LINE,BN,DROP.DESC,ERROR)
NAME = NAMES<1>
IF NOT(ERROR) THEN SN = NAMES:AM:SVC.ADD
IF BN = "" THEN BN = SN
END ELSE
LNM = FIELD(ACT$CUS.NAME,"*",1)
FNM = FIELD(ACT$CUS.NAME,"*",2)
TTL = FIELD(ACT$CUS.NAME,"*",3)
SN = TRIM(TTL:" ":FNM:" ":LNM); NAME = SN
*
STT.ID = FIELD(ACT$ADD.ID,"*",3)
IF STT.ID THEN
APT.NUM = FIELD(ACT$ADD.ID,"*",1)
HOUSE.NUM = FIELD(ACT$ADD.ID,"*",2)
READ STT FROM STT.FILE,STT.ID ELSE STT = ""
IF APT.NUM # "" THEN HOUSE.NUM = APT.NUM:"-":HOUSE.NUM
SN<2> = TRIM(HOUSE.NUM:" ":STT<1>)
SVC.LINE = SN<2>
LOCATE STT<2> IN CITIES<1> SETTING LC THEN CITY = CITIES<2,LC>:", ":CITIES<3,LC> ELSE CITY = ""
SN<3> = CITY
SN<4> = ADD$POST.CODE
END ELSE SN<2> = "Billing only"
*
BTDT = ""; BILL.TO.VC = ""
FOR VC = 1 TO 2
IF ACT$BILL.ADDR<1,VC> # "" THEN
BEFF = ACT$BILL.EFF.DATE<1,VC>
IF BEFF LE ST.PRDT AND (BTDT = "" OR BEFF LE BTDT) THEN
BILL.TO.VC = VC
BTDT = BEFF
END
END
NEXT VC
IF BILL.TO.VC = "" THEN BN = SN; GOSUB GET.PO.BOX ELSE
IF ACT$BILL.NAME<1,BILL.TO.VC> = "" THEN BN = SN<1> ELSE
BILL.NAME = ACT$BILL.NAME<1,BILL.TO.VC>
BN = TRIM(FIELD(BILL.NAME,"*",3):" ":FIELD(BILL.NAME,"*",2):" ":FIELD(BILL.NAME,"*",1))
END
BILL.ADDR = ACT$BILL.ADDR<1,BILL.TO.VC>
IF BILL.ADDR = "" THEN
BN<2> = SN<2>
GOSUB GET.PO.BOX
BN<3> = SN<3>
BN<4> = SN<4>
END ELSE
BN<2> = FIELD(BILL.ADDR,"*",1)
BN<3> = FIELD(BILL.ADDR,"*",2):", ":FIELD(BILL.ADDR,"*",3)
BN<4> = FIELD(BILL.ADDR,"*",4)
END
END
END
RETURN
!
GET.PO.BOX: *
IF ACT$PO.BOX # "" THEN
IF ACT$PO.BOX = "GD" THEN BN<2> = "General Delivery" ELSE BN<2> = "P.O. Box ":ACT$PO.BOX
END
RETURN
!
CALL.MENU: *
PRINT CLB:
EXECUTE "CALL.MENU"; * DON'T CHANGE
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TTL = "Statements - Print or reprint statements"
PRINT @(0,1):(SPACE(40-LEN(TTL)/2):TTL) "L#80":RVE:
PRINT @(0,6):
IF RPR THEN PRINT "Reprint": ELSE PRINT "New": 
PRINT " statements dated ":OCONV(ST.PRDT,"D2")
IF NOT(RPR) THEN PRINT @(0,8):CLL:"Disconnect date used for this statement run: ":OCONV(DISC.DATE,"D2"):
RETURN
!
~STAT.PRINT.6X85~
*CODE.SEGMENT:      STAT.PRINT.6X85
* VERSION: 890712
* DESCRIPTION:       PRINT STATEMENTS
*
*                    12 JUL 89  H. HORSMAN    FROM STATEMENTS.9.5X7.0
*
*
!
GEN.MASK: *
IF FIRST THEN
LATE.BAL.LINE = "Previous balance"
LOCATE "B" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN LATE.BAL.LINE = TMP
END
TMP = ""; THIRTY.DAY.MSG = ""
LOCATE "T" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN THIRTY.DAY.MSG = TMP
END
FOR ACR = 1 TO MXACR
IF ACR = 1 THEN FILLER = SPACE(2) ELSE FILLER = SPACE(7)
PL(ACR,6) = STR("X",30):"999999-9" "R#12":OCONV(TDY,"D2") "R#13"
PL(ACR,11) = SPACE(32):"DD-MMM-YY":"999.99-" "R#14"
PL(ACR,12) = FILLER:STR("X",30)
PL(ACR,13) = FILLER:STR("X",30)
PL(ACR,14) = FILLER:STR("X",30)
PL(ACR,15) = FILLER:STR("X",30)
PL(ACR,18) = THIRTY.DAY.MSG<1>
PL(ACR,21) = SPACE(40):"PAGE XX"
PL(ACR,24) = SPACE(37):"Due Date  DD-MMM-YY"
PL(ACR,27) = STR("X",30):"999999-9" "R#12":OCONV(TDY,"D2") "R#13"
FOR LN = 31 TO 45
PL(ACR,LN) = "DDMMMYY ":STR("X",37):"999.99-" "R#11"
NEXT LN
FOR LN = 47 TO 50
PL(ACR,LN) = STR("X",55)
NEXT LN
NEXT ACR
GOSUB PSTMTS
FIRST = ""
END
*
RETURN
!
SU.PL: *
PG = 1; LN = 31
GOSUB GET.ADDRESSES
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:CLB:"Entering SU.PL":; INPUT TMP:
END
PL(ACR,27) = SN<2> "L#30":FID "R#12":OCONV(TDY,"D2") "R#13"
PREV.BLN = ACT$BALANCE
GOSUB SU.TOP
DXP = ""; DMT = 0
*
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
PREV.BLN = PREV.BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
IF PREV.BLN NE 0 THEN
PL(ACR,LN) = PST.DATE "L#8":LATE.BAL.LINE "L#37":OCONV(PREV.BLN,"MR2M") "R#11"
END
*
BLN = PREV.BLN
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 45 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(ACR,LN) = EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#11"
END ELSE PL(ACR,LN) = EDT "L#8":TDE "L#36":OCONV(TMT,"MR2ZM") "R#12"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN
IF NOT(TTY = "W" AND STY1 = "c") THEN AMT = ""
END
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 45 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#25":" ":SDTS
PL(ACR,LN) = COMF:SPACE(19):SDE "L#41":OCONV(AMT,"MR2ZM") "R#11":REGF
END
SC = SC+1
REPEAT
END
END
NEXT VC
GOSUB SU.MG
TMP = LN
IF BMSG<2> # "" THEN TMP = TMP+1
IF BMSG # "" THEN TMP = TMP+2
IF TMP > 43 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF BLN > 0 THEN LC = 1 ELSE IF BLN LT 0 THEN LC = 2 ELSE LC = 3
IF LN < 44 THEN LN = LN+2 ELSE LN = LN+1
PL(ACR,LN) = SPACE(8):BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#11"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(ACR,LN) = "IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#12"
END
*
IF BMSG # "" THEN
LN = LN+2
PL(ACR,LN) = BMSG<1>[1,55]
LN = LN+1
PL(ACR,LN) = BMSG<2>[1,55]
END
IF LN < 45 THEN
PL(ACR,45) = "Payments received at our office after ":OCONV(TDY-1,"D0") "L#7":"do not show"
END
ACR = ACR+1; IF ACR > MXACR THEN GOSUB PSTMTS
RETURN
!
MPG: *
IF MPG.RUN THEN
PL(ACR,21) = SPACE(40):"PAGE ":PG
PL(ACR,45) = COMF:SPACE(19):"Continued on next page ...":REGF
ACR = ACR+1; IF ACR > MXACR THEN GOSUB PSTMTS
GOSUB SU.TOP; PG = PG+1
PL(ACR,24) = SPACE(40):"PAGE ":PG
PL(ACR,31) = COMF:SPACE(19):"... Continued from previous page":REGF
LN = 32
RETURN
END
*
MPG.IDS<-1> = ACT.ID
FOR LN = 1 TO 51; PL(ACR,LN) = ""; NEXT LN
RETURN
!
SU.MG: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"Entering SU.MG":; INPUT TMP:
END
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<3> = AMG<1>
ML<4> = AMG<2>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
BMSG = "";  ****
IF MG.LGTH(MN) > 2 THEN
BMSG<1> = ML<1>
BMSG<2> = ML<2>
IF BMSG<1> = "" AND BMSG<2> = "" THEN BMSG = ""
ML = AMG
END
FOR TMP = 47 TO 50
PL(ACR,TMP) = ML<TMP-46>[1,55]
NEXT TMP
RETURN
!
SU.TOP: *
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
IF ACT$CREDIT.STATUS EQ 1 AND ACT$STAT = "D" THEN PDD = "NOW DUE"
IF ACT$CREDIT.STATUS GT THEN PDD = "PAST DUE"
IF PDD = "" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END
END ELSE PDD = PYDD
IF ACR = 1 THEN FILLER = SPACE(2) ELSE FILLER = SPACE(7)
PL(ACR,6) = SN<2> "L#30":FID "R#12":OCONV(TDY,"D2") "R#13"
* PL(ACR,11) = SPACE(38):OCONV(ACT$BALANCE,"MR2M") "R#18"
PL(ACR,11) = SPACE(38):OCONV(ACT$BALANCE,"MR2M") "R#18"
PL(ACR,12) = FILLER:BN<1>
PL(ACR,13) = FILLER:BN<2>
PL(ACR,14) = FILLER:BN<3>
PL(ACR,15) = FILLER:BN<4>
PL(ACR,18) = THIRTY.DAY.MSG<1>
PL(ACR,24) = SPACE(37):"Due Date ":OCONV(PDD,"D2") "L#9"
*
RETURN
!
PSTMTS: *
IF (TEST.FL<1> # "" AND TEST.FL<5> # "") THEN PRINT BELL:"Entering PSTMTS":; INPUT TMP:
IF TEST.FL<7> EQ "" OR RPR THEN
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 6
LOOP
PTEMP = ""
FOR ACR = 1 TO MXACR
TEMP = PL(ACR,LN)
IF TRIM(TEMP) = "" THEN PTEMP = PTEMP:SPACE(60) ELSE
IF ACR = MXACR THEN PRINT PTEMP:TEMP: ELSE
IF TEMP[1,LEN(COMF)] # COMF THEN PRINT PTEMP:TEMP "L#60": ELSE PRINT PTEMP:TEMP:CR:REGF:SPACE(60*ACR):
PTEMP = ""
END
END
NEXT ACR
PRINT
UNTIL LN = 5 DO
LN = LN+1; IF LN > 51 THEN LN = 1
REPEAT
PRINT COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS NE "R" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
END
MAT PL = ""
ACR = 1
RETURN
!
FINISH: *
LN = 8
LOOP UNTIL LN = 30 DO
PL(ACR,LN) = SPACE(LN-3):OCONV(TDY,"D2"):" Count: ":STMT.COUNT
LN = LN+1
REPEAT
GOSUB PSTMTS
*
IF BAD.ACCTS<1> # "" THEN
CALL PRINTER.ON(STAT); IF STAT THEN STOP
PRINT "Accounts containing garbage: ":
AC = 1
LOOP UNTIL BAD.ACCTS<AC> = "" DO
PRINT BAD.ACCTS<AC>:" ":; AC = AC+1
REPEAT
PRINT
PRINTER OFF
END
*
IF REJECTED.ACCTS<1> # '' AND TEST.FL<5> NE '' THEN
CALL PRINTER.ON(STAT); IF STAT THEN STOP
PRINT
PRINT
PRINT "Accounts rejected in processing: "
AC = 1
LOOP UNTIL REJECTED.ACCTS<AC> = "" DO
PRINT REJECTED.ACCTS<AC,1> "L#10":REJECTED.ACCTS<AC,2> "L#4":REJECTED.DESC<REJECTED.ACCTS<AC,2>>
AC = AC + 1
REPEAT
PRINT
PRINTER OFF
* PRINT CLB:"Enter <CR> . . . ":; INPUT TMP:
* PRINT @(0,8):CLS
* PRINT
* PRINT "Accounts rejected in processing: ":
* PRINT
* AC = 1
* LOOP UNTIL REJECTED.ACCTS<AC> = "" DO
* PRINT REJECTED.ACCTS<AC,1> "L#10":REJECTED.ACCTS<AC,2> "L#4":REJECTED.DESC<REJECTED.ACCTS<AC,2>>[1,50]
* IF LEN(REJECTED.DESC<REJECTED.ACCTS<AC,2>>) > 50 THEN
* PRINT "     ":REJECTED.DESC<REJECTED.ACCTS<AC,2>>[51,70]
* END
* AC = AC + 1
* REPEAT
* PRINT
END
*
EXECUTE 'SP-ASSIGN'; * ULT ONLY
CLS.COL = 0; CLS.ROW = DISP.LN; GOSUB CLS.ROUTINE
STOP
!
*#
~STAT.PRINT.95X70~
*CODE.SEGMENT:      STAT.PRINT.95X70
* DESCRIPTION:       PRINT STATEMENTS
*
*                    31 MAY 87  D. HORSMAN    FROM STATEMENTS.9.5X7.0
*
*                    01 MAY 87  H. HORSMAN    ANALYST'S COMMENT
*                               THIS VERSION DOES NOT CONTAIN THE TEST OF
*                               PAY.METHOD STATEMENT FLAG. IF THE STATEMENT
*                               FLAG IS 'N', THEN NO STATEMENT SHOULD
*                               BE PRINTED FOR THE SUBSCRIBER!
*
*
*                    01 MAR 87  DAVID HORSMAN  Problem with disconnected
*                               Not receiving statements.
*
*                    25 SEP 86  BOB CONARROE  FROM STATEMENTS.9.5X7.3
*
*
!
9741: * GEN.MASK
IF FIRST THEN
PL(1,2) = SPACE(58):STR("X",22)
FOR LN = 4 TO 5
PL(1,LN) = STR("X",80)
NEXT LN
TM = STR("X",29):"999999-9" "R#9":OCONV(TDY,"D2") "R#11"
PL(1,8) = "XXX XXX ":STR("X",22):" ":TM
PL(1,13) = SPACE(8):STR("X",30):"999.99-" "R#36"
PL(1,14) = SPACE(8):STR("X",30)
PL(1,15) = SPACE(8):STR("X",30)
PL(1,16) = SPACE(8):STR("X",30)
PL(1,25) = SPACE(58):STR("X",22)
PL(1,28) = STR("X",30):" ":TM
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN PL(1,LN) = STR("X",44):" " ELSE PL(1,LN) = SPACE(47)
PL(1,LN) = PL(1,LN):CRCOM78:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB 9747
FIRST = ""
END
*
RETURN
!
9742: *
PG = 1
GOSUB 9734
GOSUB 9744
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(1,30) = CRCOM78:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 30
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#21":" ":SDTS
PL(1,LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(1,LN) = PL(1,LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB 9745
GOSUB 9746
GOSUB 9747
RETURN
!
9743: *
IF MPG.RUN THEN
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,42) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB 9746
FOR TM = 30 TO 42
PL(1,TM) = SPACE(47):PL(1,TM)
NEXT TM
GOSUB 9747
PG = PG+1
GOSUB 9744
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,30) = CRCOMF:"... Continued from previous page"
LN = 31
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
9744: *
SVC.LIST = ""
SVC.CN = 1
LOOP WHILE ACT$SERVICES<1,SVC.CN> # "" AND LEN(SVC.LIST) < 20 DO
IF SVC.CN > 1 THEN SVC.LIST = SVC.LIST:", "
SVC.LIST = SVC.LIST:ACT$SERVICES<1,SVC.CN>:" (":ACT$QNTYS<1,SVC.CN>+0:")"
SVC.CN = SVC.CN + 1
REPEAT
SALN = SN<2> "L#30":FID "R#8":OCONV(TDY,"D2") "R#11"
*
PL(1,2) = SPACE(58):TDSC(STAT.TY)
PL(1,25) = PL(1,2)
*
PL(1,4) = RTO.ADD1
PL(1,5) = RTO.ADD2
PL(1,8) = ADD$DWELLING.TYPE "L#4":FIELD(ACT$RATE.TYPE,"*",1) "L#4":SVC.LIST "L#22":" ":SALN
PL(1,28) = SN<1> "L#30":" ":SALN
RETURN
!
9745: *
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<5> = AMG<1>
ML<6> = AMG<2>
ML<7> = AMG<3>
ML<8> = AMG<4>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN
PL(1,LN) = (ML<LN-33>:SPACE(46))[1,46]:" ":PL(1,LN)
END ELSE PL(1,LN) = SPACE(47):PL(1,LN)
NEXT LN
RETURN
!
9746: *
PL(1,13) = SPACE(8):BN<1> "L#55"
IF PG # 1 OR NOT(MPG.RUN) THEN PL(1,13) = PL(1,13):OCONV(BLN,"MR2M") "R#11"
PL(1,14) = SPACE(8):BN<2>
PL(1,15) = SPACE(8):BN<3>
PL(1,16) = SPACE(8):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(1,20) = SPACE(59):OCONV(PDD,"D2")
RETURN
!
9747: *
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 2
LOOP
IF LN < 23 OR LN > 24 THEN
PTM = ""
TM = PL(1,LN)
IF TRIM(TM) # "" THEN
IF LN > 29 AND LN < 43 THEN PRINT TM:CR:REGF: ELSE PRINT TM:
END
PRINT
END
UNTIL LN = 1 DO
LN = LN+1; IF LN > 44 THEN LN = 1
REPEAT
PRINT CR:COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~STAT.PRINT.95X73~
*CODE.SEGMENT:      STAT.PRINT.95X73
* DESCRIPTION:       PRINT STATEMENTS
*
* AUTHOR:            31 MAY 87  D. HORSMAN  FROM STATEMENTS.9.5X7.3
*                               Split off validation and
*                               standardize all statement formats.
*
*
*
!
9741: * GEN.MASK
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF FIRST THEN
PL(1,2) = SPACE(58):STR("X",22)
FOR LN = 4 TO 5
PL(1,LN) = STR("X",80)
NEXT LN
TM = STR("X",29):"999999-9" "R#9":OCONV(TDY,"D2") "R#11"
PL(1,8) = "XXX XXX ":STR("X",22):" ":TM
PL(1,13) = SPACE(8):STR("X",30):"999.99-" "R#36"
PL(1,14) = SPACE(8):STR("X",30)
PL(1,15) = SPACE(8):STR("X",30)
PL(1,16) = SPACE(8):STR("X",30)
PL(1,25) = SPACE(58):STR("X",22)
PL(1,28) = STR("X",30):" ":TM
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN PL(1,LN) = STR("X",44):" " ELSE PL(1,LN) = SPACE(47)
PL(1,LN) = PL(1,LN):CRCOM78:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB 9747
FIRST = ""
END
*
RETURN
!
9742: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
PG = 1
GOSUB 9734
GOSUB 9744
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(1,30) = CRCOM78:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 30
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#21":" ":SDTS
PL(1,LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(1,LN) = PL(1,LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB 9745
GOSUB 9746
GOSUB 9747
RETURN
!
9743: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF MPG.RUN THEN
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,42) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB 9746
FOR TM = 30 TO 42
PL(1,TM) = SPACE(47):PL(1,TM)
NEXT TM
GOSUB 9747
PG = PG+1
GOSUB 9744
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,30) = CRCOMF:"... Continued from previous page"
LN = 31
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
9744: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
SVC.LIST = ""
SVC.CN = 1
LOOP WHILE ACT$SERVICES<1,SVC.CN> # "" AND LEN(SVC.LIST) < 20 DO
IF SVC.CN > 1 THEN SVC.LIST = SVC.LIST:", "
SVC.LIST = SVC.LIST:ACT$SERVICES<1,SVC.CN>:" (":ACT$QNTYS<1,SVC.CN>+0:")"
SVC.CN = SVC.CN + 1
REPEAT
SALN = SN<2> "L#30":FID "R#8":OCONV(TDY,"D2") "R#11"
*
PL(1,2) = SPACE(58):TDSC(STAT.TY)
PL(1,25) = PL(1,2)
*
PL(1,4) = RTO.ADD1
PL(1,5) = RTO.ADD2
PL(1,8) = ADD$DWELLING.TYPE "L#4":FIELD(ACT$RATE.TYPE,"*",1) "L#4":SVC.LIST "L#22":" ":SALN
PL(1,28) = SN<1> "L#30":" ":SALN
RETURN
!
9745: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
*
* THE FOLLOWING TEST WAS CHANGED TO TAKE INTO ACCOIUNT STATUS 'N'.
*
*GOOD HARV, (DH)* IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
IF ACT$STAT = "D" THEN MGI = "MSG.D" ELSE MGI = "MSG.C"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<5> = AMG<1>
ML<6> = AMG<2>
ML<7> = AMG<3>
ML<8> = AMG<4>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN
PL(1,LN) = (ML<LN-33>:SPACE(46))[1,46]:" ":PL(1,LN)
END ELSE PL(1,LN) = SPACE(47):PL(1,LN)
NEXT LN
RETURN
!
9746: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
PL(1,13) = SPACE(8):BN<1> "L#55"
IF PG # 1 OR NOT(MPG.RUN) THEN PL(1,13) = PL(1,13):OCONV(BLN,"MR2M") "R#11"
PL(1,14) = SPACE(8):BN<2>
PL(1,15) = SPACE(8):BN<3>
PL(1,16) = SPACE(8):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(1,20) = SPACE(59):OCONV(PDD,"D2")
RETURN
!
9747: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 2
LOOP
PTM = ""
TM = PL(1,LN)
IF TRIM(TM) # "" THEN
IF LN > 29 AND LN < 43 THEN PRINT TM:CR:REGF: ELSE PRINT TM:
END
PRINT
UNTIL LN = 1 DO
LN = LN+1; IF LN > 44 THEN LN = 1
REPEAT
PRINT CR:COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~STAT.PRINT.LINDSAY~
*CODE.SEGMENT:           STAT.PRINT.LINDSAY
* DESCRIPTION:       PRINT STATEMENTS (LINDSAY CATV FORMAT)
*
*                    08 MAR 88  MESSAGE UPPED FROM 45 TO 47 CHARACTERS.
*                               MESSAGE UPPED FROM 4 TO 6 LINES.
*
*                    31 MAY 87  D. HORSMAN    FROM STATEMENTS.LINDSAY
*
*                    01 MAY 87  H. HORSMAN    ANALYST'S COMMENT
*                               THIS VERSION DOES NOT CONTAIN THE TEST OF
*                               PAY.METHOD STATEMENT FLAG. IF THE STATEMENT
*                               FLAG IS 'N', THEN NO STATEMENT SHOULD
*                               BE PRINTED FOR THE SUBSCRIBER!
*
*                    01 MAR 87  DAVID HORSMAN  Problem with disconnected
*                               Not receiving statements.
*
*                    25 SEP 86  BOB CONARROE  FROM STATEMENTS.9.5X7.3
*
*                    ** FEB 87   BOB CONARROE **
*
!
9741: * GEN.MASK
IF FIRST THEN
PL(1,2) = SPACE(69):OCONV(TDY,"D2")
FOR LN = 4 TO 5
PL(1,LN) = SPACE(6): STR("X",72)
NEXT LN
PL(1,8) = SPACE(10):STR("X",25):SPACE(8):STR("X",22):SPACE(5):"999999-9"
PL(1,14) = SPACE(61):"$99999.99"
PL(1,16) = SPACE(10):STR("X",30)
PL(1,17) = SPACE(10):STR("X",30)
PL(1,18) = SPACE(10):STR("X",30)
PL(1,19) = SPACE(10):STR("X",30):SPACE(22):"DD MMM YY"
PL(1,31) = SPACE(69):OCONV(TDY,"D2")
PL(1,35) = PL(1,8)
FOR LN = 38 TO 50
IF LN # 44 THEN PL(1,LN) = C12.FONT.CR:STR("X",47)
NEXT LN
FOR LN = 38 TO 54
PL(1,LN) = PL(1,LN):CRCOM72:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB 9747
FIRST = ""
END
*
RETURN
!
9742: *
PG = 1
GOSUB 9734
GOSUB 9744
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(1,38) = CRCOM72:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 39
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 53 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(1,LN) = CRCOM72:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(1,LN) = CRCOM72:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 53 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#20":" ":SDTS
PL(1,LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(1,LN) = PL(1,LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 53 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 55 THEN
IF LN < 53 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB 9745
GOSUB 9746
GOSUB 9747
RETURN
!
9743: *
IF MPG.RUN THEN
PL(1,31) = SPACE(59):"PAGE ":PG:PL(1,31)[66,99]
PL(1,54) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB 9746
GOSUB 9747
PG = PG+1
GOSUB 9744
PL(1,31) = SPACE(59):"PAGE ":PG:PL(1,31)[66,99]
PL(1,38) = CRCOMF:"... Continued from previous page"
LN = 39
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
9744: *
PL(1,2) = SPACE(69):OCONV(TDY,"D2")
PL(1,31) = PL(1,2)
*
PL(1,4) = SPACE(6): RTO.ADD1
PL(1,5) = SPACE(6): RTO.ADD2
PL(1,8) = SPACE(10):SN<1> "L#30":SPACE(3):SN<2> "L#25":"  ":FID
PL(1,35) = PL(1,8)
RETURN
!
9745: *
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<7> = AMG<1>
ML<8> = AMG<2>
ML<9> = AMG<3>
ML<10> = AMG<4>
ML<11> = AMG<5>
ML<12> = AMG<6>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 38 TO 43
PL(1,LN) = C12.FONT.CR:ML<LN-37> "L#47":PL(1,LN)
NEXT LN
FOR LN = 45 TO 50
PL(1,LN) = C12.FONT.CR:ML<LN-38> "L#47":PL(1,LN)
NEXT LN
RETURN
!
9746: *
IF PG # 1 OR NOT(MPG.RUN) THEN PL(1,14) = SPACE(60):OCONV(BLN,"MR2M$") "R#10"
PL(1,16) = SPACE(10):BN<1>
PL(1,17) = SPACE(10):BN<2>
PL(1,18) = SPACE(10):BN<3>
PL(1,19) = SPACE(10):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
* REMOVE RTEMP FROM TM<1> AT 1 SETTING RFLAG; * REV ONLY
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(1,19) = PL(1,19) "L#62":OCONV(PDD,"D2")
RETURN
!
9747: *
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT LPI8
PRINT REGF
FOR LN = 2 TO 56
IF LN = 37 THEN PRINT C12.FONT.CR ELSE PRINT PL(1,LN)
NEXT LN
PRINTER OFF
CTR = CTR+1
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~STATUS.VAR.EQUATES~
*CODE.SEGMENT: STATUS.VAR.EQUATES
*
* FILE: STL      ID: STATUS.LOG
EQU STATUS.CHANNEL     TO 1; * CHANNEL #
EQU STATUS.CHAN.STAT   TO 2; * CHANNEL STATUS
EQU STATUS.DESC        TO 3; * CHANNEL DESCRIPTION
EQU STATUS.CHECKED     TO 4; * DT*TM OF LAST STATUS CHECK
EQU STATUS.SRVC        TO 5; * SERVICE ASSOC'T W THIS CHANNEL
EQU STATUS.FLAGGED     TO 6; * FLAG
*
*
EQU AI.UP TO "UP"
EQU AI.DN TO "DN"
EQU AI.ON TO "ON"
EQU AI.OFF TO "OFF"
*
~STD.DIM~
*CODE.SEGMENT: STD.DIM
*
DIM STD(50)
*
~STM.DIM~
*CODE.SEGMENT: ?
DIM STM(20)
~STM.VAR.EQUATES~
*CODE.SEGMENT: STM.VAR.EQUATES
*
* FILE 'STM' EQUATES - GENERATED 13:37:09  07 MAY 1991
EQU STM$ISSUE.DATE TO 1;                * DATE OF STATEMENT GENERATION
EQU STM$DUE.DATE TO 2;                  * PAYMENT DUE DATE
EQU STM$AMT.DUE TO 3;                   * PAYMENT AMOUNT DUE
EQU STM$FL.CODE TO 4;                   * FRANCHISE/LICENSE CODE
EQU STM$RATE.TYPE TO 5;                 * SUBSCRIBER'S RATE TYPE
EQU STM$DWELLING.TYPE TO 6;             * DWELLING TYPE OF SVC ADDRESS
EQU STM$SVC.ADDR TO 7;                  * HOUSE  STREET NAME  APT NUM
EQU STM$SUB.NAME TO 8;                  * SUB NAME AND ALT NAME
EQU STM$SVC.AT.ADDR TO 9;               * ACTIVE SERVICES OF SUBSCRIBER
EQU STM$ALL.ACCTS.MSG TO 10;            * THE 4 LINE ALL ACCOUNTS MESSAGE
EQU STM$OTHER.MSG.TYPE TO 11;           * C D AND P MESSAGE TYPES
EQU STM$OTHER.MSG.TEXT TO 12;           * 4 LINES OF OTHER MESSAGE TEXT
EQU STM$PCODE TO 13;                    * POSTAL/ZIP CODE OF MAILING ADDR
EQU STM$BILL.ADDR TO 14;                * MAILING ADDRESS OF THE SUBSCRIBER
EQU STM$PNS.MSG TO 15;                  * PMT REC'D AFTER 'DATE' NOT SHOWN
EQU STM$PREV.BAL TO 16;                 * BAL FWD FROM LAST STMT
EQU STM$TRANS.DATE TO 17;               * EFFECTIVE DATE OF THE TRANSACTION
EQU STM$TRANS.DESC TO 18;               * SVC DESC, FROM DATE, TO DATE
EQU STM$TRANS.AMT TO 19;                * TRANSACTION AMOUNT
~STT.DIM~
*CODE.SEGMENT: ?
DIM STT(10)
~STT.EQUATES~
*CODE.SEGMENT: ?
EQUATE STT$NAME TO STT(1)
EQUATE STT$CITY.NUM TO STT(2)
EQUATE STT$FIRST.HOUSE.NUMS TO STT(3)
EQUATE STT$LAST.HOUSE.NUMS TO STT(4)
EQUATE STT$VALID.HOUSE.NUMS TO STT(5)
EQUATE STT$ZONES TO STT(6)
EQUATE STT$GEO.DATA TO STT(7)
~STX.DIM~
*CODE.SEGMENT: ?
DIM STX(10)
~STX.EQUATES~
*CODE.SEGMENT: ?
* FILE 'STX' EQUATES - GENERATED 09:34:06  09 NOV 1983
EQU STX$STR.ID TO STX(1);               * STREET NUMBER
EQU STX$ADDRESS TO STX(2);              * STREET ADDRESS
~SVC.DIM~
*CODE.SEGMENT: SVC.DIM
*
DIM SVC(15)
~SVC.EQUATES~
*CODE.SEGMENT: SVC.EQUATES
*
* FILE 'SVC' EQUATES - GENERATED 13:23:09  03 MAY 1992
EQU SVC$DESC TO SVC(1);                 * DESCRIPTION OF SERVICE
EQU SVC$BILL.FREQS TO SVC(2);           * ALLOWED BILLING FREQUENCY
EQU SVC$DVC.FUNCS TO SVC(3);            * DEVICE FUNCTIONS REQUIRED FOR SERVICE
EQU SVC$COMPONENTS TO SVC(4);           * COMPONENT OF SERVICE
EQU SVC$REVERTS.TO TO SVC(5);           * SERVICE TO WHICH THIS SERVICE REVERTS
EQU SVC$RATE.AREAS TO SVC(6);           * AREAS FOR RATE AND TAX CALCULATION
EQU SVC$TAX.NAMES TO SVC(7);            * APPLICABLE TAX TABLES
EQU SVC$PRICES TO SVC(8);               * SELLING PRICE
EQU SVC$BILL.METHOD TO SVC(9);          * METHOD AND DAY OF BILLING
EQU SVC$MSG.TYPE TO SVC(10);            * STATEMENT MESSAGE TYPE
EQU SVC$BULK.CODE TO SVC(11);           * BULK CODE FOR REPORTING (E,I,N,S)
EQU SVC$BULK.QNTY TO SVC(12);           * STARTING OUTLET QNTY FOR BULK ACCOUNTS
EQU SVC$SUPP.RPT TO SVC(13);            * SUPPLIER REPORT TO BE PRINTED (Y,N)
EQU SVC$COUNT.FREE TO SVC(14);          * COUNTING OF FREE SERVICE (I,S)
~SVC.VAR.EQUATES~
*CODE.SEGMENT: SVC.VAR.EQUATES
*
* FILE 'SVC' EQUATES - GENERATED 13:23:10  03 MAY 1992
EQU SVC$DESC TO 1;                      * DESCRIPTION OF SERVICE
EQU SVC$BILL.FREQS TO 2;                * ALLOWED BILLING FREQUENCY
EQU SVC$DVC.FUNCS TO 3;                 * DEVICE FUNCTIONS REQUIRED FOR SERVICE
EQU SVC$COMPONENTS TO 4;                * COMPONENT OF SERVICE
EQU SVC$REVERTS.TO TO 5;                * SERVICE TO WHICH THIS SERVICE REVERTS
EQU SVC$RATE.AREAS TO 6;                * AREAS FOR RATE AND TAX CALCULATION
EQU SVC$TAX.NAMES TO 7;                 * APPLICABLE TAX TABLES
EQU SVC$PRICES TO 8;                    * SELLING PRICE
EQU SVC$BILL.METHOD TO 9;               * METHOD AND DAY OF BILLING
EQU SVC$MSG.TYPE TO 10;                 * STATEMENT MESSAGE TYPE
EQU SVC$BULK.CODE TO 11;                * BULK CODE FOR REPORTING (E,I,N,S)
EQU SVC$BULK.QNTY TO 12;                * STARTING OUTLET QNTY FOR BULK ACCOUNTS
EQU SVC$SUPP.RPT TO 13;                 * SUPPLIER REPORT TO BE PRINTED (Y,N)
EQU SVC$COUNT.FREE TO 14;               * COUNTING OF FREE SERVICE (I,S)
~SVS.DIM~
*CODE.SEGMENT: ?
DIM SVS(20)
~SVS.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SVS' EQUATES - GENERATED 10:38:23  28 MAR 1994
EQU SVS$MONTH.END.DATES TO SVS(1);      * MONTH END DATE FOR SERVICE COUNT
EQU SVS$MONTH.END.QNTYS TO SVS(2);      * MONTH END QUANTITY FOR SERVICE
EQU SVS$MONTH.END.COUNT TO SVS(3);      * MONTH END COUNT OF SERVICE
EQU SVS$UNREPORTED.DATES TO SVS(4);     * UNREPORTED SERVICE CHANGE DATES
EQU SVS$UNREPORTED.QNTYS TO SVS(5);     * UNREPORTED SERVICE QUANTITY CHANGE
EQU SVS$UNREPORTED.STARTS TO SVS(6);    * UNREPORTED START COUNT
EQU SVS$UNREPORTED.STOPS TO SVS(7);     * UNREPORTED STOP COUNT
EQU SVS$REPORTED.DATES TO SVS(8);       * LAST REPORTED SERVICE CHANGE DATES
EQU SVS$REPORTED.QNTYS TO SVS(9);       * LAST REPORTED SERVICE QUANTITY CHANGE
EQU SVS$REPORTED.STARTS TO SVS(10);     * LAST REPORTED START COUNT
EQU SVS$REPORTED.STOPS TO SVS(11);      * LAST REPORTED STOP COUNT
EQU SVS$NO.BASIC TO SVS(12);            * SUBS WITH NO BASIC SERVICE
EQU SVS$RATE.IDS TO SVS(13);            * RATE.IDS AT LAST MONTHEND UPDATE
EQU SVS$RATE.QNTYS TO SVS(14);          * QUANTIES AT LAST MONTHEND UPDATE
EQU SVS$RATE.COUNTS TO SVS(15);         * COUNTS BY QNTY AT LAST ME UPDATE
EQU SVS$FREE.RATE.IDS TO SVS(16);       * FREE RATE IDS
EQU SVS$FREE.RATE.QNTYS TO SVS(17);     * FREE RATE QNTYS
EQU SVS$FREE.RATE.COUNTS TO SVS(18);    * FREE RATE COUNTS
~SYS.COMM.WAIT.QUIET~
*CODE.SEGMENT: SYS.COMM.WAIT.QUIET
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Communications Design)
*
*   DATE: 10 FEB 89
*
* VARIABLES:
*        IN: COMM.WAIT.QUIET      -    Number of seconds continuous quiet
*            COMM.WAIT.MAX        -    Max length of wait
*            COMM.WAIT.ERROR      -    Max length error flag (null/1)
*            COMM.WAIT.PAUSE      -    # of RQMs to be performed
*            COMM.WAIT.CLEAR      -    Clear buffer if it exceeds
*                                       this # of char's.
*
* INITIALIZATION
CW.START.TIME = TIME()
CW.START.DATE = DATE()
* CURRENT # OF CHAR'S IN TYPE AHEAD BUFFER
BEGIN CASE
CASE OPSYS = "U"
CW.START.SYS11 = SYSTEM(11)
CASE OPSYS = "M"
CW.START.SYS11 = 1
CASE OPSYS = "R"
CW.START.SYS11 = 1
END CASE
*
CW.CONT.QUIET = 0
*
CW.LAST.SYS11 = CW.START.SYS11
CW.LAST.DATE  = CW.START.DATE
CW.LAST.TIME  = CW.START.TIME
*
*
* MAIN LOOP
LOOP
*
* DETERIME TOTAL ELP
CW.CURR.TIME = TIME()
CW.CURR.DATE = DATE()
IF CW.START.DATE NE CW.CURR.DATE THEN
CW.ELP = (CW.CURR.DATE-CW.START.DATE-1) * 86400 + 86400 - CW.START.TIME + CW.CURR.TIME
END ELSE
CW.ELP = ABS(CW.CURR.TIME-CW.START.TIME)
END
*@ PRINT "CW.ELP ":CW.ELP; *@
IF CW.ELP GT COMM.WAIT.MAX THEN COMM.WAIT.ERROR = 1
*@ PRINT "COMM.WAIT.ERROR ":COMM.WAIT.ERROR; *@
*
IF NOT(COMM.WAIT.ERROR) THEN
*
* CURRENT # OF CHAR'S IN TYPE AHEAD BUFFER
BEGIN CASE
CASE OPSYS = "U"
CW.CURR.SYS11 = SYSTEM(11)
CASE OPSYS = "M"
CW.CURR.SYS11 = 1
CASE OPSYS = "R"
CW.CURR.SYS11 = 1
END CASE
*
* DETERMINE CHANGE IN BUFFER
*
* # OF CHAR'S HAS CHANGED
IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
CW.LAST.SYS11 = CW.CURR.SYS11
CW.LAST.DATE  = CW.CURR.DATE
CW.LAST.TIME  = CW.CURR.TIME
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
*@ PRINT "CW.LAST.DATE ":CW.LAST.DATE; *@
*@ PRINT "CW.LAST.TIME ":CW.LAST.TIME; *@
IF CW.LAST.SYS11 GT COMM.WAIT.CLEAR AND COMM.WAIT.CLEAR THEN
INPUTCLEAR
CW.LAST.SYS11 = 0
CW.CURR.SYS11 = 1
END; * OF CLEAR
END ELSE
*
* BUFFER IS QUIET
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
IF CW.LAST.DATE NE CW.CURR.DATE THEN
CW.CONT.QUIET = (CW.CURR.DATE-CW.LAST.DATE-1) * 86400 + 86400 - CW.LAST.TIME + CW.CURR.TIME
END ELSE
CW.CONT.QUIET = ABS(CW.CURR.TIME-CW.LAST.TIME)
END
*@ PRINT "CW.CONT.QUIET ":CW.CONT.QUIET; *@
*
IF CW.LAST.SYS11 GT COMM.WAIT.CLEAR AND COMM.WAIT.CLEAR THEN
INPUTCLEAR
CW.LAST.SYS11 = 0
CW.CURR.SYS11 = 0
END; * OF CLEAR
*
END; * OF LAST.SYS11
*
END; * OF NOT(COMM.WAIT.ERROR)
*
WHILE NOT(COMM.WAIT.ERROR) AND CW.CONT.QUIET LT COMM.WAIT.QUIET DO
*
* Wait the required # of RQMs
FOR CW.TEMP = 1 TO COMM.WAIT.PAUSE
RQM
NEXT CW.TEMP
*
REPEAT
*
~SYS.COMMON~
*CODE.SEGMENT: SYS.COMMON
*
*
COMMON SYS.PROG,SYS.LOCT,SYS.SLOC,SYS.FILE,SYS.ITEM
COMMON FUNCTION,SUB.FUNCTION
COMMON SUBR.FUNCTION,SUBR.SUB.FUNCTION
COMMON CALL.FUNCTION,CALL.SUB.FUNCTION
COMMON USER.NAME,USER.CO.CODE
COMMON MENU.APPL,MENU.SUB.APPL,MENU.GRP.APPL
COMMON MENU.NAME,PRMPTING,TOPIC.KEY,MENU.CONTROL
COMMON TASK.NUM,TASK.STEP,TOPIC.ID,USER.KEY,PSD.KEY,SPTM.KEY,CTC.KEY
COMMON WAIT.FLAG,USER.MODE,USER.ABORT,SYS.ABORT,USER.LOCKED,CHECK.TIME
COMMON SYS.VALUES,SYS.ANSWERS,LAST.LOCT
COMMON SCH.FLAG,MSG.FLAG,TCL.FLAG,OFF.FLAG
COMMON CO.DATA,SY.FILE,PS.FILE,MENU.PARAMS,MENU.APPL.DESC
COMMON EXEC.VERB,EXEC.FILE.ITEM,MENU.FILE,MENU.SUBJCT,MENU.PREV
COMMON LCK.STAT,PORTD
COMMON STRUCT(120),USER.UPD(20)
*
*,MENU.EI.APPL,MENU.NUM,MENU.TYPE
*COMMON LO.D.M,HI.D.M,HI.S.M,LO.TCL.M,LO.T.M,HI.T.M,LO.O.M,HI.O.M,LO.M.M,HI.M.M,LO.S.M
*COMMON OFF.RSP,TCL.RSP,SYS.RSP,BELL,LF,FF,CR,SVM,VM,AM,WHO,PORT,ACCT,CLS,CLL
*,STAT.CHECK
*COMMON YES,NO,TRUE,FALSE,TERMINAL,RVB,RVE
*,MENU(25),SLOC(25),PRMPT(25),PORTD(25)
*,MODE.DESC(30),STAT.DESC(15)
*
*
~SYS.ERR.INIT~
*CODE.SEGMENT: SYS.ERR.INIT
*
* DAVID HORSMAN
*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
PORT.NUM = PORT.KEY
PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORTS.LIST.BUILD = 9
PORT.CONT = FALSE; PORT.TYPE = EMPTY; PORT.ON = FALSE
PORT.LOC = ONE; PORT.VC = ONE
*
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
TMP = EMPTY; TMP0 = EMPTY; TPM1 = EMPTY; TMP2 = EMPTY
*
*
TEXT = EMPTY; OUTPUTS = EMPTY
MSG.DISP = FALSE; MSG = EMPTY; MSG.N = ZERO
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY; COM.AI.ERR.TYPE = EMPTY
COM.AI.ERR.FUNC = EMPTY; COM.AI.ERR.DISP = ONE
COM.AI.RUN.ELP = ZERO; COM.AI.ON = EMPTY; COM.AI.UP = EMPTY
*
ERR.DISP.ONLY = FALSE; ERR.CLB = FALSE
ERR.CL = 31; ERR.LN = 5; ERR.LEN = 48; ERR.FMT = EMPTY
ERR.LN.MIN = 5; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CLS = FALSE; ERR.BELL = FALSE; ERR.CR = FALSE
ERR.HDR = "Error Messages "; ERR.TEXT = EMPTY
ERR.LAST = EMPTY; ERR.TMP = EMPTY
*
CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 18
CHECK.LEN = 33; CHECK.LN.HI = ZERO
*
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
*
LCK.ELP.MAX = 60
*
~SYS.ERROR.CONTROL~
*CODE.SEGMENT: SYS.ERROR.CONTROL
*
* AUTHOR: DAVID G. HORSMAN
*
!
*INCLUDE DH.BP SYS.ERROR.CONTROL
*
*
*
ERROR.CONTROL: * Subroutine to display & log errors
ERROR.CN = 0
ERROR.FATAL = 99
ERROR.READ = 0
ERROR.WRITE = 0
*
LOOP
ERROR.CN = ERROR.CN + 1
ERROR.TEXT1 = ERROR.TEXT<1>
ERROR.CODE1 = ERROR.CODE<1>
ERROR.CODE2 = ERROR.CODE<2>
*
WHILE LEN(ERROR.TEXT:ERROR.CODE) # 0 DO
PRINT @(0,21):CLS:@(0,23):
IF LEN(ERROR.CODE1) =0 THEN ERROR.CODE1 = 5
IF NOT(NUM(ERROR.CODE1)) THEN ERROR.CODE1 = 5
IF ERROR.CODE1 < 5 ! (ERROR.CODE1 > 10 & ERROR.CODE1 < 13) THEN PRINT BELL:
*
ERROR.DISP = TRIM((USER.NAME:", ":ERROR.TEXT1)[1,75])
PRINT ERROR.DISP:
*
IF ERROR.CODE1 < 3 THEN PRINT "!  ": ELSE
IF ERROR.CODE1 < 5 ! (ERROR.CODE1 > 10 & ERROR.CODE1 < 13) THEN
PRINT ".  ":
END ELSE
IF ERROR.CODE2 # "" THEN PRINT ", ": ELSE PRINT ".  ":
END
END
*
ERROR.RSP = ""
IF ERROR.CODE1 < 5 ! (ERROR.CODE1 > 10 & ERROR.CODE1 < 13) THEN
PRINT "Enter <CR>":BELL:
INPUT ERROR.RSP:
END ELSE RQM; RQM
*
IF ERROR.CODE1 < 3 THEN
FOR A = 1 TO 3
RQM
PRINT BELL:
NEXT A
END
*
IF NOT(ERROR.READ) THEN
READ ERROR.REC FROM SY.FILE,"@ERRORS@":USER.NAME ELSE ERROR.REC = ""
ERROR.READ = 1
END
*
*
*1 IS SCRUTINIZED
*2 IS PURGE
*3 IS ANY ACTIONS TO
*4 IS APPLICATION
*5 IS MENU NUMBER
*6 IS MENU OPTION
*7 IS PROGRAM NAME
*8 IS PROGRAM LOCATION
*9 IS PROGRAM SUB-LOCATION
*10 IS PORT
*11 IS ACCOUNT
*12 IS DATE
*13 IS TIME
*14 IS SEVERITY OF ERROR
*15 IS TEXT FOR DISPLAY
*16 IS WHAT USER TYPED IS RESPONSE TO 'ENTER <CR>'
*
*
IF ERROR.CODE < 11 THEN
ERROR.REC1 = "0":VM:"0":VM:VM:VM:VM:VM:SYS.PROG:VM:SYS.LOCT:VM:SYS.SLOC
ERROR.REC1 = ERROR.REC1:VM:PORT:VM:ACCT:VM:DATE():VM:TIME()
ERROR.REC1 = ERROR.REC1:VM:ERROR.CODE1:VM:ERROR.TEXT1:VM:ERROR.RSP:AM:ERROR.REC
ERROR.REC = ERROR.REC1
ERROR.REC1 = ""
END
*
IF ERROR.FATAL > ERROR.CODE1 THEN ERROR.FATAL = ERROR.CODE1
ERROR.CODE = DELETE(ERROR.CODE,1)
ERROR.TEXT = DELETE(ERROR.TEXT,1)
REPEAT
*
IF ERROR.READ & NOT(ERROR.WRITE) THEN
WRITE ERROR.REC ON SY.FILE,"@ERRORS@":USER.NAME
ERROR.WRITE =1
END
*
IF ERROR.FATAL = 1 THEN CHAIN "MENU-RUN OFF"
*
IF ERROR.FATAL = 2 THEN STOP
*
IF ERROR.FATAL = 3 THEN
FOR A = 1 TO 10
RQM
NEXT A
END
*
RETURN
*
!
~SYS.ERROR.STRUCT~
*CODE.SEGMENT: SYS.ERROR.STRUCT
*
!
*#INCLUDE DH.BP SYS.ERROR.CONTROL
*#
*#
*# ERROR.CODE1 = 0        DON'T DISPLAY (SECURITY)
*# ERROR.CODE1 = 1 OR 2   DISPLAY
*# ERROR.CODE1 = 3        SLAVE MODE DON'T INPUT
*# ERROR.CODE1 = 4        DIAL-UP PORT HUNG DON'T DISP OR INPUT
*#
*# ERROR.CODE2 = SEVERITY
*#
*# ERROR.CODE3 = WRITE FLAG
*#
*# ERROR.CODE4 = BELL FLAG
*#
*# ERROR.CODE5 = ENTRY FLAG (ERROR.RSP)
*#
*#
ERROR.CONTROL: *# Subroutine to display & log errors
ERROR.CN = 0
ERROR.FATAL = 99
*ERROR.READ = 0
*ERROR.WRITE = 0
*#
LOOP
ERROR.CN = ERROR.CN + 1
ERROR.TEXT1 = ERROR.TEXT<1>
ERROR.CODE1 = ERROR.CODE<1>[1,1]
ERROR.CODE2 = ERROR.CODE<1>[2,1]
ERROR.CODE3 = ERROR.CODE<1>[3,1]
ERROR.CODE4 = ERROR.CODE<1>[4,1]
ERROR.CODE5 = ERROR.CODE<1>[5,1]
*#
*#WHILE LEN(ERROR.TEXT:ERROR.CODE) DO
IF LEN(ERROR.TEXT<2>:ERROR.CODE<2>) THEN ERROR.MORE = 1 ELSE ERROR.MORE = 0
IF LEN(ERROR.TEXT:ERROR.CODE) THEN
*#
IF ERROR.CODE2 LT 4 AND ERROR.CODE1 THEN ERROR.CODE3 = 1
*#
IF STRUCT(27)<1,PORT+1> GT 0 AND STRUCT(27)<1,PORT+1> LT 11 THEN ERROR.CODE1 = 3
*#
IF ERROR.CODE1 AND ERROR.CODE1 LT 4 THEN
ERROR.LN = ERROR.CODE[6,2]
IF NOT(NUM(ERROR.LN)) THEN ERROR.LN = 22
IF NOT(LEN(ERROR.LN)) OR ERROR.LN LT 0 THEN ERROR.LN = 22
ERROR.CL = ERROR.CODE[8,2]
IF NOT(NUM(ERROR.CL)) THEN ERROR.CL = 0
IF NOT(LEN(ERROR.CL)) OR ERROR.CL LT 0 THEN ERROR.CL = 0
IF ERROR.CODE2 LT 4 THEN
ERROR.LN = 10
PRINT @(0,5):CLS:BELL:
RQM
PRINT BELL:
ERROR.CODE5 = 1
END
*#PRINT @(0,21):CLL:
IF NOT(ERROR.CL) THEN PRINT @(0,ERROR.LN):CLL:
PRINT @(ERROR.CL,ERROR.LN):
IF ERROR.CODE4 THEN PRINT BELL:; RQM
IF ERROR.CODE1 EQ 1 THEN
ERROR.DISP = TRIM((USER.NAME:", ":ERROR.TEXT1)[1,75])
ERROR.DISP = RVB:"[=| ":RVE:ERROR.DISP
END ELSE ERROR.DISP = RVB:"[=| ":RVE:TRIM(ERROR.TEXT1)
IF ERROR.CODE2 LT 4 THEN PRINT RVB:
PRINT ERROR.DISP:
IF ERROR.CODE2 LT 4 THEN PRINT "!  ": ELSE
IF ERROR.CODE5 EQ 1 THEN
PRINT ".  ":
END ELSE IF ERROR.CODE1 NE 2 THEN
IF ERROR.MORE THEN PRINT ", ": ELSE IF NOT(ERROR.CODE5) THEN PRINT ".":
END ELSE
PRINT " ":
END
END
IF ERROR.CODE2 LT 4 THEN PRINT RVE:
END
*#
*#
ERROR.RSP = ""
IF ERROR.CODE5 AND ERROR.CODE1 AND ERROR.CODE1 LT 3 THEN
ERROR.LEN = ERROR.CODE[10,3]
IF ERROR.LEN EQ '' OR NOT(NUM(ERROR.LEN)) THEN ERROR.LEN = 50
IF ERROR.LEN LT 1 THEN ERROR.LEN = 50
IF ERROR.CODE5 EQ 1 THEN PRINT "Enter <CR>   ":
FOR TEMP = 1 TO 10 UNTIL SYSTEM(11) OR ERROR.CODE5 EQ 2
IF NOT(SYSTEM(11)) THEN RQM
NEXT TEMP
IF SYSTEM(11) OR ERROR.CODE2 LT 6 OR ERROR.CODE5 EQ 2 THEN
*#INPUT ERROR.RSP:
OLD.RSP = ERROR.RSP
IF ERROR.CL+ERROR.LEN GT 80 THEN ERROR.LEN = 79 - ERROR.CL
IF ERROR.CODE5 EQ 2 THEN ERROR.FORCE = 1 ELSE ERROR.FORCE = 0
CALL SYS.LINE.INPUT(ERROR.CL+LEN(ERROR.DISP)+1,ERROR.LN,ERROR.LEN,OLD.RSP,ERROR.RSP,0,1,1,ERROR.FORCE)
IF INDEX(OFF.RSP,"*":ERROR.RSP:"*",1) OR INDEX(TCL.RSP,"*":ERROR.RSP:"*",1) THEN
PRINT @(0,23):CLL:RVB:"[SYSTEM DEBUG|> ":RVE:
INPUT TEMP.RSP:
IF TEMP.RSP EQ 'APEX ABORT' THEN
IF INDEX(OFF.RSP,"*":ERROR.RSP:"*",1) THEN EXECUTE "OFF"
IF INDEX(TCL.RSP,"*":ERROR.RSP:"*",1) THEN STOP
RETURN
END; *# OF APEX ABORT
END; *# OF OFF OR TCL COMMAND
END ELSE ERROR.RSP = "" ; *# OF SYSTEM(11) OR ERROR.CODE2 LT 6
END; *# OF ERROR.CODE5 AND ERROR.CODE1 AND ERROR.CODE1 LT 3
*#
WAIT.TEMP = WAIT.FLAG - 1
IF NOT(NUM(WAIT.TEMP)) THEN WAIT.TEMP = 3
IF WAIT.TEMP LT 0 THEN WAIT.TEMP = 0
IF NOT(LEN(WAIT.TEMP)) THEN WAIT.TEMP = 3
FOR A = 1 TO WAIT.TEMP UNTIL SYSTEM(11); RQM; NEXT A
*#
*#
IF ERROR.CODE3 THEN
*IF NOT(ERROR.READ) THEN
READV NEXT.ERROR FROM SY.FILE,"@ERRORS@":USER.NAME,1 ELSE NEXT.ERROR = 2
*ERROR.READ = 1
*END
*#
*#1 IS SCRUTINIZED
*#2 IS PURGE
*#3 IS ANY ACTIONS TO
*#4 IS APPLICATION
*#5 IS MENU NUMBER
*#6 IS MENU OPTION
*#7 IS PROGRAM NAME
*#8 IS PROGRAM LOCATION
*#9 IS PROGRAM SUB-LOCATION
*#10 IS PORT
*#11 IS ACCOUNT
*#12 IS DATE
*#13 IS TIME
*#14 IS SEVERITY OF ERROR
*#15 IS TEXT FOR DISPLAY
*#16 IS WHAT USER TYPED IS RESPONSE TO 'ENTER <CR>'
*#
*#
ERROR.REC = '0':VM:'0':VM:STRUCT(5):VM:MENU.APPL:VM:MENU.CONTROL<1,9>:VM:PRMPTING
ERROR.REC = ERROR.REC:VM:SYS.PROG<1>:VM:SYS.LOCT<1>:VM:SYS.SLOC<1>:VM
ERROR.REC = ERROR.REC:PORT:VM:ACCT:VM:DATE():VM:TIME()
ERROR.REC = ERROR.REC:VM:ERROR.CODE<1>:VM:ERROR.TEXT1:VM:ERROR.RSP
*#
WRITEV ERROR.REC ON SY.FILE,"@ERRORS@":USER.NAME,NEXT.ERROR
NEXT.ERROR = NEXT.ERROR + 1
WRITEV NEXT.ERROR ON SY.FILE,"@ERRORS@":USER.NAME,1
*ERROR.WRITE =1
ERROR.REC = ""
END
*#
IF NUM(ERROR.CODE2) THEN
IF ERROR.FATAL GT ERROR.CODE2 THEN ERROR.FATAL = ERROR.CODE2
END
*#
ERROR.CODE = DELETE(ERROR.CODE,1)
ERROR.TEXT = DELETE(ERROR.TEXT,1)
*#
*REPEAT
END; *# OF LEN(ERROR.TEXT:ERROR.CODE)
WHILE ERROR.MORE DO REPEAT
*#
*IF ERROR.WRITE THEN WRITEV NEXT.ERROR ON SY.FILE,"@ERRORS@":USER.NAME,1
IF NOT(NUM(ERROR.FATAL)) THEN ERROR.FATAL = 0
IF ERROR.FATAL EQ 1 THEN EXECUTE "OFF"
IF ERROR.FATAL EQ 2 THEN STOP
IF ERROR.FATAL EQ 3 THEN PRINT BELL:
ERROR.TEXT = ''
RETURN
*#
!
*#
SYS.CLEAR.PAGE.MID: *#
FOR TEMP = CLS.LO TO CLS.HI WHILE NOT(SYSTEM(11)) OR TEMP LT 14
PRINT @(0,TEMP):CLL:RVB:"[":@(79):RVB:"]":RVE:
NEXT TEMP
CLS.HI = 20
CLS.LO = 5
*#
RETURN; *# from gosub...
*#
!
~SYS.HEADING~
*CODE.SEGMENT: SYS.HEADING
*
* AUTHOR: DAVID G. HORSMAN
*
TEMP = 0
TEMP1 = 0
TEMP2 = 0
SCR.PORT = ""
SCR.UPD = ""
SCR.CNTR = ""
*
IF STRUCT(25)<1,PORT+1> THEN
*
IF STRUCT(70) > 0 THEN SCR.CNTR = (STRUCT(70)-1)[1,1] ELSE SCR.CNTR = "s"
IF STRUCT(91) > 0 THEN SCR.CNTR = SCR.CNTR:(STRUCT(91)-1)[1,1] ELSE SCR.CNTR = SCR.CNTR:"m"
IF WAIT.FLAG THEN SCR.CNTR = SCR.CNTR:WAIT.FLAG[1,1] ELSE SCR.CNTR = SCR.CNTR:"w"
*
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF STRUCT(21)<1,TEMP> # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVE
SCR.PORT = SCR.PORT:STRUCT(21)<1,TEMP>[1,1]
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVB; TEMP1 = 2
END ELSE
SCR.PORT = SCR.PORT:"o"
END
REPEAT
SCR.PORT = SCR.PORT[1,10+TEMP1]
*
TEMP = 0
TEMP2 = 0
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF USER.UPD(TEMP) # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVE
SCR.UPD = SCR.UPD:USER.UPD(TEMP)[1,1]
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVB; TEMP2 =TEMP2 + 2
END ELSE
SCR.UPD = SCR.UPD:"o"
END
REPEAT
SCR.UPD = SCR.UPD[1,10+TEMP2]
*
END
*
*
IF OUT.TO.PRINT = 1 THEN
PRINTER ON
PRINT FF
MAX.COL = 132
MAX.LN = 60
END ELSE
*
*# LINE 0 - LINE 0 - LINE 0
PRINT @(0,0):CLL:RVB: ; *#
MAX.COL = 80
MAX.LN = 20
END
*
*
PRINT (OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS")) "L#20": ; *#
PRINT (PORT:".":ACCT:".":STRUCT(2)) "L#13":" ": ; *#
*
IF STRUCT(25)<1,PORT+1> THEN PRINT " ":MODE.DESC(USER.MODE) "L#5":" ": ELSE PRINT SPACE(7): ; *#
PRINT MENU.APPL.DESC "L#39":
*#
*#v
*# LINE 1 - LINE 1 - LINE 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,1):RVB:CLL: ; *#
END
*#^
IF STRUCT(25)<1,PORT+1> THEN 
PRINT "[P ": ; *#
TEMP3 = "R#":(TEMP1+10)
PRINT SCR.PORT TEMP3: ; *#
PRINT "]": ; *#
END ELSE PRINT SPACE(14): ; *#
*
*
IF STRUCT(25)<1,PORT+1> THEN
PRINT "[U ": ; *#
TEMP3 = "L#":(TEMP2+10)
PRINT SCR.UPD TEMP3: ; *#
PRINT "]": ; *#
END ELSE PRINT SPACE(14): ; *#
IF STRUCT(25)<1,PORT+1> THEN PRINT ("[":SCR.CNTR[1,3]:"]") "L#5": ELSE PRINT SPACE(5): ; *#
PRINT "  ":
*# 40 CHARS AVAIL.
PRINT MENU.CONTROL<1,1> "L#45": ; *#
*
*# LINE 2 - LINE 2 - LINE 2
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,2):CLL: ; *#
END
PRINT CO.DATA<1,1,1> "L#35": ; *#
PRINT SYS.PROG.DESC "L#45": ; *#
*# LINE 3 - LINE 3 - LINE 3
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,3):CLL: ; *#
END
LN = 3
*
*
IF NOT(OUT.TO.PRINT) THEN PRINT RVE: ELSE PRINT
TEMP = 0
LOOP TEMP = TEMP + 1 WHILE LEN(SCR.HEADING<TEMP>) # 0 DO
PRINT SCR.HEADING[1,MAX.COL-1]: ; *#
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE PRINT @(0,LN):CLL: ; *#
REPEAT
*
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN
PRINT
PRINTER OFF
END ELSE
PRINT @(0,LN):CLS: ; *#
END
*
RETURN
*#**
*#**
~SYS.INCL.11.ABORT~
*CODE.SEGMENT: SYS.INCL.11.ABORT
*
*#$INCLUDE DH.IBP SYS.INCL.11.ABORT
*#
*#
IF SYSTEM(11) THEN
PRINT @(0,22):CLL:BELL:"Yes? ":
INPUT TEMP.RSP:
IF TEMP.RSP EQ "END" OR TEMP.RSP EQ "CAN" OR TEMP.RSP EQ "KILL" OR TEMP.RSP EQ CHAR(27) THEN
USER.ABORT = 1
END ELSE IF TEMP.RSP NE "" THEN
EXECUTE TEMP.RSP
END
END
*#
~SYS.INCL.14.BUSY~
*CODE.SEGMENT: SYS.INCL.14.BUSY
*#
*# DAVID HORSMAN - 31 MAR 88
*# 
STRUCT(14) = PORT+1
STRUCT(27)<1,PORT+1> = 11
*#
WRITEV STRUCT(14) ON SY.FILE,"@SYS@USER@":USER.NAME,14
*#
~SYS.INCL.142127~
*CODE.SEGMENT: SYS.INCL.142127
*#
*# DAVID HORSMAN - 31 MAR 88
*# 
READV STRUCT(14) FROM SY.FILE,"@SYS@USER@":USER.NAME,14 ELSE STRUCT(14) = F
READV TEMP1 FROM SY.FILE,"@SYS@USER@":USER.NAME,21 ELSE TEMP1 = F
READV TEMP FROM SY.FILE,"@SYS@USER@":USER.NAME,27 ELSE TEMP = F
*#
IF STRUCT(14) THEN
PRINT @(44,23):RVB:" | Cport":STRUCT(14)-1 "R#2":" | ":RVE:@(75):RVB:" |=]":RVE:
CPORT = STRUCT(14)
END
*#
*#
IF STRUCT(14) NE PORT+1 AND NOT(SYSTEM(11)) THEN
IF TEMP<1,PORT+1> LT 1 OR TEMP<1,PORT+1> GT 11 THEN
LOOP WHILE TEMP<1,PORT+1> LE 0 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> + 10 REPEAT
LOOP WHILE TEMP<1,PORT+1> GE 11 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> - 10 REPEAT
STRUCT(27) = TEMP
WRITEV TEMP ON SY.FILE,"@SYS@USER@":USER.NAME,27
END
END ELSE
*
LOOP WHILE TEMP<1,PORT+1> LE 10 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> + 10 REPEAT
LOOP WHILE TEMP<1,PORT+1> GT 21 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> - 10 REPEAT
FOR A = 1 TO 20 UNTIL NOT(LEN(TEMP1<1,A>))
IF A NE PORT+1 AND TEMP1<1,A> AND TEMP<1,A> GE 11 THEN TEMP<1,A> = 4; TEMP1<1,A> = 4
NEXT A
STRUCT(14) = PORT+1
WRITEV STRUCT(14) ON SY.FILE,"@SYS@USER@":USER.NAME,14
STRUCT(27) = TEMP
WRITEV TEMP ON SY.FILE,"@SYS@USER@":USER.NAME,27
STRUCT(21) = TEMP1
WRITEV TEMP1 ON SY.FILE,"@SYS@USER@":USER.NAME,21
PRINT @(44,23):RVB:" | Cport":STRUCT(14)-1 "R#2":" | ":RVE:@(75):RVB:" |=]":RVE:
CPORT = STRUCT(14)
END; * of slave/controlling port (0-10 / 11-20)
*#
*#
~SYS.INCL.21.BUSY~
*CODE.SEGMENT: SYS.INCL.21.BUSY
*#
*# DAVID HORSMAN - 31 MAR 88
*# 
READV STRUCT(21) FROM SY.FILE,"@SYS@USER@":USER.NAME,21 ELSE STRUCT(21) = F
*#
IF STRUCT(21)<1,PORT+1> EQ 5 THEN STRUCT(21)<1,PORT+1> = 6
IF STRUCT(21)<1,PORT+1> EQ 1 THEN STRUCT(21)<1,PORT+1> = 2
*#
WRITEV STRUCT(21) ON SY.FILE,"@SYS@USER@":USER.NAME,21
*#
~SYS.INCL.21.CHECK~
*CODE.SEGMENT: SYS.INCL.21.CHECK
*#
*# subroutine to check if a reset is required
*# 
*# 
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@USER@":STRUCT(2)
*#
READV STRUCT(21) FROM SY.FILE,SYS.ITEM,21 THEN
IF STRUCT(21)<1,PORT+1> EQ F THEN STRUCT(21)<1,PORT+1> = T
END ELSE
STRUCT(21)<1,PORT+1> = 9
WRITEV STRUCT(21) ON SY.FILE,SYS.ITEM,21
END
*#
IF (STRUCT(21)<1,PORT+1> GE 3 AND STRUCT(21)<1,PORT+1> LE 4) OR STRUCT(21)<1,PORT+1> GT 6 THEN
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "RESET"
GOSUB RECORD.USER.CALL
*#RSP = MENU.NAME
RSP = F
END
*# 
IF PORTD<5> NE "D" THEN PRINT @(4,23):RVB:" | C Reset | ":RVE:
*#
~SYS.INCL.ABORT.CHECK~
*CODE.SEGMENT: SYS.INCL.ABORT.CHECK
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: APR 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF ABORT.OK THEN
*
CP<ABORT.PRESENT> = "Abort is: ":ABORT.FLAG<ONE>
IF COUNT(ABORT.FLAG,AM) GE TWO THEN
IF NUM(ABORT.FLAG<TWO>) AND NUM(ABORT.FLAG<3>) THEN
IF (ABORT.FLAG<TWO> AND DATE() GT ABORT.FLAG<TWO>) OR (DATE() GE ABORT.FLAG<TWO> AND TIME() GE ABORT.FLAG<3>) THEN
IF ABORT.DEL THEN DELETE PAR.FILE,"TRANSFER.ABORT":PORT
ABORT.OK = FALSE
END; *# of date/time
END
END
*
IF ABORT.OK THEN
IF NUM(ABORT.FLAG<ONE>) THEN DONE.FLAG = ABORT.FLAG<ONE> ELSE DONE.FLAG = ABORT.PRESENT
MAX = DCOUNT(ITEM,AM)
IF ITEM[1,1] NE ESC AND ITEM[1,1] NE "@" THEN
ITEM = ESC:"ABORT"; MAX = ONE; CN = ZERO
END ELSE
IF ITEM<MAX> NE ESC:"END" THEN MAX = MAX + ONE
ITEM<MAX> = ESC:"ABORT"
END
ITEM<-ONE> = ESC:"END"; MAX = MAX + ONE
TMP = TRIM(ABORT.FLAG<ONE>[ONE,4])
IF TMP EQ "OFF" THEN STAT = LOGOFF.COMMAND
END ELSE ABORT.FLAG = EMPTY
*
END ELSE
ABORT.FLAG = EMPTY
IF DONE.FLAG EQ ABORT.PRESENT THEN DONE.FLAG = FALSE
END
*      
~SYS.INCL.ABORT.CHECK.READ~
*CODE.SEGMENT: SYS.INCL.ABORT.CHECK.READ
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: APR 89
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
READ ABORT.FLAG FROM PAR.FILE,FKEY.ID THEN FKEY.FOUND = TRUE; ABORT.OK = TRUE; ABORT.DEL = FALSE ELSE ABORT.OK = FALSE; ABORT.DEL = FALSE; FKEY.FOUND = FALSE
*
~SYS.INCL.ACC.OPSYS~
*CODE.SEGMENT: SYS.INCL.ACC.OPSYS
*
* AUTHOR: David Horsman
* COMPANY: Macroscope Design Matrix
* RELEASED: 15 June 91
*
* Copyright (c) 1992 All rights reserved
*
READ ACC.FMT.REC FROM COM.FILE,"ACC.FMT" THEN
*
ACC.FILE.DICT = ACC.FMT.REC<ONE>
ACC.FILE.NAME = ACC.FMT.REC<TWO>
ACC.ID = ("000":PORT) "R#3"
ACC.AM.DESC = ACC.FMT.REC<4>
ACC.AM.DT = ACC.FMT.REC<5>
ACC.AM.TM = ACC.FMT.REC<6>
ACC.AM.VERB = ACC.FMT.REC<7>
ACC.DESC.FMT = ACC.FMT.REC<8>
*
END ELSE
*
*
BEGIN CASE
*
CASE OPSYS EQ "M"
ACC.FILE.DICT = "DICT"
ACC.FILE.NAME = "ACC"
ACC.ID = ("000":PORT) "R#3"
ACC.AM.DESC = 4
ACC.AM.DT = 5
ACC.AM.TM = 6
ACC.AM.VERB = 7
ACC.DESC.FMT = "L#30"
*
CASE OPSYS EQ "U"
ACC.FILE.DICT = "DICT"
ACC.FILE.NAME = "ACC"
ACC.ID = "MENU.":("000":PORT) "R#3"
ACC.AM.DESC = 4
ACC.AM.DT = 5
ACC.AM.TM = 6
ACC.AM.VERB = 7
ACC.DESC.FMT = "L#30"
*
CASE OPSYS EQ "R"
ACC.FILE.DICT = EMPTY
ACC.FILE.NAME = "LISTS"
ACC.ID = "PORT.":("000":PORT) "R#3"
ACC.AM.DESC = ONE
ACC.AM.DT = 5
ACC.AM.TM = 6
ACC.AM.VERB = 7
ACC.DESC.FMT = "L#30"
*
CASE TRUE
ACC.FILE.DICT = EMPTY
ACC.FILE.NAME = "SYS"
ACC.ID = "PORT.":("000":PORT) "R#3"
ACC.AM.DESC = ONE
ACC.AM.DT = TWO
ACC.AM.TM = 3
ACC.AM.VERB = 4
ACC.DESC.FMT = "L#30"
STOP
*
END CASE
*
END; * 
*
~SYS.INCL.ACK.OR.SEND~
*CODE.SEGMENT: SYS.INCL.ACK.OR.SEND
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 23 SEP 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
ACK.RSP.INPUT: * Subroutine to input ACK.RSP
*
B = ZERO
IF ACK.RSP NE "GO" THEN ACK.RSP = ""
VALID.PKT = ZERO
*
LOOP
*
A = ZERO
TMP = ERR.CN
IF DIR.FLAG EQ DOUT THEN TMP = INT(TMP/TWO)
IF TMP LE ERR.LOW THEN TMP = ERR.LOW
IF TMP GT ERR.HI AND ERR.HI THEN TMP = ERR.HI
TMP = TMP + ERR.IN.OFFSET
CHAR.PAUSE = TMP * (ONE+TMP/10) * 20
LOOP
*
A = A + ONE
ACK.CHAR.CN = SYSTEM(ELEVEN); * ULT ONLY
*%%MDD%%=ACK.CHAR.CN = SYSTEM(14)
*
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT CHAR.PAUSE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
*
IF A GT 47 THEN RQM; * IF DIR.FLAG EQ DOUT THEN RQM
ACK.CHAR.CN1 = SYSTEM(ELEVEN); * ULT ONLY
*%%MDD%%=ACK.CHAR.CN1 = SYSTEM(14)
*
WHILE A LE 50 AND ACK.RSP EQ "" AND (ACK.CHAR.CN NE ACK.CHAR.CN1 OR ACK.CHAR.CN LT 4) AND ACK.CHAR.CN LT LINE.MAX.LEN+15 DO REPEAT
*
IF A LT 50 THEN
*
IF ACK.RSP EQ "" THEN ACK.RSP = "?NO RSP?"
*
* ACK.CHAR.CN1 = SYSTEM(ELEVEN); * ULT ONLY
* *%%MDD%%=ACK.CHAR.CN1 = SYSTEM(14)
*
IF ACK.CHAR.CN1 GT 4 THEN
*
B = B + ONE
*
INPUT ACK.RSP,ACK.CHAR.CN1 - ONE:
*
LOOP UNTIL NOT(LEN(ACK.RSP)) OR ACK.RSP EQ "GO" OR ACK.RSP[ONE,LEN(ESC)] EQ ESC OR ACK.RSP[ONE,LEN(PICK.ESC)] EQ PICK.ESC OR ACK.RSP[ONE,ONE] EQ "*" OR ACK.RSP[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE DO
IF (ACK.RSP EQ "OFF" OR ACK.RSP EQ "KILL") THEN STOP
ACK.RSP = ACK.RSP[TWO,HI.NUM]
REPEAT
*
IF ACK.RSP[ONE,ONE] EQ "*" THEN
PRINT CR:
PRINT "G":CR:
PRINT CR:
END
*
* Packet validation
VALID.PKT = TRUE
FOR TMP = ONE TO 3 WHILE LEN(ACK.RSP) AND VALID.PKT
* Trim ESC or PICK.ESC char
IF ACK.RSP[ONE,LEN(ESC)] EQ ESC THEN
TMP = ONE
ACK.RSP = ACK.RSP[LEN(ESC)+ONE,HI.NUM]
END ELSE IF ACK.RSP[ONE,LEN(PICK.ESC)] EQ PICK.ESC THEN
TMP = ONE
ACK.RSP = ACK.RSP[LEN(PICK.ESC)+ONE,HI.NUM]
* Trim  Start block char
END ELSE IF ACK.RSP[ONE,LEN(STB)] EQ STB THEN
IF TMP NE TWO THEN VALID.PKT = FALSE
ACK.RSP = ACK.RSP[LEN(STB)+ONE,HI.NUM]
END ELSE IF ACK.RSP[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE THEN
LINE.MESSAGE = ACK.RSP; GOSUB PACKET.ERROR.RECVD
VALID.PKT = FALSE
END ELSE
IF TMP EQ 3 THEN VALID.PKT = TRUE ELSE VALID.PKT = FALSE
END
NEXT TMP
*
END; * GT 4
*
* Loop back for bad block
IF ERR.CN GE ERR.MAX AND ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERR.ABORT.VRF
*
* ACK.CHAR.CN1 = ZERO; * REV ONLY
*
END ELSE
ERR.CN = ERR.CN + ONE
END; * OF A LT 50
*
UNTIL ACK.RSP EQ "GO" OR B GT 30 OR ACK.CHAR.CN1 LE 4OR STAT EQ MAX.ERR.ABORT.VRF DO
*
IF VALID.PKT THEN
IF ERR.CN GT ERR.LOW THEN
*IF ERR.CN.LAST LE ERR.CN.LAST.HI THEN 
ERR.CN = ERR.CN - ONE; ERR.CN.LAST = ERR.CN.LAST.HI
*END ELSE ERR.CN.LAST = ERR.CN.LAST - ONE
END
END
*
REPEAT
*
*
RETURN
*
CHAR.SEND.PKT: * Subroutine to send packet
*
TMP = ERR.CN
IF TMP GT ERR.HI THEN TMP = ERR.HI
IF TMP LT ERR.LOW THEN TMP = ERR.LOW
TMP = TMP + ERR.OUT.OFFSET
IF TMP LT ONE THEN TMP = ONE
CHAR.PAUSE = (TMP-ONE) * (ONE+TMP/20)
TC = ZERO
*
LOOP
TC = TC + ONE
TC.CHAR = LINE.PACKET[TC,ONE]
WHILE LEN(TC.CHAR) DO
IF SEQ(TC.CHAR) GE 252 THEN TC.CHAR = CHAR(SEQ(TC.CHAR)-224)
PRINT TC.CHAR:
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT CHAR.PAUSE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
REPEAT
*
RETURN
*
~SYS.INCL.AVG.DAY~
*CODE.SEGMENT: SYS.INCL.AVG.DAY
*
*$INCLUDE DH.IBP SYS.INCL.AVG.DAY
*
AVG.DAY = 10
*
~SYS.INCL.BATCH.RSP~
*CODE.SEGMENT: SYS.INCL.BATCH.RSP
*
EQU BATCH.RSP TO "*LISTU*ULIST*UL*SYS.ULIST*WHERE*WHO*TIME*DATE*LISTVERBS*LISTDICT*BLIST*CATALOG*BASIC*CLEAR-FILE*CLEAR-LOCKS-MACRO*CLEAR.LOCKS*DECATALOG*SEARCH*"
*QLISTFILES*LISTFILES*DELETE*LIST*SORT*COPY*"
*
~SYS.INCL.CALC.BCC~
*CODE.SEGMENT: SYS.INCL.CALC.LRC
*
* COMPANY: AXION / MACROSCOPE DESIGN MAXTRIX
*
* AUTHOR: DAVID HORSMAN
*
*   NOTE: THIS CALCULATION IS A PART OF AXION COMPUTER SOFTWARE'S
* GENERAL (AND EAGLE) ON PREMISE ADDRESSABLE INTERFACE SOFTWARE
* AND IS A PART OF THE KBIL SUBSCRIBER BILLING SYSTEM.
*
*
***** LRC
TC.SUM = "00000000"
TC.CN = ZERO
TC.MAX = LEN(TC.PACKET)
*
LOOP
*
TC.CN = TC.CN + ONE
IF LBL.DISP THEN PRINT "CHAR # ":TC.CN:" ":
*
S8 = TC.SUM[ONE,ONE]
S7 = TC.SUM[TWO,ONE]
S6 = TC.SUM[3,ONE]
S5 = TC.SUM[4,ONE]
S4 = TC.SUM[5,ONE]
S3 = TC.SUM[6,ONE]
S2 = TC.SUM[7,ONE]
S1 = TC.SUM[8,ONE]
*
UNTIL TC.CN GT TC.MAX DO
*
TC = TC.PACKET[TC.CN,ONE]
*
IF LBL.DISP THEN PRINT TC:" ":
*
TC.SEQ = SEQ(TC)
*
IF LBL.DISP THEN
PRINT TC.SEQ
PRINT
PRINT "SUM ":TC.SUM
END
*
IF TC.SEQ GT 127 THEN T8 = "1"; TC.SEQ = TC.SEQ - 128 ELSE T8 = "0"
IF TC.SEQ GT  63 THEN T7 = "1"; TC.SEQ = TC.SEQ -  64 ELSE T7 = "0"
IF TC.SEQ GT  31 THEN T6 = "1"; TC.SEQ = TC.SEQ -  32 ELSE T6 = "0"
IF TC.SEQ GT  15 THEN T5 = "1"; TC.SEQ = TC.SEQ -  16 ELSE T5 = "0"
IF TC.SEQ GT   7 THEN T4 = "1"; TC.SEQ = TC.SEQ -   8 ELSE T4 = "0"
IF TC.SEQ GT   3 THEN T3 = "1"; TC.SEQ = TC.SEQ -   4 ELSE T3 = "0"
IF TC.SEQ GT   1 THEN T2 = "1"; TC.SEQ = TC.SEQ -   2 ELSE T2 = "0"
IF TC.SEQ THEN T1 = "1" ELSE T1 = "0"
*
IF LBL.DISP THEN
PRINT "MAP ":T8:T7:T6:T5:T4:T3:T2:T1
END
*
IF (T8 OR S8) AND NOT(T8 AND S8) THEN S8 = "1" ELSE S8 = "0"
IF (T7 OR S7) AND NOT(T7 AND S7) THEN S7 = "1" ELSE S7 = "0"
IF (T6 OR S6) AND NOT(T6 AND S6) THEN S6 = "1" ELSE S6 = "0"
IF (T5 OR S5) AND NOT(T5 AND S5) THEN S5 = "1" ELSE S5 = "0"
IF (T4 OR S4) AND NOT(T4 AND S4) THEN S4 = "1" ELSE S4 = "0"
IF (T3 OR S3) AND NOT(T3 AND S3) THEN S3 = "1" ELSE S3 = "0"
IF (T2 OR S2) AND NOT(T2 AND S2) THEN S2 = "1" ELSE S2 = "0"
IF (T1 OR S1) AND NOT(T1 AND S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF LBL.DISP THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
REPEAT
*
TC.SEQ = 0
IF S8 THEN TC.SEQ = TC.SEQ + 128
IF S7 THEN TC.SEQ = TC.SEQ +  64
IF S6 THEN TC.SEQ = TC.SEQ +  32
IF S5 THEN TC.SEQ = TC.SEQ +  16
IF S4 THEN TC.SEQ = TC.SEQ +   8
IF S3 THEN TC.SEQ = TC.SEQ +   4
IF S2 THEN TC.SEQ = TC.SEQ +   2
TC.SEQ = TC.SEQ + S1
*
TC.HEX = OCONV(CHAR(TC.SEQ),"MX")
TC.HEX = ("00":TC.HEX) "R#2"
*
IF LBL.DISP THEN PRINT "END > SEQ ":TC.SEQ:"    HEX ":TC.HEX
*
*
~SYS.INCL.CALC.LRC~
*CODE.SEGMENT: SYS.INCL.CALC.LRC
* USED BY: AI.PARSE.INPUT.EA
*          AI.PARSE.OUTPUT.EA
*          AI.TEST.LRC
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
* AUTHOR: DAVID HORSMAN
*
*   NOTE: THIS CALCULATION IS A PART OF AXION COMPUTER SOFTWARE'S
* GENERAL (AND EAGLE) ON PREMISE ADDRESSABLE INTERFACE SOFTWARE
* AND IS A PART OF THE KBIL SUBSCRIBER BILLING SYSTEM.
*
*
***** LRC
TC.SUM = "00000000"
TC.CN = ZERO
TC.MAX = LEN(TC.PACKET)
*
LOOP
*
TC.CN = TC.CN + ONE
IF CNT.TST$LBL THEN PRINT "CHAR # ":TC.CN:" ":
*
S8 = TC.SUM[ONE,ONE]
S7 = TC.SUM[TWO,ONE]
S6 = TC.SUM[3,ONE]
S5 = TC.SUM[4,ONE]
S4 = TC.SUM[5,ONE]
S3 = TC.SUM[6,ONE]
S2 = TC.SUM[7,ONE]
S1 = TC.SUM[8,ONE]
*
UNTIL TC.CN GT TC.MAX DO
*
TC = TC.PACKET[TC.CN,ONE]
*
IF CNT.TST$LBL THEN PRINT TC:" ":
*
TC.SEQ = SEQ(TC)
*
IF CNT.TST$LBL THEN
PRINT TC.SEQ
PRINT
PRINT "SUM ":TC.SUM
END
*
IF TC.SEQ GT 127 THEN T8 = "1"; TC.SEQ = TC.SEQ - 128 ELSE T8 = "0"
IF TC.SEQ GT  63 THEN T7 = "1"; TC.SEQ = TC.SEQ -  64 ELSE T7 = "0"
IF TC.SEQ GT  31 THEN T6 = "1"; TC.SEQ = TC.SEQ -  32 ELSE T6 = "0"
IF TC.SEQ GT  15 THEN T5 = "1"; TC.SEQ = TC.SEQ -  16 ELSE T5 = "0"
IF TC.SEQ GT   7 THEN T4 = "1"; TC.SEQ = TC.SEQ -   8 ELSE T4 = "0"
IF TC.SEQ GT   3 THEN T3 = "1"; TC.SEQ = TC.SEQ -   4 ELSE T3 = "0"
IF TC.SEQ GT   1 THEN T2 = "1"; TC.SEQ = TC.SEQ -   2 ELSE T2 = "0"
IF TC.SEQ THEN T1 = "1" ELSE T1 = "0"
*
IF CNT.TST$LBL THEN
PRINT "MAP ":T8:T7:T6:T5:T4:T3:T2:T1
END
*
IF (T8 OR S8) AND NOT(T8 AND S8) THEN S8 = "1" ELSE S8 = "0"
IF (T7 OR S7) AND NOT(T7 AND S7) THEN S7 = "1" ELSE S7 = "0"
IF (T6 OR S6) AND NOT(T6 AND S6) THEN S6 = "1" ELSE S6 = "0"
IF (T5 OR S5) AND NOT(T5 AND S5) THEN S5 = "1" ELSE S5 = "0"
IF (T4 OR S4) AND NOT(T4 AND S4) THEN S4 = "1" ELSE S4 = "0"
IF (T3 OR S3) AND NOT(T3 AND S3) THEN S3 = "1" ELSE S3 = "0"
IF (T2 OR S2) AND NOT(T2 AND S2) THEN S2 = "1" ELSE S2 = "0"
IF (T1 OR S1) AND NOT(T1 AND S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF CNT.TST$LBL THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
REPEAT
*
TC.SEQ = 0
IF S8 THEN TC.SEQ = TC.SEQ + 128
IF S7 THEN TC.SEQ = TC.SEQ +  64
IF S6 THEN TC.SEQ = TC.SEQ +  32
IF S5 THEN TC.SEQ = TC.SEQ +  16
IF S4 THEN TC.SEQ = TC.SEQ +   8
IF S3 THEN TC.SEQ = TC.SEQ +   4
IF S2 THEN TC.SEQ = TC.SEQ +   2
TC.SEQ = TC.SEQ + S1
*
TC.HEX = OCONV(CHAR(TC.SEQ),"MX")
TC.HEX = ("00":TC.HEX) "R#2"
*
IF CNT.TST$LBL THEN PRINT "END > SEQ ":TC.SEQ:"    HEX ":TC.HEX
*
*
~SYS.INCL.CALC.XOR.COMPL~
*CODE.SEGMENT: SYS.INCL.CALC.LRC
* USED BY: AI.PARSE.INPUT.PA
*          AI.PARSE.OUTPUT.PA
*          AI.TEST.XOR
*
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
*   NOTE: THIS CALCULATION IS A PART OF AXION COMPUTER SOFTWARE'S
* GENERAL (AND EAGLE) ON PREMISE ADDRESSABLE INTERFACE SOFTWARE
* AND IS A PART OF THE KBIL SUBSCRIBER BILLING SYSTEM.
*
*
***** LRC
TC.SUM = "00000000"
TC.CN = ZERO
TC.MAX = LEN(TC.PACKET)
*
LOOP
*
TC.CN = TC.CN + ONE
IF CNT.TST$X THEN PRINT "CHAR # ":TC.CN:" ":
*
S8 = TC.SUM[ONE,ONE]
S7 = TC.SUM[TWO,ONE]
S6 = TC.SUM[3,ONE]
S5 = TC.SUM[4,ONE]
S4 = TC.SUM[5,ONE]
S3 = TC.SUM[6,ONE]
S2 = TC.SUM[7,ONE]
S1 = TC.SUM[8,ONE]
*
UNTIL TC.CN GT TC.MAX DO
*
TC = TC.PACKET[TC.CN,ONE]
*
IF CNT.TST$X THEN PRINT TC:" ":
*
TC.SEQ = SEQ(TC)
*
IF CNT.TST$X THEN
PRINT TC.SEQ
PRINT
PRINT "SUM ":TC.SUM
END
*
IF TC.SEQ GT 127 THEN T8 = "1"; TC.SEQ = TC.SEQ - 128 ELSE T8 = "0"
IF TC.SEQ GT  63 THEN T7 = "1"; TC.SEQ = TC.SEQ -  64 ELSE T7 = "0"
IF TC.SEQ GT  31 THEN T6 = "1"; TC.SEQ = TC.SEQ -  32 ELSE T6 = "0"
IF TC.SEQ GT  15 THEN T5 = "1"; TC.SEQ = TC.SEQ -  16 ELSE T5 = "0"
IF TC.SEQ GT   7 THEN T4 = "1"; TC.SEQ = TC.SEQ -   8 ELSE T4 = "0"
IF TC.SEQ GT   3 THEN T3 = "1"; TC.SEQ = TC.SEQ -   4 ELSE T3 = "0"
IF TC.SEQ GT   1 THEN T2 = "1"; TC.SEQ = TC.SEQ -   2 ELSE T2 = "0"
IF TC.SEQ THEN T1 = "1" ELSE T1 = "0"
*
IF CNT.TST$X THEN
PRINT "MAP ":T8:T7:T6:T5:T4:T3:T2:T1
END
*
IF (T8 OR S8) AND NOT(T8 AND S8) THEN S8 = "1" ELSE S8 = "0"
IF (T7 OR S7) AND NOT(T7 AND S7) THEN S7 = "1" ELSE S7 = "0"
IF (T6 OR S6) AND NOT(T6 AND S6) THEN S6 = "1" ELSE S6 = "0"
IF (T5 OR S5) AND NOT(T5 AND S5) THEN S5 = "1" ELSE S5 = "0"
IF (T4 OR S4) AND NOT(T4 AND S4) THEN S4 = "1" ELSE S4 = "0"
IF (T3 OR S3) AND NOT(T3 AND S3) THEN S3 = "1" ELSE S3 = "0"
IF (T2 OR S2) AND NOT(T2 AND S2) THEN S2 = "1" ELSE S2 = "0"
IF (T1 OR S1) AND NOT(T1 AND S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF CNT.TST$X THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
REPEAT
*
IF CNT.TST$LBL THEN
PRINT
PRINT "COMPLEMENT"
PRINT "CURR":TC.SUM
END
IF NOT(S8) THEN S8 = "1" ELSE S8 = "0"
IF NOT(S7) THEN S7 = "1" ELSE S7 = "0"
IF NOT(S6) THEN S6 = "1" ELSE S6 = "0"
IF NOT(S5) THEN S5 = "1" ELSE S5 = "0"
IF NOT(S4) THEN S4 = "1" ELSE S4 = "0"
IF NOT(S3) THEN S3 = "1" ELSE S3 = "0"
IF NOT(S2) THEN S2 = "1" ELSE S2 = "0"
IF NOT(S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF CNT.TST$LBL THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
*
TC.SEQ = 0
IF S8 THEN TC.SEQ = TC.SEQ + 128
IF S7 THEN TC.SEQ = TC.SEQ +  64
IF S6 THEN TC.SEQ = TC.SEQ +  32
IF S5 THEN TC.SEQ = TC.SEQ +  16
IF S4 THEN TC.SEQ = TC.SEQ +   8
IF S3 THEN TC.SEQ = TC.SEQ +   4
IF S2 THEN TC.SEQ = TC.SEQ +   2
TC.SEQ = TC.SEQ + S1
*
TMP = TC.SEQ; GOSUB HX.CONV; * TC.HEX = OCONV(CHAR(TC.SEQ),"MX")
TC.HEX = ("00":TMP1) "R#2"
*
IF CNT.TST$LBL THEN PRINT "END > SEQ ":TC.SEQ:"    HEX ":TC.HEX
*
*
~SYS.INCL.CHK.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.CHK.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
*
DT = DATE(); TM = TIME()
*
IF ((DT - DELAY.DT) * 86400) + (TM - DELAY.TM) GT DELAY.RESET THEN
*
READ DELAY.CN.MAX FROM PAR.FILE,"STARDARD.DELAY.CURR" ELSE DELAY.CN.MAX = ZERO:AM:300
*
DELAY.RESET = DELAY.CN.MAX<TWO>
DELAY.CN.MAX = DELAY.CN.MAX<ONE>
*
DELAY.DT = DATE(); DELAY.TM = TIME()
*
END
*
*
~SYS.INCL.COMM.WAIT.QUIET~
*CODE.SEGMENT: SYS.COMM.WAIT.QUIET
*     AUTHOR: DAVE HORSMAN
* DATE WRITTEN: 10 FEB 89
*    COMPANY: Macroscope Design Matrix
*                  & (additionally)
*             Axion Computer Software Ltd.
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*  APPLICATION: System Communications Design
*
*    VARIABLES:
*        IN: PAR.FILE             -    Parameter file for reading control
*                                            records.
*            COMM.WAIT.KEY        -    Read control file when filled
*            COMM.WAIT.QUIET      -    Number of seconds continuous quiet
*            COMM.WAIT.MAX        -    Max length of wait
*            COMM.WAIT.ERROR      -    Max length error flag (null/1)
*            COMM.WAIT.PAUSE      -    # of RQMs to be performed
*            COMM.WAIT.CLEAR      -    Clear buffer if it exceeds
*                                       this # of char's.
*
IF LEN(COMM.WAIT.KEY) THEN
READ COMM.WAIT.REC FROM PAR.FILE,COMM.WAIT.KEY ELSE
COMM.WAIT.REC = EMPTY 
RETURN; *# TO CALLING PROGRAM
END
END ELSE COMM.WAIT.REC = EMPTY 
*
COMM.WAIT.REC.CN.MAX = DCOUNT(COMM.WAIT.REC,AM)
COMM.WAIT.REC.CN     = ZERO
COMM.WAIT.RECVD      = EMPTY
COMM.WAIT.RECVD.LEN  = ZERO
COMM.STRING.FOUND = TRUE
COMM.LINE.TO.PRINT = FALSE
COMM.INIT         = FALSE
*
LOOP
*
IF COMM.WAIT.REC.CN LE COMM.WAIT.REC.CN.MAX AND COMM.STRING.FOUND AND NOT(COMM.LINE.TO.PRINT) THEN
COMM.WAIT.REC.CN = COMM.WAIT.REC.CN + ONE
COMM.WAIT.COMMAND = COMM.WAIT.REC<COMM.WAIT.REC.CN>
*
COMM.WAIT.VERB = FIELD(COMM.WAIT.COMMAND," ",ONE)
COMM.WAIT.SUBJECT = FIELD(COMM.WAIT.COMMAND," ",TWO)
COMM.WAIT.PREDICATE = FIELD(COMM.WAIT.COMMAND," ",3)
COMM.STRING.TO.BE.FOUND = EMPTY
*
BEGIN CASE
*
CASE COMM.WAIT.VERB EQ "WAIT" AND NOT(NUM(COMM.WAIT.SUBJECT))
*
BEGIN CASE
*
CASE COMM.WAIT.SUBJECT EQ "PAUSE"
IF NOT(NUM(COMM.WAIT.PREDICATE)) THEN COMM.WAIT.PREDICATE = ZERO
COMM.WAIT.PAUSE = COMM.WAIT.PREDICATE + ZERO
*
CASE COMM.WAIT.SUBJECT EQ "QUIET"
IF NOT(NUM(COMM.WAIT.PREDICATE)) THEN COMM.WAIT.PREDICATE = ZERO
COMM.WAIT.QUIET = COMM.WAIT.PREDICATE + ZERO
*
END CASE
*
CASE COMM.WAIT.VERB EQ "CLEAR" OR COMM.WAIT.VERB EQ "INIT"
INPUTCLEAR
COMM.INIT = FALSE
*
CASE INDEX("*PAUSE*SLEEP*EXECUTE*PERFORM*DO*","*":COMM.WAIT.VERB:"*",ONE) OR (COMM.WAIT.VERB EQ "WAIT" AND NUM(COMM.WAIT.SUBJECT))
IF COMM.WAIT.VERB EQ "WAIT" THEN COMM.WAIT.PREDICATE = COMM.WAIT.SUBJECT; COMM.WAIT.SUBJECT = "SLEEP"
*
BEGIN CASE
*
CASE COMM.WAIT.VERB EQ "EXECUTE" OR COMM.WAIT.VERB EQ "PERFORM" OR COMM.WAIT.VERB EQ "DO"
*
CASE COMM.WAIT.PREDICATE MATCHES "1N':'2N" OR COMM.WAIT.PREDICATE MATCHES "2N':'2N" OR COMM.WAIT.PREDICATE MATCHES "1N':'2N':'2N" OR COMM.WAIT.PREDICATE MATCHES "2N':'2N':'2N"
EXEC.VERB = "SLEEP ":COMM.WAIT.PREDICATE
EXEC.FLAG = TRUE
*
CASE NUM(COMM.WAIT.PREDICATE)
IF NOT(NUM(COMM.WAIT.PAUSE)) THEN COMM.WAIT.PAUSE = ONE
IF COMM.WAIT.PAUSE LT ZERO THEN COMM.WAIT.PAUSE = ABS(COMM.WAIT.PAUSE)
IF NOT(COMM.WAIT.PAUSE) THEN COMM.WAIT.PAUSE = ONE
EXEC.VERB = "SLEEP ":COMM.WAIT.PAUSE
EXEC.FLAG = TRUE
*
CASE COMM.WAIT.SUBJECT[ONE,ONE] EQ '"' OR COMM.WAIT.SUBJECT[ONE,ONE] EQ "'" OR COMM.WAIT.SUBJECT[ONE,ONE] EQ '/' OR COMM.WAIT.SUBJECT[ONE,ONE] EQ '\'
CHAR.END = COMM.WAIT.SUBJECT.SYS11
STRING.START = INDEX(COMM.WAIT.COMMAND,CHAR.END,ONE)
STRING.END   = INDEX(COMM.WAIT.COMMAND,CHAR.END,TWO)
IF NOT(STRING.END) THEN STRING.END = LEN(COMM.COMMAND) + ONE
COMM.STRING.TO.BE.FOUND = COMM.WAIT.COMMAND[STRING.START + ONE,(STRING.END - STRING.START - ONE)]
EXEC.FLAG = FALSE
*
CASE TRUE
EXEC.FLAG = FALSE
*
END CASE
*
IF EXEC.FLAG THEN
EXEC.RSP = EMPTY
EXECUTE EXEC.VERB, //OUT. > EXEC.RSP
END
*
CASE TRUE
COMM.LINE.TO.PRINT = TRUE
*
END CASE
*
END; *# OF LOAD NEXT VERB
*
* WAIT INITIALIZATION
IF NOT(COMM.INIT) THEN
COMM.INIT = TRUE
CW.START.TIME = TIME()
CW.START.DATE = DATE()
* CURRENT # OF CAHR'S IN TYPE AHEAD BUFFER
*
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
CW.START.SYS11 = SYSTEM(ELEVEN)
* INPUT TMP,-ONE:; * REV ONLY
* CW.START.SYS11 = LEN(TMP); * REV ONLY
CASE OPSYS EQ "M"
CW.START.SYS11 = ONE
CASE OPSYS EQ "R"
* INPUT TMP,-ONE:; * REV ONLY
* CW.START.SYS11 = LEN(TMP); * REV ONLY
END CASE
*
CW.CONT.QUIET = ZERO
*
CW.LAST.SYS11 = CW.START.SYS11
CW.LAST.DATE = CW.START.DATE
CW.LAST.TIME = CW.START.TIME
*
END
*
* MAIN LOOP
LOOP
*
* DETERMIN TOTAL ELP
CW.CURR.TIME = TIME()
CW.CURR.DATE = DATE()
IF CW.START.DATE NE CW.CURR.DATE THEN
CW.ELP = (CW.CURR.DATE - CW.START.DATE - ONE) * 86400 + 86400 - CW.START.TIME + CW.CURR.TIME
END ELSE
CW.ELP = ABS(CW.CURR.TIME - CW.START.TIME)
END
*# PRINT "CW.ELP ":CW.ELP; *#
IF CW.ELP GT COMM.WAIT.MAX THEN COMM.WAIT.ERROR = ONE
*@ PRINT "COMM.WAIT.ERROR ":COMM.WAIT.ERROR; *@
*
IF NOT(COMM.WAIT.ERROR) THEN
*
*# CURRENT # OF CHARS IN TYPE AHEAD BUFFER
BEGIN CASE
*
CASE OPSYS EQ "U"
* ULT ONLY
CW.CURR.SYS11 = SYSTEM(ELEVEN)
* INPUT TMP,-ONE:; * REV ONLY
* CW.CURR.SYS11 = LEN(TMP); * REV ONLY
CASE OPSYS EQ "M"
CW.CURR.SYS11 = ONE
CASE OPSYS EQ "R"
* INPUT TMP,-ONE:; * REV ONLY
* CW.CURR.SYS11 = LEN(TMP); * REV ONLY
END CASE
*
*# DETERMINE CHANGE IN BUFFER
*
*# # OF CHAR'S HAS CHANGED
IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
CW.LAST.SYS11 = CW.CURR.SYS11
CW.LAST.DATE = CW.CURR.DATE
CW.LAST.TIME = CW.CURR.TIME
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
*@ PRINT "CW.LAST.DATE  ":CW.LAST.DATE; *@
*@ PRINT "CW.LAST.TIME  ":CW.LAST.TIME; *@
END ELSE
*
*# BUFFER IS EMPTY
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
IF CW.LAST.DATE NE CW.CURR.DATE THEN
CW.CONT.QUIET = (CW.CURR.DATE - CW.LAST.DATE - ONE) * 86400 + 86400 - CW.LAST.TIME + CW.CURR.TIME
END ELSE
CW.CONT.QUIET = ABS(CW.CURR.TIME - CW.LAST.TIME)
END
*@ PRINT "CW.CONT.QUIET ":CW.CONT.QUIET; *@
*
END; *# OF LAST.SYS11
*
*#  DETERMINE IF CLEAR OR STRING CHECK IS REQUIRED
IF OPSYS EQ "R" OR (CW.LAST.SYS11 + COMM.WAIT.RECVD.LEN GT COMM.WAIT.CLEAR AND COMM.WAIT.CLEAR) OR LEN(COMM.STRING.TO.BE.FOUND) THEN
COMM.WAIT.RECVD.LEN = LEN(COMM.WAIT.RECVD)
TMP = LEN(COMM.STRING.TO.BE.FOUND)
IF CW.LAST.SYS11 LT TMP THEN TMP = CW.LAST.SYS11 - ONE
INPUT TMP1,TMP:
CW.LAST.SYS11 = CW.LAST.SYS11 - TMP; CW.CURR.SYS11 = CW.CURR.SYS11 - TMP
COMM.WAIT.RECVD = COMM.WAIT.RECVD:TMP1
* INPUTCLEAR
IF LEN(COMM.STRING.TO.BE.FOUND) THEN
COMM.STRING.FOUND = INDEX(COMM.WAIT.RECVD,COMM.STRING.TO.BE.FOUND,ONE)
IF COMM.STRING.FOUND THEN COMM.INIT = FALSE
END ELSE COMM.STRING.FOUND = TRUE
*
LOOP
COMM.WAIT.RECVD.LEN = LEN(COMM.WAIT.RECVD)
WHILE COMM.WAIT.RECVD.LEN GT LEN(COMM.STRING.TO.BE.FOUND) * TWO AND LEN(COMM.STRING.TO.BE.FOUND) DO
COMM.WAIT.RECVD = COMM.WAIT.RECVD[LEN(COMM.STRING.TO.BE.FOUND) +ONE,99999]
REPEAT
*
CW.LAST.SYS11 = ZERO 
IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
*# OF CHAR'S HAS CHANGED
CW.CURR.SYS11 = ONE 
END ELSE
CW.CURR.SYS11 = ZERO
END
END; * OF CLEAR OR STRING CHECK
*
END; * OF NOT(COMM.WAIT.ERROR)
*
*@ PRINT "COMM.WAIT.ERROR ":COMM.WAIT.ERROR; *@
*@ PRINT "COMM.INIT ":COMM.INIT; *@
*@ PRINT "CW.CONT.QUIET:*:COMM.WAIT.QUIET ":CW.CONT.QUIET:"*":COMM.WAIT.QUIET; *@
*@ PRINT "COMM.STRING.FOUND ":COMM.STRING.FOUND; *@
WHILE NOT(COMM.WAIT.ERROR) AND COMM.INIT AND ((CW.CONT.QUIET LT COMM.WAIT.QUIET) AND NOT(COMM.STRING.FOUND)) DO
*
* Wait the required # of RQMs
FOR CW.TEMP = ONE TO COMM.WAIT.PAUSE
RQM
NEXT CW.TEMP
*
REPEAT
*
IF COMM.LINE.TO.PRINT THEN
*
PRINT COMM.WAIT.COMMAND:CR:
COMM.LINE.TO.PRINT = FALSE
COMM.INIT = FALSE
*
* Wait the required # of RQMs
FOR CW.TEMP = ONE TO COMM.WAIT.PAUSE
RQM
NEXT CW.TEMP
*
END
*
WHILE NOT(COMM.WAIT.ERROR) AND ((CW.CONT.QUIET LT COMM.WAIT.QUIET) OR COMM.WAIT.REC.CN LT COMM.WAIT.REC.CN.MAX) DO REPEAT
*
~SYS.INCL.COMPANY.READ~
*CODE.SEGMENT: SYS.INCL.COMPANY.READ
*
*
*DGH 870624
*
*
*CO.DATA@@@@@ READ COMPANY DATA
*
SYS.FILE = "SYS"
IF STRUCT(29)<1,PORT+1> EQ "" THEN STRUCT(29)<1,PORT+1> = STRUCT(4)
LOOP
SYS.ITEM = "@CO.DATA@":STRUCT(29)<1,PORT+1>
READ CO.DATA FROM SY.FILE,SYS.ITEM ELSE
CO.DATA = AM:DATE()
SYS.ABORT = 1
PRINTER ON
PRINT "CAN NOT READ COMPANY DATA FOR ":SYS.ITEM
PRINT
PRINTER OFF
PRINT
PRINT "CAN NOT READ COMPANY DATA FOR ":SYS.ITEM
END
WHILE NOT(SYS.ABORT OR USER.ABORT) AND CO.DATA<4> NE STRUCT(29)<1,PORT+1> DO
STRUCT(29)<1,PORT+1> = CO.DATA<4>
PRINT "COMPANY CHANGED TO ":CO.DATA<4>
REPEAT
EXEC.VERB = ""; PRMPTING = ""
*
*
IF USER.ABORT OR SYS.ABORT THEN
*#IF PORTD<5> NE "D" THEN 
PRINT BELL:" ABORT AT COMPANY READ!":
IF SYS.PROG.TYPE GT 3 THEN RETURN
END
*
*
*
~SYS.INCL.CONV.AM.TO.VM~
*CODE.SEGMENT: SYS.INCL.CONV.AM.TO.VM
*
*
AM.CN = ONE
LOOP
AM.LOC = INDEX(LINE,CHAR(254),ONE)
WHILE AM.LOC DO
LINE = LINE[ONE,AM.LOC - ONE]:VM:LINE[AM.LOC + ONE,99999]
IF TF THEN PRINT @(50,23):'AM ':AM.CN:; * RQM
AM.CN = AM.CN + ONE
REPEAT
*
~SYS.INCL.CONV.NUM.FROM.HEX~
*CODE.SEGMENT: SYS.INCL.CONV.NUM.FROM.HEX
* AUTHOR: DAVID HORSMAN
* DATE.WRITTEN: 2 APR 94
* (c) Copyright 1994
* MACROSCOPE DESIGN MATRIX
*
* TMP INCOMING NUMBER
* TMP1 OUTGOING NUMBER
* TMP2 BASE
*
* 1,048,576   65,536  4,096  256  16  1
*
!
*
DIGIT.CN.MAX = 1
DIGIT.VAL.MAX = TMP2
TMP3 = LEN(TMP)
* * * LOOP WHILE DIGIT.VAL.MAX LE TMP DO
LOOP WHILE DIGIT.CN.MAX LT TMP3 DO
DIGIT.VAL.MAX = DIGIT.VAL.MAX * TMP2
DIGIT.CN.MAX = DIGIT.CN.MAX + 1
REPEAT
* DIGIT.CN.MAX = DIGIT.CN.MAX - ONE
DIGIT.VAL.MAX = DIGIT.VAL.MAX / TMP2
*
***PRINT
***PRINT "Digits: ":DIGIT.CN.MAX
***PRINT "Value:  ":DIGIT.VAL.MAX
***PRINT
*
!
*
*
* * * IF NUM(TMP) THEN
* * * TMP3 = ABS(TMP)
TMP5 = EMPTY
* * * DIGIT.CN = DIGIT.CN.MAX
DIGIT.CN = ONE
DIGIT.VAL = DIGIT.VAL.MAX
*********
* * * LOOP WHILE DIGIT.CN GT ONE AND TMP3 GT ZERO DO
LOOP WHILE DIGIT.CN LE DIGIT.CN.MAX DO
TMP5<DIGIT.CN> = ZERO
* * * LOOP WHILE TMP3 GE DIGIT.VAL DO
* * * TMP3 = TMP3 - DIGIT.VAL
***PRINT ".":
* * * TMP5<DIGIT.CN> = TMP5<DIGIT.CN> + ONE
TMP3 = TMP[DIGIT.CN,ONE]
IF TMP3 EQ EMPTY THEN TMP3 = "0"
TMP7 = ZERO
IF TMP3 NE "0" THEN
TMP7 = INDEX("123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",TMP3,ONE)
END
TMP5<DIGIT.CN> = TMP7 * DIGIT.VAL
* * * REPEAT
***PRINT
***PRINT "val: ":DIGIT.VAL
***PRINT " cn: ":DIGIT.CN
***PRINT "CHR: ":TMP5<DIGIT.CN>
***PRINT "ALL: ":TMP5
DIGIT.VAL = DIGIT.VAL / TMP2
DIGIT.CN = DIGIT.CN + ONE
* * * DIGIT.CN = DIGIT.CN - ONE
REPEAT
* * * TMP5<ONE> = TMP3
*
***PRINT "ALL: ":TMP5
TMP6 = EMPTY
LOOP WHILE LEN(TMP5) DO
* TMP6 = (OCONV(CHAR(TMP5<ONE>),"MX"))[TWO,ONE]:TMP6
* * * TMP7 = ZERO
* * * IF TMP5<ONE> THEN TMP7 = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[TMP5<ONE>,ONE]
* * * TMP6 = TMP7:TMP6
TMP6 = TMP6 + TMP5<ONE>
DEL TMP5<ONE>
REPEAT
***PRINT "FINAL: ":TMP6
*
*********
TMP1 = TMP6
* * * END ELSE TMP1 = EMPTY
*
~SYS.INCL.CONV.NUM.TO.HEX~
*CODE.SEGMENT: SYS.INCL.CONV.NUM.TO.HEX
* AUTHOR: DAVID HORSMAN
* DATE.WRITTEN: 2 APR 94
* (c) Copyright 1994
* MACROSCOPE DESIGN MATRIX
*
* TMP INCOMING NUMBER
* TMP1 OUTGOING NUMBER
* TMP2 BASE
*
* 1,048,576   65,536  4,096  256  16  1
*
!
*
DIGIT.CN.MAX = 1
DIGIT.VAL.MAX = TMP2
LOOP WHILE DIGIT.VAL.MAX LE TMP DO
DIGIT.VAL.MAX = DIGIT.VAL.MAX * TMP2
DIGIT.CN.MAX = DIGIT.CN.MAX + 1
REPEAT
* DIGIT.CN.MAX = DIGIT.CN.MAX - ONE
DIGIT.VAL.MAX = DIGIT.VAL.MAX / TMP2
*
*** PRINT
*** PRINT "Digits: ":DIGIT.CN.MAX
*** PRINT "Value:  ":DIGIT.VAL.MAX
*** PRINT
*
!
*
*
IF NUM(TMP) THEN
TMP3 = ABS(TMP)
TMP5 = EMPTY
DIGIT.CN = DIGIT.CN.MAX
DIGIT.VAL = DIGIT.VAL.MAX
*********
LOOP WHILE DIGIT.CN GT ONE AND TMP3 GT ZERO DO
TMP5<DIGIT.CN> = ZERO
LOOP WHILE TMP3 GE DIGIT.VAL DO
TMP3 = TMP3 - DIGIT.VAL
*** PRINT ".":
TMP5<DIGIT.CN> = TMP5<DIGIT.CN> + ONE
REPEAT
*** PRINT
*** PRINT "val: ":DIGIT.VAL
*** PRINT " cn: ":DIGIT.CN
*** PRINT "CHR: ":TMP5<DIGIT.CN>
*** PRINT "ALL: ":TMP5
DIGIT.VAL = DIGIT.VAL / TMP2
DIGIT.CN  = DIGIT.CN  - ONE
REPEAT
TMP5<ONE> = TMP3
*
*** PRINT "ALL: ":TMP5
TMP6 = EMPTY
LOOP WHILE LEN(TMP5) DO
* TMP6 = (OCONV(CHAR(TMP5<ONE>),"MX"))[TWO,ONE]:TMP6
TMP7 = ZERO
IF TMP5<ONE> THEN TMP7 = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[TMP5<ONE>,ONE]
TMP6 = TMP7:TMP6
DEL TMP5<ONE>
REPEAT
*** PRINT "FINAL: ":TMP6
*
*********
TMP1 = TMP6
END ELSE TMP1 = EMPTY
*
~SYS.INCL.CONV.TO.HEX~
*CODE.SEGMENT: SYS.INCL.CONV.TO.HEX
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: DEC 89, INCL CREATED: 25 MAR 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF NOT(LINE.IS.HEX) THEN
TC.CN = ZERO
TC.MAX = LEN(LINE)
HEX.LINE = ""; OLD.LINE = LINE
LOOP
TC.CN = TC.CN + ONE
WHILE TC.CN LE TC.MAX DO
TC = LINE[TC.CN,ONE]
HEX.LINE = HEX.LINE:OCONV(TC,"MX")
REPEAT
LINE = HEX.LINE
LINE.IS.HEX = TRUE
END
*
~SYS.INCL.CONV.TO.TXT~
*CODE.SEGMENT: SYS.INCL.CONV.TO.TXT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: DEC 89, INCL CREATED: 25 MAR 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF LINE.IS.HEX THEN
TC.CN = ONE
TC.MAX = LEN(LINE)
HEX.LINE = ""; OLD.LINE = LINE
LOOP WHILE TC.CN LE TC.MAX+ONE DO
TC = LINE[TC.CN,TWO]
HEX.LINE = HEX.LINE:ICONV(TC,"MX")
TC.CN = TC.CN + TWO
REPEAT
LINE = HEX.LINE
LINE.IS.HEX = FALSE
END
*
~SYS.INCL.CONV.VM.TO.AM~
*CODE.SEGMENT: SYS.INCL.CONV.VM.TO.AM
*
*
VM.CN = ONE
LOOP
VM.LOC = INDEX(LINE,CHAR(254),ONE)
WHILE VM.LOC DO
LINE = LINE[ONE,VM.LOC - ONE]:AM:LINE[VM.LOC + ONE,99999]
IF TF THEN PRINT @(50,23):'VM ':VM.CN:; * RQM
VM.CN = VM.CN + ONE
REPEAT
*
~SYS.INCL.CPORT~
*CODE.SEGMENT: SYS.INCL.CPORT
*
*$INCLUDE DH.IBP SYS.INCL.CPORT
*
IF STRUCT(14) EQ PORT+1 THEN EQ.PROG.STATUS = 11 ELSE
EQ.PROG.STATUS = 1
END
*
~SYS.INCL.CURR.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.CURR.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
READ DELAY.CN.MAX FROM PAR.FILE,"STANDARD.DELAY.CURR" THEN
DELAY.RESET = DELAY.CN.MAX<TWO>
DELAY.CN.MAX = DELAY.CN.MAX<ONE>
END ELSE NULL
*
*
~SYS.INCL.DEB.RSP~
*CODE.SEGMENT: SYS.INCL.DEB.RSP
*
*
EQU DEB.RSP TO "*DEB*DEBUG*debug*Debug*TEST*test*Test*"
*$INCLUDE DH.BP SYS.INCL.DEB.RSP
*
~SYS.INCL.END.RSP~
*CODE.SEGMENT: SYS.INCL.END.RSP
*
*
EQU END.RSP TO "*END*end*End*KILL*kill*Kill*"
*
~SYS.INCL.ENTER.STD.SUBR~
*CODE.SEGMENT: SYS.INCL.ENTER.STD.SUBR
*
*
READ TMP FROM COM.FILE,STD.SUBR.NAME THEN
TMP = GENERIC; TMP1 = SEC.USER$ITEM.ID
CALL @STD.SUBR.NAME(STD.FILE,SEC.USER$ITEM.ID,MAT STD,PAR.FILE,LCK.FILE,TMP1,TMP,CO.DATA,MAT CNT.TST,STAT)
MATWRITE STD ON STD.FILE,SEC.USER$ITEM.ID
END ELSE
PRINT CLB:RVB:"Function does not exist! Enter <cr> . . . ":RVE:BELL:; INPUT TMP.RSP
END
*
~SYS.INCL.ERROR~
*CODE.SEGMENT: SYS.INCL.ERROR
* USED BY: AI.TALKER
*          AI.CONTORL.UTILITY
*          AI.HANDLER
*          AI.CHECK.HANDLER
*          AI.CHANNEL.DN
*          AI.CHANNEL.UP
*          UPLOAD.PPV.BUYS
*          DOWNLOAD.PPV.BUYS
*
* ERR.HDR    -
* ERR.LN.MIN - 
* ERR.LN.HI  -
* ERR.LEN    -
* ERR.CLB    -
* ERR.CLS    -
* TEXT       -
* ERR.LN      -
* ERR.CL      -
* ERR.BELL     -
* ERR.CR       -
* ERR.FMT       -
* ERR.DISP.ONLY -
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
LOOP WHILE LEN(TEXT) AND TEXT<ONE> EQ EMPTY DO DEL TEXT<ONE> REPEAT
*
IF LEN(TEXT) THEN
*
ERR.LN = ERR.LN.MIN; ERR.FMT = "L#":ERR.LEN - TWO
*
IF ERR.CLB THEN ERR.LN = 23
*
IF (ERR.CLS AND ERR.CLB) THEN PRINT @(ZERO,ERR.LN):CLS: ELSE
*
PRINT @(ZERO,23):CLL:
*
IF NOT(ERR.CLB) THEN
*
IF ERR.LN.HI GT ERR.LN.MIN THEN
FOR ERR.LN = ERR.LN.MIN TO ERR.LN.MAX UNTIL ERR.LN GT ERR.LN.HI
PRINT @(ERR.CL,ERR.LN):RVB:"!":RVE:" " ERR.FMT:RVB:"!":RVE:
NEXT ERR.LN
ERR.LN.HI = ERR.LN.MIN - ONE
END
*
PRINT @(ERR.CL,ERR.LN.MIN - ONE):RVB:"!":ERR.HDR ERR.FMT:"!":RVE:
*
ERR.LN = ERR.LN.MIN
*
END; * of not clb (print on bottom)
*
END; * of clb (line 23) flag
*
IF ERR.BELL THEN PRINT BELL:
*
LOOP
*
TMP = TEXT<ONE>
TMP1 = LEN(TMP)
IF TMP1 GT ERR.LEN THEN TMP1 = ERR.LEN
DEL TEXT<ONE>
*
IF TMP1 THEN
PRINT @(ERR.CL,ERR.LN):RVB:"!":RVE:TMP ERR.FMT:RVB:"!":RVE:
IF NOT(ERR.CLB) THEN ERR.LN = ERR.LN + ONE
END; * of text present
*
IF ERR.CLB OR ERR.LN GT ERR.LN.MAX OR NOT(LEN(TEXT)) THEN
*
IF ERR.DISP.ONLY AND NOT(ERR.CR AND NOT(LEN(TEXT))) THEN
*
FOR A = ONE TO ERR.DISP.ONLY; RQM; NEXT A
*
END ELSE
*
TMP = ERR.CL + TMP1
*
IF NOT(ERR.CLB) THEN
IF TMP + 41 GT 78 THEN TMP = ZERO
PRINT @(TMP,23):CLL:
IF LEN(TEXT) THEN PRINT " More messages - ":
PRINT " Press <cr> to continue ":
END ELSE
*
IF TMP LT 70 THEN
PRINT " Press <cr> ":
END ELSE
PRINT BELL:
END; * 70
*
END; * ERR.CLB
*
INPUT RSP:
* IF ERR.CLB THEN PRINT @(ERR.CL,ERR.LN):CLL:
IF RSP = "KILL" THEN STOP
*
END; * ERR.DISP.ONLY
*
IF NOT(ERR.CLB) AND ERR.LN.HI LT ERR.LN THEN ERR.LN.HI = ERR.LN
*
IF NOT(ERR.CLB) AND LEN(TEXT) THEN ERR.LN = ERR.LN.MIN
*
END; * of page or end of text
*
WHILE LEN(TEXT) DO REPEAT
*
IF NOT(ERR.CLB) AND ERR.CLS THEN
* LOOP WHILE ERR.LN LE ERR.LN.MAX DO PRINT @(ERR.CL,ERR.LN):CLL:; ERR.LN = ERR.LN + ONE REPEAT
LOOP WHILE ERR.LN LE ERR.LN.MAX DO
PRINT @(ERR.CL,ERR.LN):RVB:"!":RVE:" " ERR.FMT:RVB:"!":RVE:
ERR.LN = ERR.LN + ONE
REPEAT
END ELSE IF NOT(ERR.CLB) AND ERR.LN LE ERR.LN.MAX THEN
PRINT @(ERR.CL,ERR.LN):RVB:"!":STR("-",ERR.LEN - TWO) ERR.FMT:"!":RVE:
END
*
END; * of text present
*
~SYS.INCL.ERROR.BU~
*CODE.SEGMENT: SYS.INCL.DISPLAY
*
*
IF LBL.DISP THEN PRINT @(60,20):"Error Display" "L#18":; RQM
ERR.LN = ERR.LN.MIN
*
IF LEN(TEXT) THEN
IF DCOUNT(TEXT,AM) LE 1 THEN ERR.LN = 23
ERR.FMT = "L#":ERR.LEN
IF ERR.CLS AND (ERR.LN.MIN AND ERR.LN.MAX) THEN PRINT @(ZERO,ERR.LN):CLS:
*
LOOP
*
IF LEN(TEXT) THEN
PRINT @(ERR.CL,ERR.LN):TEXT<ONE> ERR.FMT:
ERR.LN = ERR.LN + ONE
DEL TEXT<ONE>
END; * of text present
*
IF ERR.LN GT ERR.LN.MAX OR NOT(LEN(TEXT)) THEN
*
IF ERR.LN NE 23 THEN PRINT @(ZERO,23):CLL ELSE PRINT " - ":
IF LEN(TEXT) THEN PRINT "More messages to display":
MSG.DISP = TRUE
*
IF TST.CR THEN
PRINT " - Press <cr>":
INPUT TST.RSP:
IF RSP = "KILL" THEN STOP
END ELSE IF NOT(ERR.DISP.ONLY) THEN RQM ELSE
FOR A = ONE TO ERR.DISP.ONLY; RQM; NEXT A
END
*
ERR.LN = ERR.LN.MIN
*
END; * of last msg or next page
*
WHILE LEN(TEXT) DO REPEAT
*
IF MSG.DISP THEN PRINT @(ZERO,23):CLL:
*
END; * of text present
*
~SYS.INCL.EXEC.STD.FUNC~
*CODE.SEGMENT: SYS.INCL.EXEC.STD.FUNC
*
*
* Execute command
*
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = EXEC.VERB
LCK.STAT = FALSE
EXEC.VERB.ID = EXEC.VERB
IF EXEC.VERB[ONE,ONE] EQ "." THEN
EXEC.VERB = EXEC.VERB[TWO,9999]
CR.FLAG = TRUE
END
*
! Check for generic toggle (CHAR(1) <CTRL>-A)
*
IF EXEC.VERB[ONE,ONE] EQ CHAR(1) THEN
IF GENERIC THEN GENERIC = FALSE ELSE GENERIC = TRUE
EXEC.VERB = EXEC.VERB[TWO,9999]
END
*
! Check for RESET param (^)
*
IF EXEC.VERB[ONE,ONE] EQ "^" THEN RESET.SW = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! TCL request made (TCL)
*
IF EXEC.VERB EQ "TCL" AND (MENU.NAME NE EMPTY AND MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE>) THEN
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
END
PAR.MENU$LOCN<ONE,ONE> = SCR.LOCN
*
! Check for 'Enter <cr>' param   (%)
*
IF EXEC.VERB[ONE,ONE] EQ "%" THEN CR.FLAG = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! Question for user (!)
*
LOOP TC = INDEX(EXEC.VERB,"!",ONE) WHILE TC DO
TMP = FIELD(EXEC.VERB,"!",TWO); TMP1 = EXEC.VERB[ONE,TC - ONE]
TMP2 = INDEX(EXEC.VERB,"!",TWO)
IF TMP2 THEN TMP2 = EXEC.VERB[TMP2 + ONE,999] ELSE TMP2 = EMPTY
PRINT CLB:TMP[ONE,70]:" ":; INPUT TMP.RSP:
EXEC.VERB = TMP1:TMP.RSP:TMP2
REPEAT
*
! Insert port key here ($)
*
LOOP TC = INDEX(EXEC.VERB,"$",ONE) WHILE TC DO
TC.BEG = TC - ONE
TC.END = INDEX(EXEC.VERB,"$",TWO)
IF NOT(TC.END) THEN TC.END = TC.BEG + ONE
TC.WORD = EXEC.VERB[TC.BEG,TC.END - TC.BEG]
BEGIN CASE
CASE TC.WORD EQ "PORT"
EXEC.VERB = EXEC.VERB[ONE,TC.BEG]:PORT.KEY:EXEC.VERB[TC.END,999]
CASE TC.WORD EQ "OPER"
CASE TC.WORD EQ "ACCT"
CASE TC.WORD EQ "FILE"
CASE TC.WORD EQ "ITEM"
CASE TC.WORD EQ "DATE"
CASE TC.WORD EQ "TIME"
CASE TC.WORD EQ "SYS11"
CASE TC.WORD EQ "SEL.ERROR"
CASE TC.WORD EQ "TST"
CASE TC.WORD EQ "SYS.ERROR"
CASE TC.WORD EQ "MENU.NAME"
CASE TC.WORD EQ "APPL"
CASE TC.WORD EQ "SUB.APPL"
CASE TC.WORD EQ "PROG"
CASE TC.WORD EQ "LOCT"
CASE TC.WORD EQ "SYS"
CASE TC.WORD EQ "OPSYS"
CASE TC.WORD EQ "TOPIC"
CASE TC.WORD EQ "USER"
CASE TC.WORD EQ "MODE"
CASE TRUE
EXEC.VERB = EXEC.VERB[ONE,TC.BEG]:"$":EXEC.VERB[TC.END,999]
END CASE
REPEAT
*
! Insert account name here (#?) (  #D   #T   #n  )
*
LOOP TC = INDEX(EXEC.VERB,"#",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF TMP EQ EMPTY THEN TMP = "?"
IF NUM(TMP) THEN
IF TMP LT ONE THEN TMP = ONE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:FIELD(ACCT,".",TMP):EXEC.VERB[TC + TWO,999]
END ELSE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:PAR.MENU$USER:EXEC.VERB[TC+ ONE,999]
END
REPEAT
*
! Insert date or time here (  #D  #T  #n   )
*
LOOP TC = INDEX(EXEC.VERB,"_",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF NOT(NUM(TMP)) THEN TMP = ONE
IF TMP EQ "T" THEN TMP1 = OCONV(DATE(),"D2") ELSE
IF TMP EQ "D" THEN TMP1 = OCONV(TIME(),"MTS") ELSE TMP1 = "?"
END
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:TMP1:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Insert special routines name here   (   .?   )
*
ROUTINE.SUFFIX = EMPTY
LOOP TC = INDEX(EXEC.VERB,".?",ONE) WHILE TC DO
IF NOT(LEN(ROUTINE.SUFFIX)) THEN
TMP = EXEC.VERB[ONE,TC - ONE]
LOOP UNTIL NOT(INDEX(TMP," ",ONE)) DO TMP = TMP[TWO,999] REPEAT
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = EMPTY
LOCATE TMP IN SPECIAL.ROUTINES<ONE> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<TWO,LOC>
END
EXEC.VERB = EXEC.VERB[ONE,TC]:ROUTINE.SUFFIX:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Check for lock param (l)
*
IF EXEC.VERB[ONE,ONE] EQ "l" THEN
EXEC.VERB = EXEC.VERB[TWO,9999]
LCK.ITM = TRUE
END ELSE LCK.ITM = FALSE
*
! Process terminal input to routing
*
PARAMS = EXEC.VERB
EXEC.VERB = EXEC.VERB<ONE,ONE,ONE>
EXEC.VERB.ID = EXEC.VERB
DEL PARAMS<ONE,ONE,ONE>
EXEC.IN = EMPTY
*
LOOP UNTIL PARAMS = EMPTY DO
IF OPSYS = "R" THEN DATA PARAMS<ONE,ONE,ONE> ELSE EXEC.IN = EXEC.IN:PARAMS<ONE,ONE,ONE>:AM
DEL PARAMS<ONE,ONE,ONE>
REPEAT
*
BEGIN CASE
*
CASE OPSYS = "U"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
* IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP ":EXEC.VERB
END
*
CASE OPSYS = "R"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP.OBJ ":EXEC.VERB
END
*
CASE TRUE
TMP = FIELD(EXEC.VERB," ",ONE)
IF TMP EQ "RUN" THEN
TMP = FIELD(EXEC.VERB," ",TWO)
EXEC.VERB = EXEC.VERB[COL2() + ONE,9999]
END
*
END CASE
*
! Check group authorization
*
IF EXEC.VERB.ID[ONE,ONE] EQ "." OR EXEC.VERB EQ "TCL" THEN
LOCATE "TCL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "ALL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE LCK.STAT = TRUE
END
IF LCK.STAT THEN
PRINT CLB:RVB:"You do not have access to TCL! Enter <cr> . . . ":RVE:BELL:; INPUT TMP.RSP:
END
END
*
IF SEC.USER.ID NE EMPTY THEN
MSG.VERB = "SYS.MSG.SEND"
MSG.IN = "-2":AM:SEC.USER.ID
EXECUTE MSG.VERB, //IN. < MSG.IN
END
*
! Lock record
*
IF NOT(LCK.STAT) THEN
IF EXEC.VERB.ID[ONE,ONE] EQ "." THEN EXEC.VERB.ID = EXEC.VERB.ID[TWO,999]
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "RUN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",3)
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "CHAIN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",TWO)
IF LCK.ITM THEN
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE,LCK.STAT)
WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
END ELSE LCK.STAT = FALSE
END; * Of lock stat
*
! OFF request made
*
IF RESET.SW OR EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
PAR.MENU$MENU.ID = EMPTY
PAR.MENU$LOCN   = ONE
PAR.MENU$DESC = "OFF"
END
PAR.MENU$GROUP = EMPTY
PAR.MENU$USER = EMPTY
END
*
! Write location
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Ready to execute routing
*
IF NOT(LCK.STAT) THEN
*
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
*
READ TMP FROM ACC.FILE,ACC.ID ELSE TMP = EMPTY
IF EXEC.DESC EQ EMPTY THEN
TMP<ACC.AM.DESC> = EXEC.VERB<ONE,ONE,ONE>
END ELSE
TMP<ACC.AM.DESC> = EXEC.DESC
END
TMP<ACC.AM.VERB> = EXEC.VERB
TMP<ACC.AM.DT>   = DATE()
TMP<ACC.AM.TM>   = TIME()
WRITE TMP ON ACC.FILE,ACC.ID
*
MATWRITE STD ON COM.FILE,SEC.USER$ITEM.ID
*
*%%ULT%%=IF EXEC.VERB EQ "TCL" THEN STOP
*%%PCK%%=IF EXEC.VERB EQ "TCL" THEN STOP
*%%MDD%%=IF EXEC.VERB EQ "TCL" THEN ABORT
*
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF RESET.SW EQ 999 THEN GOTO UNLOCK
CHAIN "ZZOFF"
END
*
IF EXEC.VERB[ONE,6] EQ "CHAIN " THEN CHAIN EXEC.VERB[7,999]
*
* is it a PC command
IF EXEC.VERB[ONE,3] EQ "PC " THEN
*
EXECUTE EXEC.VERB; * DON'T CHANGE
*
END ELSE
*
* Not a PC command
IF EXEC.IN EQ EMPTY THEN
*
EXECUTE EXEC.VERB
*
END ELSE
*
EXEC.IN = EXEC.IN[ONE,LEN(EXEC.IN) - ONE]
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
END
*
END; * Of PC or not
*
END; * Of item not locked
*
IF LCK.ITM THEN
CALL UNLOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE)
END
*
*
IF CR.FLAG EQ TWO THEN
*960605*DGH*PRINT CLB:RVB:"Continuing . . . ":RVE:BELL:; RQM; RQM
PRINT @(ZERO):CLL:RVB:"Continuing . . . ":RVE:BELL:; RQM; RQM
END ELSE IF CR.FLAG THEN
PRINT @(ZERO):CLL:"Enter <cr> to continue . . . ":; INPUT TMP.RSP:
END
*
~SYS.INCL.EXEC.STD.FUNC.13MAR94~
*CODE.SEGMENT: SYS.INCL.EXEC.STD.FUNC
*
*
* Execute command
*
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = EXEC.VERB
LCK.STAT = FALSE
EXEC.VERB.ID = EXEC.VERB
IF EXEC.VERB[ONE,ONE] EQ "." THEN EXEC.VERB = EXEC.VERB[TWO,9999]
*
! Check for generic toggle (CHAR(1) <CTRL>-A)
*
IF EXEC.VERB[ONE,ONE] EQ CHAR(1) THEN
IF GENERIC THEN GENERIC = FALSE ELSE GENERIC = TRUE
EXEC.VERB = EXEC.VERB[TWO,9999]
END
*
! Check for RESET param (^)
*
IF EXEC.VERB[ONE,ONE] EQ "^" THEN RESET.SW = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! TCL request made (TCL)
*
IF EXEC.VERB EQ "TCL" AND (MENU.NAME NE EMPTY AND MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE>) THEN
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
END
PAR.MENU$LOCN<ONE,ONE> = SCR.LOCN
*
! Check for 'Enter <cr>' param   (%)
*
IF EXEC.VERB[ONE,ONE] EQ "%" THEN CR.FLAG = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! Question for user (!)
*
LOOP TC = INDEX(EXEC.VERB,"!",ONE) WHILE TC DO
TMP = FIELD(EXEC.VERB,"!",TWO); TMP1 = EXEC.VERB[ONE,TC - ONE]
TMP2 = INDEX(EXEC.VERB,"!",TWO)
IF TMP2 THEN TMP2 = EXEC.VERB[TMP2 + ONE,999] ELSE TMP2 = EMPTY
PRINT CLB:TMP[ONE,70]:" ":; INPUT TMP.RSP:
EXEC.VERB = TMP1:TMP.RSP:TMP2
REPEAT
*
! Insert port key here ($)
*
LOOP TC = INDEX(EXEC.VERB,"$",ONE) WHILE TC DO
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:PORT.KEY:EXEC.VERB[TC + ONE,999]
REPEAT
*
! Insert account name here (#?) (  #D   #T   #n  )
*
LOOP TC = INDEX(EXEC.VERB,"#",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF TMP EQ EMPTY THEN TMP = "?"
IF NUM(TMP) THEN
IF TMP LT ONE THEN TMP = ONE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:FIELD(ACCT,".",TMP):EXEC.VERB[TC + TWO,999]
END ELSE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:PAR.MENU$USER:EXEC.VERB[TC+ ONE,999]
END
REPEAT
*
! Insert date or time here (  #D  #T  #n   )
*
LOOP TC = INDEX(EXEC.VERB,"_",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF NOT(NUM(TMP)) THEN TMP = ONE
IF TMP EQ "T" THEN TMP1 = OCONV(DATE(),"D2") ELSE
IF TMP EQ "D" THEN TMP1 = OCONV(TIME(),"MTS") ELSE TMP1 = "?"
END
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:TMP1:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Insert special routines name here   (   .?   )
*
ROUTINE.SUFFIX = EMPTY
LOOP TC = INDEX(EXEC.VERB,".?",ONE) WHILE TC DO
IF NOT(LEN(ROUTINE.SUFFIX)) THEN
TMP = EXEC.VERB[ONE,TC - ONE]
LOOP UNTIL NOT(INDEX(TMP," ",ONE)) DO TMP = TMP[TWO,999] REPEAT
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = EMPTY
LOCATE TMP IN SPECIAL.ROUTINES<ONE> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<TWO,LOC>
END
EXEC.VERB = EXEC.VERB[ONE,TC]:ROUTINE.SUFFIX:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Check for lock param (l)
*
IF EXEC.VERB[ONE,ONE] EQ "l" THEN
EXEC.VERB = EXEC.VERB[TWO,9999]
LCK.ITM = TRUE
END ELSE LCK.ITM = FALSE
*
! Process terminal input to routing
*
PARAMS = EXEC.VERB
EXEC.VERB = EXEC.VERB<ONE,ONE,ONE>
EXEC.VERB.ID = EXEC.VERB
DEL PARAMS<ONE,ONE,ONE>
EXEC.IN = EMPTY
*
LOOP UNTIL PARAMS = EMPTY DO
IF OPSYS = "R" THEN DATA PARAMS<ONE,ONE,ONE> ELSE EXEC.IN = EXEC.IN:PARAMS<ONE,ONE,ONE>:AM
DEL PARAMS<ONE,ONE,ONE>
REPEAT
*
BEGIN CASE
*
CASE OPSYS = "U"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
* IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP ":EXEC.VERB
END
*
CASE OPSYS = "R"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP.OBJ ":EXEC.VERB
END
*
CASE TRUE
TMP = FIELD(EXEC.VERB," ",ONE)
IF TMP EQ "RUN" THEN
TMP = FIELD(EXEC.VERB," ",TWO)
EXEC.VERB = EXEC.VERB[COL2() + ONE,9999]
END
*
END CASE
*
! Check group authorization
*
IF EXEC.VERB.ID[ONE,ONE] EQ "." OR EXEC.VERB EQ "TCL" THEN
LOCATE "TCL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "ALL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE LCK.STAT = TRUE
END
IF LCK.STAT THEN
PRINT CLB:RVB:"You do not have access to TCL! Enter <cr> . . . ":RVE:BELL:; INPUT TMP.RSP:
END
END
*
! Lock record
*
IF NOT(LCK.STAT) THEN
IF EXEC.VERB.ID[ONE,ONE] EQ "." THEN EXEC.VERB.ID = EXEC.VERB.ID[TWO,999]
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "RUN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",3)
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "CHAIN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",TWO)
IF LCK.ITM THEN
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE,LCK.STAT)
WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
END ELSE LCK.STAT = FALSE
END; * Of lock stat
*
! OFF request made
*
IF RESET.SW OR EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
PAR.MENU$MENU.ID = EMPTY
PAR.MENU$LOCN   = ONE
PAR.MENU$DESC = "OFF"
END
PAR.MENU$GROUP = EMPTY
PAR.MENU$USER = EMPTY
END
*
! Write location
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Ready to execute routing
*
IF NOT(LCK.STAT) THEN
*
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
*
READ TMP FROM ACC.FILE,ACC.ID ELSE TMP = EMPTY
TMP<ACC.AM.DESC> = EXEC.DESC
TMP<ACC.AM.VERB> = EXEC.VERB
TMP<ACC.AM.DT>   = DATE()
TMP<ACC.AM.TM>   = TIME()
WRITE TMP ON ACC.FILE,ACC.ID
*
MATWRITE STD ON COM.FILE,SEC.USER$ITEM.ID
*
IF EXEC.VERB EQ "TCL" THEN STOP
*
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF RESET.SW EQ 999 THEN GOTO UNLOCK
CHAIN "AXOFF"
END
*
IF EXEC.VERB[ONE,6] EQ "CHAIN " THEN CHAIN EXEC.VERB[7,999]
*
* is it a PC command
IF EXEC.VERB[ONE,3] EQ "PC " THEN
*
EXECUTE EXEC.VERB; * DON'T CHANGE
*
END ELSE
*
* Not a PC command
IF EXEC.IN EQ EMPTY THEN
*
EXECUTE EXEC.VERB
*
END ELSE
*
EXEC.IN = EXEC.IN[ONE,LEN(EXEC.IN) - ONE]
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
END
*
END; * Of PC or not
*
END; * Of item not locked
*
IF LCK.ITM THEN
CALL UNLOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE)
END
*
*
IF CR.FLAG EQ TWO THEN
PRINT CLB:RVB:"Continuing . . . ":RVE:BELL:; RQM; RQM
END ELSE IF CR.FLAG THEN
PRINT CLB:"Enter <cr> to continue . . . ":; INPUT TMP.RSP:
END
*
~SYS.INCL.FIRSTWORD~
*CODE.SEGMENT: SYS.INCL.FIRSTWORD
*
TC.CN = ONE; OLD.TC.CN = TC.CN
TC = "?"; TC.MARK = "^"; TC.SP = ZERO
TC.MARK1 = "#"
WORD.CN = ONE
FIRST = ""; SECOND = ""
*
IF LINE.DISP THEN
IF LEN(LINE) GT 77 THEN TMP.DISP = FALSE ELSE
*PRINT @(ZERO,18):CLL:
PRINT @(ZERO,19):CLL:
PRINT @(ZERO,20):CLL:" ":LINE "L#77":
PRINT @(ZERO,21):CLL:
PRINT @(ZERO,22):CLL:
TMP.DISP = TRUE
END
END ELSE TMP.DISP = FALSE
*
FOR WORD.CN = ONE TO TWO UNTIL TC EQ EMPTY
*
LOOP
*
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,21):TC.MARK1:@(TC.CN,21):RVB:TC.MARK:RVE:" ":; OLD.TC.CN = TC.CN
*
UNTIL INDEX(" ;",TC,ONE) OR TC EQ EMPTY DO TC.CN = TC.CN + ONE REPEAT
*
IF WORD.CN EQ ONE THEN
FIRST = LINE[ONE,TC.CN - ONE]
TC.SP = TC.CN
TC.MARK = "&"
TC.MARK1 = "="
TC.CN = TC.CN + ONE
END ELSE
SECOND = LINE[TC.SP+ONE,TC.CN - ONE - (TC.SP)]
END
*
NEXT WORD.CN
*
IF TMP.DISP THEN
*PRINT @(ZERO,21):RVB:">":STR("-",TC.CN - ONE):"<":RVE:" ":
PRINT @(ZERO,21):">":RVB:STR("-",TC.SP - ONE):RVE:"&":RVB:STR("_",TC.CN - TC.SP - ONE):RVE:"<":" ":
END
*
IF TMP.DISP THEN
PRINT @(10,19):FIRST:"|":@(20,19):SECOND:"|     "
END
*
~SYS.INCL.FKEY.DISP~
*CODE.SEGMENT: SYS.INCL.FKEY.DISP
*
FUNC.VC.OFFSET = ZERO; FUNC.CL = ZERO
FUNC.STR = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0><"
*
* Display function keys; * : *
IF NOT(GENERIC) AND NOT(SYSTEM(11)) THEN
**PRINT @(ZERO,STAT.LN):RVB:FUNC.RSP:RVE:
PRINT @(ZERO,STAT.LN):
LOOP
TMP = 5 + LEN(CURSOR.KEYS<4,FUNC.VC + FUNC.VC.OFFSET>)
* ULT ONLY
IF SYSTEM(11) THEN TMP = 999
UNTIL FUNC.VC + FUNC.VC.OFFSET GT FUNC.VC.MAX OR FUNC.CL + TMP GE 80 DO
TMP1 = FUNC.STR[FUNC.VC + FUNC.VC.OFFSET,ONE]
PRINT RVB:("F":TMP1):RVE:" ":CURSOR.KEYS<4,FUNC.VC + FUNC.VC.OFFSET>:"  ":
FUNC.CL = FUNC.CL + TMP
FUNC.VC.OFFSET = FUNC.VC.OFFSET + ONE
REPEAT
END
~SYS.INCL.FSEARCH.BOT~
*CODE.SEGMENT: SYS.INCL.FSEARCH.BOT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 01 OCT 87
* (c) Copyright 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
WHILE NOT(FKEY.FOUND) AND FSEARCH.CN LT FSEARCH.MAX DO
FSEARCH.CN = FSEARCH.CN + ONE
REPEAT
*
~SYS.INCL.FSEARCH.TOP~
*CODE.SEGMENT: SYS.INCL.FSEARCH.TOP
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 01 OCT 87
* (c) Copyright 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
* FSEARCH.PREFIX must be set upon entry!
*
FSEARCH.MAX = 6
FSEARCH.CN  = ONE
FKEY.ID     = ""
FKEY.SUFFIX = ""
*
LOOP
*
BEGIN CASE
CASE FSEARCH.CN EQ ONE
FSEARCH.SUFFIX = "@ALL"
CASE FSEARCH.CN EQ TWO
FSEARCH.SUFFIX = "@ACCT@":ACCT:"@":PORT
CASE FSEARCH.CN EQ 3
FSEARCH.SUFFIX = "@ACCT@":ACCT
CASE FSEARCH.CN EQ 4
FSEARCH.SUFFIX = "@PORT@":PORT
CASE FSEARCH.CN EQ 5
FSEARCH.SUFFIX = "@USER@":USER.ID
CASE FSEARCH.CN EQ 6
FSEARCH.SUFFIX = "@APPL@":APPL
CASE FSEARCH.CN
FSEARCH.SUFFIX = FSEARCH.PREFIX
END CASE
*
FKEY.ID = FSEARCH.PREFIX:FSEARCH.SUFFIX
FKEY.FOUND = FALSE
*
~SYS.INCL.HEADING~
*CODE.SEGMENT: SYS.HEADING
*
*$INCLUDE DH.BP SYS.HEADING(OUT.TO.PRINT,SYS.PROG.DESC,SCR.HEADING)
!
*#*$INCLUDE DH.BP SYS.COMMON
*#*
*#*$INCLUDE DH.BP SYS.STANDARD.FUNCTIONS
*#*
*#*SYS.PROG = "SYS.SCHED.NEXT":AM:SYS.PROG
*#*SYS.LOCT = "INIT":AM:SYS.LOCT
*#*SYS.SLOC = "":AM:SYS.SLOC
SYS.SLOC<1>="HEADING"
*#**
*#*GOSUB S.HEADING
*#**
*#*End.of.prog: * bypass GOTO for abnormal end.
*#**
*#*SYS.PROG = DELETE(SYS.PROG,1)
*#*SYS.LOCT = DELETE(SYS.LOCT,1)
*#*SYS.SLOC = DELETE(SYS.SLOC,1)
*#*RETURN
*#*!
*#**
*#**
*#*S.HEADING: * Subroutine to print screen heading.
TEMP = 0
TEMP1 = 0
SCR.PORT = ""
SCR.UPD = ""
SCR.CNTR = ""
*
*
IF STRUCT(25)<1,PORT+1> THEN
*
IF STRUCT(70) > 0 THEN SCR.CNTR = (STRUCT(70)-1)[1,1] ELSE SCR.CNTR = "o"
IF STRUCT(91) > 0 THEN SCR.CNTR = SCR.CNTR:(STRUCT(91)-1)[1,1] ELSE SCR.CNTR = SCR.CNTR:"o"
IF WAIT.FLAG THEN SCR.CNTR = SCR.CNTR:WAIT.FLAG[1,1] ELSE SCR.CNTR = SCR.CNTR:"w"
*
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF STRUCT(21)<1,TEMP> # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVE
SCR.PORT = SCR.PORT:STRUCT(21)<1,TEMP>[1,1]
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVB; TEMP1 = 2
END ELSE
SCR.PORT = SCR.PORT:"o"
END
REPEAT
SCR.PORT = SCR.PORT[1,10+TEMP1]
*
TEMP = 0
TEMP2 = 0
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF USER.UPD(TEMP) # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVE
SCR.UPD = SCR.UPD:USER.UPD(TEMP)[1,1]
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVB; TEMP2 = 2
END ELSE
SCR.UPD = SCR.UPD:"o"
END
REPEAT
SCR.UPD = SCR.UPD[1,10+TEMP2]
*
END
*
*
IF OUT.TO.PRINT = 1 THEN
PRINTER ON
PRINT FF
MAX.COL = 132
MAX.LN = 60
END ELSE
*
*# LINE 0 - LINE 0 - LINE 0
PRINT @(0,0):CLL:RVB: ; *#
*#CLS:
MAX.COL = 80
MAX.LN = 20
END
*
*
PRINT (OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS")) "L#20": ; *#
*@*#PRINT (SPACE(20-LEN(CO.DATA<1,1,1>)/2+.5):CO.DATA<1,1,1>) "L#40":
PRINT (PORT:".":ACCT:".":STRUCT(2)) "R#15": ; *#
*
*IF OUT.TO.PRINT = 1 THEN PRINT ELSE
*PRINT @(0,1):CLL:
*END
*
IF STRUCT(25)<1,PORT+1> THEN PRINT (" ":MODE.DESC(USER.MODE):" mode") "L#16": ELSE PRINT SPACE(16): ; *#
*#PRINT (SPACE(20-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#40":
PRINT MENU.APPL.DESC "L#28":
*#
*#v
*# LINE 1 - LINE 1 - LINE 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,1):CLL: ; *#
END
*#^
IF STRUCT(25)<1,PORT+1> THEN 
*#PRINT "Ports.on>":
PRINT "[P|": ; *#
*#IF NOT(TEMP1) THEN PRINT SCR.PORT "R#10": ELSE 
PRINT SCR.PORT "R#12": ; *#
*#PRINT "<":
PRINT "] ": ; *#
END ELSE PRINT SPACE(15): ; *#
*
*IF OUT.TO.PRINT = 1 THEN PRINT ELSE
*PRINT @(0,2):CLL:
*END
*
IF STRUCT(25)<1,PORT+1> THEN
*#PRINT "Upd>":
PRINT "[U|": ; *#
*#IF NOT(TEMP1) THEN PRINT SCR.UPD "R#10": ELSE 
PRINT SCR.UPD "L#12": ; *#
*#PRINT "<":
PRINT "] ": ; *#
END ELSE PRINT SPACE(15): ; *#
*@*#PRINT (SPACE(25-LEN(MENU.CONTROL<1,1>)/2+.5):MENU.CONTROL<1,1>) "L#50":
IF STRUCT(25)<1,PORT+1> THEN PRINT SCR.CNTR "R#15": ELSE PRINT SPACE(15): ; *#
*
*# LINE 2 - LINE 2 - LINE 2
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,2):CLL: ; *#
END
PRINT CO.DATA<1,1,1> "L#35": ; *#
*#SPACE(INT(17.5-LEN(CO.DATA<1,1,1>)/2+.5)):
*#PRINT (SPACE(20-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#39" ; *#
PRINT " ":MENU.CONTROL<1,1> "L#43":
*#SPACE(20-LEN(MENU.CONTROL<1,1>)/2+.5):
*# LINE 3 - LINE 3 - LINE 3
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,3):CLL: ; *#
END
LN = 3
*
IF LEN(SYS.PROG.DESC) # 0 THEN
PRINT (SPACE((80-LEN(SYS.PROG.DESC)) / 2):SYS.PROG.DESC) "L#80": ; *#
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE PRINT @(0,LN):CLL: ; *#
END
*
IF NOT(OUT.TO.PRINT) THEN PRINT RVE: ELSE PRINT
TEMP = 0
LOOP TEMP = TEMP + 1 WHILE LEN(SCR.HEADING<TEMP>) # 0 DO
PRINT SCR.HEADING[1,MAX.COL-1]: ; *#
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE PRINT @(0,LN):CLL: ; *#
REPEAT
*
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN
PRINT
PRINTER OFF
END ELSE
PRINT @(0,LN):CLS: ; *#
END
*
*#*RETURN
*#**
*#**
*#*END
~SYS.INCL.HI.DEV.MODE~
*CODE.SEGMENT: SYS.INCL.HI.DEV.MODE
*
EQU HI.D.M TO 20
*
~SYS.INCL.HI.SALES.MODE~
*CODE.SEGMENT: SYS.INCL.HI.SALES.MODE
*
EQU HI.S.M TO 2
*
~SYS.INCL.HI.TRAIN.MODE~
*CODE.SEGMENT: SYS.INCL.HI.TRAIN.MODE
*
EQU HI.T.M TO 6
*
~SYS.INCL.ITEM.TYPE~
*CODE.SEGMENT: SYS.INCL.ITEM.TYPE
*
*
ATTR1.TC = ATTR1[ONE,ONE]
*
BEGIN CASE
*
CASE ATTR1[ONE,10] EQ "*PROGRAM: "
PROG.LIST<-ONE> = ITEM.ID
PRINT "PROG" "L#5":
WRITE.FLAG = TRUE
IF LIST.TYPE NE "PROG" THEN LIST.TYPE = "PROG"
RTN.TYPE = "PROG"
*
CASE ATTR1[ONE,15] EQ "*CODE.SEGMENT: "
CSEG.LIST<-ONE> = ITEM.ID
PRINT "CSEG" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*PROC*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "CSEG"
RTN.TYPE = "CSEG"
*
CASE ATTR1[ONE,TWO] EQ "PQ"
PROC.LIST<-ONE> = ITEM.ID
PRINT "PROC" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "PROC"
RTN.TYPE = "PROC"
*
CASE ATTR1[ONE,11] EQ "SUBROUTINE "
SUBR.LIST<-ONE> = ITEM.ID
PRINT "SUBR" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*CSEG*PROC*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "SUBR"
RTN.TYPE = "SUBR"
*
CASE INDEX("ASXDQP",ATTR1.TC,ONE)
DICT.LIST<-ONE> = ITEM.ID
PRINT "DICT" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "DICT"
RTN.TYPE = "DICT"
*
CASE TRUE
OTHER.LIST<-ONE> = ITEM.ID
PRINT "OTHR" "L#5":
IF LIST.TYPE EQ "ABORT" THEN LIST.TYPE = "OTHER"
RTN.TYPE = "OTHER"
*
END CASE
*
~SYS.INCL.LASTWORD~
*CODE.SEGMENT: SYS.INCL.LASTWORD
*
*
* find last statement
*
TC.SPCC = ")":VM:">":VM:"]":VM:"}":VM:"'":VM:'"':VM:","
TC.ALTC = "(":VM:"<":VM:"[":VM:"{":VM:"'":VM:'"':VM:" "
TC.CN = LEN(LINE); TC.CN.START = ZERO; TC.CN.MAX = TC.CN
OLD.TC.CN = TC.CN
*
IF LINE.DISP THEN
IF LEN(LINE) GT 77 THEN TMP.DISP = FALSE ELSE
**PRINT @(ZERO,18):CLL:
**PRINT @(ZERO,19):CLL:
PRINT @(ZERO,20):CLL:" ":LINE "L#77":
**PRINT @(ZERO,22):CLL:
TMP.DISP = TRUE
END
END ELSE TMP.DISP = FALSE
*
LOOP
*
LOOP
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
UNTIL TC EQ ";" OR NOT(TC.CN) DO
TC.CN = TC.CN - ONE
REPEAT
*
TC.CN.START = TC.CN; TC.CN = TC.CN + ONE
*
LOOP
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
WHILE TC EQ " " AND TC.CN LT TC.CN.MAX DO TC.CN = TC.CN + ONE REPEAT
*
WHILE (TC EQ "*" OR TC EQ "!") AND TC.CN.START DO
*
TC.CN.MAX = TC.CN.START - ONE; TC.CN = TC.CN.MAX
*
REPEAT
*
! Find last word
*
* Trim spaces
*
TC.CN = TC.CN.MAX
*
LOOP
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
WHILE LINE[TC.CN,ONE] EQ " " OR NOT(TC.CN GT TC.CN.START) DO TC.CN = TC.CN - ONE REPEAT
*
TC.CN.END = TC.CN + ONE
TC.SPCC.CN = ZERO
*
! Find start of word
*
LOOP
*
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
*
LOCATE TC IN TC.SPCC<ONE> SETTING TMP THEN
TC.SPCC.CN = TC.SPCC.CN + ONE
TC.CN = TC.CN - ONE
LOOP
TC = LINE[TC.CN,ONE]
IF TC EQ TC.ALTC<ONE,TMP> THEN TC.SPCC.CN = TC.SPCC.CN - ONE ELSE
IF TC EQ TC.SPCC<ONE,TMP> THEN TC.SPCC.CN = TC.SPCC.CN + ONE
END
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
WHILE TC.SPCC.CN GT ZERO AND TC.CN GT TC.CN.START DO
TC.CN = TC.CN - ONE
REPEAT
IF TC.CN GT TC.CN.START THEN
TC.CN = TC.CN - ONE
TC = LINE[TC.CN,ONE]
END ELSE TC = EMPTY
END ELSE NULL
*
UNTIL INDEX(" ;",TC,ONE) OR (INDEX(":+-*/",TC,ONE) AND TC.CN LT TC.CN.END - ONE) OR TC.CN LE TC.CN.START DO
TC.CN = TC.CN - ONE
REPEAT
*
LAST = TRIM(LINE[TC.CN + ONE,TC.CN.END - TC.CN - ONE])
IF TMP.DISP THEN
PRINT @(TC.CN,22):RVB:">":STR("-",TC.CN.END - TC.CN - ONE):"<":RVE:" ":
END
*
IF TMP.DISP THEN
*PRINT @(ZERO,19):CLL:RVB:LAST:RVE:" ":
PRINT @(30,19):LAST:"|           "
END
*
~SYS.INCL.LCK.ITM~
*CODE.SEGMENT: SYS.INCL.LCK.ITM
*
* LCK.FIL.ID
* LCK.ITM.ID
* LCK.TYPE
* LCK.ITM
* LCK.RELS
* LCK.ELP.MAX
*
IF LCK.ITM THEN
*
LCK.STAT = FALSE
LCK.DT = DATE(); LCK.TM = TIME(); LCK.ELP = ZERO
*
LOOP
LCK.TMP = LCK.TYPE; LCK.STAT = EMPTY
CALL SYS.ITM.LCK(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TMP,"1",SYS.PROG,"0",OPER,EXP.LCK.TM,SYS.LOCT,"A","",LCK.STAT)
LCK.ELP = ((DATE() - LCK.DT) * 86400) + (TIME() - LCK.TM)
UNTIL NOT(LCK.STAT) OR LCK.ELP GT LCK.ELP.MAX DO REPEAT
*
END
*
~SYS.INCL.LCK.RELS~
*CODE.SEGMENT: SYS.INCL.LCK.RELS
*
* LCK.FIL.ID
* LCK.ITM.ID
* LCK.TYPE
* LCK.ITM
* LCK.RELS
* LCK.ELP.MAX
*
IF LCK.RELS THEN
*
LCK.TMP = LCK.TYPE
CALL SYS.ITM.RLS(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TMP,"1",SYS.PROG,"0",OPER,EXP.LCK.TM,SYS.LOCT,"A","",LCK.STAT)
LCK.RELS.DT = DATE(); LCK.RELS.TM = TIME()
LCK.RELS.ELP = ((LCK.RELS.DT - LCK.DT) * 86400) + (LCK.RELS.TM - LCK.TM)
*
END
*
~SYS.INCL.LIST.RSP~
*CODE.SEGMENT: SYS.INCL.LIST.RSP
*
*
EQU LIST.RSP TO "*COPY-LIST*GET-LIST*QSELECT*FORM-LIST*SELECT*SSELECT*"
*
~SYS.INCL.LIST.TYPE.WRITE~
*CODE.SEGMENT: SYS.INCL.LIST.TYPE.WRITE
*
*
WRITE PROG.LIST ON LISTS.FILE,LIST.NAME:".PROG"
WRITE CSEG.LIST ON LISTS.FILE,LIST.NAME:".CSEG"
WRITE PROC.LIST ON LISTS.FILE,LIST.NAME:".PROC"
WRITE SUBR.LIST ON LISTS.FILE,LIST.NAME:".SUBR"
WRITE DICT.LIST ON LISTS.FILE,LIST.NAME:".DICT"
WRITE OTHER.LIST ON LISTS.FILE,LIST.NAME:".OTHER"
*
WRITE CODE.LIST ON LISTS.FILE,LIST.NAME:".CODE"
WRITE EDIT.LIST ON LISTS.FILE,LIST.NAME:".EDIT"
*
~SYS.INCL.LO.DEV.MODE~
*CODE.SEGMENT: SYS.INCL.LO.DEV.MODE
*
EQU LO.D.M TO 11
*
~SYS.INCL.LO.TCL.MODE~
*CODE.SEGMENT: SYS.INCL.LO.TCL.MODE
*
EQU LO.TCL.M TO 9
*
~SYS.INCL.LO.TRAIN.MODE~
*CODE.SEGMENT: SYS.INCL.LO.TRAIN.MODE
*
EQU LO.T.M TO 3
*
~SYS.INCL.LOAD.ACC~
*CODE.SEGMENT: SYS.INCL.LOAD.ACC
*
* DAVID HORSMAN
*
READ ACC.REC FROM ACC.FILE,ACC.ID ELSE ACC.REC = EMPTY
ACC.DESC = ACC.REC<ACC.AM.DESC> 
ACC.VERB = ACC.REC<ACC.AM.VERB> 
ACC.DT   = ACC.REC<ACC.AM.DT>   
ACC.TM   = ACC.REC<ACC.AM.TM>   
*
~SYS.INCL.LOAD.AUTO~
*CODE.SEGMENT: SYS.INCL.LOAD.AUTO
*
INPUT AUTO.RUN
*
IF NOT(STAT) AND AUTO.RUN THEN
*
LCK.FILE.ID = "PAR"; LCK.ID = "CURRENT.RUN"
*
IF NOT(STAT) AND LCK.ITM THEN
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(PAR.FILE,LCK.FILE.ID,LCK.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN STAT = LCK.STAT
WHILE NOT(STAT) AND LCK.STAT DO REPEAT
*
IF NOT(STAT) THEN
READ CURRENT.RUN FROM PAR.FILE,LCK.ID ELSE CURRENT.RUN = EMPTY
END
*
IF NOT(LCK.STAT) THEN
CALL UNLOCK.ITEM(PAR.FILE,LCK.FILE.ID,LCK.ID,LCK.FILE)
END
*
END ELSE IF NOT(STAT) THEN
READ CURRENT.RUN FROM PAR.FILE,LCK.ID ELSE CURRENT.RUN = EMPTY
END
*
IF STAT THEN
TEXT = "Unable to perform current procedure"
STOP
END
*
END ELSE CURRENT.RUN = EMPTY
*
~SYS.INCL.LOAD.CMD~
*CODE.SEGMENT: SYS.INCL.LOAD.CMD
*
*
*
*
PROC.FL = TRUE; PROC.BUF = EMPTY
TCL.FL = FALSE; TCL.BUF = EMPTY
EXEC.FL = FALSE; EXEC.BUF = EMPTY
CMD.BUF = EMPTY
*
BEGIN CASE
CASE OPSYS EQ "M"
*TCL.BUF = SYSTEM(??)
IF TCL.BUF NE EMPTY THEN CMD.BUF = TCL.BUF
* MDD ONLY
PROCREAD PROC.BUF ELSE PROC.FL = FALSE
IF PROC.FL THEN
PROC.CN.MAX = DCOUNT(PROC.BUF,AM)
PROC.REC = PROC.BUF; TMP = PROC.BUF; PROC.BUF = EMPTY
FOR CN = ONE TO PROC.CN.MAX
IF (CN - ONE) THEN PROC.BUF = PROC.BUF:" "
PROC.BUF = PROC.BUF:TMP<CN>
NEXT CN
CMD.BUF = PROC.BUF
END; * of PROC.FL
CASE OPSYS EQ "P"
CASE OPSYS EQ "R"
CASE OPSYS EQ "U"
* ULT ONLY
PROCREAD PROC.BUF ELSE PROC.FL = FALSE
CASE TRUE
PROC.FL = FALSE
PROC.BUF = EMPTY
END CASE
IF PROC.BUF[ONE,3] EQ "SET" THEN PROC.FL = FALSE
* IF PROC.BUF EQ EMPTY THEN PROC.FL = FALSE
*
*
!
*
~SYS.INCL.LOAD.CO~
*CODE.SEGMENT: SYS.INCL.LOAD.CO
*
*DATE: 24 FEB 93
*
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = ""
IF OPERATORS = "" THEN OPERATORS = ACCT[1,3]
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; INPUT RSP; STOP
ACCTG.PERIOD = CURR.ACCTG.PERIOD[1,2]:"-":CURR.ACCTG.PERIOD[3,2]
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; INPUT RSP; STOP
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DT = CO.DATA<2,1,1>
~SYS.INCL.LOAD.PORT.KEY~
*CODE.SEGMENT: SYS.INCL.LOAD.PORT.KEY
*
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
~SYS.INCL.LOAD.STD.DATA~
*CODE.SEGMENT: SYS.INCL.LOAD.STD.DATA
*
*
IF STD.FUNC EQ "READ" OR STD.FUNC EQ "PERFORM" THEN
* Enter STanDard SUBRoutine
*
LOOP
STD.CONT = FALSE
*
IF STD.FUNC EQ "PERFORM" THEN
PRINT @(ZERO,22):CLL:RVB:"Enter file name: ":RVE:BELL:
INPUT TMP.RSP:
IF TMP.RSP NE EMPTY THEN SEC.USER$FILE.NAME = TMP.RSP ELSE PRINT SEC.USER$FILE.NAME:
END
IF SEC.USER$FILE.NAME EQ EMPTY THEN SEC.USER$FILE.NAME = "COM"
OPEN SEC.USER$FILE.NAME TO STD.FILE THEN
*
IF STD.FUNC EQ "PERFORM" THEN
PRINT @(ZERO,22):CLL:RVB:"Enter Item ID: ":RVE:BELL:
INPUT TMP.RSP:
IF TMP.RSP NE EMPTY THEN SEC.USER$ITEM.ID = TMP.RSP ELSE PRINT SEC.USER$ITEM.ID:
END
*
MATREAD STD FROM STD.FILE,SEC.USER$ITEM.ID ELSE
PRINT CLB:RVB:SEC.USER$ITEM.ID:" item is missing! Enter <cr> . . .":RVE:BELL:; INPUT TMP.RSP:
END
*
END ELSE
PRINT CLB:RVB:SEC.USER$FILE.NAME:" file is missing! Enter <cr> . . .":RVE:BELL:; INPUT TMP.RSP:
STD.FUNC = "PERFORM"; STD.CONT = TRUE
END; * Of open
WHILE STD.CONT DO REPEAT
*
END; * Of read or perform
*
~SYS.INCL.LOAD.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.LOAD.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
*
READ DELAY.CN.MAX FROM PAR.FILE,"STANDARD.DELAY" ELSE DELAY.CN.MAX = ZERO:AM:300
*
DELAY.RESET = DELAY.CN.MAX<TWO>
DELAY.CN.MAX = DELAY.CN.MAX<ONE>
*
DELAY.DT = DATE(); DELAY.TM = TIME()
*
*
~SYS.INCL.LOAD.TST~
*CODE.SEGMENT: SYS.INCL.LOAD.TEST.ITEM
*
* AUTHOR: David Horsman
*
CALL SH.MAINT.TST.SUB(CNT.FILE,CNT.TST.ID,MAT CNT.TST,PAR.FILE,LCK.FILE,CNT.ID.SAVE,GENERIC,CO.DATA,SYS.TST,STAT)
*
INPUT TMP:
RETURN
*
* REMOVE THESE VARIABLES
*
TEST.FL = ZERO; LIST.NAME = EMPTY; DIS.SUB = ZERO; DIS.ITEM = ZERO
*  TF         ; TST<TST$LIST.NAME>; LBL.DISP     ; ID.DISP
DIS.PROG = ZERO; TIMING = ZERO; BREAK.ON = ZERO
*TST<TST$RTN>  ; TST<TST$TIMING>; TST<TST$BREAK>
*
* These variable are handled here or s/b replaced
* TST<TST$TA>
BREAK.ON = ZERO;   WKO.TEST = ZERO
*TST<TST$BREAK>;   TST$AM = 12 & TST$VM = 1
*
*
TST.ID = "SYSTEM.TEST"
READ TST FROM CNT.FILE,TST.ID ELSE TST = EMPTY
*
LBL.DISP = FALSE; CNT.TST$CR = FALSE; ID.DISP = FALSE; FILE.UPD = FALSE
TF = EMPTY
IF LEN(TST<TST$AM,TST$VM>) THEN TF = TST<TST$AM,TST$VM>
IF TF EQ 9 THEN TF = EMPTY
*
*
IF TF EQ EMPTY THEN
TF = FALSE
IF TST<TST$SYS> GT TF THEN TF = TST<TST$SYS>
IF TST<TST$APPL> GT TF THEN TF = TST<TST$APPL>
IF TF THEN
LBL.DISP = TST<TST$LBL>
IF LBL.DISP GE 3 THEN CNT.TST$CR = TRUE ELSE CNT.TST$CR = FALSE
IF LBL.DISP GE 5 THEN ID.DISP = TRUE
FILE.UPD = TST<TST$FILE>
IF FILE.UPD THEN ID.DISP = TRUE
END
END ELSE
IF TF GE 3 THEN CNT.TST$CR = TRUE
IF TF GE 1 THEN LBL.DISP = TRUE
IF TF GE 5 THEN ID.DISP = TRUE
IF TF GE 6 AND TF LE 8 THEN FILE.UPD = TF
END
*
!
*
IF TST<TST$BREAK> THEN
* BREAK IS ON
END ELSE
* BREAK IS OFF
END
IF TST<TST$TA> THEN
*TYPE AHEAD IS ON
END ELSE
* TYPE AHEAD IS OFF
END
*
IF TF THEN
TEST.FL = 1
DIS.PROG  = TST<TST$RTN>
DIS.SUB   = TST<TST$LBL>
DIS.ITEM  = TST<TST$FILE>
LIST.NAME = TST<TST$LIST.NAME>
TIMING    = TST<6>
BREAK.ON  = TST<7>
WKO.TEST  = TST<8>
PRINT @(0,22):CLL:RVB:("Rtn ":TST<TST$RTN>:" SubRtn ":TST<TST$LBL>:" Item ":TST<TST$FILE>:" List ":TST<TST$LIST.NAME>) "L#75":RVE:
PRINT @(0,23):CLL:RVB:("Tst ":TST<TST$SYS>:"Timing ":TST<6>:" Break ":TST<7>:" WKO ":TST<8>:" Appl ":TST<TST$APPL>) "L#75":RVE:
*
IF CNT.TST$CR THEN PRINT CLB:"SYS.INCL.LOAD.TST <cr> ":; INPUT TMP:
*
RQM
END
!
~SYS.INCL.LOAD.TST.DOC~
*CODE.SEGMENT: SYS.INCL.LOAD.TST.DOC
*
*
* READS CNT (THE VARIABLE 'TST') WHICH MUST BE LOADED
*
* 'SYS.TST' IN GENERAL.COMMON.AREA SHOULD BE LOADED WHERE APPLICABLE
*
* FILE: CNT     ITEM: SYSTEM.TEST
*
*EQ TST$SYS            TO 1
*** TST$APPL           ** 17
*EQ TST$RTN            TO 2
*EQ TST$LBL            TO 3
*EQ TST$FILE           TO 4
*EQ TST$LIST.NAME      TO 5
*EQ TST$TEST.DATE      TO 6
*EQ TST$BREAK          TO 7
*EQ TST$TIMING         TO 8
*EQ TST$TA             TO 9
*
*EQ TST$SPEC.APPL      TO 10
*EQ TST$SPEC.VAL       TO 11
*
*EQ TST$WO             TO 12
*EQ TST$BILL           TO 13
*EQ TST$SYST           TO 14
*EQ TST$RELS           TO 15
*EQ TST$PAUSE          TO 16
*EQ TST$APPL           TO 17
*
!
*
* ATR   PURPOSE
*   1   ON/OFF
*
*   2   Display 'ENTERING' PROGRAM OR EXTERNAL SUBROUTINE (CALLED)
*       1 - Display LOCATION 
*       2 - Display Location and PAUSE
*       3 - Display Location and INPUT <cr>
*
*   3   Display 'ENTERING' AN INTERNAL SUBROUTINE (GOSUB)
*       1 - Display LOCATION 
*       2 - Display Location and PAUSE
*       3 - Display Location and INPUT <cr>
*
*   4   Display Item ID Flag
*       1 - Display Item ID being processed
*       2 - Display Item ID being processed and PAUSE
*       3 - Display Item ID being processed and INPUT <cr>
*       6 - Display Item ID and MSG when ERROR/REJECTED, etc.
*
*   5   LIST.NAME to be PROCESSED
*
*   6   TEST.DATE to be used (EXTERNAL FORMAT)
*
*   7   BREAK is ON
*
*   8   TIMING Display is ON
*
*   9   TYPE-AHEAD is OFF
*
*  10   Application / Routine Name Table
*
*  11   Test Flag Value for Table
*
*  12   W/O Sup-application Flags
*    mv 1 W/O Processing in Genie
*    mv 2  "  Printing
*    mv 3  "  Type processing Disc
*    mv 4  "   "       "      Connect
*    mv 5  "   "       "      Transfers
*    mv 6  "   "       "      Premium
*    mv 7 Device processing
*    mv 8 Addr Intfc processing
*    mv 9 Headend Intfc ports
*
*  13   Billing Sub-application Flags
*    mv 1 Billing
*    mv 2 Statements
*    mv 3 Daily update
*    mv 4 Monthly update
*    mv 5 EFT/PAC processing
*    mv 6 Late charges
*
*  14   System Maintenence Flags
*    mv 1 Parameters
*    mv 2 Purging
*    mv 3 Backup/Restore
*    mv 4 Printer processing
*    mv 5 Input processing
*    mv 6 Numeric/Special conversions
*
*  15   Release Distribution Flags
*
*  16   Standard Number of Pauses
*         typically 1 to 3 seconds
*
!
!
*
* Note: The structure of the test flags is
*
* 1 - 9      system 
*
* 10 - 15  Applications
*
* 10  { spec.appl#1 { spec.appl#2 { spec.appl#3 { . . . } } } }
* 11  { spec.val#1  { spec.val#2  { spec.val#3  { . . . } } } }
*
!
!
* NOTE: The usage of test flags is
*
* blank - don't use this flag, use system flags
* 0     - Test status is force off at this level
* GT 0  - Test flag is forced off
*    9  - Use system RTN & LBL flag
*    1  - Display message (no pause)
*    2  - Display message and pause for val#
*    3  - Input a <cr> after msg display
*    4  - Full test control (3,5,6,7)
*    5  - Display id's (5,6,7)
*    6  - Display run stats (6,7)
*    7  - Display run progress only
*    8  - Do not write
*
!
*
* Statement label to be used:     LOAD.TST: *
*
* REQUIRES: 
*
*   TST$AM
*   TST$VM
*
!
*
~SYS.INCL.LOCK.ITEM~
*CODE.SEGMENT: SYS.INCL.LOCK.ITEM
*
IF NOT(STAT) AND LCK.ITM THEN
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,LCK.FILE.ID,LCK.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN STAT = LCK.STAT
WHILE NOT(STAT) AND LCK.STAT DO REPEAT
END
*
~SYS.INCL.LOG.ENTRY~
*CODE.SEGMENT: SYS.INCL.LOG.ENTRY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: 25 JAN 90
*
* (c) Copyright 1990
* MACROSCOPE DESIGN MATRIX
*
*# Load the error log record
EL.ID = "TRANSFER.LOG":EL.PREFIX
IF EL.CN THEN
TMP = (100000+EL.CN)[2,5]
EL.ID = EL.ID:"@":TMP
END
READ EL FROM PAR.FILE,EL.ID THEN EL.FOUND = TRUE ELSE EL.FOUND = FALSE; EL = ""
*
IF LEN(EL) + LEN(EL.DATA) GE 2000 THEN
EL.CN = EL.CN + 1
FKEY.ID = "TRANSFER.LOG.CN":EL.PREFIX
WRITE EL.CN ON PAR.FILE,FKEY.ID
*
EL.ID = "TRANSFER.LOG":EL.PREFIX
TMP = (100000+EL.CN)[2,5]
EL.ID = EL.ID:"@":TMP
EL = EL.DATA
END ELSE
EL<-ONE> = EL.DATA
END
*
*# Write error log
WRITE EL ON PAR.FILE,EL.ID
*
~SYS.INCL.LPT.CO~
*CODE.SEGMENT: SYS.INCL.LPT.CO
*
*
PRINT FF:TIMEDATE() "L#25":(SPACE(40 - LEN(CO.NAME) / TWO):CO.NAME) "L#80":("Page ":LPT.PG) "R#25"
*
~SYS.INCL.MAIN.RSP~
*CODE.SEGMENT: SYS.INCL.MAIN.RSP
*
*
EQU MAIN.RSP TO "*M*?*TOPIC*TCL*OFF*EXIT*SCHEDULE*"
*#
*#       Clear screen.
PRINT @(0,5):CLS:
*#
*#       Lock User record.
*LOOP
*
~SYS.INCL.MENU.RSP~
*CODE.SEGMENT: SYS.INCL.MENU.RSP
*
*DGH 870624
*DGH 871216
*
EQU MENU.RSP TO "*MKTG*FILES*DICTS*MENUS*LISTS*AXION*DSL*UTILS*UT*PG*ED*M*"
*
*#NU.RSP.SYN TO "*/MKTG*/FILES*/DICTS*/MENUS*/LISTS*/AXION*/DSL*/UTILS*/UTILS*/PG*/SD@CD*/*"
*
*
~SYS.INCL.MENU.RSP.SYNONYM~
*CODE.SEGMENT: SYS.INCL.MENU.RSP
*
*DGH 870624
*DGH 871216
*
******* MENU.RSP TO "*MKTG*FILES*DICTS*MENUS*LISTS*AXION*DSL*UTILS*UT*PG*ED*M*"
*
EQU MENU.RSP.SYN TO "*/MKTG*/FILES*/DICTS*/MENUS*/LISTS*/AXION*/DSL*/UTILS*/UTILS*/PG*/SD@CD*/*"
*
*
~SYS.INCL.OFF.RSP~
*CODE.SEGMENT: SYS.INCL.OFF.RSP
*
*
EQU OFF.RSP TO "*OFF*off*Off*STOP*stop*HALT*halt*Halt*BYE*bye*Bye*LOGOFF*logoff*Logoff*"
*
~SYS.INCL.OPER.LOAD~
*CODE.SEGMENT: SYS.INCL.OPER.LOAD
*
READV OPER FROM PAR.FILE,CALL.ID,8 ELSE NULL
*
~SYS.INCL.PACK.NUMBER~
*CODE.SEGMENT: SYS.INCL.PACK.NUMBER
*
* AUTHOR:            DAVID STERN - AXION
* UPDATED:           DAVID HORSMAN - MACROSCOPE
* DESCRIPTION:       UNPACK A NUMBER IN HEX
*
BEGIN CASE
CASE OPSYS EQ "R"
IF NUM.IN MATCHES "0N" THEN NUM.OUT = ICONV(NUM.IN,"HEX") ELSE
IF NUM.IN MATCHES "'-'0N" THEN NUM.OUT = CHAR(13):ICONV(-NUM.IN,"HEX") ELSE NUM.OUT = EMPTY
END
CASE OPSYS EQ "U"
IF NUM.IN MATCHES "0N" THEN NUM.OUT = ICONV(NUM.IN,"MX") ELSE
IF NUM.IN MATCHES "'-'0N" THEN NUM.OUT = ICONV(NUM.IN,"MX") ELSE NUM.OUT = EMPTY
END
CASE OPSYS EQ "M"
IF NUM.IN MATCHES "0N" THEN NUM.OUT = ICONV(NUM.IN,"MX") ELSE
IF NUM.IN MATCHES "'-'0N" THEN NUM.OUT = CHAR(13):ICONV(-NUM.IN,"MX") ELSE NUM.OUT = EMPTY
END
CASE TRUE; NUM.OUT = EMPTY
END CASE
*
~SYS.INCL.PARSE.LINE~
*CODE.SEGMENT: SYS.INCL.PARSE.LINE
*
EQU EOF TO CHAR(26)
EQU XOF TO CHAR(19)
EQU XON TO CHAR(17)
*
! VERB THEN ELSE TERM
*
* OPEN file.name {THEN statements {END }}ELSE statements {END}
*OPEN_file.var,file.name.string_{
*THEN{_|<rs>}statement{<rs>statements . . .}{_|<rs>END}
*}ELSE{_|<rs>}statement{<rs>statements . . .}{<rs>|<rs>END}
* "@SYS@VERBS"
*
! FUNCTION TERM
* "@SYS@FUNCTIONS"
*
! COND THEN ELSE TERM
*
*IF_condition_THEN{_|<rs>}statement{<rs>statements . . .}{<rs>|<rs>END}{
*{_|_}ELSE{_|<rs>}statement{<rs>statements . . .}{<rs>|<rs>END}}
* "@SYS@CONDITIONS"
*
! LOOP THEN COND THEN
* "@SYS@LOOPS"
*
*
SYS$LN.SEP = ';':AM
SYS$LN.PREFIX.SEP = '!*/\@'
SYS$CLAUSE.SEP = "'":'" ;'
SYS$WORD.SEP = "'":' ,"-.;:'
SYS$REFERENCE.SEP = '(<[,;: '
SYS$REFERENCE.TERM = ',)]>'
* SYS$PERSOR.SEP = ?
* SYS$SYLLABLE.SEP = ?
* "@SYS@FUNCTIONS"
*
TC.CN = ONE; OLD.TC.CN = TC.CN
*
IF TERM.DISP THEN
IF LEN(LINE) GT 77 THEN TMP.DISP = FALSE ELSE
PRINT @(ZERO,19):CLL:
PRINT @(ZERO,20):CLL:
PRINT @(ZERO,21):CLL:" ":LINE "L#77":
PRINT @(ZERO,22):CLL:
TMP.DISP = TRUE
END
END ELSE TMP.DISP = FALSE
*
! LOOP To process words in line
*
LOOP
*
*
! LOOP To get next word
*
LOOP
*
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
*
TC.CONT = TRUE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
UNTIL TC.CONT OR TC EQ EMPTY DO TC.CN = TC.CN + ONE REPEAT
*
FIRST = LINE[ONE,TC.CN - ONE]
*
IF TMP.DISP THEN
PRINT @(ZERO,22):RVB:">":STR("-",TC.CN - ONE):"<":RVE:" ":
END
*
IF TMP.DISP THEN
PRINT @(ZERO,20):CLL:RVB:FIRST:RVE:" ":
END
*
~SYS.INCL.PICKTR.COMMANDS~
*CODE.SEGMENT: SYS.INCL.PICKTR.COMMANDS
*CODE.SEGMENT: COMMAND.PROCESS
*
*Subroutine to parse control parameters
*      
COMMAND.SCAN = TRUE
*# Loop to input program control parameters from master computer
LOOP
*      
DEL.CN = ZERO
BLCK.RSP = ITEM<ONE>
*      
IF BLCK.RSP EQ NULL.FLAG THEN
DEL.CN = ONE
END ELSE IF BLCK.RSP[ONE,9] EQ COMMAND THEN
BLCK.RSP = BLCK.RSP[TEN,HI.NUM]; DEL.CN = ONE
IF ITEM<TWO> EQ NULL.FLAG THEN
ITEM<TWO> = EMPTY
IF ITEM<3> EQ NULL.FLAG THEN
ITEM<3> = EMPTY
IF ITEM<4> EQ NULL.FLAG THEN
ITEM<4> = EMPTY
IF ITEM<5> EQ NULL.FLAG THEN
ITEM<5> = EMPTY
END
END
END
END
*
*      
*# Load program control parameters from master computer
*      
IF BLCK.RSP EQ "?INIT" THEN
INIT.FLAG = FALSE
*
END ELSE IF BLCK.RSP EQ "INIT" THEN
DIR.FLAG = EMPTY; IN.FILE.NAME  = EMPTY; OUT.FILE.NAME = EMPTY
IN.ITEM.NAME  = EMPTY; COMM.SYS.NAME = EMPTY
OOUT.ITEM.NAME = EMPTY; OPTIONS = EMPTY; ACCT.NAME = EMPTY
IF NOT(FROM.LIST AND LIST.SOURCE) THEN LIST.NAME = EMPTY; LIST.SOURCE = EMPTY
*      
INIT.FLAG = TRUE; CDIR.FLAG = FALSE; FILE.FLAG = FALSE; ITEM.FLAG = FALSE
OPTN.FLAG = FALSE; LIST.FLAG = FALSE; ACCT.FLAG = FALSE; SYST.FLAG = FALSE
SRCE.FLAG = FALSE
*      
END ELSE IF BLCK.RSP EQ "ITEM.TYPE" THEN
VRF.ITEM.TYPE = ITEM<TWO>; DEL.CN = TWO
IF VRF.ITEM.TYPE NE ITEM.TYPE THEN STAT = 16
*      
END ELSE IF BLCK.RSP EQ "TDIR" THEN
DIR.FLAG = ITEM<TWO>; DEL.CN = TWO
CDIR.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "FNAM" THEN
IN.FILE.NAME = ITEM<TWO>
OUT.FILE.NAME = ITEM<3>; DEL.CN = 3
FILE.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "INAM" THEN
OUT.ITEM.NAME = ITEM<TWO>
IN.ITEM.NAME = ITEM<3>; DEL.CN = 3
ITEM.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "OPTN" THEN
OPTIONS = ITEM<TWO>; DEL.CN = TWO
OPTN.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "SRCE" THEN
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.SOURCE = ITEM<TWO>
DEL.CN = TWO
SRCE.FLAG = TRUE
ITEM.DATE = EMPTY
*
END ELSE IF BLCK.RSP EQ "LIST.CN" THEN
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.CN = ITEM<TWO>
DEL.CN = TWO
*
END ELSE IF BLCK.RSP EQ "ABORT" THEN
ABORT.FLAG = ITEM<TWO>; DEL.CN = TWO
STAT = ABORT.RECVD; *# ABORT RECEIVED
*
END ELSE IF BLCK.RSP EQ "LIST" THEN
DEL.CN = TWO
IF NOT(LIST.SOURCE AND FROM.LIST) THEN
LIST.NAME = ITEM<TWO>
IF NOT(LEN(LIST.NAME)) THEN LIST.FLAG = FALSE; FROM.LIST = FALSE ELSE
LIST.FLAG = TRUE
IF LIST.SOURCE THEN
IF NOT(FROM.LIST) THEN
IF COUNT(LIST.NAME," ") THEN
EXEC.VERB = LIST.NAME
END ELSE IF LIST.NAME EQ "*" OR LIST.NAME EQ "ALL" THEN
EXEC.VERB = "SSELECT ":IN.FILE.NAME
END ELSE
EXEC.VERB = "GET-LIST ":LIST.NAME
END
EXECUTE EXEC.VERB, //OUT. > EXEC.RSP
CP<20> = EXEC.RSP
END
END; *# of list.source
FROM.LIST = TRUE
END; *# of not(from.list)
END; *# of not master or source
*      
END ELSE IF BLCK.RSP EQ "ACCT" THEN
ACCT.NAME = ITEM<TWO>; DEL.CN = TWO
*# IF LEN(ACCT.NAME) AND ACCT.NAME NE ACCT THEN PRINT "???????ACCT??????"; STOP
ACCT.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "SYST" THEN
TMP = ITEM<TWO>; DEL.CN = TWO
COMM.SYS.NAME = FIELD(TMP,"#",1)
DICT.BASE = ZERO; FILE.BASE = ZERO
FILE.OPT = FIELD(TMP,"#",2)
DICT.MOD = FIELD(TMP,"#",3); DICT.SEP = FIELD(TMP,"#",4)
FILE.MOD = FIELD(TMP,"#",5); FILE.SEP = FIELD(TMP,"#",6)
*# IF LEN(SYS.NAME) AND SYS.NAME NE COMM.SYS.NAME THEN PRINT "???????SYS??????"; STOP
SYST.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "TP.MAX" THEN
TP.MAX = ITEM<TWO>; DEL.CN = TWO
*      
END ELSE IF BLCK.RSP EQ "ERR.CN" THEN
ERR.CN = ITEM<TWO>; DEL.CN = TWO
IF MAIN.FLAG EQ SLAVE THEN ERR.CN = ERR.CN + TWO
IF ERR.CN LT ERR.LOW THEN ERR.CN = ERR.LOW
*      
END ELSE IF BLCK.RSP EQ "ERROR" THEN
BLCK.RSP = ITEM<TWO>; DEL.CN = TWO
STAT = 47; *# ERROR RECEIVED
CP<16,-1> = BLCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*      
END ELSE IF BLCK.RSP EQ "DONE" THEN
DONE.FLAG = WORK.DONE
*      
END ELSE IF BLCK.RSP EQ "?INAM" THEN
ITEM.FLAG = FALSE
*      
END ELSE IF BLCK.RSP EQ "END.LIST" THEN
FROM.LIST = FALSE
STAT = LIST.FINISHED
*      
END ELSE IF BLCK.RSP EQ "KILL" OR BLCK.RSP EQ "OFF" OR BLCK.RSP EQ "TCL" OR BLCK.RSP[ONE,5] EQ "ERROR" OR BLCK.RSP[ONE,ONE] EQ "?" THEN
STAT = ABORT.RECVD; *# KILL/OFF/TCL/ERROR RECEIVED
CP<16,-1> = BLCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*
END ELSE
ERR.CN.ALL = ERR.CN.ALL + ONE
END; *# of valid commands
*
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE
*      
END ELSE
IF BLCK.RSP EQ "KILL" OR BLCK.RSP EQ "OFF" OR BLCK.RSP EQ "TCL" THEN
*# Block is a user command
*      
IF MAIN.FLAG NE MASTER THEN STAT = 37 ; *# Terminal entered KILL,OFF,TCL command
*      
END
*# Block is not a command
* ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
IF NOT(CNTR.FLAG) THEN COMMAND.SCAN = FALSE ELSE DEL.CN = ONE
*      
END; *# of block not command
*      
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERROR.ABORT
*      
LOOP WHILE DEL.CN DO DEL ITEM<ONE,ZERO,ZERO>; DEL.CN = DEL.CN - ONE REPEAT
WHILE LEN(ITEM) AND COMMAND.SCAN DO REPEAT
*      
~SYS.INCL.PICKTR.DETAIL~
*CODE.SEGMENT: SYS.INCL.PICKTR.DETAIL
*      
*#  MAIN.FLAG EQ ENTRY
IF MAIN.FLAG EQ ENTRY THEN
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
PRINT
PRINT
PRINT "Enter item name: ":
LOOP
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "LIST" OR RSP EQ "*" OR RSP EQ "ALL" THEN
PRINT
PRINT "Enter list name: ":
IF RSP EQ "*" OR RSP EQ "ALL" THEN LIST.NAME = "*" ELSE INPUT LIST.NAME
LOOP TC = LIST.NAME[ONE,ONE] WHILE LEN(LIST.NAME) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO LIST.NAME = LIST.NAME[TWO,HI.NUM] REPEAT
IF LIST.NAME EQ "KILL" THEN ABORT
IF LIST.NAME EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF LIST.NAME[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
PRINT
PRINT "On this system (Y/N)? ":
INPUT YES.NO
IF YES.NO[ONE,ONE] EQ "Y" OR YES.NO[ONE,ONE] EQ "y" OR YES.NO = EMPTY THEN LIST.SOURCE = TRUE ELSE LIST.SOURCE = FALSE
END ELSE
LIST.SOURCE = EMPTY; LIST.NAME = EMPTY
END
WHILE NOT(DONE.FLAG) AND NOT(LEN(RSP)) OR SYSTEM(ELEVEN) GT 3 DO REPEAT
*
IN.ITEM.NAME = RSP
PRINT
*
IF NOT(DONE.FLAG OR LEN(LIST.NAME) OR STAT) THEN
PRINT "Enter output item name (":IN.ITEM.NAME:"): ":
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = IN.ITEM.NAME ELSE OUT.FILE.NAME = EMPTY
*
IF OUT.FILE.NAME NE IN.FILE.NAME THEN
IF NOT(LEN(OUT.FILE.NAME)) THEN OUT.FILE.NAME = IN.FILE.NAME
PRINT
PRINT "Enter output file name (":OUT.FILE.NAME:"): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = OUT.FILE.NAME
* OUT.FILE.NAME = IN.FILE.NAME
END
OUT.ITEM.NAME = RSP
END; *# of not done
*
MAX = 0
ISIZE = 0
*      
END; *# of MAIN.FLAG EQ ENTRY
*      
~SYS.INCL.PICKTR.EQU~
*CODE.SEGMENT: SYS.INCL.PICKTR.EQU
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
ERR.VRF.ARRAY<3> = "RECVD":VM:"STAT":VM:"CHK.SUM.BAD":VM:"CHK.ID":VM:"NON.PACKET":VM:"CHK.SUM":VM:"KEYBOARD.ABORT":VM:"PREV.CHK.ID":VM:"END":VM:"ABORT":VM:"CHOKE":VM:"HEX.ON":VM:"13":VM:"MAX.ERR.ABORT":VM:"SLEEP":VM:"PAUSE"
ERR.VRF.ARRAY<5> = 1:VM:2:VM:0:VM:0:VM:0:VM:0:VM:0:VM:0:VM:9:VM:10:VM:11:VM:12:VM:0:VM:14:VM:15:VM:16
*      
*# Equates Area
*
*# Miscellaneous
EQU ZERO            TO 0
EQU ONE             TO 1
EQU TWO             TO 2
EQU TEN             TO 10
EQU ELEVEN          TO 11
EQU HI.NUM          TO 99999
EQU NULL.FLAG       TO "@}n"
EQU COMMAND         TO "@}c"
EQU PERR.MESSAGE    TO "@}e"
EQU CONT.MESSAGE    TO "@}+"
*
EQU EMPTY TO ""
*
*# Equates for DONE.FLAG
EQU SCAN.FOR.WORK   TO 1;   *# DONE.FLAG
EQU SHUTDOWN.DONE   TO 9;   *# DONE.FLAG
EQU ABORT.PRESENT   TO 16;  *# DONE.FLAG
*QU ABORT.VRF     TO 17;  *# DONE.FLAG
EQU UNAVAIL.SCHED   TO 18;  *# DONE.FLAG
EQU NO.WORK         TO 19;  *# DONE.FLAG
EQU WORK.DONE       TO 59;  *# DONE.FLAG
EQU ENTRY.DONE      TO 39;  *# DONE.FLAG
*QU ABORT.COMMAND   TO 117; *# DONE.FLAG
*
*# Equates for STAT
*
*# Error message verification & counting
EQU RECVD.VRF            TO 1; *# STAT
EQU STAT.VRF             TO 2; *# STAT
EQU CHK.SUM.BAD.VRF      TO 3; *# STAT
EQU CHK.ID.VRF           TO 4; *# STAT
EQU NON.PACKET.VRF       TO 5; *# STAT
EQU CHK.SUM.VRF          TO 6; *# STAT
EQU KEYBOARD.ABORT.VRF   TO 7; *# STAT
EQU PREV.CHK.ID.VRF      TO 8; *# STAT
EQU END.VRF              TO 9; *# STAT
EQU ABORT.VRF            TO 10; *# STAT
EQU CHOKE.VRF            TO 11; *# STAT
EQU HEX.FLAG.VRF         TO 12; *# STAT
*13
EQU MAX.ERR.ABORT.VRF    TO 14; *# STAT
EQU SLEEP.VRF            TO 15; *# STAT
EQU PAUSE.VRF            TO 16; *# STAT
*
*# Resource control parameters
EQU ITEM.TYPE.ERROR      TO 17;  *# STAT
EQU UNAVAIL.SCHED.STAT   TO 18;  *# STAT
EQU LIST.FINISHED        TO 19;  *# STAT
EQU FILE.MISSING         TO 20;  *# STAT
EQU ITEM.OV.ERROR        TO 21;  *# STAT
EQU ITEM.NEW.ERROR       TO 22;  *# STAT
EQU ITEM.OV.RQRD.ERROR   TO 23;  *# STAT
EQU FPOINTER.OV.ERROR    TO 24;  *# STAT
EQU FPOINTER.TR.ERROR    TO 25;  *# STAT
EQU ITEM.MISSING         TO 26;  *# STAT
EQU MAX.ITEM.SIZE        TO 29;  *# STAT
EQU WAIT.ERROR           TO 30;  *# STAT
EQU LOGOFF.COMMAND       TO 31;  *# STAT
EQU COMM.ERROR.STAT      TO 32;  *# STAT
EQU LINE.HUNG            TO 33;  *# STAT
*
*
*# Main program control
EQU MASTER         TO "MASTER"
EQU SLAVE          TO "SLAVE"
EQU ENTRY          TO "ENTER"
EQU DIN            TO "IN"
EQU DOUT           TO "OUT"
*
EQU CP TO COMM.PARAM 
EQU TP TO TRANS.PARAM
*
~SYS.INCL.PICKTR.HEADER~
*CODE.SEGMENT: SYS.INCL.PICKTR.HEADER
*
* DAVID HORSMAN 03 OCT 89
*
FILE.OPT = "MC,S,?,QC"
IF MAIN.FLAG = MASTER  THEN
PRINT
END ELSE
*      
*#  MAIN.FLAG = SLAVE OR ENTRY
PRINT
PRINT
PRINT "Enter direction of tranfer (OUT)":
INPUT RSP
*      
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
* MAIN.FLAG = ENTRY
*      
IF RSP EQ "" THEN RSP =  DOUT
IF RSP NE DIN AND RSP NE DOUT THEN RSP = DOUT
DIR.FLAG = RSP
*      
PRINT
PRINT
PRINT "Enter the system name (UNKNOWN)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "UNKNOWN"
COMM.SYS.NAME = RSP
*      
PRINT
PRINT
PRINT "Enter the account name (SYSPROG)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "SYSPROG"
ACCT.NAME = RSP
*      
PRINT "Enter the account password (PUBLIC)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "PUBLIC"
ACCT.PASS = RSP
*      
PRINT
PRINT
PRINT "Enter input file name (BP)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "BP"
IN.FILE.NAME = RSP
*      
PRINT
PRINT
PRINT "Enter output file name (BP): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "BP"
OUT.FILE.NAME = RSP
*      
LOOP
CONT = FALSE
PRINT
PRINT
PRINT "Enter options (O): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "O"
CN = ZERO
OPTIONS = EMPTY
LOOP
CN = CN + ONE
TC = RSP[CN,ONE]
WHILE TC NE EMPTY DO
IF NOT(INDEX("OAEN",TC,ONE)) THEN CONT = TRUE ELSE OPTIONS = OPTIONS:TC
*# O OVERWRITE
*# A APPEND
*# E EXISTS ON FILE
*# N NON-EXISTANT ONLY
*      
REPEAT
*
WHILE CONT DO REPEAT
*
LOOP
CONT = FALSE
PRINT
PRINT
PRINT "Enter the file creation options (MD,S,?,QC): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" AND TC NE "," DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "MC,S,?,QC"
CN = ZERO
FILE.OPT = EMPTY
CNMAX = COUNT(RSP,",") + ONE
LOOP
CN = CN + ONE
TC = FIELD(RSP,",",CN)
WHILE CN LE CNMAX DO
IF NOT(INDEX("FC,DC,DAC,MC,S,?,QC",TC,ONE)) THEN CONT = TRUE ELSE
IF LEN(TC) THEN
IF LEN(FILE.OPT) THEN FILE.OPT = FILE.OPT:","
FILE.OPT = FILE.OPT:TC
END
END
*# FC File creation (dict and/or data) OK
*# DC Dict creation OK
*# DAC Data area creation OK
*# MC MD Q-pointer create OK
*# S Search for the file as far as is possible
*# ? Asking the user questions is OK
*# QC Q-pointer for file is OK to create
*      
REPEAT
*
WHILE CONT DO REPEAT
*
IF DIR.FLAG EQ DIN THEN
CFILE.NAME = OUT.FILE.NAME
END ELSE CFILE.NAME = IN.FILE.NAME
*
MD.FILE.NAME = "MD"; DICT.NAME = CFILE.NAME; DICT.BASE = FALSE; DICT.MOD = FALSE; DICT.SEP = FALSE; FILE.MOD = FALSE; FILE.SEP = FALSE; FILE.NAME = CFILE.NAME; FILE.BASE = FALSE; STAT = FALSE; PROG.DEBUG = FALSE
*
CALL SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,FILE.OPT,FILE.NAME,FILE.BASE,STAT,PROG.DEBUG)
*
*PRINT BELL:; INPUT POOP
*
END; *# of SLAVE OR ENTRY
*      
~SYS.INCL.PICKTR.JOB.LOAD~
*CODE.SEGMENT: SYS.INCL.PICKTR.JOB.LOAD
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 17 FEB 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
TP<TP.CN+ONE,ONE> =  IN.FILE.NAME
TP<TP.CN+ONE,TWO> = OUT.FILE.NAME
TP<TP.CN+ONE,3> =  IN.ITEM.NAME
TP<TP.CN+ONE,4> = OUT.ITEM.NAME
TP<TP.CN+ONE,5> =       OPTIONS
TP<TP.CN+ONE,6> =      DIR.FLAG
TP<TP.CN+ONE,7> =     LIST.NAME
TP<TP.CN+ONE,8,ONE> = ACCT.NAME
TP<TP.CN+ONE,8,TWO> = ACCT.PASS
TP<TP.CN+ONE,9,ONE> = COMM.SYS.NAME
TP<TP.CN+ONE,9,TWO> = FILE.OPT
TP<TP.CN+ONE,9,3>   = DICT.MOD
TP<TP.CN+ONE,9,4>   = DICT.SEP
TP<TP.CN+ONE,9,5>   = FILE.MOD
TP<TP.CN+ONE,9,6>   = FILE.SEP
TP<TP.CN+ONE,TEN> =  LIST.SOURCE
IF MAIN.FLAG EQ ENTRY THEN
TP<TP.CN+ONE,ELEVEN> = EMPTY
TP<TP.CN+ONE,12> = ZERO
END
*
~SYS.INCL.PRINT.INIT~
*CODE.SEGMENT: SYS.INCL.PRINT.INIT 
*
TMP = "LP":AM:"PKH":AM:"AUX":AM:"TERM"
LOOP
PRINT
PRINT "ENTER PRINTER DEVICE (LP,PKH,AUX,TERM): ":
INPUT RSP
LOCATE RSP IN TMP SETTING PRINTER.FLAG ELSE PRINTER.FLAG = ZERO
WHILE NOT(PRINTER.FLAG) DO PRINT BELL: REPEAT
~SYS.INCL.PRINT.OFF~
*CODE.SEGMENT: SYS.INCL.PRINT.OFF 
*
BEGIN CASE
CASE PRINTER.FLAG EQ ONE
PRINTER OFF
CASE PRINTER.FLAG EQ TWO
PRINT CAPT.PRNT.OFF:
CASE PRINTER.FLAG EQ 3
PRINT AUX.OFF:
CASE TRUE
END CASE
~SYS.INCL.PRINT.ON~
*CODE.SEGMENT: SYS.INCL.PRINT.ON 
*
BEGIN CASE
CASE PRINTER.FLAG EQ ONE
PRINTER ON
CASE PRINTER.FLAG EQ TWO
PRINT CAPT.PRNT.ON:
CASE PRINTER.FLAG EQ 3
PRINT AUX.ON:
CASE TRUE
END CASE
~SYS.INCL.QUIET.LOAD~
*CODE.SEGMENT: SYS.INCL.QUIET.LOAD
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
LINE.MAX.LEN = CP<TWO>
IF NOT(LINE.MAX.LEN) THEN LINE.MAX.LEN = 70
*# Maximum # of err's for this run
ERR.MAX.ALL = CP<3>
IF NOT(ERR.MAX.ALL) THEN ERR.MAX.ALL = 1000
*# Maximum # of err - floating speed regulator
ERR.MAX = CP<4>
IF NOT(ERR.MAX) THEN ERR.MAX = 30
*ERR.CN = CP<5>
*IF NOT(NUM(ERR.CN)) THEN ERR.CN = ZERO
*IF NOT(ERR.CN) THEN ERR.CN = 3
*LOOP WHILE ERR.CN GE ERR.MAX AND ERR.CN GT TEN DO ERR.CN = ERR.CN - TEN REPEAT
COMM.WAIT.MAX = CP<6>
IF NOT(COMM.WAIT.MAX) THEN COMM.WAIT.MAX = 300
COMM.WAIT.PAUSE = CP<7>
IF NOT(COMM.WAIT.PAUSE) THEN COMM.WAIT.PAUSE = ONE
COMM.WAIT.CLEAR = CP<8>
IF NOT(COMM.WAIT.CLEAR) THEN COMM.WAIT.CLEAR = 75
*ERR.CN.ALL = CP<9>
*ERR.CN.ALL = ZERO
*ERR.CN.TOTAL = CP<TEN>
*IF NOT(NUM(ERR.CN.TOTAL)) THEN ERR.CN.TOTAL = ZERO
*IF NOT(NUM(ERR.CN.ALL)) THEN ERR.CN.ALL = ZERO
COMM.SYNC = CP<ELEVEN>
IF NOT(NUM(COMM.SYNC)) THEN COMM.SYNC = EMPTY
COMM.WAIT.QUIET = CP<ONE>
*ERR.CN.ARRAY = CP<17>
AM.MAX = CP<18>
IF AM.MAX LE 5 THEN AM.MAX = 100
ERR.LOW = CP<19,ONE>; ERR.OUT.OFFSET = CP<19,TWO>; ERR.IN.OFFSET = CP<19,3>; ERR.CHOKE = CP<19,4>; ERR.HI = CP<19,5>
*IF ERR.CN LT ERR.LOW THEN ERR.CN = ERR.LOW
*      
~SYS.INCL.QUIET.WRITE~
*CODE.SEGMENT: SYS.INCL.QUIET.WRITE
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
READ COMM.PARAM FROM PAR.FILE,"TRANSFER.QUIET":PORT ELSE
READ COMM.PARAM FROM PAR.FILE,"TRANSFER.QUIET" ELSE
CP = ""
END
END
CP<5> = ERR.CN
CP<9> = ERR.CN.ALL
CP<10> = ERR.CN.TOTAL + ERR.CN.ALL
CP<12,1,1> = DATE()
CP<12,1,2> = TIME()
CP<12,1,3> = WHO
* :COMM.ERROR:SVM
CP<12,1,5> = STAT
* :TRANS.CN:SVM:TRANS.MAX:SVM:DONE.FLAG:SVM:COMM.INIT:SVM:COMM.STARTUP:SVM:COMM.SHUTDOWN:SVM:
* ACK.RSP
CP<12,1,12> = ACK.RSP
CP<12,1,13> = LINE.PACKET
CP<17> = ERR.CN.ARRAY
CP<28> = ERR.LEVEL
IF LEN(CP) GT 10000 THEN CP = CP[1,7000]
ERR.LOW = CP<19,ONE>; ERR.OUT.OFFSET = CP<19,TWO>; ERR.IN.OFFSET = CP<19,3>; ERR.CHOKE = CP<19,4>; ERR.HI = CP<19,5>
WRITE COMM.PARAM ON PAR.FILE,"TRANSFER.QUIET":PORT
* IF STAT  AND NOT(ERR.SENT AND ERR.RECVD) THEN
* PRINTER ON
* PRINT FF:
* PRINT OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS"):" ":WHO
* TMP = DCOUNT(COMM.PARAM,AM)
* FOR TMP1 = ONE TO TMP
* PRINT COMM.PARAM<TMP1>
* NEXT TMP1
* PRINT "ERR.CN ":ERR.CN
* PRINT "  STAT ":STAT
* PRINT "    CN ":CN
* PRINT "   MAX ":MAX
* PRINT
* PRINT "  ITEM ":ITEM<ONE>
* PRINT "  LINE ":LINE
* PRINT FF:
* PRINTER OFF
* PRINTER CLOSE
* END
*
~SYS.INCL.RECORD.TIME~
*CODE.SEGMENT: SYS.INCL.RECORD.TIME
*# 870630 DGH
RECORD.TIME: * to record time usage
*
IF CHECK.TIME AND INDEX(SYS.PROG,"SYS.TIME",1) # 0 THEN RETURN
IF CHECK.TIME < 3 OR CHECK.TIME > 7 THEN
IF EQ.PROG.TYPE > 1 THEN CHECK.TIME = 1 ELSE CHECK.TIME = 9
END
CALL SYS.TIME
*END
*
RETURN
*
~SYS.INCL.RECORD.USER.CALL~
*CODE.SEGMENT: SYS.INCL.RECORD.USER.CALL
* 870630 DGH
!
RECORD.USER.CALL: *Subroutine to update user info
*
SYS.SLOC<1> = "RECORD.USER.CALL"
IF CALL.FUNCTION<1> # "LOGON" AND CALL.FUNCTION<1> # "LOGOFF" AND CALL.FUNCTION<1> # "MENU" THEN CALL.FUNCTION<1> = "UNKNOWN"
IF CALL.SUB.FUNCTION<1> # "UPDATE" AND CALL.SUB.FUNCTION<1> # "READ" THEN
IF CALL.SUB.FUNCTION<1> # "WRITE" AND CALL.SUB.FUNCTION<1> # "RESET" THEN RETURN
END
LOOP
SYS.FILE = "SYS"
IF STRUCT(2) # "" THEN USER.NAME = STRUCT(2)
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
WHILE (USER.LOCKED AND USER.LOCKED # PORT+1) AND NOT(USER.ABORT) DO REPEAT
*
RETURN
!
RECORD.LOCATION: * to record you menu location AND topics
USER.UPD(2) = 1
TEMP = (100000+DATE())[2,5]
TEMP = TEMP:(100000+TIME())[2,5]
IF TEMP > LAST.LOCT + (STRUCT(48) * 5) OR INDEX(SYS.RSP,"*":PRMPTING:"*",1) # 0 THEN
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
LAST.LOCT = TEMP
END ELSE
STRUCT(29)<1,PORT + 1> = USER.CO.CODE
STRUCT(30)<1,PORT + 1> = MENU.APPL:SVM:MENU.SUB.APPL:SVM:MENU.GRP.APPL
STRUCT(31)<1,PORT + 1> = MENU.CONTROL<1,7>
STRUCT(32)<1,PORT + 1> = MENU.NAME
STRUCT(33)<1,PORT + 1> = PRMPTING
STRUCT(34)<1,PORT + 1> = TOPIC.KEY
STRUCT(35)<1,PORT + 1> = MENU.CONTROL<1,9>
END
*
RETURN
*
*
~SYS.INCL.REMOVE.AM~
*CODE.SEGMENT: SYS.INCL.REMOVE.AM
*
*
AM.CN = ONE
LOOP
AM.LOC = INDEX(LINE,CHAR(254),ONE)
WHILE AM.LOC DO
LINE = LINE[ONE,AM.LOC - ONE]:'":AM:"':LINE[AM.LOC + ONE,99999]
IF TF THEN PRINT @(50,23):'AM ':AM.CN:; * RQM
AM.CN = AM.CN + ONE
REPEAT
*
~SYS.INCL.REMOVE.ESC~
*CODE.SEGMENT: SYS.INCL.REMOVE.ESC
*
*
ESC.CN = ONE
LOOP
ESC.LOC = INDEX(LNS,CHAR(27),ONE)
WHILE ESC.LOC DO
AM.LOC = DCOUNT(LNS[1,ESC.LOC],CHAR(254))
LINE = LNS<AM.LOC>
LOOP
ESC.LOC = INDEX(LINE,CHAR(27),ONE)
WHILE ESC.LOC DO
LINE = LINE[ONE,ESC.LOC - ONE]:'":ESC:"':LINE[ESC.LOC + ONE,99999]
IF TF THEN PRINT @(40,23):'ESC ':ESC.CN:; * RQM
ESC.CN = ESC.CN + ONE 
REPEAT
LNS<AM.LOC> = LINE
REPEAT
*
~SYS.INCL.REMOVE.SVM~
*CODE.SEGMENT: SYS.INCL.REMOVE.SVM
*
*
SVM.CN = ONE
LOOP
SVM.LOC = INDEX(LNS,CHAR(252),ONE)
WHILE SVM.LOC DO
AM.LOC = DCOUNT(LNS[1,SVM.LOC],CHAR(254))
LINE = LNS<AM.LOC>
LOOP
SVM.LOC = INDEX(LINE,CHAR(252),ONE)
WHILE SVM.LOC DO
LINE = LINE[ONE,SVM.LOC - ONE]:'":SVM:"':LINE[SVM.LOC + ONE,99999]
IF TF THEN PRINT @(40,23):'SVM ':SVM.CN:; * RQM
SVM.CN = SVM.CN + ONE 
REPEAT
LNS<AM.LOC> = LINE
REPEAT
*
~SYS.INCL.REMOVE.VM~
*CODE.SEGMENT: SYS.INCL.REMOVE.VM
*
*
VM.CN = ONE
LOOP
VM.LOC = INDEX(LNS,CHAR(253),ONE)
WHILE VM.LOC DO
AM.LOC = DCOUNT(LNS[ONE,VM.LOC],CHAR(254))
LINE = LNS<AM.LOC>
LOOP
VM.LOC = INDEX(LINE,CHAR(253),ONE)
WHILE VM.LOC DO
LINE = LINE[ONE,VM.LOC - ONE]:'":VM:"':LINE[VM.LOC + ONE,99999]
IF TF THEN PRINT @(40,23):'VM ':VM.CN:; * RQM
VM.CN = VM.CN + ONE 
REPEAT
LNS<AM.LOC> = LINE
REPEAT
*
~SYS.INCL.RLS.ITM~
*CODE.SEGMENT: SYS.INCL.RLS.ITM
*
IF LCK.ITM THEN
CALL SYS.ITM.RLS(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TMP,"1",SYS.PROG,"0",OPER,EXP.LCK.TM,SYS.LOCT,"A","",LCK.STAT)
END
*
~SYS.INCL.RSP.KEY~
*CODE.SEGMENT: SYS.INCL.RSP.KEY 
*#
*# Subroutine to load slave key
*#
*# Variables: EQIOW      Rsp write slave output flag
*#            S27        Rsp mode (last char STRUCT(27)<1,PORT+1>)
*#            ESP        Rsp mode suffix
*#
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@RSP-STACK@"
*#
IF EQIOW THEN
SYS.ITEM = SYS.ITEM:"SLAVE@"
SYS.ITEM = SYS.ITEM:ESP
END ELSE
IF STRUCT(27)<1,PORT+1> LT 11 THEN
SYS.ITEM = SYS.ITEM:"SLAVE@"
END ELSE
SYS.ITEM = SYS.ITEM:"LAST@"
END
IF S27 EQ 4 THEN SYS.ITEM = SYS.ITEM:"QUE" ELSE
SYS.ITEM = SYS.ITEM:STR("0",2-LEN(PORT)):PORT
END
END
*#
~SYS.INCL.RUN.DISP.END~
*CODE.SEGMENT: SYS.INCL.RUN.DISP.END
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    26 NOV 91
*
IF NOT(SNGL) AND NOT(PHANTOM.RUN) THEN
IF NOT(T.CN) THEN T.CN = C.CN
IF CNT.TST$LBL THEN
PRINT CLB0:"Counts - Examined: ":C.CN "L#5":"  Skipped: ":S.CN "L#5":"  Updated: ":U.CN "L#5":
IF P.CN THEN PRINT "  Semi-updated: ":P.CN "L#5":
PRINT CLB1:"Total: ":RSTAT.MISC2 "L#8":"  Total time: ":OCONV(RSTAT.ELP,"MTS") "L#8":"  Update time: ":OCONV(U.TM,"MTS") "L#8":
IF P.CN THEN PRINT "  Semi-updated: ":P.CN "L#5":
IF CNT.TST$CR THEN PRINT " <cr>":; INPUT TMP:
END; * of CNT.TST$LBL
END; * of not sngl
*
~SYS.INCL.RUN.DISP.ID~
*CODE.SEGMENT: SYS.INCL.RUN.INS
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    25 NOV 91
*
IF NOT(SNGL) AND NOT(PHANTOM.RUN) THEN
B.CN = B.CN + ONE
IF CNT.TST$LBL OR B.CN GE D.CN THEN
B.CN = ZERO
IF U.CN NE ZERO THEN
U.TM.AVG = INT((U.TM / U.CN) * 100) / 100
END ELSE U.TM.AVG = EMPTY
C.ELP = ((DATE() - START.DT) * 86400) + (TIME() - START.TM)
C.TM.AVG = INT((C.ELP / C.CN) * 100) / 100
PRINT CLB0:"Times - Avg.: ":C.TM.AVG "L#5":"  Avg.Update: ":U.TM.AVG "L#5":"  Total: ":OCONV(C.ELP,"MTS"):  "  Last ID: ":ID "L#10":
PRINT CLB1:"Counts - Examined: ":C.CN "L#5":"  Skipped: ":S.CN "L#5":"  Updated: ":U.CN "L#5":
IF P.CN THEN PRINT "  Semi-updated: ":P.CN "L#5":
IF CNT.TST$CR THEN PRINT BELL:" <cr>":; INPUT TMP:
END; * of CNT.TST$LBL
END; * of not sngl
*
~SYS.INCL.RUN.ELP~
*CODE.SEGMENT: SYS.INCL.RUN.ELP
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
END.DT = DATE(); END.TM = TIME()
RSTAT.ELP = ((START.DT - END.DT) * 86400) + (END.TM - START.TM)
*
~SYS.INCL.RUN.INIT~
*CODE.SEGMENT: SYS.INCL.RUN.INIT
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
START.DT = DATE(); START.TM = TIME(); END.DT = START.DT; END.TM = START.TM
*
MATREAD CNT.RSTAT FROM CNT.FILE,RSTAT.ID ELSE
* RSTAT.ID = "SYSTEM.RUNS"
MATREAD CNT.RSTAT FROM CNT.FILE,"SYSTEM.RUNS" ELSE
MAT CNT.RSTAT = EMPTY
CNT.RSTAT$CN.MAX = 100
END
END
RSTAT.MAX = CNT.RSTAT$CN.MAX
IF NOT(CNT.RSTAT$LH) THEN CNT.RSTAT$LH = 50
D.CN = 100 / CNT.RSTAT$LH
IF CNT.RSTAT$PERCENT GT D.CN THEN D.CN = CNT.RSTAT$PERCENT
IF T.CN THEN D.CN = INT(T.CN * D.CN / 100) ELSE D.CN = CNT.RSTAT$UNITS
IF NOT(D.CN) THEN D.CN = ONE
*
C.CN = ZERO; C.TM = ZERO; U.CN = ZERO; U.TM = ZERO
P.CN = ZERO; P.TM = ZERO; S.CN = ZERO; S.TM = ZERO
RSTAT.MISC1 = EMPTY; RSTAT.MISC2 = EMPTY
RSTAT.MISC3 = EMPTY; RSTAT.MISC4 = EMPTY
RSTAT.RUN = ONE; RSTAT.ELP = ZERO; B.CN = ZERO; T.CN = ZERO
*
*
~SYS.INCL.RUN.INS~
*CODE.SEGMENT: SYS.INCL.RUN.INS
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    20 NOV 91
*
* CNT.FILE, RSTAT.ID, RSTAT.RUN, RSTAT.MAX, START.DT, START.TM, END.DT, END.TM
* , C.CN, C.TM, U.CN, U.TM, P.CN, P.TM, S.CN, S.TM
* , RSTAT.MISC1, RSTAT.MISC2, RSTAT.MISC3, RSTAT.MISC4
* , CNT.TST$LBL, STAT
* RSTAT.MAX
*
IF CNT.TST$LBL THEN
PRINT CLB:"SYS.INCL.RUN.INS ":
IF CNT.TST$CR THEN PRINT BELL:" <cr>":; INPUT TMP:
END
*
INS RSTAT.RUN  BEFORE CNT.RSTAT$RUN.NO<ONE,ONE>
INS START.DT  BEFORE CNT.RSTAT$DT<ONE,ONE>
INS START.TM  BEFORE CNT.RSTAT$TM<ONE,ONE>
INS END.DT    BEFORE CNT.RSTAT$END.DT<ONE,ONE>
INS END.TM    BEFORE CNT.RSTAT$END.TM<ONE,ONE>
RSTAT.ELP = ((END.DT - START.DT) * 86400) + (END.TM - START.TM)
INS RSTAT.ELP BEFORE CNT.RSTAT$ELP<ONE,ONE>
INS C.CN   BEFORE CNT.RSTAT$CN<ONE,ONE>
INS C.TM   BEFORE CNT.RSTAT$TM<ONE,ONE>
INS U.CN   BEFORE CNT.RSTAT$UPD.CN<ONE,ONE>
INS U.TM   BEFORE CNT.RSTAT$UPD.TM<ONE,ONE>
INS P.CN   BEFORE CNT.RSTAT$PUPD.CN<ONE,ONE>
INS P.TM   BEFORE CNT.RSTAT$PUPD.TM<ONE,ONE>
INS S.CN   BEFORE CNT.RSTAT$SKIP.CN<ONE,ONE>
INS S.TM   BEFORE CNT.RSTAT$SKIP.TM<ONE,ONE>
INS RSTAT.MISC1 BEFORE CNT.RSTAT$MISC1<ONE,ONE>
INS RSTAT.MISC2 BEFORE CNT.RSTAT$MISC2<ONE,ONE>
INS RSTAT.MISC3 BEFORE CNT.RSTAT$MISC3<ONE,ONE>
INS RSTAT.MISC4 BEFORE CNT.RSTAT$MISC4<ONE,ONE>
IF NOT(RSTAT.MAX) THEN RSTAT.MAX = 100
*
LOOP
RSTAT.CN = DCOUNT(CNT.RSTAT$RUN.NO,VM)
WHILE RSTAT.CN GT RSTAT.MAX DO
DEL CNT.RSTAT$RUN.NO<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$DT<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$END.DT<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$END.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$ELP<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$UPD.CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$UPD.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$PUPD.CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$PUPD.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$SKIP.CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$SKIP.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC1<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC2<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC3<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC4<ONE,RSTAT.MAX + ONE>
REPEAT
*
*
MATWRITE CNT.RSTAT ON CNT.FILE,RSTAT.ID
*
~SYS.INCL.SCR.CO~
*CODE.SEGMENT: SYS.INCL.SCR.CO
*SCR.CO,CO.NAME,PHAN.RUN
*
*DATE: 24 FEB 93
*
SCR.CO = OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15"
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ZERO):RVB:SCR.CO:RVE:
*
~SYS.INCL.SLEEP.1~
*CODE.SEGMENT: SYS.INCL.SLEEP.1
EXECUTE "SLEEP 1"
*
~SYS.INCL.SLEEP.10~
*CODE.SEGMENT: SYS.INCL.SLEEP.10
EXECUTE "SLEEP 10"
*
~SYS.INCL.SLEEP.3~
*CODE.SEGMENT: SYS.INCL.SLEEP.3
EXECUTE "SLEEP 3"
*
~SYS.INCL.SLEEP.5~
*CODE.SEGMENT: SYS.INCL.SLEEP.5
EXECUTE "SLEEP 5"
*
~SYS.INCL.STAT.LINE~
*CODE.SEGMENT: SYS.INCL.STAT.LINE
*
*
IF USER.MODE GE LO.D.M THEN
ZZTEMP = FIELD(SYS.PROG<1>,".",1)
IF INDEX("*SYS*CODE*SH*EI*","*":ZZTEMP:"*",1) NE 0 THEN
ZZTEMP = SYS.PROG<1>[COL2()+1,999]
END ELSE ZZTEMP = SYS.PROG<1>
PRINT @(0,23):
PRINT CO.DATA<3> "L#6":" ":STRUCT(2) "L#6":" ":
PRINT ZZTEMP "L#6":" ":SYS.LOCT<1> "L#6":" ":SYS.SLOC<1> "L#6":" ":
ZZTEMP = ''
END
*
~SYS.INCL.STATUS.CHECK~
*CODE.SEGMENT: SYS.INCL.STATUS.CHECK
*
EQU STAT.CHECK TO "*O*N*I*C*H*X*L*P*D*A*M*"
*
~SYS.INCL.STATUS.DESC~
*CODE.SEGMENT: SYS.INCL.STATUS.DESC
*
*$INCLUDE DH.IBP SYS.INCL.STATUS.DESC
*
STAT.DESC(1) = "Optional"
STAT.DESC(2) = "Not started"
STAT.DESC(3) = "In progress"
STAT.DESC(4) = "Complete"
STAT.DESC(5) = "Hold for now"
STAT.DESC(6) = "Cancelled"
STAT.DESC(7) = "Loaded"
STAT.DESC(8) = "Purged"
STAT.DESC(9) = "In Daily Schedule"
STAT.DESC(10) = "Add Step"
STAT.DESC(11) = "Modified"
STAT.DESC(12) = "?"
STAT.DESC(13) = "?"
STAT.DESC(14) = "?"
STAT.DESC(15) = "?"
*
~SYS.INCL.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
* ULT ONLY
FOR DELAY.CN = ONE TO DELAY.CN.MAX UNTIL SYSTEM(11)
* FOR DELAY.CN = ONE TO DELAY.CN.MAX; * REV ONLY
BEGIN CASE
CASE OPSYS EQ "U"
RQM
CASE OPSYS EQ "M"
EXECUTE "SLEEP 1"
CASE OPSYS EQ "R"
RQM
CASE TRUE
RQM
END CASE
NEXT DELAY.CN
*
*
~SYS.INCL.STEP.DISPLAY~
*CODE.SEGMENT: SYS.INCL.STEP.DISPLAY
*
SYS.SLOC<1> = "SCHED"
IF TASK.NUM # 0 AND PORTD<5> # "D" THEN
PRINT @(TEMP.CL,TEMP.LN):RVB:"|":RVE:("Task: ":TASK.NUM:" - ":TASK.STEP:" ":STRUCT(62)<1,PORT+1>) "L#48":RVB:"|":RVE:
READV TEMP.DESC FROM PS.FILE,"@J@":CO.DATA<3>:"@":TASK.NUM,1 ELSE
TEMP.DESC = ''
END
PRINT @(TEMP.CL,TEMP.LN+1):RVB:"|":RVE:TEMP.DESC "L#48":RVB:"|":RVE:
PRINT @(TEMP.CL,TEMP.LN+2):RVB:"|":STR("-",48):"|":RVE:
END
TEMP.CL = 0
TEMP.LN = 21
*#
~SYS.INCL.STEP.DISPLAY.ELP~
*CODE.SEGMENT: SYS.INCL.STEP.DISPLAY.ELP
*
SYS.SLOC<1> = "ELP.TIME"
PRINT @(0,5):RVB:"|":RVE:("The elasped time was ":OCONV(ELP.TIME,"MTS")) "L#48":RVB:"|":RVE:
PRINT @(0,6):RVB:"|":RVE:("The key used was ":PSD.KEY) "L#48":RVB:"|":RVE:
PRINT @(0,7):RVB:"|":STR("-",48):"|":RVE:
*
*
~SYS.INCL.SYS.RSP~
*CODE.SEGMENT: SYS.INCL.SYS.RSP
*
*
EQU SYS.RSP TO "*PKH*SCHED*SCHEDULE*MESSAGE*WAIT*FASTER*SLOWER*FAST*SLOW*HELP*"
*
*#.RSP.SYN TO "*PKH*SCHEDULE*SCHEDULE*MESSAGE*WAIT*WAIT*WAIT*WAIT*WA
*
*
* SYS.RSP = "*SCHEDULE*MESSAGE*WAIT*HELP*TIME*WHO*WHERE*STATUS*CONTACTS*TCL*OFF*"
* SYS.RSP = SYS.RSP:"EXPENSES*NOTES*PHONE.BOOK*SHOPPING*ACCOUNTS*USERS*PORTS*UTILITIES*"
~SYS.INCL.SYS.RSP.SYNONYM~
*CODE.SEGMENT: SYS.INCL.SYS.RSP.SYNONYM
*
*
****EQU SYS.RSP TO "*PKH*SCHED*SCHEDULE*MESSAGE*WAIT*FASTER*SLOWER*FAST*SLOW*HELP*"
*
EQU SYS.RSP.SYN TO "*PKH*SCHEDULE*SCHEDULE*MESSAGE*WAIT*WAIT*WAIT*WAIT*WAIT*HELP*"
*
*
~SYS.INCL.TC.INPUT~
*CODE.SEGMENT: SYS.INCL.TC.INPUT
*
*
TC = OCONV(TC,"U51EA")
*
TC = OCONV(TC,'U51EA')
*
~SYS.INCL.TCL.RSP~
*CODE.SEGMENT: SYS.INCL.TCL.RSP
*
*
EQU TCL.RSP TO "*EXIT*EXI*EX*COMMAND*EXIT.MENU*exit.menu*exit*command*"
*#("*":CHAR(6):"*":CHAR(24):"*":CHAR(27):"*":CHAR(251):"*")
*
~SYS.INCL.UNPACK.NUMBER~
*CODE.SEGMENT: SYS.INCL.UNPACK.NUMBER
*
* AUTHOR:            DAVID STERN - AXION
* UPDATED:           DAVID HORSMAN - MACROSCOPE
* DESCRIPTION:       UNPACK A NUMBER IN HEX
*
BEGIN CASE
CASE OPSYS EQ "R"
IF NUM.IN[ONE,ONE] = CHAR(13) THEN NUM.OUT = -OCONV(NUM.IN[TWO,99],"HEX") ELSE NUM.OUT = OCONV(NUM.IN,"HEX")
CASE OPSYS EQ "U"
NUM.OUT = OCONV(NUM.IN,"MX")
IF NUM.OUT[ONE,ONE] = "D" THEN NUM.OUT = -NUM.OUT[TWO,99] ELSE IF NUM.OUT[ONE,TWO] = "0D" THEN NUM.OUT = -NUM.OUT[3,99] ELSE NUM.OUT = NUM.OUT + ZERO
CASE OPSYS EQ "M"
NUM.OUT = OCONV(NUM.IN,"MX")
IF NUM.OUT[ONE,ONE] = "D" THEN NUM.OUT = -NUM.OUT[TWO,99] ELSE IF NUM.OUT[ONE,TWO] = "0D" THEN NUM.OUT = -NUM.OUT[3,99] ELSE NUM.OUT = NUM.OUT + ZERO
CASE TRUE; NUM.OUT = EMPTY
END CASE
*
~SYS.INCL.UPD.AUTO~
*CODE.SEGMENT: SYS.INCL.UPD.AUTO
*
IF NOT(STAT) AND NOT(AUTO.RUN) THEN
CALL AUTO.LOADER(EXEC.VERB,EXEC.IN,EXEC.DESC)
END
*
~SYS.INCL.UPD.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.UPD.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
WRITE DELAY.CN.MAX:AM:DELAY.RESET ON PAR.FILE,"STANDARD.DELAY.CURR"
*
*
~SYS.INCL.UPD.TERM~
*CODE.SEGMENT: SYS.INCL.UPD.TERM
*
*
TERMS = EMPTY
TAUXS = EMPTY
BEGIN CASE
CASE OPSYS EQ "M"
OPEN "DEVICES" TO DEVICE.FILE ELSE STOP
CASE TRUE
OPEN "PAR" TO DEVICE.FILE ELSE STOP
END CASE
*
CN.MAX = DCOUNT(DICT.TERMINAL.FL<ONE>,VM)
*
FOR CN = ONE TO CN.MAX
PORT.NUM = DICT.TERMINAL.FL<ONE,CN>
LOOP WHILE LEN(PORT.NUM) LT 3 DO PORT.NUM = "0":PORT.NUM REPEAT
* TERMINAL TYPE
TERMS<DICT.TERMINAL.FL<ONE,CN> + ONE> = DICT.TERMINAL.FL<TWO,CN>
* PORT LOCATION
BEGIN CASE
CASE OPSYS EQ "M"
READ DEVICE FROM DEVICE.FILE,"PORT*":PORT.NUM ELSE DEVICE = EMPTY
DEVICE<ONE> = DICT.TERMINAL.FL<11,CN>
WRITE DEVICE ON DEVICE.FILE,"PORT*":PORT.NUM
CASE TRUE
READ DEVICE FROM DEVICE.FILE,"MENU.":PORT.NUM ELSE DEVICE = EMPTY
DEVICE<ONE> = DICT.TERMINAL.FL<11,CN>
WRITE DEVICE ON DEVICE.FILE,"MENU.":PORT.NUM
END CASE
* AUX PORT ON / OFF FLAGS
TAUXS<DICT.TERMINAL.FL<ONE,CN> + ONE> = DICT.TERMINAL.FL<TWO,CN>
*
NEXT CN
*
WRITE TERMS ON DICT.TERMINAL.FL.FILE,"TERMINALS"
WRITE TAUXS ON DICT.TERMINAL.FL.FILE,"AUXILARYS"
*
~SYS.INCL.UPDT.ACC~
*CODE.SEGMENT: SYS.INCL.UPDT.ACC
*
* DAVID HORSMAN
*
ACC.REC<ACC.AM.DESC> = ACC.DESC
ACC.REC<ACC.AM.VERB> = ACC.VERB
ACC.REC<ACC.AM.DT>   = ACC.DT
ACC.REC<ACC.AM.TM>   = ACC.TM
WRITE ACC.REC ON ACC.FILE,ACC.ID
*
~SYS.INCL.USER.MODE.DESC~
*CODE.SEGMENT: SYS.INCL.USER.MODE.DESC
*
*$INCLUDE DH.IBP SYS.INCL.USER.MODE.DESC
*
MODE.DESC(1) = "Customer Introduction"
MODE.DESC(2) = "Customer Demonstration"
MODE.DESC(3) = "Trainee Demonstration"
MODE.DESC(4) = "Inexperienced Trainee"
MODE.DESC(5) = "Normal Trainee"
MODE.DESC(6) = "Advanced Trainee"
MODE.DESC(7) = "New Operator"
MODE.DESC(8) = "Normal Operator"
MODE.DESC(9) = "Advanced Operator"
MODE.DESC(10) = "Systems Operator"
MODE.DESC(11) = "Dev - Conceptualization"
MODE.DESC(12) = "Dev - Design"
MODE.DESC(13) = "Dev - Detailed Design"
MODE.DESC(14) = "Dev - Codeing"
MODE.DESC(15) = "Dev - Debugging"
MODE.DESC(16) = "Dev - Testing"
MODE.DESC(17) = "Dev - System Testing"
MODE.DESC(18) = "Release System"
MODE.DESC(19) = "Installation"
MODE.DESC(20) = "Service & Support"
MODE.DESC(21) = "?"
MODE.DESC(22) = "?"
MODE.DESC(23) = "?"
MODE.DESC(24) = "?"
MODE.DESC(25) = "?"
MODE.DESC(26) = "?"
MODE.DESC(27) = "?"
MODE.DESC(28) = "?"
MODE.DESC(29) = "?"
MODE.DESC(30) = "?"
~SYS.INCL.USER.SET~
*CODE.SEGMENT: ?
USER.ID = "USER@":ACCT:"@":PORT; APPL = "PICKTR"
~SYS.INCL.UTILS.RSP~
*CODE.SEGMENT: SYS.INCL.UTILS.RSP
*
*DGH 870625
*
EQU UTILS.RSP TO "*UT*PG*ED*M*"
*
EQU UTILS.RSP.SYN TO "*/UTILS*/PG*/SD@CD*/*"
*
*
~SYS.INPUT.DATE.CODE~
*PROGRAM: SYS.INPUT.DATE.CODE
*
* AUTHOR: DAVID HORSMAN
*
!
*
*$INCLUDE IBP SYS.INPUT.DATE.CODE
*
INPUT.DATE.CODE: * Date to remove from hold and reason code or comments
IF INDEX("*H*X*","*":F.T:"*",1) # 0 THEN
PRINT @(0,21):CLL:@(0,22):CLL:@(0,23):CLL:
ENT.DATE = "0"
IF F.T = "H" THEN
PRINT "Till what date? ":
ENT.DATE = ""
INPUT ENT.DATE:
ENT.DATE = ICONV(ENT.DATE,"D2")
IF LEN(ENT.DATE) = 0 THEN ENT.DATE = "0"
IF ENT.DATE # 0 THEN PRINT @(16):OCONV(ENT.DATE,"D2"):@(28): ELSE PRINT @(16):"on request":@(28):
END
PRINT "Comment: ":
INPUT ENT.CODE:
P.S<CN,DATE.CODE.VM> = ENT.DATE:"*":ENT.CODE:SVM:P.S<CN,DATE.CODE.VM>
END
RETURN
*
~SYS.STANDARD.FUNCTIONS~
*CODE.SEGMENT: SYS.STANDARD.FUNCTIONS
*
* Author: David G. Horsman
*
* Company: Macroscope Design Matrix
*
* (C) 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1992
*
*
EQU BELL TO CHAR(7); EQU LF TO CHAR(10); EQU FF TO CHAR(12)
EQU CR TO CHAR(13); EQU ESC TO CHAR(27)
EQU SVM TO CHAR(252); EQU VM TO CHAR(253); EQU AM TO CHAR(254)
EQU STXC TO CHAR(2); EQU EMPTY TO ""
EQU TRUE TO 1; EQU FALSE TO 0; EQU TWO TO 2; EQU ONE TO 1; EQU ZERO TO 0
*
RSP = EMPTY; RSPBUF = EMPTY
WHO = ICONV(0,"U50BB"); * ULT ONLY
* WHO = ICONV(0,"U50BB"); * MDD ONLY
* WHO = @USER0; * REV ONLY
PORT = (FIELD(WHO," ",ONE)+1000)[TWO,3]; ACCT = FIELD(WHO," ",TWO)
OPSYS = "U"; * ULT ONLY
* OPSYS = "R"; * REV ONLY
* OPSYS = "R"; * MDD ONLY
RUN.TYPE = "S"; PHANTOM.RUN = FALSE
GENERIC = FALSE; * ULT ONLY
* GENERIC = FIELD(@USER0," ",3); * REV ONLY
* GENERIC = FALSE; * MDD ONLY
TT = SYSTEM(7); * ULT ONLY
* TT = EMPTY; * REV ONLY
* TT = SYSTEM(7); * MDD ONLY
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
*
IF GENERIC THEN
CLB = @(ZERO,23); CLB0 = @(ZERO,21); CLB1 = @(ZERO,22); CLB2 = @(ZERO,23)
END ELSE
CLB = @(ZERO,23):CLL; CLB0 = @(ZERO,21):CLL; CLB1 = @(ZERO,22):CLL; CLB2 = @(ZERO,23):CLL
END
*
BEGIN CASE
CASE OPSYS EQ "R"
RVB = CHAR(27):"00"; RVE = CHAR(27):"0A"; RVH = CHAR(27):"01"
AUX.ON = EMPTY; AUX.OFF = EMPTY
CASE TT EQ "D"
RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE TT EQ "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":; * ULT ONLY
CASE TT EQ "U"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
CASE TT EQ "M"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
CASE 1
RVB = EMPTY; RVE = EMPTY; RVH = EMPTY; AUX.ON = EMPTY; AUX.OFF = EMPTY
END CASE
*
~SYS.TCL.PTASK~
*CODE.SEGMENT: SYS.TCL.PTASK
*
*
P.TASK: * Print TCL.
*
CPAGETEN = INT( ( L.W - 1) / SCR.LINES ) * SCR.LINES
P.V3 = P.V<1,3>
P.V2 = P.V<1,2>
P.V1 = P.V<1,1>
P.V4 = P.V<1,4>
P.V5 = P.V<1,5>
P.V6 = P.V<1,6>
P.V7 = P.V<1,7>
*
IF OUT.TO.PRINT THEN
PRINTER ON
END ELSE
IF TOP.DISPLAY.FLAG THEN
PRINT @(0,6):CLL:
PR.FL = 0
END ELSE
PRINT @(0,L.W-CPAGETEN+7):CLL:
END
END
*
*
*
*
IF NOT(OUT.TO.PRINT) THEN PRINT @(5):RVB: ELSE PRINT; VRF.EXTRA = VRF.EXTRA + 1
PRINT L.W "R#3":"| ":
*IF PR.FL & NOT(OUT.TO.PRINT) THEN
IF NOT(OUT.TO.PRINT) THEN
PRINT RVE:P.V2 "L#45":"  ":RVB:FIELD(P.V1,"*",1) "L#1":" ":FIELD(P.V3,"*",1) "L#5":" ":FIELD(P.V6,"*",1) "L#5":" ":FIELD(P.V7,"*",1) "L#5":" |":RVE:
END ELSE
PRINT P.V2 "L#45":"  ":FIELD(P.V1,"*",1) "L#1":" ":FIELD(P.V3,"*",1) "L#5":" ":FIELD(P.V6,"*",1) "L#5":" ":FIELD(P.V7,"*",1) "L#5":
END
IF OUT.TO.PRINT THEN
PRINTER OFF
END
RETURN
*
*
~SYS.TCL.UPD~
*CODE.SEGMENT: SYS.TCL.UPD
*
!
UPDATE.FILE: * subroutine to write TCL.STACK or PRESTORE
PRINT @(60,23):"Update.File" "L#18":
IF OLD.CALL.SUB.FUNCTION = "LOGGED" THEN
WRITE P.S ON SY.FILE,"@TCL@STACK@":CO.DATA<3>:"@":STRUCT(2)
END ELSE IF OLD.CALL.SUB.FUNCTION = "PRESTORE" THEN
TEMP.CN = 0
LOOP TEMP.CN = TEMP.CN + 1 WHILE P.S<TEMP.CN> # "" DO
PRESTORE.REC<TEMP.CN+20> = P.S<TEMP.CN>
REPEAT
WRITE PRESTORE.REC ON PS.FILE,"@TCL@":CO.DATA<3>:"@":DISP.PRESTORE
END
*@*UNLOCK
RETURN
!
RECORD.PORT: * to record which task this port is working on
PRINT @(60,23):"Record.Port" "L#18":
IF CALL.SUB.FUNCTION = "LOGGED" THEN
END
RETURN
!
CLEAR.PORT: * to clear this port of current task and step information.
PRINT @(60,23):"Clear.Port" "L#18":
IF CALL.SUB.FUNCTION = "LOGGED" THEN
END
RETURN
!
RECORD.TCL: * to record a change in task or step
PRINT @(60,23):"Record.Tcl" "L#18":
RETURN
!
WAIT.RTN: * Subroutine to modify WAIT.FLAG
PRINT @(60,23):"Wait.Rtn" "L#18":
IF WAIT.TEMP[1,4] = "WAIT" THEN
WAIT.TEMP = FIELD(WAIT.TEMP," ",2)
IF NUM(WAIT.TEMP) THEN
IF WAIT.TEMP < 6 THEN WAIT.FLAG = WAIT.TEMP
END ELSE
IF WAIT.FLAG THEN WAIT.FLAG = 0 ELSE WAIT.FLAG = 1
END
END
RETURN
*
*
~SYS.TEST.FL.LOAD~
*CODE.SEGMENT: SYS.TEST.FL.LOAD
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Testing Design)
*
*   DATE: 14 JAN 88
*
*OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
READ TEST.FL FROM CNT.FILE,"SYSTEM.TEST" THEN
*
END ELSE
*
* 1 Initialization Zones Trace Flag (MV)
* 2 Main Loop Zones
* 2]1 Main Loop Trace Flag
* 2]2 Level Two Trace Flag
* 2]2\1 Level Two, Sub-level One
* 22\2 Level Two, Sub-level Two
* 2]3 Level Three Trace Flag
* 3 List to Use
* 4 Date to Use
* 5 On/Off string
* 6 Termination Zones
*
* NOTE: Comment lines starting with *S> denote internal program structure.
*
TEST.FL = "0":AM:"0":AM:"":AM:DATE():AM:"":AM:"0"
END
*
~SYS.TEST.FL.OPEN~
*CODE.SEGMENT: SYS.TEST.FL.OPEN
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Testing Design)
*
*   DATE: 14 JAN 88
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
*
~SYS.USER.NAME~
*CODE.SEGMENT: SYS.USER.NAME
*
!
*
*
*
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = ""
SYS.ITEM = ""
*
*
SYS.SLOC = "ACC"
OPEN "ACC" TO AC.FILE ELSE
ERROR.TEXT = "no ACC file"
ERROR.CODE = 1
GOSUB ERROR.CONTROL
STOP
END
*
CALL.ID = "MENU.":PORT
READV USER.NAME FROM AC.FILE,CALL.ID,2 ELSE
USER.NAME = "?"
ERROR.TEXT = "I don't know your name"
ERROR.CODE = "19011"
GOSUB ERROR.CONTROL
STOP
END
*
*
*
!
*
~SYSS.DIM~
*CODE.SEGMENT: ?
DIM SYSS(10)
~SYSS.EQUATES~
*CODE.SEGMENT: SYSS.EQUATES
*
* FILE 'CNTR.REC' EQUATES - GENERATED 15:53:29  15 AUG 1984
EQU EI.IA.V.S TO CNTR.REC(1); * VALID STANDARD INFO. AREAS
EQU EI.IA.A TO CNTR.REC(2);     * ADDITIONAL VALID IA'S AND VALID ACTIONS
EQU EI.IA.V.A TO CNTR.REC(3);   * VALID ACTIONS ON STANDARD IA'S
EQU EI.IA.P.S TO CNTR.REC(4);       * INFO-AREA PREFIX/SUFFIX FLAG
EQU EI.U.P.S TO CNTR.REC(5);     * USER FILE/KEY PREFIX/SUFFIX FLAG
EQU EI.V.F TO CNTR.REC(6);      * DATA PROCESSING VERIFICATION ACTION FLAG
EQU EI.A.M TO CNTR.REC(7);      * ENTITY KEY INPUT METHOD FLAG
EQU EI.P.F TO CNTR.REC(8);       * The root of the information file.
EQU EI.S.F TO CNTR.REC(9);     * The name of the secondary info file.
EQU EI.P.C TO CNTR.REC(10);  * A series of commands and screen input.
*
~SYSTEM.TEST~
*CODE.SEGMENT: ?
SYSTEM.TEST: *
*
*
* 'SYS.TST' IN GENERAL.COMMON.AREA SHOULD BE LOADED WHERE APPLICABLE
*
* ATR   PURPOSE
*   1   TESTING ON/OFF
*   2   DISPLAY 'ENTERING' PROGRAM OR CALLED SUBROUTINE
*   3   DISPLAY 'ENTERING' A SUBROUTINE
*   4   1 - DISPLAY ITEM ID BEING PROCESSED
*       2 - DISPLAY ITEM AND MSG IF ERROR/REJECTED, ETC.
*   5   LIST.NAME TO BE PROCESSED
*   6   TEST.DATE TO BE USED (EXTERNAL FORMAT)
*   7   BREAK IS ON
*   8   TIMING DISPLAY IS ON
*   9   PROGRAM SPECIFIC
*  10   PROGRAM SPECIFIC
*  11   PROGRAM SPECIFIC
!
TEST.FL = 0; LIST.NAME = ""; DIS.SUB = 0; DIS.ITEM = 0; DIS.PROG = 0
TIMING = 0; BREAKON = 0; WKO.TEST = 0; PROG.TEST9 = 0; PROG.TEST10 = 0
PROG.TEST11 = 0
IF SYS.TST<1> THEN
TEST.FL =   1
DIS.PROG  = SYS.TST<2>
DIS.SUB   = SYS.TST<3>
DIS.ITEM  = SYS.TST<4>
LIST.NAME = SYS.TST<5>
TIMING    = SYS.TST<6>
BREAKON  = SYS.TST<7>
WKO.TEST  = SYS.TST<8>
PROG.TEST9 = SYS.TST<9>
PROG.TEST10 = SYS.TST<10>
PROG.TEST11 = SYS.TST<11>
END ELSE SYS.TST = ""
!
~TAX.DIM~
DIM TAX(10)
~TAX.EQUATES~
*CODE.SEGMENT: TAX.EQUATES
*
* FILE 'TAX' EQUATES - GENERATED 13:36:21  31 MAR 1993
EQU TAX$DESC TO TAX(1);                 * DESCRIPTION OF TAX
EQU TAX$PRORATE.FLAG TO TAX(2);         * WHETHER TAX IS PRORATED OVER BILLING
EQU TAX$EFF.DATES TO TAX(3);            * EFFECTIVE DATE FOR TAX RATE
EQU TAX$TAX.RATES TO TAX(4);            * PERCENTAGE RATE OF TAX
EQU TAX$RENTAL.AMT.FLAG TO TAX(5);      * WHETHER TAX APPLICABLE ON RENTALS
EQU TAX$SALES.AMT.FLAG TO TAX(6);       * WHETHER TAX APPLICABLE ON SALES
EQU TAX$OTHER.AMT.FLAG TO TAX(7);       * WHETHER TAX APPLICABLE ON OTHER CHARGES
EQU TAX$EXEMPT.RATE.TYPES TO TAX(8);    * LIST OF EXEMPT RATE TYPES (SEP BY ,'S)
EQU TAX$ACCTG.METHOD TO TAX(9);         * A - ACCRUAL, C - CASH
~TAX.VAR.EQUATES~
*CODE.SEGMENT: TAX.VAR.EQUATES
*
* FILE 'TAX' EQUATES - GENERATED 13:36:21  31 MAR 1993
EQU TAX$DESC TO 1;                      * DESCRIPTION OF TAX
EQU TAX$PRORATE.FLAG TO 2;              * WHETHER TAX IS PRORATED OVER BILLING
EQU TAX$EFF.DATES TO 3;                 * EFFECTIVE DATE FOR TAX RATE
EQU TAX$TAX.RATES TO 4;                 * PERCENTAGE RATE OF TAX
EQU TAX$RENTAL.AMT.FLAG TO 5;           * WHETHER TAX APPLICABLE ON RENTALS
EQU TAX$SALES.AMT.FLAG TO 6;            * WHETHER TAX APPLICABLE ON SALES
EQU TAX$OTHER.AMT.FLAG TO 7;            * WHETHER TAX APPLICABLE ON OTHER CHARGES
EQU TAX$EXEMPT.RATE.TYPES TO 8;         * LIST OF EXEMPT RATE TYPES (SEP BY ,'S)
EQU TAX$ACCTG.METHOD TO 9;              * A - ACCRUAL, C - CASH
~TEMP~
*CODE.SEGMENT: ?
~TEMP.ADD.EQUATES~
*FILE 'SAVE.ADD' EQUATES - GENERATED 12:08:58  22 APR 1985
EQU SAVE.ADD$MULT.APT.NUMS TO SAVE.ADD(1);        * STRING OF APT. NOS. AT THIS ADDRESS
EQU SAVE.ADD$ACT.IDS TO SAVE.ADD(2);              * CUSTOMER ACCOUNT NO.
EQU SAVE.ADD$ACT.FROM.DATES TO SAVE.ADD(3);       * ACCOUNT CONNECT DATE
EQU SAVE.ADD$ACT.TO.DATES TO SAVE.ADD(4);         * ACCOUNT DISCONNECT DATE
EQU SAVE.ADD$STAT TO SAVE.ADD(5);                 * ADDRESS SERVICE STATUS
EQU SAVE.ADD$POST.CODE TO SAVE.ADD(6);            * POSTAL/ZIP CODE OF ADDRESS
EQU SAVE.ADD$DWELLING.TYPE TO SAVE.ADD(7);        * TYPE OF DWELLING
EQU SAVE.ADD$DROP.TYPE TO SAVE.ADD(8);            * TYPE OF DROP
EQU SAVE.ADD$HOT.OUTLETS TO SAVE.ADD(9);          * NUMBER OF HOT OUTLETS AT ADDRESS
EQU SAVE.ADD$WIRED.OUTLETS TO SAVE.ADD(10);       * NUMBER OF OUTLETS WIRED AT ADDRESS
EQU SAVE.ADD$TECH.INFO TO SAVE.ADD(11);           * TECHNICAL INFORMATION FOR ADDRESS
EQU SAVE.ADD$GEOGRAPHIC.DATA TO SAVE.ADD(12);     * GEOGRAPHIC DATA
EQU SAVE.ADD$BULK.ACT.ID TO SAVE.ADD(13);         * POINTER TO BULK ACCOUNT
EQU SAVE.ADD$CONF.WO.NUMS TO SAVE.ADD(14);        * CONFIRMED WORK ORDER NO.
EQU SAVE.ADD$WKO.TYPE TO SAVE.ADD(15);            * TYPE OF WORK ORDER
EQU SAVE.ADD$WKO.ACT.ID TO SAVE.ADD(16);          * ACCOUNT TO WHICH WORK ORDER APPLIED
EQU SAVE.ADD$WKO.EFF.DATE TO SAVE.ADD(17);        * EFFECTIVE DATE OF WORK ORDER
EQU SAVE.ADD$WKO.COMPL.DATE TO SAVE.ADD(18);      * COMPLETION DATE OF WORK ORDER
EQU SAVE.ADD$OUTLET.LOCATIONS TO SAVE.ADD(19);    * LOCATION OF OUTLET WITHIN ADDRESS
EQU SAVE.ADD$MESSAGE TO SAVE.ADD(20);             * ADDRESS MESSAGE
EQU SAVE.ADD$DROP TO SAVE.ADD(21);                * DROP NUMBER
EQU SAVE.ADD$MASTER TO SAVE.ADD(22);               * MASTER DROP (FCI)
~TEMP10~
*CODE.SEGMENT: ?
SYS.INCL.CONV.TO.HEX
SYS.INCL.CONV.TO.TXT
SYS.INCL.ACK.OR.SEND
SYS.INCL.PICKTR.HEADER
SYS.INCL.PICKTR.DETAIL
SYS.INCL.PICKTR.COMMANDS
SYS.INCL.PICKTR.EQU
SYS.INCL.PICKTR.JOB.LOAD
SYS.INCL.SCHED.CHECK
SYS.INCL.SCHED.CHECK.READ
SYS.INCL.ABORT.CHECK
SYS.INCL.ABORT.CHECK.READ
SYS.INCL.QUIET.WRITE
SYS.INCL.QUIET.LOAD
SYS.INCL.COMM.WAIT.QUIET
STANDARD.FUNCTIONS.CHARACTERS
STANDARD.CHARACTERS
SYS.INCL.FSEARCH.TOP
SYS.INCL.FSEARCH.BOT
SYS.INCL.LOG.ENTRY
SYS.INCL.USER.SET
TEMP9
TEMP10
~TEMP9~
*CODE.SEGMENT: ?
SYS.SUBR.SYSTEM.NAME
SYS.SUBR.SYSTEM.TYPE
SYS.SUBR.FILE.STAT
SYS.COMM.WAIT.QUIET.SUB
SYS.LOG.ENTRY.SUB
PICKTR.HEADER.SUB
PICKTR.DETAIL.SUB
PICK.TRANSFER.SUB
PICK.TRANSFER
~TPL.DIM~
*CODE.SEGMENT: ?
DIM TPL(10)
~TPL.EQUATES~
*CODE.SEGMENT: ?
* FILE 'TPL' EQUATES - GENERATED 13:16:16  22 APR 1985
EQU TPL$ADD.ID TO TPL(1);               * POINTER TO ADDRESS.ID IN FILE 'ADD'
EQU TPL$STAT TO TPL(2);                 * STATUS (Taplock, Removed)
EQU TPL$DISC.DATE TO TPL(3);            * Disconnect date
EQU TPL$DISC.WO TO TPL(4);              * Disconnect work order number
EQU TPL$REM.DATE TO TPL(5);             * Taplock removal date
EQU TPL$REM.WO TO TPL(6);               * Taplock removal work order number
~TST.EQUATES~
*CODE.SEGMENT: TST.EQUATES
*
*
* FILE: CNT     ITEM: SYSTEM.TEST
*
EQU TST$SYS            TO 1
EQU TST$RTN            TO 2
EQU TST$LBL            TO 3
EQU TST$FILE           TO 4
EQU TST$LIST.NAME      TO 5
EQU TST$TEST.DATE      TO 6
EQU TST$BREAK          TO 7
EQU TST$TIMING         TO 8
EQU TST$TA             TO 9
*
EQU TST$SPEC.APPL      TO 10
EQU TST$SPEC.VAL       TO 11
*
EQU TST$WO             TO 12
EQU TST$BILL           TO 13
EQU TST$SYST           TO 14
EQU TST$RELS           TO 15
*
EQU TST$PAUSE          TO 16
EQU TST$APPL           TO 17
~TST.INCL.LOAD~
*CODE.SEGMENT: TST.INCL.LOAD
* VERSION: 940119 2.0  ADDED CNT.TST(17) FOR SH.MAINT.TST.SUB.
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   1990         ALL RIGHTS RESERVED
*
* AUTHOR: David Horsman
*
IF TYPE.RUN EQ "5" THEN
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
TYPE.RUN = "6"
CNT.TST.ID.SAVE = CNT.TST.ID
END ELSE NULL
*
END ELSE IF TYPE.RUN NE "9" THEN
CNT.TST.ID = "SYS.TST.":PORT
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST.":PORT
END ELSE
CNT.TST.ID = "SYS.TST"
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST"
END ELSE
CNT.TST.ID = "SYS.TST.":SYS.APPL.SUB
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST.":SYS.APPL.SUB
END ELSE
CNT.TST.ID = "SYS.TST.":ACCT
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST.":ACCT
END ELSE
CNT.TST.ID = "SYS.TST.":PORT
CNT.TST.ID.SAVE = "SYS.TST.":PORT
MAT CNT.TST = EMPTY
END
END
END
END
END
*
IF AUTO.RUN THEN DISP.ONLY = TRUE
*
IF NOT(AUTO.RUN) AND CNT.TST$MAINT THEN
* CALL SH.MAINT.TST.SUB(CNT.FILE,CNT.TST.ID,MAT CNT.TST,PAR.FILE,LCK.FILE,CNT.ID.SAVE,GENERIC,CO.DATA,"1",STAT)
* CALL SH.SUBR.MAINT.TST(CNT.TST.FILE,CNT.TST.ID,MAT CNT.TST,LCK.FILE,MAT TDL,CNT.TST.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*960509*DGH*CALL SH.SUBR.MAINT.TST(TDL.REC,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,CNT.FILE,LCK.FILE)
*
CALL SH.SUBR.MAINT.TST(TDL.REC,CNT.TST.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,CNT.TST.FILE,LCK.FILE)
*
END
*
*
***CNT.TST$BREAK = TRUE
***CNT.TST$TA    = TRUE
***CNT.TST$RTN   = FALSE
***CNT.TST$ID    = FALSE
***CNT.TST$LBL   = FALSE
***CNT.TST$FILE  = FALSE
***CNT.TST$CR    = FALSE
***CNT.TST$LIST.NAME = EMPTY
***CNT.TST$X = FALSE
***CNT.TST$Y = FALSE
***CNT.TST$Z = FALSE
***CNT.TST$MAINT = FALSE
*
!
*
IF CNT.TST$ON THEN
*
LOCATE SYS.APPL.SUB IN CNT.TST$APPL<ONE> SETTING SYS.APPL.LOC THEN
*
*
***TC.CN = ZERO
***LOOP
***TC.CN = TC.CN + ONE
***TC = CNT.TST$PARAMS<ONE,SYS.APPL.LOC>[TC.CN,ONE]
TMP = CNT.TST$PARAMS<ONE,SYS.APPL.LOC>
***WHILE TC NE EMPTY DO
***BEGIN CASE
IF NOT(INDEX(TMP,"B",ONE)) THEN CNT.TST$BREAK = FALSE
*
IF NOT(INDEX(TMP,"T",ONE)) THEN CNT.TST$TA    = FALSE
*
IF NOT(INDEX(TMP,"R",ONE)) THEN CNT.TST$RTN   = FALSE
*
IF NOT(INDEX(TMP,"K",ONE)) THEN CNT.TST$ID    = FALSE
*
IF NOT(INDEX(TMP,"L",ONE)) THEN CNT.TST$LBL   = FALSE
*
IF NOT(INDEX(TMP,"F",ONE)) THEN CNT.TST$FILE  = FALSE
*
IF NOT(INDEX(TMP,"C",ONE)) THEN CNT.TST$CR    = FALSE
*
IF INDEX(TMP,"G",ONE) THEN CNT.TST$LIST.NAME = CNT.TST$LISTS<ONE,SYS.APPL.LOC>
*
IF NOT(INDEX(TMP,"X",ONE)) THEN CNT.TST$X = FALSE
*
IF NOT(INDEX(TMP,"Y",ONE)) THEN CNT.TST$Y = FALSE
*
IF NOT(INDEX(TMP,"Z",ONE)) THEN CNT.TST$Z = FALSE
*
IF NOT(INDEX(TMP,"M",ONE)) THEN CNT.TST$MAINT = FALSE
*
***END CASE
***REPEAT
END
*
!
*
IF CNT.TST$BREAK EQ EMPTY THEN CNT.TST$BREAK = TRUE
IF NOT(CNT.TST$BREAK) THEN 
BREAK OFF
END
*
IF CNT.TST$TA EQ EMPTY THEN CNT.TST$TA = TRUE
IF NOT(CNT.TST$TA) THEN 
* TYPEAHEAD OFF
END
*
END
IF AUTO.RUN THEN CNT.TST$CR = FALSE
*
IF CNT.TST$LBL THEN
PRINT CLB:"Exiting system test ":
IF CNT.TST$CR THEN PRINT BELL:" <cr>":; INPUT TMP:
END
*
*2APR94* RETURN
*
~TST.VAR.EQUATES~
*CODE.SEGMENT: TST.EQUATES
*
*
* FILE: CNT     ITEM: SYSTEM.TEST
*
EQU TST$SYS            TO 1
EQU TST$RTN            TO 2
EQU TST$LBL            TO 3
EQU TST$FILE           TO 4
EQU TST$LIST.NAME      TO 5
EQU TST$TEST.DATE      TO 6
EQU TST$BREAK          TO 7
EQU TST$TIMING         TO 8
EQU TST$TA             TO 9
*
EQU TST$SPEC.APPL      TO 10
EQU TST$SPEC.VAL       TO 11
*
EQU TST$WO             TO 12
EQU TST$BILL           TO 13
EQU TST$SYST           TO 14
EQU TST$RELS           TO 15
*
EQU TST$PAUSE          TO 16
EQU TST$APPL           TO 17
~ULT.STANDARD.FUNCTIONS~
*CODE.SEGMENT: ?
!
STANDARD.FUNCTIONS: *
EQUATE BELL TO CHAR(7)
EQUATE LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13)
EQUATE TRUE TO 1,T TO 1,FALSE TO 0,F TO 0
EQUATE SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+1000)[2,3]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~UPR.DIM~
*CODE.SEGMENT: ?
DIM UPR(30)
~UPR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'UPR' EQUATES - GENERATED 12:27:47  14 SEP 1984
EQU UPR$STATE.PROV TO UPR(1);           * ST/PRV
EQU UPR$COMPANY TO UPR(2);              * CABLE COMPANY NAME
EQU UPR$ADDRESS TO UPR(3);              * MAILING ADDRESS
EQU UPR$PCODE TO UPR(4);                * PZ.CODE
EQU UPR$COUNTRY TO UPR(5);              * CTY
EQU UPR$CONTACT TO UPR(6);              * CABLE COMPANY CONTACTS
EQU UPR$TITLE TO UPR(7);                * CONTACT TITLES
EQU UPR$SUBS TO UPR(8);                 * SUBS
EQU UPR$HOMES.PASSED TO UPR(9);         * PASSED
EQU UPR$HOMES.IN TO UPR(10);            * HOM.IN
EQU UPR$POP TO UPR(11);                 * POP
EQU UPR$PAY.SUBS TO UPR(12);            * PAYS
EQU UPR$OWNERSHIP TO UPR(13);           * O.C
EQU UPR$MSO TO UPR(14);                 * MSO.ID
EQU UPR$COMPETITOR TO UPR(15);          * CC
EQU UPR$TYPE TO UPR(16);                * CT
EQU UPR$SYSTEM.STATUS TO UPR(17);       * S.STAT
EQU UPR$START.DATE TO UPR(21);          * START.DATE
EQU UPR$COMMENTS TO UPR(22);            * COMMENTS
EQU UPR$PHONE TO UPR(23);               * PHONE NO.
EQU UPR$CONTACT.FLAG TO UPR(24);        * CONTACT FLAG
EQU UPR$COMP.CONTACT.FLAG TO UPR(25);   * COMP. CONTACT FLAG
EQU UPR$INTEREST.RATE TO UPR(26);       * ANNUAL INTEREST RATE FOR COST OF CREDIT
~WKH.DIM~
*CODE.SEGMENT: ?
DIM WKH(50)
~WKH.EQUATES~
*CODE.SEGMENT: ?
* FILE 'WKH' EQUATES - GENERATED 14:47:51  27 SEP 1984
EQU WKH$ACT.ID TO WKH(1);               * TENANT ACCOUNT NO.
EQU WKH$ADD.ID TO WKH(2);               * ADDRESS ID
EQU WKH$TFR.FROM.ADD.ID TO WKH(3);      * TFR. FROM ADDRESS ID
EQU WKH$TYPE TO WKH(4);                 * WORK ORDER TYPE
EQU WKH$STAT TO WKH(5);                 * WORK ORDER STATUS
EQU WKH$SCH.DATE TO WKH(6);             * SCHEDULED DATE
EQU WKH$SCH.TIME TO WKH(7);             * SCHEDULED TIME
EQU WKH$SCH.POINTS TO WKH(8);           * SCHEDULE POINTS
EQU WKH$SCH.TYPE TO WKH(9);             * SCHEDULE TYPE
EQU WKH$SCH.OVERBOOK TO WKH(10);        * SCHEDULE OVERBOOKED FLAG
EQU WKH$COMPL.DATE TO WKH(11);          * COMPLETION DATE
EQU WKH$OPERATOR TO WKH(12);            * OPERATOR ENTERING WORK ORDER
EQU WKH$INSTALLER TO WKH(13);           * INSTALLER COMPLETING WORK ORDER
EQU WKH$SALESMAN TO WKH(14);            * SALESMAN WHO SOLD W/O SERVICES
EQU WKH$DVC.COLLECT.INFO TO WKH(15);    * DEVICE COLLECTION INFORMATION
EQU WKH$DVC.PRINT.DATE TO WKH(16);      * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU WKH$DVC.REPRINT.DATE TO WKH(17);    * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU WKH$PRINT.DATE TO WKH(18);          * DATE WORK ORDER WAS FIRST PRINTED
EQU WKH$REPRINT.DATE TO WKH(19);        * DATE WORK ORDER WAS LAST REPRINTED
EQU WKH$ENTRY.DATE TO WKH(21);          * DATE WORK ORDER WAS ENTERED
EQU WKH$EFF.DATE TO WKH(22);            * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU WKH$DEPOSIT.AMT TO WKH(23);         * AMOUNT OF DEPOSIT ADJUSTMENT
EQU WKH$TOTAL.AMT TO WKH(24);           * TOTAL AMOUNT BILLED ON WORK ORDER
EQU WKH$ACTIVS TO WKH(25);              * WORK ORDER ACTIVITY
EQU WKH$ACTIV.QNTYS TO WKH(26);         * QUANTITY FOR THIS ACTIVITY
EQU WKH$ACTIV.AMTS TO WKH(27);          * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU WKH$ACTIV.SERVICES TO WKH(28);      * SERVICE PROVIDED FROM THIS ACTIVITY
EQU WKH$SVC.FREQS TO WKH(29);           * BILL FREQUENCY OF SERVICE
EQU WKH$SVC.LOCATIONS TO WKH(30);       * LOCATION OF OUTLET
EQU WKH$DVC.IDS TO WKH(31);             * DEVICE NO.
EQU WKH$DVC.ACTIV.STATS TO WKH(32);     * STATUS OF DEVICE ACTIVITY
EQU WKH$MAINT.CODES TO WKH(33);         * Service Order Maintenance codes
EQU WKH$MAINT.DESCS TO WKH(34);         * Service Order Maintenance descriptions
EQU WKH$BILL.SERVICES TO WKH(35);       * TYPE OF SERVICE BILLED
EQU WKH$BILL.QNTYS TO WKH(36);          * QUANTITY OF SERVICE BILLED
EQU WKH$BILL.FROM.DATES TO WKH(37);     * DATE FROM WHICH SERVICE IS BILLED
EQU WKH$BILL.TO.DATES TO WKH(38);       * DATE TO WHICH SERVICE IS BILLED
EQU WKH$BILL.RENT.AMTS TO WKH(39);      * RENTAL AMOUNT
EQU WKH$BILL.OTHER.AMTS TO WKH(40);     * NON-RENTAL AMOUNT
EQU WKH$BILL.FREQS TO WKH(41);          * BILL FREQUENCY FOR RATE CALC.
EQU WKH$BILL.DVC.NUMS TO WKH(42);       * DEVICE NO. FOR BILLING OF SERVICE
EQU WKH$BILL.SVC.LOCATIONS TO WKH(43);  * LOCATION OF BILLED SERVICE
EQU WKH$RATE.EFF.DATES TO WKH(44);      * EFF. DATE FOR RATE USED
EQU WKH$RATE.QNTYS TO WKH(45);          * NO. OF OUTLETS AT RATE
EQU WKH$MTHLY.RATES TO WKH(46);         * RATE PER OUTLET PER MONTH
EQU WKH$TAX.NAMES TO WKH(47);           * NAME OF TAX
EQU WKH$TAX.AMTS TO WKH(48);            * AMOUNT OF TAX
EQU WKH$BULK.ADD.IDS TO WKH(49);        * BULK ADDRESS POINTER
EQU WKH$MESSAGE TO WKH(50);             * WORK ORDER MESSAGE
~WKO.DIM~
*CODE.SEGMENT: ?
DIM WKO(60)
~WKO.EQUATES~
*CODE.SEGMENT: WKO.EQUATES
*
* FILE 'WKO' EQUATES - GENERATED 16:14:40  30 DEC 1991
EQU WKO$ACT.ID TO WKO(1);               * TENANT ACCOUNT NO.
EQU WKO$ADD.ID TO WKO(2);               * ADDRESS ID
EQU WKO$TFR.FROM.ADD.ID TO WKO(3);      * TFR. FROM ADDRESS ID
EQU WKO$TYPE TO WKO(4);                 * WORK ORDER TYPE
EQU WKO$STAT TO WKO(5);                 * WORK ORDER STATUS
EQU WKO$SCH.DATE TO WKO(6);             * SCHEDULED DATE
EQU WKO$SCH.TIME TO WKO(7);             * SCHEDULED TIME
EQU WKO$SCH.POINTS TO WKO(8);           * SCHEDULE POINTS
EQU WKO$SCH.TYPE TO WKO(9);             * SCHEDULE TYPE
EQU WKO$SCH.OVERBOOK TO WKO(10);        * SCHEDULE OVERBOOKED FLAG
EQU WKO$COMPL.DATE TO WKO(11);          * COMPLETION DATE
EQU WKO$OPERATOR TO WKO(12);            * OPERATOR ENTERING WORK ORDER
EQU WKO$INSTALLER TO WKO(13);           * INSTALLER COMPLETING WORK ORDER
EQU WKO$SALESMAN TO WKO(14);            * SALESMAN WHO SOLD W/O SERVICES
EQU WKO$DVC.COLLECT.INFO TO WKO(15);    * DEVICE COLLECTION INFORMATION
EQU WKO$DVC.PRINT.DATE TO WKO(16);      * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU WKO$DVC.REPRINT.DATE TO WKO(17);    * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU WKO$PRINT.DATE TO WKO(18);          * DATE WORK ORDER WAS FIRST PRINTED
EQU WKO$REPRINT.DATE TO WKO(19);        * DATE WORK ORDER WAS LAST REPRINTED
EQU WKO$DEPOSIT.TAX TO WKO(20);         * TAX ON THE DEPOSIT AMOUNT
EQU WKO$ENTRY.DATE TO WKO(21);          * DATE WORK ORDER WAS ENTERED
EQU WKO$EFF.DATE TO WKO(22);            * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU WKO$DEPOSIT.AMT TO WKO(23);         * AMOUNT OF DEPOSIT ADJUSTMENT
EQU WKO$TOTAL.AMT TO WKO(24);           * TOTAL AMOUNT BILLED ON WORK ORDER
EQU WKO$ACTIVS TO WKO(25);              * WORK ORDER ACTIVITY
EQU WKO$ACTIV.QNTYS TO WKO(26);         * QUANTITY FOR THIS ACTIVITY
EQU WKO$ACTIV.AMTS TO WKO(27);          * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU WKO$ACTIV.SERVICES TO WKO(28);      * SERVICE PROVIDED FROM THIS ACTIVITY
EQU WKO$SVC.FREQS TO WKO(29);           * BILL FREQUENCY OF SERVICE
EQU WKO$SVC.LOCATIONS TO WKO(30);       * LOCATION OF OUTLET
EQU WKO$DVC.IDS TO WKO(31);             * DEVICE NO.
EQU WKO$DVC.ACTIV.STATS TO WKO(32);     * STATUS OF DEVICE ACTIVITY
EQU WKO$MAINT.CODES TO WKO(33);         * Service Order Maintenance codes
EQU WKO$OUTCOME.CODES TO WKO(34);       * Service Order Outcome Codes
EQU WKO$BILL.SERVICES TO WKO(35);       * TYPE OF SERVICE BILLED
EQU WKO$BILL.QNTYS TO WKO(36);          * QUANTITY OF SERVICE BILLED
EQU WKO$BILL.FROM.DATES TO WKO(37);     * DATE FROM WHICH SERVICE IS BILLED
EQU WKO$BILL.TO.DATES TO WKO(38);       * DATE TO WHICH SERVICE IS BILLED
EQU WKO$BILL.RENT.AMTS TO WKO(39);      * RENTAL AMOUNT
EQU WKO$BILL.OTHER.AMTS TO WKO(40);     * NON-RENTAL AMOUNT
EQU WKO$BILL.FREQS TO WKO(41);          * BILL FREQUENCY FOR RATE CALC.
EQU WKO$BILL.DVC.NUMS TO WKO(42);       * DEVICE NO. FOR BILLING OF SERVICE
EQU WKO$BILL.SVC.LOCATIONS TO WKO(43);  * LOCATION OF BILLED SERVICE
EQU WKO$RATE.EFF.DATES TO WKO(44);      * EFF. DATE FOR RATE USED
EQU WKO$RATE.QNTYS TO WKO(45);          * NO. OF OUTLETS AT RATE
EQU WKO$MTHLY.RATES TO WKO(46);         * RATE PER OUTLET PER MONTH
EQU WKO$TAX.NAMES TO WKO(47);           * NAME OF TAX
EQU WKO$TAX.AMTS TO WKO(48);            * AMOUNT OF TAX
EQU WKO$PRINT.SOURCE TO WKO(49);        * Printed by System or out of GENIE
EQU WKO$MESSAGE TO WKO(50);             * WORK ORDER MESSAGE
EQU WKO$DISC.REASON TO WKO(51);         * Reason the subscriber was disconnected
EQU WKO$SCH.REQUEST TO WKO(52);         * Scheduled date is at sub's request.
EQU WKO$TROUBLE.CLASS TO WKO(53);       * Trouble classification code
EQU WKO$TRUCK.ROLL TO WKO(54);          * WAS A TRUCK ROLLED FOR THE WKO?
EQU WKO$CONF.DATE.TM TO WKO(55);        * The WKO confirmation date and time.
EQU WKO$REQUEST.DATE TO WKO(56);        * Date install was requested for.
EQU WKO$TAKEN.DATE TO WKO(57);          * Date the order was taken.
EQU WKO$TAKEN.TM TO WKO(58);            * The time the order was taken.
EQU WKO$ENTRY.TM TO WKO(59);            * The time of day the order was entered.
EQU WKO$COMPL.TM TO WKO(60);            * The time of day the order was completed.
~WKO.VAR.EQUATES~
*CODE.SEGMENT: WKO.VAR.EQUATES
*
* FILE 'WKO' EQUATES - GENERATED 16:14:41  30 DEC 1991
EQU WKO$ACT.ID TO 1;                    * TENANT ACCOUNT NO.
EQU WKO$ADD.ID TO 2;                    * ADDRESS ID
EQU WKO$TFR.FROM.ADD.ID TO 3;           * TFR. FROM ADDRESS ID
EQU WKO$TYPE TO 4;                      * WORK ORDER TYPE
EQU WKO$STAT TO 5;                      * WORK ORDER STATUS
EQU WKO$SCH.DATE TO 6;                  * SCHEDULED DATE
EQU WKO$SCH.TIME TO 7;                  * SCHEDULED TIME
EQU WKO$SCH.POINTS TO 8;                * SCHEDULE POINTS
EQU WKO$SCH.TYPE TO 9;                  * SCHEDULE TYPE
EQU WKO$SCH.OVERBOOK TO 10;             * SCHEDULE OVERBOOKED FLAG
EQU WKO$COMPL.DATE TO 11;               * COMPLETION DATE
EQU WKO$OPERATOR TO 12;                 * OPERATOR ENTERING WORK ORDER
EQU WKO$INSTALLER TO 13;                * INSTALLER COMPLETING WORK ORDER
EQU WKO$SALESMAN TO 14;                 * SALESMAN WHO SOLD W/O SERVICES
EQU WKO$DVC.COLLECT.INFO TO 15;         * DEVICE COLLECTION INFORMATION
EQU WKO$DVC.PRINT.DATE TO 16;           * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU WKO$DVC.REPRINT.DATE TO 17;         * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU WKO$PRINT.DATE TO 18;               * DATE WORK ORDER WAS FIRST PRINTED
EQU WKO$REPRINT.DATE TO 19;             * DATE WORK ORDER WAS LAST REPRINTED
EQU WKO$DEPOSIT.TAX TO 20;              * TAX ON THE DEPOSIT AMOUNT
EQU WKO$ENTRY.DATE TO 21;               * DATE WORK ORDER WAS ENTERED
EQU WKO$EFF.DATE TO 22;                 * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU WKO$DEPOSIT.AMT TO 23;              * AMOUNT OF DEPOSIT ADJUSTMENT
EQU WKO$TOTAL.AMT TO 24;                * TOTAL AMOUNT BILLED ON WORK ORDER
EQU WKO$ACTIVS TO 25;                   * WORK ORDER ACTIVITY
EQU WKO$ACTIV.QNTYS TO 26;              * QUANTITY FOR THIS ACTIVITY
EQU WKO$ACTIV.AMTS TO 27;               * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU WKO$ACTIV.SERVICES TO 28;           * SERVICE PROVIDED FROM THIS ACTIVITY
EQU WKO$SVC.FREQS TO 29;                * BILL FREQUENCY OF SERVICE
EQU WKO$SVC.LOCATIONS TO 30;            * LOCATION OF OUTLET
EQU WKO$DVC.IDS TO 31;                  * DEVICE NO.
EQU WKO$DVC.ACTIV.STATS TO 32;          * STATUS OF DEVICE ACTIVITY
EQU WKO$MAINT.CODES TO 33;              * Service Order Maintenance codes
EQU WKO$OUTCOME.CODES TO 34;            * Service Order Outcome Codes
EQU WKO$BILL.SERVICES TO 35;            * TYPE OF SERVICE BILLED
EQU WKO$BILL.QNTYS TO 36;               * QUANTITY OF SERVICE BILLED
EQU WKO$BILL.FROM.DATES TO 37;          * DATE FROM WHICH SERVICE IS BILLED
EQU WKO$BILL.TO.DATES TO 38;            * DATE TO WHICH SERVICE IS BILLED
EQU WKO$BILL.RENT.AMTS TO 39;           * RENTAL AMOUNT
EQU WKO$BILL.OTHER.AMTS TO 40;          * NON-RENTAL AMOUNT
EQU WKO$BILL.FREQS TO 41;               * BILL FREQUENCY FOR RATE CALC.
EQU WKO$BILL.DVC.NUMS TO 42;            * DEVICE NO. FOR BILLING OF SERVICE
EQU WKO$BILL.SVC.LOCATIONS TO 43;       * LOCATION OF BILLED SERVICE
EQU WKO$RATE.EFF.DATES TO 44;           * EFF. DATE FOR RATE USED
EQU WKO$RATE.QNTYS TO 45;               * NO. OF OUTLETS AT RATE
EQU WKO$MTHLY.RATES TO 46;              * RATE PER OUTLET PER MONTH
EQU WKO$TAX.NAMES TO 47;                * NAME OF TAX
EQU WKO$TAX.AMTS TO 48;                 * AMOUNT OF TAX
EQU WKO$PRINT.SOURCE TO 49;             * Printed by System or out of GENIE
EQU WKO$MESSAGE TO 50;                  * WORK ORDER MESSAGE
EQU WKO$DISC.REASON TO 51;              * Reason the subscriber was disconnected
EQU WKO$SCH.REQUEST TO 52;              * Scheduled date is at sub's request.
EQU WKO$TROUBLE.CLASS TO 53;            * Trouble classification code
EQU WKO$TRUCK.ROLL TO 54;               * WAS A TRUCK ROLLED FOR THE WKO?
EQU WKO$CONF.DATE.TM TO 55;             * The WKO confirmation date and time.
EQU WKO$REQUEST.DATE TO 56;             * Date install was requested for.
EQU WKO$TAKEN.DATE TO 57;               * Date the order was taken.
EQU WKO$TAKEN.TM TO 58;                 * The time the order was taken.
EQU WKO$ENTRY.TM TO 59;                 * The time of day the order was entered.
EQU WKO$COMPL.TM TO 60;                 * The time of day the order was completed.
~WKP.DIM~
*CODE.SEGMENT: ?
DIM WKP(10)
~WKP.EQUATES~
*CODE.SEGMENT: ?
* FILE 'WKP' EQUATES - GENERATED 11:42:14  12 JUL 1984
EQU WKP$TOTAL.POINTS TO WKP(1);         * TOTAL POINTS ALLOCATED
EQU WKP$POINTS.TAKEN TO WKP(2);         * NO. OF POINTS ALREADY TAKEN
EQU WKP$SCH.TIMES TO WKP(3);            * SCH. TIMES WHERE ENTERED
EQU WKP$SCH.POINTS TO WKP(4);           * SCH. POINTS FOR SCH. TIMES ENTERED
EQU WKP$SCH.AREAS TO WKP(5);            * SERVICE AREAS LIST
~WKS.DIM~
*CODE.SEGMENT: WKS.DIM
*
DIM WKS(20)
~WKS.EQUATES~
*CODE.SEGMENT: WKS.EQUATES
*
* FILE 'WKS' EQUATES - GENERATED 16:54:46  08 APR 1992
EQU WKS$PERIODS TO WKS(1);              * 
EQU WKS$WEIGHTED.TOTALS TO WKS(2);      * 
EQU WKS$WEIGHTED.COMPLETED TO WKS(3);   * 
EQU WKS$WEIGHTED.PERCENT TO WKS(4);     * 
EQU WKS$WEIGHTED.OVER.BY.CUST TO WKS(5);     * 
EQU WKS$WEIGHTED.OVER.NOT.BY.CUST TO WKS(6); * 
EQU WKS$ACTUAL.TOTALS TO WKS(7);        * 
EQU WKS$ACTUAL.COMPLETED TO WKS(8);     * 
EQU WKS$ACTUAL.PERCENT TO WKS(9);       * 
EQU WKS$ACTUAL.OVER.BY.CUST TO WKS(10);      * 
EQU WKS$ACTUAL.OVER.NOT.BY.CUST TO WKS(11);  * 
EQU WKS$WEIGHTED.TOTAL.CUST TO WKS(12); * 
EQU WKS$WEIGHTED.NON.BULK.CUST TO WKS(13);   * 
EQU WKS$WEIGHTED.BULK.CUST TO WKS(14);       * 
EQU WKS$WEIGHTED.NO.BASIC.CUST TO WKS(15);   * 
EQU WKS$ACTUAL.TOTAL.CUST TO WKS(16);   * 
EQU WKS$ACTUAL.NON.BULK.CUST TO WKS(17);* 
EQU WKS$ACTUAL.BULK.CUST TO WKS(18);    * 
EQU WKS$ACTUAL.NO.BASIC.CUST TO WKS(19);* 
~WKS.VAR.EQUATES~
*CODE.SEGMENT: WKS.VAR.EQUATES
*
* FILE 'WKS' EQUATES - GENERATED 16:54:47  08 APR 1992
EQU WKS$PERIODS TO 1;                   * 
EQU WKS$WEIGHTED.TOTALS TO 2;           * 
EQU WKS$WEIGHTED.COMPLETED TO 3;        * 
EQU WKS$WEIGHTED.PERCENT TO 4;          * 
EQU WKS$WEIGHTED.BY.CUST TO 5;          * 
EQU WKS$WEIGHTED.NOT.BY.CUST TO 6;      * 
EQU WKS$ACTUAL.TOTALS TO 7;             * 
EQU WKS$ACTUAL.COMPLETED TO 8;          * 
EQU WKS$ACTUAL.PERCENT TO 9;            * 
EQU WKS$ACTUAL.BY.CUST TO 10;           * 
EQU WKS$ACTUAL.NOT.BY.CUST TO 11;       * 
EQU WKS$WEIGHTED.TOTAL.CUST TO 12;      * 
EQU WKS$WEIGHTED.NON.BULK TO 13;        * 
EQU WKS$WEIGHTED.BULK TO 14;            * 
EQU WKS$WEIGHTED.NO.BASIC TO 15;        * 
EQU WKS$ACTUAL.TOTAL.CUST TO 16;        * 
EQU WKS$ACTUAL.NON.BULK.CUST TO 17;     * 
EQU WKS$ACTUAL.BULK.CUST TO 18;         * 
EQU WKS$ACTUAL.NO.BASIC.CUST TO 19;     * 
~WO.DVC.OUT.STATUS~
*CODE.SEGMENT: WO.DVC.OUT.STATUS
*
* GENERAL.COMMON.AREA
*
*
DVC.OUT = "N"; LOC = 1
LOOP ACTIV = WKO$ACTIVS<1,LOC> UNTIL ACTIV = "" OR DVC.OUT EQ "Y" DO
IF ACTIV = "IC" OR ACTIV = "ID" THEN
IF WKO$ACTIV.QNTYS<1,LOC> < 0 THEN
SC = 1
LOOP DVC.ID = WKO$DVC.IDS<1,LOC,SC> UNTIL DVC.ID = "" OR DVC.OUT EQ "Y" DO
IF WKO$DVC.ACTIV.STATS<1,LOC,SC> = "" THEN DVC.OUT = "Y" ELSE
SC = SC+1
END
REPEAT
END
END
IF DVC.OUT NE "Y" THEN LOC = LOC+1
REPEAT
*
*
~WO.LOCKUP~
*CODE.SEGMENT: WO.LOCKUP
*
*
* GENERAL.COMMON.AREA
*
IF RL THEN RETURN ELSE RL = ONE
REF = "ACT*":ACT.ID; CALL UPDATE.LOCK(ACT.FILE); IF STAT GT ZERO THEN STAT = 999; RETURN
REF = "ADD*":ADD.ID; CALL UPDATE.LOCK(ADD.FILE); IF STAT GT ZERO THEN STAT = 999; RETURN
REF = "WKO*":WKO.ID; CALL UPDATE.LOCK(WKO.FILE); IF STAT GT ZERO THEN STAT = 999; RETURN
*
~WOA.DIM~
*CODE.SEGMENT: ?
DIM WOA(10)
~WOA.EQUATES~
*CODE.SEGMENT: ?
* FILE 'WOA' EQUATES - GENERATED 11:47:32  07 OCT 1983
EQU WOA$CODES TO WOA(1);                * ACTIVITY CODE
EQU WOA$DESCS TO WOA(2);                * ACTIVITY DESCRIPTION
EQU WOA$TYPES TO WOA(3);                * ACTIVITY TYPE
EQU WOA$GENERATES TO WOA(4);            * GENERATED SUBSTITUTE ACTIVITIES
~WOT.DIM~
*CODE.SEGMENT: ?
DIM WOT(25)
~WOT.EQUATES~
*CODE.SEGMENT: WOT.EQUATES
*
* FILE 'WOT' EQUATES - GENERATED 12:26:07  30 DEC 1991
EQU WOT$TYPE TO WOT(1);                 * TYPE OF WORK ORDER
EQU WOT$DESC TO WOT(2);                 * DESCRIPTION
EQU WOT$BASIC.POINTS TO WOT(3);         * BASIC POINTS FOR W/O TYPE
EQU WOT$REQD.ACTIVS TO WOT(4);          * REQUIRED ACTIVITY
EQU WOT$REQD.POINTS TO WOT(5);          * W/O POINTS FOR REQD. ACTIVITY
EQU WOT$OPT.ACTIVS TO WOT(6);           * OPTIONAL ACTIVITY
EQU WOT$OPT.POINTS TO WOT(7);           * W/O POINTS FOR OPT. ACTIVITY
EQU WOT$FUNC TO WOT(8);                 * BASIC FUNCTION OF W/O
EQU WOT$NEW.TNT TO WOT(9);              * W/O SPECIFIC TO NEW OR OLD TENANT
EQU WOT$ACT.STATS TO WOT(10);           * VALID ACT STATUSES FOR W/O
EQU WOT$ADD.STATS TO WOT(11);           * VALID ADD STATUSES FOR W/O
EQU WOT$SCH.REQD TO WOT(12);            * WHETHER W/O SCHEDULING IS REQUIRED
EQU WOT$SCH.TYPE TO WOT(13);            * SCHEDULE TYPE
EQU WOT$PRINT.DESC TO WOT(14);          * DESCRIPTION PRINTED ON WORK ORDER
EQU WOT$PURGE.REQ TO WOT(15);           * PURGE OPTION
EQU WOT$CONFIRM.OPT TO WOT(16);         * CONFIRMATION OPTION
EQU WOT$CANCEL.OPT TO WOT(17);          * CANCELLATION OPTION
EQU WOT$INSTALL.OPT TO WOT(18);         * INSTALLER OPTION
EQU WOT$SALES.OPT TO WOT(19);           * SALESMAN OPTION
EQU WOT$DISC.REASON TO WOT(20);         * DISCONNECT REASON
EQU WOT$ROLL TO WOT(21);                * IS A TRUCK ROLL REQUIRED?
~WOT.VAR.EQUATES~
*CODE.SEGMENT: WOT.VAR.EQUATES
*
* FILE 'WOT' EQUATES - GENERATED 12:26:07  30 DEC 1991
EQU WOT$TYPE TO 1;                      * TYPE OF WORK ORDER
EQU WOT$DESC TO 2;                      * DESCRIPTION
EQU WOT$BASIC.POINTS TO 3;              * BASIC POINTS FOR W/O TYPE
EQU WOT$REQD.ACTIVS TO 4;               * REQUIRED ACTIVITY
EQU WOT$REQD.POINTS TO 5;               * W/O POINTS FOR REQD. ACTIVITY
EQU WOT$OPT.ACTIVS TO 6;                * OPTIONAL ACTIVITY
EQU WOT$OPT.POINTS TO 7;                * W/O POINTS FOR OPT. ACTIVITY
EQU WOT$FUNC TO 8;                      * BASIC FUNCTION OF W/O
EQU WOT$NEW.TNT TO 9;                   * W/O SPECIFIC TO NEW OR OLD TENANT
EQU WOT$ACT.STATS TO 10;                * VALID ACT STATUSES FOR W/O
EQU WOT$ADD.STATS TO 11;                * VALID ADD STATUSES FOR W/O
EQU WOT$SCH.REQD TO 12;                 * WHETHER W/O SCHEDULING IS REQUIRED
EQU WOT$SCH.TYPE TO 13;                 * SCHEDULE TYPE
EQU WOT$PRINT.DESC TO 14;               * DESCRIPTION PRINTED ON WORK ORDER
EQU WOT$PURGE.REQ TO 15;                * PURGE OPTION
EQU WOT$CONFIRM.OPT TO 16;              * CONFIRMATION OPTION
EQU WOT$CANCEL.OPT TO 17;               * CANCELLATION OPTION
EQU WOT$INSTALL.OPT TO 18;              * INSTALLER OPTION
EQU WOT$SALES.OPT TO 19;                * SALESMAN OPTION
EQU WOT$DISC.REASON TO 20;              * DISCONNECT REASON
EQU WOT$ROLL TO 21;                     * IS A TRUCK ROLL REQUIRED?
~XPV.DIM~
DIM XPV(10)
~XPV.EQUATES~
*CODE.SEGMENT: XPV.EQUATES
*
* FILE 'XPV' EQUATES - GENERATED 15:56:53  04 MAR 1994
EQU XPV$EVENT.NUMS TO XPV(1);           * EVENT NUMBERS
EQU XPV$DUR TO XPV(2);                  * DURATION OF THE EVENT SHOWN (1-16 SECS)
EQU XPV$ACCOUNT TO XPV(3);              * THE ACCOUNT THAT WATCHED THE EVENT
EQU XPV$ACC TO XPV(4);                  * COMPANY CODE (PICK ACCOUNT)
EQU XPV$ERROR TO XPV(5);                * ERROR TEXT FROM THE SPLIT OR UPLOAD
EQU XPV$DONE TO XPV(6);                 * PROCESSED BY THE SPLIT INDICATOR
EQU XPV$COLL.ERR TO XPV(7);             * COLLECTION ERROR CODE
EQU XPV$AI.CODE TO XPV(8);              * CODE FOR THE AI.TYPE
EQU XPV$GROUP TO XPV(9);                * COLLECTION GROUP NUMBER
EQU XPV$TIME TO XPV(10);                * TIME OF UPLOAD
~XPV.VAR.EQUATES~
*CODE.SEGMENT: XPV.VAR.EQUATES
*
* FILE 'XPV' EQUATES - GENERATED 15:56:53  04 MAR 1994
EQU XPV$EVENT.NUMS TO 1;                * EVENT NUMBERS
EQU XPV$DUR TO 2;                       * DURATION OF THE EVENT SHOWN (1-16 SECS)
EQU XPV$ACCOUNT TO 3;                   * THE ACCOUNT THAT WATCHED THE EVENT
EQU XPV$ACC TO 4;                       * COMPANY CODE (PICK ACCOUNT)
EQU XPV$ERROR TO 5;                     * ERROR TEXT FROM THE SPLIT OR UPLOAD
EQU XPV$DONE TO 6;                      * PROCESSED BY THE SPLIT INDICATOR
EQU XPV$COLL.ERR TO 7;                  * COLLECTION ERROR CODE
~XTR.EQUATES~
*CODE.SEGMENT: XTR.EQUATES
*
* FILE 'XTR' EQUATES - GENERATED 05:22:00  25 JUL 1991
~XTR.ERR.DIM~
*CODE.SEGMENT: ?
DIM XTR.ERR(5)
~XTR.ERR.EQUATES~
*CODE.SEGMENT: XTR.ERR.EQUATES
*
* FILE 'XTR.ERR' EQUATES - GENERATED 21:24:13  06 DEC 1991
EQU XTR.ERR$DATE.SEQ TO XTR.ERR(1);     * Date*sequence number from transmission
EQU XTR.ERR$ERR TO XTR.ERR(2);          * Error number detected in split
~XTR.ERR.VAR.EQUATES~
*CODE.SEGMENT: XTR.ERR.VAR.EQUATES
*
* FILE 'XTR.ERR' EQUATES - GENERATED 21:24:13  06 DEC 1991
EQU XTR.ERR$DATE.SEQ TO 1;              * Date*sequence number from transmission
EQU XTR.ERR$ERR TO 2;                   * Error number detected in split
~XTR.INCL.POST.READ~
*CODE.SEGMENT: XTR.INCL.POST.READ
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
LOOP
LCK.STAT = -LCK.TYPE; CALL LOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID,LCK.FILE,LCK.STAT)
WHILE LCK.STAT DO REPEAT
READ XTR.POST FROM CNT.FILE,XTR.POST.ID ELSE XTR.POST = EMPTY
*
~XTR.INCL.POST.WRITE~
*CODE.SEGMENT: XTR.INCL.POST.WRITE
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
IF NOT(CNT.TST$FILE) THEN
WRITE XTR.POST ON CNT.FILE,XTR.POST.ID
END
CALL UNLOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID,LCK.FILE)
*
~XTR.TRANS.DIM~
*CODE.SEGMENT: ?
DIM XTR.TRANS(20)
~XTR.TRANS.EQUATES~
*CODE.SEGMENT: XTR.TRANS.EQUATES
*
* FILE 'XTR.TRANS' EQUATES - GENERATED 21:24:30  06 DEC 1991
EQU XTR.TRANS$REC.CN TO XTR.TRANS(1);   * Record counter
EQU XTR.TRANS$FAILED TO XTR.TRANS(2);   * Transmission split has failed
EQU XTR.TRANS$TOT.REMT TO XTR.TRANS(3); * Total remitances
EQU XTR.TRANS$REMT.CN TO XTR.TRANS(4);  * total number of remitances
EQU XTR.TRANS$BAT.LAST TO XTR.TRANS(5); * Last batch number
EQU XTR.TRANS$TRANS.DT TO XTR.TRANS(6); * Transmission date
EQU XTR.TRANS$TRANS.TM TO XTR.TRANS(7); * Transmission time
EQU XTR.TRANS$DEP.DT TO XTR.TRANS(8);   * Deposit date
EQU XTR.TRANS$CALC.REMT.CN TO XTR.TRANS(9);  * Actual count of remitances
EQU XTR.TRANS$CALC.TOT.REMT TO XTR.TRANS(10);* Calculated total remitances
EQU XTR.TRANS$BAT TO XTR.TRANS(11);          * 
EQU XTR.TRANS$ERR TO XTR.TRANS(12);          * Error array for batch
EQU XTR.TRANS$BAT.REMT.CN TO XTR.TRANS(13);  * Erorr batch remitance counts
EQU XTR.TRANS$BAT.TOT.REMT TO XTR.TRANS(14); * Error batch total remitances
EQU XTR.TRANS$BAT.ERR TO XTR.TRANS(15);      * Error batch error array
EQU XTR.TRANS$FOUND TO XTR.TRANS(16);        * Count of found header records
EQU XTR.TRANS$SPLIT TO XTR.TRANS(17);        * Has this transmission been split
~XTR.TRANS.VAR.EQUATES~
*CODE.SEGMENT: XTR.TRANS.VAR.EQUATES
*
* FILE 'XTR.TRANS' EQUATES - GENERATED 21:24:30  06 DEC 1991
EQU XTR.TRANS$REC.CN TO 1;              * Record counter
EQU XTR.TRANS$FAILED TO 2;              * Transmission split has failed
EQU XTR.TRANS$TOT.REMT TO 3;            * Total remitances
EQU XTR.TRANS$REMT.CN TO 4;             * total number of remitances
EQU XTR.TRANS$BAT.LAST TO 5;            * Last batch number
EQU XTR.TRANS$TRANS.DT TO 6;            * Transmission date
EQU XTR.TRANS$TRANS.TM TO 7;            * Transmission time
EQU XTR.TRANS$DEP.DT TO 8;              * Deposit date
EQU XTR.TRANS$CALC.REMT.CN TO 9;        * Actual count of remitances
EQU XTR.TRANS$CALC.TOT.REMT TO 10;      * Calculated total remitances
EQU XTR.TRANS$BAT TO 11;                * 
EQU XTR.TRANS$ERR TO 12;                * Error array for batch
EQU XTR.TRANS$BAT.REMT.CN TO 13;        * Erorr batch remitance counts
EQU XTR.TRANS$BAT.TOT.REMT TO 14;       * Error batch total remitances
EQU XTR.TRANS$BAT.ERR TO 15;            * Error batch error array
EQU XTR.TRANS$FOUND TO 16;              * Count of found header records
EQU XTR.TRANS$SPLIT TO 17;              * Has this transmission been split
~XTR.VAR.EQUATES~
*CODE.SEGMENT: XTR.VAR.EQUATES
*
* FILE 'XTR' EQUATES - GENERATED 05:22:01  25 JUL 1991
