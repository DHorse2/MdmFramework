QG. HORSMAN
*
BREAK OFF
*
END
~BREAK-ON~
*PROGRAM: BREAK-ON
*
* AUTHOR: DAVID G. HORSMAN
*
BREAK ON
*
END
~BU1.LOCK.ITEM~
XSUBROUTINE LOCK.ITEM (ITEM.FILE,FILE.NAME,ITEM.ID,LOCKS.FILE,STAT)
* VERSION: 910917 261  MAJOR CHANGES MADE BY DH
* (ITEM.FILE,FILE.NAME,ITEM.ID,LOCKS.FILE,RETRY,DISP,INPT,OVERRIDE,STAT)
* PRIOR: 900415 1.9
* PROGRAM:           LOCK.ITEM
* AUTHOR:            DAVID HORSMAN - AXION
* DESCRIPTION:       LOCK AN ITEM
*
*     STAT      MEANING
*     ----      __________________________________
*        0      SUCCESSFULLY LOCKED
*      nnn      ALREADY LOCKED AT TERMINAL nnn - 1
*      900      SYSTEM LEVEL LOCK PRESENT
*      999      OPERATOR 'KILL' REQUEST
*
* IF RSP EQ 'OVERRIDE'    -   OPERATOR 'OVERRIDE' REQUEST
*
* PASSED TO PROGRAM: 
*       ZERO = Normal, RETRY, INPUT, SCREEN I/O (T/O)
*       -ONE = RETRY if already locked (IMMED)
*       -TWO = No RETRY, INPUT <cr> if locked (IMMED)
*       -3   = No RETRY, No INPUT if already locked (T/O)
*       -4   = No RETRY, No INPUT if already locked (IMMED)
*       -5   = No RETRY, No SCREEN I/O if already locked (IMMED)
*       -6   = No RETRY, No SCREEN I/O, OVERRIDE if locked (IMMED)
*       -7   = No RETRY, No SCREEN I/O, OVERRIDE if locked (T/O)
*
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP LOCKS.VAR.EQUATES
*
LOCK.TYPE = STAT
LOCK.ID = FILE.NAME:"*":ITEM.ID
!
READ.IT: * ATTEMPT TO READ THE LOCK ITEM
*
MSG = EMPTY; TRY.CN = 1
*
LOOP
*
IF MSG NE EMPTY THEN IF LOCK.TYPE GE -4 THEN
PRINT CLB2:MSG:
PRINT CLB1:"Lock attempt no. ":TRY.CN-ONE:
END
*
LOCK.LOCKED = FALSE
*
* MSG = EMPTY; * REV ONLY
* LOCK ITEM.FILE, ITEM.ID ELSE; * REV ONLY
* IF STATUS() NE ONE THEN LOCK.LOCKED = TRUE; STAT = 900; MSG = FILE.NAME:" ":ITEM.ID:" in use."; * REV ONLY
* END; * REV ONLY
* IF MSG NE EMPTY THEN GOTO NEXT.TRY ELSE STAT = FALSE; RETURN; * REV ONLY
*
* ULT ONLY
READU LOCK.REC FROM LOCKS.FILE,LOCK.ID LOCKED LOCK.LOCKED = TRUE ELSE GOTO LOCK.IT
*
IF LOCK.LOCKED THEN LOCK.REC = EMPTY 
*
IF LOCK.REC<LOCKS$PORT> EQ PORT THEN
MSG = "Lock is already present for this port!"
* IF LOCK.TYPE GE -4 THEN PRINT CLB2:MSG:
GOTO LOCK.IT
END
*
IF NOT(LOCK.LOCKED) THEN RELEASE LOCKS.FILE,LOCK.ID
*
IF LOCK.LOCKED THEN
*
MSG = "LOCKS control information is not available yet . . . "
STAT = 900
*
END ELSE
*
PORT.NUM = LOCK.REC<LOCKS$PORT>
ACCT.NUM = LOCK.REC<LOCKS$ACCT.NAME>
LOCK.DATE = LOCK.REC<LOCKS$LOCK.DATE>
LOCK.TIME = LOCK.REC<LOCKS$LOCK.TIME>
LOCK.ELP = ((DATE() - LOCK.DATE) * 86400) + (TIME() - LOCK.TIME)
IF LOCK.ELP GT 7200 THEN
MSG = "Lock item is ":OCONV(LOCK.ELP,"MTS"):" hours old and has expired."
IF LOCK.TYPE GE -4 THEN PRINT CLB2:MSG:
GOTO LOCK.IT
END
STAT = PORT.NUM + ONE
*
*
LOCK.DATE = OCONV(LOCK.DATE,"D2")
LOCK.DATE = FIELD(LOCK.DATE," ",ONE):" ":FIELD(LOCK.DATE," ",2)
*
LOCK.TIME.DISP = OCONV(LOCK.TIME,"MTS")
*
MSG = FILE.NAME:" ":ITEM.ID:" in use by ":PORT.NUM:" ":ACCT.NUM:" (":LOCK.DATE:" ":LOCK.TIME.DISP:" for ":OCONV(LOCK.ELP,"MTS"):")"
*
IF LOCK.TYPE EQ -ONE OR LOCK.TYPE EQ -TWO OR (LOCK.TYPE LE -4 AND LOCK.TYPE GE -6) THEN TRY.CN = 999
*
END; * of lock not locked
*
NEXT.TRY: *
*
* WHILE TRY.CN LT 5 DO; * REV ONLY
* ULT ONLY
WHILE TRY.CN LT 5 AND NOT(SYSTEM(11)) DO
IF LOCK.TYPE GE -4 THEN PRINT CLB2:MSG:
TRY.CN = TRY.CN + ONE
FOR COUNTER = ONE TO 3
RQM
NEXT COUNTER
REPEAT
*
* GOTO NEXT.TRY1; * REV ONLY
*
IF LOCK.TYPE LE -6 THEN
MSG = "Lock OVERRIDE in effect. Now locked by your port"
GOTO LOCK.IT
END
*
NEXT.TRY1: *
*
IF LOCK.TYPE GE -4 THEN
PRINT CLB1:MSG:
PRINT CLB2:"Can't lock this information.":
END
IF LOCK.TYPE EQ -TWO THEN
PRINT BELL:" Enter <cr>: ":; INPUT TMP:
END
*
IF LOCK.TYPE LE -TWO THEN GOTO RELEASE.IT
*
RQM; RQM
PRINT BELL:CLB1:MSG:
* ULT ONLY
PRINT CLB2:"Try to lock it again (<cr>/N/OVERRIDE)? ":
* PRINT CLB2:"Try to lock it again (<cr>/N)? ":; * REV ONLY
* ULT ONLY
INPUTCLEAR
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO RELEASE.IT
IF RSP EQ "OVERRIDE" THEN
* ULT ONLY
DELETE LOCKS.FILE,LOCK.ID
* ULT ONLY
PRINT CLB1:CLB2:; GOTO READ.IT
END
IF RSP NE "N" THEN
IF MSG NE EMPTY AND LOCK.TYPE GE -4 THEN PRINT CLB1:CLB2:
GOTO READ.IT
END
*
GOTO RELEASE.IT
*
!
*
LOCK.IT: * LOCK THE ITEM
*
IF MSG NE EMPTY AND LOCK.TYPE GE -4 THEN
RQM
PRINT CLB1:CLB2:
END
*
LOCK.REC    = EMPTY
LOCK.REC<LOCKS$PORT> = PORT
LOCK.REC<LOCKS$ACCT.NAME> = ACCT
LOCK.REC<LOCKS$LOCK.DATE> = DATE()
LOCK.REC<LOCKS$LOCK.TIME> = TIME()
LOCK.REC<LOCKS$LOCK.TYPE> = LOCK.TYPE
LOCK.REC<LOCKS$MSG>       = MSG
*
WRITE LOCK.REC ON LOCKS.FILE,LOCK.ID
*
STAT = FALSE
*
RETURN
*
!
*
RELEASE.IT: *
*
RELEASE LOCKS.FILE,LOCK.ID
*
RETURN
*
END
~BYE~
*PROGRAM: BYE
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT
PRINT "Good-bye !"
PRINT
*
END
~CONTACT.GENERATE~
*PROGRAM: GENERATE.CONTACT
*
*#
*#    Documentation Area
$INCLUDE IBP CG@DOC@HDR@CONTACT.GENERATE
*#
*#
*#    Common Area
$INCLUDE IBP CG.COMMON.VARIABLES
*#
$INCLUDE IBP CG.COMMON.FUNCTIONS
*#
*#    Initialization Area
*#
*#    System Variables
SYS.PROG = "CONTACT.GENERATE"
SYS.LOCT = "INIT"
SYS.SLOC = "FUNCTIONS"
*#
SYS.PROG.DESC = 'Generate a list'
SYS.FORMAT = "2x6x35x2"
SYS.ABORT = ''; USER.ABORT = ''
*#
*#    Set Start Time
E.START.DATE = DATE(); E.START.TIME = TIME()
LBL.PR.CN = 0
*#
*#    Arrays
DIM KEY.LIST(500), OUT.CNTCT(30), MST.CNTCT(30), CALL.VL(10)
MAT KEY.LIST = ""; MAT OUT.CNTCT = ""; MAT ENTITY.REC = ""; MAT MST.CNTCT = ""; MAT CALL.VL = ""
KEY.COMM.LIST = ""
MAT PRVL = ""
MAT FORM = ""
*#
*#    Variables
HORZ.CN = 0
FINISHED = 0
ERROR = 0
*# Clear Screen
PRINT @(0,0):CLS:@(35,3):SYS.PROG.DESC
SYS.PROG.STATUS = 'IN.PROGRESS'
SYS.SLOC<1> = "INPUT.PARAMS"
*#
*#    Input SYS.RUN.TYPE
*#          USER.NAME
*#          CNTC.KEY
*#          Contacts File
*#          How many labels to print per contact
*#          Label printing format
*#          Status to process
*#
PRINT @(0,5):CLS:
INPUT SYS.RUN.TYPE
INPUT USER.NAME
INPUT CNTC.KEY
INPUT CNTC.FILE.NAME
INPUT LBL.TO.PRINT
INPUT SYS.FORMAT
IF LEN(SYS.FORMAT) LT 6 THEN SYS.FORMAT = "1x6x80"
INPUT SYS.PROC.STATUS
IF INDEX("*C*X*H*I*?*","*":SYS.PROC.STATUS:"*",1) EQ 0 THEN SYS.PROC.STATUS = "I"
SYS.RUNT = FIELD(SYS.FORMAT,"#",4)
IF SYS.RUNT NE "E" THEN SYS.RUNT = "R"
*
E.START.DATE = DATE(); E.START.TIME = TIME()
*#
*#    Open Files
*#
*#       Open System file (SY.FILE)
SYS.SLOC<1> = "OPEN.SY.FILE"
OPEN 'SYS.STRUCTURE' TO SY.FILE ELSE ERROR = 1; GOSUB ERROR.RTN; STOP
*#
*#       Open Contacts file (OUTPUT) (CNTC.FILE)
SYS.SLOC<1> = "OPEN.CNCT.FILE"
OPEN CNTC.FILE.NAME TO CNTC.FILE ELSE ERROR = 7; GOSUB ERROR.RTN; STOP
*#
*#       Open Codes file
SYS.SLOC<1> = "OPEN.CODES.FILE"
OPEN "CODES" TO CODES.FILE ELSE ERROR = 11; GOSUB ERROR.RTN; STOP
*#
*#    Update Run Jrnl #
SYS.SLOC<1> = "JRNL"
READ SYS.JRNL FROM SY.FILE,"@SYS@":USER.NAME:"@JRNL@RUNS" ELSE SYS.JRNL = 0
SYS.JRNL = SYS.JRNL + 1
WRITE SYS.JRNL ON SY.FILE,"@SYS@":USER.NAME:"@JRNL@RUNS"
*#
*#    *** Being processing ***
*#
*#
*#
*#    Read in List Master record.
*#
*#   Item ID
SYS.FILE = "SY.FILE"
SYS.ITEM = "@CNTC@MSTR@":CNTC.KEY
SYS.LOCT<1> = "CNTC.MSTR"
SYS.SLOC<1> = "READ"
*#
*#   READ Item
READ CNCT.MSTR.DATA FROM CNTC.FILE,SYS.ITEM THEN
*#
*#    Item foun***
*#
*#
*#
*#    Read in List Master record.
*#
*#   Item ID
SYS.FILE = "SY.FILE"
SYS.ITEM = "@CNTC@MSTR@":CNTC.KEY
SYS.LOCT<1> = "CNTC.MSTR"
SYS.SLOC<1> = "READ"
*#
*#   READ Item
READ CNCT.MSTR.DATA FROM CNTC.FILE,SYS.ITEM THEN
*#
*#    Item found
SYS.SLOC<1> = "VAR"
E.USER         = CNCT.MSTR.DATA<1>; * USER EXECUTING GENERATE CONTACT
KEY.LIST.NAME  = CNCT.MSTR.DATA<2>; * NAME OF LIST TO GENERATE
LIST.FILE.NAME = CNCT.MSTR.DATA<3>; * NAME OF LISTS FILE
EI.FILE        = CNCT.MSTR.DATA<4>; * FILE THE LIST ACCESSES
CNTC.FILE.NAME = CNCT.MSTR.DATA<5>; * FILE TO WRITE CONTACT ON TO
E.PREF         = CNCT.MSTR.DATA<6>; * CONTACT KEY PREFIX
E.SUFF         = CNCT.MSTR.DATA<7>; * CONTACT KEY SUFFIX
E.CALL         = CNCT.MSTR.DATA<8>; * SV'S WITH SUBROUTINES TO CALL
*                                       PER CONTACT
E.CAL2         = CNCT.MSTR.DATA<9>; * AS ABOVE BUT FOR SECOND PASS OF FILE
E.KEYC         = CNCT.MSTR.DATA<10>; * KEYS FOR CONTACT MASTER RECORD
E.KEY2         = CNCT.MSTR.DATA<11>; * AS ABOVE BUT FOR SECOND PASS OF FILE
E.STAT         = CNCT.MSTR.DATA<12>; * RUN HISTORY FOR THIS LIST
*#
*#    Item not found
END ELSE
SYS.SLOC<1> = "ERR.INPUT"
ERROR = 2; GOSUB ERROR.RTN
PRINT; PRINT
PRINT 'USER: ':; INPUT E.USER:; PRINT @(7):E.USER
PRINT 'LIST: ':; INPUT KEY.LIST.NAME:; PRINT @(7):KEY.LIST.NAME
PRINT 'FILE: ':; INPUT LIST.FILE.NAME:; PRINT @(7):LIST.FILE.NAME
PRINT 'FILA: ':; INPUT EI.FILE:; PRINT @(7):EI.FILE
PRINT 'FILC: ':; INPUT CNTC.FILE.NAME:; PRINT @(7):CNTC.FILE.NAME
PRINT 'PREF: ':; INPUT E.PREF:; PRINT @(7):E.PREF
PRINT 'SUFF: ':; INPUT E.SUFF:; PRINT @(7):E.SUFF
PRINT 'CALL: ':; INPUT E.CALL:; PRINT @(7):E.CALL
PRINT 'CAL2: ':; INPUT E.CAL2:; PRINT @(7):E.CAL2
PRINT 'KEYC: ':; INPUT E.KEYC:; PRINT @(7):E.KEYC
PRINT 'KEY2: ':; INPUT E.KEY2:; PRINT @(7):E.KEY2
E.STAT = ''
END
*#
*#    Files Section
*#
*#    Read in Form if present
SYS.FORM = FIELD(SYS.FORMAT,"#",3)
IF LEN(SYS.FORM) THEN
MATREAD FORM FROM SY.FILE,"@FORM@":SYS.FORM ELSE
ERROR = 10; GOSUB ERROR.RTN
MAT FORM = ''
END
END ELSE MAT FORM = ''
*#
*#       Open List file (LIST.FILE.NAME)
SYS.SLOC<1> = "OPEN.LIST.FILE"
OPEN LIST.FILE.NAME TO LIST.FILE ELSE ERROR = 3; GOSUB ERROR.RTN; STOP
*#
*#       Read in List to KEY.LIST from List files (LIST.FILE.NAME)
SYS.SLOC<1> = "READ.KEYS"
MATREAD KEY.LIST FROM LIST.FILE,KEY.LIST.NAME ELSE ERROR = 4; GOSUB ERROR.RTN; STOP
*#
*#       Open Data (INPUT) file (EI.FILE)
SYS.SLOC<1> = "OPEN.EI"
LOOP
CONT = 0
IF EI.FILE EQ '' THEN CONT = 1 ELSE
OPEN EI.FILE TO ENTITY.FILE ELSE
ERROR = 6; GOSUB ERROR.RTN
CONT = 1
END
END
WHILE CONT DO
GOSUB INPUT.FILE.NAME
IF FILE.NAME = 'END' THEN GOTO End.of.program
EI.FILE = FILE.NAME
REPEAT
*#
EXECUTE "SP-ASSIGN HS"
IF SYS.RUNT EQ "E" THEN
PRINTER ON
PRINT FF:OCONV(DATE(),"D2"):SPACE(10):SYS.PROG.DESC
PRINT OCONV(TIME(),"MTH")
PRINT SPACE(30):"Exceptions Report"
PRINT 
PRINT 
PRINT "User: ":E.USER
PRINT "Control Item: ":CNTC.KEY
PRINT "Contact File: ":CNTC.FILE.NAME
PRINT "# of Labels/Pages: ":LBL.TO.PRINT
PRINT "Label Format: ":SYS.FORMAT
PRINT 
PRINT 
PRINTER OFF
END
*#
*#
*#   MAIN PROCESSING LOOP   @@@v
*#
*Second.pass.return.point: *#*
LBL.ALPHA = "A"
FOR PASS = 1 TO 2 UNTIL (SYS.ABORT OR USER.ABORT) OR (PASS = 2 AND E.CAL2 = '')
*#
*#    Load CALLs into CALL.VL (E.CALL MVs)
SYS.LOCT<1> = "MAIN"
SYS.SLOC<1> = "CALLS"
CN = 0
LOOP CN = CN + 1 WHILE E.CALL<1,CN> # '' DO CALL.VL(CN) = E.CALL<1,CN> REPEAT
CALL.CN = CN - 1
KEY.CN = 0
KEY.RJT.CN = 0
*#
Loop.return.point: *#*
LOOP
KEY.CN = KEY.CN + 1
EI.KEY.VL = KEY.LIST(KEY.CN)<1,1>
*
KEY.STATUS = KEY.LIST(KEY.CN)<1,3,1>
IF INDEX("*C*X*H*I*?*","*":KEY.STATUS:"*",1) EQ 0 THEN KEY.STATUS = "I"
IF EI.KEY.VL EQ "" THEN FINISHED = TRUE
*#
*#    Check for end of List
WHILE SYS.PROG.STATUS # 'STOP' AND EI.KEY.VL # '' DO
*#
*#    Check status of the Item
SYS.PROG.STATUS = 'NEXT'
IF KEY.STATUS EQ SYS.PROC.STATUS THEN
*#
*#    Read Entity data
SYS.SLOC<1> = "READ.EI.DATA"
SYS.FILE = "ENTITY.FILE"
SYS.ITEM = EI.KEY.VL
MATREAD ENTITY.REC FROM ENTITY.FILE,SYS.ITEM THEN
*#
*#   PROCESS SUBROUTINE CALLS FOR THIS MASTER CONTACT (2 LEVELS RELOOPED)
CALL.COMM = ''
CN = 0
LOOP WHILE CN < CALL.CN & SYS.PROG.STATUS # 'STOP' DO
CN = CN + 1
CALL.ID = CALL.VL(CN)
CALL @CALL.ID (ERROR)
IF SYS.PROG.STATUS = 'STOP' THEN ERROR = 8; PRINT BELL:; RQM; PRINT BELL:; RQM
IF SYS.PROG.STATUS = 'STOP' OR SYS.PROG.STATUS = 'SKIP' OR CALL.COMM # '' THEN
IF SYS.RUNT EQ "E" THEN
PRINTER ON
PRINT 
PRINT 
PRINT 
PRINT KEY.CN:'. ':EI.KEY.VL:', Status: ':SYS.PROG.STATUS
CN1 = 0
LOOP CN1 = CN1 + 1 WHILE CALL.COMM<CN1> # '' DO PRINT '|<>|<>|<>|':CALL.COMM<CN1> REPEAT
FOR A = 1 TO 10 UNTIL A > 6 AND LNVL(A-2) EQ ""
PRINT A "R#2":" [>":LNVL(A)
*
*=================================*
*/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\/^\*
* 1  2  3  4  5  6  7  8  9  0  1 *
*\v/\v/\v/\v/\v/\v/\v/\v/\v/\v/\v/*
*=================================*
*
NEXT A
PRINTER OFF
END; * OF SYS.RUNT EQ "E"
CN1 = 0
PRINT @(0,5):CLS:
PRINT @(0,6):EI.KEY.VL:
PRINT @(10,8):'Processing Status: ':SYS.PROG.STATUS:
LOOP
CN1 = CN1 + 1
WHILE CALL.COMM<CN1> # '' DO
IF CN1 = 10 THEN PRINT @(0,23):CLL:'HIT <CR> ':; INPUT A$:
IF CN1 > 10 THEN PRINT @(5,CN1+9-10): ELSE PRINT @(5,CN1+9):
PRINT CLL:CALL.COMM<CN1>:
*#
*#
REPEAT
*#
*IF CN1 > 1 THEN RQM
END; *#   OF CALL.COMM NOT EMPTY OR ERROR (SYS.PROG.STATUS=STOP OR SKIP)
*#
*#
REPEAT; *#		 FOR CN < CALL.CN
*#
*#    EI data gone!
END ELSE
CALL.COMM=CALL.COMM:AM:"ENTITY.INFOrmation is missing !"
END
*#
*#   NOW GENERATE CONTACT AND WRITE IT ON THE CONTACT FILE
*#
SEQ = 0
F.SEQ = 0
MST.CN = 1
LOOP
*#
*# NEXT CONTACT SEQUENCE NUMBER
SYS.FILE = "CNTC.FILE"
SEQ = SEQ + 1
K.SEQ = STR('0',(5-LEN(SEQ))):SEQ
SYS.ITEM = E.PREF:EI.KEY.VL:E.SUFF:'@':K.SEQ
READV TEMP.REC FROM CNTC.FILE,SYS.ITEM,1 ELSE
F.SEQ = 1
MAT OUT.CNTCT = ''
*#
*#   READ IN MASTER CONTACT (GOTTEN FROM LIST MASTER)
SYS.SLOC<1> = "READ.MSTR.DETL"
SYS.FILE = "LIST.FILE"
SYS.ITEM = "@CNTC@MSTR@":CNTC.KEY:"@":E.KEYC<1,MST.CN>
MATREAD MST.CNTCT FROM LIST.FILE,SYS.ITEM ELSE ERROR = 5; GOSUB ERROR.RTN; PRINT ' Enter <CR>. ':;INPUT A$
OUT.CNTCT(1)=MST.CNTCT(1)
OUT.CNTCT(2)=MST.CNTCT(2)
*
IF MST.CNTCT(3)<1,1> # '' & MST.CNTCT(3)<1,1> # ' ' THEN
OUT.CNTCT(3)<1,1> = MST.CNTCT(3)<1,1>
END ELSE OUT.CNTCT(3)<1,1> = DATE()
*
IF MST.CNTCT(3)<1,2> # '' & MST.CNTCT(3)<1,2> # ' ' THEN
OUT.CNTCT(3)<1,2> = MST.CNTCT(3)<1,2>
END ELSE OUT.CNTCT(3)<1,2> = 'Generated'
*
IF MST.CNTCT(3)<1,3> # '' & MST.CNTCT(3)<1,3> # ' ' THEN
OUT.CNTCT(3)<1,3> = MST.CNTCT(3)<1,3>
END ELSE OUT.CNTCT(3)<1,3> = E.USER
*
IF MST.CNTCT(3)<1,4> # '' & MST.CNTCT(3)<1,4> # ' ' THEN
OUT.CNTCT(3)<1,4> = MST.CNTCT(3)<1,4>
END ELSE OUT.CNTCT(3)<1,4> = TIME()
*
IF MST.CNTCT(3)<1,5> # '' & MST.CNTCT(3)<1,5> # ' ' THEN
OUT.CNTCT(3)<1,5> = MST.CNTCT(3)<1,5>
END ELSE OUT.CNTCT(3)<1,5> = 0
*
OUT.CNTCT(4)=MST.CNTCT(4)
OUT.CNTCT(5) = DATE():SVM:E.USER:VM
OUT.CNTCT(6)=MST.CNTCT(6)
OUT.CNTCT(7)=MST.CNTCT(7)
OUT.CNTCT(8)=MST.CNTCT(8)
OUT.CNTCT(9)=MST.CNTCT(9)
*#
*#   WRITE CONTACT ON CNTC.FILE
MATWRITE OUT.CNTCT ON CNTC.FILE,SYS.ITEM
MST.CN = MST.CN + 1
END
WHILE NOT(F.SEQ) DO REPEAT
END ELSE
SYS.PROG.STATUS = 'OMIT'
ERROR = 9
END; *#   OF KEY.STATUS EQ SYS.PROC.STATUS
PRINT @(0,23):CLL:(KEY.CN:'. ') 'R#8':EI.KEY.VL:
*#
*#    Set completion status
IF SYS.PROG.STATUS = 'STOP' OR SYS.PROG.STATUS = 'SKIP' THEN
KEY.STATUS = 'X'
KEY.RJT.CN = KEY.RJT.CN + 1
END ELSE
KEY.STATUS = 'C'
END
*#
IF KEY.STATUS NE SYS.PROC.STATUS THEN
*KEY.LIST(KEY.CN)<1,3> = KEY.STATUS:SVM:E.USER:SVM:DATE():SVM:TIME():SVM:WHO:VM:KEY.LIST(KEY.CN)<1,3>
KEY.LIST(KEY.CN)<1,3> = KEY.STATUS:SVM:E.USER:SVM:DATE():SVM:TIME():SVM:WHO
END ELSE
KEY.COMM.LIST = KEY.COMM.LIST:KEY.LIST(KEY.CN)<1,1>:VM:KEY.LIST(KEY.CN)<1,2>:VM:KEY.STATUS:SVM:E.USER:SVM:DATE():SVM:TIME():SVM:WHO:AM
END
IF KEY.CN < 5 THEN RQM; RQM; RQM
REPEAT; * for next KEY processing
*#
!
*#
IF SYS.PROG.STATUS = 'STOP' THEN
GOSUB ERROR.RTN
PRINT @(0,20):CLL:'There has been an error in reading the file.'
PRINT @(0,21):CLL:'Should I continue processing? ':; INPUT A$
IF INDEX('*Y*y*Yes*yes*','*':A$:'*',1) # 0 THEN
SYS.PROG.STATUS = 'IN.PROGRESS-RESUMED'
KEY.CN = KEY.CN - 1
*GOTO Loop.return.point
END
END
IF E.CAL2 # '' THEN
E.CALL = E.CAL2
E.KEYC = E.KEY2
E.CAL2 = ''
END
*GOTO Second.pass.return.point
*NEXT PASS
IF SYS.PROG.STATUS EQ "STOP" THEN
*
END
*WHILE SYS.PROG.STAT NE "STOP" AND NOT(SYS.ABORT OR USER.ABORT) DO REPEAT
NEXT PASS
GOTO End.of.program
!
*
*
*
INPUT.FILE.NAME: *@* FILE INPUT SUBROUTINE
*
LOOP
PRINT CLL:'What file contains the data? ':
INPUT FILE.NAME:
WHILE FILE.NAME EQ '' DO REPEAT
RETURN
*
*
*
ERROR.RTN: *@* ERROR HANDLING
PRINT CLL:BELL:'Error ':ERROR:'.':
RQM; RQM
RQM; RQM
RETURN
*
End.of.program: *
MATWRITE KEY.LIST ON LIST.FILE,KEY.LIST.NAME
WRITE KEY.COMM.LIST ON LIST.FILE,KEY.LIST.NAME:"@REJECTED"
IF SYS.RUNT EQ "E" THEN
PRINTER ON
PRINT 
PRINT STR("*",70)
PRINT 
PRINT 
PRINT "Number of items processed: ":KEY.CN
PRINT "Number of invalid items  : ":KEY.RJT.CN
PRINT OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
PRINT 
PRINT 
PRINT "End of execptions report."
PRINT 
PRINTER OFF
END
PRINTER CLOSE
EXECUTE "SP-ASSIGN "
END
*
END
~CONTACT.SUB.LABEL.RTN~
SUBROUTINE CONTACT.SUB.LABEL.RTN
*SUBROUTINE: CONTACT.SUB.LABEL.RTN
*
$INCLUDE IBP CG.COMMON.VARIABLES
*#
$INCLUDE IBP CG.COMMON.FUNCTIONS
*#
*#    Initialization
*#
*#          Arrays
*DIM LNVL(10)
MAT LNVL = ""
*#
*#          System Variables
SYS.PROG = "CONTACT.SUB.LABEL.RTN":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "VAR":AM:SYS.SLOC
SYS.PROG.DESC = "Label Printing"
*#
*#          Label Control Variables
LBL.CN = 0
*
LBL.HORZ  = FIELD(SYS.FORMAT,"x",1)
IF NOT(NUM(LBL.HORZ)) THEN LBL.HORZ = 1
*
LBL.LINES = FIELD(SYS.FORMAT,"x",2)
IF NOT(NUM(LBL.LINES)) THEN LBL.LINES = 6
IF LBL.LINES < 1 THEN LBL.LINES = 6
*
LBL.WDTH = "L#":FIELD(SYS.FORMAT,"x",3)
*
LBL.SPACING = FIELD(SYS.FORMAT,"x",4)
*#
*#    Open Files
*#
*#SYS.LOCT<1> = "OPEN"
*#SYS.SLOC<1> = "CODES"
*#OPEN "CODES" TO CODES.FILE ELSE
*#SYS.PROG.STATUS = "SKIP"
*#RETURN
*#END
*#
SYS.LOCT<1> = "INIT"
SYS.SLOC<1> ="LP.ALIGN"
IF LBL.PR.CN < 1 THEN
*SP.RESULT = ""
*EXECUTE "SP-ASSIGN I R1", //OUT. > SP.RESULT
*IF LEN(SP.RESULT) > 1 THEN PRINT "SP.RESULT: ":SP.RESULT:". Enter <CR>.":; INPUT A$:
MAT LNVL = STR("X",35)
LNVL(LBL.LINES) = ""
MAT PRVL = ""
PRINT @(0,5):CLS:@(10,6):SYS.PROG.DESC:
PRINT @(0,8):CLL:"Mount labels on printer and enter <CR> ":
INPUT A$:
CN = 0; RSP = "N"
LOOP
SYS.SLOC<1> = "LP.ALIGN.INCR"
CN = CN + 1
SYS.SLOC<1> = "LP.ALIGN.COND"
WHILE RSP # "Y" DO
SYS.SLOC<1> =  "LP.ALIGN"
GOSUB Pr.rtn
PRINT @(0,8):CLL:"Is alignment correct? ":
INPUT RSP:
IF INDEX("*Y*YES*y*yes*Yes*","*":RSP:"*",1) # 0 THEN RSP = "Y" ELSE
PRINT @(10,10):CLL:"Enter the number of line to shift printing or":
PRINT @(10,11):CLL:"align labels and enter <CR>. I will print another mask. ":
INPUT MSK.LN:
IF LEN(MSK.LN) = 0 THEN MSK.LN = "GO TEAM"
IF NUM(MSK.LN) THEN
PRINTER ON
FOR A = 1 TO (LBL.LINES+MSK.LN)
PRINT ON 2 "<"
NEXT A
PRINTER OFF
END
END
REPEAT
END
SYS.LOCT<1> = "CYCLE"
SYS.SLOC<1> = "INIT"
CN = 0
LOOP
SYS.SLOC<1> = "LOCATE.INCR"
KEY.LNVL = 1
MAT LNVL = ""
CN = CN + 1
SYS.SLOC<1> = "LOCATE.COND"
WHILE ENTITY.REC(3)<1,CN> # 'MAIL' AND ENTITY.REC(3)<1,CN> NE '' DO REPEAT
*#
*#
SYS.MV.TYPE = "MAIL"
LOOP
SYS.SLOC<1> = "LBL.TO.PRINT.INCR"
LBL.CN = LBL.CN + 1
SYS.SLOC<1> = "LBL.TO.PRINT.COND"
WHILE LBL.CN <= LBL.TO.PRINT AND SYS.PROG.STATUS NE "STOP" AND SYS.PROG.STATUS NE "SKIP" DO
SYS.SLOC<1> = "VL.MV.TYPE"
IF ENTITY.REC(3)<1,CN> = 'MAIL' THEN
SYS.SLOC<1> = "VL.MAIL.ADDRESS"
*#
*#    Attention
IF ENTITY.REC(14)<1,CN> # '' THEN
SYS.ITEM = ENTITY.REC(14)<1,CN>
IF LEN(SYS.ITEM) EQ 2 THEN
LOCATE(SYS.ITEM,ENTITY.REC(18),1;LOC) THEN
LNVL(KEY.LNVL) = ENTITY.REC(17)<1,LOC>
END ELSE
SYS.FILE = 'CODES'
READV PRIMARY.CONTACT FROM CODES.FILE,'040@':SYS.ITEM,1 THEN
LNVL(KEY.LNVL) = PRIMARY.CONTACT
END ELSE
*ERROR
CALL.COMM = CALL.COMM:AM:'Primary Contact Title/Postion Code Missing from CODES file'
SYS.PROG.STATUS = "WARNING"
END
*#
END; *# of indexed the position to a person
*#
*# attention is text
END ELSE
LNVL(KEY.LNVL) = ENTITY.REC(14)<1,CN>
*#
END; *#   of attn is text
*#
END; *#  of attn present
KEY.LNVL = KEY.LNVL + 1
*#
*#    Entity being addressed
LNVL(KEY.LNVL) = EI.KEY.VL
KEY.LNVL = KEY.LNVL + 1
*#
*#    Appartment number
SYS.SLOC<1> = "VL.APPT"
IF ENTITY.REC(4)<1,CN> # '' THEN LNVL(KEY.LNVL) = '# ':ENTITY.REC(4)<1,CN>:' - '
*#
*#    House number
SYS.SLOC<1> = "VL.ADDRESS"
IF ENTITY.REC(5)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Street address missing on ':EI.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(5)<1,CN>:' '
*#
*#    Street name
SYS.SLOC<1> = "VL.STREET"
IF ENTITY.REC(6)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Street name missing on ':EI.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(6)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
END
*#
*#    Extra line of address
SYS.SLOC<1> = "VL.COUNTY"
IF ENTITY.REC(7)<1,CN> # '' & ENTITY.REC(7)<1,CN> # ' ' THEN
LNVL(KEY.LNVL) = ENTITY.REC(7)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
*#
*#    City name
SYS.SLOC<1> = "VL.CITY"
IF ENTITY.REC(8)<1,CN> = '' THEN
SYS.PROG.STATUS = "SKIP"
CALL.COMM=CALL.COMM:AM:'City missing on ':EI.KEY.VL
*#
*#    Read City Master record
END ELSE
*#
SYS.SLOC<1> = "READ.CITY"
READV CITY FROM CODES.FILE,'030@':ENTITY.REC(8)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):CITY:', '
*#
SYS.SLOC<1> = "VL.PROV"
IF ENTITY.REC(9)<1,CN> = '' THEN
SYS.PROG.STATUS = "SKIP"
CALL.COMM=CALL.COMM:AM:'Province missing on ':EI.KEY.VL
END ELSE
*#
SYS.SLOC<1> = "READ.PROV"
READV PROV FROM CODES.FILE,'020@':ENTITY.REC(9)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):PROV
KEY.LNVL = KEY.LNVL + 1
END ELSE
SYS.PROG.STATUS = "SKIP"
CALL.COMM=CALL.COMM:AM:'Province master record missing on ':EI.KEY.VL
END
END
*#
*#    City master missing
END ELSE
SYS.PROG.STATUS = "SKIP"
CALL.COMM=CALL.COMM:AM:'City master record missing on ':EI.KEY.VL
END
END
*
SYS.SLOC<1> = "PCODE"
IF ENTITY.REC(11)<1,CN> = '' THEN
SYS.PROG.STATUS = "SKIP"
CALL.COMM=CALL.COMM:AM:'Postal code missing on ':EI.KEY.VL
END ELSE
LNVL(KEY.LNVL) = ENTITY.REC(11)<1,CN>
END
*
SYS.SLOC<1> = "VL.LBL"
IF KEY.LNVL GT 5 THEN
SYS.PROG.STATUS = "SKIP"
CALL.COMM=CALL.COMM:AM:"Maximum number of lines for a label execeeded at ":LBL.CN:"."
CALL.COMM=CALL.COMM:AM:"( ":KEY.LNVL:" lines present on ":EI.KEY.VL:"."
MAT LNVL = ""
END
IF SYS.PROG.STATUS NE "STOP" AND SYS.PROG.STATUS NE "SKIP" THEN
GOSUB Pr.rtn
END
END
REPEAT; * FOR STATUS OK AND LBL.CN < LBL.TO.PRINT
*#
*#
LBL.PR.CN = LBL.PR.CN + 1
LOOP WHILE CALL.COMM[1,1] = AM DO CALL.COMM=CALL.COMM[2,999] REPEAT
*
*
*#          Clear System Variables
SYS.PROG = DELETE(SYS.PROG,1,0,0)
SYS.LOCT = DELETE(SYS.LOCT,1,0,0)
SYS.SLOC = DELETE(SYS.SLOC,1,0,0)
*
RETURN
!
*
Po.box: *#*
*
SYS.SLOC<1> = "P.O.BOX"
LNVL(KEY.LNVL) = ''
IF ENTITY.REC(12)<1,CN> = '' THEN
IF LEN(ENTITY.REC(13)<1,CN>) > 1 THEN
IF SYS.PROG.STATUS EQ "" THEN SYS.PROG.STATUS = "WARNING"
END ELSE
SYS.PROG.STATUS = "SKIP"
END
CALL.COMM=CALL.COMM:AM:"** Warning ** P.O. Box missing on ":EI.KEY.VL
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(11)<1,CN>:" "
*
IF ENTITY.REC(13)<1,CN> = "" THEN
IF SYS.PROG.STATUS EQ "" THEN SYS.PROG.STATUS = "WARNING"
CALL.COMM=CALL.COMM:AM:"** Warning ** Station missing from P O Box on ":EI.KEY.VL
END ELSE LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(12)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
RETURN
!
*
Pr.rtn: *#*
SYS.SLOC<1> = "PRINTING"
IF HORZ.CN GE LBL.HORZ OR FINISHED OR SYS.PROG.STATUS EQ "SKIP" OR SYS.PROG.STATUS = "STOP" THEN
PRINTER ON
*IF SYS.FORMAT[1,4] EQ "1x6x" THEN
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE CN2 LE LBL.LINES DO
IF SYS.PROG.STATUS NE "SKIP" AND SYS.PROG.STATUS NE "STOP" THEN
PRINT ON 2 PRVL(CN2)
END ELSE
*PRINT ON 1 LNVL(CN2)
END
REPEAT
MAT PRVL = ""
HORZ.CN = 0
*END ELSE IF SYS.FORMAT EQ "DUMMYxDUMMYxDUMMY" THEN
*PRINT @(40,23):"Print label" "L#20":
*END ELSE
*SYS.PROG.STATUS = "STOP"
*END
PRINTER OFF
END
IF NOT(FINISHED) AND SYS.PROG.STATUS NE "SKIP" AND SYS.PROG.STATUS NE "STOP" THEN
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE CN2 LE LBL.LINES DO
PRVL(CN2) = PRVL(CN2):LNVL(CN2) LBL.WDTH:SPACE(LBL.SPACING)
REPEAT
MAT LNVL = ""
HORZ.CN = HORZ.CN + 1
END
RETURN
*
END
~CONTACT.SUB.PDLIST.RTN~
SUBROUTINE CONTACT.SUB.PDLIST.RTN
*SUBROUTINE: CONTACT.SUB.PDLIST.RTN
*
$INCLUDE IBP CG.COMMON.VARIABLES
*#
$INCLUDE IBP CG.COMMON.FUNCTIONS
*#
*#    Initialization
*#
*#          Arrays
*DIM LNVL(10)
MAT LNVL = ""
*#
*#          System Variables
SYS.PROG = "CONTACT.SUB.PDLIST.RTN":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "VAR":AM:SYS.SLOC
SYS.PROG.DESC = "Prospect List Printing"
*#
*#          Prospect List Control Variables
PRP.CN = 0
SYS.LABEL = FIELD(SYS.FORMAT,"#",1)
SYS.FORM  = FIELD(SYS.FORMAT,"#",2)
SYS.RUNT  = FIELD(SYS.FORMAT,"#",4)
*
*
PRP.HORZ  = FIELD(SYS.LABEL,"x",1)
IF NOT(NUM(PRP.HORZ)) THEN PRP.HORZ = 1
*
PRP.LINES = FIELD(SYS.LABEL,"x",2)
IF NOT(NUM(PRP.LINES)) THEN PRP.LINES = 6
IF PRP.LINES < 1 THEN PRP.LINES = 6
*
PRP.WDTH = FIELD(SYS.LABEL,"x",3)
*
PRP.SPACING = FIELD(SYS.LABEL,"x",4)
*
*
*
FRM.HORZ  = FIELD(SYS.FORM,"x",1)
IF NOT(NUM(FRM.HORZ)) THEN FRM.HORZ = 1
*
FRM.LINES = FIELD(SYS.FORM,"x",2)
IF NOT(NUM(FRM.LINES)) THEN FRM.LINES = 6
IF FRM.LINES < 1 THEN FRM.LINES = 6
*
FRM.WDTH = FIELD(SYS.FORM,"x",3)
*
FRM.SPACING = FIELD(SYS.FORM,"x",4)
*
NEW.PAGE = ''
PRSP.EXCEPTIONS = ''
*#
*#    Open Files
*#
*#SYS.LOCT<1> = "OPEN"
*#SYS.SLOC<1> = "CODES"
*#OPEN "CODES" TO CODES.FILE ELSE
*#SYS.PROG.STATUS = "ERROR"
*#RETURN
*#END
*#
SYS.LOCT<1> = "INIT"
SYS.SLOC<1> ="LP.ALIGN"
IF LBL.PR.CN < 1 THEN
*SP.RESULT = ""
*EXECUTE "SP-ASSIGN I R1", //OUT. > SP.RESULT
*IF LEN(SP.RESULT) > 1 THEN PRINT "SP.RESULT: ":SP.RESULT:". Enter <CR>.":; INPUT A$:
MAT LNVL = STR("X",35)
LNVL(PRP.LINES) = ""
MAT PRVL = ""
PRINT @(0,5):CLS:@(10,6):SYS.PROG.DESC:
PRINT @(0,8):CLL:"Mount stock tab paper on printer and enter <CR> ":
INPUT A$:
CN = 0; RSP = "N"
LOOP
SYS.SLOC<1> = "LP.ALIGN.INCR"
CN = CN + 1
SYS.SLOC<1> = "LP.ALIGN.COND"
WHILE RSP # "Y" DO
SYS.SLOC<1> =  "LP.ALIGN"
GOSUB Pr.rtn
PRINT @(0,8):CLL:"Is alignment correct? ":
INPUT RSP:
IF INDEX("*Y*YES*y*yes*Yes*","*":RSP:"*",1) # 0 THEN RSP = "Y" ELSE
PRINT @(10,10):CLL:"Enter the number of line to shift printing or":
PRINT @(10,11):CLL:"align labels and enter <CR>. I will print another mask. ":
INPUT MSK.LN:
IF LEN(MSK.LN) = 0 THEN MSK.LN = "GO TEAM"
IF NUM(MSK.LN) THEN
PRINTER ON
FOR A = 1 TO (PRP.LINES+MSK.LN)
PRINT "<"
NEXT A
PRINTER OFF
END
END
REPEAT
END
SYS.LOCT<1> = "CYCLE"
SYS.SLOC<1> = "INIT"
CN = 0
LOOP
SYS.SLOC<1> = "LOCATE.INCR"
KEY.LNVL = 1
MAT LNVL = ""
CN = CN + 1
SYS.SLOC<1> = "LOCATE.COND"
WHILE ENTITY.REC(3)<1,CN> # 'MAIL' AND ENTITY.REC(3)<1,CN> NE '' DO REPEAT
*#
*#
SYS.MV.TYPE = "MAIL"
LOOP
SYS.SLOC<1> = "LBL.TO.PRINT.INCR"
PRP.CN = PRP.CN + 1
SYS.SLOC<1> = "LBL.TO.PRINT.COND"
WHILE PRP.CN <= LBL.TO.PRINT AND SYS.PROG.STATUS NE "STOP" AND SYS.PROG.STATUS NE "ERROR" DO
*
SYS.SLOC<1> = "VL.MV.ETYPE"
LOCATE('PRSP',ENTITY.REC(1),1;NEW.PAGE) ELSE NEW.PAGE = ''
IF NOT(NEW.PAGE) THEN
LOCATE('CLNT',ENTITY.REC(1),1;NEW.PAGE) ELSE NEW.PAGE = ''
END
*
SYS.SLOC<1> = "VL.MV.TYPE"
IF ENTITY.REC(3)<1,CN> = 'MAIL' THEN
SYS.SLOC<1> = "VL.MAIL.ADDRESS"
*#
*#    Attention
IF ENTITY.REC(14)<1,CN> # '' THEN
SYS.ITEM = ENTITY.REC(14)<1,CN>
IF LEN(SYS.ITEM) EQ 2 THEN
LOCATE(SYS.ITEM,ENTITY.REC(18),1;LOC) THEN TEMP = 1 ELSE TEMP = ""
IF TEMP THEN
LNVL(KEY.LNVL) = ENTITY.REC(17)<1,LOC>
END ELSE
SYS.FILE = 'CODES'
READV PRIMARY.CONTACT FROM CODES.FILE,'040@':SYS.ITEM,1 THEN
LNVL(KEY.LNVL) = PRIMARY.CONTACT
END ELSE
*ERROR
PRSP.EXCEPTIONS = PRSP.EXCEPTIONS:AM:'Primary Contact Title/Postion Code Missing from CODES file'
SYS.PROG.STATUS = "WARNING"
END
*#
END; *# of indexed the position to a person
*#
*# attention is text
END ELSE
LNVL(KEY.LNVL) = ENTITY.REC(14)<1,CN>
*#
END; *#   of attn is text
*#
END; *#  of attn present
KEY.LNVL = KEY.LNVL + 1
*#
*#    Entity being addressed
LNVL(KEY.LNVL) = EI.KEY.VL
IF LBL.ALPHA NE EI.KEY.VL[1,1] THEN
HORZ.CN = PRP.HORZ + 1
NEW.PAGE = 1
LBL.ALPHA = EI.KEY.VL[1,1]
END
KEY.LNVL = KEY.LNVL + 1
*#
*#    Appartment number
SYS.SLOC<1> = "VL.APPT"
IF ENTITY.REC(4)<1,CN> # '' THEN LNVL(KEY.LNVL) = '# ':ENTITY.REC(4)<1,CN>:' - '
*#
*#    House number
SYS.SLOC<1> = "VL.ADDRESS"
IF ENTITY.REC(5)<1,CN> = '' THEN
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:'Street address missing on ':EI.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(5)<1,CN>:' '
*#
*#    Street name
SYS.SLOC<1> = "VL.STREET"
IF ENTITY.REC(6)<1,CN> = '' THEN
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:'Street name missing on ':EI.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(6)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
END
*#
*#    Extra line of address
SYS.SLOC<1> = "VL.COUNTY"
IF ENTITY.REC(7)<1,CN> # '' & ENTITY.REC(7)<1,CN> # ' ' THEN
LNVL(KEY.LNVL) = ENTITY.REC(7)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
*#
*#    City name
SYS.SLOC<1> = "VL.CITY"
IF ENTITY.REC(8)<1,CN> = '' THEN
SYS.PROG.STATUS = "ERROR"
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:'City missing on ':EI.KEY.VL
*#
*#    Read City Master record
END ELSE
*#
SYS.SLOC<1> = "READ.CITY"
READV CITY FROM CODES.FILE,'030@':ENTITY.REC(8)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):CITY:', '
*#
SYS.SLOC<1> = "VL.PROV"
IF ENTITY.REC(9)<1,CN> = '' THEN
SYS.PROG.STATUS = "ERROR"
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:'Province missing on ':EI.KEY.VL
END ELSE
*#
SYS.SLOC<1> = "READ.PROV"
READV PROV FROM CODES.FILE,'020@':ENTITY.REC(9)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):PROV
KEY.LNVL = KEY.LNVL + 1
END ELSE
SYS.PROG.STATUS = "ERROR"
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:'Province master record missing on ':EI.KEY.VL
END
END
*#
*#    City master missing
END ELSE
SYS.PROG.STATUS = "ERROR"
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:'City master record missing on ':EI.KEY.VL
END
END
*
SYS.SLOC<1> = "PCODE"
IF ENTITY.REC(11)<1,CN> = '' THEN
SYS.PROG.STATUS = "ERROR"
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:'Postal code missing on ':EI.KEY.VL
END ELSE
LNVL(KEY.LNVL) = ENTITY.REC(11)<1,CN>
END
*
SYS.SLOC<1> = "VL.PRP"
IF KEY.LNVL GT 5 THEN
SYS.PROG.STATUS = "ERROR"
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:"Maximum number of lines for a label execeeded at ":PRP.CN:"."
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:"( ":KEY.LNVL:" lines present on ":EI.KEY.VL:"."
MAT LNVL = ""
END
*
*
*
* PERSONEL XREF & COMMUN
IF ENTITY.REC(17) NE '' THEN
CN = PRP.LINES
CN1 = 1
LOOP WHILE ENTITY.REC(17)<1,CN1> NE '' DO
CN = CN + 1
PRP.LINES = PRP.LINES + 1
IF CN1 EQ 1 THEN
LNVL(CN) = "Staff: "
END ELSE
LNVL(CN) = "     : "
END
LNVL(CN) = LNVL(CN):ENTITY.REC(17)<1,CN1>:"  -  ":ENTITY.REC(18)<1,CN1>:"  [CNTC> ":ENTITY.REC(19)<1,CN1>
CN1 = CN1 + 1
REPEAT
IF CN1 > 1 THEN PRP.LINES = PRP.LINES + 2
END
*
*
* COMMUNICATION DATA
IF ENTITY.REC(15) NE '' THEN
CN = PRP.LINES
CN1 = 1
LOOP WHILE ENTITY.REC(15)<1,CN1> NE '' DO
CN = CN + 1
PRP.LINES = PRP.LINES + 1
IF CN1 EQ 1 THEN
LNVL(CN) = "Phone: "
END ELSE
LNVL(CN) = "     : "
END
LNVL(CN) = LNVL(CN):"(":ENTITY.REC(15)<1,CN1,1>:") ":ENTITY.REC(15)<1,CN1,2>:"   ":ENTITY.REC(15)<1,CN1,3>
CN1 = CN1 + 1
REPEAT
IF CN1 > 1 THEN PRP.LINES = PRP.LINES + 1
END
*
*
*
* ENTITY TYPE DESCRIPTORS
IF ENTITY.REC(1) NE '' THEN
CN = PRP.LINES
CN1 = 1
LOOP WHILE ENTITY.REC(1)<1,CN1> NE '' DO
IF ENTITY.REC(1)<1,CN1> EQ "PRSP" THEN NEW.PAGE = 1
CN = CN + 1
PRP.LINES = PRP.LINES + 1
IF CN1 EQ 1 THEN
LNVL(CN) = "TYPE: "
END ELSE
LNVL(CN) = "    : "
END
READV ETDESC FROM CODES.FILE,'100@':ENTITY.REC(1)<1,CN1>,1 ELSE ETDESC = ''
LNVL(CN) = LNVL(CN):ENTITY.REC(1)<1,CN1>:SPACE(5-LEN(ENTITY.REC(1)<1,CN1>)):" ":ETDESC
CN1 = CN1 + 1
REPEAT
IF CN1 > 1 THEN PRP.LINES = PRP.LINES + 1
END
*
*
* COMMENTS FOR COMPANY
IF ENTITY.REC(16) NE '' THEN
CN = PRP.LINES
CN1 = 1
LOOP WHILE ENTITY.REC(16)<1,CN1> NE '' DO
CN = CN + 1
PRP.LINES = PRP.LINES + 1
IF CN1 EQ 1 THEN
LNVL(CN) = "> "
END ELSE
LNVL(CN) = "> "
END
LNVL(CN) = LNVL(CN):ENTITY.REC(16)<1,CN1>
CN1 = CN1 + 1
REPEAT
IF CN1 > 1 THEN PRP.LINES = PRP.LINES + 2
END
*
* ?? HOW BIG ??
IF PRP.LINES > 25 THEN NEW.PAGE = 1
*
*
* Warning Messages
IF PRSP.EXCEPTIONS NE '' THEN
CN = PRP.LINES
LOOP WHILE LEN(PRSP.EXCEPTIONS) DO
CN = CN + 1
PRP.LINES = PRP.LINES + 1
LNVL(CN) = PRSP.EXCEPTIONS<1>
PRSP.EXCEPTIONS = DELETE(PRSP.EXCEPTIONS,1)
REPEAT
END
*
IF SYS.PROG.STATUS NE "STOP" AND SYS.PROG.STATUS NE "SKIP" THEN
LBL.PR.CN = LBL.PR.CN + 1
IF LBL.PR.CN - INT(LBL.PR.CN / 3) * 3 = 0 THEN NEW.PAGE = 1
GOSUB Pr.rtn
END
END
REPEAT; * FOR STATUS OK AND PRP.CN < LBL.TO.PRINT
*#
*#
*LBL.PR.CN = LBL.PR.CN + 1
LOOP WHILE CALL.COMM[1,1] = AM DO CALL.COMM=CALL.COMM[2,9999] REPEAT
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
*
RETURN
!
*
Po.box: *#*
*
SYS.SLOC<1> = "P.O.BOX"
LNVL(KEY.LNVL) = ''
IF ENTITY.REC(12)<1,CN> = '' THEN
IF LEN(ENTITY.REC(13)<1,CN>) > 1 THEN
IF SYS.PROG.STATUS EQ "" THEN SYS.PROG.STATUS = "WARNING"
END ELSE
SYS.PROG.STATUS = "ERROR"
END
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:"** Warning ** P.O. Box missing on ":EI.KEY.VL
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(11)<1,CN>:" "
*
IF ENTITY.REC(13)<1,CN> = "" THEN
IF SYS.PROG.STATUS EQ "" THEN SYS.PROG.STATUS = "WARNING"
PRSP.EXCEPTIONS=PRSP.EXCEPTIONS:AM:"** Warning ** Station missing from P O Box on ":EI.KEY.VL
END ELSE LNVL(KEY.LNVL) = LNVL(KEY.LNVL):ENTITY.REC(12)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
RETURN
!
*
Pr.rtn: *#*
SYS.SLOC<1> = "PRINTING"
IF HORZ.CN GE PRP.HORZ OR FINISHED OR SYS.PROG.STATUS EQ "SKIP" OR SYS.PROG.STATUS = "STOP" OR NEW.PAGE THEN
PRINTER ON
*IF SYS.LABEL[1,4] EQ "1x6x" THEN
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE CN2 LE PRP.LINES OR CN2 LE FRM.LINES DO
IF SYS.PROG.STATUS NE "SKIP" AND SYS.PROG.STATUS NE "STOP"  OR PRVL(CN2):PRVL(CN2+1) NE "" THEN
IF SYS.RUNT NE "E" THEN PRINT PRVL(CN2)
END ELSE
IF SYS.RUNT EQ "E" THEN PRINT LNVL(CN2)
END
REPEAT
MAT PRVL = ""
HORZ.CN = 0
*END ELSE IF SYS.LABEL EQ "DUMMYxDUMMYxDUMMY" THEN
*PRINT @(40,23):"Print label" "L#20":
*END ELSE
*SYS.PROG.STATUS = "STOP"
*END
PRINTER OFF
IF NEW.PAGE THEN
PRINTER ON
IF SYS.PROG.STATUS NE "SKIP" AND SYS.PROG.STATUS NE "STOP" THEN
IF SYS.RUNT NE "E" THEN PRINT FF:
END ELSE
IF SYS.RUNT EQ "E" THEN PRINT FF:
END
PRINTER OFF
NEW.PAGE = ''
END
END
IF NOT(FINISHED) AND SYS.PROG.STATUS NE "SKIP" AND SYS.PROG.STATUS NE "STOP" THEN
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE CN2 LE PRP.LINES OR CN2 LE FRM.LINES DO
TEMP = PRP.WDTH
TEMP2 = PRP.SPACING
TEMP3 = FRM.WDTH
IF LEN(LNVL(CN2)) > PRP.WDTH THEN
TEMP = LEN(LNVL(CN2)) + 1
TEMP2 = TEMP2 + PRP.WDTH - TEMP
IF TEMP2 < 0 THEN TEMP2 = 0
TEMP3 = TEMP3 + PRP.WDTH - TEMP + PRP.SPACING - TEMP2
END
TEMP1 = "L#":TEMP
TEMP4 = "L#":TEMP3
PRVL(CN2) = PRVL(CN2):LNVL(CN2) TEMP1:SPACE(TEMP2):FORM(CN2)[FRM.WDTH-TEMP3-1,999] TEMP4:SPACE(FRM.SPACING)
REPEAT
MAT LNVL = ""
HORZ.CN = HORZ.CN + 1
END
RETURN
*
END
~CONTACT.TRANS~
SUBROUTINE CONTACT.TRANS(CT.KEY,CT.SOURCE,CT.FILE,CTC.ERROR,CTC.ACTION,CT.UPDATE)
*SUBROUTINE: CONTACT.TRANS
*
*
* DESC: CONTRACT TRANSACTIONS SUBPROGRAM
*
*                                  PH: 254-9889
*                                  VAN., B.C.
*
*
* 
$INCLUDE IBP STANDARD.FUNCTIONS
* 
* 
$INCLUDE IBP CTC.DIM
*$INCLUDE IBP CTC.EQUATES
* 
*CUSTOM*START
CTC.NAME.ACCESS = '18&20&22&24&26&28&30&32&34&36&'
DIM CTC.SEQN.LOCT(22)
DIM CTC.DETL.LOCT(22)
MAT CTC.SEQN.LOCT = 0
MAT CTC.DETL.LOCT = 0
DIM CTC.ERR.MSG(20)
DIM CTC.PROG.LOCT(20)
CALL SUB.INIT.TABLES.CT (MAT CTC.ERR.MSG,MAT CTC.PROG.LOCT)
CTC.LOCT.NUMB = 1
CTC.VISITOR = 'Y'
*
OPEN CT.FILE TO CTC.FILE ELSE
CTC.ERR = 14
GOSUB CTC.ERR.DISP
CTC.ERR = 20
CTC.ERR.MSG(20) = 'The missing file is ':CT.FILE:'. Service is required.'
GOSUB CTC.ERR.DISP
RETURN
END
*
CTC.LOCT.NUMB = 2
MIN.LINE = 12; MAX.LINE = 21
MAT CTC.SEQN.LOCT = 0
MAT CTC.DETL.LOCT = 0
MAT CTC = ''
MAX.FLD = 5
CTC.CONTACT = ''
FUNC.TYPE = 'N'; FUNC.SEQ = 0; FUNC.DET = 0
CTC.NEW = ''; CURR.LINE = MIN.LINE+1
CTC.DETL = 'PRINT.MORE'
CTC.RECD.STAT = 'DISP.RECD'
CTC.REPL.FIELD = 'END'
CT.ACTION = 1
CT.ERROR = 0
CT.UPDATE = ''
CTC.SEQN = 0
CT.CALL = 'CTC.ID.':CT.SOURCE
CALL @CT.CALL (CT.KEY,CTC.ID,CTC.CONTACT,FUNC.TYPE,FUNC.SEQ,CTC.RECD.STAT,CTC.DETL,CTC.SEQN,CT.ERROR,CT.ACTION,CT.UPDATE)
IF CT.ERROR # 0 THEN
CTC.ERR=12
GOSUB CTC.ERR.DISP
CTC.ERR = 20
CTC.ERR.MSG(20) = 'The error number was ':CT.ERROR:'.'
GOSUB CTC.ERR.DISP
CTC.ERR.MSG(20) = 'The key that was returned to me was ':CTC.ID:'.'
GOSUB CTC.ERR.DISP
END
CURR.LINE = MIN.LINE+1
CTC.SEQN = 0
GOSUB CTC.FIND.KEY
CTC.LOCT.NUMB = 2
CTC.SEQN = 0
GOSUB CTC.DISP.HEADING
CTC.LOCT.NUMB = 3
LOOP WHILE CTC.RECD.STAT # 'UPDATE.RECD' DO
IF FUNC.SEQ = 0 & CTC.SEQN = 0 & FUNC.TYPE # 'A' THEN FUNC.TYPE = 'B'
IF FUNC.TYPE = 'B' THEN
FUNC.SEQ = 0; CTC.SEQN = 0
FUNC.DET = 0
FUNC.TYPE = 'N'
GOSUB CTC.CLEAR
CTC.LOCT.NUMB = 8
CTC.RECD.STAT = 'DISP.RECD'
END
IF (FUNC.TYPE = 'A' & FUNC.SEQ = 0) THEN
FLD.NUM = 0; CTC.REPL.FIELD = ''
GOSUB CTC.CLEAR
CTC.LOCT.NUMB = 3
END
LOOP
IF CTC.RECD.STAT = 'DISP.RECD' & FUNC.TYPE # 'A' THEN
GOSUB CTC.READ.NEXT
CTC.LOCT.NUMB = 8
IF CTC.RECD.STAT = 'LAST.RECD' THEN
CTC.DETL = 'CHOOSE.ACTION'
CTC.REPL.FIELD = 'END'
END
END
WHILE CTC.REPL.FIELD # 'END' ! CTC.DETL # 'CHOOSE.ACTION' DO
IF CTC.DETL = 'PAGE.FULL' THEN
IF FUNC.TYPE = 'A' THEN
GOSUB CTC.ENTER.CR
CTC.LOCT.NUMB = 3
END ELSE
CTC.INPUT = 'N'
PRINT @(0,22):CLL:'(B)eginning, <CR> = (N)ext page, or E to stop:'
INPUT @(67,22):CTC.INPUT
IF CTC.INPUT = 'END' THEN CTC.INPUT = 'E'
IF CTC.INPUT = '' THEN CTC.INPUT = 'N'
END
IF CTC.INPUT = 'N' ! CTC.INPUT = 'B' THEN
MIN.LINE = 6
GOSUB CTC.CLEAR
CTC.LOCT.NUMB = 8
IF FUNC.TYPE = '' ! FUNC.TYPE = 'N' THEN FUNC.TYPE = 'N'
IF FUNC.TYPE = 'A' THEN CTC.DETL = 'INPUT.MORE' ELSE CTC.DETL = 'PRINT.MORE'
IF CTC.INPUT = 'B' THEN CTC.SEQN = 0; GOSUB CTC.READ.NEXT
END ELSE
CTC.DETL = 'CHOOSE.ACTION'
CTC.REPL.FIELD = 'END'
END
END
IF CTC.REPL.FIELD # 'END' ! CTC.DETL # 'CHOOSE.ACTION' THEN
FLD.NUM = 1
IF CTC.RECD.STAT # 'HOLD.KEY' THEN GOSUB CTC.DISP.KEY
IF CTC.REPL.FIELD = 'END' & FUNC.TYPE = 'A' THEN
CTC.DETL = 'CHOOSE.ACTION'
CTC.RECD.STAT = 'LAST.RECD'
END
IF CTC.REPL.FIELD # 'END' ! CTC.DETL # 'CHOOSE.ACTION' THEN
FLD.NUM = 5
IF CTC.RECD.STAT # 'HOLD.RECD' THEN
GOSUB CTC.DISP.RECD
CTC.LOCT.NUMB = 3
IF CTC.REPL.FIELD # 'END' & CTC.DETL # 'PAGE.FULL' & FUNC.TYPE = 'A' THEN
GOSUB CTC.UPDATE
CTC.LOCT.NUMB = 3
END ELSE
IF CTC.REPL.FIELD = 'END' & FUNC.TYPE='A' THEN
PRINT @(0,CURR.LINE):CLL:
END
END
END
END ELSE
IF CTC.REPL.FIELD = 'END' & FUNC.TYPE='A' THEN
PRINT @(0,CURR.LINE):CLL:
END
END
IF CTC.REPL.FIELD = 'END' & FUNC.TYPE = 'A' THEN
CTC.DETL = 'CHOOSE.ACTION'
CTC.RECD.STAT = 'LAST.RECD'
END
END
REPEAT
GOSUB CTC.CHANGES
CTC.LOCT.NUMB = 3
REPEAT
RETURN
*
INPUT.FLD: *#*
*
CTC.LOCT.NUMB = 4
PROG.SUB.NAME = 'Input the Field'
PRINT @(0,22):CLL:PROG.SUB.NAME:
*
I.top: IF FLD.NUM<1 THEN FLD.NUM = 1
CURR.COLM = 0
IF FLD.NUM = 1 THEN CURR.COLM = 9 ELSE
IF FLD.NUM = 2 THEN CURR.COLM = 18 ELSE
IF FLD.NUM = 3 THEN CURR.COLM = 27 ELSE
IF FLD.NUM = 4 THEN CURR.COLM = 38 ELSE
IF FLD.NUM = 5 THEN CURR.COLM = 9 ELSE
CTC.ERR = 4
GOSUB CTC.ERR.DISP
CTC.LOCT.NUMB = 4
FLD.NUM = 3
GOTO I.top
END
END
END
END
END
PRINT @(CURR.COLM,CURR.LINE):RVB:SPACE(79-CURR.COLM):
*CTC.REPL.FIELD = CTC(FLD.NUM)<1,CTC.DETL.SEQ>
IF FLD.NUM = 1 THEN
CTC.REPL.FIELD = OCONV(CTC(3)<1,1,1>,'D2/')
END ELSE IF FLD.NUM = 2 THEN
CTC.REPL.FIELD = OCONV(CTC(3)<1,4,1>,'MTS')
END ELSE IF FLD.NUM = 3 THEN
CTC.REPL.FIELD = CTC(3)<1,2,1>
END ELSE IF FLD.NUM = 4 THEN
CTC.REPL.FIELD = CTC(4)
END ELSE IF FLD.NUM = 5 THEN
CTC.REPL.FIELD = CTC(9)<1,CTC.DETL.SEQ>
END ELSE PRINT 'ERROR 841220'
IF LEN(CTC.REPL.FIELD) = 0 & FLD.NUM # 5 THEN CTC.REPL.FIELD = '(NONE)'
CTC.FIELD.INP = CTC.REPL.FIELD
INPUT @(CURR.COLM,CURR.LINE):CTC.FIELD.INP
IF CTC.FIELD.INP # 'END' THEN 
IF LEN(CTC.FIELD.INP) = 0 THEN CTC.FIELD.INP = CTC.REPL.FIELD
*CTC(FLD.NUM)<1,CTC.DETL.SEQ> = CTC.FIELD.INP
IF FLD.NUM = 1 THEN
CTC(3)<1,1,1> = ICONV(CTC.FIELD.INP,'D2/')
END ELSE IF FLD.NUM = 2 THEN
CTC(3)<1,4,1> = ICONV(CTC.FIELD.INP,'MTS')
END ELSE IF FLD.NUM = 3 THEN
CTC(3)<1,2,1> = CTC.FIELD.INP
END ELSE IF FLD.NUM = 4 THEN
CTC(4) = CTC.FIELD.INP
END ELSE IF FLD.NUM = 5 THEN
CTC(9)<1,CTC.DETL.SEQ> = CTC.FIELD.INP
END ELSE PRINT 'ERROR 1000'
END ELSE
CTC.REPL.FIELD = CTC.FIELD.INP
*END REQUESTED (NO ACTION HERE)
END
PRINT RVE:
RETURN
*
CTC.CLEAR: *#*
*
CTC.LOCT.NUMB = 5
CURR.LINE = MIN.LINE+1
MAT CTC.SEQN.LOCT = 0
MAT CTC.DETL.LOCT = 0
GOSUB CTC.DISP.HEADING
RETURN
*
CTC.DISP.HEADING: *#*
*
CTC.LOCT.NUMB = 6
PRINT @(0,MIN.LINE):CLS:
PRINT @(0,MIN.LINE):CLL:RVB:'CONTACT NAME: ':RVE:CTC.CONTACT:
PRINT @(0,MIN.LINE+1):RVB:'SEQ-TRAN DATE.... TIME.... TYPE...... DOCUMENT.LOCATION':STR('.',23):RVE:
RETURN
*
CTC.ENTER.CR: *#*
*
CTC.LOCT.NUMB = 7
IF CTC.DETL = 'PAGE.FULL' THEN
PRINT @(0,22):CLL:@(40):'Enter <CR> :'
CTC.INPUT = ' '
INPUT @(53,22):CTC.INPUT
GOSUB CTC.CLEAR
CTC.LOCT.NUMB = 7
CTC.DETL = 'PRINT.MORE'
CTC.INPUT = 'N'
END
RETURN
*#*
*#*
*#*
*
CTC.READ.NEXT: *#*
*
CTC.LOCT.NUMB = 9
IF CTC.SEQN>99 THEN CTC.SEQN = 1
*
R.top: GOSUB CTC.FIND.KEY
CTC.LOCT.NUMB = 9
CTC.NEW = ''
MATREAD CTC FROM CTC.FILE,CTC.ID THEN 
IF FUNC.TYPE = 'A' & FUNC.SEQ = 0 THEN
IF CTC.SEQN < 99 THEN GOTO R.top
CTC.ERR = 2
GOSUB CTC.ERR.DISP
CTC.LOCT.NUMB = 9
*#* POSSIBLE RE-LOOP UPON PROMPT (ERROR RECOVERY)
RETURN
END
CTC.RECD.STAT = 'DISP.RECD'
END ELSE
IF FUNC.TYPE # '' & FUNC.TYPE # 'N' & NOT(FUNC.TYPE = 'A' & FUNC.SEQ = 0) THEN
CTC.ERR = 1
GOSUB CTC.ERR.DISP
RETURN
END
CTC.RECD.STAT = 'LAST.RECD'
MAT CTC = ''
CTC.NEW = 1
IF FUNC.TYPE = 'A' THEN
*WAS CTC.SEQN = 1 ! FUNC.TYPE = 'A'
CTC.RECD.STAT = 'ADD.RECD'
IF CTC.SEQN = 1 THEN CTC.SEQN = 0
*FUNC.TYPE = 'A'
END
END
RETURN
*
CTC.FIND.KEY: *#*
*
CTC.LOCT.NUMB = 10
IF CTC.SEQN>99 THEN CTC.SEQN = 1
IF (FUNC.TYPE = 'A' & FUNC.SEQ = 0) ! FUNC.TYPE = 'N' THEN
CTC.SEQN = CTC.SEQN+1
END
IF CTC.SEQN < 1 THEN CTC.SEQN = 1
CT.ACTION = 2
CALL @CT.CALL(CT.KEY,CTC.ID,CTC.CONTACT,FUNC.TYPE,FUNC.SEQ,CTC.RECD.STAT,CTC.DETL,CTC.SEQN,CT.ERROR,CT.ACTION,CT.UPDATE)
IF CT.ERROR # 0 THEN
CTC.ERR = 13
GOSUB CTC.ERR.DISP
END
RETURN
*
CTC.DISP.KEY: *#**
*
CTC.LOCT.NUMB = 11
IF (NOT(CURR.LINE+2<MAX.LINE) & CTC(9)<1,2> # '') ! NOT(CURR.LINE<MAX.LINE) THEN 
CTC.DETL = 'PAGE.FULL'
CTC.RECD.STAT = 'HOLD.RECD'
END ELSE
IF (FUNC.TYPE = 'A' & FUNC.SEQ = 0) ! CTC.RECD.STAT = 'ADD.RECD' THEN
MAT CTC = ''
GOSUB CTC.FIND.KEY
CTC.LOCT.NUMB = 11
TEMP.DATE = DATE()
PR.DATE = OCONV(TEMP.DATE,'D2')
CTC(3)<1,1,1> = TEMP.DATE
TEMP.TIME = TIME()
PR.TIME = OCONV(TEMP.TIME,'MTS')
CTC(3)<1,4,1> = TEMP.TIME
IF CTC.VISITOR = 'Y' THEN
IF CTC.SEQN = 1 THEN
CTC(3)<1,2,1> = 'CCTA.VISIT'
CTC(4) = 'BROCHURE & CARD'
END
IF CTC.SEQN = 2 THEN
CTC(3)<1,2,1> = 'CCTA.CONFG'
CTC(4) = '@ CONFIGURE & SELECT.DOC & PRINT'
END
END
END
CURR.LINE = CURR.LINE+1
CTC.DETL.SEQ = 0
CTC.DISP.SEQ = CTC.SEQN
LOOP WHILE CTC.DISP.SEQ[1,1] = '0' DO
CTC.DISP.SEQ = CTC.DISP.SEQ[2,(LEN(CTC.DISP.SEQ)-1)]
REPEAT
CTC.SEQN.LOCT(CURR.LINE) = CTC.SEQN
CTC.DETL.LOCT(CURR.LINE) = 0
IF (FUNC.TYPE = 'A' & FUNC.SEQ = 0) ! CTC.RECD.STAT = 'ADD.RECD' THEN
GOSUB CTC.DATE.TIME
PRINT @(0,CURR.LINE):CLL:RVB:CTC.DISP.SEQ:RVE:@(9,CURR.LINE):PR.DATE:@(18,CURR.LINE):PR.TIME:
PRINT @(27,CURR.LINE):CTC(3)<1,2,1>:@(38,CURR.LINE):CTC(4):
FLD.NUM = 1
GOSUB INPUT.FLD
CTC.LOCT.NUMB = 11
IF CTC.REPL.FIELD # 'END' THEN
FLD.NUM = 2
GOSUB INPUT.FLD
CTC.LOCT.NUMB = 11
IF CTC.REPL.FIELD # 'END' THEN
FLD.NUM = 3
GOSUB INPUT.FLD
CTC.LOCT.NUMB = 11
IF CTC.REPL.FIELD # 'END' THEN
FLD.NUM = 4
GOSUB INPUT.FLD
CTC.LOCT.NUMB = 11
END
END
END
END
GOSUB CTC.DATE.TIME
PRINT @(0,CURR.LINE):CLL:RVB:CTC.DISP.SEQ:RVE:
IF FUNC.TYPE = 'D' AND FUNC.DET = 0 AND FUNC.SEQ = CTC.SEQN THEN PRINT RVB:
PRINT @(9,CURR.LINE):PR.DATE:@(18,CURR.LINE):PR.TIME:
PRINT @(27,CURR.LINE):CTC(3)<1,2,1>:@(38,CURR.LINE):CTC(4):
IF FUNC.TYPE = 'D' AND FUNC.DET = 0 AND FUNC.SEQ = CTC.SEQN THEN PRINT RVE:
IF CTC.RECD.STAT = 'HOLD.RECD' THEN CTC.RECD.STAT = 'DISP.RECD'
END
RETURN
*
CTC.DATE.TIME: *#*
*
PR.DATE = OCONV(CTC(3)<1,1,1>,'D2/')
PR.TIME = OCONV(CTC(3)<1,4,1>,'MTS')
RETURN
*
CTC.DISP.RECD: *#*
*
CTC.LOCT.NUMB = 12
IF CTC.RECD.STAT = 'HOLD.KEY' THEN CTC.RECD.STAT = 'DISP.RECD'
IF FUNC.TYPE = 'A' ! CTC.RECD.STAT = 'ADD.RECD' THEN
GOSUB CTC.DISP.RECD.LOOP
CTC.LOCT.NUMB = 12
IF CTC.DETL = 'PAGE.FULL' THEN RETURN
SAVE.CURR.LINE = CURR.LINE
SAVE.CTC.DETL.SEQ = CTC.DETL.SEQ
FLD.NUM = 5
LOOP WHILE FLD.NUM = 5 & CURR.LINE < MAX.LINE DO
CTC.DETL.SEQ = CTC.DETL.SEQ+1
CURR.LINE = CURR.LINE+1
GOSUB INPUT.FLD
CTC.LOCT.NUMB = 12
IF CTC(9)<1,CTC.DETL.SEQ> = '' THEN
FLD.NUM = 0
*PRINT @(CURR.COLM,CURR.LINE):RVE:SPACE(79-CURR.COLM):
PRINT @(0,CURR.LINE):RVE:CLL:
CTC.DETL = 'DISP.RECD'
END
REPEAT
CURR.LINE = SAVE.CURR.LINE
CTC.DETL.SEQ = SAVE.CTC.DETL.SEQ
END
GOSUB CTC.DISP.RECD.LOOP
RETURN
*
CTC.DISP.RECD.LOOP: *#**
*
CTC.LOCT.NUMB = 13
LOOP WHILE CTC(9)<1,CTC.DETL.SEQ+1> # '' & CURR.LINE < MAX.LINE DO
CURR.LINE = CURR.LINE+1
CTC.DETL.SEQ = CTC.DETL.SEQ+1
PRINT @(0,CURR.LINE):CLL:RVB:
IF CURR.LINE = MIN.LINE+2 THEN
PRINT CTC.DISP.SEQ:
END ELSE
PRINT SPACE(LEN(CTC.DISP.SEQ)):
END
PRINT '-':CTC.DETL.SEQ:RVE:
IF FUNC.TYPE = 'D' AND FUNC.DET = CTC.DETL.SEQ THEN PRINT RVB:
PRINT @(9,CURR.LINE):CTC(9)<1,CTC.DETL.SEQ>:
IF FUNC.TYPE = 'D' AND FUNC.DET = CTC.DETL.SEQ THEN PRINT RVE:
CTC.SEQN.LOCT(CURR.LINE) = CTC.SEQN
CTC.DETL.LOCT(CURR.LINE) = CTC.DETL.SEQ
REPEAT
IF CTC(9)<1,CTC.DETL.SEQ+1> # '' ! (FUNC.TYPE = 'A' ! CTC.RECD.STAT = 'ADD.RECD' & NOT(CURR.LINE < MAX.LINE)) THEN
CTC.RECD.STAT = 'HOLD.KEY'
CTC.DETL = 'PAGE.FULL'
END
RETURN
*#*
*#*
*#*
*
CTC.CHANGES: *#*
*
CTC.LOCT.NUMB = 14
*
C.top: PRINT @(0,22):CLL:"Enter an action (X##-##, B/N/A/C/D with SEQUENCE-DETAIL, or END):":
LINE.WANTED = 'B'
INPUT @(70,22):LINE.WANTED
CTC.ERR = 0
IF LEN(LINE.WANTED) = 0 THEN LINE.WANTED = 'B'
 IF LINE.WANTED = 'END' ! LINE.WANTED = 'CAN' THEN
IF LINE.WANTED # 'CAN' THEN CTC.RECD.STAT = 'UPDATE.RECD' ELSE CTC.RECD.STAT = 'CANCEL'
RETURN
END ELSE
IF LINE.WANTED = 'B' ! LINE.WANTED = 'N' THEN 
FUNC.TYPE = LINE.WANTED[1,1]
IF LINE.WANTED = 'N' & CTC.RECD.STAT = 'LAST.RECD' THEN
PRINT @(0,22):CLL:'NO MORE DETAILS':
GOTO C.top
END
CTC.DETL = 'PRINT.MORE'
RETURN
END ELSE
FUNC.SEQ = FIELD(LINE.WANTED,'-',1)
IF LEN(FUNC.SEQ) = 0 THEN FUNC.SEQ = LINE.WANTED
FUNC.TYPE = ''
LOOP WHILE NOT(NUM(FUNC.SEQ[1,1])) DO
FUNC.TYPE = FUNC.SEQ[1,1]
FUNC.SEQ = FUNC.SEQ[2,(LEN(FUNC.SEQ)-1)]
REPEAT
IF FUNC.TYPE # 'A' & FUNC.TYPE # 'C' & FUNC.TYPE # 'D' THEN
CTC.ERR = 3; GOSUB CTC.ERR.DISP
GOTO C.top
END
IF LEN(FUNC.SEQ) = 0 THEN
FUNC.SEQ = 0
END
IF FUNC.SEQ = 0 THEN
*IF FUNC.TYPE = 'A' THEN FUNC.SEQ = 0
IF FUNC.TYPE = 'C' THEN CTC.ERR = 6
IF FUNC.TYPE = 'D' THEN
GOSUB CTC.DEL.ALL
GOSUB CTC.UPDATE
CTC.LOCT.NUMB = 14
GOTO C.top
END
END
IF CTC.ERR THEN
GOSUB CTC.ERR.DISP
CTC.ERR = 0
GOTO C.top
END
FUNC.DET = FIELD(LINE.WANTED,'-',2)
IF LEN(FUNC.DET) = 0 THEN
FUNC.DET = 0
END
END
END
IF NOT(NUM(FUNC.SEQ)) ! NOT(NUM(FUNC.DET)) THEN 
CTC.ERR = 3
GOSUB CTC.ERR.DISP
GOTO C.top
END
CTC.LAST.SEQN = CTC.SEQN
IF CTC.RECD.STAT = 'ADD.RECD' THEN
FUNC.SEQ = CTC.SEQN
END
CTC.SEQN = FUNC.SEQ
CTC.ERR = 0
GOSUB CTC.READ.NEXT
CTC.LOCT.NUMB = 14
IF CTC.ERR THEN 
CTC.SEQN = CTC.LAST.SEQN
CTC.ERR = 0
GOSUB CTC.READ.NEXT
CTC.LOCT.NUMB = 14
GOTO C.top
END
*        DISP IF NECESSARY
IF (FUNC.TYPE = 'A' & FUNC.SEQ # 0 & FUNC.DET = 0) ! FUNC.TYPE # 'A' THEN
GOSUB CTC.CLEAR
CTC.LOCT.NUMB = 14
CTC.REPL.FIELD = ''
CTC.DETL = 'INPUT.FIELDS'
CTC.DETL.SEQ = 0
LOOP WHILE CTC.DETL = 'INPUT.MORE' ! CTC.DETL = 'INPUT.FIELDS' ! CTC.DETL = 'PAGE.FULL' & (CTC.DETL.SEQ < FUNC.DET ! FUNC.DET = 0) DO
IF CTC.DETL = 'PAGE.FULL' THEN
GOSUB CTC.ENTER.CR
CTC.LOCT.NUMB = 14
CTC.DETL = 'INPUT.MORE'
END
IF CTC.DETL = 'INPUT.FIELDS' THEN GOSUB CTC.DISP.KEY
IF CTC.DETL # 'PAGE.FULL' THEN GOSUB CTC.DISP.RECD
IF CTC.DETL = 'INPUT.FIELDS' THEN CTC.DETL = 'INPUT.MORE'
IF FUNC.TYPE # 'A' & (CTC.DETL # 'PAGE.FULL' ! CTC.DETL.SEQ >= FUNC.DET) THEN CTC.DETL = 'CHOOSE.ACTION'
REPEAT
CTC.DETL = 'CHOOSE.ACTION'
CTC.REPL.FIELD = 'END'
IF FUNC.TYPE = 'A' & FUNC.SEQ # 0 & FUNC.DET = 0 THEN 
GOSUB CTC.UPDATE
CTC.LOCT.NUMB = 14
*CTC.SEQN = CTC.SEQN - 1
GOTO C.top
END
END
LOC.NUM = MIN.LINE+1; LOC.NUM1 = MIN.LINE+1
LOC.SEQ.FOUND = 0; LOC.DET.FOUND = 0
CONT.FLAG = 1; CONT.FLAG1 = 1
LOOP
IF NOT(LOC.SEQ.FOUND) THEN LOC.NUM = LOC.NUM+1
IF NOT(LOC.NUM>MIN.LINE & NOT(LOC.NUM>MAX.LINE)) THEN CONT.FLAG = 0 ELSE
 IF NOT(CTC.SEQN.LOCT(LOC.NUM) # 0 & NOT(CTC.SEQN.LOCT(LOC.NUM)>FUNC.SEQ)) THEN CONT.FLAG = 0
END
WHILE CONT.FLAG = 1 & NOT(LOC.SEQ.FOUND) DO
IF CTC.SEQN.LOCT(LOC.NUM) = FUNC.SEQ THEN LOC.SEQ.FOUND = 1
IF FUNC.DET # 0 THEN
LOOP
LOC.NUM1 = LOC.NUM1+1
IF NOT(NOT(LOC.NUM1>MAX.LINE) & LOC.NUM1>MIN.LINE) THEN CONT.FLAG1 = 0 ELSE
IF NOT(CTC.SEQN.LOCT(LOC.NUM1) = FUNC.SEQ) THEN CONT.FLAG1 = 0 ELSE
IF NOT(CTC.SEQN.LOCT(LOC.NUM1) # 0 & NOT(CTC.DETL.LOCT(LOC.NUM1)>FUNC.DET)) THEN CONT.FLAG1 = 0
END
END
WHILE CONT.FLAG1 = 1 DO
IF CTC.DETL.LOCT(LOC.NUM1) = FUNC.DET THEN LOC.DET.FOUND = 1
LOC.NUM = LOC.NUM1
REPEAT
END
REPEAT
CTC.ERR = 0
IF FUNC.SEQ # 0 THEN
IF LOC.SEQ.FOUND THEN 
IF FUNC.DET # 0 THEN
IF FUNC.TYPE = 'A' THEN CTC.ERR = 8 ELSE
IF NOT(LOC.DET.FOUND) THEN CTC.ERR = 1 ELSE
IF FUNC.TYPE = 'D' THEN
GOSUB CTC.DEL.DETL
GOSUB CTC.UPDATE
GOTO C.top
END
**               *CHANGE*DETL*
END
**            *OF LOC.DET.FOUND*
END
**         *OF FUNC.TYPE # 'A'*
END ELSE
**      *START OF FUNC.DET = 0*
IF FUNC.TYPE = 'D' THEN
GOSUB CTC.DEL.SEQNS
CTC.LOCT.NUMB = 14
GOTO C.top
END
**         *ADD*DETLS*
**         *CHANGE*SEQN*
END
END ELSE
CTC.ERR = 1
END
END ELSE
IF FUNC.TYPE = 'D' THEN
GOSUB CTC.DEL.SEQNS
CTC.LOCT.NUMB = 14
GOTO C.top
END
IF FUNC.TYPE = 'C' THEN CTC.ERR = 9
**   *ADD*SEQNS*
END
IF CTC.ERR # 0 THEN
GOSUB CTC.ERR.DISP
CTC.ERR = 0
GOTO C.top
END
IF FUNC.DET # 0 THEN CURR.LINE = LOC.NUM1 ELSE CURR.LINE = LOC.NUM
IF FUNC.TYPE = 'C' THEN
IF FUNC.DET # 0 THEN
CTC.DETL.SEQ = FUNC.DET
CURR.LINE = CURR.LINE-1
FLD.NUM = 5
GOSUB INPUT.FLD
CTC.LOCT.NUMB = 14
CURR.LINE = CURR.LINE-1
CTC.DETL.SEQ = CTC.DETL.SEQ-1
END ELSE
CTC.DETL.SEQ = 0
FLD.NUM = 0
LOOP FLD.NUM = FLD.NUM+1 WHILE FLD.NUM < 5 DO
GOSUB INPUT.FLD
CTC.LOCT.NUMB = 14
REPEAT
CURR.LINE = CURR.LINE-1
GOSUB CTC.DISP.KEY
CTC.LOCT.NUMB = 14
END
GOSUB CTC.DISP.RECD
GOSUB CTC.UPDATE
CTC.LOCT.NUMB = 14
GOTO C.top
END
IF FUNC.TYPE = 'A' & FUNC.SEQ = 0 THEN CTC.SEQN = CTC.SEQN - 1
PRINT @(0,22):BELL:BELL:BELL:'AT FALL-OUT OF ':CTC.PROG.LOCT(CTC.LOCT.NUMB):'...':
RETURN
*
CTC.UPDATE: *#*
*
CTC.LOCT.NUMB=15
MATWRITE CTC ON CTC.FILE,CTC.ID
CT.ACTION = 3
CALL @CT.CALL (CT.KEY,CTC.ID,CTC.CONTACT,FUNC.TYPE,FUNC.SEQ,CTC.RECD.STAT,CTC.DETL,CTC.SEQN,CT.ERROR,CT.ACTION,CT.UPDATE)
IF CT.ERROR # 0 THEN
CTC.ERR = 14
GOSUB CTC.ERR.DISP
END
*MATWRITE PRP ON PRP.FILE,CTC.KEY.OVERVIEW
CT.UPDATE='UPDATE.RECORD'
RETURN
*
CTC.ERR.DISP: *#*
*
*CTC.LOCT.NUMB=16
PRINT @(0,22):CLL:BELL:CTC.ERR.MSG(CTC.ERR):', enter a <CR>.':
A$=''
INPUT @(70,22):A$
PRINT @(0,22):CLL:
RETURN
*
CTC.DEL.ALL: *#*
*
CTC.LOCT.NUMB=17
CTC.ERR=7
GOSUB CTC.ERR.DISP
RETURN
*
CTC.DEL.SEQNS: *#*
*
IF FUNC.TYPE='D' AND FUNC.SEQ = CTC.SEQN AND FUNC.DET = 0 THEN
PRINT @(0,22):BELL:CLL:'DELETE THIS SEQUENCE (Y/<CR>=N): ':
YES.NO = 'N'
INPUT @(40,22):YES.NO
IF LEN(YES.NO)=0 THEN YES.NO = 'N'
IF YES.NO = 'Y' THEN
CTC.DEL.SEQN = CTC.SEQN
CTC.DEL.FLAG = 1
LOOP
CTC.DEL.SEQN = CTC.DEL.SEQN + 1
CTC.OLD.ID = CTC.ID
CTC.SEQN = CTC.DEL.SEQN
GOSUB CTC.FIND.KEY
MATREAD CTC FROM CTC.FILE,CTC.ID ELSE CTC.DEL.FLAG = ''
WHILE CTC.DEL.FLAG DO
MATWRITE CTC ON CTC.FILE,CTC.OLD.ID
REPEAT
DELETE CTC.FILE,CTC.OLD.ID
END
END
RETURN
*
CTC.DEL.DETL: *#*
*
PRINT @(0,22):BELL:CLL:'DELETE THIS TEXT LINE (Y/<CR>=N): ':
YES.NO = 'N'
INPUT @(40,22):YES.NO
IF LEN(YES.NO)=0 THEN YES.NO = 'N'
IF YES.NO = 'Y' THEN
CTC(9)<1> = DELETE(CTC(9),1,FUNC.DET)
CTC.DETL.SEQ=CTC.DETL.SEQ -1
CURR.LINE = CURR.LINE - 1
GOSUB CTC.DISP.RECD
END
RETURN
*
CTC.LOCT.NUMB=20
*
*#*END OF CHANGES*#*
*CUSTOM*END OF
!
END
END
~CTC.ID.CCTA~
SUBROUTINE CTC.ID.CCTA(CCTA.ID,CT.KEY,CT.CONTACT,CT.FUNC.TYPE,CT.FUNC.SEQ,CT.RECD.STAT,CT.DETL,CT.SEQN,CT.ERROR,CT.ACTION,CT.UPDATE)
*SUBROUTINE: CTC.ID.CCTA
*
*
* CCTA.ID  1  PRP$CONTACT.FLAG
*          2  PRP(25)
*          3  PRP.ID
*          4  PRP$CONTACT
*          5  CNTR.NUM
*          6  NOT USED
*
*
ON CT.ACTION GOSUB CT.INIT,CT.FIND.KEY,CT.UPDATE.RTN
RETURN
*
CT.INIT: *#*
*
CT.LOCT.NUMB = 1
IF CCTA.ID<5> = 11 THEN 
CCTA.ID<1,11> = CCTA.ID<2,1>
END
IF CCTA.ID<1,CCTA.ID<5>> # '*' THEN
CT.FUNC.TYPE = 'A'
CT.RECD.STAT = 'ADD.RECD'
CT.DETL = 'INPUT.MORE'
END
RETURN
*
CT.FIND.KEY: *#*
*
CT.LOCT.NUMB = 2
IF CCTA.ID<5> < 11 THEN
CT.CONTACT = FIELD(CCTA.ID<4>,'*',CCTA.ID<5>)
END ELSE
CT.CONTACT = CCTA.ID<3>
END
CT.KEY = CCTA.ID<3>:'@':CT.CONTACT:'@':STR('0',(5-LEN(CT.SEQN))):CT.SEQN
RETURN
*
CT.UPDATE.RTN: *#*
*
CT.LOCT.NUMB = 3
IF CCTA.ID<1,CCTA.ID<5>> # '*' THEN CCTA.ID<1,CCTA.ID<5>>='*'
IF CCTA.ID<5>=11 THEN
CCTA.ID<1,11>=''
CCTA.ID<2,1>='*'
END
CT.UPDATE = 'UPDATE.RECORD'
RETURN
~DATASENSE.UPPER.CASE~
SUBROUTINE DATASENSE.UPPER.CASE(SUBJECT)
*SUBROUTINE: DATASENSE.UPPER.CASE
*
*      This program converts lower case text to upper case.
*  It is necessary because Microdatas don't support OCONV(X,'MCU')
*
*
PROGRAM="DATASENSE.UPPER.CASE"
IF SUBJECT > "" THEN
    RESULT=""
    FOR X=1 TO LEN(SUBJECT)
        A=SUBJECT[X,1]
        IF A >= "a" AND A <= "z" THEN
            A=CHAR(SEQ(A)-32)
        END
        RESULT=RESULT:A
    NEXT X
    SUBJECT=RESULT
END
RETURN; * TO CALLING PROGRAM
*
END
~DOC.OVERVIEW.SYSTEM.STRUCTURE~
*PROGRAM: MENU.HANDLER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
*
* MODES: 0 - ERROR CONDITION
*
*        1 - SUMMARY OVERVIEW   - MARKETTING  - SALES DOC WITHIN MENUS
*
*        2 - SUMMARY            -     "       - SALES AND OPERATOR
*              DEMONSTRATION                     DOC. WITHIN MENUS
*
***** POINT WHERE PROGRAMS ARE EXECUTED.
*
*        3 - DETAILED           -     "       - OPERATOR DOC. WITHIN MENUS
*              DEMONSTRATION      TRAINING       AND FIELDS WITHIN PROGS.
*
***** POINT WHERE ACTUAL ENTRY OF DATA OCCURS.
*
*        4 - DETAILED ENTRY     - TRAINING    - OPERATOR DOC. PRIOR TO
*                                                ENTRY OF ALL FIELDS. LONG
*                                                FIELD NAMES.
*
*        5 - SUMMARY ENTRY      - TRAINING    - NO DOC. LONG FIELD NAMES.
*
*        6 - REGULAR MODE       - NORMAL      - NORMAL FIELD NAMES ARE USED
*                                  OPERATIONS    ,MULTIPLE SCREENS.
*
*        7 - DEVELOPMENT MODE   - DEVELOPMENT - CREATION OF NON-EXISTANT
*                                                PROCEDURES AND PROGRAMS
*
*        8 - DOCUMENTATION MODE - DOCUMENTING - CREATION OF VARIOUS LEVELS
*                                                OF DOCUMENTATION
*
*        9 - TEST MODE          - SYSTEMS     - TESTING OF SYSTEM USING
*                                   TESTING      TEST FILES.
*
*       10 - NOT IN USE
*
*       11 - MACH 01           - CONDENSED    - SHORTENED FIELD NAMES,
*                                  SCREENS       SINGLE SCREENS, COMBINED
*                                                MENUS, ETC.
*
*     > 11 - MACH 2 to 10      - AS PER MACH 01 BUT WITH PROGRESSIVELY
*                                  HIGHER TIME SLICES ASSIGNED TO USER.
*
*        
!
~DT.LP~
*PROGRAM: DT.LP
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINTER ON
PRINT
PRINT
PRINT OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
PRINT
PRINT
PRINTER OFF
PRINT OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
PRINT
*
END
~ENTITY.INFO~
X*PROGRAM: ENTITY.INFO
*
$INCLUDE IBP EI.COMMON.VARIABLES
PROG.LOCT = 1
PROG.NAME = "Entity File Entry and Control Program"
$INCLUDE IBP CNTR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP EI.STANDARD.FUNCTIONS
*
*@* DIM STATEMENTS *@*
PROG.LOCT = 2
MAT TB.LOCT = 0; MAT TB.ERRS = 0
MAT TB.L = ""
MAT IA.C = 0
*
*
*
MAT EI.REC = ""
K.H.L = 10
*
PRINT
PRINT "EI Appl":
INPUT EI.A
PRINT "EI User":
INPUT EI.U
PRINT "EI List":
INPUT EI.A.U
PRINT "EI Run Type":
INPUT EI.RUN.TYPE
EI.MV.AM = 0; EI.KL.AM = 0; EI.ET.AM = 0; EI.CDT.AM = 0; EI.ADT.AM = 0
EI.PDT.AM = 0; EI.CR.AM = 0; EI.SK.FL = 0; EI.FI.VL = ""
*
L.A = 0; L.P = 0; C.P = 0
KEYS.SL = ""
KEY.LIST.CN = 0
KEY.LIST.DEL = 0
KEY.LIST.SAVE = ""
KEY.LIST = ""
ID = ""
KEY.ITEM = ""
REC.STATUS = 9
FUNCT.NUMBER = 1
F.T = "M"
FUNCT.SCAN = ""
FUNCT.SCAN.INP = ""
C.R = 0; NUMB.REC = 0
IA.C.RESET = 1
SD.PAGE = ""
L.W = 0; SAVE.L.W = 0; SUB.L.W = 0; SUB.FUNCT = ""; LINE.ALPHA = ""
EI.ENTY.FILE = ""; TB.FL = 0
PROMPT ""
PRINT FF
*
CONTR.FLAG = 0
KEY.P.L = 1
K.C.L = 1
K.D.L = 0
KEY.DF.L = 0
FTB.DONE = "MODIFY.INFO"
F.TIME = 1
*
*@* FILE OPEN AREA *@*
*
PROG.LOCT = 3
*
*@* OPEN SYSTEM STRUCTURE FILE
*
$INCLUDE IBP SUB.IO.OPEN.EI.SYSS
*
*#*
*#* Initialize Program Control Fields
*#*
PROG.LOCT = 4
CURRENT.DAT.INP = 0
CALL S.I.T.EI 
IF F.ERR THEN STOP
*
PROG.LOCT = 5
$INCLUDE IBP SUB.IO.OPEN.EI
*
PROG.LOCT = 6
KEY.ENTITY = ""; KEY.ENTITY.ID = KEY.ENTITY; KEY.ENTITY.INPUT = ""
KEY.CN1 = 0; KEY.CN2 = 0
*#*
*#* Determine List Handling
*#*
GOSUB ENTITY.LIST.CONTROL
*#*
*#* Input program default/control information
*#*
GOSUB ENTITY.CONTROL
*#*
*#*
*#* MAIN LOGIC AREA
*#*
*#*
10 LOOP
PROG.LOCT = 100
IF F.T # "END" THEN GOSUB KEY.INPUT.PRIMARY           
WHILE KEY.ENTITY.INPUT # "END" & F.T # "END" DO 
*
*      READ ENTITY FILE RECORD
*
F.T = ""
GOSUB ENTITY.READ           
IF REC.STATUS # 7 THEN
GOSUB IA.LOAD.CONTROL
*
*          ENTER ADDR IF NEW
*
FUNCT.SCAN = ""
F.T = ""
IF REC.STATUS = 1 THEN
IF FTB.DONE = "ADD.RECORD" THEN
FTB.DONE = "NEXT.MV"; F.T = "@"
GOSUB INPUT.CONTROL
FTB.DONE = "MODIFY.INFO"
GOSUB MAIN.LOOP
END
END ELSE
GOSUB FOREGROUND.DISPLAY
GOSUB MAIN.LOOP
END
END
REPEAT
GOSUB END.OF.PROGRAM.AREA
GOTO 99999
*
MAIN.LOOP: *#*
*
*      INPUT FUNCTION - S,L,P,A/M/D,U,I
*
100  GOSUB ACTION.SELECT
IF F.T = "END" THEN 
PRINT @(F.Z1,L.E):CLL:RVB:BELL:"END requested, (Y/<CR> = N):":RVE:
YES.NO = "N"
INPUT @(F.Z3,L.E):YES.NO:
IF YES.NO # "Y" THEN GOSUB CONTROL.DISPLAY; GOTO 100
END ELSE
IF F.T = "CAN" THEN
IF REC.STATUS = 1 ! REC.STATUS = 2 THEN
YES.NO = "Y"
END ELSE
IF REC.STATUS = 4 ! REC.STATUS = 5 ! REC.STATUS = 6 THEN
PRINT @(F.Z1,L.M):CLL:RVB:BELL:"Entity has been ":TB.STAT(REC.STATUS):" (":REC.STATUS:"), some changes have occurred.":;RQM
RQM
PRINT @(F.Z1,L.E):CLL:BELL:"CANCELL changes that occured after record ":TB.STAT(REC.STATUS):" (Y/<CR> = N):"
YES.NO = "N"
INPUT @(F.Z4,L.E):YES.NO
IF LEN(YES.NO) = 0 THEN YES.NO = "N"
END ELSE
PRINT @(F.Z1,L.E):CLL:RVB:BELL:"CANCELLATION requested, (Y or <CR>):":RVE:
YES.NO = "N"
INPUT @(F.Z3,L.E):YES.NO:
END
END
IF YES.NO # "Y" THEN GOTO 100
REC.STATUS = 7; GOSUB CONTROL.DISPLAY
END
*
*    ENTITY FILE RECORD MODIFY
*
IF F.T = "S" THEN
*    GOSUB KEY.REDEFINE.AREA
GO TO 100
END
*
*    LIST ADDR ON SCREEN
*
IF F.T = "L" THEN GOSUB SCREEN.LISTING.AREA
*
*    PRINT ADDR ON PRINTER
*
IF F.T = "P" THEN GOSUB PRINTER.LISTING.AREA
*
*    CHANGE INFO AREA
*
IF F.T = "I" THEN
F.ERR = ""
KEY.P.L = K.C.L
CALL SUB.KEY.SELECT.EI 
IF F.ERR THEN
IF F.ERR = "END" THEN F.T = "END"
IF F.ERR = "CAN" THEN REC.STATUS = 7; F.T = "U"
END ELSE
IF K.C.L = KEY.P.L THEN GOSUB BACKGROUND.DISPLAY
GOSUB IA.LOAD.CONTROL
GOSUB FOREGROUND.DISPLAY
GOTO 100
END
END
*
*@* DETAIL RECORD MODIFY *@*
*
FTB.DONE = "MODIFY.INFO"
IF F.T = "A" ! F.T = "M" ! F.T = "D" THEN 
IF NOT(K.C.L>K.H.L) THEN
IF F.T = "A" THEN FTB.DONE = "NEXT.MV"; F.T = "@"
GOSUB INPUT.CONTROL
END ELSE
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", I am unable to access than KEY LEVEL.":; RQM
END
IF F.T # "END" & F.T # "CAN" THEN GOTO 100
END
IF REC.STATUS # 7 THEN 
GOSUB UPDATE.ENTITY.RECORD
REC.STATUS = 8; GOSUB CONTROL.DISPLAY
END
IF F.T = "END" THEN GOTO 99999
END
RETURN; *: *
*
UPDATE.ENTITY.RECORD: *@* FILE UPDATE SUBROUTINE *@*
*
MATWRITE EI.REC ON ENTY,KEY.ENTITY
REC.STATUS = 4; GOSUB CONTROL.DISPLAY; RQM
RETURN; *: *
*
ENTITY.DELETE.AREA: *@*
*PRINT 'ENTITY.DELETE.AREA'
*INPUT TEMP
*IF TEMP = "END" THEN STOP
*
IF F.T = "D" THEN
IF FUNCT.SCAN THEN
PRINT @(F.Z1,L.E):CLL:"Delete this ":TB.L(K.C.L)<1,1,1>:" ( Q or Y or <CR> = N):":
FUNCT.SCAN.INP = "N"
INPUT @(F.Z4,L.E):FUNCT.SCAN.INP
END ELSE FUNCT.SCAN.INP = "Y"
IF FUNCT.SCAN.INP = "" THEN FUNCT.SCAN.INP = "N"
IF FUNCT.SCAN.INP = "Y" THEN
*PRINT ' (DELETE) FUNCT.SCAN.INP EQ "Y"'
*INPUT TEMP
*IF TEMP EQ "END" THEN STOP
*GOSUB ENTITY.DELETE.RECORD
*END
*END
*RETURN; *: *
**
*ENTITY.DELETE.RECORD: *@*
*
*PRINT 'ENTITY.DELETE.RECORD'
*INPUT TEMP
*IF TEMP EQ "END" THEN STOP
*IF F.T = "D" THEN
MAXM.FLD = TB.L(K.C.L)<1,1,6>
CN1 = 1
LOOP
CN1 = CN1 + 1
WHILE CN1 < MAXM.FLD+1 DO
CT.ATT = IA.C(3,CN1)<1,1>
EI.REC(CT.ATT) = DELETE(EI.REC(CT.ATT),1,C.R)
REPEAT
NUMB.REC = NUMB.REC-1
*END
REC.STATUS = 5; GOSUB CONTROL.DISPLAY; RQM
END
END
RETURN; *: *
*
*
ENTITY.DELETE.RECORD: *@*
*
PRINT @(F.Z1,L.E):CLL:EI.U:", are you sure you want to delete the Entity? ":
INPUT FUNCT.SCAN.INP:
IF FUNCT.SCAN.INP EQ "Y" THEN
REC.STATUS = 5; GOSUB CONTROL.DISPLAY; RQM
EI.REC(EI.ET.AM) = "*DELETED*":VM:EI.REC(EI.ET.AM)
END
RETURN; *: *
*
KEY.INPUT.PRIMARY: *@* SCREEN-KEY INPUT  *@*
*
300  PROG.SUB.NAME = "Input Entity Key"
KEY.ENTITY.INPUT = KEY.ENTITY
KEY.ENTITY.ID = KEY.ENTITY.ID<1,1>
IF EI.RUN.TYPE # 0 THEN
IF ID NE "" & EI.RUN.TYPE >= 2 THEN
LOOP
KEY.STATUS = "C"
PRINT @(F.Z1,L.E):CLL:EI.U:", enter the status of this list item: ":
INPUT KEY.STATUS:
WHILE NOT(INDEX("*H*C*X*I*N*S*","*":KEY.STATUS:"*",1)) DO REPEAT
KEY.LIST<KEY.LIST.CN> = ID:VM:VM:KEY.STATUS:SVM:EI.U:SVM:DATE():SVM:TIME():SVM:WHO:VM
END
IF EI.RUN.TYPE = 3 THEN
LOOP
CONT = 0
KEY.ITEM = KEY.LIST<KEY.LIST.CN+1>
ID = KEY.ITEM<1,1>
IF ID EQ "" THEN
PRINT @(F.Z1,L.M):CLL:BELL:EI.U:", your list has been exhausted. Enter 'Y' to start over... ":; INPUT YES.NO:
IF YES.NO EQ "Y" OR YES.NO EQ "y" THEN
GOSUB ENTITY.LIST.CONTROL
CONT = 1
END
END ELSE
KEY.STATUS = KEY.ITEM<1,3,1>
PRINT @(F.Z4,L.M):CLL:RVB:((KEY.LIST.CN+10001) "R#4":" ":KEY.STATUS:"    ":OCONV(TIME(),"MTS")) "L#18":RVE:
*IF KEY.STATUS EQ "" OR KEY.STATUS EQ "N" OR KEY.STATUS EQ "S" THEN KEY.STATUS = "I"
IF KEY.STATUS NE "X" AND KEY.STATUS NE "C" AND KEY.STATUS NE "H" THEN KEY.STATUS = "I"
IF LIST.NEW.LO NE "" THEN
IF ID[1,LEN(LIST.NEW.LO)] LT LIST.NEW.LO THEN CONT = 1
IF ID[1,LEN(LIST.NEW.HI)] GT LIST.NEW.HI THEN CONT = 1
*#*END ELSE
END
IF KEY.STATUS NE LIST.PROC.STAT AND ID NE "" AND LIST.PROC.STAT NE "*" THEN CONT = 1
*#*END
END
WHILE CONT = 1 DO
KEY.LIST.CN = KEY.LIST.CN + 1
REPEAT
IF ID EQ "" THEN EI.RUN.TYPE = 0
END ELSE IF EI.RUN.TYPE = 2 THEN
READNEXT ID FROM ENTY.LIST ELSE
EI.RUN.TYPE = 0
GOTO 300
END
KEY.ITEM=ID:VM:VM:"N"
KEY.STATUS="N"
END
KEY.LIST.CN = KEY.LIST.CN + 1
KEY.ENTITY = ID
KEY.ENTITY.INPUT = ID
END 
CN1 = 1
CONT1 = 1
LOOP
CN1 = CN1 + 1
CN2 = CN1
LOOP WHILE TB.L(K.C.L)<1,CN2> = "" & CN2 - CN1 < 3 DO
CN2 = CN2 + 1
REPEAT
IF CN2 - CN1 >= 3 THEN CONT1 = 0 ELSE CN1 = CN2
WHILE CONT1 & KEY.ENTITY.INPUT # "END" DO
IF EI.RUN.TYPE # 0 THEN
K.EXTRACT  = "G":(CN1-2):"@1"
KEY.ENTITY.INPUT = OCONV(KEY.ENTITY,K.EXTRACT)
END ELSE
KEY.ENTITY.INPUT = KEY.ENTITY.ID<1,CN1-1>
K.CP = TB.L(K.C.L)<1,CN1,1>
K.LP = TB.L(K.C.L)<1,CN1,2>
PRINT @((K.CP+LEN(KEY.ENTITY.INPUT)),K.LP):SPACE(52-LEN(KEY.ENTITY.INPUT)):
INPUT @(K.CP,K.LP):KEY.ENTITY.INPUT
END
IF KEY.ENTITY.INPUT # "END" & LEN(KEY.ENTITY.INPUT) # 0 THEN
KEY.ENTITY.ID<1,CN1-1> = KEY.ENTITY.INPUT
END
REPEAT
IF KEY.ENTITY.INPUT # "END" THEN
KEY.CN1 = CN1 - 2
KEY.CN2 = 0
IF EI.SK.FL = 1 THEN
GOSUB KEY.INPUT.SECONDARY
IF ENTITY.INPUT.VALUE = "END" THEN KEY.ENTITY.INPUT = ENTITY.INPUT.VALUE
END
END
IF KEY.ENTITY.INPUT = "END" THEN
PRINT @(F.Z4,L.M):SPACE(20):BELL:"END requested."
RETURN
END
GOSUB KEY.DISPLAY
IF LEN(KEY.ENTITY) = 0 ! KEY.ENTITY = "@" ! KEY.ENTITY = "@@" THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:" you can not have an empty ENTITY KEY":; RQM
GOTO 300
END
RETURN; *: *
*
KEY.INPUT.SECONDARY: *#*
*
CN1 = KEY.CN1
IF EI.SK.FL = 1 THEN
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE IA.C(4,CN2)<1,1> = "K" DO
IF EI.RUN.TYPE # 0 THEN
K.EXTRACT = "G":(CN2+CN1):"@1"
ENTITY.INPUT.VALUE = OCONV(KEY.ENTITY,K.EXTRACT)
END ELSE
L.W = CN2
FTB.DONE = "INPUT.KEY"; F.T = "@"
GOSUB INPUT.FLD
END
IF ENTITY.INPUT.VALUE = "END" THEN RETURN
KEY.ENTITY.ID<1,CN2+CN1> = ENTITY.INPUT.VALUE
REPEAT
KEY.CN2 = CN2 - 1
END
RETURN; *: *
*
KEY.DISPLAY: *#*
*
CN1 = 0; CN2 = 0
KEY.ENTITY = ""; KEYCHAR = ""
LOOP
IF CN1 < KEY.CN1 THEN CN1 = CN1 + 1 ELSE CN2 = CN2 + 1
WHILE CN1 < KEY.CN1 ! CN2 < KEY.CN2 + 1 DO
IF CN1 = 2 ! CN2 # 0 THEN KEYCHAR = "@"
KEY.ENTITY = KEY.ENTITY:KEYCHAR:KEY.ENTITY.ID<1,CN1+CN2>
IF CN2 = 0 THEN
K.CP = TB.L(K.C.L)<1,CN1+1,1>
K.LP = TB.L(K.C.L)<1,CN1+1,2>
K.LE = TB.L(K.C.L)<1,CN1+1,3>
END ELSE
K.CP = IA.C(2,CN2)
K.LP = IA.C(1,CN2) + L.A
K.LE = LEN(KEY.ENTITY.ID<1,CN1+CN2>)+5
END
PRINT @(K.CP,K.LP):KEY.ENTITY.ID<1,CN1+CN2>:SPACE(K.LE - LEN(KEY.ENTITY.ID<1,CN1+CN2>)):
REPEAT
RETURN; *: *
*
ENTITY.READ: *@* ENTITY FILE RECORD READ SUBROUTINE
*
PROG.SUB.NAME = "Read an Entity Record"
SD.PAGE<1,1> = "N"
*SD.PAGE<1,2> = 0
YES.NO = "N"; REC.STATUS = 2
KEY.PRE = ""; KEY.SUF = ""
IF EI.U.P.S = 3 THEN KEY.PRE = EI.U:"@":KEY.PRE
IF EI.IA.P.S = 4 THEN KEY.SUF = KEY.SUF:"@":TB.L(K.C.L)<1,1,1>[5,20]
IF EI.U.P.S = 4 THEN KEY.SUF = KEY.SUF:"@":EI.U
IF EI.IA.P.S = 3 THEN KEY.PRE = TB.L(K.C.L)<1,1,1>[5,20]:"@":KEY.PRE
MATREAD EI.REC FROM ENTY,KEY.PRE:KEY.ENTITY:KEY.SUF THEN
IF EI.KL.AM # 0 THEN
IF F.T = "I" THEN
EI.REC(EI.KL.AM) = K.C.L
END ELSE
IF K.C.L = 0 THEN K.C.L = KEY.DF.L
IF LEN(EI.REC(EI.KL.AM)) = 0 THEN EI.REC(EI.KL.AM) = K.C.L
IF EI.REC(EI.KL.AM) = 0 THEN EI.REC(EI.KL.AM) = K.C.L
K.C.L = EI.REC(EI.KL.AM)
END
END
IF EI.MV.AM # 0 THEN
C.R = EI.REC(EI.MV.AM)<1,K.C.L>
END ELSE C.R = 1
END ELSE
REC.STATUS = 1; GOSUB CONTROL.DISPLAY; MAT EI.REC = ""
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", the record for ":KEY.ENTITY:" does not exist.":
PRINT @(F.Z4,L.E):CLL:"Add this record?":
INPUT @(F.Z4+17,L.E):YES.NO
IF YES.NO # "NO" & YES.NO # "YES" & YES.NO # "Y" THEN YES.NO = "N"
IF YES.NO = "YES" ! YES.NO = "Y" THEN
FTB.DONE = "ADD.RECORD"; F.T = "@"
NUMB.REC = 0
END ELSE
REC.STATUS = 7
END
END
GOSUB CONTROL.DISPLAY
RETURN; *: *
*
REC.COUNTER: *@*
*
PROG.SUB.NAME = "Count Number of Records in Level"
*IF K.D.L = 0 THEN RETURN
IF EI.MV.AM = 0 THEN NUMB.REC = 1; C.R = 1 ELSE
IF REC.STATUS < 7 THEN
NUMB.CN1 = 0
NUMB.REC = 0
N.C.ATTR = IA.C(3,2)
IF N.C.ATTR = 0 THEN N.C.ATTR = 1
*  N.C.ATTR IS THE FILE ATTRIBUTE THAT IT"S FIRST MULTI-VALUE THAT HAS A NULL VALUE DETERMINES THERE ARE MULTI-VALUE - 1 RECORDS.
LOOP NUMB.CN1 = NUMB.CN1+1 UNTIL LEN(EI.REC(N.C.ATTR)<1,NUMB.CN1>) = 0 DO REPEAT
NUMB.REC = NUMB.CN1 - 1
END ELSE NUMB.REC = 1
END
RETURN; *: *
*
INPUT.CONTROL: *@*
*
PROG.SUB.NAME = "Entity Data Input Area"
L.W = 0; SUB.L.W = 0; SUB.FUNCT = ""
*SPEC.CONT = 1
T.of.ic: *#*
*PRINT 'DELETE T.of.ic'
*INPUT TEMP
*IF TEMP EQ "END" THEN STOP
*
IF FTB.DONE = "NEXT.IA" THEN
IF K.C.L > 0 THEN
PRINT @(F.Z1,L.E):CLL:"Do you want to add the next Info. Level? ":
INPUT A$:
IF NOT(INDEX("*Y*YES*Yes*yes*y*OK*","*":A$:"*",1)) THEN RETURN
END
K.C.L = K.C.L+1
IF K.R(K.C.L) = 0 & K.C.L < K.H.L THEN GOTO T.of.ic
FTB.DONE = "NEXT.MV"
IF K.C.L<K.H.L + 1 AND K.R(K.C.L) = 1 THEN
GOSUB IA.LOAD.CONTROL
END ELSE
PRINT @(F.Z1,L.M):CLL:RVB:"Sorry ":EI.U:", I am unable to access than KEY LEVEL.":RVE:;RQM
PRINT @(F.Z1,L.M):CLL:RVB:"ERROR AT ":PROG.SUB.NAME:RVE:;RQM
PRINT @(F.Z1,L.M):CLL:"Normal error when creating information.":;RQM
K.C.L = KEY.P.L
RETURN; *: *
END
END
IF FTB.DONE = "NEXT.MV" THEN
IF F.T EQ "D" AND FUNCT.SCAN THEN
IF C.R>NUMB.REC THEN RETURN
L.W = MAXM.FLD
END ELSE
IF F.T NE "D" THEN
IF EI.MV.AM # 0 THEN
NUMB.REC = NUMB.REC + 1
L.W = 1
END ELSE
NUMB.REC = 1
L.W = 0
END
C.R = NUMB.REC
FTB.DONE = "ADD.INFO"; F.T = "A"
END
END
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
GOSUB FOREGROUND.DISPLAY
PROG.SUB.NAME = "Entity Data Input Area"
END ELSE IF F.T EQ "D" AND NOT(LEN(LINE.ALPHA)) THEN
FTB.DONE = "DELETE.INFO"; F.T = "D"
*PRINT '(DELETE) ENTITY.DELETE.INFO'
*INPUT TEMP
*IF TEMP EQ 'END' THEN STOP
L.W = 1
*FUNCT.SCAN = ""
END
* IF FTB.DONE EQ "ADD.INFO" OR (F.T EQ "D" AND (FUNCT.SCAN OR LEN(LINE.ALPHA))) THEN
IF F.T EQ "A" OR (F.T EQ "D" AND FUNCT.SCAN) OR LEN(LINE.ALPHA) THEN
* * IA.C(4,L.W)<1,1,1> is Row/Column/Normal
* * IA.C(4,L.W)<1,1,2> is the L.W to jump to
* * IA.C(4,L.W)<1,1,6> is the controling L.W
L.W = L.W + 1
IF L.W>MAXM.FLD THEN
* IF F.T EQ "D" THEN
IF F.T EQ "D" THEN
IF NOT(LEN(LINE.ALPHA)) THEN
IF FUNCT.SCAN THEN
GOSUB  ENTITY.DELETE.AREA
END
IF FUNCT.SCAN.INP = "Q" THEN
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
RETURN; *: *
END
IF FUNCT.SCAN.INP = "N" & EI.MV.AM # 0 THEN
C.R = C.R + 1
EI.REC(EI.MV.AM)<1,K.C.L> = C.R
END
END ELSE LINE.ALPHA = ""
GOTO T.of.ic
END
FTB.DONE = "NEXT.MV.MOD"
END ELSE
* TEMP = ""
* IF FTB.DONE EQ "ADD.INFO" THEN
IF F.T EQ "A" THEN
IF LEN(EI.CR.AM) GT 1 AND NOT(INDEX(EI.CR.AM,"-":L.W:"-",1)) THEN
PRINT @(F.Z1,L.E):CLL:"   ":L.W:" not for input on add.":
IF NOT(SYSTEM(11)) THEN RQM
PRINT @(F.Z1,L.E):CLL:
* TEMP = 1
IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
IF IA.C(4,L.W)<1,1,2> EQ IA.C(4,L.W)<1,1,6> THEN
L.W = IA.C(4,L.W)<1,1,6> - 1; LINE.ALPHA = ""
GOTO T.of.ic
END
END
*
END
END
* IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
* IF IA.C(4,L.W)<1,1,2> EQ IA.C(4,L.W)<1,1,6> THEN
* IF F.T EQ "A" THEN L.W = IA.C(4,L.W)<1,1,6> - 1; TEMP = 1
* IF F.T NE "D" THEN LINE.ALPHA = ""
* END
* END
* IF TEMP THEN GOTO T.of.ic
END
****************************************INSERT SPECIAL PROCESSING
END
IF FTB.DONE # "ADD.INFO" THEN
IF F.T EQ "D" AND FUNCT.SCAN THEN
LINE.ALPHA = 1
END ELSE
IF LEN(LINE.ALPHA) = 0 THEN
LINE.ALPHA = ""
PRINT @(F.Z1,L.E):CLL:@(F.Z4,L.E):CLL:"Which line?":
INPUT @(F.Z4+12,L.E):LINE.ALPHA
END
END
IF LINE.ALPHA = "" THEN LINE.ALPHA = 0
IF LINE.ALPHA = "END" ! LINE.ALPHA = "CAN" THEN
F.T = "END"
IF LINE.ALPHA = "CAN" THEN F.T = "CAN"; REC.STATUS = 7
LINE.ALPHA = 0
RETURN; *: *
END ELSE
SUB.L.W = 0
IF LINE.ALPHA[1,1] NE "-" AND NOT(NUM(LINE.ALPHA[1,1])) THEN
SUB.FUNCT = LINE.ALPHA [1,1]
IF NOT(INDEX("*A*M*D*N*B*","*":SUB.FUNCT:"*",1)) THEN SUB.FUNCT = ""; LINE.ALPHA = ""; GOTO T.of.ic
LINE.ALPHA = LINE.ALPHA[2,99]
END ELSE SUB.FUNCT = F.T
IF FIELD(LINE.ALPHA,"-",2) # "" THEN
SUB.L.W = FIELD(LINE.ALPHA,"-",2)
IF NOT(NUM(SUB.L.W)) THEN SUB.L.W = 0
END
TEMP = FIELD(LINE.ALPHA,"-",1)
IF LEN(TEMP) THEN
L.W = FIELD(LINE.ALPHA,"-",1)
IF NOT(NUM(L.W)) THEN LINE.ALPHA = ""; GOTO T.of.ic
LINE.ALPHA = LINE.ALPHA[COL2(),99]
IF L.W THEN
TEMP = IA.C(4,L.W)<1,1,6>
IF F.T EQ "D" AND TEMP NE L.W THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", you must do a line delete on the controlling field (":TEMP:").":; RQM
LINE.ALPHA = ""; GOTO T.of.ic
END
END
END
* IF NOT(NUM(L.W)) THEN LINE.ALPHA = ""; GOTO T.of.ic
*IF SUB.FUNCT = "N" THEN SD.PAGE<1,1> = "Y"
SD.PAGE<1,1> = "Y"
IF L.W = 0 THEN
IF FTB.DONE = "NEXT.MV.MOD" THEN
FTB.DONE = "NEXT.MV"
IF EI.MV.AM = 0 THEN FTB.DONE = "NEXT.IA"
GOTO T.of.ic
END
RETURN; *: *
END
IF L.W>20 ! L.W<1 THEN LINE.ALPHA = ""; GOTO T.of.ic
IF IA.C(3,L.W) = "" ! IA.C(3,L.W) = 0 THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", that is an unaccessable field!":; RQM
LINE.ALPHA = ""; GOTO T.of.ic
END
END
END
GOSUB INPUT.FLD
IF F.T EQ "D" AND ((NOT(FUNCT.SCAN) OR FUNCT.SCAN.INP EQ "Q") AND NOT(LEN(LINE.ALPHA))) THEN RETURN
IF (F.T EQ "D" AND NOT(LEN(LINE.ALPHA))) OR (CTC.ERR EQ 9 AND F.T EQ "A") THEN
LINE.ALPHA = ""
IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
IF L.W NE IA.C(4,L.W)<1,1,2> THEN L.W = IA.C(4,L.W)<1,1,2> - 1
END
END ELSE
IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
IF IA.C(4,L.W)<1,1,2> EQ IA.C(4,L.W)<1,1,6> THEN
IF L.W NE IA.C(4,L.W)<1,1,2> THEN L.W = IA.C(4,L.W)<1,1,2> - 1
LINE.ALPHA = ""
END
END ELSE LINE.ALPHA = ""
END
IF F.T EQ "D" AND NOT(LEN(LINE.ALPHA)) THEN RETURN
IF F.T EQ "D" THEN GOTO T.of.ic
IF F.T EQ "M" THEN GOTO T.of.ic
LINE.ALPHA = ""; GOTO T.of.ic
*
INPUT.FLD: *#*
*
GOSUB IA.FIELD.CONTROL
****************************************INSERT DOC.
1790 ENTITY.INPUT.VALUE = ""
IF L.W = 1 & EI.MV.AM # 0 THEN
INPUT @(C.P,L.P+L.A):ENTITY.INPUT.VALUE
IF NOT(NUM(ENTITY.INPUT.VALUE)) ! LEN(ENTITY.INPUT.VALUE) = 0 THEN
ENTITY.INPUT.VALUE = 1
END
*
*
IF ENTITY.INPUT.VALUE > NUMB.REC ! ENTITY.INPUT.VALUE < 1 THEN
IF ENTITY.INPUT.VALUE > NUMB.REC & NUMB.REC # 0 THEN
F.T = "A"
END ELSE
IF NUMB.REC = 0 THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", the info. area ":TB.L(K.C.L)<1,1,1>:" must be (A)dded."; RQM
END ELSE
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", that is not a valid ":TB.L(K.C.L)<1,1,1>:" number!":; RQM
END
FTB.DONE = "MODIFY.INFO"
RETURN; *: *
END
END
*
*
IF ENTITY.INPUT.VALUE > NUMB.REC & F.T = "A" THEN
FTB.DONE = "NEXT.MV"
ENTITY.INPUT.VALUE = NUMB.REC + 1
GOSUB CONTROL.DISPLAY
RETURN; *: *
END
*
*
C.R = ENTITY.INPUT.VALUE
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
IA.C.RESET = 1
GOSUB FOREGROUND.DISPLAY
PROG.SUB.NAME = "Entity Data Input Area"
END ELSE
IF L.W NE 0 AND NOT(F.T EQ "D" AND NOT(LEN(LINE.ALPHA))) THEN
****************** INSERT SPECIAL PROCESSING
IF IA.C(4,L.W)<1,1,1> = "R" ! IA.C(4,L.W)<1,1,1> = "C" THEN
IF NOT(LEN(SUB.FUNCT)) THEN SUB.FUNCT = F.T
FTYPE = SUB.FUNCT
IF SUB.FUNCT EQ "D" THEN F.T = "D"
IF LEN(SUB.L.W) = 0 THEN SUB.L.W = 0
GOSUB SPEC.DISP.CALL
* IF L.W EQ IA.C(4,L.W)<1,1,6> THEN
* IA.C(5,L.W)<1,1,6> = CNTR<1,1,6>
* IA.C(5,L.W)<1,1,7> = CNTR<1,1,7>
* IF (F.T EQ "D" AND NOT(LEN(LINE.ALPHA))) OR (CTC.ERR EQ 9 AND F.T EQ "A") THEN
* L.W = IA.C(4,L.W)<1,1,2> - 1
* LINE.ALPHA = ""
* END
* END
END ELSE
INPUT @(C.P,L.P+L.A):ENTITY.INPUT.VALUE
IF FTB.DONE = "INPUT.KEY" THEN RETURN
IF LEN(ENTITY.INPUT.VALUE) # 0 THEN
IF EI.MV.AM = 0 THEN
EI.REC(CT.ATT)<1,FILE.MV,CT.SVL> = ENTITY.INPUT.VALUE
END ELSE
EI.REC(CT.ATT)<1,C.R,CT.SVL> = ENTITY.INPUT.VALUE
END
END
IF REC.STATUS = 2 THEN REC.STATUS = 3; GOSUB CONTROL.DISPLAY
END
IF L.W = 2 & FTB.DONE = "ADD.INFO" & EI.MV.AM # 0 THEN 
IF ENTITY.INPUT.VALUE = "" THEN
IF FTB.DONE = "ADD.INFO" & REC.STATUS = 1 THEN
FTB.DONE = "NEXT.IA"
END ELSE
FTB.DONE = "MODIFY.INFO"
END
NUMB.REC = NUMB.REC-1
C.R = NUMB.REC
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
GOSUB FOREGROUND.DISPLAY
PROG.SUB.NAME = "Entity Data Input Area"
END
END
!
*  INSERT SPECIAL PROCESSING
*
*IF TEMP.C = 1 ! TEMP.C = 0 AND ENTITY.INPUT.VALUE = "END" THEN
**?
*END
!
END
END
IF F.T = "D" AND NOT(LEN(LINE.ALPHA)) THEN
IF EI.MV.AM # 0 THEN
GOSUB ENTITY.DELETE.AREA
IF FUNCT.SCAN.INP = "Q" THEN RETURN
FTB.DONE = "NEXT.MV"
END ELSE
GOSUB ENTITY.DELETE.RECORD
END
END
RETURN; *: *
*
ERROR.ON.DISPLAY: *@*
*
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", I am unable to display that KEY LEVEL.":
RETURN; *: *
*
ACTION.SELECT: *@* INPUT FUNCTION SUBROUTINE
*
2100 PROG.SUB.NAME = "Input function"
*PRINT @(F.Z1,L.M):CLL:
PRINT @(F.Z1,L.E):CLL:"ACTION (":
CN1 = 1
LOOP CN1 = CN1+1 WHILE TB.F.DESC(CN1) # "" DO
IF CN1 > 2 THEN PRINT ", ":
PRINT TB.F.DESC(CN1)[2,1]:
REPEAT
PRINT " or <CR> = U): ":
F.T = "U"
L.W = 0; SUB.L.W = 0; SUB.FUNCT = ""
INPUT F.T:
IF LEN(F.T) = 0 THEN F.T = "U"
IF F.T = "END" ! F.T = "CAN" THEN RETURN
LINE.ALPHA = F.T[2,10]
F.T = F.T[1,1]
CN1 = 1; CN2 = ""
LOOP CN1 = CN1+1 WHILE TB.F.DESC(CN1) # "" & NOT(CN2) DO
IF INDEX(TB.F.DESC(CN1),"(":F.T:")",1) THEN CN2 = CN1
REPEAT
IF NOT(CN2) THEN
FUNCT.NUMBER = 8
PRINT @(F.Z1,L.M):CLL:BELL:RVB:"Sorry ":EI.U:", you have enterid an invalid function":RVE:; RQM
GOSUB CONTROL.DISPLAY
GOTO 2100
END ELSE
FUNCT.NUMBER = CN2
*PRINT @(F.Z1,L.E):CLL:
GOSUB CONTROL.DISPLAY
PROG.SUB.NAME = "Input function"
END
IF (F.T = "D" AND LINE.ALPHA NE "") OR F.T = "L" THEN
*IF F.T = "D" THEN
*PRINT "Delete the entire item? ":
*INPUT ANS
*IF ANS EQ "Y" THEN
*GOSUB ENTITY.DELETE.RECORD
*REC.STATUS = 7
*RETURN
*END
*END ELSE IF EI.MV.AM NE 0 THEN F.T = ""
IF EI.MV.AM NE 0 THEN
PRINT @(F.Z1,L.E):CLL:"(C) Choose or <CR> = (S) Scan :":
FUNCT.SCAN.INP = ""
INPUT @(F.Z3,L.E):FUNCT.SCAN.INP
IF FUNCT.SCAN.INP = "" THEN FUNCT.SCAN.INP = "S"
IF FUNCT.SCAN.INP = "S" THEN FUNCT.SCAN = 1 ELSE
IF FUNCT.SCAN.INP = "C" THEN FUNCT.SCAN = "" ELSE
GOTO 2100
END
END
END
END
RETURN; *: *
*
*@* LIST ENTITY ON SCREEN SUBROUTINE
*
SCREEN.LISTING.AREA: *@*
PROG.SUB.NAME = "Screen Entity List"
RETURN; *: *
*
*@* PRINT ENTITY ON PRINTER SUBROUTINE
*
PRINTER.LISTING.AREA: *@*
PROG.SUB.NAME = "Printer Entity List"
RETURN; *: *
*
IA.LOAD.CONTROL: *@*
*
IF K.R(K.C.L) = 0 THEN K.C.L = KEY.DF.L
F.ERR = ""
IF KEY.P.L # K.C.L ! F.TIME THEN
CN1 = ""
LOOP WHILE NOT(CN1) ! (F.ERR & CN1 & K.C.L # KEY.DF.L) DO
IF F.ERR THEN K.C.L = KEY.DF.L
CALL S.I.T.INFO.EI 
CN1 = 1
REPEAT
EI.FI.VL = TB.L(K.C.L)<1,1,3>
EI.SK.FL = TB.L(K.C.L)<1,1,4>
EI.MV.AM = TB.L(K.C.L)<1,1,5>
MAXM.FLD = TB.L(K.C.L)<1,1,6>
L.A = TB.L(K.C.L)<1,1,7>
EI.KL.AM = TB.L(K.C.L)<1,1,8>
EI.ET.AM = TB.L(K.C.L)<1,1,9>
EI.CDT.AM = TB.L(K.C.L)<1,1,10>
EI.ADT.AM = TB.L(K.C.L)<1,1,11>
EI.PDT.AM = TB.L(K.C.L)<1,1,12>
EI.CR.AM = TB.L(K.C.L)<1,1,13>
*
GOSUB BACKGROUND.DISPLAY
*
*
$INCLUDE IBP SUB.IO.OPEN.EI.ENTY
*
IF NOT(F.TIME) THEN
IF TB.L(KEY.P.L)<1,1,4> = 1 THEN
CN1 = 0
KEY.CN2 = 0
KEY.ENTITY.ID = ""
LOOP CN1 = CN1 + 1 WHILE CN1 < KEY.CN1 + 1 DO
KEY.ENTITY.ID<1,CN1> = FIELD(KEY.ENTITY,"@",CN1)
REPEAT
END
*
IF EI.SK.FL = 1 THEN GOSUB KEY.INPUT.SECONDARY
GOSUB KEY.DISPLAY
IF TB.FL THEN GOSUB ENTITY.READ
END
KEY.P.L = K.C.L
END
*
IF EI.MV.AM # 0 THEN
IF LEN(EI.REC(EI.MV.AM)<1,K.C.L>) = 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
IF EI.REC(EI.MV.AM)<1,K.C.L> = 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
END
K.D.L = K.C.L
GOSUB REC.COUNTER
IF EI.MV.AM # 0 THEN C.R = EI.REC(EI.MV.AM)<1,K.C.L> ELSE C.R = 1
IF EI.KL.AM # 0 THEN EI.REC(EI.KL.AM) = K.C.L
*IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
IA.C.RESET = 1
F.TIME = 0
RETURN; *: *
*
IA.FIELD.CONTROL: *#*
*
IF L.W # 0 THEN
C.P = IA.C(2,L.W)
L.P = IA.C(1,L.W)
SPEC = IA.C(4,L.W)
CNTR = IA.C(5,L.W)
IF SPEC<1,1,6> THEN
CNTR<1,1,6> = IA.C(5,SPEC<1,1,6>)<1,1,6>
CNTR<1,1,7> = IA.C(5,SPEC<1,1,6>)<1,1,7>
END
IF FTYPE EQ "d" THEN CNTR<1,1,3> = CNTR<1,1,1>
CT.ATT = IA.C(3,L.W)<1,1>
FILE.MV = IA.C(3,L.W)<1,2>
CT.SVL = IA.C(3,L.W)<1,3>
CT.4VL = IA.C(3,L.W)<1,4>
CT.5VL = IA.C(3,L.W)<1,5>
IF LEN(FILE.MV) = 0 THEN FILE.MV = 0
IF LEN(CT.SVL) = 0 THEN CT.SVL = 0
IF LEN(CT.4VL) = 0 THEN CT.4VL = 0
IF LEN(CT.5VL) = 0 THEN CT.5VL = 0
*IF SPEC<1,1,5> = "4V" OR SPEC<1,1,5> = "5V" THEN
*IF CT.ATT = 0 THEN CT.ATT = 1
*IF FILE.MV = 0 THEN FILE.MV = 1
*IF CT.SVL = 0 THEN CT.SVL = 1
*END
IF SPEC<1,1,1> = "K" & FTB.DONE # "INPUT.KEY" THEN RETURN
****************************************INSERT SPECIAL PROCESSING
END
RETURN; *: *
ENTITY.LIST.CONTROL: *#*
*
*#*
LIST.NEW.LO = ""
LIST.NEW.HI = ""
LIST.PROC.STAT = "I"
IF EI.RUN.TYPE > 2 THEN
PRINT @(F.Z1,L.M):CLL:"Enter starting ID string: ":; INPUT LIST.NEW.LO:
IF LIST.NEW.LO NE "" THEN
PRINT @(F.Z1,L.M):CLL:"Enter ending ID string: ":; INPUT LIST.NEW.HI:
IF LIST.NEW.HI EQ "" THEN LIST.NEW.HI = LIST.NEW.LO
END
LOOP
PRINT @(F.Z1,L.M):CLL:"What status will be processed? ":; INPUT LIST.PROC.STAT:
WHILE NOT(INDEX("*X*C*H*I*N*S**","*":LIST.PROC.STAT:"*",1)) DO REPEAT
IF LIST.PROC.STAT EQ "" THEN LIST.PROC.STAT = "*" ELSE
IF INDEX("*I*N*S**","*":LIST.PROC.STAT:"*",1) THEN LIST.PROC.STAT = "I"
END
END
KEY.LIST.CN = 0
ID = ""
RETURN; *: *
*
!
ENTITY.CONTROL: *#*
*
CONTR.FLAG = "N"
PRINT @(0,0):CLL:@(F.Z1,L.E):"CONTROL DISPLAY ON? ":;INPUT CONTR.FLAG:
IF LEN(CONTR.FLAG) = 0 THEN CONTR.FLAG = "N"
IF INDEX(YES,"*":CONTR.FLAG:"*",1) THEN CONTR.FLAG = 1 ELSE CONTR.FLAG = 0
IF NOT(KEYS.SL) THEN K.C.L = 0
GOSUB CONTROL.DISPLAY
GOSUB BACKGROUND.DISPLAY
*
FTYPE = ""
CALL SUB.KEY.SELECT.EI
IF FTYPE = "END" ! FTYPE = "CAN" THEN F.T = F.T; RETURN
GOSUB IA.LOAD.CONTROL
GOSUB CONTROL.DISPLAY
RETURN; *: *
*
CONTROL.DISPLAY: *@*
PRINT @(F.Z1,L.F):CLL:RVB:
IF CONTR.FLAG = "N" THEN RETURN
CN1 = K.C.L
IF LEN(CN1) = 0 ! CN1 = 0 THEN CN1 = 1
*PRINT @(F.Z1,L.F):TB.L(CN1)<1,1,1>[5,18]:
PRINT TB.L(CN1)<1,1,1> "L#20":
*PRINT @(F.Z2,L.F):TB.FTYPE(FUNCT.NUMBER)[1,18]:
PRINT TB.FTYPE(FUNCT.NUMBER) "L#20":
IF TB.L(CN1)<1,1,3> # "" THEN
*PRINT @(F.Z3,L.F):TB.L(CN1)<1,1,3>[1,18]:
PRINT TB.L(CN1)<1,1,3> "L#20":
END ELSE
*PRINT @(F.Z3,L.F):EI.P.F[1,18]:
PRINT EI.P.F "L#20":
END
*PRINT @(F.Z4,L.F):TB.STAT(REC.STATUS)[1,18]:RVE:
PRINT TB.STAT(REC.STATUS) "L#18":RVE:
RETURN
*
FOREGROUND.DISPLAY: *@*
*
IF K.R(K.C.L) = 1 THEN
K.D.L = K.C.L
C.D.R = C.R
IF C.D.R = 0 THEN C.D.R = 1
IF F.T # "A" THEN
FG.C.CALL = "SUB.SCREEN.CLEAR.":TB.L(K.C.L)<1,1,1>[5,30]
CALL @FG.C.CALL 
END
IF NUMB.REC = 0 THEN
GOSUB REC.COUNTER
END
GOSUB KEY.DISPLAY
IF NUMB.REC # 0 THEN
FG.D.CALL = "SUB.SCREEN.DISPL.":TB.L(K.C.L)<1,1,1>[5,30]
CALL @FG.D.CALL
SAVE.L.W = L.W
L.W = 0
LOOP L.W = L.W + 1 WHILE L.W < MAXM.FLD + 1 DO
IF IA.C(4,L.W)<1,1,1> = "R" ! IA.C(4,L.W)<1,1,1> = "C" THEN
SD.PAGE<1,1> = "N"
*SD.PAGE<1,2> = 0
IF IA.C.RESET = 1 THEN IA.C(5,L.W)<1,1,1> = 0
FTYPE = "d"
IF LEN(IA.C(5,L.W)<1,1,3>) = 0 THEN IA.C(5,L.W)<1,1,3> = 0
GOSUB IA.FIELD.CONTROL
GOSUB SPEC.DISP.CALL
END
REPEAT
L.W = SAVE.L.W
IA.C.RESET = 0
END
END
GOSUB CONTROL.DISPLAY
RETURN; *: *
*
*
BACKGROUND.DISPLAY: *@* DISPLAY BACKGROUND *@*
*
SP.NUM = 40 - (LEN(PROG.NAME)/2)
PRINT @(0,1):RVB:CLS:SPACE(SP.NUM):PROG.NAME:SPACE(SP.NUM-20):TIMEDATE()
SP.NUM = 40 - (LEN(EI.A)/2)
PRINT @(0,2):EI.U:SPACE(SP.NUM-LEN(EI.U)):EI.A:SPACE(SP.NUM)
*
IF K.C.L # 0 THEN
BG.D.CALL = "SUB.SCREEN.APPL.BKGRD.":EI.A
CALL @BG.D.CALL 
PRINT RVB:
IF K.R(K.C.L) = 1 THEN
BG.D.CALL = "SUB.SCREEN.BKGRD.":TB.L(K.C.L)<1,1,1>[5,30]
CALL @BG.D.CALL 
END
PRINT RVE:
END
RETURN; *: *
*
SPEC.DISP.CALL: *#*
*
IF SPEC<1,1,1> = "R" ! SPEC<1,1,1> = "C" THEN
CN4 = 0
IF EI.MV.AM # 0 THEN
CT.VAL = C.R
END ELSE
CT.VAL = FILE.MV
END
IF LEN(CNTR<1,1,1>) = 0 THEN CNTR<1,1,1> = 0
IF LEN(CNTR<1,1,2>) = 0 THEN CNTR<1,1,2> = SPEC<1,1,5>
CNTR<1,1,3> = SUB.L.W
CNTR<1,1,4> = SD.PAGE<1,1>
IF LEN(CNTR<1,1,5>) = 0 THEN CNTR<1,1,5> = 0
IF NOT(INDEX("*A*M*D*N*B*","*":FTYPE:"*",1)) THEN FTYPE = "d"
CALL EI.SD
*
IA.C(5,L.W) = CNTR
IA.C(5,L.W)<1,1,3> = 0
IF SD.PAGE<1,1> = "N" THEN CNTR<1,1,4> = IA.C(5,L.W)<1,1,4>
*SD.PAGE<1,2> = CNTR<1,1,5>
*
*Returned last value from SPEC.DISP is in CNTR<1,1>. 
*The requested input or starting value (if applicable) was passed
END
RETURN; *: *
*
END.OF.PROGRAM.AREA: *@* END OF PROGRAM *@*
IF EI.RUN.TYPE = 2 THEN
CONT = 1
KEY.LIST.CN1 = KEY.LIST.CN - KEY.LIST.DEL
LOOP
READNEXT ID FROM ENTY.LIST ELSE CONT = 0
WHILE CONT DO
KEY.LIST = KEY.LIST:AM:ID:VM:"N":VM:DATE():VM:TIME():VM:WHO
KEY.LIST.CN1 = KEY.LIST.CN1 + 1
PRINT @(F.Z4,L.M):CLL:RVB:((KEY.LIST.CN1+10000) "R#4") "L#18":RVE:
REPEAT
END
IF EI.RUN.TYPE = 3 THEN KEY.LIST.CN1 = DCOUNT(KEY.LIST,AM)
IF EI.RUN.TYPE >= 2 THEN
*WRITE KEY.LIST ON KLIST,EI.A.U
PRINT @(F.Z1,L.M):CLL:KEY.LIST.CN1:" items remaining of a total of ":(KEY.LIST.CN1 + KEY.LIST.DEL):" items.":
RQM; RQM; RQM; RQM
YES.NO = ""
PRINT @(F.Z1,L.M):CLL:"Do you want to save the changed list? ":;INPUT YES.NO:
IF NOT(INDEX(NO,"*":YES.NO:"*",1)) THEN
PRINT @(F.Z1,L.M):CLL:"Enter the list name if a new list: ":
NEW.NAME=""
INPUT NEW.NAME:
IF NEW.NAME NE "" THEN EI.A.U=NEW.NAME
WRITE KEY.LIST ON KLIST,EI.A.U
END
END
RETURN; *: *
*
99999   PROMPT "?"
END
~FILE.KEY.CONVERT~
*PROGRAM: FILE.KEY.CONVERT
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
SYS.PROG = 'FILE.KEY.CONVERT'
SYS.LOCT = ''
SYS.SLOC = ''
RUN.DATE = DATE()
RUN.TIME = TIME()
Start.of.prog: *
PRINT @(0,5):CLS:@(0,7):
PRINT 'Enter "FROM" file name: ':; INPUT INP.FILE.NAME:
IF INP.FILE.NAME = "" OR INP.FILE.NAME = "END" THEN STOP
PRINT @(0,9):'Enter "TO" file name: ':; INPUT OUT.FILE.NAME:
IF OUT.FILE.NAME = "" THEN GOTO Start.of.prog
PRINTER CLOSE
EXECUTE "SP-ASSIGN HS"
PRINTER ON
PRINT FF:SYS.PROG
PRINT
PRINT
PRINT OCONV(RUN.DATE,'D2'):'     ':OCONV(RUN.TIME,'MTS'):
PRINT
PRINT '"FROM" file name: ':INP.FILE.NAME
PRINT
PRINT '"TO" file name: ':OUT.FILE.NAME
PRINT
PRINTER OFF
OPEN INP.FILE.NAME TO INP.FILE ELSE GOTO Start.of.prog
OPEN OUT.FILE.NAME TO OUT.FILE ELSE GOTO Start.of.prog
CONT = 1
INP.DELETE = 0
PRINT @(40,7):'Enter old key prefix: ':; INPUT INP.PREFIX:
PRINT @(40,9):'Enter new key prefix: ':; INPUT OUT.PREFIX:
PRINT @(0,11):BELL:'Delete "FROM" records? ':; INPUT INP.DELETE:
IF INP.DELETE = "YES" THEN INP.DELETE = 1
IF NOT(NUM(INP.DELETE)) THEN INP.DELETE = 0
IF INP.DELETE # 1 THEN INP.DELETE = 0
PRINT @(0,13):"OK to continue? ":; INPUT RSP:
IF RSP # "Y" THEN STOP
PRINTER ON
PRINT; PRINT "INP.DELETE: ":INP.DELETE
PRINT; PRINT "INP PREFIX: ":INP.PREFIX
PRINT; PRINT "OUT PREFIX: ":OUT.PREFIX
PRINT; PRINT; PRINT; PRINT
INP.K.L = LEN(INP.PREFIX)
OUT.K.L = LEN(OUT.PREFIX)
LOOP
READNEXT ID ELSE CONT = 0
WHILE CONT DO
IF ID[1,INP.K.L] = INP.PREFIX THEN
*
READ INP.REC FROM INP.FILE,ID THEN
*
ID.SUFFIX = ID[INP.K.L+1,99]
WRITE INP.REC ON OUT.FILE,OUT.PREFIX:ID.SUFFIX
PRINTER ON
PRINT ID "L#15":" COPIED TO ":OUT.PREFIX:ID.SUFFIX:"<"
PRINTER OFF
PRINT ID "L#15":" COPIED TO ":OUT.PREFIX:ID.SUFFIX:"<"
*
IF INP.DELETE THEN
DELETE INP.FILE,ID
PRINTER ON
PRINT ID "L#15":" DELETED<"
PRINTER OFF
PRINT ID "L#15":" DELETED<"
END
*
*
END ELSE
PRINT "Record not found on old file!  Key: ":ID:"   ":; INPUT CONT
PRINTER ON
PRINT "Record not found on old file!  Key: ":ID
PRINTER OFF
END
*
*
END ELSE
PRINTER ON
PRINT ID "L#15":" is bypassed because of the key prefix<"
PRINTER OFF
PRINT ID "L#15":" is bypassed because of the key prefix<"
END
*
REPEAT
GOTO Start.of.prog
END
~HELLO~
*PROGRAM: HELLO
*
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT
PRINT "Hi !"
PRINT
*
END
~HI~
*PROGRAM: HI
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT
PRINT "Hi !"
PRINT
*
END
~LABEL.RTN~
SUBROUTINE LABEL.RTN(ERROR)
*SUBROUTINE: LABEL.RTN
*
$INCLUDE IBP CG.COMMON.VARIABLES
$INCLUDE IBP STANDARD.FUNCTIONS
*
**9204***** DIM LNVL(10)
MAT LNVL = ''
PROG.NAME = 'Label printing'
OPEN 'CODES' TO CD.FILE ELSE
PROGRAM.CONTROL = 'STOP'
RETURN
END
IF KEY.COUNTER < 2 THEN
*SP.RESULT = ''
*EXECUTE 'SP-ASSIGN I R1', //OUT. > SP.RESULT
*IF LEN(SP.RESULT) > 1 THEN PRINT 'SP.RESULT: ':SP.RESULT:'. Enter <CR>.':; INPUT A$:
MAT LNVL = STR('X',35)
LNVL(6) = ''
PRINT @(0,5):CLS:@(10,6):PROG.NAME:
PRINT @(0,8):CLL:'Mount labels on printer and enter <CR> ':
INPUT A$:
CN = 0; RSP = 'N'
LOOP CN = CN + 1 WHILE RSP # 'Y' DO
GOSUB Pr.rtn
PRINT @(0,8):CLL:'Is alignment correct? ':
INPUT RSP:
IF INDEX('*Y*YES*y*yes*Yes*','*':RSP:'*',1) # 0 THEN RSP = 'Y' ELSE
PRINT @(10,10):CLL:'Enter the number of line to shift printing or':
PRINT @(10,11):CLL:'align labels and enter <CR>. I will print another mask. ':
INPUT MSK.LN:
IF LEN(MSK.LN) = 0 THEN MSK.LN = 'GO TEAM'
IF NUM(MSK.LN) THEN
PRINTER ON
FOR A = 1 TO (6+MSK.LN)
PRINT ON 1 '<'
NEXT A
PRINTER OFF
END
END
REPEAT
END
CN = 0
LOOP
KEY.LNVL = 1
MAT LNVL = ''
CN = CN + 1
WHILE IN.FILE(3)<1,CN> # '' DO
IF IN.FILE(3)<1,CN> = 'MAIL' THEN
LNVL(KEY.LNVL) = IN.KEY.VL
IF IN.FILE(14)<1,CN> # '' THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):' care of ':IN.FILE(14)<1,CN>
END
KEY.LNVL = KEY.LNVL + 1
*
IF IN.FILE(4)<1,CN> # '' THEN LNVL(KEY.LNVL) = '# ':IN.FILE(4)<1,CN>:' - '
*
IF IN.FILE(5)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Street address missing on ':IN.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(5)<1,CN>:' '
*
IF IN.FILE(6)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Street name missing on ':IN.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(6)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
END
*
*
IF IN.FILE(7)<1,CN> # '' & IN.FILE(7)<1,CN> # ' ' THEN
LNVL(KEY.LNVL) = IN.FILE(7)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
*
IF IN.FILE(8)<1,CN> = '' THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'City missing on ':IN.KEY.VL
END ELSE
READV CITY FROM CD.FILE,'030@':IN.FILE(8)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):CITY:', '
*
IF IN.FILE(9)<1,CN> = '' THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Province missing on ':IN.KEY.VL
END ELSE
READV PROV FROM CD.FILE,'020@':IN.FILE(9)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):PROV
KEY.LNVL = KEY.LNVL + 1
END ELSE
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Province master record missing on ':IN.KEY.VL
END
END
*
END ELSE
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'City master record missing on ':IN.KEY.VL
END
END
*
IF IN.FILE(11)<1,CN> = '' THEN
*PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Postal code missing on ':IN.KEY.VL
END ELSE
LNVL(KEY.LNVL) = IN.FILE(11)<1,CN>
END
*
IF KEY.LNVL > 5 THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Maximum number of lines for a label execeeded'
CALL.COMM=CALL.COMM:AM:'( ':KEY.LNVL:' lines present on ':IN.KEY.VL
END ELSE GOSUB Pr.rtn
END
REPEAT
LOOP WHILE CALL.COMM[1,1] = AM DO CALL.COMM=CALL.COMM[2,999] REPEAT
RETURN
!
*
Po.box: *#*
*
LNVL(KEY.LNVL) = ''
IF IN.FILE(12)<1,CN> = '' THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'P O Box missing on ':IN.KEY.VL
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(11)<1,CN>:' '
*
IF IN.FILE(13)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Station missing from P O Box on ':IN.KEY.VL
END ELSE LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(12)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
RETURN
!
*
Pr.rtn: *#*
PRINTER ON
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE CN2 < 7 DO PRINT ON 1 LNVL(CN2) REPEAT
PRINTER OFF
RETURN
*
END
~MAIL.TO.EMPL.CONVERT~
*PROGRAM: MAIL.TO.EMPL.CONVERT
*
DIM IN.ENTITY(100), OUT.ENTITY(100)
MAT OUT.ENTITY = ''
MAT IN.ENTITY = ''
IN.FILE.NAME = 'MAIL.ADDR.DATA'
OUT.FILE.NAME = 'EMPL.PROSPECTS'
PROGRAM.CONTROL = 'CONTINUE'
DELETE.FLAG = 'NO'
KEY.COUNTER = 0
WORK.LIST = ''
LOCT = 1
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN 'SYS.STRUCTURE' TO SYSS ELSE STOP
LOCT = 2
OPEN IN.FILE.NAME TO IN.FILE ELSE PRINT '?'; STOP
LOCT = 3
OPEN OUT.FILE.NAME TO OUT.FILE ELSE PRINT '??'; STOP
LOCT = 5
OPEN 'CAREER.LISTS' TO LS.FILE ELSE PRINT '???'; STOP
LOCT = 6
PRINT @(0,0):CLS:@(20,10):'Enter list to transfer':
INPUT LIST.NAME:
PRINT @(20,15):'You have asked for ':LIST.NAME:'.'
PRINT @(20,16):'Transfer from ':IN.FILE.NAME:' to ':OUT.FILE.NAME:'.':
PRINT @(20,18):'Is this correct? ':; INPUT A$:
IF A$ # 'YES' & A$ # 'Y' THEN GOTO End.of.program
READ LIST.VAR FROM LS.FILE,LIST.NAME ELSE PRINT '????'; GOTO End.of.program
SELECT LIST.VAR
LOCT = 7
KEY.COUNTER = 0
Del.flag: *
PRINT @(0,0):CLS:@(20,10):'I will proceed.':
PRINT @(20,12):'Do you want to Delete (YES/NO)? ':; INPUT DELETE.FLAG:
IF DELETE.FLAG # 'YES' & DELETE.FLAG # 'NO' THEN GOTO Del.flag
PRINT @(0,0):CLS:@(0,0):'Entity transfer started'
PRINT @(0,10):
CURR.LINE = 10
LOOP
READNEXT KEY.ID ELSE PROGRAM.CONTROL = 'STOP'
WHILE PROGRAM.CONTROL # 'STOP'  DO
KEY.COUNTER = KEY.COUNTER + 1
MATREAD IN.ENTITY FROM IN.FILE,KEY.ID THEN
MAT OUT.ENTITY = ''
WORK.FLAG = 0
OUT.ENTITY(1) = IN.ENTITY(1)
CN = 0
LOOP CN = CN + 1 WHILE OUT.ENTITY(1)<1,CN> # '' DO
IF LEN(OUT.ENTITY(1)<1,CN>) > 4 THEN WORK.FLAG = 1
REPEAT
CN = 0; CN1 = 0
LOOP CN = CN + 1 WHILE CN < 2 ! IN.ENTITY(6)<1,CN> # '' DO
IF IN.ENTITY(6)<1,CN> # '' OR IN.ENTITY(11)<1,CN> # '' THEN
CN1 = CN1 + 1
OUT.ENTITY(3)<1,CN1> = IN.ENTITY(6)<1,CN>
OUT.ENTITY(4)<1,CN1> = IN.ENTITY(7)<1,CN>
OUT.ENTITY(5)<1,CN1> = IN.ENTITY(8)<1,CN>
OUT.ENTITY(6)<1,CN1> = IN.ENTITY(9)<1,CN>
OUT.ENTITY(7)<1,CN1> = ' '
OUT.ENTITY(8)<1,CN1> = IN.ENTITY(10)<1,CN>
OUT.ENTITY(9)<1,CN1> = IN.ENTITY(11)<1,CN>
OUT.ENTITY(10)<1,CN1> = IN.ENTITY(12)<1,CN>
OUT.ENTITY(11)<1,CN1> = IN.ENTITY(13)<1,CN>
OUT.ENTITY(12)<1,CN1> = IN.ENTITY(14)<1,CN>
OUT.ENTITY(13)<1,CN1> = IN.ENTITY(15)<1,CN>
OUT.ENTITY(14)<1,CN1> = IN.ENTITY(17)<1,CN>
OUT.ENTITY(15)<1,CN1,1> = ' '
OUT.ENTITY(15)<1,CN1,2> = IN.ENTITY(16)<1,CN>
OUT.ENTITY(15)<1,CN1,3> = ' '
IF NOT(OUT.ENTITY(15)<1,CN1,2> MATCHES '7N') & NOT(OUT.ENTITY(15)<1,CN1,2> MATCHES '3N"-"4N')THEN WORK.FLAG = 1
IF IN.ENTITY(6)<1,CN> = '' OR IN.ENTITY(6)<1,CN> = ' ' THEN WORK.FLAG = 1
END
REPEAT
OUT.ENTITY(2) = CN1
CN = 0; CN1 = 0
LOOP CN = CN + 1 WHILE CN < 2 OR IN.ENTITY(2)<1,CN> # '' DO
IF IN.ENTITY(2)<1,CN> # '' & IN.ENTITY(2)<1,CN> # ' ' THEN
CN1 = CN1 + 1
OUT.ENTITY(17)<1,CN1> = IN.ENTITY(2)<1,CN>
OUT.ENTITY(18)<1,CN1> = IN.ENTITY(4)<1,CN>
OUT.ENTITY(19)<1,CN1> = ' '
OUT.ENTITY(16)<1,CN1> = IN.ENTITY(5)<1,CN>
END
REPEAT
MATWRITE OUT.ENTITY ON OUT.FILE,KEY.ID
IF WORK.FLAG = 1 THEN WORK.LIST = WORK.LIST:KEY.ID:AM
IF DELETE.FLAG = 'YES' THEN DELETE IN.FILE,KEY.ID
END
PRINT '*':
IF KEY.COUNTER - (INT(KEY.COUNTER/25)*25) = 0 THEN
PRINT ' ':KEY.COUNTER:@(40):KEY.ID[1,38]:
CURR.LINE = CURR.LINE + 1
IF CURR.LINE > 19 THEN CURR.LINE = 1
PRINT @(0,CURR.LINE):CLL:
END
IF KEY.COUNTER < 3  THEN RQM;RQM
REPEAT
WRITE WORK.LIST ON LS.FILE,'@LIST@WORK'
End.of.program: *
PRINT; PRINT; PRINT; PRINT @(20):'Thank you very much, ':KEY.COUNTER:' records transfered.':
END
~MAINT.AR.CLNT.FORMAT~
*PROGRAM: SH.MAINT.AR.CLNT.FORMAT
*
* AUTHOR:            DAVID G. HORSMAN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
*                    COURTESY OF AXION COMPUTER SOFTWARE
*              SOURCEGEN & SCREEN.HANDLER (C) 1989 AXION COMPUTER SOFTWARE
* DATE WRITTEN:      19 SEP 89
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "LAW.AR.CLNT.FORMAT" TO LAW.AR.CLNT.FORMAT.FILE ELSE TEXT = "Can't open LAW.AR.CLNT.FORMAT"; GOSUB ERROR; STOP
OPEN "LAW.CLNT.MAST" TO LAW.CLNT.MAST.FILE ELSE TEXT = "Can't open LAW.CLNT.MAST"; GOSUB ERROR; STOP
OPEN "JB.LAW.PARMS" TO JB.LAW.PARMS.FILE ELSE TEXT = "Can't open JB.LAW.PARMS"; GOSUB ERROR; STOP
*
READV CO.NAME FROM JB.LAW.PARMS.FILE,"INTEREST.AND.MESSAGE", 7 ELSE CO.NAME = "COMPANY NOT ON FILE"
*
READ CLIENT.STAT.FORMATS FROM JB.LAW.PARMS.FILE,"CLIENT.STAT.FORMATS" ELSE CLIENT.STAT.FORMATS = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(1)
VALID.REFS = "PF"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
LAW.AR.CLNT.FORMAT.ID = ""; GOSUB GET.KEY; IF LAW.AR.CLNT.FORMAT.ID = "" THEN STOP
READ LAW.CLNT.MAST FROM LAW.CLNT.MAST.FILE,LAW.AR.CLNT.FORMAT.ID ELSE
PRINT CLB:"The Client is missing! Enter <cr> . . . ":; INPUT RSP:
GOTO NEXT.ITEM
END
READU LAW.AR.CLNT.FORMAT FROM LAW.AR.CLNT.FORMAT.FILE,LAW.AR.CLNT.FORMAT.ID THEN NEW = "" ELSE NEW = 1; LAW.AR.CLNT.FORMAT = ""
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = LAW.AR.CLNT.FORMAT.ID; LAW.AR.CLNT.FORMAT.ID = "!":LAW.AR.CLNT.FORMAT.ID; GOSUB GET.KEY; LAW.AR.CLNT.FORMAT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
GOTO NEXT.ITEM
END
END ELSE
PRINT @(20,6):LAW.CLNT.MAST<5> "L#40":
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "CANCEL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 1
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT CLB:"Enter CHange, DElete, REdisplay, CANCEL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "CANCEL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "CANCEL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE LAW.AR.CLNT.FORMAT.FILE,LAW.AR.CLNT.FORMAT.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = LAW.AR.CLNT.FORMAT.ID; LAW.AR.CLNT.FORMAT.ID = "!":LAW.AR.CLNT.FORMAT.ID; GOSUB GET.KEY; LAW.AR.CLNT.FORMAT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE LAW.AR.CLNT.FORMAT ON LAW.AR.CLNT.FORMAT.FILE,LAW.AR.CLNT.FORMAT.ID
UPDATED = 1
!
UNLOCK: *
RELEASE LAW.AR.CLNT.FORMAT.FILE, LAW.AR.CLNT.FORMAT.ID
GOTO NEXT.ITEM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                      Client Statement Format Maintenance                       ":RVE:
PRINT @(0,5):RVB:"Client Number     ":RVE:
PRINT @(0,6):RVB:"Client Name       ":RVE:
PRINT @(0,8):RVB:"PF> Print Format  ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(20,6):LAW.CLNT.MAST<5> "L#40":
PRINT @(20,8):LAW.AR.CLNT.FORMAT<1> "L#1":; LN = 8; GOSUB T01
RETURN
!
GET.KEY: *
CALL INPUT.DATA(LAW.AR.CLNT.FORMAT.ID,20,5,"L7",1,"","OP":VM:"LF":SVM:"0":SVM:"7","",RSP,STAT)
IF STAT = 999 THEN RETURN
RETURN
!
GET.DATA: *
ON REF GOSUB I01
RETURN
!
I01: CALL INPUT.DATA(LAW.AR.CLNT.FORMAT,20,8,"L1",1,"","DF":SVM:"S":VM:"EQ":SVM:"D":SVM:"S":SVM:"N","",RSP,STAT)
IF STAT THEN RETURN ELSE LN = 8; GOSUB T01; RETURN
!
T01: TRN.FLD = LAW.AR.CLNT.FORMAT<1>
LOCATE TRN.FLD IN CLIENT.STAT.FORMATS<1> SETTING LOC THEN TRN.FLD = CLIENT.STAT.FORMATS<2,LOC> ELSE TRN.FLD = ""
PRINT @(25,LN):TRN.FLD "L#20":
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~MAINT.AR.STATEMENT.TABLE~
*PROGRAM: MAINT.AR.STATEMENT.TABLE
*
* CLIENT:            ROBERTSON, WARD, SEUDERMAN
*
*
* COMPANY:           JB INFORMATION TECHNIQUES INC.
*                    ______________________________
*
*
*
* AUTHOR:            DAVID G.HORSMAN
*                    Written under sub-contract
* CODE GENERATED COURTESY OF:  AXION COMPUTER SOFTWARE
*
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
*                                  (C) 1989             (C) 1989
*                       AXION COMPUTER SOFTWARE     AXION COMPUTER SOFTWARE
*
*
* DATE WRITTEN:      20 SEP 89
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "JB.LAW.PARMS" TO JB.LAW.PARMS.FILE ELSE TEXT = "Can't open JB.LAW.PARMS"; GOSUB ERROR; STOP
*
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(10)
VALID.REFS = "CO":AM:"M1":AM:"M2":AM:"CI":AM:"FB":AM:"RT":AM:"TE":AM:"CP":AM:"DT":AM:"AG"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
JB.LAW.PARMS.ID = ""; GOSUB GET.KEY; IF JB.LAW.PARMS.ID = "" THEN STOP
READU JB.LAW.PARMS FROM JB.LAW.PARMS.FILE,JB.LAW.PARMS.ID THEN NEW = "" ELSE NEW = 1; JB.LAW.PARMS = ""
CO.NAME = JB.LAW.PARMS<7>
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = JB.LAW.PARMS.ID; JB.LAW.PARMS.ID = "!":JB.LAW.PARMS.ID; GOSUB GET.KEY; JB.LAW.PARMS.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 10
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT CLB:"Enter screen ref., REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = JB.LAW.PARMS.ID; JB.LAW.PARMS.ID = "!":JB.LAW.PARMS.ID; GOSUB GET.KEY; JB.LAW.PARMS.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE JB.LAW.PARMS ON JB.LAW.PARMS.FILE,JB.LAW.PARMS.ID
UPDATED = 1
!
UNLOCK: *
RELEASE JB.LAW.PARMS.FILE, JB.LAW.PARMS.ID
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                        Statement Parameter Maintenance                         ":RVE:
PRINT @(0,3):RVB:"CO> Company Name    ":RVE:
PRINT @(0,5):RVB:"M1> Message Line 1  ":RVE:
PRINT @(0,8):RVB:"M2> Message Line 2  ":RVE:
PRINT @(0,11):RVB:"CI> Calculate Interest   ":RVE:
PRINT @(0,12):RVB:"FB> Calculate Per Fee Bil":RVE:
PRINT @(0,13):RVB:"RT> Monthly Rate to Use  ":RVE:
PRINT @(0,14):RVB:"TE> Terms in # of Days   ":RVE:
PRINT @(0,15):RVB:"CP> Compound Interest    ":RVE:
PRINT @(0,16):RVB:"DT> Detailed Printing    ":RVE:
PRINT @(0,17):RVB:"AG> Show Aged Totals     ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(25,3):JB.LAW.PARMS<7> "L#40":
PRINT @(4,6):JB.LAW.PARMS<4,1> "L#75":
PRINT @(4,9):JB.LAW.PARMS<4,2> "L#75":
PRINT @(30,11):JB.LAW.PARMS<1> "L#1":
PRINT @(30,12):JB.LAW.PARMS<2> "L#1":
PRINT @(30,13):JB.LAW.PARMS<5> "L#8":
PRINT @(30,14):JB.LAW.PARMS<6> "L#2":
PRINT @(30,15):JB.LAW.PARMS<3> "L#1":
PRINT @(30,16):JB.LAW.PARMS<8> "L#1":
PRINT @(30,17):JB.LAW.PARMS<9> "L#1":
RETURN
!
GET.KEY: *
JB.LAW.PARMS.ID = "INTEREST.AND.MESSAGE"
RETURN
!
GET.DATA: *
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07,I08,I09,I10
RETURN
!
I01: CALL INPUT.DATA(JB.LAW.PARMS,25,3,"L40",7,"","OP","",RSP,STAT); RETURN
CO.NAME = JB.LAW.PARMS<7>
I02: CALL INPUT.DATA(JB.LAW.PARMS,4,6,"L75",4:",":1,"","OP","",RSP,STAT); RETURN
I03: CALL INPUT.DATA(JB.LAW.PARMS,4,9,"L75",4:",":2,"","OP","",RSP,STAT); RETURN
I04: CALL INPUT.DATA(JB.LAW.PARMS,30,11,"L1",1,"","DF":SVM:"Y":VM:"EQ":SVM:"Y":SVM:"N","",RSP,STAT); RETURN
I05: CALL INPUT.DATA(JB.LAW.PARMS,30,12,"L1",2,"","DF":SVM:"Y":VM:"EQ":SVM:"Y":SVM:"N","",RSP,STAT); RETURN
I06: CALL INPUT.DATA(JB.LAW.PARMS,30,13,"L8",5,"","MA":SVM:"0N'.'0N","",RSP,STAT); RETURN
I07: CALL INPUT.DATA(JB.LAW.PARMS,30,14,"L2",6,"","DF":SVM:"10":VM:"MA":SVM:"1N":SVM:"2N","",RSP,STAT); RETURN
I08: CALL INPUT.DATA(JB.LAW.PARMS,30,15,"L1",3,"","DF":SVM:"Y":VM:"EQ":SVM:"Y":SVM:"N","",RSP,STAT); RETURN
I09: CALL INPUT.DATA(JB.LAW.PARMS,30,16,"L1",8,"","DF":SVM:"N":VM:"EQ":SVM:"Y":SVM:"N","",RSP,STAT); RETURN
I10: CALL INPUT.DATA(JB.LAW.PARMS,30,17,"L1",9,"","DF":SVM:"N":VM:"EQ":SVM:"Y":SVM:"N","",RSP,STAT); RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~MSG.SEND~
*PROGRAM: MSG.SEND
*
* AUTHOR: DAVID HORSMAN
*
* ACTION - LOCKED - YOU RECEIVE, NOT YET READY
*        - 1      - YOU RECEIVE, READY
*        - 0      - YOU INITIATE
*
* FOR YOUR PORT RECORD
* (ATR 1)
*
*2 IS MY LINE
*
*3 IS MY ACCT
*
*4 IS MY USER
*
*5 IS TRANSMITION TYPE
* 1 - FLIP/FLOP DIALOG (using a token)
* 2 - Q: & A:
* 3 - INTERUPT EITHER OF ABOVE (DEMAND TOKEN)
* 4 - TOKEN DEMANDED FROM ME (GIVE THE TOKEN AWAY)
* 5 - MEMO
* 6 - LETTER
* 7 - PHONE CALL
* 8 - PUBILE ANNOUNCEMENTS (P.A.)
* 9 - ?
*
*6 IS TOKEN
* 0 - NOT TAKEN
* 1 - MINE
* 2 - THEIRS
* 3 - DO NOT DISTURB ME (EXCEPT EMERGENCY OR URGENCY)
*
*7 (FOR TOKEN = 3) WHEN I WILL BE AVAILABLE NEXT.
*
*8 Person currently talking to (LINE mv ACCT mv USER)
*
*9 LAST DATE AND TIME THAT I CHECKED FOR A MESSAGE.
*
*10 JOURNAL NUMBER'S OF THE MESSAGES WAITING FOR ME.
*
*11 Person messages are frome (USER)
*
*12  LINE messages are from (LINE)
*
*13 Account message are from (ACCT)
*
*14 Importance of messages (PRIORITY)
*
*15 Type of message (MSG.TYPE)
*
*
*
* START UP SEQUENCE IS
* CHECK MY LOCK, WAIT
* LOCK MY RECORD
* READ MY RECORD
*
* CHECK THEIR LOCK, WAIT
* LOCK THEIR RECORD
* READ THEIR RECORD
*
* DISPLAY MY JOURNALS
* ENTER HIS JOURNALS, UPDATE
* UPDATE MY RECORD
* UPDATE THEIR RECORD
*
* CLEAR MY LOCK
* CLEAR THEIR LOCK
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
DIM MY.RECORD(20), THEIR.RECORD(20), MY.STAT.DESC(10), MSG.DESC(10), PRIORITY.DESC(101)
MAT MY.RECORD = ''
MAT THEIR.RECORD = ''
MAT MY.STAT.DESC = ''
MAT MSG.DESC = ''
MAT PRIORITY.DESC = ''
JR.REC = ''
MY.PRIORITY = 1
WAIT.FLAG = 0
END.OF.PROG = 0
CONTINUE = 1
PRINT @(0,0):CLS:@(10,0):'Message Send/Recieve Function':
OPEN 'LOCKS' TO LCK.FILE ELSE STOP
OPEN 'SYS' TO SY.FILE ELSE PRINT 'No SYS file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
MATREAD MY.STAT.DESC FROM SY.FILE,'@MSG@STATDESC' ELSE MAT MY.STAT.DESC = ''
MATREAD MSG.DESC FROM SY.FILE,'@MSG@DESC' ELSE MAT MSG.DESC = ''
MATREAD PRIORITY.DESC FROM SY.FILE,'@MSG@PRIORITYDESC' ELSE MAT PRIORITY.DESC = ''
READ VALID.FUNCTIONS FROM SY.FILE,'@MSG@VAILD.FUNCTIONS' ELSE VALID.FUNCTIONS = '*D*Q*I*?*M*L*C*A*H*U*P*E*END*'
OPEN 'ACC' TO AC.FILE ELSE PRINT 'No ACC file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
CALL.ID = 'MENU.':PORT
READV USER.NAME FROM AC.FILE,CALL.ID,2 ELSE
USER.NAME = ''
END
Verify.MY.User: * INPUT YOU USER NAME AND VALIDATE
READ V.ME FROM SY.FILE,'@MSG@TRACE@':USER.NAME ELSE
PRINT @(0,15):CLS:@(0,16):'Enter your user ID: ':;INPUT USER.NAME:
GOTO Verify.MY.User
END
MY.ACCT = ACCT
MY.LINE = PORT
MSG.R.D.S = '?'
*
Prog.start: * Determine if originating or receiving.
STAT = ''
MY.KEY = '@MSG@TRACE@':USER.NAME
WRITEV '1' ON SY.FILE,MY.KEY,1
MSG.JOURNAL.KEY = '@MSG@JOURNAL'
END.OF.PROG = 0
JOURNAL = ''
MESS.LN = ''
MESS.ENT = ''
THEIR.LINE = ''
THEIR.ACCT = ''
THEIR.USER = ''
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
MSG.TYPE = 0
*
*
Main.Loop: * Loop for controlling function and send/recieve
*
*
LOOP
*
* Determine Required Actions.
*
IF MSG.R.D.S NE 'D' THEN
IF MY.RECORD(6) NE 2 THEN
GOSUB MY.RECORD.LOCK
MATREAD MY.RECORD FROM SY.FILE,MY.KEY ELSE
MY.RECORD(6) = 0
MY.RECORD(5) = 0
END
GOSUB MY.RECORD.UNLOCK
END
*
MY.RECORD(1) = 1
WRITEV MY.RECORD(1) ON SY.FILE,MY.KEY,1
*
*
*IF LEN(THEIR.USER) EQ 0 THEN GOSUB Input.THEIR.User
*
IF LEN(MY.RECORD(8)<1,1>) NE 0 & MY.RECORD(8)<1,1> NE THEIR.LINE THEN
THEIR.LINE = MY.RECORD(8)<1,1>
END
IF LEN(MY.RECORD(8)<1,2>) NE 0 & MY.RECORD(8)<1,2> NE THEIR.ACCT THEN
THEIR.ACCT = MY.RECORD(8)<1,2>
END
IF LEN(MY.RECORD(8)<1,3>) NE 0 & MY.RECORD(8)<1,3> NE THEIR.USER THEN
GOSUB THEIR.RECORD.UNLOCK
THEIR.USER = MY.RECORD(8)<1,3>
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
IF MY.RECORD(6) EQ 1 THEN
GOSUB THEIR.RECORD.LOCK
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE MAT THEIR.RECORD = ''
END
END
*
GOSUB Input.Action
*
IF MSG.TYPE EQ 'E' OR MSG.TYPE EQ 'END' THEN END.OF.PROG = 1
END
IF NOT(END.OF.PROG) THEN
MSG.TYPE = FIELD(VALID.FUNCTIONS,'*',MY.RECORD(5))
IF MY.RECORD(5) EQ 3 THEN
GOSUB Wait.For.Token
GOSUB MY.RECORD.LOCK
*MATREAD MY.RECORD FROM SY.FILE,MY.KEY
GOSUB THEIR.RECORD.LOCK
END
IF MY.RECORD(5) EQ 4 THEN
MSG.TYPE = '?'
GOSUB MY.RECORD.UNLOCK
GOSUB THEIR.RECORD.UNLOCK
FOR TEMP = 1 TO 5
RQM
NEXT TEMP
END
IF MY.RECORD(5) < 1 OR MY.RECORD(5) > 10 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'You have no transmission type.':
IF WAIT.FLAG THEN RQM; RQM; RQM
MY.RECORD(5) = 0
MSG.TYPE = ''
END
IF MSG.R.D.S EQ '' THEN
IF MY.RECORD(6) EQ 1 OR MY.RECORD(6) EQ 0 THEN
MY.RECORD(6) = 1
END ELSE IF MY.RECORD(6) EQ 2 THEN
MY.RECORD(6) = 2
END ELSE IF MY.RECORD(6) EQ 3 THEN
GOSUB You.Are.No.Disturb
END ELSE
PRINT @(0,22):CLL:@(0,23):CLL:BELL:'Your token status is invalid ( ':MY.RECORD(6):' ).':
IF WAIT.FLAG THEN RQM; RQM; RQM
MY.RECORD(6) = 0
MSG.R.D.S = '?'
END
END
*
*IF MY.RECORD(10) NE '' THEN MSG.R.D.S = 'D'
*
GOSUB Screen.Header
*
PRINT @(0,23):CLL:THEIR.USER:' is ':MY.STAT.DESC(THEIR.RECORD(6)+1):   
PRINT @(55,1):CLL:MSG.DESC(MY.RECORD(5)+1):
*
*
IF (LEN(THEIR.KEY) EQ 0 OR THEIR.KEY EQ '@MSG@TRACE@') & MSG.R.D.S NE 'D' THEN
GOSUB Input.THEIR.User
END ELSE
*
*
IF MSG.R.D.S EQ 'D' THEN
GOSUB Journal.Display
GOSUB MY.Journal.Remove
MSG.R.D.S = '?'
*
END ELSE IF MY.RECORD(6) EQ 1 THEN
GOSUB MY.RECORD.LOCK
IF MY.RECORD(5) EQ 1 THEN
GOSUB THEIR.RECORD.LOCK
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE MAT THEIR.RECORD = ''
THEIR.RECORD(5) = MY.RECORD(5)
THEIR.RECORD(6) = 2
THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
*#*GOSUB THEIR.RECORD.UNLOCK
END
CONTINUE = 1
LOOP
IF CONTINUE NE 2 THEN
GOSUB Journal.Next
JR.REC = ''
END ELSE
CONTINUE = 1
END
GOSUB Journal.Enter
IF CN1 > 1 THEN
GOSUB Journal.Write
GOSUB THEIR.Journal.Add
END
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
*#*GOSUB THEIR.RECORD.LOCK
READ THEIR.REC10 FROM SY.FILE,THEIR.KEY ELSE THEIR.REC10 = ''
IF LEN(THEIR.REC10<10>) NE 0 THEN
CN = 0
LOOP CN = CN + 1 WHILE THEIR.RECORD(10)<1,CN> NE '' DO
FOR CN.ADD = 10 TO 15
THEIR.REC10<CN.ADD> = THEIR.REC10<CN.ADD>:VM:THEIR.RECORD(CN.ADD)<1,CN>
NEXT CN.ADD
REPEAT
END ELSE
FOR CN.ADD = 10 TO 15
THEIR.REC10<CN.ADD> = THEIR.RECORD(CN.ADD)
NEXT CN.ADD
END
WRITE THEIR.REC10 ON SY.FILE,THEIR.KEY
FOR CN.DEL = 10 TO 15
THEIR.RECORD(CN.DEL) = ''
NEXT CN.DEL
*#*GOSUB MY.RECORD.LOCK
*#*GOSUB THEIR.RECORD.UNLOCK
WHILE CONTINUE DO REPEAT
IF MESS.ENT EQ 'OVER' THEN
MY.RECORD(6) = 2
READ THEIR.REC10 FROM SY.FILE,THEIR.KEY ELSE THEIR.REC10 = ''
*THEIR.REC10<5> = MY.RECORD(5)
THEIR.REC10<6> = 1
THEIR.REC10<8> = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MY.RECORD(6) = 2
WRITE THEIR.REC10 ON SY.FILE,THEIR.KEY
END ELSE
*MY.RECORD(5) = 0
MY.RECORD(6) = 0
MY.RECORD(9) = DATE():VM:TIME():VM:WHO
MY.RECORD(8) = ''
READ THEIR.REC10 FROM SY.FILE,THEIR.KEY ELSE THEIR.REC10 = ''
*THEIR.REC10<5> = 0
THEIR.REC10<6> = 0
THEIR.REC10<8> = ''
MSG.R.D.S = '?'
MSG.TYPE = 0
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
WRITE THEIR.REC10 ON SY.FILE,THEIR.KEY
END
GOSUB MY.RECORD.UNLOCK
GOSUB THEIR.RECORD.UNLOCK
*
END ELSE IF MY.RECORD(6) EQ 2 THEN
GOSUB Wait.For.Token
IF MY.RECORD(6) EQ 3 THEN MY.RECORD(6) = 1
*
END ELSE
*
PRINT @(0,23):CLL:BELL:'Huh?':
IF WAIT.FLAG THEN RQM; RQM; RQM
*
END
END
END
WHILE NOT(END.OF.PROG) DO REPEAT
*
IF LEN(THEIR.KEY) AND THEIR.KEY NE '@MSG@TRACE@' THEN
GOSUB THEIR.RECORD.LOCK
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE MAT THEIR.RECORD = ''
THEIR.RECORD(5) = 0
THEIR.RECORD(6) = 0
THEIR.RECORD(8) = ''
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
GOSUB THEIR.RECORD.UNLOCK
*
END
GOSUB MY.RECORD.LOCK
MY.RECORD(1) = 0
MY.RECORD(5) = 0
MY.RECORD(6) = 0
MY.RECORD(9) = DATE():VM:TIME():VM:WHO
MY.RECORD(8) = ''
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
GOSUB MY.RECORD.UNLOCK
*
*
GOTO End.prog
*
!
Input.THEIR.User: * Input their line, account, and user ID.
GOSUB THEIR.RECORD.UNLOCK
THEIR.KEY = ''
CONT3 = 1
LOOP WHILE CONT3 & NOT(END.OF.PROG) DO
ENT.THEIR.USER = THEIR.USER
PRINT @(0,2):CLL:'Which User are you sending to? ':
INPUT ENT.THEIR.USER:
IF LEN(ENT.THEIR.USER) EQ 0 THEN ENT.THEIR.USER = THEIR.USER
IF ENT.THEIR.USER NE 'END' THEN
THEIR.USER = ENT.THEIR.USER
READ V.ME FROM SY.FILE,'@MSG@TRACE@':THEIR.USER THEN 
THEIR.ACCT = V.ME<3>
THEIR.LINE = V.ME<2>
PRINT ', and which Account? ':
INPUT ENT.ACCT:
IF LEN(ENT.ACCT) EQ 0 THEN ENT.ACCT = THEIR.ACCT
IF ENT.ACCT EQ 'END' THEN
END.OF.PROG = 1
END ELSE
THEIR.ACT = ENT.ACCT
END
END ELSE
THEIR.USER = ''
THEIR.ACCT = ''
THEIR.LINE = ''
PRINT @(0,22):CLL:@(0,23):CLL:BELL:'User not on file!':
END
END ELSE END.OF.PROG = 1
IF LEN(THEIR.USER) NE 0 & NOT(END.OF.PROG) THEN CONT3 = 0 ELSE CONT3 = 1
REPEAT
IF NOT(END.OF.PROG) THEN
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
*IF MY.RECORD(6) EQ 1 THEN GOSUB THEIR.RECORD.LOCK
MY.RECORD(8) = THEIR.LINE:VM:THEIR.ACCT:VM:THEIR.USER
GOSUB THEIR.RECORD.LOCK
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE MAT THEIR.RECORD = ''
THEIR.RECORD(1) = THEIR.RECORD(1) + 0
THEIR.RECORD(6) = THEIR.RECORD(6) + 0
THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
IF THEIR.RECORD(1) NE 1 THEN
IF MY.RECORD(5) EQ 1 THEN PRINT BELL:
PRINT @(0,23):CLL:THEIR.USER:' is not in the message send program.':
IF WAIT.FLAG THEN RQM; RQM; RQM
*IF MY.RECORD(5) EQ 1 THEN
PRINT @(0,22):CLL:@(0,23):CLL:BELL:USER.NAME:', I changed you message type to a MEMO!!!!':
MSG.TYPE = 'M'
*MY.RECORD(5) = 5
MY.RECORD(6) = 1
*THEIR.RECORD(5) = 0
*THEIR.RECORD(6) = 0
IF THEIR.RECORD(8) EQ '' THEN THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
*END
END
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
GOSUB THEIR.RECORD.UNLOCK
PRINT @(0,23):CLL:THEIR.USER:' is ':MY.STAT.DESC(THEIR.RECORD(6)+1):   
PRINT @(55,1):CLL:MSG.DESC(MY.RECORD(5)+1):
END
RETURN
**
**
**
!
LCK.A.RECORD: * LOCK RECORD BEFORE READING
CALL LOCK.ITEM('1',"SYS",LCK.ID,LCK.FILE,STAT)
RETURN
!
UNLCK.A.RECORD: *
CALL UNLOCK.ITEM('1',"SYS",LCK.ID,LCK.FILE)
RETURN
!
Input.Action: * Input action wanted (esp. when token not taken).
Routine = 'Input.Action'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
Status.Window: * Routine to display & choose message.
STAT.CN = 0; STAT.NEXT = 0; STAT.NEXT.CN = 0
MSG.HEADING = RVB:'Line Person...... Priority.... Description. MSG.#':RVE
PRINT @(0,7):CLS:MSG.HEADING:
LOOP
STAT.CN = STAT.CN + 1
WHILE MY.RECORD(10)<1,STAT.CN> NE '' DO
PRINT @(0,STAT.CN+7):CLL:MY.RECORD(12)<1,STAT.CN> 'R#3':'  ':
PRINT MY.RECORD(11)<1,STAT.CN> 'L#12':' ':
*
STAT.PRIORITY = MY.RECORD(14)<1,STAT.CN>
IF NOT(NUM(STAT.PRIORITY)) THEN STAT.PRIORITY = 6
IF STAT.PRIORITY < 1 OR STAT.PRIORITY > 100 THEN STAT.PRIORITY = 6
PRINT PRIORITY.DESC(STAT.PRIORITY + 1) 'L#12':' ':
*
STAT.MT = MY.RECORD(15)<1,STAT.CN>
IF NOT(NUM(STAT.MT)) THEN STAT.MT = 0
IF LEN(STAT.MT) EQ 0 THEN STAT.MT = 0
PRINT MSG.DESC(STAT.MT + 1) 'L#12':' ':
*
PRINT MY.RECORD(10)<1,STAT.CN> 'R#5':
IF STAT.PRIORITY < 6 OR STAT.PRIORITY < MY.PRIORITY THEN
PRINT BELL:RVB:' ***':RVE:
IF WAIT.FLAG THEN RQM; RQM; PRINT BELL:
RQM
STAT.NEXT = MY.RECORD(10)<1,STAT.CN>
STAT.NEXT.CN = STAT.CN
LOOP WHILE LEN(STAT.NEXT) AND NOT(NUM(STAT.NEXT[1,1])) DO STAT.NEXT = STAT.NEXT[2,99] REPEAT
END
REPEAT
RSP = ''
IF STAT.NEXT NE 0 THEN
RSP = STAT.NEXT
PRINT @(51,STAT.NEXT.CN+7):'* DEFAULT *':
END
CONT1 = 1
MSG.TYPE = 0
LOOP WHILE CONT1 DO
YES.NO = ''
PRINT @(0,19):CLS:@(0,20):'Choose a message # from the above,':
PRINT @(0,21):CLL:'(D)ialogue, (Q)uestions, (I)nteruptions, (L)etter, (M)emo,':
PRINT @(0,22):CLL:@(5):'(H)istory display, (U)ser List, Change (P)ersons, (E)nd or END ':
IF STAT.NEXT EQ 0 OR NOT(NUM(STAT.NEXT)) THEN
FOR CN = 1 TO 10 UNTIL SYSTEM(11)
RQM
NEXT CN
IF SYSTEM(11) THEN
INPUT YES.NO:
END ELSE YES.NO = ''
END ELSE
YES.NO = STAT.NEXT
PRINT YES.NO:
END
JOURNAL = ''
IF SYSTEM(11) > 0 THEN INPUTCLEAR
IF YES.NO EQ 'L' THEN YES.NO = 'M'
MT = INDEX(VALID.FUNCTIONS,'*':YES.NO:'*',1)
IF MT NE 0 THEN
MSG.TYPE = YES.NO
IF MSG.TYPE EQ 'I' THEN
GOSUB Interuptions.Access
END ELSE IF MSG.TYPE EQ 'P' & MY.RECORD(6) EQ 0 THEN
GOSUB Input.THEIR.User
END ELSE IF MSG.TYPE EQ 'U' THEN
GOSUB User.List
END ELSE IF MSG.TYPE EQ 'H' THEN
GOSUB History.Access
END ELSE IF MSG.TYPE EQ '?' THEN
PRINT @(0,22):CLL:@(0,23):CLL:('Sorry ':USER.NAME:', but there are no HELP facilities available.') 'L#75':BELL:
IF WAIT.FLAG THEN RQM; RQM; RQM
RQM
END ELSE
CONT1 = 0
MT = INT(MT/2) + 1
MY.RECORD(5) = MT
MY.RECORD(6) = 1
END
END ELSE IF NUM(YES.NO) THEN
YES.NO = STR('0',5-LEN(YES.NO)):YES.NO
STAT.CN = 0
*#CONT1.1 = 1
*#LOOP
*#STAT.CN = STAT.CN + 1
*#WHILE MY.RECORD(10)<1,STAT.CN> NE '' & CONT1.1 DO
*#IF YES.NO EQ MY.RECORD(10)<1,STAT.CN> THEN
*#JOURNAL = YES.NO
*#MY.RECORD(5) = MY.RECORD(15)<1,STAT.CN>
*#MSG.TYPE = MY.RECORD(15)<1,STAT.CN>
MSG.R.D.S = 'D'
*#CONT1.1 = 0
CONT1 = 0
*#END
*#REPEAT
JOURNAL = (YES.NO + 100000)[2,5]
END ELSE
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', your entry was invalid. Please re-enter . . .':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RQM
END
REPEAT
RETURN
!
User.List: * Subroutine to execute the UL tcl command.
Routine = 'User List Command'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
PRINT @(0,7):
EXECUTE "UL"
RSP = ''
PRINT @(0,22):CLS:@(0,23):'Enter <CR> to continue. . .':
INPUT RSP:
GOSUB PEOPLE.LIST
RETURN
!
PEOPLE.LIST: * PEOLPE ON MESSAGE SYSTEM
GOSUB Screen.Header
OUT.RESULT = ''; UL.LIST = ''
EXEC.VERB = '= "@MSG@TRACE@]"'
EXECUTE 'SSELECT SYS ':EXEC.VERB, //OUT. > OUT.RESULT, //SELECT. > UL.LIST
CN.TEMP = 0
PRINT @(0,7):CLS:
LOOP CN.TEMP = CN.TEMP + 1 WHILE OUT.RESULT<CN.TEMP> NE '' DO
PRINT @(0,CN.TEMP + 7):CLL:OUT.RESULT<CN.TEMP>:
 IF WAIT.FLAG THEN RQM; RQM
REPEAT
CN = 0; CN.LINE = 99
LOOP
READNEXT USERS.KEY FROM UL.LIST ELSE USERS.KEY = ''
WHILE LEN(USERS.KEY) NE 0 DO
CN.LINE = CN.LINE + 1
IF CN.LINE > 20 THEN
IF CN.LINE NE 100 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue. . .':
RSP = ''
INPUT RSP:
END
PRINT @(0,6):CLS:'User...... Last.Access....... Current.Status...................':
CN.LINE = 7
END
READ MSG.REC FROM SY.FILE,USERS.KEY ELSE MSG.REC = ''
PRINT @(0,CN.LINE):CLL:MSG.REC<4> 'L#10':' ':
IF LEN(MSG.REC<9>) > 0 THEN
PRINT (OCONV(MSG.REC<9,1>,'D2'):' ':OCONV(MSG.REC<9,2>,'MTS')) 'L#19':
END ELSE PRINT 'Not a user' 'L#19':
IF NOT(NUM(MSG.REC<6>)) THEN MSG.REC<6> = 0
DESC.NUM = MSG.REC<6> + 1
PRINT @(30):MY.STAT.DESC(DESC.NUM):
REPEAT
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue. . .':
RSP = ''
INPUT RSP:
GOSUB Screen.Header
RETURN
!
Interuptions.Access: * Inputs Minimum priorty for interupt,
* do not disturb status and
* date/time to remove from do not disturb status
*
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', can you be interupted? ':
INPUT YES.NO:
IF INDEX(NO,YES.NO,1) NE 0 THEN
MY.RECORD(6) = 3
PRINT @(0,22):CLL:@(0,23):CLL:'UNtil what date? ':
INPUT PRIORITY.DATE:
IF LEN(PRIORITY.DATE) EQ 0 THEN PRIORITY.DATE = OCONV(DATE(),'D2')
PRIORITY.DATE = ICONV(PRIORITY.DATE,'D2')
IF PRIORITY.DATE < DATE() OR PRIORITY.DATE > DATE() + 1 THEN
PRIORITY.DATE = DATE() + 1
PRINT @(0,23):CLL:"Set to tommorow's date!":
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RQM
END
PRINT @(0,23):CLL:'UNtil what time? ':
INPUT PRIORITY.TIME:
IF LEN(PRIORITY.TIME) EQ 0 THEN
IF PRIORITY.DATE EQ DATE() THEN
PRIORITY.TIME = OCONV(TIME()+3600,'MT')
PRINT @(0,23):CLL:'Set to one hour from now!':
END ELSE
PRIORITY.TIME = OCONV(0,'MT')
PRINT @(0,23):CLL:'Set to the start of that day!':
END
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RQM
END
PRIORITY.TIME = ICONV(PRIORITY.TIME,'MT')
MY.RECORD(7)<1,1> = PRIORITY.DATE
MY.RECORD(7)<1,2> = PRIORITY.TIME
END ELSE IF INDEX(YES,YES.NO,1) NE 0 THEN
IF MY.RECORD(6) EQ 3 THEN
PRINT @(0,23):CLL:'You were in a do not interupt status.':
IF WAIT.FLAG THEN RQM; RQM
RQM
MY.RECORD(6) = 0
MY.RECORD(7) = ''
END
PRINT @(0,23):CLL:'You CAN now be interupted by NORMAL messages.':
IF WAIT.FLAG THEN RQM; RQM; RQM
RQM
END
PRINT @(0,22):CLL:'What priority level must a message NORMALLY have if I am going to':
PRINT @(0,23):CLL:'   immediately interupt you and enter this program (5 - 100)? ':
INPUT NEW.PRIORITY:
IF NOT(NUM(NEW.PRIORITY)) THEN NEW.PRIORITY = MY.PRIORITY
IF LEN(NEW.PRIORITY) NE 0 THEN MY.PRIORITY = NEW.PRIORITY
IF MY.PRIORITY < 5 THEN MY.PRIORITY = 5
PRINT @(0,22):CLL:'Your new priority interupt must be,':
PRINT @(0,23):CLL:'(':MY.PRIORITY:') or ':PRIORITY.DESC(MY.PRIORITY):
MY.RECORD(16) = MY.PRIORITY
*
IF WAIT.FLAG THEN RQM; RQM; RQM
RQM
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
RETURN
!
Screen.Header: * Prints Header for screen I/O
PRINT @(0,0):CLS:'Message Send/Recieve Function':
PRINT @(0,2):CLL:@(5):'To User: ':THEIR.USER:
PRINT ', Account: ':THEIR.ACCT:', Port: ':THEIR.LINE:
PRINT @(39,0):CLL:'Message number: ':JOURNAL
PRINT @(49,1):CLL:'Type: ':MSG.DESC(MY.RECORD(5)+1):
RETURN
!
Journal.Display: * Routine to display a message
Routine = 'Journal.Display'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
STAT = 0
LCK.ID = '@MSG@':JOURNAL
CALL LOCK.ITEM('1','SYS',LCK.ID,LCK.FILE,STAT)
IF STAT THEN
CALL UNLOCK.ITEM('1','SYS',LCK.ID,LCK.FILE)
IF STAT NE 999 THEN GOTO Journal.Display
END ELSE
READ JR.REC FROM SY.FILE,'@MSG@':JOURNAL THEN
MY.R.LOC = 0
LOOP
MY.R.LOC = MY.R.LOC + 1
WHO.FOR = JR.REC<10,MY.R.LOC>
WHILE WHO.FOR NE '' & WHO.FOR NE USER.NAME DO REPEAT
IF WHO.FOR EQ '' THEN
JR.REC<10,MY.R.LOC> = USER.NAME
JR.REC<8,MY.R.LOC> = 'U'
END
JR.REC<9,MY.R.LOC> = MY.ACCT:SVM:JR.REC<9,MY.R.LOC>
JR.REC<11,MY.R.LOC> = PORT:SVM:JR.REC<11,MY.R.LOC>
JR.REC<12,MY.R.LOC> = DATE():SVM:JR.REC<12,MY.R.LOC>
JR.REC<13,MY.R.LOC> = TIME():SVM:JR.REC<13,MY.R.LOC>
JR.REC<14,MY.R.LOC> = 'Y'
*
IF NOT(NUM(JR.REC<7>)) THEN JR.REC<7> = 1
IF JR.REC<7> < 1 THEN JR.REC<7> = 1
PRINT @(0,4):CLL:PRIORITY.DESC(JR.REC<7>):'message from ':JR.REC<3>:', in account ':JR.REC<2>:', from port ':JR.REC<4>:'.':
*
PRINT @(0,6):CLS:
PRINT @(0,22):CLL:@(0,23):'Do you need to know who else received this (Y/N)? ':
INPUT YES.NO,1:
IF YES.NO EQ 'Y' THEN
CN = 0; CN.LINE = 99
CONT4 = 1
LOOP CN = CN + 1 WHILE CONT4 & JR.REC<10,CN> NE '' DO
CN1 = 0; CONT5 = 1
IF CN.LINE < 21 THEN PRINT @(0,CN.LINE):CLL:JR.REC<10,CN>:
LOOP CN1 = CN1 + 1 WHILE CONT5 & JR.REC<9,CN,CN1> NE '' DO
IF CN.LINE > 20 THEN
IF CN.LINE < 90 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue.':
INPUT YES.NO:
END ELSE YES.NO = ''
IF YES.NO EQ 'END' THEN CONT4 = 0 ELSE
PRINT @(0,6):CLS:'User...... Account... Port R/T ..Date... ..Time...':
CN.LINE = 7
PRINT @(0,CN.LINE):CLL:JR.REC<10,CN>:
END
END
IF CONT4 THEN
PRINT @(11):JR.REC<9,CN,CN1>:@(22):JR.REC<11,CN,CN1>:
PRINT @(27):(JR.REC<8,CN>:'/':JR.REC<14,CN>):@(31):OCONV(JR.REC<12,CN,CN1>,'D2'):
PRINT @(41):OCONV(JR.REC<13,CN,CN1>,'MTS'):
END
CN.LINE = CN.LINE + 1
REPEAT
REPEAT
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue.':
INPUT YES.NO:
PRINT @(0,7):CLS:
END
CN = 19
CN.LINE = 6
CONT4 = 1
LOOP
CN = CN + 1
WHILE CONT4 & JR.REC<CN> NE '' DO
CN.LINE = CN.LINE + 1
IF CN.LINE > 20 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue display.':
INPUT YES.NO:
IF YES.NO EQ 'END' THEN CONT4 = 0 ELSE
PRINT @(0,7):CLS:
CN.LINE = 7
END
END
IF CONT4 THEN PRINT @(0,CN.LINE):CLL:@(5):JR.REC<CN>:
REPEAT
WRITE JR.REC ON SY.FILE,'@MSG@':JOURNAL
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> for next message.':
RSP = ''
INPUT RSP:
END ELSE
JR.REC = ''
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', message number ':JOURNAL:' is missing!':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
END
END
LCK.ID = '@MSG@':JOURNAL
CALL UNLOCK.ITEM('1','SYS',LCK.ID,LCK.FILE)
RETURN
!
Journal.Enter: * Routine to input a message.
Routine = 'Journal.Enter'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
CONT2 = 1
CN1 = 0
MESS.LN = ''
MESS.ENT = ''
*PRINT @(55,0):CLL:
LOOP WHILE CONT2 DO
CN1 = CN1 + 1
CTEN = INT((CN1-1)/10) * 10
IF CN1 - 1 - CTEN EQ 0 THEN
PRINT @(0,7):CLS:
PRINT @(0,22):CLL:'Enter next line, CLEAR above line,':
IF MY.RECORD(5) EQ 1 THEN PRINT ' OVER,':
PRINT @(0,23):CLL:@(5):'END to end, NEXT for next journal, or SEND to send.':
END
MESS.O = 0
ENT.LINE = CN1-CTEN+7
PRINT @(5,ENT.LINE):CLL:
MESS.ENT = ''
INPUT MESS.ENT
MESS.LN<CN1> = MESS.ENT
IF MESS.ENT EQ 'END' THEN
IF MY.RECORD(5) EQ 1 THEN
MESS.LN<CN1> = 'Over and out.....'
CN1 = CN1 + 1
CONT2 = 0
CONTINUE = 0
END ELSE
MESS.ENT = 'OVER'
END
END
IF MESS.ENT EQ 'OVER' THEN
IF MY.RECORD(5) EQ 1 THEN
MESS.LN<CN1> = 'Your turn to send......'
CN1 = CN1 + 1
END ELSE
MESS.LN<CN1> = ''
END
CONTINUE = 0
CONT2 = 0
END ELSE IF MESS.ENT EQ 'SEND' OR MESS.ENT EQ 'NEXT' THEN
MESS.LN<CN1> = 'I have more to send, please wait....'
CONT2 = 0
IF MY.RECORD(5) EQ 1 THEN
CONTINUE = 2
CN1 = CN1 + 1
END ELSE
CONTINUE = 0
MESS.LN<CN1> = ''
END
END ELSE IF MESS.ENT EQ 'CLEAR' THEN
IF ENT.LINE NE 8 OR CTEN > 0 THEN
CN1 = CN1 - 2
END ELSE CN1 = CN1 - 1
PRINT @(5,ENT.LINE):CLL:
END
REPEAT
RETURN
!
Journal.Write: * Write a journal onto the Message File.
Routine = 'Journal.Write'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
*JR.REC = MY.RECORD(5):AM:MY.ACCT:AM:USER.NAME:AM:MY.LINE:AM:DATE():AM:TIME():AM:MY.PRIORITY:AM:'N'
JR.REC<1> = MY.RECORD(5)
JR.REC<2> = MY.ACCT
JR.REC<3> = USER.NAME
JR.REC<4> = MY.LINE
JR.REC<5> = DATE()
JR.REC<6> = TIME()
JR.REC<7> = MY.PRIORITY
JR.REC<8> = 'N'
*JR.REC = JR.REC:AM:THEIR.ACCT:AM:THEIR.USER:AM:THEIR.LINE:AM:0:AM:0:AM:'N':AM:'N':AM:'16':AM:'17':AM:'18':AM:'19'
JR.REC<9> = THEIR.ACCT
JR.REC<10>= THEIR.USER
JR.REC<11>= THEIR.LINE
JR.REC<14>= 'N'
JR.REC<15>= 'N'
JR.REC<20> = JR.REC<20>:AM:MESS.LN
WRITE JR.REC ON SY.FILE,'@MSG@':JOURNAL
RETURN
!
Journal.Next: * Get and reserve next available Journal #.
Routine = 'Journal.Next'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
LCK.ID = MSG.JOURNAL.KEY
CALL LOCK.ITEM('1','SYS',LCK.ID,LCK.FILE,STAT) 
IF STAT THEN
CALL UNLOCK.ITEM('1','SYS',LCK.ID,LCK.FILE)
GOTO Journal.Next
END
READV NEXT.JOURNAL FROM SY.FILE,MSG.JOURNAL.KEY,1 ELSE NEXT.JOURNAL = 0
IF NOT(NUM(NEXT.JOURNAL)) THEN NEXT.JOURNAL = 0
NEXT.JOURNAL = NEXT.JOURNAL + 1
NEXT.JOURNAL = STR('0',(5-LEN(NEXT.JOURNAL))):NEXT.JOURNAL
WRITEV NEXT.JOURNAL ON SY.FILE,MSG.JOURNAL.KEY,1
LCK.ID = MSG.JOURNAL.KEY
CALL UNLOCK.ITEM('1','SYS',LCK.ID,LCK.FILE)
JOURNAL = NEXT.JOURNAL
PRINT @(55,0):CLL:BELL:JOURNAL:
RETURN
!
MY.Journal.Remove: * Remove a Journal from my Stack.
Routine = 'MY.Journal.Remove'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
DEL.LOC = 1
LOOP
IF MY.RECORD(10)<1,DEL.LOC> EQ JOURNAL THEN
FOR CN.DEL = 10 TO 15
MY.RECORD(CN.DEL) = DELETE(MY.RECORD(CN.DEL),1,DEL.LOC)
NEXT CN.DEL
DEL.LOC = DEL.LOC - 1
END
DEL.LOC = DEL.LOC + 1
WHILE MY.RECORD(10)<1,DEL.LOC> NE '' DO REPEAT
IF MY.RECORD(6) NE 2 THEN
GOSUB MY.RECORD.LOCK
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
GOSUB MY.RECORD.UNLOCK
END
RETURN
!
MY.Journal.Add: * Add a journal to my Stack. (Memo to myself).
Routine = 'MY.Journal.Add'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
MY.RECORD(10) = MY.RECORD(10):JOURNAL:VM
MY.RECORD(11) = MY.RECORD(11):USER.NAME:VM
MY.RECORD(12) = MY.RECORD(12):MY.LINE:VM
MY.RECORD(13) = MY.RECORD(13):MY.ACCT:VM
MY.RECORD(14) = MY.RECORD(14):MY.PRIORITY:VM
MY.RECORD(15) = MY.RECORD(15):MY.RECORD(5):VM
RETURN
!
THEIR.Journal.Remove: * Delete a Journal from their Stack.
Routine = 'THEIR.Journal.Remove'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
FOR CN.DEL = 10 TO 15
THEIR.RECORD(CN.DEL) = DELETE(THEIR.RECORD(CN.DEL),1,1)
NEXT CN.DEL
RETURN
!
THEIR.Journal.Add: * Add a Journal to their Stack.
Routine = 'THEIR.Journal.Add'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
THEIR.RECORD(10) = THEIR.RECORD(10):JOURNAL:VM
THEIR.RECORD(11) = THEIR.RECORD(11):USER.NAME:VM
THEIR.RECORD(12) = THEIR.RECORD(12):MY.LINE:VM
THEIR.RECORD(13) = THEIR.RECORD(13):MY.ACCT:VM
THEIR.RECORD(14) = THEIR.RECORD(14):MY.PRIORITY:VM
THEIR.RECORD(15) = THEIR.RECORD(15):MY.RECORD(5):VM
RETURN
!
MY.RECORD.LOCK: * Wait for "my token" or "no token" and LOCK my control
* record.
Routine = 'MY.RECORD.LOCK'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
LCK.ID = MY.KEY 
CALL LOCK.ITEM('1','SYS',LCK.ID,LCK.FILE,STAT) 
MY.RECORD(6) = 0
IF STAT AND MY.RECORD(6) NE 2 THEN
IF STAT NE 999 THEN GOSUB Wait.For.Token
IF MY.RECORD(6) NE 2 THEN GOTO MY.RECORD.LOCK
END
*MATREAD MY.RECORD FROM SY.FILE,MY.KEY ELSE
*MAT MY.RECORD = ''
*MY.RECORD(6) = 0
*MY.RECORD(5) = 0
*END
*MY.RECORD(2) = PORT
*MY.RECORD(3) = ACCT
*MY.RECORD(4) = USER.NAME
*IF STAT THEN MY.RECORD(6) = 2
*MY.RECORD(8)<1,1> = THEIR.LINE
*MY.RECORD(8)<1,2> = THEIR.ACCT
*MY.RECORD(8)<1,3> = THEIR.USER
*THEIR.KEY = '@MSG@TRACE@':THEIR.USER
RETURN
*
!
MY.RECORD.UNLOCK: * UNLOCK my record.
Routine = 'MY.RECORD.UNLOCK'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
LCK.ID = MY.KEY
CALL UNLOCK.ITEM('1','SYS',LCK.ID,LCK.FILE)
RETURN
!
THEIR.RECORD.LOCK: * If token is mine then LOCK their record, or give token
Routine = 'THEIR.RECORD.LOCK'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
LCK.ID = THEIR.KEY
CALL LOCK.ITEM('1','SYS',LCK.ID,LCK.FILE,STAT) 
IF STAT AND MY.RECORD(6) NE 2 THEN
CALL UNLOCK.ITEM('1','SYS',LCK.ID,LCK.FILE)
GOTO THEIR.RECORD.LOCK
END
*MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE
*MAT THEIR.RECORD = ''
*THEIR.RECORD(6) = 2
*THEIR.RECORD(5) = MY.RECORD(5)
*END
RETURN
!
THEIR.RECORD.UNLOCK: * UNLOCK their record.
Routine = 'THEIR.RECORD.UNLOCK'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
LCK.ID = THEIR.KEY
CALL UNLOCK.ITEM('1','SYS',LCK.ID,LCK.FILE)
RETURN
!
Wait.For.Token: * Routine to Cycle until token is available.
Routine = 'Wait.For.Token'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
*MY.RECORD(6) = 0
IF MY.RECORD(5) NE 1 THEN
MY.RECORD(6) = 1
THEIR.RECORD(6) = 0
IF THEIR.RECORD(8) EQ '' THEN THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
GOSUB THEIR.RECORD.UNLOCK
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
GOSUB MY.RECORD.UNLOCK
END ELSE
MY.RECORD(6) = 2
THEIR.RECORD(6) = 1
THEIR.RECORD(5) = MY.RECORD(5)
THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
GOSUB THEIR.RECORD.LOCK
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
GOSUB THEIR.RECORD.UNLOCK
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
GOSUB MY.RECORD.UNLOCK
MY.RECORD(6) = 2
SYS11.ELP = 10
LOOP WHILE MY.RECORD(6) = 2 DO
PRINT @(0,22):CLS:'You are waiting for ':THEIR.USER:
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE MAT THEIR.RECORD = ''
THEIR.RECORD(1) = THEIR.RECORD(1) + 0
THEIR.RECORD(6) = THEIR.RECORD(6) + 0
PRINT @(0,23):CLL:THEIR.USER:' is ':MY.STAT.DESC(THEIR.RECORD(6)+1):   
IF THEIR.RECORD(1) NE 1 THEN
PRINT @(0,23):CLL:BELL:THEIR.USER:' is not in the message send program.':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
*THEIR.RECORD(5) = 0
*THEIR.RECORD(6) = 0
*MY.RECORD(5) = 0
*MY.RECORD(6) = 0
END
IF THEIR.RECORD(8) EQ '' THEN
THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
END
IF MY.RECORD(8) EQ '' THEN
MY.RECORD(8) = THEIR.LINE:VM:THEIR.ACCT:VM:THEIR.USER
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
END
IF WAIT.FLAG THEN
IF SYS11.ELP > 3 THEN SYS11.ELP = SYS11.ELP - 1
FOR CNTOKEN = 1 TO SYS11.ELP
RQM
NEXT CNTOKEN
END
IF SYSTEM(11) NE 0 THEN
SAVE.ACTION = MY.RECORD(5)
GOSUB Input.Action
IF YES.NO EQ 'E' OR YES.NO EQ 'END' THEN
MY.RECORD(6) = 0
WRITEV MY.RECORD(6) ON SY.FILE,MY.KEY,6
*MY.RECORD(6) = 5
END
MY.RECORD(5) = SAVE.ACTION
END
MY.RECORD(6) = 0
MATREAD MY.RECORD FROM SY.FILE,MY.KEY THEN
MY.RECORD(2) = PORT
MY.RECORD(3) = ACCT
MY.RECORD(4) = USER.NAME
IF MY.RECORD(10) NE '' THEN MY.RECORD(6) = 3
IF LEN(MY.RECORD(8)) NE 0 THEN
THEIR.LINE = MY.RECORD(8)<1,1>
THEIR.ACCT = MY.RECORD(8)<1,2>
THEIR.USER = MY.RECORD(8)<1,3>
END
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
END ELSE
MAT MY.RECORD = ''
MY.RECORD(6) = 0
END
*IF MY.RECORD(6) NE 3 & MY.RECORD(6) NE 5 THEN MY.RECORD(6) = MY.RECORD(6)
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', you are ':MY.STAT.DESC(MY.RECORD(6)+1):
IF WAIT.FLAG THEN RQM; RQM; RQM
REPEAT
END
PRINT @(0,22):CLS:@(0,23):BELL:USER.NAME:', you are finished waiting.':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RETURN
!
History.Access: * Routine to allow access to previous journals.
Routine = 'History.Access'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
RETURN
!
You.Are.No.Disturb: * Routine reminds you that you are LOCKed
Routine = 'You.Are.No.Disturb'
$INCLUDE IBP MSG.ROUTINE.DISPLAY
RETURN
!
End.prog: * End of program
PRINT @(0,0):CLS:
PRINT
PRINT
PRINT 'Thank you. Now ending....'
IF WAIT.FLAG THEN RQM; RQM; RQM
PRINT
PRINT
END
~OLD.SY.STRUCT~
X*PROGRAM: MENU.HANDLER
!
$INCLUDE IBP SYS.COMMON
TERMINAL = "?"
$INCLUDE IBP STANDARD.FUNCTIONS
*
SYS.PROG = "SYS.STRUCTURE"
SYS.LOCT = "INIT"
SYS.SLOC = "ERROR.CONTROL"
*
*
OFF.RSP = "*OFF*off*Off*END*end*End*STOP*stop*HALT*halt*Halt*BYE*bye*Bye*LOGOFF*logoff*Logoff*"
TCL.RSP ="*COMMAND*TCL*tcl*Tcl*"
USER.NAME = ""
MENU.NAME = ""
MENU.NUM = 1
MENU.APPL = "LOGON"
PRMPTING = ""
TOPIC.KEY = ""
MAT STRUCT = ""
STRUCT(1) = 0
WAIT.FLAG = 2
!
SYS.SLOC = "FILES"
SYS.FILE = "SYS"
OPEN "SYS" TO SY.FILE ELSE
ERROR.TEXT = "No SYS file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "MENUS"
OPEN "MENUS" TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
CHECK.MAIL = 0
*
SYS.FILE = "HLP"
OPEN "HLP" TO HLP.FILE THEN CHECK.HELP = 1 ELSE
CHECK.HELP = 0
ERROR.TEXT = "No HLP file"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "PSD"
OPEN "PSD" TO PS.FILE THEN CHECK.TIME = 2 ELSE
CHECK.TIME = 0
ERROR.TEXT = "No PSD file"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "ACC"
OPEN "ACC" TO AC.FILE ELSE
ERROR.TEXT = "No ACC file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
*
SYS.SLOC = "TABLES"
SYS.FILE = "ACC"
SYS11.ELP = 0; USER.FLAG = 1
CALL.ID = "MENU.":PORT
SYS.ITEM = CALL.ID
READV USER.NAME FROM AC.FILE,CALL.ID,2 ELSE USER.NAME = ""; USER.FLAG = 0
MENU.NAME = ""
*
SYS.FILE = "MD"
SYS.ITEM = "CO.DATA"
READ CO.DATA FROM SY.FILE,SYS.ITEM ELSE CO.DATA = AM:DATE()
EXEC.VERB = ""; PRMPTING = ""
*
*
SYS.FILE = "SYS"
SYS.ITEM = "@M@USER.MODE.DESC"
MATREAD MODE.DESC FROM SY.FILE,SYS.ITEM ELSE
MAT MODE.DESC = "?"
ERROR.TEXT = "user mode descriptions missing"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.ITEM = "@M@STATUS@CHECK"
READ STAT.CHECK FROM SY.FILE,SYS.ITEM ELSE
STAT.CHECK = "?"
ERROR.TEXT = "No STATUS flag verifiers"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.ITEM = "@M@STATUS@DESC"
MATREAD STAT.DESC FROM SY.FILE,SYS.ITEM ELSE
MAT STAT.DESC = ""
ERROR.TEXT = "No STATUS descriptions"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.ITEM = "@SYS@LO.DEV.MODE"
READ LO.D.M FROM SY.FILE,SYS.ITEM ELSE LOW.DEV.MODE = 0
SYS.ITEM = "@SYS@HI.DEV.MODE"
READ HI.D.M FROM SY.FILE,SYS.ITEM ELSE HI.D.M = 0
SYS.ITEM = "@SYS@HI.SALES.MODE"
READ HI.S.M FROM SY.FILE,SYS.ITEM ELSE HI.S.M = 0
SYS.ITEM = "@SYS@LO.TCL.MODE"
READ LO.TCL.M FROM SY.FILE,SYS.ITEM ELSE LO.TCL.M = 0
SYS.ITEM = "@SYS@LO.TRAIN.MODE"
READ LO.T.M FROM SY.FILE,SYS.ITEM ELSE LO.T.M = 0
SYS.ITEM = "@SYS@HI.TRAIN.MODE"
READ HI.T.M FROM SY.FILE,SYS.ITEM ELSE HI.T.M = 0
*
*
SYS.SLOC = "USER"
MAT USER.UPD = 0
USER.LOCKED = 0; USER.ABORT = 0; SYS.ABORT = 0
PRINT @(0,5):CLS:
*
GOSUB LOG.IN.TO.MENU
*
IF USER.ABORT ! SYS.ABORT THEN PRINT BELL:" ABORT!":; STOP
*
GOSUB RECORD.TIME
IF OFF.FLAG THEN PRMPTING = "OFF"
IF TCL.FLAG THEN PRMPTING = "TCL"
OFF.FLAG = 0
*
LAST.LOCT = 0
OLD.MENU.NAME = "*"
MENU.APPL = OLD.MENU.NAME
MENU.PREV = "/"
MENU.APPL.DESC = ""
RESTART: * Return for error.
LOOP
SYS.LOCT = "MENU"
SYS.SLOC = "READ"
SYS.FILE = ""
SYS.ITEM = ""
MENU.ERROR = 0
EXEC.VERB = ""
PRMPTING = ""
MAT PRMPT = ""
USER.NEW = 1
MAT SLOC = 0
RSP = ""
IF OLD.MENU.NAME # MENU.NAME THEN
MENU.NEW = 1
LOOP WHILE MENU.NEW DO
IF MENU.ERROR > 5 THEN CHAIN "MENU-RUN OFF"
SYS.FILE = "MENUS"
SYS.ITEM = "@AS@":MENU.NAME
MATREAD MENU FROM MU.FILE,SYS.ITEM THEN
MENU.NEW = 0
MENU.PREV = MENU(1)<1,5>
SYS.SLOC = "APPL"
*
IF MENU.APPL # MENU(1)<1,6> THEN
IF OLD.MENU.NAME # "*" THEN TOPIC.KEY = ""
MENU.APPL = MENU(1)<1,6>
MENU.APPL.REC = AM:"?"
LOOP WHILE MENU.APPL.REC<2> # MENU.APPL DO
SYS.FILE = "SYS"
SYS.ITEM = "@APPL@":MENU.APPL
READ MENU.APPL.REC FROM SY.FILE,SYS.ITEM ELSE
MENU.APPL.REC = ""
ERROR.TEXT = "Application description not on file for ":MENU.APPL
ERROR.CODE = 13110
GOSUB ERROR.CONTROL
END
MENU.APPL = MENU.APPL.REC<2>
REPEAT
MENU.APPL.DESC = MENU.APPL.REC<1>
MENU.APPL.REC = ""
IF STRUCT(30)<1,PORT + 1> # MENU.APPL THEN TOPIC.KEY = ""
END
OLD.MENU.NAME = MENU.NAME
*
MENU.EI.APPL = MENU(1)<1,7>
MENU.TYPE = MENU(1)<1,8>[1,1]
MENU.SPLIT = MENU(1)<1,8>[2,99]
MENU.NUM = MENU(1)<1,9>
IF NOT(NUM(MENU.NUM)) THEN MENU.NUM = 0
GOSUB RECORD.LOCATION
END ELSE
IF USER.MODE >= LO.D.M ! USER.MODE <= HI.D.M THEN
YES.NO = ""
PRINT @(0,23):CLL:BELL:@(20):"Maintain menu? ":;INPUT YES.NO:
IF INDEX(YES,"*":YES.NO:"*",1) # 0 THEN
EXEC.VERB = "EI.MENUS.DEV M @AS@":MENU.NAME
END ELSE IF YES.NO = "EDIT" THEN
PRINT @(0,5):CLS:
EXEC.VERB = "EDIT MENUS @AS@":MENU.NAME
END
OLD.MENU.NAME = "*"
EXECUTE EXEC.VERB
EXEC.VERB = MENU.NAME
END ELSE
MENU.ERROR = MENU.ERROR + 1
ERROR.TEXT = "the menu @AS@":MENU.NAME:" is not on file"
ERROR.CODE = 13110
GOSUB ERROR.CONTROL
END
IF MENU.NAME = OLD.MENU.NAME THEN MENU.NAME = "/" ELSE MENU.NAME = OLD.MENU.NAME
END
REPEAT
USER.UPD(2) = 1
END
!
GOSUB CHECK.CONTROL
SYS.SLOC = "HEADING"
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#20":(SPACE(20-LEN(CO.DATA<1,1,1>)/2+.5):CO.DATA<1,1,1>) "L#40":("Port: ":PORT) "R#20":
*
PRINT @(0,1):OCONV(TIME(),"MTS") "L#15":(SPACE(25-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#50":("Acct: ":ACCT) "R#15":
*
IF STRUCT(25)<1,PORT+1> THEN PRINT @(0,2):(MODE.DESC(USER.MODE):" mode") "L#20": ELSE PRINT @(0,2):SPACE(20): 
*
PRINT (SPACE(20-LEN(MENU(1)<1,1>)/2+.5):MENU(1)<1,1>) "L#40":("User: ":STRUCT(2)) "R#20":RVE:
*
SYS.SLOC = "LOAD.COMPLETION"
GOSUB COMPLETION.LOAD
*
*IF  MENU(1)<1,2,1> > 0 THEN
*SYS.SLOC = "LOAD.TASK"
*CALL.FUNCTION = "DISPLAY"; IF MENU.TYPE = "P" THEN CALL.SUB.FUNCTION = 2 ELSE CALL.SUB.FUNCTION = 1
*CALL SYS.TOPIC
*END
!
SYS.LOCT = "DISPLAY"
SYS.SLOC = "INIT"
VALID.USER = ""; TYPING = ""; MENU.FILE = ""; MENU.STEP = ""; SUBJCT = ""
IF MENU.TYPE = "" ! MENU.TYPE = " " THEN MENU.TYPE = "O"
IF NOT(NUM(MENU.SPLIT)) THEN MENU.SPLIT = 0
IF LEN(MENU.SPLIT) = 0 THEN MENU.SPLIT = 0
CL = 0
IF MENU.SPLIT # 0 ! MENU.TYPE = "P" THEN CL = 2 ELSE CL = 22
AC = 1; LN = 4
LS = 999
LS.AC = 0
PR.FL = 0
SYS.SLOC = "LOOP"
LOOP AC = AC + 1; LINE = MENU(AC) UNTIL LINE = "" ! AC > 25 DO
IF AC = MENU.SPLIT THEN LN = 4; CL = 42
PRMPT(AC) = LINE<1,3>; IF PRMPT(AC) = " " ! PRMPT(AC) = "" THEN PRMPT(AC) = AC
ST = 0
IF MENU.TYPE = "P" & TASK.NUM # 0 THEN
ST = LINE<1,8>
IF NOT(NUM(ST)) THEN ST = 0
IF INDEX("*N*C*I*O*X*H*","*":USER.COMPL<1,MENU.NUM,AC>:"*",1) = 0 THEN USER.COMPL<1,MENU.NUM,AC> = "N"
IF ST > 0 THEN
IF ST < LS & INDEX("*C*H*X*O*","*":USER.COMPL<1,MENU.NUM,AC>:"*",1) = 0 THEN LS = ST; LS.AC = AC
END
END ELSE ST = 0
*
VALID = 1; VALID.ACCTS = LINE<1,4>; VALID.USERS = LINE<1,5>
IF VALID.ACCTS # " " & VALID.ACCTS # "" THEN
LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
END
*
IF VALID THEN
IF VALID.USERS # " " & VALID.USERS # "" THEN
LOCATE STRUCT(2) IN VALID.USERS<1> SETTING VALID ELSE VALID = 0
END
END
*
IF VALID THEN
*
SLOC(AC) = LN
GOSUB PRINT.LOOP
*
END
*
REPEAT
MAX.AC = AC - 1
!
SYS.SLOC = "LOW.STEP"
PRINT.LOW.STEP: * Return point for step completion
IF MENU.TYPE = "P" & TASK.NUM # 0 THEN
IF LS > 0 AND NOT(LS > 25) THEN
LN = SLOC(LS.AC)
ST = MENU(LS.AC)<1,8>
LINE = MENU(LS.AC)
AC = LS.AC
PR.FL = 1
GOSUB PRINT.LOOP
END
END
*
*
SYS.SLOC = "TOPIC"
PRINT @(0,3):CLL:@(0,4):CLL:
IF  MENU(1)<1,2,1> > 0 THEN
CALL.FUNCTION = "DISPLAY"; IF MENU.TYPE = "P" THEN CALL.SUB.FUNCTION = 2 ELSE CALL.SUB.FUNCTION = 1
CALL SYS.TOPIC
END
*
SYS.SLOC = "SCHED"
IF TASK.NUM # 0 THEN
PRINT @(0,3):STRUCT(62)<1,PORT+1>:
PRINT @(0,4):"Task: ":TASK.NUM:" - ":TASK.STEP:
END
!
LOOP
Input.rsp: * Return point that resets wait status and time recording.
SYS.LOCT = "FUNCTION"
SYS.SLOC = "INIT"
*
MENU.ERROR = 0; RSP=""; SYS11.PR = 0; SYS11.ELP = 0; OLD.SYS11.ELP = 0
OLD.SYS11.ELP1 = 0; EXEC.VERB = ""; PRMPTING = ""
DISP.ENT = "Enter your choice: "; PRINT @(0,23):CLL:@(20,23):DISP.ENT:
SYS11.DATE=DATE(); SYS11.TIME=TIME()
*
IF STRUCT(23)<1,PORT+1> = 1 THEN
Input.rsp.save.wait: * Return point that retains wait status.
LOOP
*
SYS11.N.DATE=DATE(); SYS11.N.TIME=TIME()
*
IF SYS11.DATE # SYS11.N.DATE THEN
SYS11.ELP = 86400 - SYS11.TIME + SYS11.N.TIME
END ELSE
SYS11.ELP = SYS11.N.TIME - SYS11.TIME
END
*
WHILE SYSTEM(11) = 0 & LEN(RSP) = 0 DO
IF SYS11.ELP > 10 THEN RQM
IF SYS11.N.DATE > SYS11.DATE ! SYS11.ELP > 60 THEN
IF USER.MODE <= HI.S.M THEN RSP = "BYE" ELSE
IF SYS11.ELP > 300 THEN
IF NOT(SYS11.PR) ! SYS11.PR = 2 THEN
IF CHECK.TIME THEN CHECK.TIME = 8; GOSUB RECORD.TIME
PRINT @(0,23):CLL:RVB:"WAIT STATUS":RVE:
DISP.ENT = "Were you working? "
SYS11.PR = 1
END
IF SYS11.ELP - 10 > OLD.SYS11.ELP THEN
PRINT @(0,0):RVB:OCONV(DATE(),"D2"):@(0,1):OCONV(TIME(),"MTS"):RVE:
END
IF SYS11.ELP - 60 > OLD.SYS11.ELP THEN
PRINT @(12,23):CLL:"- Elapsed time: ":OCONV(SYS11.ELP,"MTS"):". ":DISP.ENT:SPACE(75 - LEN(DISP.ENT) - 40):
OLD.SYS11.ELP = SYS11.ELP
END
IF SYS11.ELP - 300 > OLD.SYS11.ELP1 THEN
*
GOSUB CHECK.CONTROL
END
RQM; RQM
END
IF SYS11.ELP > 3000 THEN
FOR A = 1 TO 10; RQM; NEXT A
END
IF SYS11.ELP > 7000 THEN PRINT @(0,22):BELL:"Logging off in ":7200-SYS11.ELP:" seconds...":
IF SYS11.ELP > 7200 THEN RSP = "OFF"
END
END
REPEAT
*
*
IF SYS11.PR # 0 THEN
* Timed out or elapsed time > 60 x 60 (3600 = 1hr.)
PRINT @(0,21):CLS:@(0,23):"Welcome back...":
IF SYS11.PR THEN SYS11.PR = 2
ANSW = 0
LOOP
PRINT @(25,23):CLL:"Where you working? ":
IF SYSTEM(11) = 0 THEN RQM
IF SYSTEM(11) = 0 THEN RQM
IF SYSTEM(11) = 0 THEN RQM
IF SYSTEM(11) = 0 THEN
SYS11.PR = 0
*RSP = ""
GOTO Input.rsp.save.wait
END ELSE INPUT YES.NO,1:
IF INDEX(YES,"*":YES.NO:"*",1) # 0 THEN
ANSW = 1
END ELSE IF INDEX(NO,"*":YES.NO:"*",1) # 0 THEN
STRUCT(33)<1,PORT+1> = "WAIT.STATUS"
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
ANSW = 1
STRUCT(33)<1,PORT+1> = ""
END ELSE
ERROR.TEXT = 'your answer must be "Y" or "N"'
ERROR.CODE = 14011
*GOSUB ERROR.CONTROL
PRINT BELL:
END
WHILE NOT(ANSW) DO REPEAT
SYS11.DATE=DATE()
SYS11.TIME=TIME()
IF LEN(RSP) = 0 THEN GOTO Input.rsp
END
END
*
IF LEN(RSP)=0 THEN INPUT RSP:
*
* Still a potential hangup point but could do a character by charater
*     input until timed out on SYSTEM(11) = 0 or <CR> enter.
*
PRINT @(0,0):RVB:OCONV(DATE(),"D2"):@(0,1):OCONV(TIME(),"MTS"):RVE:
!
IF RSP = "MODE" & (USER.MODE >= HI.S.M ! STRUCT(6) >= HI.S.M) THEN
SYS.SLOC = RSP
PRINT @(20,23):CLL:"Enter Mode #: ":; INPUT MODE.ENT:
IF MODE.ENT = "PRINT" THEN
IF STRUCT(25)<1,PORT+1> = 1 THEN STRUCT(25)<1,PORT+1> = 0 ELSE STRUCT(25)<1,PORT+1> = 1
USER.UPD(1) = 1
END
IF MODE.ENT = "NEXT" & (USER.MODE < LO.D.M ! STRUCT(6) >= LO.D.M) & USER.MODE < 21 THEN
MODE.ENT = USER.MODE + 1
END ELSE
IF NUM(MODE.ENT) THEN
IF MODE.ENT > 0 AND MODE.ENT < 21 & NOT(MODE.ENT > STRUCT(6)) THEN
USER.MODE = MODE.ENT
STRUCT(24)<1,PORT+1> = USER.MODE
USER.UPD(1) = 1
END ELSE
ERROR.TEXT = "your mode was not reset"
ERROR.CODE = 15010
GOSUB ERROR.CONTROL
END
END
END
ERROR.TEXT = "your mode is ":USER.MODE
ERROR.CODE = 18010
GOSUB ERROR.CONTROL
GOTO Input.rsp
!
END ELSE IF RSP[1,4] = "WAIT" THEN
SYS.SLOC = RSP[1,4]
TEMP = FIELD(RSP," ",2)
IF LEN(TEMP) = 0 THEN TEMP = WAIT.FLAG
IF NOT(NUM(TEMP)) THEN TEMP = WAIT.FLAG
IF TEMP <= 0 & NOT(STRUCT(10)) THEN TEMP = 1
IF TEMP < 7 - STRUCT(6) THEN TEMP = 7 - STRUCT(6)
IF TEMP < 0 THEN TEMP = 0
IF TEMP > 10 THEN TEMP = 10
WAIT.FLAG = TEMP
ERROR.TEXT = "you have ":WAIT.FLAG:" waits after each message"
ERROR.CODE = 18010
GOSUB ERROR.CONTROL
USER.UPD(1) = 1
GOTO Input.rsp
!
END ELSE IF RSP = "TOPIC" & MENU(1)<1,2,1> > 0 THEN
SYS.SLOC = RSP
CALL.FUNCTION = "MENU"; IF MENU.TYPE = "P" THEN CALL.SUB.FUNCTION = 2 ELSE CALL.SUB.FUNCTION = 1
PRMPTING = RSP
CALL SYS.TOPIC
PRMPTING = ""
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP[1,4] = "TASK" THEN
SYS.SLOC = RSP[1,4]
TEMP.TASK = FIELD(RSP," ",2)
TEMP.STEP = FIELD(RSP," ",3)
IF LEN(TEMP.TASK) = 0 THEN TEMP.TASK = 0
IF TEMP.TASK = "*" THEN TEMP.TASK = TASK.NUM
IF LEN(TEMP.STEP) = 0 THEN TEMP.STEP = 1
IF NOT(NUM(TEMP.TASK)) THEN TEMP.TASK = TASK.NUM
IF NOT(NUM(TEMP.STEP)) THEN TEMP.STEP = 1
IF TEMP.STEP < 1 THEN TEMP.STEP = 1
TEMP.TASK = STR("0",(5 - LEN(TEMP.TASK))):TEMP.TASK
READV TEMP.REC FROM PS.FILE,"@J@":STRUCT(2):"@":TEMP.TASK,TEMP.STEP + 20 THEN
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
TASK.NUM = TEMP.TASK
STRUCT(61)<1,PORT+1> = TASK.NUM
TASK.STEP = TEMP.STEP
STRUCT(69)<1,PORT+1> = TASK.STEP
*
GOSUB COMPLETION.LOAD
*
STRUCT(62)<1,PORT+1> = TEMP.REC<1,2>
TEMP.REC = ""
USER.UPD(4) = 1
END ELSE
ERROR.TEXT = "the task ":TEMP.TASK:", or that step is not on file"
ERROR.CODE = 17111
GOSUB ERROR.CONTROL
END
PRMPTING = ""
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP = "SCHEDULE" THEN
SYS.SLOC = RSP
IF STRUCT(70) # PORT+1 & STRUCT(70) THEN
ERROR.TEXT = "you are using the scheduler on PORT ":STRUCT(70)-1
ERROR.CODE = 15111
GOSUB ERROR.CONTROL
END ELSE
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = RSP
GOSUB RECORD.LOCATION
EXECUTE "SYS.SCHEDULE"
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = ""
GOSUB RECORD.LOCATION
EXEC.VERB = MENU.NAME
END
!
END ELSE IF INDEX("*COMPLETED*HOLD*IN.PROGRESS*CANCELLED*NOT.STARTED*","*":FIELD(RSP," ",1):"*",1) # 0 THEN
TRS = FIELD(RSP," ",1)
SYS.SLOC = TRS
IF MENU.TYPE = "P" & TASK.NUM # 0  & LS > 0 & LS < 999 THEN
TEMP.AC = FIELD(RSP," ",2)
IF LEN(TEMP.AC) = 0 THEN TEMP.AC = LS.AC ELSE
IF NOT(NUM(TEMP.AC)) THEN TEMP.AC = LS.AC ELSE TEMP.AC = TEMP.AC + 1
END
IF TEMP.AC < 2 ! TEMP.AC > MAX.AC THEN TEMP.AC = 2
IF TRS = "COMPLETED" THEN
USER.COMPL<1,MENU.NUM,TEMP.AC> = "C"
END ELSE IF TRS = "HOLD" THEN
USER.COMPL<1,MENU.NUM,TEMP.AC> = "H"
END ELSE IF TRS = "IN.PROGRESS" THEN
USER.COMPL<1,MENU.NUM,TEMP.AC> = "I"
END ELSE IF TRS = "CANCELLED" THEN
USER.COMPL<1,MENU.NUM,TEMP.AC> = "X"
END ELSE IF TRS = "NOT.STARTED" THEN
USER.COMPL<1,MENU.NUM,TEMP.AC> = "N"
END
WRITEV USER.COMPL ON PS.FILE,USER.KEY,TASK.STEP + 1
LS = 999
END ELSE
ERROR.TEXT = "No current step to ":TRS
ERROR.CODE = 18111
GOSUB ERROR.CONTROL
END
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP = "MESSAGE" THEN
SYS.SLOC = RSP
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = RSP
GOSUB RECORD.LOCATION
EXECUTE "SYS.MESSAGE"
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = ""
GOSUB RECORD.LOCATION
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP = "" THEN
IF USER.MODE > HI.S.M THEN EXEC.VERB = MENU.PREV ELSE
READ ILSE.DISPLAY FROM SY.FILE,"@SYS@ILSE.DISPLAY" ELSE ILSE.DISPLAY = "/SL"
EXEC.VERB = ILSE.DISPLAY
ILSE.DESPLAY = ""
END
!
END ELSE IF RSP[1,1] = "/" & USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN
READV MU.VALID FROM MU.FILE,'@AS@':RSP,1 THEN MU.VALID = 1 ELSE MU.VALID = 0
IF MU.VALID THEN EXEC.VERB = RSP ELSE EXEC.VERB = MENU.NAME
!
END ELSE IF INDEX(OFF.RSP,"*":RSP:"*",1) # 0 & USER.MODE > HI.S.M THEN
EXEC.VERB = "OFF"
!
END ELSE IF INDEX(TCL.RSP,"*":RSP:"*",1) # 0 & USER.MODE >= LO.TCL.M THEN
EXEC.VERB = "TCL"
!
END ELSE IF RSP = "MENU" THEN
IF USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN EXECUTE "EI.MENUS.DEV M @AS@":MENU.NAME; OLD.MENU.NAME = "*"
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP = "EDIT.MENU" THEN
PRMPTING = RSP
GOSUB RECORD.LOCATION
IF USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN 
PRINT @(0,5):CLS:; PRINT; PRINT "Ready for EDIT."; PRINT
EXECUTE "EDIT MENUS @AS@":MENU.NAME
OLD.MENU.NAME = "*"
END
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP = "EDIT.APPL" THEN
PRMPTING = RSP
GOSUB RECORD.LOCATION
IF USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN 
PRINT @(0,5):CLS:; PRINT; PRINT "Ready for EDIT."; PRINT
EXECUTE "EDIT SYS @APPL@":MENU.APPL
OLD.MENU.NAME = "*"
END
EXEC.VERB = MENU.NAME
!
END ELSE IF INDEX(RSP,"?",1) # 0 ! INDEX(RSP,"HELP",1) # 0 THEN
SYS.SLOC = "SYS.HELP"
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = "HELP"
GOSUB RECORD.LOCATION
HELP = RSP; RSP = ""
CALL SYS.HELP(HELP,RSP)
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = ""
GOSUB RECORD.LOCATION
EXEC.VERB = MENU.NAME
END ELSE
!
SYS.SLOC = "LOCATE.OPTION"
FOR NUM = 2 TO 25 UNTIL PRMPT(NUM) = RSP ! PRMPT(NUM) = ""; NEXT NUM
IF NUM <= 25 & PRMPT(NUM) # "" THEN
*
LINE = MENU(NUM)
EXEC.VERB = LINE<1,2>
PRMPTING = PRMPT(NUM)
VALID.ACCTS = LINE<1,4>
VALID.USER = LINE<1,5>
TYPING = LINE<1,6>
MENU.FILE = LINE<1,7>
MENU.STEP = LINE<1,8>
SUBJCT = LINE<1,9>
*
IF EXEC.VERB<1,1,2> # "" THEN
PRINT @(20,23):CLL:"What is the password: ":
ECHO OFF; INPUT RSP:; ECHO ON
IF RSP = EXEC.VERB<1,1,2> THEN EXEC.VERB = EXEC.VERB<1,1,1> ELSE EXEC.VERB = ""
END
*
TEMP = ""
TEMP1 = PRMPTING
IF USER.MODE <= HI.S.M THEN
HELP = 1; CALL SYS.HELP("?":TEMP1:" ":HELP,TEMP)
TEMP1 = PRMPTING
END
*
IF USER.MODE >= LO.T.M & USER.MODE <= HI.T.M THEN
HELP = 2; CALL SYS.HELP("?":TEMP1:" ":HELP,TEMP)
TEMP1 = PRMPTING
HELP = 3; CALL SYS.HELP("?":TEMP1:" ":HELP,TEMP)
TEMP1 = PRMPTING
END
*
IF USER.MODE <= HI.S.M THEN EXEC.VERB = MENU.NAME
END ELSE EXEC.VERB = ""
END
*
!
WHILE EXEC.VERB = "" DO
*
MENU.ERROR = MENU.ERROR + 1
ERROR.TEXT = "your entry was invalid"
ERROR.CODE = 18110
GOSUB ERROR.CONTROL
IF MENU.ERROR > 3 THEN CALL SYS.HELP("?RSP 2","")
REPEAT
*
*
!
*
*
IF EXEC.VERB[1,1] # "/" & EXEC.VERB # "OFF" & EXEC.VERB # "TCL" THEN
EXEC.FILE.ITEM = ""
CN = 0
LOOP CN = CN + 1; TC = TYPING[CN,1] WHILE TC # "" DO
IF TC = " " THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:TC ELSE
IF TC = "A" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU.APPL ELSE
IF TC = "B" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:TASK.NUM ELSE
IF TC = "C" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:TASK.STEP ELSE
IF TC = "D" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:"(T)" ELSE
IF TC = "E" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:"(P)" ELSE
IF TC = "F" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU.FILE ELSE
IF TC = "G" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:"*" ELSE
IF TC = "H" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU.NAME ELSE
IF TC = "I" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU.PREV ELSE
IF TC = "J" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU.EI.APPL ELSE
IF TC = "K" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:"" ELSE
IF TC = "L" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:"" ELSE
IF TC = "M" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU.NAME[2,99] ELSE
IF TC = "N" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU.PREV[2,99] ELSE
IF TC = "O" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:PRMPTING ELSE
IF TC = "P" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:" @PRESTORES" ELSE
IF TC = "Q" THEN EXEC.FILE.ITEM = EXEC.FILE.ITEM:"" ELSE
*
IF TC = "R" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:""
*
END ELSE IF TC = "S" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:SUBJCT
*
END ELSE IF TC = "T" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:MENU(1)<1,4>:TOPIC.KEY
*
END ELSE IF TC = "U" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:USER.NAME
*
END ELSE IF TC = "V" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:""
*
END ELSE IF TC = "W" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:""
*
END ELSE IF TC = "X" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:""
*
END ELSE IF TC = "Y" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:""
*
END ELSE IF TC = "Z" THEN
EXEC.FILE.ITEM = EXEC.FILE.ITEM:TOPIC.KEY
*
END ELSE IF TC = "<" THEN
CN = CN + 1
TCC = TYPING[CN,1]
TEMP = LEN(EXEC.FILE.ITEM)
LOOP WHILE EXEC.FILE.ITEM[TEMP,1] = TCC ! EXEC.FILE.ITEM[TEMP,1] = " " DO
TEMP = TEMP - 1
EXEC.FILE.ITEM = EXEC.FILE.ITEM[1,TEMP]
REPEAT
*
END ELSE IF TC = "'" ! TC = '"' THEN
TCC = TC
LOOP
CN = CN + 1
TC = TYPING[CN,1]
WHILE TC # TCC & TC # "" DO
EXEC.FILE.ITEM = EXEC.FILE.ITEM:TC
REPEAT
END ELSE
*
EXEC.FILE.ITEM = EXEC.FILE.ITEM:TC
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
REPEAT
*
CHECK.TIME = 1; GOSUB RECORD.TIME
GOSUB RECORD.LOCATION
*EXECUTE EXEC.VERB:EXEC.FILE.ITEM, //SELECT. > EXEC.LIST, //OUT. > EXEC.RESULT, \\IN. < EXEC.PARAM
*EXECUTE EXEC.VERB:EXEC.FILE.ITEM, //SELECT. < EXEC.LIST, //OUT. > EXEC.RESULT, \\IN. < EXEC.PARAM
*
EXEC.LIST = ""; EXEC.PARAM = ""; EXEC.RESULT = ""
ERROR.TEXT = "you will now execute: ":EXEC.VERB:EXEC.FILE.ITEM
ERROR.CODE = 19000
GOSUB ERROR.CONTROL
PRINT @(0,5):CLS:
EXECUTE EXEC.VERB:EXEC.FILE.ITEM
*
IF LEN(EXEC.RESULT) # 0 THEN
LOOP
ERROR.TEXT = EXEC.RESULT<1,1>
ERROR.CODE = 19110
IF LEN(ERROR.TEXT) # 0 THEN GOSUB ERROR.CONTROL
EXEC.RESULT = DELETE(EXEC.RESULT,1)
WHILE LEN(EXEC.RESULT) # 0 DO
REPEAT
END
*
CHECK.TIME = 1; GOSUB RECORD.TIME
PRINT @(0,23):CLL:@(40):"Enter <cr> to return to menu    ":
INPUT YES.NO:
PRMPTING = ""
EXEC.VERB = MENU.NAME
END
*
WHILE EXEC.VERB[1,1] = "/" DO MENU.NAME = EXEC.VERB REPEAT
*
PARAM = FIELD(EXEC.VERB," ",2)
IF PARAM # "" THEN
PARAM = " ":PARAM
EXEC.VERB = FIELD(EXEC.VERB," ",1)
END
*
*
ERROR.TEXT = "Serious software fault"
IF EXEC.VERB = "OFF" THEN
DELETE AC.FILE,CALL.ID
ERROR.TEXT = "Thank you ":USER.NAME:". I am now ending."
END ELSE
IF EXEC.VERB = "TCL" THEN ERROR.TEXT = "Remember ":USER.NAME:", to log off through the menu."
END
FOR TEMP = 1 TO WAIT.FLAG; RQM; NEXT TEMP
GOSUB LOG.OUT.OF.MENU
PRINT @(0,5):CLS:BELL:@(10,13):ERROR.TEXT:
EXEC.FILE.ITEM = ""; EXEC.PARAM = ""; EXEC.RESULT = ""; EXEC.LIST = ""
EXECUTE EXEC.VERB:EXEC.FILE.ITEM, //IN. < EXEC.PARAM, //OUT. > EXEC.RESULT
STOP
!
PRINT.LOOP: * FOR PRINTING SCREEN OPTIONS
*
NUM = 0
LOOP NUM = NUM + 1; TEXT = LINE<1,1,NUM> WHILE TEXT # "" DO
*
IF TEXT[1,1] = "*" THEN
IF TEXT # "*" THEN PRINT @(CL-2,LN):TEXT[2,99]
END ELSE IF TEXT[1,1] = "+" THEN
*
PRINT @(CL,LN):"    ":
IF MENU.TYPE = "P" ! (ST # "0" & ST # "" & ST # " ") THEN PRINT "    ":
IF PR.FL = 1 THEN PRINT RVB:TEXT[2,99]:RVE: ELSE PRINT TEXT[2,99]:
END ELSE
IF TEXT # "" & TEXT # " " THEN PRINT @(CL,LN):RVB:PRMPT(AC) "R#3":RVE:" ":
IF MENU.TYPE = "P" ! (ST # "0" & ST # "" & ST # " ") THEN
IF (ST # "0" & ST # "" & ST # " ") THEN
PRINT ST "R#2":". ":
END ELSE PRINT " .. ":
END
STAT.NUM = INDEX(STAT.CHECK,"*":USER.COMPL<1,MENU.NUM,AC>:"*",1)
IF PR.FL = 1 THEN
PRINT RVB:TEXT:RVE:
IF TASK.NUM # 0 & STAT.NUM # 0 THEN
STAT.NUM = (STAT.NUM + 1) / 2
PRINT "     ":STAT.DESC(STAT.NUM):
END
END ELSE
PRINT TEXT:
IF TASK.NUM # 0 & STAT.NUM # 0 & USER.COMPL<1,MENU.NUM,AC> # "N" THEN
STAT.NUM = (STAT.NUM + 1) / 2
PRINT "     ":STAT.DESC(STAT.NUM):
END
END
END
LN = LN + 1
REPEAT
RETURN
!
1000 * DEFAULTS
AC = 3
LOOP DEFAULT = DEFAULTS<AC> UNTIL DEFAULT<1,3> = RSP ! DEFAULT = "" DO AC = AC+1 REPEAT
IF DEFAULT = "" THEN EXEC.VERB = ""; RETURN
VALID = 1; VALID.ACCTS = DEFAULT<1,4>
IF VALID.ACCTS # " " & VALID.ACCTS # "" THEN LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN EXEC.VERB = DEFAULT<1,2> ELSE EXEC.VERB = ""
RETURN
!
COMPLETION.LOAD: *#* Load completion status for user.
IF MENU.TYPE = "P" & TASK.NUM # 0 THEN
USER.KEY = "@C@":USER.NAME:"@":TASK.NUM:"@":MENU.APPL
SYS.FILE = "PSD"
SYS.ITEM = USER.KEY
READV USER.COMPL FROM PS.FILE,USER.KEY,TASK.STEP + 1 ELSE
USER.COMPL = ""
ERROR.TEXT = "this procedure is not included with this step!"
ERROR.CODE = 15010
GOSUB ERROR.CONTROL
END
END ELSE
USER.COMPL = ""
END
RETURN
!
LOG.OUT.OF.MENU: *#* WRITE OUT GOING TRACE RECORD
SYS.SLOC = "LOG.OUT.OF.MENU"
CALL.FUNCTION = "LOG":EXEC.VERB
CALL.SUB.FUNCTION = "UPDATE"
IF CHECK.TIME THEN CHECK.TIME = 8; GOSUB RECORD.TIME
MAT USER.UPD = 1
PRMPTING = EXEC.VERB; RSP = EXEC.VERB
GOSUB RECORD.USER.CALL
RETURN
!
LOG.IN.TO.MENU: *#* WRITE TIME RECORD WITH ELASPED TIME AND SUBR.FUNCTION
*
*
OFF.FLAG = 0
SCH.FLAG = 0
TCL.FLAG = 0
MSG.FLAG = 0
MAL.FLAG = 0
PASS.INPUT = ""
PASS.FLAG = 0
*
LOG.IN.RETURN: * reloop point
IF USER.NAME # ""  THEN
CALL.FUNCTION = "LOGON"
CALL.SUB.FUNCTION = "READ"
GOSUB RECORD.USER.CALL
IF USER.ABORT THEN RETURN
*
IF NOT(STRUCT(1)) THEN OFF.FLAG = 1; SCH.FLAG = 4
*
IF NOT(STRUCT(21)<1,PORT+1>) THEN OFF.FLAG = 1
IF STRUCT(33)<1,PORT+1> = "TCL" THEN TCL.FLAG = 1
IF STRUCT(33)<1,PORT+1> = "OFF" THEN OFF.FLAG = 1
IF NOT(OFF.FLAG) & NOT(TCL.FLAG) THEN PASS.FLAG = 0
END ELSE MAT STRUCT = ""; USER.FLAG = 0; PASS.FLAG = 1
*
*
IF NOT(USER.FLAG) THEN
PASS.INPUT = ""
PRINT @(0,5):CLS:@(0,7):"Who is there? ":
ECHO OFF; INPUT USER.NAME:; ECHO ON
PASS.INPUT = FIELD(USER.NAME,",",2)
USER.NAME  = FIELD(USER.NAME,",",1)
USER.FLAG = 1; PASS.FLAG = 1
GOTO LOG.IN.RETURN
END
*
*
IF PASS.FLAG THEN
LOOP WHILE PASS.INPUT # STRUCT(3) & PASS.FLAG < 6 DO
PRINT @(0,9):"What is your password ":USER.NAME:"? ":
IF LEN(PASS.INPUT) = 0 THEN ECHO OFF; INPUT PASS.INPUT:; ECHO ON
IF PASS.INPUT # STRUCT(3) THEN
PASS.FLAG = PASS.FLAG + 1
ERROR.TEXT = "Invalid password (":PASS.INPUT:" # ":STRUCT(3):", attempt no. ":PASS.FLAG:")"
ERROR.CODE = 14110
GOSUB ERROR.CONTROL
PASS.INPUT = ""
END ELSE
WRITE AM:USER.NAME:AM:(DATE()+100000)[2,5]:(TIME()+100000)[2,5] ON AC.FILE,CALL.ID
END
REPEAT
END
IF PASS.FLAG > 5 THEN CHAIN "MENU-RUN OFF"
*
IF STRUCT(15)<1,PORT+1> = 9 THEN
CALL.FUNCTION = "LOGON"
CALL.SUB.FUNCTION = "NEW.USER"
CALL SYS.USER.PORT.NEW
END
*
CALL.FUNCTION = "LOGON"
CALL.SUB.FUNCTION = "UPDATE"
GOSUB RECORD.USER.CALL
IF USER.ABORT THEN RETURN
*
RETURN
!
CHECK.CONTROL: * Subroutine to monitor user system functions.
*
*
SYS.ITEM = "@SYS@USER@":STRUCT(2)
SYS.FILE = "SYS"
READV CK.SCH FROM SY.FILE,SYS.ITEM,70 ELSE CK.SCH = 0; SYS.ABORT = 1
IF CK.SCH & CK.SCH # PORT+1 THEN
ERROR.TEXT = "your SCHEDULE is in use at port ":PORT+1
ERROR.CODE = 17010
GOSUB ERROR.CONTROL
END ELSE
TEMP.LAST = STRUCT(65)
TEMP.NELP = STRUCT(63)
GOSUB CHECK.ELP
IF TEMP.CK = 1 THEN SCH.FLAG = 2
TEMP.LAST = STRUCT(68)
TEMP.NELP = STRUCT(66)
GOSUB CHECK.ELP
IF TEMP.CK = 1 THEN SCH.FLAG = 3
TEMP.LAST = STRUCT(71)
TEMP.NELP = STRUCT(72)
GOSUB CHECK.ELP
IF TEMP.CK = 1 THEN SCH.FLAG = 4
END
*
IF SCH.FLAG THEN
ERROR.TEXT = "your schedule needs a ":FIELD("POOP*LOAD*PURGE*VEIWING**","*",SCH.FLAG)
ERROR.CODE = 17111
GOSUB ERROR.CONTROL
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
USER.UPD(2) = 1
PRMPTING = "SCHEDULE"
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "UPDATE"
GOSUB RECORD.USER.CALL
EXECUTE "SYS.SCHEDULE"
RSP = MENU.NAME
SCH.FLAG = 0
PRMPTING = ""
GOSUB RECORD.LOCATION
END
*
READV CK.MSG FROM SY.FILE,SYS.ITEM,91 ELSE CK.MSG = 0; SYS.ABORT = 1
IF CK.MSG & CK.MSG # PORT+1 THEN
ERROR.TEXT = "your MESSAGE is in use at port ":PORT+1
ERROR.CODE = 17010
GOSUB ERROR.CONTROL
END ELSE
TEMP.PRIOR = 100
TEMP.USER = ""
FOR TEMP = 1 TO 20 UNTIL STRUCT(86)<1,TEMP> = ""
IF STRUCT(87)<1,TEMP> < TEMP.PRIOR THEN
TEMP.PRIOR = STRUCT(87)<1,TEMP>
TEMP.USER = STRUCT(88)<1,TEMP>
END
NEXT TEMP
IF TEMP.PRIOR # 100 THEN
ERROR.TEXT = "there is a priority ":TEMP.PRIOR:" message from ":TEMP.USER
ERROR.CODE = 17010
GOSUB ERROR.CONTROL
IF TEMP.PRIOR <= STRUCT(84) THEN
ERROR.TEXT = "you will have to view it immediately"
ERROR.CODE = 17011
GOSUB ERROR.CONTROL
MSG.FLAG = 1
END ELSE
IF STRUCT(83) # 0 THEN
TEMP.MSG = (100000+DATE())[1,5]:(100000+TIME())[1,5]
IF STRUCT(83) <= TEMP.MSG THEN
ERROR.TEXT = "you are now available to accept mail"
ERROR.CODE = 17111
GOSUB ERROR.CONTROL
STRUCT(83) = 0
END ELSE
ERROR.TEXT = "you are not taking mail until ":OCONV(STRUCT(83)[6,5],"MT"):" on ":OCONV(STRUCT(83)[1,5],"D2")
ERROR.CODE = 17000
GOSUB ERROR.CONTROL
END
END
IF STRUCT(83) # 0 THEN
PRINT @(0,21):CLS:@(0,23):"Do you want to see this message? ":
INPUT YES.NO:
IF INDEX(YES,"*":YES.NO:"*",1) # 0 THEN MSG.FLAG = 1
END
END
END
*
IF MSG.FLAG THEN
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
USER.UPD(2) = 1
PRMPTING = "MESSAGE"
CALL.FUNCTION = "MENU"
CALL.SUB.FUNTION = "UPDATE"
GOSUB RECORD.USER.CALL
EXECUTE "SYS.MESSAGE"
RSP = MENU.NAME
MSG.FLAG = 0
PRMPTING = ""
GOSUB RECORD.LOCATION
END
*
IF CONTROL.DATE # DATE() THEN
IF NOT(DATE() = CONTROL.DATE+1 & TIME() < 10000) THEN
CALL SYS.CONTROL.DATE
CONTROL.DATE = CO.DATA<2,1,1>
RSP = MENU.NAME
END
END
*
*
RETURN
!
CHECK.ELP: * Last date checked, # of elp units/type, ck flag.
TEMP.CD = DATE(); TEMP.CT = TIME()
TEMP.LD = TEMP.LAST[1,5]; TEMP.LT = TEMP.LAST[6,5]
TEMP.TYPE = TEMP.NELP<1,1>; TEMP.UNITS = TEMP.NELP<1,2>
TEMP.CK = 0
IF TEMP.TYPE = "S" THEN
TEMP.LT = TEMP.LT + TEMP.UNITS
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LT = TEMP.LT + (TEMP.UNITS * 60)
END ELSE IF TEMP.TYPE = "H" THEN
TEMP.LT = TEMP.LT + (TEMP.UNITS * 3600)
END ELSE
TEMP.CT = 0
IF TEMP.TYPE = "D" THEN
TEMP.LD = TEMP.LD + TEMP.UNITS
END ELSE IF TEMP.TYPE = "W" THEN
TEMP.LD = TEMP.LD + (TEMP.UNITS * 7)
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LD = TEMP.LD + INT(TEMP.UNITS * 30.416)
END ELSE IF TEMP.TYPE = "Q" THEN
TEMP.LD = TEMP.LD + 91
END ELSE IF TEMP.TYPE = "Y" THEN
TEMP.LD = TEMP.LD + (TEMP.UNITS * 365)
END
END
*
LOOP WHILE TEMP.LT >= 86400 DO
TEMP.LD = TEMP.LD + 1
TEMP.LT = TEMP.LT - 86400
REPEAT
*
IF TEMP.LD >= TEMP.CD & TEMP.LT >= TEMP.CD THEN TEMP.CK = 1
*
RETURN
!
RECORD.USER.CALL: *Subroutine to update user info
*
SYS.SLOC = "RECORD.USER.CALL"
IF CALL.FUNCTION # "LOGON" & CALL.FUNCTION # "LOGOFF" & CALL.FUNCTION # "MENU" THEN CALL.FUNCTION = "UNKNOWN"
IF CALL.SUB.FUNCTION # "UPDATE" & CALL.SUB.FUNCTION # "READ" THEN
IF CALL.SUB.FUNCTION # "WRITE" & CALL.SUB.FUNCTION # "RESET" THEN RETURN
END
LOOP
SYS.FILE = "SYS"
IF STRUCT(2) # "" THEN USER.NAME = STRUCT(2)
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
WHILE (USER.LOCKED & USER.LOCKED # PORT+1) & NOT(USER.ABORT) DO REPEAT
RETURN
!
RECORD.LOCATION: * to record you menu location & topics
USER.UPD(2) = 1
TEMP = (100000+DATE())[1,5]
TEMP = TEMP:(100000+TIME())[1,5]
IF TEMP > LAST.LOCT + (STRUCT(48) * 5) ! LEN(PRMPTING) # 0 THEN
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "UPDATE"
GOSUB RECORD.USER.CALL
LAST.LOCT = TEMP
END ELSE
STRUCT(29)<1,PORT + 1> = USER.CO.CODE
STRUCT(30)<1,PORT + 1> = MENU.APPL
STRUCT(31)<1,PORT + 1> = MENU.EI.APPL
STRUCT(32)<1,PORT + 1> = MENU.NAME
STRUCT(33)<1,PORT + 1> = PRMPTING
STRUCT(34)<1,PORT + 1> = TOPIC.KEY
STRUCT(35)<1,PORT + 1> = MENU.NUM
END
RETURN
!
RECORD.TIME: * to record time usage
*
IF CHECK.TIME THEN
CALL SYS.TIME
END
*
RETURN
!
RECORD.SCHEDULE: * to record a change in task or step
STRUCT(61)<1,PORT+1> = TASK.NUM
STRUCT(69)<1,PORT+1> = TASK.STEP
USER.UPD(4) = 1
RETURN
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*
END
~PATTERN~
*PROGRAM: PATTERN
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
CL = 40
LN = 11
B = 1
INPUT M
IF NOT(NUM(M)) THEN M = 1.02
FOR A = 1 TO 3 UNTIL SYSTEM(11)
PRINT @(0,0):CLS:@(40,23):
B=1
FOR A1 = 1 TO 100 UNTIL SYSTEM(11)
RQM
FOR A2 = 1 TO 4
PRINT @(CL,LN):RVB:".":RVE:@(40,23):
IF M < 1 THEN
B = B + M
END ELSE
B = B * M
END
C = INT(B)
IF A2 = 1 OR A2 = 3 THEN C = INT(C*.65)
IF A2 = 1 THEN
LN = LN - C
END ELSE IF A2 = 2 THEN
CL = CL + C
END ELSE IF A2 = 3 THEN
LN = LN + C
END ELSE 
CL = CL  - C
END
NEXT A2
NEXT A1
NEXT A
PRINT @(0,22):
END
~PATTERN1~
*PROGRAM: PATTERN1
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*A=0; A1=0; A2=0; A3=0; A4=0; B=0; C=0; CL=40; LN=11; D=0
A=0; A1=A; A2=A; A3=A; A4=A; B=A; C=A; CL=4A; LN=11; D=A
PRINT
PRINT
PRINT "Character for display? ":
INPUT PCHAR
FOR A = 1 TO 2 UNTIL SYSTEM(11)
IF INT(A/2) * 2 = A THEN D = 19 ELSE D = 12
IF INT(A/7) * 7 = A THEN D = 28
IF INT(A/11) * 11 = A THEN D = 5
CL = 40
LN = 11
B = 1
PRINT @(0,0):CLS:@(40,23):
FOR A1 = 1 TO D UNTIL SYSTEM(11)
*RQM
FOR A2 = 1 TO 7 UNTIL NOT(SYSTEM(11)) AND A2 GT 4
B = B + 1
C = B
IF A2 = 1 OR A2 = 3 THEN C = INT(B*.5)
FOR A3 = 1 TO C
IF SYSTEM(11) THEN LN = LN + 2
PRINT @(CL,LN):RVB:PCHAR:RVE:
IF SYSTEM(11) THEN
IF CL > 80 THEN CL = 1
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
END
*@(40,23):
IF A2 = 1 THEN
LN = LN - 1
END ELSE IF A2 = 2 THEN
CL = CL + 1
END ELSE IF A2 = 3 THEN
LN = LN + 1
END ELSE 
CL = CL  - 1
END
NEXT A3
NEXT A2
NEXT A1
IF NOT(SYSTEM(11)) THEN
EXECUTE "SLEEP 15"
END
NEXT A
PRINT @(0,22):A1
END
~PATTERN2~
*PROGRAM: PATTERN2
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*A=0; A1=0; A2=0; A3=0; A4=0; B=0; C=0; CL=40; LN=11; D=0
A=0; A1=A; A2=A; A3=A; A4=A; B=A; C=A; CL=4A; LN=11; D=A
PRINT
PRINT
PRINT "Character for display? ":
INPUT PCHAR
FOR A = 1 TO 3 UNTIL SYSTEM(11)
IF INT(A/2) * 2 = A THEN D = 19 ELSE D = 12
IF INT(A/7) * 7 = A THEN D = 28
IF INT(A/11) * 11 = A THEN D = 5
CL = 40
LN = 11
B = 1
PRINT @(0,0):CLS:@(40,23):
FOR A1 = 1 TO D UNTIL SYSTEM(11)
*RQM
FOR A2 = 1 TO 6 UNTIL NOT(SYSTEM(11)) AND A2 GE 4
B = B + 1
C = B
IF A2 = 1 OR A2 = 3 THEN C = INT(B*.5)
FOR A3 = 1 TO C
IF SYSTEM(11) THEN LN = LN + 2
PRINT @(CL,LN):RVB:PCHAR:RVE:
IF SYSTEM(11) THEN
IF CL > 80 THEN CL = 1
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
END
*@(40,23):
IF A2 = 1 THEN
LN = LN - 1
END ELSE IF A2 = 2 THEN
CL = CL + 1
END ELSE IF A2 = 3 THEN
LN = LN + 1
END ELSE 
CL = CL  - 1
END
NEXT A3
NEXT A2
NEXT A1
IF NOT(SYSTEM(11)) THEN
EXECUTE "SLEEP 15"
END
NEXT A
PRINT @(0,22):A1
END
~PATTERN3~
*PROGRAM: PATTERN3
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*A=0; A1=0; A2=0; A3=0; A4=0; B=0; C=0; CL=40; LN=11; D=0
A=0; A1=A; A2=A; A3=A; A4=A; B=A; C=A; CL=4A; LN=11; D=A
PRINT
PRINT
PRINT "Character for display? ":
INPUT PCHAR
FOR A = 1 TO 8 UNTIL SYSTEM(11)
IF INT(A/2) * 2 = A THEN D = 19 ELSE D = 12
IF INT(A/7) * 7 = A THEN D = 28
IF INT(A/11) * 11 = A THEN D = 5
CL = 40
LN = 11
B = 1
PRINT @(0,0):CLS:@(40,23):
FOR A1 = 1 TO D UNTIL SYSTEM(11)
*RQM
FOR A2 = 1 TO 6 UNTIL NOT(SYSTEM(11)) AND A2 GE 4
B = B + 1
C = B
IF A2 = 1 OR A2 = 3 THEN C = INT(B*.5)
FOR A3 = 1 TO C
IF SYSTEM(11) THEN LN = LN + 2
PRINT @(CL,LN):RVB:PCHAR:RVE:
IF SYSTEM(11) THEN
IF CL > 80 THEN CL = 1
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
END
*@(40,23):
IF A2 = 1 THEN
LN = LN - 1
END ELSE IF A2 = 2 THEN
CL = CL + 1
END ELSE IF A2 = 3 THEN
LN = LN + 1
END ELSE 
CL = CL  - 1
END
NEXT A3
NEXT A2
NEXT A1
IF NOT(SYSTEM(11)) THEN
EXECUTE "SLEEP 15"
END
NEXT A
PRINT @(0,22):A1
END
~PATTERN4~
*PROGRAM: PATTERN4
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*A=0; A1=0; A2=0; A3=0; A4=0; B=0; C=0; CL=40; LN=11; D=0
A=0; A1=A; A2=A; A3=A; A4=A; B=A; C=A; CL=4A; LN=11; D=A
PRINT
PRINT
PRINT "Character for display? ":
INPUT PCHAR,1
IF PCHAR EQ " " OR PCHAR EQ "" THEN PCHAR = "@"
FOR A = 1 TO 20 UNTIL SYSTEM(11)
IF INT(A/2) * 2 = A THEN D = 11 ELSE D = 3
IF INT(A/7) * 7 = A THEN D = 10
IF INT(A/11) * 11 = A THEN D = 5
CL = 40
LN = 11
B = 1
PRINT @(0,0):CLS:@(40,23):
FOR A1 = 1 TO D UNTIL SYSTEM(11)
*RQM
FOR A2 = 1 TO 6 UNTIL NOT(SYSTEM(11)) AND A2 GE 4
B = B + 1
C = B
IF A2 = 1 OR A2 = 3 THEN C = INT(B*.5)
FOR A3 = 1 TO C
IF SYSTEM(11) THEN LN = LN + 2
PRINT @(CL,LN):RVB:PCHAR:RVE:
IF SYSTEM(11) THEN
IF CL > 80 THEN CL = 1
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
CL = CL + 1
PRINT @(CL,LN):RVB:PCHAR:RVE:
END
*@(40,23):
IF A2 = 1 THEN
LN = LN - 1
END ELSE IF A2 = 2 THEN
CL = CL + 1
END ELSE IF A2 = 3 THEN
LN = LN + 1
END ELSE 
CL = CL  - 1
END
NEXT A3
NEXT A2
NEXT A1
IF NOT(SYSTEM(11)) THEN
EXECUTE "SLEEP 15"
END
NEXT A
PRINT @(0,22):A1
END
~PDATE~
*PROGRAM: PDATE
*
* AUTHOR: DAVID HORSMAN
*
**DATE.VAL = OCONV(DATE(),"D2/")**
TIME.VAL = OCONV(TIME(),"MTH")
EXEC.VERB = "BLOCK-PRINT ":DATE.VAL:" ":TIME.VAL:" (P)"
EXEUCTE EXEC.VERB
END
~PRC.CONVERT~
*PROGRAM: PRC.CONVERT
*
* AUTHOR: DAVID HORSMAN
*
**DIM PRC.IN.KEY(200), PRC.OUT.KEY(200)**
DIM IN.PRC(100), OUT.PRC(100)
MAT OUT.PRC = ''
MAT IN.PRC = ''
MAT PRC.IN.KEY = ''
MAT PRC.OUT.KEY = ''
PROGRAM.CONTROL = 'CONTINUE'
LOCT = 1
$INCLUDE AX.IBP STANDARD.FUNCTIONS
OPEN 'SYS.STRUCTURE' TO SYSS ELSE STOP
LOCT = 2
OPEN 'AX.PRC' TO IN.FILE ELSE STOP
LOCT = 3
OPEN 'PRC' TO OUT.FILE ELSE STOP
LOCT = 5
MATREAD PRC.IN.KEY FROM SYSS,'PRC.LIST' ELSE STOP
LOCT = 6
MATREAD PRC.OUT.KEY FROM SYSS,'OUT.PRC.LIST' ELSE STOP
LOCT = 7
KEY.COUNTER = 0
LOOP
KEY.COUNTER = KEY.COUNTER + 1
WHILE PROGRAM.CONTROL # 'STOP' AND PRC.IN.KEY(KEY.COUNTER) # '' DO
MATREAD IN.PRC FROM IN.FILE,PRC.IN.KEY(KEY.COUNTER) ELSE STOP
MAT OUT.PRC = ''
OUT.PRC(1)='CTVL'
OUT.PRC(2)=''
OUT.PRC(3)=IN.PRC(1):VM:IN.PRC(3):VM:'SALES STAFF':VM:IN.PRC(2):VM:'0'
OUT.PRC(4)=IN.PRC(4)
OUT.PRC(5)='840820':SVM:'DGH':VM
OUT.PRC(6)=''
OUT.PRC(7)='SALES'
OUT.PRC(8)=''
OUT.PRC(9)=IN.PRC(5)
MATWRITE OUT.PRC ON OUT.FILE,PRC.OUT.KEY(KEY.COUNTER)
REPEAT
END
~PRC.CONVERT.8411~
*PROGRAM: PRC.CONVERT.8411
*
DIM CTC.KEY(200)
DIM CTC(30)
MAT CTC = ''
MAT CTC.KEY = ''
PROGRAM.CONTROL = 'CONTINUE'
LOCT = 1
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN 'SYS' TO SYSS ELSE STOP
LOCT = 2
OPEN 'PRC' TO CT.FILE ELSE STOP
LOCT = 5
MATREAD CTC.KEY FROM SYSS,'CTC.LIST' ELSE STOP
LOCT = 6
MATREAD CTC.KEY FROM SYSS,'CTC.LIST' ELSE STOP
LOCT = 7
PRINT @(0,0):CLS:@(20):'CONVERSION NOW RUNNING . . . . . . .':
KEY.CN = 0
LOOP
KEY.CN = KEY.CN + 1
WHILE PROGRAM.CONTROL # 'STOP' AND CTC.KEY(KEY.CN) # '' DO
MATREAD CTC FROM CT.FILE,CTC.KEY(KEY.CN) ELSE STOP
PRINT @(0,10):CLL:KEY.CN:'.':CTC.KEY(KEY.CN):
*
OPER.TEMP1 = CTC(5)<1,1,1>
OPER.TEMP2 = OPER.TEMP1[3,2]:'/':OPER.TEMP1[5,2]:'/':OPER.TEMP1[1,2]
PRINT @(0,12):CLL:'OPER: ':OPER.TEMP2:
OPER.TEMP = ICONV(OPER.TEMP2,'D2\')
PRINT ' ------ ':OPER.TEMP:
*
TEMP.DATE1 = CTC(3)<1,1,1>
TEMP.DATE2 = TEMP.DATE1[3,2]:'/':TEMP.DATE1[5,2]:'/':TEMP.DATE1[1,2]
PRINT @(0,14):CLL:'DATE: ':TEMP.DATE2:
TEMP.DATE = ICONV(TEMP.DATE2,'D2\')
PRINT ' ------ ':TEMP.DATE:
*
TEMP.TIME1 = CTC(3)<1,4,1>
TEMP.TIME2 = TEMP.TIME1[1,2]:':':TEMP.TIME1[3,2]:':':TEMP.TIME1[5,2]
PRINT @(0,15):CLL:'TIME: ':TEMP.TIME2:
TEMP.TIME = ICONV(TEMP.TIME2,'MTS')
PRINT ' ------ ':TEMP.TIME:
*
CTC(3)<1,1,1> = TEMP.DATE
CTC(3)<1,4,1> = TEMP.TIME
CTC(5)<1,1,1> = OPER.TEMP
CTC(5) = CTC(5):DATE():SVM:'Dave':VM
PRINT @(0,17):CLL:"CTC5: ":CTC(5):
*
MATWRITE CTC ON CT.FILE,CTC.KEY(KEY.CN)
IF KEY.CN < 10 THEN
RQM; RQM; RQM
IF KEY.CN < 5 THEN 
RQM; RQM; RQM
END
END
REPEAT
END
~PROC.WRITE.COUNT~
*PROGRAM: PROC.WRITE.COUNT
*
* AUTHOR: DAVID HORSMAN
*
EQU ONE TO 1
EQU AM TO CHAR(254)
PROMPT CHAR(0)
PRINT "ENTER PROC NAME: ":; INPUT PROC.NAME
IF NOT(LEN(PROC.NAME)) THEN STOP
OPEN "MD" TO MD.FILE ELSE STOP
*
READ PROC FROM MD.FILE,PROC.NAME THEN
STOP
END ELSE
PROC = "PQN"
END
*
PRINT "ENTER FILE NAME PREFIX: ":; INPUT FILE.NAME.PREFIX
PRINT
PRINT "     ":PROC.NAME
PRINT
*
CONT = 1
*
LOOP
READNEXT FILE.ID THEN
PROC<-ONE> = "C":AM:"C":AM:"HCOUNT ":FILE.NAME.PREFIX:FILE.ID:AM:"P":AM:"C":AM:"CCCCCCCCC":AM:"C"
PRINT FILE.NAME.PREFIX:FILE.ID
END ELSE CONT = 0
WHILE CONT DO REPEAT
*
PROC<-ONE> = "C":AM:"X"
WRITE PROC ON MD.FILE,PROC.NAME
STOP
END
~RECREATE.ACX.COM~
*PROGRAM: RECREATE.ACX.COM
EQU VS TO " (R:1.0)"
*
* COPYRIGHT     MACROSCOPE DESIGN MATRIX
*   1992           ALL RIGHTS RESERVED
*
* AUTHOR: DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:      RECREATE NAME INDEX FILE FROM ACT...
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ACX.DIM
$INCLUDE IBP SAVE.ACT.DIM
$INCLUDE IBP SAVE.ACT.EQUATES
$INCLUDE IBP ACX.EQUATES
*
! System Control
*
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB: "Can't open CNT.":; INPUT TMP:
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE>
*
* System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "SYS"
SYS.APPL.SUB = "INDEX"; SYS.PROG = "UPDATE.INDEXES.STD"; SYS.LOC = "INIT"
SYS.APPL.LOC = ONE
VERSION = VS; AUTO.RUN = FALSE; REDISP = FALSE; DISP.ONLY = FALSE
STAT = FALSE
*
DT = DATE(); TIME = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
*
*: * Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
SYS.LOC = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOC) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
! Open files
*
OPEN "ACT" TO ACT.FILE ELSE PRINT CLB: "Can't open ACT.":; INPUT TMP:
*
OPEN "ACX" TO ACX.FILE ELSE PRINT CLB: "Can't open ACX.":; INPUT TMP:
*
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB: "Can't open PAR.":; INPUT TMP:
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS.":; INPUT TMP:
* LCK.FILE = 0; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
*
MAT SAVE.ACT = EMPTY
*
!
*
PRINT @(ZERO,ZERO):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME)/ TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Recreate Account Name Index":VERSION
PRINT @(ZERO,ONE):(SPACE(40 - LEN(TITLE)/ TWO):TITLE) "L#80":RVE:
*
INPUT AUTO.RUN:
*
IF AUTO.RUN THEN READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("RECREATE.ACX.COM",EMPTY,"Index Name")
*
* * PRINT @(ZERO,8):CLL:"Clearing Name Index File 'ACX'":
* * PRINT @(ZERO,9):
* * *
* * EXECUTE 'CLEAR-FILE DATA ACX'
*
PRINT @(ZERO,3):CLL:"Sorting accounts by name...":
EXLN = " BY CUS.LAST.NAME BY CUS.FIRST.NAME"
PRINT @(ZERO,3)
*
* EXECUTE 'SSELECT ACT ':EXLN
*
EXECUTE 'GET-LIST ACT.NAME', //SELECT. > ACT.ID.LIST
*
CTR = ZERO; LN = 3; LINE = ONE
STAT = FALSE
*
!
*
NXT: *
*
READNEXT ACT.ID FROM ACT.ID.LIST ELSE STOP
*
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE GOTO NXT
*
MAT SAVE.ACT = EMPTY
CTR = CTR + ONE
PRINT @(ZERO,4):CLL:CTR "R#5":ACT.ID "R#10":"    ":ACT$CUS.NAME "L#30":ACT$ALT.NAME:
*
NEW.NAME = ACT$CUS.NAME; NEW.NAME = TRIM(FIELD(NEW.NAME,"*",1):" ":FIELD(NEW.NAME,"*",2))
*
*
CALL UPDATE.INDEXES.STD(NEW.NAME,ACT.ID,"ACX.COM","I",2,"AL",15,5,LCK.ITM,LCK.TYPE,LCK.STAT,LCK.FILE,STAT,CO.DATA,MAT CNT.TST,CNT.TST.ID)
*
*
MATWRITE ACT ON ACT.FILE,ACT.ID
*
GOTO NXT
*
STOP
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
*
END
~RVB~
*PROGRAM: RVB
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT RVB:
*
END
~SUB.INIT.TABLES.CT~
SUBROUTINE SUB.INIT.TABLES.CT(MAT CTC.ERR.MSG,MAT CTC.PROG.LOCT)
*SUBROUTINE: SUB.INIT.TABLES.CT
*
* AUTHOR: DAVID HORMSMAN     OF    AIM SERVICES
*                                  PH: 254-9889
*                                  VAN., B.C.
*
*
* 
$INCLUDE IBP STANDARD.FUNCTIONS
* 
DIM CTC.ERR.MSG(20)
DIM CTC.PROG.LOCT(20)
MAT CTC.ERR.MSG = 'ERROR'
MAT CTC.PROG.LOCT = 'PROGRAM LOCATION ??'
CTC.ERR.MSG(1) = 'That sequence # not found'
CTC.ERR.MSG(2) = 'Too many transaction, please purge'
CTC.ERR.MSG(3) = 'That is not a valid choice'
CTC.ERR.MSG(4) = 'That field number is invalid'
CTC.ERR.MSG(5) = 'You must enter this field'
CTC.ERR.MSG(6) = 'You must enter a seqence number on a change'
CTC.ERR.MSG(7) = 'Purge feature not yet released'
CTC.ERR.MSG(8) = 'You can not enter a detail number here'
CTC.ERR.MSG(9) = 'Enter <CR> to return to PROSPECTS INFO.'
CTC.ERR.MSG(10) = 'The "Transfer Contact Tran." is not yes released'
CTC.ERR.MSG(11) = 'A change here will loose your contact trans.'
CTC.ERR.MSG(12) = 'MESSAGE 12'
CTC.ERR.MSG(13) = 'MESSAGE 13'
CTC.ERR.MSG(14) = 'The file I am trying to access was not found.'
* 
CTC.PROG.LOCT(1) = 'CCTA VISITOR main program'
CTC.PROG.LOCT(2) = 'Initialization'
CTC.PROG.LOCT(3) = 'Program control'
CTC.PROG.LOCT(4) = 'Input fields'
CTC.PROG.LOCT(5) = "Clear the screen and it's tables"
CTC.PROG.LOCT(6) = 'Display the heading'
CTC.PROG.LOCT(7) = 'Input a <CR>'
CTC.PROG.LOCT(8) = 'Subroutine control for Displaying transactions'
CTC.PROG.LOCT(9) = 'Read record from the CONTACT file'
CTC.PROG.LOCT(10) = 'Derive the key for the CONTACT file'
CTC.PROG.LOCT(11) = 'Display the SEQUENCE information'
CTC.PROG.LOCT(12) = 'Subroutine control for Displaying TEXT'
CTC.PROG.LOCT(13) = 'Display the TEXT information'
CTC.PROG.LOCT(14) = 'Input persons desired action'
CTC.PROG.LOCT(15) = 'Update record to the CONTACT file'
CTC.PROG.LOCT(16) = 'Standard Error Display'
CTC.PROG.LOCT(17) = 'Set the Purge Flag (delete all SEQUENCEs)'
CTC.PROG.LOCT(18) = 'Delete one SEQUENCE'
CTC.PROG.LOCT(19) = 'Delete one TEXT line'
CTC.PROG.LOCT(20) = 'END OF PROGRAM'
*
*
RETURN
~SYS.APEX~
X*PROGRAM: SYS.APEX
*
* AUTHOR: DAVID G. HORSMAN
*
!
$INCLUDE IBP SYS.COMMON
TERMINAL = "?"; EQ.PROG.STATUS = 11
$INCLUDE IBP STANDARD.FUNCTIONS
*
SYS.PROG = "SYS.APEX"
SYS.LOCT = "INIT"
SYS.SLOC = "DIM"
SYS.PROG.TYPE = 3
SYS.ABORT = FALSE
USER.ABORT = FALSE
EQ.PROG.STATUS = ''
*
DIM MENU(25), MODE.DESC(30), STAT.DESC(15), SLOC(25), PRMPT(25)
*
SYS.SLOC = "PARAMETERS"
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*
SYS.PROG.DESC = "System Structure and Control Program"
*
SYS.SLOC = "USER.PROMPTS"
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
$INCLUDE IBP SYS.INCL.DEB.RSP
*
SYS.SLOC = "ROUTINE.CONTROL"
USER.NAME = ""
FUNCTION = ""; SUB.FUNCTION = ""
SUBR.FUNCTION = ""; SUBR.SUB.FUNCTION = ""
CALL.FUNCTION = ""; CALL.SUB.FUNCTION = ""
MENU.CONTROL = ""
MENU.NAME = ""; MENU.CONTROL<1,9> = 1; MENU.APPL = "LOGON"; MENU.SUB.APPL = ""
MENU.GRP.APPL = ""; PRMPTING = ""; EXEC.VERB = ""; TOPIC.KEY = ""; MAT STRUCT = ""
STRUCT(1) = 0; STRUCT(2) = ""; WAIT.FLAG = 1
ERROR.RSP = ""; ERROR.CODE = ""; ERROR.TEXT = ""
!
SYS.LOCT<1> = "OPEN"
SYS.SLOC<1> = "FILES"
SYS.FILE = "SYS"; SYS.ITEM = "*OPEN*"
OPEN "SYS" TO SY.FILE ELSE
ERROR.TEXT = ERROR.TEXT:"No SYS file":AM
ERROR.CODE = ERROR.CODE:"11111":AM
*GOSUB ERROR.CONTROL
END
*
SYS.FILE = "MENUS"; SYS.ITEM = "*OPEN*"
OPEN "MENUS" TO MU.FILE ELSE
ERROR.TEXT = ERROR.TEXT:"No MENUS file":AM
ERROR.CODE = ERROR.CODE:"11111":AM
*GOSUB ERROR.CONTROL
END
*
CHECK.MAIL = 0
*
SYS.FILE = "HLP"; SYS.ITEM = "*OPEN*"
OPEN "HLP" TO HLP.FILE THEN CHECK.HELP = 1 ELSE
CHECK.HELP = 0
ERROR.TEXT = ERROR.TEST:"No HLP file":AM
ERROR.CODE = ERROR.CODE:"13111":AM
*GOSUB ERROR.CONTROL
END
*
SYS.FILE = "PSD"; SYS.ITEM = "*OPEN*"
OPEN "PSD" TO PS.FILE THEN CHECK.TIME = 2 ELSE
CHECK.TIME = 0
ERROR.TEXT = ERROR.TEXT:"No PSD file":AM
ERROR.CODE = ERROR.CODE:"13111":AM
*GOSUB ERROR.CONTROL
END
*
**SYS.FILE = "ACC"; SYS.ITEM = "*OPEN*"
**OPEN "ACC" TO AC.FILE ELSE
**ERROR.CODE = ERROR.TEXT:"No ACC file":AM
**ERROR.CODE = ERROR.CODE:"11111":AM
***GOSUB ERROR.CONTROL
**END
*
IF LEN(ERROR.TEXT) THEN GOSUB ERROR.CONTROL
**!
*
SYS.LOCT<1> = "LOAD"
SYS.SLOC<1> = "TABLES"
SYS11.ELP = 0; USER.FLAG = 1
CALL.ID = "MENU.":PORT
SYS.FILE = "ACC"; SYS.ITEM = CALL.ID
READV USER.NAME FROM SY.FILE,CALL.ID,2 ELSE USER.NAME = ""; USER.FLAG = 0
IF USER.NAME[1,1] = "/" ! USER.NAME[1,7] = "CALL-PL" THEN
DELETE SY.FILE,CALL.ID
USER.NAME = ""
USER.FLAG = 0
END
*
MENU.NAME = ""
*
*SYS.FILE = "MD"; *SYS.ITEM = "CO.DATA"
*READ CO.DATA FROM SY.FILE,SYS.ITEM ELSE CO.DATA = AM:DATE()
*EXEC.VERB = ""; PRMPTING = ""
*
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@PORT@":PORT
READ PORTD FROM SY.FILE,SYS.ITEM ELSE
PORTD = ""
PORTD<5> = "R"
END
*
*
*
SYS.SLOC<1> = "USER"
MAT USER.UPD = 0
USER.LOCKED = 0; USER.ABORT = 0; SYS.ABORT = 0
IF PORTD<5> # "D" THEN CLS.LO = 7; CLS.HI = 21; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,8):
*
GOSUB LOG.IN.TO.MENU
*
IF USER.ABORT ! SYS.ABORT THEN
IF PORTD<5> # "D" THEN PRINT BELL:" ABORT!":
STOP
END
WRITEV USER.NAME ON SY.FILE,CALL.ID,2
*
$INCLUDE IBP SYS.INCL.COMPANY.READ
*
*
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@MENU-STACK@":USER.NAME
READV MENU.PREV FROM SY.FILE,SYS.ITEM,PORT+1 ELSE MENU.PREV = "/"
*
GOSUB RECORD.TIME
IF OFF.FLAG THEN PRMPTING = "OFF"
IF TCL.FLAG THEN PRMPTING = "TCL"
OFF.FLAG = 0
*
LAST.LOCT = 0
OLD.MENU.NAME = "*"
MENU.APPL = OLD.MENU.NAME
MENU.APPL.DESC = ""
RESTART: * Return for error.
LOOP
SYS.LOCT<1> = "MENU"
SYS.SLOC<1> = "READ"
SYS.FILE = ""; SYS.ITEM = ""
MENU.ERROR = 0
EXEC.VERB = ""
PRMPTING = ""
SYS.ES = ""
MAT PRMPT = ""
USER.NEW = 1
MAT SLOC = 0
PORTD = ""
RSP = ""
IF OLD.MENU.NAME # MENU.NAME THEN
MENU.NEW = 1
LOOP WHILE MENU.NEW DO
IF MENU.ERROR > 5 THEN CHAIN "MENU-RUN OFF"
SYS.FILE = "MENUS"; SYS.ITEM = "@AS@":MENU.NAME
MATREAD MENU FROM MU.FILE,SYS.ITEM THEN
MENU.CONTROL = MENU(1)
IF INDEX("@KBIL@DSL@AXION@MACRO@AGW@",MENU.CONTROL,1) THEN
SUBR.FUNCTION = MENU(2):AM:SUBR.FUNCTION
CALL SYS.MENU.CONVERT(MAT MENU)
SUBR.FUNCTION = DELETE(SUBR.FUNCTION,1)
MENU.CONTROL = MENU(1)
END
MENU.NEW      = 0
TEMP = INDEX(MENU.PREV,MENU.NAME,1)
IF TEMP THEN MENU.PREV = MENU.PREV[TEMP,9999]
IF MENU.NAME # MENU.PREV<1,1> THEN MENU.PREV = MENU.NAME:VM:MENU.PREV
MENU.SUB.APPL = MENU.CONTROL<1,6,2>
MENU.GRP.APPL = MENU.CONTROL<1,6,3>
SYS.SLOC<1> = "APPL"
*
IF MENU.APPL # MENU.CONTROL<1,6,1> THEN
*IF OLD.MENU.NAME # "*" THEN TOPIC.KEY = ""
MENU.APPL = MENU.CONTROL<1,6,1>
MENU.APPL.REC = AM:"?"
LOOP WHILE MENU.APPL.REC<2> # MENU.APPL DO
SYS.FILE = "SYS"; SYS.ITEM = "@APPL@":MENU.APPL
READ MENU.APPL.REC FROM SY.FILE,SYS.ITEM THEN
MENU.APPL = MENU.APPL.REC<2>
END ELSE
MENU.APPL.REC = ""
ERROR.TEXT = "Application description not on file for ":MENU.APPL
ERROR.CODE = ERROR.CODE:"14110"
GOSUB ERROR.CONTROL
IF ERROR.RSP<1> EQ "EDIT" THEN
EXEC.VERB = "EDIT SYS @APPL@":MENU.APPL
EXECUTE EXEC.VERB
END ELSE MENU.APPL.REC<2> = MENU.APPL
END
REPEAT
MENU.APPL.DESC = MENU.APPL.REC<1>
MENU.APPL.REC = ""
*
*#IF STRUCT(30)<1,PORT + 1,1> # MENU.APPL THEN
*#IF NOT(INDEX("*SCHED*MAIN*CORP*SPTM*DEV*WP*ADMIN*TIME*NOTES*","*":MENU.APPL:"*",1)) THEN
*#TOPIC.KEY = ""
*#END
*#END
*#
END
*#
OLD.MENU.NAME = MENU.NAME
*
*MENU.EI.APPL = MENU.CONTROL<1,7>
MENU.TYPE = MENU.CONTROL<1,8>[1,1]
MENU.SPLIT = MENU.CONTROL<1,8>[2,99]
*MENU.NUM = MENU.CONTROL<1,9>
IF NOT(NUM(MENU.CONTROL<1,9>)) THEN MENU.CONTROL<1,9> = 0
GOSUB RECORD.LOCATION
*#END ; *# OF APPL NE NEW.APPL
END ELSE
*#
*# Menu NOT on File
IF USER.MODE GE LO.D.M AND USER.MODE LE HI.D.M THEN
YES.NO = ""
IF PORTD<5> # "D" THEN
IF PORTD<5> # "D" THEN PRINT @(0,23):CLL:@(20):"[=| Not on file, maintain menu? ":
INPUT YES.NO:
END ELSE YES.NO = "N"
IF INDEX(YES,"*":YES.NO:"*",1) NE 0 THEN
EXEC.VERB = "EI.MENUS.DEV M @AS@":MENU.NAME
END ELSE IF INDEX(NO,"*":YES.NO:"*",1) OR YES.NO EQ "PREV" THEN
*#
EXEC.VERB = ""
MENU.PREV = DELETE(MENU.PREV,1,1)
MENU.NAME = MENU.PREV<1,1>
IF YES.NO EQ "PREV" THEN
EXEC.VERB = "EDIT MENUS @AS@":MENU.NAME
END
END ELSE IF YES.NO EQ "EDIT" OR YES.NO EQ "EDIT.MENU" THEN
EXEC.VERB = "EDIT MENUS @AS@":MENU.NAME
END ELSE
EXEC.VERB = YES.NO
END
IF EXEC.VERB # "" THEN
IF PORTD<5> #  "D" THEN CLS.LO = 7; CLS.HI = 21; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,8):
EXECUTE EXEC.VERB
END
END ELSE
MENU.ERROR = MENU.ERROR + 1
ERROR.TEXT = "the menu @AS@":MENU.NAME:" is not on file"
ERROR.CODE = "14110"
GOSUB ERROR.CONTROL
END
IF MENU.NAME = "*" ! MENU.PREV = "" THEN MENU.NAME = MENU.CONTROL<1,5> 
END
REPEAT
USER.UPD(2) = 1
END
!
SYS.SLOC<1> = "HEADING"
OUT.TO.PRINT = 0; SCR.HEADING = ""
*SYS.PROG.DESC = ""
CALL SYS.SUBR.HEADING(OUT.TO.PRINT,SYS.PROG.DESC,SCR.HEADING)
*#*$INCLUDE IBP SYS.HEADING
*#*
SYS.SLOC<1> = "LOAD.COMPLETION"
GOSUB COMPLETION.LOAD
!
SYS.LOCT<1> = "DISPLAY"
SYS.SLOC<1> = "INIT"
VALID.USER = ""; MENU.PARAMS = ""; MENU.FILE = ""; MENU.STEP = ""; MENU.SUBJCT = ""
IF MENU.TYPE = "" ! MENU.TYPE = " " THEN MENU.TYPE = "O"
IF NOT(NUM(MENU.SPLIT)) THEN MENU.SPLIT = 0
IF LEN(MENU.SPLIT) = 0 THEN MENU.SPLIT = 0
CL = 0
IF MENU.SPLIT NE 0 ! MENU.TYPE = "P" THEN CL = 2 ELSE CL = 22
AC = 2; LN = 4
LS = 999
LS.AC = 0
PR.FL = 0
SYS.SLOC<1> = "LOOP"
CONT = 1
LOOP
LINE = MENU(AC)
IF LINE EQ "" THEN CONT = 0 ELSE
IF AC = MENU.SPLIT THEN LN = 4; CL = 42
PRMPT(AC) = LINE<1,3>; IF PRMPT(AC) = " " ! PRMPT(AC) = "" THEN PRMPT(AC) = AC
ST = 0
IF MENU.TYPE = "P" AND TASK.NUM NE 0 THEN
ST = LINE<1,8>
IF NOT(NUM(ST)) THEN ST = 0
IF INDEX("*N*C*I*O*X*H*","*":USER.COMPL<1,MENU.CONTROL<1,9>,AC>:"*",1) = 0 THEN USER.COMPL<1,MENU.CONTROL<1,9>,AC> = "N"
IF ST > 0 THEN
IF ST < LS & INDEX("*C*H*X*O*","*":USER.COMPL<1,MENU.CONTROL<1,9>,AC>:"*",1) = 0 THEN LS = ST; LS.AC = AC
END
END ELSE ST = 0
*
VALID = 1; VALID.ACCTS = LINE<1,4,1>; VALID.USERS = LINE<1,4,2>
IF VALID.ACCTS NE " " AND VALID.ACCTS NE "" THEN
LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
END
*
IF VALID THEN
IF VALID.USERS NE " " AND VALID.USERS NE "" THEN
LOCATE STRUCT(2) IN VALID.USERS<1,1> SETTING VALID ELSE VALID = 0
END
END
*
IF VALID THEN
*
SLOC(AC) = LN
GOSUB PRINT.LOOP
*
END
*
AC = AC + 1
END
UNTIL AC > 25 OR NOT(CONT) DO REPEAT
MAX.AC = AC - 1
!
SYS.SLOC<1> = "LOW.STEP"
PRINT.LOW.STEP: * Return point for step completion
IF MENU.TYPE = "P" AND TASK.NUM NE 0 THEN
IF LS > 0 AND NOT(LS > 25) THEN
LN = SLOC(LS.AC)
IF MENU.SPLIT NE 0 OR MENU.TYPE EQ "P" THEN
IF MENU.SPLIT NE 0 AND LS >= MENU.SPLIT THEN CL = 42 ELSE CL = 2
END ELSE CL = 22
ST = MENU(LS.AC)<1,8>
LINE = MENU(LS.AC)
AC = LS.AC
PR.FL = 1
GOSUB PRINT.LOOP
END
END
*
*
SYS.SLOC<1> = "TOPIC"
IF PORTD<5> NE  "D" THEN PRINT @(0,3):CLL:@(0,4):CLL:
IF  MENU.CONTROL<1,2,1> > 0 THEN
CALL.FUNCTION = "DISPLAY":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = 1:AM:CALL.SUB.FUNCTION
IF MENU.TYPE = "P" THEN CALL.SUB.FUNCTION<1> = 2
CALL SYS.TOPIC
END
*
*#SYS.SLOC<1> = "SCHED"
*NEIF TASK.NUM NE 0 AND PORTD<5> NE "D" THEN
*#PRINT @(TEMP.CL,TEMP.LN):("Task: ":TASK.NUM:" - ":TASK.STEP "L#2":" ":STRUCT(62)<1,PORT+1>) "L#49":" ":
*#*#PRINT @(TEMP.CL,TEMP.LN+1):STRUCT(62)<1,PORT+1> "L#49":" ":
*#READV TEMP.DESC FROM PS.FILE,"@J@":CO.DATA<3>:"@":TASK.NUM,1 ELSE
*#TEMP.DESC = ''
*#END
*#PRINT @(TEMP.CL,TEMP.LN+1):TEMP.DESC "L#49":" ":
*#PRINT @(TEMP.CL,TEMP.LN+2):"." "L#50":
*#END
TEMP.CL = 0
TEMP.LN = 3
$INCLUDE IBP SYS.INCL.STEP.DISPLAY
*END WAS HERE 860907
!
LOOP
Input.rsp: * Return point that resets wait status and time recording.
SYS.LOCT<1> = "FUNCTION"
SYS.SLOC<1> = "INIT"
READV INP.MODE FROM SY.FILE,"@SYS@USER@":USER.NAME,27 ELSE INP.MODE<1,PORT+1> = "11"
INP.MODE = INP.MODE<1,PORT+1>
SYS.EV = "0":SVM:"1":SVM:"1":SVM:INP.MODE:SVM:SVM
SYS.EV = SYS.EV:SVM:SVM:SVM:SVM:SVM
SYS.EV = SYS.EV:MENU.APPL:SVM:MENU.NAME:SVM:"SYS.APEX":SVM:"9900":SVM:USER.NAME:SVM
SYS.EV = SYS.EV:"1":SVM:"0":SVM:"0":SVM:"100"
SYS.EV<2> = "20":VM:"21":VM:"Enter your choice: ":VM:"201000001":VM:"0":VM
SYS.EV<2> = SYS.EV<2>:"2000":VM:"EX":SVM
FOR NUM = 2 TO 25 UNTIL PRMPT(NUM) = ""
SYS.EV = SYS.EV:'"':PRMPT(NUM):'"':SVM
NEXT NUM
SYS.EV = SYS.EV:VM:"1":VM:"your entry was invalid":VM:""
SYS.ES = ""
CALL.FUNCTION = "RSP":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "INPUT":AM:CALL.SUB.FUNCTION
CALL SYS.RSP
USER.UPD(20) = 0
RSP = SYS.ES<SYS.ES<1,1,1>+1,11>
*@@@@@ LAST PORT ACTIVE
*
*
*
IF PORTD<5> NE  "D" THEN PRINT @(0,0):RVB:OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS"):RVE:
!
IF INDEX("*COMPLETED*HOLD*IN.PROGRESS*CANCELLED*NOT.STARTED*","*":FIELD(RSP," ",1):"*",1) THEN
TRS = FIELD(RSP," ",1)
SYS.SLOC<1> = TRS
IF MENU.TYPE = "P" AND TASK.NUM NE 0  AND LS > 0 AND LS < 999 THEN
TEMP.AC = FIELD(RSP," ",2)
IF LEN(TEMP.AC) = 0 THEN TEMP.AC = LS.AC ELSE
IF NOT(NUM(TEMP.AC)) THEN TEMP.AC = LS.AC ELSE TEMP.AC = TEMP.AC + 1
END
IF TEMP.AC < 2 OR TEMP.AC > MAX.AC THEN TEMP.AC = 2
IF TRS = "COMPLETED" THEN
USER.COMPL<1,MENU.CONTROL<1,9>,TEMP.AC> = "C"
END ELSE IF TRS = "HOLD" THEN
USER.COMPL<1,MENU.CONTROL<1,9>,TEMP.AC> = "H"
END ELSE IF TRS = "IN.PROGRESS" THEN
USER.COMPL<1,MENU.CONTROL<1,9>,TEMP.AC> = "I"
END ELSE IF TRS = "CANCELLED" THEN
USER.COMPL<1,MENU.CONTROL<1,9>,TEMP.AC> = "X"
END ELSE IF TRS = "NOT.STARTED" THEN
USER.COMPL<1,MENU.CONTROL<1,9>,TEMP.AC> = "N"
END
WRITEV USER.COMPL ON PS.FILE,USER.KEY,TASK.STEP + 1
LS = 999
END ELSE
ERROR.TEXT = "No current step to ":TRS
ERROR.CODE = "18111"
GOSUB ERROR.CONTROL
END
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP MATCHES '"SLAVE "0N' THEN
SYS.SLOC<1> = RSP
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = RSP[1,5]
GOSUB RECORD.LOCATION
CALL.FUNCTION = PRMPTING:AM:CALL.FUNCTION
CALL.SUB.FUNCTION = FIELD(RSP," ",2):AM:CALL.SUB.FUNCTION
CALL SYS.SLAVE
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
PRMPTING = ""
GOSUB RECORD.LOCATION
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP = "" THEN
IF USER.MODE > HI.S.M THEN
IF MENU.PREV NE "" THEN 
MENU.PREV = DELETE(MENU.PREV,1,1)
LOOP WHILE MENU.PREV NE "" AND MENU.PREV<1,1> EQ MENU.NAME DO
MENU.PREV = DELETE(MENU.PREV,1,1)
REPEAT
EXEC.VERB = MENU.PREV<1,1> 
MENU.PREV = DELETE(MENU.PREV,1,1)
END ELSE EXEC.VERB = MENU.CONTROL<1,5>
END ELSE
READ ILSE.DISPLAY FROM SY.FILE,"@SYS@ILSE.DISPLAY" ELSE ILSE.DISPLAY = "/SL"
EXEC.VERB = ILSE.DISPLAY
ILSE.DESPLAY = ""
END
!
END ELSE IF RSP[1,1] = "/" & USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN
READV MU.VALID FROM MU.FILE,'@AS@':RSP,1 THEN MU.VALID = 1 ELSE MU.VALID = 0
IF MU.VALID THEN EXEC.VERB = RSP ELSE EXEC.VERB = MENU.NAME
!
END ELSE IF INDEX(OFF.RSP,"*":RSP:"*",1) # 0 & USER.MODE > HI.S.M THEN
EXEC.VERB = "OFF"
!
END ELSE IF INDEX(TCL.RSP,"*":RSP:"*",1) # 0 & USER.MODE >= LO.TCL.M THEN
EXEC.VERB = "EXIT.MENU"
!
END ELSE IF RSP = "MENU" THEN
IF USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN EXECUTE "EI.MENUS.DEV M @AS@":MENU.NAME; OLD.MENU.NAME = "*"
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP[1,5] = "EDIT." OR RSP[1,5] = "EDIT " THEN
PRMPTING = RSP
GOSUB RECORD.LOCATION
IF USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN 
IF PORTD<5> #  "D" THEN CLS.LO = 7; CLS.HI = 21; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,8); PRINT RVB:"[=| ":RVE:"Ready for EDIT."
TEMP = RSP[6,99]
IF TEMP = "MENU" THEN
EXEC.VERB = "EDIT MENUS @AS@":MENU.NAME
END ELSE IF TEMP = "APPL" THEN
EXEC.VERB =  "EDIT SYS @APPL@":MENU.APPL
END ELSE IF TEMP = "TOPIC" THEN
EXEC.VERB =  "EDIT PSD @T@":CO.DATA<4>:"@":MENU.APPL:"@":TASK.NUM
END ELSE
EXEC.VERB =  "EDIT ":TEMP
END
PRINT RVB:"[=| ":RVE:EXEC.VERB
EXECUTE EXEC.VERB
OLD.MENU.NAME = "*"
END
EXEC.VERB = MENU.NAME
!
END ELSE IF RSP EQ "RED" THEN
EXEC.VERB = MENU.NAME
!
END ELSE
SYS.SLOC<1> = "LOCATE.OPTION"
FOR NUM = 2 TO 25 UNTIL PRMPT(NUM) = RSP ! PRMPT(NUM) = ""; NEXT NUM
EXEC.FILE.ITEM = ""
IF NUM <= 25 & PRMPT(NUM) # "" THEN
*
LINE = MENU(NUM)
EXEC.VERB   = LINE<1,2>
PRMPTING    = PRMPT(NUM)
VALID.ACCTS = LINE<1,4,1>
VALID.USERS = LINE<1,4,2>
MENU.SELECT = LINE<1,5>
MENU.PASSWORD = LINE<1,6>
MENU.FILE   = LINE<1,7>
MENU.STEP   = LINE<1,8>
MENU.SUBJCT = LINE<1,9>
*
IF MENU.PASSWORD # "" THEN
PRINT @(20,23):CLL:RVB:"[=| ":RVE:"What is the password: ":
ECHO OFF; INPUT RSP:; ECHO ON
END
*
TEMP = ""
IF USER.MODE <= HI.S.M THEN
HELP = 1; TEMP1 = "?":PRMPTING:" ":HELP; CALL SYS.HELP(TEMP1,TEMP)
END
*
IF USER.MODE >= LO.T.M & USER.MODE <= HI.T.M THEN
HELP = 2; TEMP1 = "?":PRMPTING:" ":HELP; CALL SYS.HELP(TEMP1,TEMP)
HELP = 3; TEMP1 = "?":PRMPTING:" ":HELP; CALL SYS.HELP(TEMP1,TEMP)
END
*
IF USER.MODE <= HI.S.M THEN EXEC.VERB = MENU.NAME
END ELSE EXEC.VERB = ""
END
*
!
WHILE EXEC.VERB = "" DO
*
MENU.ERROR = MENU.ERROR + 1
ERROR.TEXT = "your entry was invalid"
ERROR.CODE = "18110"
GOSUB ERROR.CONTROL
IF MENU.ERROR > 3 THEN TEMP1 = "?RSP 2"; TEMP = ""; CALL SYS.HELP(TEMP1,TEMP)
REPEAT
*
!
*
IF EXEC.VERB[1,1] NE "/" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "EXIT.MENU" AND EXEC.VERB NE "RED" THEN
*
*@@@STRUCT(1) = 1
*@@@WRITEV STRUCT(1) ON SY.FILE,"@SYS@USER@":USER.NAME,1
*@@@STRUCT(14) = PORT + 1
*@@@WRITEV STRUCT(14) ON SY.FILE,"@SYS@USER@":USER.NAME,14
*
PARAMS = EXEC.VERB; EXEC.PARAMS = ""
LOOP UNTIL PARAMS = "" DO
EXEC.PARAMS = EXEC.PARAMS:PARAMS<1,1,1>:AM
DEL PARAMS<1,1,1>
REPEAT
IF LEN(EXEC.PARAMS) # 0 THEN 
EXEC.PARAMS = EXEC.PARAMS[1,LEN(EXEC.PARAMS)-1]
END ELSE EXEC.PARAMS = "?"
S.F.I.PARAMS = EXEC.PARAMS
S.F.I.EXEC = ""
CALL SYS.FILE.ITEM(S.F.I.PARAMS,S.F.I.EXEC)
EXEC.PARAMS = S.F.I.EXEC
EXEC.VERB = EXEC.PARAMS<1>; DEL EXEC.PARAMS<1>
IF EXEC.PARAMS = AM THEN EXEC.PARAMS = ""
EXEC.LIST = ""; EXEC.RESULT = ""
*
*
CHECK.TIME = 1; GOSUB RECORD.TIME
GOSUB RECORD.LOCATION
CALL.FUNCTION = "LOGOFF":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "UPDATE":AM:CALL.SUB.FUNCTION
GOSUB RECORD.USER.CALL
*
*
IF MENU.SELECT NE "" THEN
S.F.I.PARAMS = MENU.SELECT
S.F.I.SELECT = ""
CALL SYS.FILE.ITEM(S.F.I.PARAMS,S.F.I.SELECT)
MENU.SELECT = S.F.I.SELECT
IF PORTD<5> #  "D" THEN CLS.LO = 7; CLS.HI = 21; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,8):
*
ERROR.TEXT = "you will now execute: ":MENU.SELECT
ERROR.CODE = 19000
*ERROR.CODE = 19100
GOSUB ERROR.CONTROL
EXECUTE MENU.SELECT, //SELECT. > EXEC.LIST
*
ERROR.TEXT = "you will now execute: ":EXEC.VERB
ERROR.CODE = 19000
*ERROR.CODE = 19100
GOSUB ERROR.CONTROL
IF EXEC.PARAMS NE '' THEN
EXECUTE EXEC.VERB, //SELECT. < EXEC.LIST, //IN. < EXEC.PARAMS
END ELSE
EXECUTE EXEC.VERB, //SELECT. < EXEC.LIST
END
END ELSE
*
*
ERROR.TEXT = "you will now execute: ":EXEC.VERB
ERROR.CODE = 19000
*ERROR.CODE = 19100
GOSUB ERROR.CONTROL
IF PORTD<5> #  "D" THEN CLS.LO = 7; CLS.HI = 21; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,8):
IF EXEC.PARAMS NE '' THEN
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS
END ELSE
EXECUTE EXEC.VERB
END
END
*
IF LEN(EXEC.RESULT) # 0 THEN
LOOP
ERROR.TEXT = EXEC.RESULT<1,1>
ERROR.CODE = 19100
IF LEN(ERROR.TEXT) # 0 THEN GOSUB ERROR.CONTROL
EXEC.RESULT = DELETE(EXEC.RESULT,1)
WHILE LEN(EXEC.RESULT) # 0 DO
REPEAT
END
*
GOSUB LOG.IN.RETURN
CHECK.TIME = 1; GOSUB RECORD.TIME
*#PRINT @(0,23):CLL:@(40):
ERROR.TEXT = "Enter <cr> to return to menu    "
ERROR.CODE = "2900220"
*#INPUT YES.NO:
GOSUB ERROR.CONTROL
PRMPTING = ""
EXEC.VERB = MENU.NAME
END
*
WHILE EXEC.VERB[1,1] EQ "/" OR EXEC.VERB EQ "RED" DO
IF EXEC.VERB[1,1] EQ "/" THEN
MENU.NAME = FIELD(EXEC.VERB," ",1)
TEMP = FIELD(EXEC.VERB," ",2)
END ELSE TEMP = EXEC.VERB
EXEC.VERB = ""
RSP = ""
REPEAT
*
EXEC.VERB = EXEC.VERB<1,1,1>
*
*
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@MENU-STACK@":USER.NAME
WRITEV MENU.PREV ON SY.FILE,SYS.ITEM,PORT+1
*
ERROR.TEXT = "Serious software fault"
IF EXEC.VERB = "OFF" THEN
DELETE SY.FILE,CALL.ID
ERROR.TEXT = "Thank you ":USER.NAME:". I am now ending."
END ELSE
IF EXEC.VERB = "EXIT.MENU" THEN ERROR.TEXT = "Remember ":USER.NAME:", to log off through the menu."
END
OFF.FLAG = 1
GOSUB LOG.OUT.OF.MENU
IF PORTD<5> # "D" THEN
IF EXEC.VERB = "OFF" THEN
CLS.LO = 3; CLS.HI = 23; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,5):@(10,7):ERROR.TEXT:
END ELSE
CLS.LO = 7; CLS.HI = 21; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,8):@(10,13):ERROR.TEXT:
END
FOR TEMP = 1 TO WAIT.FLAG; RQM; NEXT TEMP
END
IF EXEC.VERB # "" AND EXEC.VERB # "EXIT.MENU" THEN EXECUTE EXEC.VERB
STOP
!
PRINT.LOOP: * FOR PRINTING SCREEN OPTIONS
*
NUM = 0
LOOP NUM = NUM + 1; TEXT = LINE<1,1,NUM> WHILE TEXT # "" AND SYSTEM(11) = 0 DO
*
IF TEXT[1,1] = "*" THEN
IF TEXT # "*" THEN PRINT @(CL-2,LN):TEXT[2,99]
END ELSE IF TEXT[1,1] = "+" THEN
*
PRINT @(CL,LN):"    ":
IF MENU.TYPE = "P" ! (ST # "0" & ST # "" & ST # " ") THEN PRINT "    ":
IF PR.FL = 1 THEN PRINT RVB:TEXT[2,99]:RVE: ELSE PRINT TEXT[2,99]:
END ELSE
IF TEXT # "" & TEXT # " " THEN PRINT @(CL,LN):RVB:PRMPT(AC) "R#3":RVE:" ":
IF MENU.TYPE = "P" ! (ST # "0" & ST # "" & ST # " ") THEN
IF (ST # "0" & ST # "" & ST # " ") THEN
PRINT ST "R#2":". ":
END ELSE PRINT " .. ":
END
STAT.NUM = INDEX(STAT.CHECK,"*":USER.COMPL<1,MENU.CONTROL<1,9>,AC>:"*",1)
IF PR.FL = 1 THEN
PRINT RVB:TEXT:RVE:
IF TASK.NUM # 0 & STAT.NUM # 0 THEN
STAT.NUM = (STAT.NUM + 1) / 2
IF MENU.SPLIT NE 0 THEN
PRINT " ":STAT.DESC(STAT.NUM)[1,1]:
END ELSE
PRINT "     ":STAT.DESC(STAT.NUM):
END
END
END ELSE
PRINT TEXT:
IF TASK.NUM # 0 & STAT.NUM # 0 & USER.COMPL<1,MENU.CONTROL<1,9>,AC> # "N" THEN
STAT.NUM = (STAT.NUM + 1) / 2
IF MENU.SPLIT NE 0 THEN
PRINT " ":STAT.DESC(STAT.NUM)[1,1]:
END ELSE
PRINT "     ":STAT.DESC(STAT.NUM):
END
END
END
END
LN = LN + 1
REPEAT
RETURN
!
1000 * DEFAULTS
AC = 3
LOOP DEFAULT = DEFAULTS<AC> UNTIL DEFAULT<1,3> = RSP ! DEFAULT = "" DO AC = AC+1 REPEAT
IF DEFAULT = "" THEN EXEC.VERB = ""; RETURN
VALID = 1; VALID.ACCTS = DEFAULT<1,4>
IF VALID.ACCTS # " " & VALID.ACCTS # "" THEN LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN EXEC.VERB = DEFAULT<1,2> ELSE EXEC.VERB = ""
RETURN
!
COMPLETION.LOAD: *#* Load completion status for user.
IF MENU.TYPE = "P" & TASK.NUM # 0 THEN
USER.KEY = "@C@":STRUCT(29)<1,PORT+1>:"@":TASK.NUM:"@":MENU.APPL
SYS.FILE = "PSD"; SYS.ITEM = USER.KEY
READV USER.COMPL FROM PS.FILE,USER.KEY,TASK.STEP + 1 ELSE
USER.COMPL = ""
ERROR.TEXT = "this procedure is not included with this step!"
ERROR.CODE = "15000"
GOSUB ERROR.CONTROL
END
END ELSE
USER.COMPL = ""
END
RETURN
!
LOG.OUT.OF.MENU: *#* WRITE OUT GOING TRACE RECORD
IF CHECK.TIME THEN CHECK.TIME = 8; GOSUB RECORD.TIME
SYS.SLOC<1> = "LOG.OUT.OF.MENU"
CALL.FUNCTION = "LOGOFF":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "UPDATE":AM:CALL.SUB.FUNCTION
*IF CHECK.TIME THEN CHECK.TIME = 8; GOSUB RECORD.TIME
MAT USER.UPD = 1
PRMPTING = EXEC.VERB; RSP = EXEC.VERB
GOSUB RECORD.USER.CALL
RETURN
!
LOG.IN.TO.MENU: *#* WRITE TIME RECORD WITH ELASPED TIME AND SUBR.FUNCTION
*
*
OFF.FLAG = 0
SCH.FLAG = 0
TCL.FLAG = 0
MSG.FLAG = 0
MAL.FLAG = 0
PASS.INPUT = ""
PASS.FLAG = 0
*
LOG.IN.RETURN: * reloop point
IF USER.NAME # ""  THEN
CALL.FUNCTION = "LOGON":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "READ":AM:CALL.SUB.FUNCTION
GOSUB RECORD.USER.CALL
IF USER.ABORT THEN RETURN
*
*870808IF NOT(STRUCT(1)) THEN OFF.FLAG = 1; SCH.FLAG = 4
*
IF NOT(STRUCT(21)<1,PORT+1>) THEN OFF.FLAG = 1
IF STRUCT(33)<1,PORT+1> = "EXIT.MENU" THEN TCL.FLAG = 1
IF STRUCT(33)<1,PORT+1> = "OFF" THEN OFF.FLAG = 1
*#IF NOT(OFF.FLAG) & NOT(TCL.FLAG) THEN PASS.FLAG = 0
IF NOT(OFF.FLAG) AND TCL.FLAG THEN PASS.FLAG = 0
END ELSE MAT STRUCT = ""; USER.FLAG = 0; PASS.FLAG = 1
*
*
IF PORTD<5> = "D" AND (NOT(USER.FLAG) OR OFF.FLAG) THEN
*#
*#      Enter Telephone Number Here!!!
*#
CALL.FUNCTION = "DIAL.USER":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = PORT:" LOGON ":OCONV(TIME(),"MTS")
CALL SYS.DIAL.USER
*#
END ELSE IF PORTD<5> = "L" AND (NOT(USER.FLAG) OR OFF.FLAG) THEN
*#
CALL.FUNCTION = "PORT.LINK":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = PORT:" LOGON ":OCONV(TIME(),"MTS")
CALL SYS.PORT.LINK
END
*
IF NOT(USER.FLAG) THEN
PASS.INPUT = ""
IF PORTD<5> #  "D" THEN CLS.LO = 7; CLS.HI = 21; GOSUB SYS.CLEAR.PAGE.MID; PRINT @(0,8):
PRINT @(0,7):RVB:"[=| ":RVE:"Who is there? ":
ECHO OFF; INPUT USER.NAME:; ECHO ON
PASS.INPUT = FIELD(USER.NAME,",",2)
USER.NAME  = FIELD(USER.NAME,",",1)
USER.FLAG = 1; PASS.FLAG = 1
GOTO LOG.IN.RETURN
END
*
*
IF PASS.FLAG THEN
LOOP WHILE PASS.INPUT # STRUCT(3) & PASS.FLAG < 6 DO
PRINT @(0,9):RVB:"[=| ":RVE:"What is your password ":USER.NAME:"? ":
IF LEN(PASS.INPUT) = 0 THEN ECHO OFF; INPUT PASS.INPUT:; ECHO ON
IF PASS.INPUT # STRUCT(3) THEN
PASS.FLAG = PASS.FLAG + 1
ERROR.TEXT = "Invalid password (":PASS.INPUT:" # ":STRUCT(3):", attempt no. ":PASS.FLAG:")"
ERROR.CODE = "14110"
GOSUB ERROR.CONTROL
PASS.INPUT = ""
END ELSE
WRITE AM:USER.NAME:AM:(DATE()+100000)[2,5]:(TIME()+100000)[2,5] ON SY.FILE,CALL.ID
END
REPEAT
END
IF PASS.FLAG > 5 THEN
SYS.ITEM = "SYS"; SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.UNLOCK.ITEM
CHAIN "MENU-RUN OFF"
END
*
IF STRUCT(15)<1,PORT+1> = 9 THEN
CALL.FUNCTION = "LOGON":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "NEW.USER":AM:CALL.SUB.FUNCTION
CALL SYS.USER.PORT.NEW
END
*
CALL.FUNCTION = "LOGON":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "UPDATE":AM:CALL.SUB.FUNCTION
GOSUB RECORD.USER.CALL
IF USER.ABORT THEN RETURN
*
RETURN
!
RECORD.USER.CALL: *Subroutine to update user info
*
SYS.SLOC<1> = "RECORD.USER.CALL"
IF CALL.FUNCTION<1> # "LOGON" & CALL.FUNCTION<1> # "LOGOFF" & CALL.FUNCTION<1> # "MENU" THEN CALL.FUNCTION<1> = "UNKNOWN"
IF CALL.SUB.FUNCTION<1> # "UPDATE" & CALL.SUB.FUNCTION<1> # "READ" THEN
IF CALL.SUB.FUNCTION<1> # "WRITE" & CALL.SUB.FUNCTION<1> # "RESET" THEN
CALL.FUNCTION = DELETE(CALL.FUNCTION,1)
CALL.SUB.FUNCTION = DELETE(CALL.SUB.FUNCTION,1)
RETURN
END
END
LOOP
IF STRUCT(2) # "" THEN USER.NAME = STRUCT(2)
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
WHILE (USER.LOCKED & USER.LOCKED # PORT+1) & NOT(USER.ABORT OR SYS.ABORT) DO REPEAT
RETURN
!
RECORD.LOCATION: * to record you menu location & topics
USER.UPD(2) = 1
TEMP = (100000+DATE())[2,5]
TEMP = TEMP:(100000+TIME())[2,5]
*#IF TEMP > LAST.LOCT + (STRUCT(48) * 5) ! LEN(PRMPTING) # 0 ! NOT(STRUCT(21)<1,PORT+1>) THEN
IF TEMP > LAST.LOCT + (STRUCT(48)) ! LEN(PRMPTING) # 0 ! NOT(STRUCT(21)<1,PORT+1>) THEN
CALL.FUNCTION = "MENU":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "UPDATE":AM:CALL.SUB.FUNCTION
GOSUB RECORD.USER.CALL
LAST.LOCT = TEMP
END ELSE
STRUCT(29)<1,PORT + 1> = USER.CO.CODE
STRUCT(30)<1,PORT + 1,1> = MENU.APPL
STRUCT(30)<1,PORT + 1,2> = MENU.SUB.APPL
STRUCT(30)<1,PORT + 1,3> = MENU.GRP.APPL
STRUCT(31)<1,PORT + 1> = MENU.CONTROL<1,7>
STRUCT(32)<1,PORT + 1> = MENU.NAME
STRUCT(33)<1,PORT + 1> = PRMPTING
STRUCT(34)<1,PORT + 1> = TOPIC.KEY
STRUCT(35)<1,PORT + 1> = MENU.CONTROL<1,9>
END
RETURN
!
RECORD.TIME: * to record time usage
*
IF CHECK.TIME THEN
CALL.FUNCTION = "TIME":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = "CHECK":AM:CALL.SUB.FUNCTION
CALL SYS.TIME
END
*
RETURN
!
RECORD.SCHEDULE: * to record a change in task or step
STRUCT(61)<1,PORT+1> = TASK.NUM
STRUCT(69)<1,PORT+1> = TASK.STEP
USER.UPD(4) = 1
RETURN
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*
END
~SYS.ASCII~
*PROGRAM: SYS.ASCII
*
* AUTHOR: DAVID G. HORSMAN
*
!
*$INCLUDE IBP SYS.COMMON
*
TERMINAL = "?"
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
SYS.PROG.DESC = "Convert characters to their ASCII codes"
SYS.PROG = "SYS.ASCII"
SYS.LOCT = "MAIN"
SYS.SLOC = "LOOP"
*
CONT = 1
PRINT @(0,5):CLS:@(0,6):"Convert characters to ASCII"
LOOP
PRINT @(0,8):CLL:"Enter character to convert: ":
INPUT RSP,1:
IF RSP = "E" THEN
PRINT @(0,21):CLS:@(0,22):'Enter "E" to end: ':
INPUT RSP1,1:
IF RSP1 = "E" THEN CONT = 0
END
WHILE CONT DO
PRINT @(0,6):"Convert characters to ASCII"
PRINT @(0,8):"Enter character to convert: ":
PRINT @(0,10):CLS:"The character (":RSP:") is ":SEQ(RSP):
REPEAT
END
~SYS.CHAR~
*PROGRAM: SYS.CHAR
*
* AUTHOR: DAVID G. HORSMAN
*
!
*$INCLUDE IBP SYS.COMMON
*
TERMINAL = "?"
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
SYS.PROG.DESC = "Convert ASCII numberss to their printable codes"
SYS.PROG = "SYS.printable"
SYS.LOCT = "MAIN"
SYS.SLOC = "LOOP"
*
CONT = 1
PRINT @(0,5):CLS:@(0,6):"Convert ASCII numbers to printalbe characters"
LOOP
PRINT @(0,8):CLL:"Enter ASCII numbers to convert: ":
INPUT RSP,3:
IF RSP = "E" THEN
PRINT @(0,21):CLS:@(0,22):'Enter "E" to end: ':
INPUT RSP1,1:
IF RSP1 = "E" THEN CONT = 0
END
WHILE CONT DO
PRINT @(0,6):"Convert ASCII numbers to printalbe characters"
PRINT @(0,8):"Enter ASCII numbers to convert: ":
PRINT @(0,10):CLS:'The ASCII number (':RPS:') is "':CHAR(RSP):'"':
REPEAT
END
~SYS.CHECK.ELP~
SUBROUTINE SYS.CHECK.ELP(TEMP.LAST,TEMP.NELP,TEMP.CK)
*SUBROUTINE: SYS.CHECK.ELP
*
* AUTHOR: DAVID G. HORSMAN
*
!
CHECK.ELP: * Last date checked, # of elp units/type, ck flag.
*
* CK = 0 , COMPARE TO CURR DATE & TIME
* CK = 1 , COMPARE TO CURR DATE & TIME BUT ALL ACTION ARE LAST-? NOT LAST+?
* CK = 2 , COMPARE TO CK<2>
* CK = 3 , COMPARE TO CK<2> BUT ALL ACTION ARE LAST-? NOT LAST+?
*
IF TEMP.CK<1> > 1 THEN
TEMP.CD = TEMP.CK<2,1>; TEMP.CT = TEMP.CK<2,2>
END ELSE
TEMP.CD = DATE(); TEMP.CT = TIME()
END
*
IF TEMP.CK<1> = 0 OR TEMP.CK<1> = 2 THEN TS = 1 ELSE TS = -1
*
TEMP.LD = TEMP.LAST[1,5]; TEMP.LT = TEMP.LAST[6,5]
TEMP.TYPE = TEMP.NELP<1,1>; TEMP.UNITS = TEMP.NELP<1,2>
TEMP.CK<1> = 0
*
IF TEMP.TYPE = "S" THEN
TEMP.LT = TEMP.LT + (TS * TEMP.UNITS)
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LT = TEMP.LT + (TS * (TEMP.UNITS * 60))
END ELSE IF TEMP.TYPE = "H" THEN
TEMP.LT = TEMP.LT + (TS * (TEMP.UNITS * 3600))
END ELSE
*
TEMP.CT = 0
IF TEMP.TYPE = "D" THEN
TEMP.LD = TEMP.LD + (TS * TEMP.UNITS)
END ELSE IF TEMP.TYPE = "W" THEN
TEMP.LD = TEMP.LD + (TS * (TEMP.UNITS * 7))
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LD = TEMP.LD + (TS * INT(TEMP.UNITS * 30.416))
END ELSE IF TEMP.TYPE = "Q" THEN
TEMP.LD = TEMP.LD + (TS * 91)
END ELSE IF TEMP.TYPE = "Y" THEN
TEMP.LD = TEMP.LD + (TS * (TEMP.UNITS * 365))
END
END
*
LOOP WHILE (TEMP.LT >= 86400 AND TS > 0) OR (TEMP.LT < 0 AND TS < 0) DO
TEMP.LD = TEMP.LD + (TS * 1)
TEMP.LT = TEMP.LT - (TS * 86400)
REPEAT
*
IF TEMP.LD < TEMP.CD ! (TEMP.LD = TEMP.CD & TEMP.LT <= TEMP.CT) THEN
TEMP.CK<1> = 1
END
*
RETURN
!
*
END
~SYS.COMPANY~
SUBROUTINE SYS.COMPANY
*SUBROUTINE: SYS.COMPANY
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP SYS.COMMON
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*#
SYS.PROG = "SYS.COMPANY":AM:SYS.PROG
SYS.PROG.TYPE = 9
EQ.PROG.STATUS = TRUE
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
SYS.FIRST = 1
EQ.PROG.STATUS = ''
*#
PRINT @(0,0):RVB:OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS"):RVE:
PRINT CALL.FUNCTION<1>:"+":CALL.SUB.FUNCTION<1>:" ":
OLD.COMPANY = STRUCT(29)<1,PORT+1>
*#
LOOP
IF CALL.FUNCTION<1> NE "COMPANY" THEN PRINT BELL:; RQM; PRINT BELL:; RQM; RETURN
IF LEN(CALL.SUB.FUNCTION<1>) THEN
*#
SYS.SLOC<1> = TRIM(CALL.SUB.FUNCTION<1>)
IF SYS.FIRST THEN
TEMP.COMPANY = TRIM(CALL.SUB.FUNCTION<1>)
SYS.FIRST = ''
END ELSE TEMP.COMPANY = ''
IF NOT(LEN(TEMP.COMPANY)) THEN
ERROR.TEXT = "Enter the company code you want: "
ERROR.CODE = "271023015010"
ERROR.RSP = STRUCT(29)<1,PORT+1>
GOSUB ERROR.CONTROL
IF NOT(LEN(ERROR.RSP)) OR ERROR.RSP = "?" THEN
TEMP.COMPANY = STRUCT(4)
END ELSE TEMP.COMPANY = ERROR.RSP
END
IF TEMP.COMPANY EQ "?" THEN
CALL SYS.LIST("@LI@CO",TEMP.COMPANY,MAT STRUCT,STAT)
END
*
STRUCT(29)<1,PORT+1> = TEMP.COMPANY
USER.CO.CODE = TEMP.COMPANY
*
$INCLUDE IBP SYS.INCL.COMPANY.READ
*
END ELSE
CALL.FUNCTION<1> = "COMPANY"
CALL.SUB.FUNCTION<1> = "?"
END; *# of PRMPTING verification and override
*
WHILE SYS.ABORT OR USER.ABORT DO
SYS.ABORT = ''
USER.ABORT = ''
REPEAT
*
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
*
USER.UPD(4) = 1
USER.UPD(20) = 1
*#EXEC.VERB = MENU.NAME
EXEC.VERB = ""
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
SYS.FILE = ""
SYS.ITEM = ""
RETURN
*
!
RECORD.TIME: * to record time usage
IF CHECK.TIME THEN
CALL SYS.TIME
END
*
RETURN
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
END
~SYS.CONTROL.DATE~
SUBROUTINE SYS.CONTROL.DATE
*SUBROUTINE: SYS.CONTROL.DATE
*
* AUTHOR: DAVID G. HORSMAN
*
* PROGRAM:           SYS.CONTROL.DATE
* MODIFIED BY DAVID HORSMAN - AIM SERVICES FOR SYSTEM STRUCTURE PROGRAM
* DESCRIPTION:       VERIFIES SYSTEM DATE AGAINST CONTROL DATE
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
SYS.PROG = "SYS.TOPIC":AM:SYS.PROG
SYS.LOCT = "OPEN":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
*
OPEN "CNT" TO CNT.FILE ELSE STOP
*
CONTROL.DATE = CO.DATA<2,1,1>
*
PRINT @(0,5):CLS:BELL:
RQM; RQM
PRINT @(20,6):RVB:"Maintain control date for user ":STRUCT(2):RVE:
*
PRINT @(20,9):CLL:"The correct date is ":OCONV(DATE(),"D2"):".":@(20,10):"The correct time is ":OCONV(TIME(),"MT"):".":
PRINT @(0,13):"If this is incorrect please press any key within 5 seconds. . . ":
COUNT.DOWN = TIME()
LOOP
TEMP=TIME()-COUNT.DOWN-5
IF TEMP < 1 THEN PRINT @(39,18):ABS(TEMP): ELSE PRINT @(39,18):"0":
*#IF TEMP > -3 THEN PRINT BELL:
RQM
WHILE TEMP < 0 AND NOT(SYSTEM(11)) DO REPEAT
IF SYSTEM(11) THEN
INPUTCLEAR
LOOP
LOOP
PRINT @(20,9):CLS:"Enter the correct date: ":OCONV(DATE(),"D2"):@(44,9):
INPUT NEW.DATE:; IF NEW.DATE = "" THEN NEW.DATE = DATE(); DATE.CHANGE = 0 ELSE CALL GET.ICONV(NEW.DATE,"D"); DATE.CHANGE = 1
IF NOT(NEW.DATE) THEN PRINT BELL: ELSE
IF NEW.DATE < CONTROL.DATE THEN
PRINT @(20,15):CLL:"The prior setting of the system date is ":OCONV(CONTROL.DATE,"D"):".":
LOOP
PRINT @(20,13):CLL:"Are you sure that the above date is correct (Y/N)? ":
INPUT RSP:
UNTIL RSP = "Y" OR RSP = "N" DO PRINT BELL: REPEAT
PRINT @(20,13):CLS:
IF RSP = "N" THEN NEW.DATE = ''
END
END
UNTIL NEW.DATE DO REPEAT
IF DATE.CHANGE THEN PRINT @(44,9):CLL:OCONV(NEW.DATE,"D2"):
LOOP
PRINT @(20,10):CLL:"Enter the correct time: ":OCONV(TIME(),"MT"):@(44,10):
INPUT NEW.TIME:; IF NEW.TIME = "" THEN TIME.CHANGE = 0 ELSE
TIME.CHANGE = 1
HRS = FIELD(NEW.TIME,":",1); MINS = FIELD(NEW.TIME,":",2)
IF NOT(HRS MATCH "1N" OR HRS MATCH "2N") THEN NEW.TIME = "" ELSE
IF NOT(MINS MATCH "2N") THEN NEW.TIME = "" ELSE IF HRS > 23 OR MINS > 59 THEN NEW.TIME = ""
END
END
WHILE NEW.TIME = "" AND TIME.CHANGE DO PRINT BELL: REPEAT
LOOP
PRINT @(20,13):CLL:"Are you sure date and time are correct (Y/N)? ":
INPUT RSP:
UNTIL RSP = "Y" OR RSP = "N" DO PRINT BELL: REPEAT
UNTIL RSP = "Y" DO REPEAT
IF DATE.CHANGE THEN EXECUTE "SET-DATE ":OCONV(NEW.DATE,"D2"), //OUT. > RSP
IF TIME.CHANGE THEN EXECUTE "SET-TIME ":NEW.TIME, //OUT. > RSP
WRITEV NEW.DATE ON SY.FILE,"@CO.DATA@":STRUCT(4),2
*
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE@":STRUCT(4) ELSE CURR.ACCTG.DATE = ""
WRITE NEW.DATE ON CNT.FILE,"CURR.ACCTG.DATE@":STRUCT(4)
CO.DATA<2,1,1> = NEW.DATE
*
END ELSE
NEW.DATE = DATE()
WRITEV NEW.DATE ON SY.FILE,"@CO.DATA@":STRUCT(4),2
CO.DATA<2,1,1> = NEW.DATE
WRITE NEW.DATE ON CNT.FILE,"CURR.ACCTG.DATE@":STRUCT(4)
END
ERROR.TEXT = "thank you . . ."
ERROR.CODE = "19000"
GOSUB ERROR.CONTROL
RQM
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
RETURN
*
$INCLUDE IBP SYS.ERROR.STRUCT
END
~SYS.ELP.CONVERT~
SUBROUTINE SYS.ELP.CONVERT(TEMP.LAST,TEMP.NELP,TEMP.CK)
*SUBROUTINE: SYS.ELP.CONVERT
*
* AUTHOR: DAVID G. HORSMAN
*
*
!
CHECK.ELP: * Last date checked, # of elp units/type, ck flag.
*
* CK = 0 , CONVERT NELP UNITS TO LAST
* CK = 1 , CONVERT NELP UNITS TO LAST BUT ALL ACTION ARE - NOT +
*
* NELP = FROM.UNIT : VM : FROM.AMT : AM : AVG.DAY
*
* LAST = DATE      : AM : TIME     : AM : TO.UNIT
*
*
IF TEMP.CK<1> = 0 THEN TS = 1 ELSE TS = -1
TEMP.CK<1> = 0
*
TEMP.LD = TEMP.LAST<1>; TEMP.LT = TEMP.LAST<2>
TEMP.TYPE = TEMP.LAST<3>; TEMP.UNITS = TEMP.NELP<1,2>
GOSUB ELP.CONVERT
*
IF INDEX("SMH",TEMP.NELP<1,1>,1) # 0 THEN
IF INDEX("SMH",TEMP.LAST,1) = 0 THEN GOSUB ELP.CONVERT3
END ELSE
IF INDEX("DWMQY",TEMP.LAST,1) = 0 THEN GOSUB ELP.CONVERT3
END
*
TEMP.TYPE = TEMP.NELP<1,1>
GOSUB ELP.CONVERT1
*
TEMP.LAST<1> = TEMP.LD; TEMP.LAST<2> = TEMP.LT
*
RETURN
!
ELP.CONVERT: *
*
IF TEMP.TYPE = "S" THEN
TEMP.LT = TEMP.LT + (TS * TEMP.UNITS)
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LT = TEMP.LT + (TS * (TEMP.UNITS * 60))
END ELSE IF TEMP.TYPE = "H" THEN
TEMP.LT = TEMP.LT + (TS * (TEMP.UNITS * 3600))
END ELSE
*
TEMP.CT = 0
IF TEMP.TYPE = "D" THEN
TEMP.LD = TEMP.LD + (TS * TEMP.UNITS)
END ELSE IF TEMP.TYPE = "W" THEN
TEMP.LD = TEMP.LD + (TS * (TEMP.UNITS * 7))
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LD = TEMP.LD + (TS * INT(TEMP.UNITS * 30.416))
END ELSE IF TEMP.TYPE = "Q" THEN
TEMP.LD = TEMP.LD + (TS * 91)
END ELSE IF TEMP.TYPE = "Y" THEN
TEMP.LD = TEMP.LD + (TS * (TEMP.UNITS * 365))
END
END
RETURN
*
ELP.CONVERT1: *
*
IF TEMP.TYPE = "S" THEN
*
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LT = TEMP.LT + (TEMP.UNITS / 60)
END ELSE IF TEMP.TYPE = "H" THEN
TEMP.LT = TEMP.LT + (TEMP.UNITS / 3600)
END ELSE
*
TEMP.CT = 0
IF TEMP.TYPE = "D" THEN
*
END ELSE IF TEMP.TYPE = "W" THEN
TEMP.LD = TEMP.LD + (TEMP.UNITS / 7)
END ELSE IF TEMP.TYPE = "M" THEN
TEMP.LD = TEMP.LD + (TEMP.UNITS / 30.416)
END ELSE IF TEMP.TYPE = "Q" THEN
TEMP.LD = TEMP.LD + (TEMP.UNITS / 91)
END ELSE IF TEMP.TYPE = "Y" THEN
TEMP.LD = TEMP.LD + (TEMP.UNITS / 365)
END
END
RETURN
*
ELP.CONVERT3: *
*
IF INDEX("SMH",TEMP.LAST,1) # 0 THEN
TEMP.LD = TEMP.LD + (TEMP.LT / 86400)
*
END ELSE
TEMP.LT = TEMP.LT + (TEMP.LD * 86400)
END
*
RETURN
!
*
END
~SYS.FILE.ITEM~
SUBROUTINE SYS.FILE.ITEM(S.F.I.PARAMS,S.F.I.EXEC)
*SUBROUTINE: SYS.FILE.ITEM
*
* AUTHOR: DAVID G. HORSMAN
*
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
SYS.PROG = "SYS.FILE.ITEM":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "FILE.ITEM":AM:SYS.SLOC
*
*
IF EXEC.VERB[1,1] # "/" & EXEC.VERB # "OFF" & EXEC.VERB # "TCL" THEN
S.F.I.EXEC = ""
CN = 0
LOOP CN = CN + 1; TC = S.F.I.PARAMS[CN,1] WHILE TC # "" DO
IF TC = " " THEN S.F.I.EXEC = S.F.I.EXEC:TC ELSE
IF TC = "A" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.APPL ELSE
IF TC = "B" THEN S.F.I.EXEC = S.F.I.EXEC:TASK.NUM ELSE
IF TC = "C" THEN S.F.I.EXEC = S.F.I.EXEC:TASK.STEP ELSE
IF TC = "D" THEN S.F.I.EXEC = S.F.I.EXEC:"(T)" ELSE
IF TC = "E" THEN S.F.I.EXEC = S.F.I.EXEC:"(P)" ELSE
IF TC = "F" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.FILE ELSE
IF TC = "G" THEN S.F.I.EXEC = S.F.I.EXEC:"*" ELSE
IF TC = "H" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.NAME ELSE
IF TC = "I" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.PREV ELSE
IF TC = "J" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.CONTROL<1,7> ELSE
IF TC = "K" THEN
TEMP = FIELD(S.F.I.PARAMS[CN+1,999],"<",1)
CN=CN+COL2()
PRINT @(0,22):CLL:BELL:TEMP:
INPUT TEMP1:
S.F.I.EXEC = S.F.I.EXEC:TEMP1
END ELSE
IF TC = "L" THEN S.F.I.EXEC = S.F.I.EXEC:"" ELSE
IF TC = "M" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.NAME[2,99] ELSE
IF TC = "N" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.PREV[2,99] ELSE
IF TC = "O" THEN S.F.I.EXEC = S.F.I.EXEC:PRMPTING ELSE
IF TC = "P" THEN S.F.I.EXEC = S.F.I.EXEC:" @PRESTORES" ELSE
IF TC = "Q" THEN S.F.I.EXEC = S.F.I.EXEC:"" ELSE
*
IF TC = "R" THEN
S.F.I.EXEC = S.F.I.EXEC:""
*
END ELSE IF TC = "S" THEN
S.F.I.EXEC = S.F.I.EXEC:MENU.SUBJCT
*
END ELSE IF TC = "T" ! TC = "Z" THEN
TEMP = ""
LOOP
WHILE S.F.I.PARAMS[CN+1,1] # "" & NUM(S.F.I.PARAMS[CN+1,1]) DO
TEMP = TEMP:S.F.I.PARAMS[CN+1,1]
CN = CN+1
REPEAT
IF NOT(NUM(TEMP)) THEN TEMP = 0
IF TEMP < 1 THEN TEMP = 0
IF TEMP > 0 THEN
IF MENU.CONTROL<1,2,TEMP> # "" THEN TC.CN = TEMP ELSE TC.CN = 1; TEMP =99
END ELSE
TC.CN = 1
TEMP = 99
END
LOOP WHILE MENU.CONTROL<1,2,TC.CN> # "" & TC.CN <= TEMP DO
IF TC = "T" THEN S.F.I.EXEC = S.F.I.EXEC:MENU.CONTROL<1,4,TC.CN>
S.F.I.EXEC = S.F.I.EXEC:FIELD(TOPIC.KEY,"#",TC.CN)
IF TEMP = 99 THEN S.F.I.EXEC = S.F.I.EXEC:"#"
TC.CN = TC.CN + 1
REPEAT
*
END ELSE IF TC = "U" THEN
S.F.I.EXEC = S.F.I.EXEC:USER.NAME
*
END ELSE IF TC = "V" THEN
S.F.I.EXEC = S.F.I.EXEC:MENU.SUB.APPL
*
END ELSE IF TC = "W" THEN
S.F.I.EXEC = S.F.I.EXEC:MENU.GRP.APPL
*
END ELSE IF TC = "X" THEN
PRINT @(0,22):CLL:BELL:"Enter command: ":
INPUT TEMP
S.F.I.EXEC = S.F.I.EXEC:TEMP
*
END ELSE IF TC = "Y" THEN
S.F.I.EXEC = S.F.I.EXEC:""
*
END ELSE IF TC = "<" ! TC = ">" THEN
CN = CN + 1
TCC = S.F.I.PARAMS[CN,1]
IF TC = ">" THEN TEMP = 1 ELSE IF TC = "<" THEN TEMP = LEN(S.F.I.EXEC)
LOOP WHILE S.F.I.EXEC[TEMP,1] = TCC ! S.F.I.EXEC[TEMP,1] = " " DO
IF TC = ">" THEN
TEMP = TEMP + 1
S.F.I.EXEC = S.F.I.EXEC[TEMP,999]
END ELSE IF TC = "<" THEN
TEMP = TEMP - 1
S.F.I.EXEC = S.F.I.EXEC[1,TEMP]
END
REPEAT
*
END ELSE IF TC = "'" ! TC = '"' THEN
TCC = TC
LOOP
CN = CN + 1
TC = S.F.I.PARAMS[CN,1]
WHILE TC # TCC & TC # "" DO
S.F.I.EXEC = S.F.I.EXEC:TC
REPEAT
END ELSE
*
S.F.I.EXEC = S.F.I.EXEC:TC
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
END
REPEAT
*
END
*
*
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
RETURN
END
~SYS.FILE.VERIFY~
SUBROUTINE SYS.FILE.VERIFY
*
* AUTHOR: DAVID G. HORSMAN
*
!
$INCLUDE IBP SYS.COMMON
TERMINAL = "?"
$INCLUDE IBP STANDARD.FUNCTIONS
*
SYS.PROG = "SYS.FILE.VERIFY"
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = "SYS"
SYS.ITEM = ""
*
!
SYS.SLOC = "SYS"
MAT STRUCT=''
OPEN "DH.SYS" TO SY.FILE ELSE
ERROR.TEXT = "No SYS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC = "MENUS"
OPEN "DH.MENUS" TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC = "MD"
OPEN "MD" TO MD.FILE ELSE
ERROR.TEXT = "No MD file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "READ"
*
*
OFF.RSP = "*OFF*off*Off*END*end*End*STOP*stop*HALT*halt*Halt*BYE*bye*Bye*LOGOFF*logoff*Logoff*"
TCL.RSP = "*COMMAND*TCL*tcl*Tcl*"
SYS.RSP = "*SCHEDULE*MESSAGE*WAIT*HELP*TIME*WHO*WHERE*STATUS*CONTACTS*TCL*OFF*"
SYS.RSP = SYS.RSP:"EXPENSES*NOTES*PHONE.BOOK*SHOPPING*ACCOUNTS*USERS*PORTS*UTILITIES*"
USER.NAME = ""
$INCLUDE IBP SYS.USER.NAME
MENU.NAME = ""
MENU.NUM = 1
MENU.APPL = "LOGON"
MENU.SUB.APPL = ""
MENU.GRP.APPL = ""
MENU.CONTROL = ""
PRMPTING = ""
TOPIC.KEY = ""
MAT STRUCT = ""
PORTD = ""
STRUCT(1) = 0
STRUCT(2) = ""
WAIT.FLAG = 1
DEFUALT.FILE = "BP"
DEFAULT.ITEM = "NOTES"
OLD.ITEM = ""
OLD.FILE = ""
!
USER.ABORT = ""
SYS.ABORT = ""
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
*
*
ERROR.TEXT = "Enter run type (1 or 2 or 3): "
*ERROR.CODE = "19002"
*GOSUB ERROR.CONTROL
PRINT @(0,21):CLS:@(0,22):ERROR.TEXT:; INPUT ERROR.RSP:
SYS.RUN.TYPE = ERROR.RSP
IF NOT(NUM(SYS.RUN.TYPE)) THEN SYS.RUN.TYPE = 2
IF SYS.RUN.TYPE EQ 0 THEN SYS.RUN.TYPE = 3
IF SYS.RUN.TYPE NE 2 THEN
*SYS.RUN.TYPE = 1
SYS.DEFAULT.FLAG = 1
READ SYS.DEFAULTS FROM MD.FILE,"@SYS@DEFAULTS@CODE.ED@":USER.NAME:"@":PORT ELSE
SYS.DEFAULTS = AM:AM:AM:AM:"BP":AM:"NOTES"
END
DEFUALT.FILE = SYS.DEFAULTS<5>
DEFAULT.ITEM = SYS.DEFAULTS<6>
END ELSE
SYS.DEFAULT.FLAG = 0
SYS.DEFAULTS = AM:AM:AM:AM:"BP":AM:"NOTES"
END
*
FILE.NAME = ""; FILE.ITEM = ""
PRINT @(0,5):CLS:
PRINT @(0,10):"Enter file name: ":
IF SYS.RUN.TYPE = 2 THEN
FOR TEMP = 1 TO WAIT.FLAG + 2 UNTIL SYSTEM(11)
RQM
NEXT TEMP
END
IF SYSTEM(11) OR SYS.RUN.TYPE = 1 THEN
INPUT FILE.NAME:
IF NOT(LEN(FILE.NAME)) THEN FILE.NAME = DEFUALT.FILE
END ELSE FILE.NAME = DEFUALT.FILE
*
INPUT.NEXT: *
*
LOOP
FILE.ITEM = ""
PRINT @(0,5):CLS:
PRINT @(0,10):"Enter file name: ":FILE.NAME:
READNEXT FILE.ITEM ELSE
PRINT @(0,12):"Enter item name: ":
FOR TEMP = 1 TO WAIT.FLAG + 2 UNTIL SYSTEM(11)
RQM
NEXT TEMP
IF SYSTEM(11) OR SYS.RUN.TYPE = 1 THEN
INPUT FILE.ITEM:
IF NOT(LEN(FILE.ITEM)) THEN FILE.ITEM = DEFAULT.ITEM
END ELSE FILE.ITEM = DEFAULT.ITEM
END
PRINT @(0,12):CLL:"Enter item name: ":FILE.ITEM:
IF FILE.ITEM EQ OLD.ITEM THEN FILE.ITEM = ""
IF LEN(FILE.ITEM) = 0 ! LEN(FILE.NAME) = 0 THEN STOP
*
WHILE FILE.ITEM = "*" DO
PRINT
PRINT
EXEC.VERB = "GET-LIST ":FILE.NAME
PRINT EXEC.VERB
EXECUTE EXEC.VERB
PRINT
READNEXT FILE.ITEM ELSE
EXEC.PARAMS = "SAVE-LIST ":FILE.NAME
EXEC.VERB = "SSELECT ":FILE.NAME
PRINT EXEC.VERB
PRINT ">":EXEC.PARAMS
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS
PRINT
END
EXEC.VERB = "GET-LIST ":FILE.NAME
PRINT EXEC.VERB
EXECUTE EXEC.VERB
PRINT
FILE.ITEM = ''
SYS.RUN.TYPE = 2
REPEAT
*
*
IF SYS.RUN.TYPE EQ 3 THEN
SYS.DEFAULTS<5> = FILE.NAME
SYS.DEFAULTS<6> = FILE.ITEM
DEFUALT.FILE = FILE.NAME
DEFAULT.ITEM = FILE.ITEM
WRITE SYS.DEFAULTS ON MD.FILE,"@SYS@DEFAULTS@CODE.ED@":USER.NAME:"@":PORT
END
*
CHECK.FILE = 0
SYS.SLOC = FILE.NAME
OPEN FILE.NAME TO INP.FILE THEN CHECK.FILE = 1 ELSE
CHECK.FILE = 0
ERROR.TEXT = "No ":FILE.NAME:" file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
OPEN "DICT DEV" TO INP.FILE.DICT THEN CHECK.FILE.DICT = 1 ELSE
CHECK.FILE.DICT = 0
ERROR.TEXT = "No DICTionary for DEV file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.LOCT = "MAIN"
SYS.LOCT = "MAIN"
SYS.SLOC = "INIT"
PRINT @(0,5):CLS:
START.DATE = DATE()
START.TIME = TIME()
READV BP.RUNS FROM INP.FILE.DICT,"@SYS@PSTAT@":FILE.ITEM,9 ELSE BP.RUNS = ""
PRINT @(0,5):"File: ":FILE.NAME
PRINT @(0,6):"Item: ":FILE.ITEM
PRINT @(0,7):"Started -   Date: ":OCONV(START.DATE,"D2"):
PRINT "  Time: ":OCONV(START.TIME,"MT"):
PRINT "  Required: ":OCONV(BP.RUNS<1,1,3>,"MTS")
PRINT
*PRINT
*PRINT;* PRINT;* PRINT
*
EXEC.VERB = "CHECK-SUM"
FILE.NAME = FILE.NAME
FILE.ITEM = FILE.ITEM
EXEC.PARAMS = ""
EXEC.RESULTS = ""
SYS.SLOC = "CHECK-SUM"
EXECUTE EXEC.VERB:' ':FILE.NAME:' "':FILE.ITEM:'"', //OUT. > EXEC.RESULTS
*
*
SYS.SLOC = "ANALYSIS"
GOSUB DISPLAY.ELP.TIME
LOOP WHILE EXEC.RESULTS<1> = '' DO
EXEC.RESULTS = DELETE(EXEC.RESULTS,1)
REPEAT
*
GOSUB DISPLAY.ELP.TIME
*
EXEC.RESULTS = "FILE: ":FILE.NAME:"    ITEM: ":FILE.ITEM:AM:EXEC.RESULTS:AM:AM:OCONV(DATE(),"D2"):"    ":OCONV(TIME(),"MT"):" ":USER.NAME:" ":WHO:" ":OCONV(ELP.TIME,"MTS"):AM:"Check-sum completed":AM:AM
*
WRITE EXEC.RESULTS ON INP.FILE.DICT,"@SYS@ESTAT@CHECK-SUM@":FILE.ITEM
*
*
PRINT
PRINT
TEMP = EXEC.RESULTS
DISPL.CN = 1
LOOP WHILE LEN(TEMP) DO
PRINTER ON
PRINT TEMP<1>
PRINTER OFF
PRINT TEMP<1>
TEMP = DELETE(TEMP,1)
DISPL.CN = DISPL.CN + 1
REPEAT
PRINTER ON
PRINT
PRINTER OFF
*
*
*
*
*
READ BP.RUNS FROM INP.FILE.DICT,"@SYS@PSTAT@":FILE.ITEM ELSE BP.RUNS = ""
BP.RUNS<9> = START.DATE:SVM:START.TIME:SVM:ELP.TIME:SVM:USER.NAME:VM:BP.RUNS<9>
*BP.RUNS<13> = "1111111111111111111111111"
WRITE BP.RUNS ON INP.FILE.DICT,"@SYS@PSTAT@":FILE.ITEM
*
*
*GOSUB ERROR.CONTROL
*
IF SYS.RUN.TYPE = 1 THEN SYS.RUN.TYPE = 2
OLD.FILE = FILE.NAME
OLD.ITEM = FILE.ITEM
GOTO INPUT.NEXT
*
STOP
*
!
DISPLAY.ELP.TIME: * Subroutine to display elapsed.
*
END.DATE = DATE(); END.TIME = TIME()
IF END.DATE # START.DATE THEN
ELP.TIME = (86400 - START.TIME) + END.TIME
END ELSE
ELP.TIME = END.TIME - START.TIME
END
*
PRINT @(0,8):CLL:"Finished -  Date: ":OCONV(END.DATE,"D2"):
PRINT "  Time: ":OCONV(END.TIME,"MT"):
PRINT "  Elasped:  ":OCONV(ELP.TIME,"MTS"):
*
RETURN
*
*$INCLUDE IBP SYS.ERROR.STRUCT
!
*INCLUDE IBP SYS.ERROR.CONTROL
*
*
* ERROR.CODE1 = 0        DON'T DISPLAY (SECURITY)
* ERROR.CODE1 = 1 OR 2   DISPLAY
* ERROR.CODE1 = 3        SLAVE MODE DON'T INPUT
* ERROR.CODE1 = 4        DIAL-UP PORT HUNG DON'T DISP OR INPUT
*
* ERROR.CODE2 = SEVERITY
*
* ERROR.CODE3 = WRITE FLAG
*
* ERROR.CODE4 = BELL FLAG
*
* ERROR.CODE5 = ENTRY FLAG (ERROR.RSP)
*
*
ERROR.CONTROL: * Subroutine to display & log errors
ERROR.CN = 0
ERROR.FATAL = 99
ERROR.READ = 0
ERROR.WRITE = 0
*
LOOP
ERROR.CN = ERROR.CN + 1
ERROR.TEXT1 = ERROR.TEXT<1>
ERROR.CODE1 = ERROR.CODE<1>[1,1]
ERROR.CODE2 = ERROR.CODE<1>[2,1]
ERROR.CODE3 = ERROR.CODE<1>[3,1]
ERROR.CODE4 = ERROR.CODE<1>[4,1]
ERROR.CODE5 = ERROR.CODE<1>[5,1]
*
WHILE LEN(ERROR.TEXT:ERROR.CODE) # 0 DO
IF LEN(ERROR.TEXT<2>:ERROR.CODE<2>) # 0 THEN ERROR.MORE = 1 ELSE ERROR.MORE = 0
*
IF ERROR.CODE2 < 4 AND ERROR.CODE1 THEN ERROR.CODE3 = 1
*
IF STRUCT(27)<1,PORT+1> > 0 AND STRUCT(27)<1,PORT+1> < 11 THEN ERROR.CODE1 = 3
*
IF ERROR.CODE1 AND ERROR.CODE1 < 4 THEN
ERROR.LN = ERROR.CODE[6,2]
IF NOT(NUM(ERROR.LN)) THEN ERROR.LN = 22
IF LEN(ERROR.LN) = 0 THEN ERROR.LN = 22
ERROR.CL = ERROR.CODE[8,2]
IF NOT(NUM(ERROR.CL)) THEN ERROR.CL = 0
IF LEN(ERROR.CL) = 0 THEN ERROR.CL = 0
IF ERROR.CODE2 < 4 THEN
ERROR.LN = 10
PRINT @(0,5):CLS:BELL:
RQM
ERROR.CODE5 = 1
END
PRINT @(0,21):CLS:
PRINT @(ERROR.CL,ERROR.LN):
IF ERROR.CODE4 THEN PRINT BELL:; RQM
IF ERROR.CODE1 = 1 THEN
ERROR.DISP = TRIM((USER.NAME:", ":ERROR.TEXT1)[1,75])
END ELSE ERROR.DISP = TRIM(ERROR.TEXT1)
IF ERROR.CODE2 < 4 THEN PRINT RVB:
PRINT ERROR.DISP:
IF ERROR.CODE2 < 4 THEN PRINT "!  ": ELSE
IF ERROR.CODE5 = 1 THEN
PRINT ".  ":
END ELSE
IF ERROR.MORE THEN PRINT ", ": ELSE IF ERROR.CODE5 = 0 THEN PRINT ".":
END
END
IF ERROR.CODE2 < 4 THEN PRINT RVE:
END
*
*
ERROR.RSP = ""
IF ERROR.CODE5 AND ERROR.CODE1 AND ERROR.CODE1 < 3 THEN
IF ERROR.CODE5 = 1 THEN PRINT "Enter <CR>   ":
FOR TEMP = 1 TO 10 UNTIL SYSTEM(11)
IF NOT(SYSTEM(11)) THEN RQM
NEXT TEMP
IF SYSTEM(11) OR ERROR.CODE2 < 6 THEN
INPUT ERROR.RSP:
*IF INDEX(OFF.RSP,"*":ERROR.RSP:"*",1) # 0 THEN EXECUTE "OFF"
*IF INDEX(TCL.RSP,"*":ERROR.RSP:"*",1) # 0 THEN STOP
END ELSE ERROR.RSP = ""
END
*
WAIT.TEMP = WAIT.FLAG - 1
IF NOT(NUM(WAIT.TEMP)) THEN WAIT.TEMP = 3
IF WAIT.TEMP < 0 THEN WAIT.TEMP = 0
IF LEN(WAIT.TEMP) = 0 THEN WAIT.TEMP = 3
FOR A = 1 TO WAIT.TEMP; RQM; NEXT A
*
*
IF ERROR.CODE3 THEN
IF NOT(ERROR.READ) THEN
READV NEXT.ERROR FROM SY.FILE,"@ERRORS@":USER.NAME,1 ELSE NEXT.ERROR = 2
ERROR.READ = 1
END
*
*1 IS SCRUTINIZED
*2 IS PURGE
*3 IS ANY ACTIONS TO
*4 IS APPLICATION
*5 IS MENU NUMBER
*6 IS MENU OPTION
*7 IS PROGRAM NAME
*8 IS PROGRAM LOCATION
*9 IS PROGRAM SUB-LOCATION
*10 IS PORT
*11 IS ACCOUNT
*12 IS DATE
*13 IS TIME
*14 IS SEVERITY OF ERROR
*15 IS TEXT FOR DISPLAY
*16 IS WHAT USER TYPED IS RESPONSE TO 'ENTER <CR>'
*
*
ERROR.REC = '0':VM:'0':VM:STRUCT(5):VM:MENU.APPL:VM:MENU.CONTROL<1,9>:VM:PRMPTING
ERROR.REC = ERROR.REC:VM:SYS.PROG<1>:VM:SYS.LOCT<1>:VM:SYS.SLOC<1>:VM
ERROR.REC = ERROR.REC:PORT:VM:ACCT:VM:DATE():VM:TIME()
ERROR.REC = ERROR.REC:VM:ERROR.CODE<1>:VM:ERROR.TEXT1:VM:ERROR.RSP
*
WRITEV ERROR.REC ON SY.FILE,"@ERRORS@":USER.NAME,NEXT.ERROR
NEXT.ERROR = NEXT.ERROR + 1
ERROR.WRITE =1
ERROR.REC = ""
END
*
IF NUM(ERROR.CODE2) THEN
IF ERROR.FATAL > ERROR.CODE2 THEN ERROR.FATAL = ERROR.CODE2
END
*
ERROR.CODE = DELETE(ERROR.CODE,1)
ERROR.TEXT = DELETE(ERROR.TEXT,1)
*
REPEAT
*
IF ERROR.WRITE THEN WRITEV NEXT.ERROR ON SY.FILE,"@ERRORS@":USER.NAME,1
IF NOT(NUM(ERROR.FATAL)) THEN ERROR.FATAL = 0
IF ERROR.FATAL = 1 THEN EXECUTE "OFF"
IF ERROR.FATAL = 2 THEN STOP
IF ERROR.FATAL = 3 THEN PRINT BELL:
RETURN
*
!
*@@@@@@@@@@2
*
END
~SYS.FILE.XREF~
*PROGRAM: SYS.FILE.XREF
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
* Load program control and structure variables.
DIM STRUCT(120)
SYS.PROG = "SYS.REL.EDIT"
SYS.PROG.TYPE = 2
NEW.RUN.TYPE = FALSE
EXEC.PARSE.TEXT = ""
* 0 or unassigned = FOREIGN ROUTINE
*# 1 = TCL PROGRAM
*# 2 = TCL PROC
*# 3 = SYS MAIN (TCL/PROC) ROUTINE
*# 7 = CALL SUBROUTINE
*# 8 = SYS SUBROUTINE CALL
*# 
SYS.ABORT = FALSE
USER.ABORT = FALSE
START.DATE = DATE()
START.TIME = TIME()
BP.RUNS = ""
EXEC.RESULTS = ""
EXEC.PARSE.TEXT =  ""
STAT = FALSE
LIST.ID.FLAG = FALSE
SYS.UPD = ""; SYS.PREFIX = ""; SYS.SUFFIX = ""
*#
$INCLUDE IBP SYS.REL.INCL.PARAMETER.INDEX
$INCLUDE IBP SYS.REL.INCL.PARAMETER.INPUT
*#
$INCLUDE IBP SYS.REL.INCL.FILE.OPEN
$INCLUDE IBP SYS.REL.INCL.USER.LOAD
*# Read the company record that user is working with.
$INCLUDE IBP SYS.INCL.COMPANY.READ
*# Detect a company data mis-match.
IF CO.DATA<4> NE STRUCT(29)<1,PORT+1> THEN
PRINT BELL:
STOP
END
$INCLUDE IBP SYS.REL.INCL.USER.READ.LAST.ACCESS
$INCLUDE IBP SYS.REL.INCL.USER.DEFAULT
$INCLUDE IBP SYS.REL.INCL.CURR
$INCLUDE IBP SYS.REL.INCL.INPUT.PARAMETERS
STRUCT(29)<1,PORT+1> = PORT.ACCESS<1>
*STRUCT(30)<1,PORT+1> = PORT.ACCESS<2>
*PORT.ACCESS<3> = TASK.REL
STRUCT(61)<1,PORT+1> = PORT.ACCESS<4>
STRUCT(69)<1,PORT+1> = PORT.ACCESS<5>
TASK.TOPIC = PORT.ACCESS<1>:"*":PORT.ACCESS<2>:"*":PORT.ACCESS<7>:"*":PORT.ACCESS<6>
STRUCT(34)<1,PORT+1> = PORT.ACCESS<1>:"#":PORT.ACCESS<2>:"#":PORT.ACCESS<7>:"#":PORT.ACCESS<6>
*PORT.ACCESS<8> = TOPIC.LOC
PORT.ACCESS<9> = TASK.TOPIC
*# Load TASK values.
TASK.CO   = PORT.ACCESS<1>
TASK.APPL = PORT.ACCESS<2>
TASK.REL  = PORT.ACCESS<3>
TASK.NUM  = PORT.ACCESS<4>
TASK.STEP = PORT.ACCESS<5>
*TASK.DESC = STRUCT(62)<1,PORT+1>
*TASK.TOPIC = PORT.ACCESS<9>
TASK.FILE = FIELD(TASK.TOPIC,"*",4)
TASK.ITEM = FIELD(TASK.TOPIC,"*",3)
TASK.LIST = PORT.ACCESS<13>
SYS.ITEM = "@SYS@USER@":USER.NAME
MATWRITE STRUCT ON SY.FILE,SYS.ITEM
*# 
LAST.FILE = "**INIT**"; LAST.ITEM = "**INIT**"; LAST.PRESTORE = "**INIT**"; LAST.TOPIC.RSP = "**INIT**"
*# 
*# Loop to process file/program sets
*#
PRINT CLL:"[=| "
PRINT CLL:"[=| "
*EXECUTE "LISTFILES MD (T,N)"
EXECUTE "LISTFILES.SEL"
*
EXECUTE "GET-LIST FILES", //SELECT. > FILE.ID.LIST
*
LOOP
READNEXT FILE.ID FROM FILE.ID.LIST ELSE STOP
*#
PRINT CLL:"[=| "
PRINT CLL:"[=| "
PRINT CLL:RVB:"[=| ":" * * * ":FILE.ID:" * * * ":RVE
PRINT CLL:"[=| "
TASK.APPL = "SYS"
TASK.NUM = "00000"
TASK.STEP = "1"
*#
XREF.INDEX.SUFF = "@SYS@DEV@XREF@INDEX"
XREF.INDEX.DATA = ""
*#
READ ITEM FROM MD.FILE,FILE.ID ELSE ITEM = ""; SYS.ABORT = 6
*#
XREF.INDEX.DATA = ITEM
*#
DCODE = ITEM<1>
IF DCODE[1,1] NE "Q" THEN
DACCT.FLAG = TRUE
QACCT.FLAG = FALSE
XREF.INDEX.ID = XREF.INDEX.SUFF:"@FILE"
XREF.INDEX.DATA<2> = ACCT
XREF.INDEX.DATA<3> = FILE.ID
END ELSE
DACCT.FLAG = FALSE
QACCT.FLAG = TRUE
XREF.INDEX.ID = XREF.INDEX.SUFF:"@QFILE"
END
TASK.ITEM = ""
*#
TASK.VAR = ""
*#
XREF.FUNC = 3
XREF.INDEX.DATA = ""
*#
SYS.RUN.STAT = TRUE
STAT = FALSE
*#
*#
TASK.FILE = "DICT.":FILE.ID
*#
CALL SYS.REL.XREF(SY.FILE,TASK.USER,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TASK.TOPIC,TASK.TOPIC.CN,TASK.FILE,TASK.ITEM,TASK.VAR,XREF.FUNC,XREF.INDEX.ID,XREF.INDEX.DATA,STAT,SYS.RUN.STAT)
*#
IF DACCT.FLAG THEN
EXEC.LINE = "SSELECT DICT ":FILE.ID
EXEC.PARAMS = "SAVE-LIST SYS.TEMP"
PRINT CLL:"[=| ":EXEC.LINE
PRINT CLL:"[=| ":">":EXEC.PARAMS
EXECUTE EXEC.LINE, //SELECT. > EXEC.LIST
EXECUTE EXEC.PARAMS, //SELECT. < EXEC.LIST
*#
EXEC.LINE = "COPY-LIST SYS.TEMP (O,D)"
EXEC.PARAMS = "(DICT ":FILE.ID:" @LIST@DICT.":FILE.ID
PRINT CLL:"[=| ":EXEC.LINE
PRINT CLL:"[=| ":">":EXEC.PARAMS
EXECUTE EXEC.LINE, //IN. < EXEC.PARAMS
END; *# OF NOT DACCT.FLAG
*#
*#
*#
TASK.FILE = FILE.ID
*#
CALL SYS.REL.XREF(SY.FILE,TASK.USER,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TASK.TOPIC,TASK.TOPIC.CN,TASK.FILE,TASK.ITEM,TASK.VAR,XREF.FUNC,XREF.INDEX.ID,XREF.INDEX.DATA,STAT,SYS.RUN.STAT)
*#
IF DACCT.FLAG THEN
EXEC.LINE = "SSELECT ":FILE.ID
EXEC.PARAMS = "SAVE-LIST SYS.TEMP"
PRINT CLL:"[=| ":EXEC.LINE
PRINT CLL:"[=| ":">":EXEC.PARAMS
EXECUTE EXEC.LINE, //SELECT. > EXEC.LIST
EXECUTE EXEC.PARAMS, //SELECT. < EXEC.LIST
*#
EXEC.LINE = "COPY-LIST SYS.TEMP (O,D)"
EXEC.PARAMS = "(DICT ":FILE.ID:" @LIST@":FILE.ID
PRINT CLL:"[=| ":EXEC.LINE
PRINT CLL:"[=| ":">":EXEC.PARAMS
EXECUTE EXEC.LINE, //IN. < EXEC.PARAMS
END; *# OF NOT DACCT.FLAG
*#
*#
*#
CONT = TRUE
WHILE CONT DO REPEAT
*
*#
*#
STOP
*#
$INCLUDE IBP SYS.REL.INCL.ERROR
~SYS.HELP~
SUBROUTINE SYS.HELP(HELP,RSP)
*SUBROUTINE: SYS.HELP
*
* AUTHOR: DAVID G. HORSMAN
*
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
*
DIM MODE.DESC(30),STAT.DESC(15)
*
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*
SYS.PROG = "SYS.HELP":AM:SYS.PROG
SYS.LOCT = "OPEN":AM:SYS.LOCT
SYS.SLOC = "OPEN":AM:SYS.SLOC
!
SYS.FILE = "MENUS"
OPEN SYS.FILE TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "HLP"
OPEN SYS.FILE TO HLP.FILE THEN CHECK.HELP = 1 ELSE
CHECK.HELP = 0
ERROR.TEXT = "No HLP file":AM:"sorry but there are no help facilities availalble"
ERROR.CODE = "13110":AM:"13111"
GOSUB ERROR.CONTROL
END
*
IF NOT(CHECK.HELP) THEN RETURN
*
SYS.LOCT<1> = "INIT"
SYS.SLOC<1> = "DIM"
DIM HELP.REC(100)
MAT HELP.REC = ""
SUBR.FUNCTION = ""
*
SYS.SLOC<1> = "READ"
*
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@HELP.LEVEL.DESC"
MATREAD HELP.REC FROM SY.FILE,SYS.ITEM ELSE
MAT HELP.REC = ""
ERROR.TEXT = "descriptions missing":AM:"sorry but there are no help facilities availalble"
ERROR.CODE = "13110":AM:"13111"
GOSUB ERROR.CONTROL
RETURN
END
*
HELP.INP1 = ""
Remove.first: * Take off HELP & ?'S
LOOP WHILE HELP[1,1] = "?" ! HELP[1,1] = " " DO HELP = HELP[2,99] REPEAT
*
IF HELP[1,4] = "HELP" THEN HELP = HELP[5,99]; GOTO Remove.first
*
TEMP = FIELD(HELP," ",1)
IF TEMP = "EDIT" ! TEMP[1,3] = "WP-" THEN
HELP.INP1 = TEMP
HELP = HELP[COL2(),99]
GOTO Remove.first
END
*
HELP.OPT = FIELD(HELP," ",1)
RSP = HELP.OPT
HELP.INP = FIELD(HELP," ",2)
IF NOT(NUM(HELP.INP)) THEN HELP.INP = 0
IF LEN(HELP.INP) = 0 THEN HELP.INP = 0
IF NOT(HELP.INP) THEN CALL.FUNCTION = "MENU" ELSE CALL.FUNCTION = "EXECUTE"
HELP = HELP.INP
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
*
LOOP
IF CALL.FUNCTION = "MENU" THEN GOSUB Help.menu
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
*
IF HELP.INP1[1,3] = "WP-" ! HELP.INP1 = "EDIT" ! CALL.FUNCTION = "EDIT" THEN
IF USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN
GOSUB Help.key.format
PRINT @(0,5):CLS:@(0,6):"Ready for edit."
EXECUTE HELP.INP1:" HLP ":SYS.ITEM
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
IF CALL.FUNCTION = "EDIT" THEN HELP.INP = "END"
END
HELP.INP1 = ""
*
END ELSE
IF HELP.INP # "END" ! CALL.FUNCTION = "EXECUTE" THEN GOSUB Help.display
*
END
WHILE CALL.FUNCTION = "MENU" & HELP.INP # "END" DO REPEAT
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
RETURN
!
Help.menu: * Main program.
SYS.LOCT<1> = "HELP.MENU"
SYS.SLOC<1> = "DISPLAY"
*
HELP.CONT = 1; HELP.CONT1 = 1
HELP.CN   = 1; HELP.STOP  = 15
*
LOOP
IF HELP.CN = INT(HELP.CN / 15) * 15 + 1 THEN
PRINT @(0,5):CLS:
END ELSE PRINT @(0,6):CLL:
PRINT @(10,6):"User Help Menu for ":USER.NAME:
LOOP WHILE HELP.REC(HELP.CN)<1,4> # "" & HELP.CONT & HELP.CN <= 100 DO
IF HELP.CN < HELP.STOP + 1 THEN
TEMP.LN = HELP.CN - INT((HELP.CN - 1) / 15) * 15 + 6
PRINT @(2,TEMP.LN):CLL:
PRINT (HELP.CN:") ") "R#4":" ":
PRINT (HELP.REC(HELP.CN)<1,4>:" . . . . . . . . . . . . . . . . . . . . . . . . .") "L#40":
PRINT HELP.REC(HELP.CN)<1,1>:"-":HELP.REC(HELP.CN)<1,2> "L#15":
HELP.CN = HELP.CN + 1
END ELSE HELP.CONT = 0
REPEAT
*
IF HELP.REC(HELP.CN)<1,4> # "" THEN PRINT @(0,6):"(MORE)":
PRINT @(0,22):CLS:STRUCT(2):', Enter "B" for back a page, "N" for next page,':
PRINT @(0,23):CLL:SPACE(5):' a help number or <CR>, or "END"  to end . . .':
INPUT HELP.INP:
IF HELP.INP = "END" THEN
HELP.CONT = 0; HELP.CONT1 = 0
*
END ELSE IF HELP.INP = "B" THEN
IF HELP.STOP >15 THEN
HELP.STOP = HELP.STOP - 15
HELP.CN = HELP.STOP - 15 + 1
END ELSE
PRINT BELL:
HELP.STOP = 15
HELP.CN = 1
END
HELP.CONT = 1
*
END ELSE IF HELP.INP = "N" THEN
IF HELP.STOP < 100 & HELP.REC(HELP.STOP + 1)<1,4> # "" THEN
HELP.STOP = HELP.STOP + 15
HELP.CN = HELP.STOP - 15 + 1
END ELSE
PRINT BELL:
HELP.STOP = 15
HELP.CN = 1
END
HELP.CONT = 1
*
END ELSE IF LEN(HELP.INP) = 0 THEN
IF HELP > 0 THEN
HELP.CONT1 = 0
HELP.INP = HELP
END ELSE
HELP.INP = ""
HELP.CN = 1
HELP.STOP = 15
HELP.CONT = 1
END
*
END ELSE
IF INDEX("*EDIT*WP-INPUT*","*":FIELD(HELP.INP," ",1):"*",1) # 0 THEN
HELP.INP1 = FIELD(HELP.INP," ",1)
HELP.INP = FIELD(HELP.INP," ",2)
IF NOT(NUM(HELP.INP)) THEN HELP.INP1 = ""
END
*
IF NUM(HELP.INP) THEN
IF NOT(HELP.INP > 0 & HELP.INP < 100 & LEN(HELP.REC(HELP.INP)<1,4>) > 0) THEN
HELP.INP = ""
END ELSE HELP.CONT1 = 0
*
END ELSE
ERROR.TEXT = "that was an invalid entry"
ERROR.CODE = 14011
GOSUB ERROR.CONTROL
HELP.CONT1 = 0
END
END
*
WHILE HELP.CONT1 DO REPEAT
*
RETURN
!
*
Help.key.format: * Subroutine to format Topic 1#2#3#4...
*
SYS.LOCT<1> = "KEY.FORMAT"
SYS.SLOC<1> = ""
*
IF HELP.INP > 0 & HELP.INP < 101 THEN
HELP.LEVEL = HELP.REC(HELP.INP)<1,1>:"@":HELP.REC(HELP.INP)<1,2>:"@":HELP.REC(HELP.INP)<1,3>
END ELSE HELP.LEVEL = ""
*
SYS.ITEM = "@":MENU.APPL:"@":MENU.CONTROL<1,9>:"@":HELP.OPT:"@":HELP.LEVEL
*
PRINT @(0,5):CLS:
*
PRINT @(0,10):"User Help Facilities"
*
PRINT @(0,12):"Key: ":SYS.ITEM
*
READV HELP.DOC FROM HLP.FILE,SYS.ITEM,1 THEN HELP.DOC.FOUND = 1 ELSE
ERROR.TEXT = "that help document does not exist"
PRINT @(0,15):ERROR.TEXT:
ERROR.TEXT = ERROR.TEXT:AM:"the key was ":SYS.ITEM
ERROR.CODE = "04110":AM:"14110"
GOSUB ERROR.CONTROL
HELP.DOC.FOUND = 0
END
*
*
RETURN
!
Help.display: * Subrouting to display Help.
*
SYS.LOCT<1> = "DISPLAY"
SYS.SLOC<1> = ""
GOSUB Help.key.format
IF HELP.DOC.FOUND THEN
PRINT @(0,5):CLS:
EXECUTE "WP-OUTPUT HLP ":SYS.ITEM
ERROR.TEXT = "Enter <CR> to return to the menu"
ERROR.CODE = 19001
GOSUB ERROR.CONTROL
END
*
RETURN
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
END
~SYS.INPUT.DATE.CODE~
*PROGRAM: SYS.INPUT.DATE.CODE
*
* AUTHOR: DAVID HORSMAN
*
!
*
*$INCLUDE IBP SYS.INPUT.DATE.CODE
*
INPUT.DATE.CODE: * Date to remove from hold and reason code or comments
IF INDEX("*H*X*","*":F.T:"*",1) # 0 THEN
PRINT @(0,21):CLL:@(0,22):CLL:@(0,23):CLL:
ENT.DATE = "0"
IF F.T = "H" THEN
PRINT "Till what date? ":
ENT.DATE = ""
INPUT ENT.DATE:
ENT.DATE = ICONV(ENT.DATE,"D2")
IF LEN(ENT.DATE) = 0 THEN ENT.DATE = "0"
IF ENT.DATE # 0 THEN PRINT @(16):OCONV(ENT.DATE,"D2"):@(28): ELSE PRINT @(16):"on request":@(28):
END
PRINT "Comment: ":
INPUT ENT.CODE:
P.S<CN,DATE.CODE.VM> = ENT.DATE:"*":ENT.CODE:SVM:P.S<CN,DATE.CODE.VM>
END
RETURN
*
~SYS.INPUT.FREQUENCY~
*PROGRAM: SYS.INPUT.FREQUENCY
*
* AUTHOR: DAVID HORSMAN
*
*$INCLUDE IBP SYS.INPUT.FREQUENCY
!
*
*$INCLUDE IBP SYS.INPUT.FREQUENCY
*
INPUT.FREQUENCY: * Amount and Unit of frequency (9999 / SMHDWMQY)
PRINT @(0,21):CLL:@(0,22):CLL:@(0,23):CLL:
FREQ.AMT = "1"
PRINT @(0,21):"Enter amount (ie. once every (M)onth, you would enter 1 here)":
PRINT @(0,22):"[==>> ":
FREQ.AMT = ""
INPUT FREQ.AMT:
IF LEN(FREQ.AMT) = 0 THEN FREQ.AMT = "1"
PRINT @(0,21):CLL:"Enter Unit of Frequency (ie. do every ":FREQ.AMT:" (H)ours; SMHDWMQ or Y)":
PRINT @(0,22):CLL:"[==>> ":
INPUT FREQ.UNIT:
P.S<CN,FREQ.VM> = FREQ.AMT:"*":REQ.UNIT:"*FREQUENCY":SVM:P.S<CN,FREQ.VM>
RETURN
*
~SYS.KEY.CONVERT-COPY~
*PROGRAM: SYS.KEY.CONVERT-COPY
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
*
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
*
!
*
SYS.PROG = 'FILE.KEY.CONVERT':AM:SYS.PROG
SYS.LOCT = '':AM:SYS.LOCT
SYS.SLOC = '':AM:SYS.SLOC
SYS.PROG.DESC = "File Key Conversion Utility"
*
*
RUN.DATE = DATE()
RUN.TIME = TIME()
EXECUTE "SP-ASSIGN HS"
Start.of.prog: *
PRINT @(0,5):CLS:@(0,7):
PRINT 'Enter "FROM" file name: ':; INPUT INP.FILE.NAME:
PRINT @(0,5):CLS:@(0,7):'Enter "FROM" file name: ':INP.FILE.NAME:
IF INP.FILE.NAME = "" OR INP.FILE.NAME = "END" THEN
EXECUTE "SP-ASSIGN"
PRINT @(0,0):CLS:SYS.PROG.DESC:
STOP
END
PRINT @(0,9):'Enter "TO" file name: ':; INPUT OUT.FILE.NAME:
PRINT @(0,9):CLL:'Enter "TO" file name: ':OUT.FILE.NAME:
IF OUT.FILE.NAME = "" THEN GOTO Start.of.prog
OPEN INP.FILE.NAME TO INP.FILE ELSE GOTO Start.of.prog
OPEN OUT.FILE.NAME TO OUT.FILE ELSE GOTO Start.of.prog
CONT = 1
INP.DELETE = 0
PRINT @(40,7):'Enter old key prefix: ':; INPUT INP.PREFIX:
PRINT @(40,7):CLL:'Enter old key prefix: ':INP.PREFIX:
PRINT @(40,8):'Enter new key prefix: ':; INPUT OUT.PREFIX:
PRINT @(40,8):CLL:'Enter new key prefix: ':OUT.PREFIX:
PRINT @(0,11):BELL:'Delete "FROM" records? ':; INPUT INP.DELETE:
IF INP.DELETE = "Y" THEN INP.DELETE = 1
IF NOT(NUM(INP.DELETE)) THEN INP.DELETE = 0
IF INP.DELETE # 1 THEN INP.DELETE = 0
RSP = ""
LOOP WHILE RSP # "Y" AND RSP # "N" DO
PRINT @(0,13):"OK to continue? ":; INPUT RSP:
IF RSP = "END" THEN
PRINT @(0,23):"Copy aborted!!!":BELL:
RQM; RQM
EXECUTE "SP-ASSIGN"
PRINT @(0,0):CLS:
STOP
END
PRINT @(0,23):CLL:
REPEAT
IF RSP = "N" THEN GOTO Start.of.prog
PRINTER CLOSE
PRINTER ON
PRINT FF:SYS.PROG
PRINT
PRINT
PRINT OCONV(RUN.DATE,'D2'):'     ':OCONV(RUN.TIME,'MTS'):
PRINT
PRINT '"FROM" file name: ':INP.FILE.NAME
PRINT
PRINT OCONV(RUN.DATE,'D2'):'     ':OCONV(RUN.TIME,'MTS'):
PRINT
PRINT '"FROM" file name: ':INP.FILE.NAME
PRINT
PRINT '"TO" file name: ':OUT.FILE.NAME
PRINT
PRINT; PRINT "INP.DELETE: ":INP.DELETE
PRINT; PRINT "INP PREFIX: ":INP.PREFIX
PRINT; PRINT "OUT PREFIX: ":OUT.PREFIX
PRINT; PRINT; PRINT; PRINT
INP.K.L = LEN(INP.PREFIX)
OUT.K.L = LEN(OUT.PREFIX)
EXEC.VERB = 'SSELECT ':INP.FILE.NAME:' = "':INP.PREFIX:']"'
EXECUTE EXEC.VERB, //SELECT. > EXEC.LIST
LOOP
READNEXT ID FROM EXEC.LIST ELSE CONT = 0
WHILE CONT DO
IF ID[1,INP.K.L] = INP.PREFIX THEN
*
READ INP.REC FROM INP.FILE,ID THEN
*
ID.SUFFIX = ID[INP.K.L+1,99]
WRITE INP.REC ON OUT.FILE,OUT.PREFIX:ID.SUFFIX
PRINTER ON
PRINT ID "L#15":" COPIED TO ":OUT.PREFIX:ID.SUFFIX:"<"
PRINTER OFF
PRINT ID "L#15":" COPIED TO ":OUT.PREFIX:ID.SUFFIX:"<"
*
IF INP.DELETE THEN
DELETE INP.FILE,ID
PRINTER ON
PRINT ID "L#15":" DELETED<"
PRINTER OFF
PRINT ID "L#15":" DELETED<"
END
*
*
END ELSE
PRINT "Record not found on old file!  Key: ":ID:"   ":; INPUT CONT
PRINTER ON
PRINT "Record not found on old file!  Key: ":ID
PRINTER OFF
END
*
*
END ELSE
PRINTER ON
PRINT ID "L#15":" is bypassed because of the key prefix<"
PRINTER OFF
PRINT ID "L#15":" is bypassed because of the key prefix<"
END
*
REPEAT
PRINTER OFF
GOTO Start.of.prog
END
~SYS.LINE.INPUT~
SUBROUTINE SYS.LINE.INPUT(CL,LN,EQ.LENG,OLD.RSP,NEW.RSP,UD.OK,LR.OK,LN.POS,RSP.FORCE)
*SUBROUTINE: SYS.LINE.INPUT
*
* AUTHOR: DAVID G. HORSMAN
*
!
*$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*#*SYS.PROG = "SYS.LINE.INPUT":AM:SYS.PROG
*#*SYS.LOCT = "INIT":AM:SYS.LOCT
*#*SYS.SLOC = "EQUATES":AM:SYS.SLOC
SYS.SLOC = "LINE.INPUT"
DIM MODE.DESC(30),STAT.DESC(15)
*
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
$INCLUDE IBP SYS.INCL.BATCH.RSP
$INCLUDE IBP SYS.INCL.LIST.RSP
*$INCLUDE IBP SYS.INCL.STAT.LINE
*#
*#
LENGTH = EQ.LENG
IF LENGTH EQ 0 THEN LENGTH = 50
LR.OK = 1
*
TEMP1 = 0
*CURSOR.LOC = "562694485025546526021546220653127":AM:"^^^^v900v<-<>+>>**999"
CURSOR.LOC    = "434526942550101360216261527251"
CURSOR.LOC<2> = "+-^<900900vv<<>>**999999"
ORIG.OLD = OLD.RSP
ORIG.NEW = NEW.RSP
IF LN.POS = 1 THEN NEW.RSP = OLD.RSP
*#
*#
*#
IF RSP.FORCE THEN
*
INPUT NEW.RSP:
IF NEW.RSP = '' THEN NEW.RSP = OLD.RSP
END ELSE
*
*#
*# NOTE: END STATEMENT IS A LOOONNNGGG WAY DOWN THERE vvv .
*#
CN = 1
PRINT @(CL,LN):OLD.RSP:@(CL):NEW.RSP:
LOOP WHILE TEMP1 NE 900 AND TEMP1 NE 951 AND CN < LENGTH + 1 DO
TC = ""
ECHO OFF
INPUT TC,1:
ECHO ON
TEMP = SEQ(TC)
*#IF TEMP = 27 THEN PRINT CLS:; PRINT; STOP
IF TEMP EQ 27 OR TEMP EQ 251 THEN TEMP1 = 951; PRINT "$":; *#
LOCATE TEMP IN CURSOR.LOC<1> SETTING LOC THEN TEMP1 = CURSOR.LOC<2,LOC> ELSE TEMP1 = ""
IF TEMP1 # "" THEN
*
IF TEMP1 = "^" AND UD.OK THEN
LN = LN-1
CN = 1
NEW.RSP = ""
*RETURN
*
END ELSE IF TEMP1 = "v" AND UD.OK THEN
LN = LN+1
CN = 1
NEW.RSP = ""
*RETURN
*
END ELSE IF TEMP1 = ">" AND LR.OK AND OLD.RSP[CN,1] # "" THEN
TC = OLD.RSP[CN,1]
PRINT TC:
CN = CN+1
NEW.RSP = NEW.RSP:TC
*
END ELSE IF TEMP1 = "<" AND LR.OK THEN
NEW.RSP = NEW.RSP[1,LEN(NEW.RSP)-1]
PRINT @(CL+LEN(NEW.RSP)):"  ":@(CL,LN):OLD.RSP:@(CL):NEW.RSP:
CN = CN - 1
IF CN < 1 THEN CN = 1
*
END ELSE IF TEMP1 = "-" OR TEMP1 = "+" AND LR.OK THEN
IF TEMP1 = "-" THEN
OLD.RSP = OLD.RSP[1,CN]:OLD.RSP[CN+2,999]
END ELSE
OLD.RSP = OLD.RSP[1,CN]:" ":OLD.RSP[CN+1,999]
END
PRINT @(CL,LN):OLD.RSP:
IF TEMP1 = "-" THEN PRINT " ":
PRINT @(CL):NEW.RSP:
*
END ELSE IF TEMP1 = "*" THEN
PRINT @(CL,LN):ORIG.OLD:
TEMP2 = CN+LEN(OLD.RSP[CN,999])-LEN(ORIG.OLD)
PRINT SPACE(TEMP2):
OLD.RSP = ORIG.OLD
NEW.RSP = ORIG.NEW
CN = 1
PRINT @(CL):NEW.RSP:
*
END ELSE IF TEMP1 = 900 THEN
*#
*#
END ELSE PRINT BELL:
END ELSE
PRINT TC:
NEW.RSP = NEW.RSP:TC
CN = CN+1
END
REPEAT
*#*
END; *#*# OF FORCE OR CHARACTER INPUT @@@
*#*
*#*
*#*
RETURN
END
~SYS.LOCK.ITEM~
SUBROUTINE SYS.LOCK.ITEM
*
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
*
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
*
!
*
SYS.PROG = "LOCK.ITEM":AM:SYS.PROG
SYS.LOCT = "OPEN":AM:SYS.LOCT
SYS.SLOC =  "ERROR.CONTROL":AM:SYS.SLOC
SYS.PROG.TYPE = 8
EQ.PROG.TYPE = 8
EQ.PROG.STATUS = TRUE
ERROR.RSP = ""
*
!
* PROGRAM:           SYS.LOCK.ITEM
* AUTHOR:            David Horsman - AIM Services
* DESCRIPTION:       LOCK AN USER CONTROL RECORD
*
* RETURN VALUE
*             LCK.STAT      MEANING
*                0      SUCCESSFULLY LOCKED
*           YOUR PORT   SUCCESSFULLY LOCKED
*      OTHER PORT #     ALREADY LOCKED AT ANOTHER TERMINAL
*              9998      OPERATOR 'KILL' REQUEST
*              9999      GAVE UP ATTEMPTING TO READ
*
* ENTRY VALUE
*       MOVED TO CONTROL.STAT
*           LCK.STAT         MEANING
*              0        LOCK RECORD, ALLOW ABORT BY USER
*              1        LOCK RECORD, ABORT IF LOCKED
*              2        LOCK RECORD, NO ABORT ALLOWED
*              3-9      UNUSED
*             10        DO NOT LOCK, CHECK TO SEE IF LOCKED
*             20        LOCK RECORD WETHER LOCKED OR NOT
*
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
*
!
*
CONTROL.STAT = LCK.STAT
LCK.STAT = 0
IF CONTROL.STAT = 9999 THEN CONTROL.STAT = 0
IF FUNCTION = "LOGON" & SUB.FUNCTION = "READ" & STRUCT(2) = "" THEN
MENU.NAME = ""
MENU.CONTROL<1,9> = 1
MENU.APPL = ""
MENU.SUB.APPL = ""
MENU.GRP.APPL = ""
PRMPTING = ""
TOPIC.KEY = ""
*
*SYS.FILE = "ACC"
*OPEN "ACC" TO AC.FILE ELSE
*LCK.STAT = 9999
*ERROR.TEXT = "No ACC file"
*ERROR.CODE = 11111
*GOSUB ERROR.CONTROL
*END
*
!
*
IF USER.NAME = "" THEN
CALL.ID = "MENU.":PORT
READV USER.NAME FROM SY.FILE,CALL.ID,2 ELSE
USER.NAME = ""
LCK.STAT = 9999
END
IF USER.NAME[1,1] = "/" ! USER.NAME[1,7] = "CALL-PL" THEN
DELETE SY.FILE,CALL.ID
USER.NAME = ""
LCK.STAT = 9999
END
END
*
MAT STRUCT = ""
END
*
!
*
IF LCK.STAT # 9999 THEN
READ.IT: * ATTEMPT TO READ THE LOCK ITEM
MSG = ""
SYS.FILE = "SYS"
LOCK.ITEM.ID = "@LOCK@":SYS.FILE:"*":SYS.ITEM
TRY = 0
*
!
*
LOOP
TRY = TRY + 1
WHILE TRY < 5 AND NOT(USER.ABORT OR SYS.ABORT) AND (TRY < 3 OR CONTROL.STAT < 10) AND LCK.STAT < 9000 AND LCK.STAT NE PORT+1 DO
*
IF TRY > 1 THEN
FOR WAIT.CN = 1 TO WAIT.FLAG+1 WHILE CONTROL.STAT < 10 AND NOT(SYSTEM(11))
IF PORTD<5> # "D" AND NOT(SYSTEM(11)) THEN PRINT ".":
RQM
NEXT WAIT.CN
END
*
IF MSG # "" THEN
IF PORTD<5> # "D" AND NOT(SYSTEM(11)) THEN PRINT @(0,22):MSG:
IF CONTROL.STAT = 20 THEN PRINT BELL:; GOSUB LCK.IT; GOTO End.of.prog
IF PORTD<5> # "D" AND NOT(SYSTEM(11)) THEN PRINT " - ":TRY-1:
END ELSE
IF PORTD<5> # "D" AND NOT(SYSTEM(11)) THEN PRINT @(0,22):CLL:
END
*
*
IF PORTD<5> = "D" AND SYSTEM(11) THEN
*PRINT BELL:
PRINT BELL:".... Enter your command: ":
INPUTCLEAR
INPUT TEMP:
CALL DATASENSE.UPPER.CASE(TEMP)
IF INDEX(TCL.RSP,"*":TEMP:"*",1) THEN CHAIN "OFF"
IF INDEX(END.RSP,"*":TEMP:"*",1) THEN USER.ABORT = 1
IF INDEX(TCL.RSP,"*":TEMP:"*",1) THEN USER.ABORT = 1
END
*
!
*
COUNTER = 0
LOOP
COUNTER = COUNTER + 1
PRINT "_":
WHILE COUNTER < 4 AND NOT(USER.ABORT OR SYS.ABORT) AND LCK.STAT NE PORT+1 DO
READ LOCK.ITEM FROM SY.FILE,LOCK.ITEM.ID THEN
IF LOCK.ITEM<1> = PORT+1 OR LOCK.ITEM<1> = '' THEN
MSG = "SYS ":LOCK.ITEM.ID:" is already record locked by you."
IF CONTROL.STAT < 10 OR CONTROL.STAT = 20 THEN
GOSUB LCK.IT
*#GOTO End.of.prog
LCK.STAT = PORT+1
END ELSE IF CONTROL.STAT = 10 THEN
SYS.ABORT = TRUE
END
*
END ELSE
MSG = "SYS ":LOCK.ITEM.ID:" is locked by PORT ":LOCK.ITEM<1>-1:"."
ERROR.TEXT = MSG
ERROR.CODE = 17000
GOSUB ERROR.CONTROL
*#
TEMP = ((DATE()-LOCK.ITEM<3>)*86400)+(TIME()-LOCK.ITEM<4>)-3600
*# ON HOUR TIME LIMIT ON LOCKS!
IF TEMP GT 0 THEN
TEMP1 = INT(TEMP/86400)
TEMP = TEMP-(INT(TEMP/86400)*86400)
TEMP2 = OCONV(TEMP,"MT")
ERROR.TEXT = "lock was expired by "
IF TEMP1 THEN ERROR.TEXT = ERROR.TEXT:TEMP1:" days, "
ERROR.TEXT = ERROR.TEXT:FIELD(TEMP2,":",1):" hours, ":FIELD(TEMP2,":",2):" minutes."
ERROR.CODE = 17101
GOSUB ERROR.CONTROL
GOSUB LCK.IT
END; *# OF TEMP GT 0 LOCK EXPIREY
*#
LCK.STAT = LOCK.ITEM<1>
END
*
* FOR READ v
END ELSE
LOCK.ITEM = ""
MSG = "SYS ":LOCK.ITEM.ID:" is available."
IF CONTROL.STAT = 10 THEN
SYS.ABORT = TRUE
END ELSE IF CONTROL.STAT < 10 OR CONTROL.STAT = 20 THEN
GOSUB LCK.IT
*#GOTO End.of.prog
LCK.STAT = PORT+1
END
END
* FOR READ ^^
*IF PORTD<5> # "D" AND NOT(SYSTEM(11)) THEN 
*PRINT @(0,22):CLL:MSG:
*END
IF CONTROL.STAT < 10 AND LOCK.ITEM<1> = PORT+1 THEN GOSUB LCK.IT; GOTO End.of.prog
IF PORTD<5> # "D" AND NOT(SYSTEM(11)) THEN 
IF CONTROL.STAT < 10 THEN PRINT "^":
END
*
IF NOT(USER.ABORT OR SYS.ABORT) AND LCK.STAT NE PORT+1 THEN
FOR WAIT.CN = 1 TO WAIT.FLAG + 1
IF CONTROL.STAT < 10 THEN
IF PORTD<5> # "D" AND NOT(SYSTEM(11)) THEN PRINT ".":
END
IF NOT(SYSTEM(11)) THEN RQM
NEXT WAIT.CN
END
*
*
REPEAT
*#NEXT COUNTER
!
*
*
PRINT @(0,22):CLL:MSG:
*
IF MSG = "" THEN
PORT.NUM = LOCK.ITEM<1>
IF NUM(PORT.NUM) THEN PORT.NUM = PORT.NUM - 1
ACCT.NUM = LOCK.ITEM<2>
LCK.DATE = OCONV(LOCK.ITEM<3>,"D2"); LCK.DATE = LCK.DATE[1,2]:LCK.DATE[4,3]:LCK.DATE[8,2]
LCK.TIME = OCONV(LOCK.ITEM<4>,"MT")
MSG = "SYS ":LOCK.ITEM.ID:" by ":ACCT.NUM:" (":PORT.NUM:" ":LCK.DATE:" ":LCK.TIME:")"
CONTROL.STAT = PORT.NUM
END
*
IF CONTROL.STAT THEN USER.ABORT = 1
REPEAT ; *#
*
IF LCK.STAT = PORT+1 THEN RETURN
IF CONTROL.STAT = 2 AND NOT(SYSTEM(11)) THEN PRINT @(0,22):CLL:; GOTO READ.IT
*IF CONTROL.STAT = 0 THEN
IF CONTROL.STAT EQ 0 OR (CONTROL.STAT EQ 2 AND SYSTEM(11)) THEN
PRINT BELL:@(0,22):CLS:MSG:@(0,23):"Would you like to try again (<cr>=Y, N or 20? ":
INPUTCLEAR
INPUT RSP:
CALL DATASENSE.UPPER.CASE(RSP)
TEMP = ''
*; IF RSP = "KILL" THEN LCK.STAT = 9998; GOTO End.of.prog
IF INDEX(OFF.RSP,"*":RSP:"*",1) THEN CHAIN "OFF"
IF INDEX(END.RSP,"*":TEMP:"*",1) THEN USER.ABORT = 1
IF INDEX(TCL.RSP,"*":TEMP:"*",1) THEN USER.ABORT = 1
IF USER.ABORT THEN
LCK.STAT = 9998
GOTO End.of.prog
END
IF NUM(RSP) THEN
*#CONTROL.STAT = RSP
IF (RSP > 0 AND RSP < 3) OR RSP = 10 OR RSP = 20 THEN
CONTROL.STAT = RSP
IF CONTROL.STAT EQ 20 THEN LCK.STAT = PORT+1
GOSUB LCK.IT
END
RSP = "Y"
END
IF NOT(INDEX(NO.RSP,"*":RSP:"*",1)) THEN PRINT @(0,22):CLL:; GOTO READ.IT
END
*
END
*
End.of.prog: * Return to calling program
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
RETURN
!
LCK.IT: * LOCK THE ITEM
IF MSG # "" THEN PRINT @(0,22):CLL:
LOCK.ITEM    = PORT+1
LOCK.ITEM<2> = ACCT
LOCK.ITEM<3> = DATE()
LOCK.ITEM<4> = TIME()
LOCK.ITEM<5> = CONTROL.STAT
LOCK.ITEM<6> = STRUCT(2)
WRITE LOCK.ITEM ON SY.FILE,LOCK.ITEM.ID
CONTROL.STAT = PORT+1
*MSG = "SYS ":LOCK.ITEM.ID:" is now locked."
*PRINT @(0,22):CLL:MSG:
RETURN
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*
END
~SYS.MONITOR~
*PROGRAM: SYS.MONITOR
*
* AUTHOR: DAVID HORSMAN
*
*#
$INCLUDE IBP STANDARD.FUNCTIONS
OLD.STAT = ""; *# OLD STATUS PARSE
NEW.STAT = ""; *# NEW STATUS PARSE
OLD.MAXL = 20; *# LAST MAX LINE ON SCREEN
MAXL = 20; *# CURR MAXIMUM LINE ON SCREEN
NEW.LOL = 0; *# NEW STARTING POINT ON SCREEN
*#
LOOP
EXEC.LINE = "WHERE"
EXECUTE EXEC.LINE, //OUT. > NEW.STAT
*#
LOOP WHILE NOT(LEN(NEW.STAT<1>)) AND LEN(NEW.STAT) DO NEW.STAT = DELETE(NEW.STAT,1) REPEAT
*#
STAT.MAX = DCOUNT(NEW.STAT,AM)
STACK.PROG = 1
NEW.LOL = 0
*#
FOR STAT.CN = 1 TO STAT.MAX UNTIL SYSTEM(11)
NEW.LINE = NEW.STAT<STAT.CN>
TEMP = NEW.LINE[2,4]
*#
*STAT.PORT =
IF TEMP NE SPACE(3) AND NUM(TEMP) THEN
STAT.PORT = TEMP
STACK.PROG = 1
END ELSE
STACK.PROG = STACK.PROG + 1
END
*#
THIS.FLAG = NEW.LINE[1,1]
PORT.ADDR = NEW.LINE[5,4]
PORT.LOCN = NEW.LINE[10,6]
STACK.CN = 0
STACK = ""
*#
LOOP TEMP1 = NEW.LINE[STACK.CN*7+20,6] WHILE LEN(TEMP1) DO
STACK<1,STACK.PROG,-1> = TEMP1
STACK.CN = STACK.CN + 1
REPEAT
*#
IF NUM(STAT.PORT) AND LEN(STAT.PORT) THEN
LOCATE (STAT.PORT;STAT.INDEX;STAT.LOC;"AL) ELSE
STACK.INDEX = INSERT(STAT.INDEX,STAT.LOC;STAT.PORT)
OLD.STAT = INSERT(OLD.STAT,STAT.LOC;"")
*NEW.LOL = STAT.LOC
END
*#
REPL.LINE = STAT.PORT:AM:STAT.ADDR:AM:STAT.LOCN:AM:STACK
*#
IF OLD.STAT<STAT.LOC> NE REPL.LINE THEN
NEW.LOL = STAT.LOC
OLD.STAT = REPL.LINE
END
*#
END; *# OF NUM STAT.PORT
*#
NEXT STAT.CN
*#
IF NEW.LOL THEN
LN = 7
IF NEW.EOL GT 1 THEN
FOR A = 1 TO NEW.EOL
LN = LN + 1
NEXT A
*#
IF NEW.LOL LT MAX.L THEN
FOR A = NEW.LOL TO MAX.L
LN = LN + 1
PRINT @(0,LN):CLL:OLD.STAT<A,1>:" ":OLD.STAT<A,2>:" ":OLD.STAT<A,3>:" ":OLD.STAT<A,4>
NEXT A
END
*#
IF MAX.L LT OLD.MAX THEN
FOR A = MAX.L TO OLD.MAX
LN = LN + 1
PRINT @(0,LN):CLL
NEXT A
END
*#
*#
WHILE NOT(SYSTEM(11)) DO
*#
EXECUTE "SLEEP 3"
*#
REPEAT
*#
*#
END
~SYS.MSG.SEND~
*PROGRAM: SYS.MSG.SEND
*
* AUTHOR: DAVID HORSMAN
*
* ACTION - LOCKED - YOU RECEIVE, NOT YET READY
*        - 1      - YOU RECEIVE, READY
*        - 0      - YOU INITIATE
*
* FOR YOUR PORT RECORD
* (ATR 1)
*
*2 IS MY LINE
*
*3 IS MY ACCT
*
*4 IS MY USER
*
*5 IS TRANSMITION TYPE
* 1 - FLIP/FLOP DIALOG (using a token)
* 2 - Q: & A:
* 3 - INTERUPT EITHER OF ABOVE (DEMAND TOKEN)
* 4 - TOKEN DEMANDED FROM ME (GIVE THE TOKEN AWAY)
* 5 - MEMO
* 6 - LETTER
* 7 - PHONE CALL
* 8 - PUBILE ANNOUNCEMENTS (P.A.)
* 9 - ?
*
*6 IS TOKEN
* 0 - NOT TAKEN
* 1 - MINE
* 2 - THEIRS
* 3 - DO NOT DISTURB ME (EXCEPT EMERGENCY OR URGENCY)
*
*7 (FOR TOKEN = 3) WHEN I WILL BE AVAILABLE NEXT.
*
*8 Person currently talking to (LINE mv ACCT mv USER)
*
*9 LAST DATE AND TIME THAT I CHECKED FOR A MESSAGE.
*
*10 JOURNAL NUMBER'S OF THE MESSAGES WAITING FOR ME.
*
*11 Person messages are frome (USER)
*
*12  LINE messages are from (LINE)
*
*13 Account message are from (ACCT)
*
*14 Importance of messages (PRIORITY)
*
*15 Type of message (MSG.TYPE)
*
*
*
* START UP SEQUENCE IS
* CHECK MY LOCK, WAIT
* LOCK MY RECORD
* READ MY RECORD
*
* CHECK THEIR LOCK, WAIT
* LOCK THEIR RECORD
* READ THEIR RECORD
*
* DISPLAY MY JOURNALS
* ENTER HIS JOURNALS, UPDATE
* UPDATE MY RECORD
* UPDATE THEIR RECORD
*
* CLEAR MY LOCK
* CLEAR THEIR LOCK
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
DIM MY.RECORD(20), THEIR.RECORD(20), MY.STAT.DESC(10), MSG.DESC(10), PRIORITY.DESC(101)
MAT MY.RECORD = ''
MAT THEIR.RECORD = ''
MAT MY.STAT.DESC = ''
MAT MSG.DESC = ''
MAT PRIORITY.DESC = ''
JR.REC = ''
MY.PRIORITY = 1
WAIT.FLAG = 1
END.OF.PROG = 0
CONTINUE = 1
PRINT @(0,0):CLS:@(10,0):'Message Send/Recieve Function':
OPEN 'LOCKS' TO LCK.FILE ELSE STOP
OPEN 'SYS' TO SY.FILE ELSE PRINT 'No SYS file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
MATREAD MY.STAT.DESC FROM SY.FILE,'@MSG@STATDESC' ELSE MAT MY.STAT.DESC = ''
MATREAD MSG.DESC FROM SY.FILE,'@MSG@DESC' ELSE MAT MSG.DESC = ''
MATREAD PRIORITY.DESC FROM SY.FILE,'@MSG@PRIORITYDESC' ELSE MAT PRIORITY.DESC = ''
READ VALID.FUNCTIONS FROM SY.FILE,'@MSG@VAILD.FUNCTIONS' ELSE VALID.FUNCTIONS = '*D*Q*I*?*M*L*C*A*H*U*P*E*END*'
OPEN 'ACC' TO AC.FILE ELSE PRINT 'No ACC file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
CALL.ID = 'MENU.':PORT
READV USER.NAME FROM AC.FILE,CALL.ID,2 ELSE
USER.NAME = ''
END
Verify.My.User: * INPUT YOU USER NAME AND VALIDATE
READ V.ME FROM SY.FILE,'@MSG@TRACE@':USER.NAME ELSE
PRINT @(0,15):CLS:@(0,16):'Enter your user ID: ':;INPUT USER.NAME:
GOTO Verify.My.User
END
MY.ACCT = ACCT
MY.LINE = PORT
MSG.R.D.S = '?'
*
Prog.start: * Determine if originating or receiving.
STAT = ''
MY.KEY = '@MSG@TRACE@':USER.NAME
WRITEV '1' ON SY.FILE,MY.KEY,1
MSG.JOURNAL.KEY = '@MSG@JOURNAL'
END.OF.PROG = 0
JOURNAL = ''
MESS.LN = ''
MESS.ENT = ''
THEIR.LINE = ''
THEIR.ACCT = ''
THEIR.USER = ''
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
MSG.TYPE = 0
*
*
Main.Loop: * Loop for controlling function and send/recieve
*
*
LOOP
*
* Determine Required Actions.
*
GOSUB My.Record.Lock
*IF LEN(THEIR.USER) = 0 THEN GOSUB Input.Their.User
IF NOT(END.OF.PROG) THEN
GOSUB Input.Action
IF MSG.TYPE = 'E' ! MSG.TYPE = 'END' THEN END.OF.PROG = 1
MSG.TYPE = FIELD(VALID.FUNCTIONS,'*',MY.RECORD(5))
IF MY.RECORD(5) = 3 THEN
GOSUB Wait.For.Token
GOSUB My.Record.Lock
GOSUB Their.Record.Lock
END
IF MY.RECORD(5) = 4 THEN
MSG.TYPE = '?'
GOSUB My.Record.Unlock
GOSUB Their.Record.Unlock
END
IF MY.RECORD(5) < 1 ! MY.RECORD(5) > 10 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'You have no transmission type.':
IF WAIT.FLAG THEN RQM; RQM; RQM
MY.RECORD(5) = 0
MSG.TYPE = ''
END
IF MSG.R.D.S = '' THEN
IF MY.RECORD(6) = 1 ! MY.RECORD(6) = 0 THEN
MSG.R.D.S = 'S'
END ELSE IF MY.RECORD(6) = 2 THEN
MSG.R.D.S = 'R'
END ELSE IF MY.RECORD(6) = 3 THEN
GOSUB You.Are.No.Disturb
END ELSE
PRINT @(0,22):CLL:@(0,23):CLL:BELL:'Your token status is invalid ( ':MY.RECORD(6):' ).':
IF WAIT.FLAG THEN RQM; RQM; RQM
MY.RECORD(6) = 0
MSG.R.D.S = '?'
END
END
*
*IF MY.RECORD(10) # '' THEN MSG.R.D.S = 'D'
*
IF LEN(THEIR.USER) # 0 THEN
IF LEN(MY.RECORD(8)<1,1>) # 0 & MY.RECORD(8)<1,1> # THEIR.LINE THEN
THEIR.LINE = MY.RECORD(8)<1,1>
END
IF LEN(MY.RECORD(8)<1,2>) # 0 & MY.RECORD(8)<1,2> # THEIR.ACCT THEN
THEIR.ACCT = MY.RECORD(8)<1,2>
END
IF LEN(MY.RECORD(8)<1,3>) # 0 & MY.RECORD(8)<1,3> # THEIR.USER THEN
GOSUB Their.Record.Unlock
THEIR.USER = MY.RECORD(8)<1,3>
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
IF MY.RECORD(6) = 1 THEN GOSUB Their.Record.Lock
END
END
GOSUB Screen.Header
IF LEN(THEIR.USER) # 0 THEN
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE MAT THEIR.RECORD = ''
THEIR.RECORD(1) = THEIR.RECORD(1) + 0
THEIR.RECORD(6) = THEIR.RECORD(6) + 0
IF THEIR.RECORD(8) = '' THEN THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
IF THEIR.RECORD(1) # 1 THEN
IF MSG.TYPE = 'D' THEN PRINT BELL:
PRINT @(0,23):CLL:THEIR.USER:' is not in the message send program.':
IF WAIT.FLAG THEN RQM; RQM; RQM
IF MSG.TYPE = 'D' THEN
PRINT @(0,22):CLL:@(0,23):CLL:BELL:USER.NAME:', I changed you message type to a MEMO!!!!':
MSG.TYPE = 'M'
MY.RECORD(5) = 5
MY.RECORD(6) = 1
THEIR.RECORD(5) = 0
THEIR.RECORD(6) = 0
IF THEIR.RECORD(8) = '' THEN THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
END
END
PRINT @(0,23):CLL:THEIR.USER:' is ':MY.STAT.DESC(THEIR.RECORD(6)+1):   
END
PRINT @(55,1):CLL:MSG.DESC(MY.RECORD(5)+1):
*
*
IF (LEN(THEIR.KEY) = 0 ! THEIR.KEY = '@MSG@TRACE@') & MSG.R.D.S # 'D' THEN
GOSUB Input.Their.User
END ELSE
*
*
IF MSG.R.D.S = 'D' THEN
GOSUB Journal.Display
GOSUB My.Journal.Remove
*
END ELSE IF MSG.R.D.S = 'S' THEN
GOSUB My.Record.Lock
IF MY.RECORD(5) = 1 THEN
GOSUB Their.Record.Lock
THEIR.RECORD(5) = MY.RECORD(5)
THEIR.RECORD(6) = 2
THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
END
CONTINUE = 1
LOOP
GOSUB Journal.Enter
WHILE CONTINUE DO
IF CN1 > 1 THEN
GOSUB Journal.Next
GOSUB Journal.Write
GOSUB Their.Journal.Add
END
IF CONTINUE = 2 THEN
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
READ THEIR.REC10 FROM SY.FILE,THEIR.KEY ELSE THEIR.REC10 = ''
IF LEN(THEIR.REC10<10>) # 0 THEN
CN = 0
LOOP CN = CN + 1 WHILE THEIR.RECORD(10)<1,CN> # '' DO
FOR CN.ADD = 10 TO 15
THEIR.REC10<CN.ADD> = THEIR.REC10<CN.ADD>:VM:THEIR.RECORD(CN.ADD)<1,CN>
NEXT CN.ADD
REPEAT
END ELSE
FOR CN.ADD = 10 TO 15
THEIR.REC10<CN.ADD> = THEIR.RECORD(CN.ADD)
NEXT CN.ADD
END
WRITE THEIR.REC10 ON SY.FILE,THEIR.KEY
CONTINUE = 1
GOSUB My.Record.Lock
END
REPEAT
IF MESS.ENT = 'OVER' & MY.RECORD(5) = 1 THEN
MY.RECORD(6) = 2
READ THEIR.REC10 FROM SY.FILE,THEIR.KEY ELSE THEIR.REC10 = ''
THEIR.REC10<5> = MY.RECORD(5)
THEIR.REC10<6> = 1
THEIR.REC10<8> = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MSG.R.D.S = 'R'
IF LEN(THEIR.REC10<10>) # 0 THEN
CN = 0
LOOP CN = CN + 1 WHILE THEIR.REC10<10,CN> # '' DO
FOR CN.ADD = 10 TO 15
THEIR.REC10<CN.ADD> = THEIR.REC10<CN.ADD>:VM:THEIR.RECORD(CN.ADD)<1,CN>
NEXT CN.ADD
REPEAT
END ELSE
FOR CN.ADD = 10 TO 15
THEIR.REC10<CN.ADD> = THEIR.RECORD(CN.ADD)
NEXT CN.ADD
END
WRITE THEIR.REC10 ON SY.FILE,THEIR.KEY
END ELSE IF MESS.ENT = 'END' THEN
MY.RECORD(5) = 0
MY.RECORD(6) = 0
MY.RECORD(9) = DATE():VM:TIME():VM:WHO
MY.RECORD(8) = ''
THEIR.RECORD(5) = 0
THEIR.RECORD(6) = 0
THEIR.RECORD(8) = ''
MSG.R.D.S = '?'
MSG.TYPE = 0
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
END
GOSUB My.Record.Unlock
GOSUB Their.Record.Unlock
*
END ELSE IF MSG.R.D.S = 'R' THEN
GOSUB Wait.For.Token
IF MY.STATUS = 3 THEN MSG.R.D.S = 'D' ELSE MSG.R.D.S = 'S'
*
END ELSE
*
PRINT @(0,23):CLL:BELL:'Huh?':
IF WAIT.FLAG THEN RQM; RQM; RQM
*
END
END
END
WHILE NOT(END.OF.PROG) DO REPEAT
*
MY.RECORD(1) = 0
MY.RECORD(5) = 0
MY.RECORD(6) = 0
MY.RECORD(9) = DATE():VM:TIME():VM:WHO
MY.RECORD(8) = ''
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
GOSUB My.Record.Unlock
*
*
GOTO End.prog
*
!
Input.Their.User: * Input their line, account, and user ID.
GOSUB Their.Record.Unlock
THEIR.KEY = ''
CONT3 = 1
LOOP WHILE CONT3 & NOT(END.OF.PROG) DO
ENT.THEIR.USER = THEIR.USER
PRINT @(0,2):CLL:'Which User are you sending to? ':
INPUT ENT.THEIR.USER:
IF LEN(ENT.THEIR.USER) = 0 THEN ENT.THEIR.USER = THEIR.USER
IF ENT.THEIR.USER # 'END' THEN
THEIR.USER = ENT.THEIR.USER
READ V.ME FROM SY.FILE,'@MSG@TRACE@':THEIR.USER THEN 
ENT.ACCT = THEIR.ACCT
PRINT ', and which Account? ':
INPUT ENT.ACCT:
IF LEN(ENT.ACCT) = 0 THEN ENT.ACCT = THEIR.ACCT
IF ENT.ACCT = 'END' THEN
END.OF.PROG = 1
END
END ELSE
THEIR.USER = ''
THEIR.ACCT = ''
THEIR.LINE = ''
PRINT @(0,22):CLL:@(0,23):CLL:BELL:'User not on file!':
END
END ELSE END.OF.PROG = 1
IF LEN(THEIR.USER) # 0 & NOT(END.OF.PROG) THEN CONT3 = 0 ELSE CONT3 = 1
REPEAT
IF NOT(END.OF.PROG) THEN
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
IF MY.RECORD(6) = 1 THEN GOSUB Their.Record.Lock
MY.RECORD(8) = THEIR.LINE:VM:THEIR.ACCT:VM:THEIR.USER
END
RETURN
**
**
**
!
Lock.A.Record: * LOCK RECORD BEFORE READING
CALL LOCK.ITEM("SYS",LCK.ID,LCK.FILE,STAT)
RETURN
!
Unlock.A.Record: *
CALL UNLOCK.ITEM("SYS",LCK.ID,LCK.FILE)
RETURN
!
Input.Action: * Input action wanted (esp. when token not taken).
Routine = 'Input.Action'
GOSUB Routine.Display
Status.Window: * Routine to display & choose message.
STAT.CN = 0; STAT.NEXT = 0
MSG.HEADING = RVB:'Line Person...... Priority.... Description. MSG.#':RVE
PRINT @(0,7):CLS:MSG.HEADING:
LOOP
STAT.CN = STAT.CN + 1
WHILE MY.RECORD(10)<1,STAT.CN> # '' DO
PRINT @(0,STAT.CN+7):CLL:MY.RECORD(12)<1,STAT.CN> 'R#3':'  ':
PRINT MY.RECORD(11)<1,STAT.CN> 'L#12':' ':
*
STAT.PRIORITY = MY.RECORD(14)<1,STAT.CN>
IF NOT(NUM(STAT.PRIORITY)) THEN STAT.PRIORITY = 6
IF STAT.PRIORITY < 1 ! STAT.PRIORITY > 100 THEN STAT.PRIORITY = 6
PRINT PRIORITY.DESC(STAT.PRIORITY + 1) 'L#12':' ':
*
STAT.MT = MY.RECORD(15)<1,STAT.CN>
IF NOT(NUM(STAT.MT)) THEN STAT.MT = 0
IF LEN(STAT.MT) = 0 THEN STAT.MT = 0
PRINT MSG.DESC(STAT.MT + 1) 'L#12':' ':
*
PRINT MY.RECORD(10)<1,STAT.CN> 'R#5':
IF STAT.PRIORITY < 6 ! STAT.PRIORITY < MY.PRIORITY THEN
IF WAIT.FLAG THEN
PRINT BELL:RVB:' ***':RVE:
RQM; RQM; PRINT BELL:
END
RQM; RQM
STAT.NEXT = MY.RECORD(10)<1,STAT.CN>
END
REPEAT
RSP = ''
IF STAT.NEXT # 0 THEN
RSP = STAT.NEXT
PRINT @(51,STAT.NEXT+7):'* DEFAULT *':
END
CONT1 = 1
MSG.TYPE = 0
LOOP WHILE CONT1 DO
YES.NO = ''
PRINT @(0,20):CLS:@(0,21):'Choose a message # from the above,':
PRINT @(0,22):CLL:'(D)ialogue, (Q)uestions, (I)nteruptions, (L)etter, (M)emo,':
PRINT @(0,23):CLL:@(5):'(H)istory display, (U)ser List, Change (P)ersons, (E)nd or END ':
IF STAT.NEXT = 0 THEN
INPUT YES.NO:
END ELSE
YES.NO = STAT.NEXT
PRINT YES.NO:
END
JOURNAL = ''
IF SYSTEM(11) > 0 THEN INPUTCLEAR
IF YES.NO = 'L' THEN YES.NO = 'M'
MT = INDEX(VALID.FUNCTIONS,'*':YES.NO:'*',1)
IF MT # 0 THEN
MSG.TYPE = YES.NO
IF MSG.TYPE = 'I' THEN
GOSUB Interuptions.Access
END ELSE IF MSG.TYPE = 'P' & MY.RECORD(6) = 0 THEN
GOSUB Input.Their.User
END ELSE IF MSG.TYPE = 'U' THEN
GOSUB User.List
END ELSE IF MSG.TYPE = 'H' THEN
GOSUB History.Access
END ELSE IF MSG.TYPE = '?' THEN
PRINT @(0,22):CLL:@(0,23):CLL:('Sorry ':USER.NAME:', but there are no HELP facilities available.') 'L#75':BELL:
IF WAIT.FLAG THEN RQM; RQM; RQM
RQM
END ELSE
CONT1 = 0
MT = INT(MT/2) + 1
MY.RECORD(5) = MT
MSG.R.D.S = 'S'
END
END ELSE IF NUM(YES.NO) THEN
YES.NO = STR('0',5-LEN(YES.NO)):YES.NO
STAT.CN = 0
CONT1.1 = 1
LOOP
STAT.CN = STAT.CN + 1
WHILE MY.RECORD(10)<1,STAT.CN> # '' & CONT1.1 DO
IF YES.NO = MY.RECORD(10)<1,STAT.CN> THEN
JOURNAL = YES.NO
MY.RECORD(5) = MY.RECORD(15)<1,STAT.CN>
MSG.TYPE = MY.RECORD(15)<1,STAT.CN>
MSG.R.D.S = 'D'
CONT1.1 = 0
CONT1 = 0
END
REPEAT
END ELSE
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', your entry was invalid. Please re-enter . . .':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RQM
END
REPEAT
RETURN
!
User.List: * Subroutine to execute the UL tcl command.
Routine = 'User List Command'
GOSUB Routine.Display
PRINT @(0,7):
EXECUTE "UL"
RSP = ''
PRINT @(0,22):CLS:@(0,23):'Enter <CR> to continue. . .':
INPUT RSP:
GOSUB PEOPLE.LIST
RETURN
!
PEOPLE.LIST: * PEOLPE ON MESSAGE SYSTEM
GOSUB Screen.Header
OUT.RESULT = ''; UL.LIST = ''
EXECUTE 'SSELECT SYS = "@MSG@TRACE@]"', //OUT. > OUT.RESULT, //SELECT. > UL.LIST
CN.TEMP = 0
PRINT @(0,7):CLS:
LOOP CN.TEMP = CN.TEMP + 1 WHILE OUT.RESULT<CN.TEMP> # '' DO
PRINT @(0,CN.TEMP + 7):CLL:OUT.RESULT<CN.TEMP>:
RQM; RQM; RQM
REPEAT
CN = 0; CN.LINE = 99
LOOP
READNEXT USERS.KEY FROM UL.LIST ELSE USERS.KEY = ''
WHILE LEN(USERS.KEY) # 0 DO
CN.LINE = CN.LINE + 1
IF CN.LINE > 20 THEN
IF CN.LINE # 100 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue. . .':
RSP = ''
INPUT RSP:
END
PRINT @(0,6):CLS:'User...... Last.Access....... Current.Status...................':
CN.LINE = 7
END
READ MSG.REC FROM SY.FILE,USERS.KEY ELSE MSG.REC = ''
PRINT @(0,CN.LINE):CLL:MSG.REC<4> 'L#10':' ':
IF LEN(MSG.REC<9>) > 0 THEN
PRINT (OCONV(MSG.REC<9,1>,'D2'):' ':OCONV(MSG.REC<9,2>,'MTS')) 'L#19':
END ELSE PRINT 'Not a user' 'L#19':
IF NOT(NUM(MSG.REC<6>)) THEN MSG.REC<6> = 0
DESC.NUM = MSG.REC<6> + 1
PRINT @(30):MY.STAT.DESC(DESC.NUM):
REPEAT
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue. . .':
RSP = ''
INPUT RSP:
GOSUB Screen.Header
RETURN
!
Interuptions.Access: * Inputs Minimum priorty for interupt,
* do not disturb status and
* date/time to remove from do not disturb status
*
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', can you be interupted? ':
INPUT YES.NO:
IF INDEX(NO,YES.NO,1) # 0 THEN
MY.RECORD(6) = 3
PRINT @(0,22):CLL:@(0,23):CLL:'Until what date? ':
INPUT PRIORITY.DATE:
IF LEN(PRIORITY.DATE) = 0 THEN PRIORITY.DATE = OCONV(DATE(),'D2')
PRIORITY.DATE = ICONV(PRIORITY.DATE,'D2')
IF PRIORITY.DATE < DATE() ! PRIORITY.DATE > DATE() + 1 THEN
PRIORITY.DATE = DATE() + 1
PRINT @(0,23):CLL:"Set to tommorow's date!":
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RQM
END
PRINT @(0,23):CLL:'Until what time? ':
INPUT PRIORITY.TIME:
IF LEN(PRIORITY.TIME) = 0 THEN
IF PRIORITY.DATE = DATE() THEN
PRIORITY.TIME = OCONV(TIME()+3600,'MT')
PRINT @(0,23):CLL:'Set to one hour from now!':
END ELSE
PRIORITY.TIME = OCONV(0,'MT')
PRINT @(0,23):CLL:'Set to the start of that day!':
END
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RQM
END
PRIORITY.TIME = ICONV(PRIORITY.TIME,'MT')
MY.RECORD(7)<1,1> = PRIORITY.DATE
MY.RECORD(7)<1,2> = PRIORITY.TIME
END ELSE IF INDEX(YES,YES.NO,1) # 0 THEN
IF MY.RECORD(6) = 3 THEN
PRINT @(0,23):CLL:'You were in a do not interupt status.':
IF WAIT.FLAG THEN RQM; RQM
RQM
MY.RECORD(6) = 0
MY.RECORD(7) = ''
END
PRINT @(0,23):CLL:'You CAN now be interupted by NORMAL messages.':
IF WAIT.FLAG THEN RQM; RQM; RQM
RQM
END
PRINT @(0,22):CLL:'What priority level must a message NORMALLY have if I am going to':
PRINT @(0,23):CLL:'   immediately interupt you and enter this program (5 - 100)? ':
INPUT NEW.PRIORITY:
IF NOT(NUM(NEW.PRIORITY)) THEN NEW.PRIORITY = MY.PRIORITY
IF LEN(NEW.PRIORITY) # 0 THEN MY.PRIORITY = NEW.PRIORITY
IF MY.PRIORITY < 5 THEN MY.PRIORITY = 5
PRINT @(0,22):CLL:'Your new priority interupt must be,':
PRINT @(0,23):CLL:'(':MY.PRIORITY:') or ':PRIORITY.DESC(MY.PRIORITY):
MY.RECORD(16) = MY.PRIORITY
*
IF WAIT.FLAG THEN RQM; RQM; RQM
RQM
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
RETURN
!
Screen.Header: * Prints Header for screen I/O
PRINT @(0,0):CLS:'Message Send/Recieve Function':
PRINT @(0,2):CLL:@(5):'To User: ':THEIR.USER:
PRINT ', Account: ':THEIR.ACCT:', Port: ':THEIR.LINE:
PRINT @(39,0):CLL:'Message number: ':
PRINT @(49,1):CLL:'Type: ':MSG.DESC(MY.RECORD(5)+1):
RETURN
!
Journal.Display: * Routine to display a message
Routine = 'Journal.Display'
GOSUB Routine.Display
STAT = 0
LCK.ID = '@MSG@':JOURNAL
GOSUB Lock.A.Record
IF STAT THEN
GOSUB Unlock.A.Record
IF STAT # 999 THEN GOTO Journal.Display
END ELSE
READ JR.REC FROM SY.FILE,'@MSG@':JOURNAL THEN
MY.R.LOC = 0
LOOP
MY.R.LOC = MY.R.LOC + 1
WHO.FOR = JR.REC<10,MY.R.LOC>
WHILE WHO.FOR # '' & WHO.FOR # USER.NAME DO REPEAT
IF WHO.FOR = '' THEN
JR.REC<10,MY.R.LOC> = USER.NAME
JR.REC<8,MY.R.LOC> = 'U'
END
JR.REC<9,MY.R.LOC> = MY.ACCT:SVM:JR.REC<9,MY.R.LOC>
JR.REC<11,MY.R.LOC> = PORT:SVM:JR.REC<11,MY.R.LOC>
JR.REC<12,MY.R.LOC> = DATE():SVM:JR.REC<12,MY.R.LOC>
JR.REC<13,MY.R.LOC> = TIME():SVM:JR.REC<13,MY.R.LOC>
JR.REC<14,MY.R.LOC> = 'Y'
*
IF NOT(NUM(JR.REC<7>)) THEN JR.REC<7> = 1
IF JR.REC<7> < 1 THEN JR.REC<7> = 1
PRINT @(0,4):CLL:PRIORITY.DESC(JR.REC<7>):'message from ':JR.REC<3>:', in account ':JR.REC<2>:', from port ':JR.REC<4>:'.':
*
PRINT @(0,7):CLS:
PRINT @(0,22):CLL:@(0,23):'Do you need to know who else received this (Y/N)? ':
INPUT YES.NO,1:
IF YES.NO = 'Y' THEN
CN = 0; CN.LINE = 99
CONT4 = 1
LOOP CN = CN + 1 WHILE CONT4 & JR.REC<10,CN> # '' DO
CN1 = 0; CONT5 = 1
IF CN.LINE < 21 THEN PRINT @(0,CN.LINE):CLL:JR.REC<10,CN> 'L10':' ':
LOOP CN1 = CN1 + 1 WHILE CONT5 & JR.REC<9,CN,CN1> # '' DO
CN.LINE = CN.LINE + 1
IF CN.LINE > 20 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue.':
INPUT YES.NO:
IF YES.NO = 'END' THEN CONT4 = 0 ELSE
PRINT @(0,6):CLS:'User...... Account... Port R/T ..Date... ..Time...':
CN.LINE = 7
PRINT @(0,CN.LINE):CLL:JR.REC<10,CN 'L10':' ':
END
END
IF CONT4 THEN
PRINT @(8):JR.REC<9,CN,CN1> 'L10':'  ':JR.REC<11,CN,CN1> 'L2':
PRINT '  ':(JR.REC<8,CN>:'/':JR.REC<14,CN>) 'L3':' ':OCONV(JR.REC<12,CN,CN1>,'D2') 'L10':
PRINT OCONV(JR.REC<13,CN,CN2>,'MTS') 'L10':
END
REPEAT
REPEAT
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue.':
INPUT YES.NO:
PRINT @(0,7):CLS:
END
CN = 19
CN.LINE = 6
CONT4 = 1
LOOP
CN = CN + 1
WHILE CONT4 & JR.REC<CN> # '' DO
CN.LINE = CN.LINE + 1
IF CN.LINE > 20 THEN
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> to continue display.':
INPUT YES.NO:
IF YES.NO = 'END' THEN CONT4 = 0 ELSE
PRINT @(0,7):CLS:
CN.LINE = 7
END
END
IF CONT4 THEN PRINT @(0,CN.LINE):CLL:@(5):JR.REC<CN>:
REPEAT
WRITE JR.REC ON SY.FILE,'@MSG@':JOURNAL
PRINT @(0,22):CLL:@(0,23):CLL:'Enter <CR> for next message.':
RSP = ''
INPUT RSP:
END ELSE
JR.REC = ''
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', message number ':JOURNAL:' is missing!':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
END
END
LCK.ID = '@MSG@':JOURNAL
GOSUB Unlock.A.Record
RETURN
!
Journal.Enter: * Routine to input a message.
Routine = 'Journal.Enter'
GOSUB Routine.Display
CONT2 = 1
CN1 = 0
MESS.LN = ''
MESS.ENT = ''
PRINT @(55,0):CLL:
LOOP WHILE CONT2 DO
CN1 = CN1 + 1
CTEN = INT((CN1-1)/10) * 10
IF CN1 - 1 - CTEN = 0 THEN
PRINT @(0,7):CLS:
PRINT @(0,22):CLL:'Enter next line, CLEAR above line,':
IF MY.RECORD(5) = 1 THEN PRINT ' OVER,':
PRINT @(0,23):CLL:@(5):'NEXT for next journal, or SEND to send.':
END
MESS.O = 0
ENT.LINE = CN1-CTEN+7
PRINT @(5,ENT.LINE):CLL:
MESS.ENT = ''
INPUT MESS.ENT
MESS.LN<CN1> = MESS.ENT
IF MESS.ENT = 'END' THEN
IF MY.RECORD(5) = 1 THEN MESS.LN<CN1> = 'Over and out.....'; CN1 = CN1 + 1
CONT2 = 0
CONTINUE = 0
END ELSE IF MESS.ENT = 'OVER' & MY.RECORD(5) = 1 THEN
MESS.LN<CN1> = 'Your turn to send......'
CN1 = CN1 + 1
CONTINUE = 0
CONT2 = 0
END ELSE IF MESS.ENT = 'SEND' ! MESS.ENT = 'NEXT' THEN
MESS.LN<CN1> = 'I have more to send, please wait....'
CONT2 = 0
IF MESS.ENT = 'SEND' THEN
IF MY.RECORD(5) = 1 THEN
CONTINUE = 2
CN1 = CN1 + 1
END ELSE
CONTINUE = 0
MESS.LN<CN1> = ''
END
END
END ELSE IF MESS.ENT = 'CLEAR' THEN
IF ENT.LINE # 8 ! CTEN > 0 THEN
CN1 = CN1 - 2
END ELSE CN1 = CN1 - 1
PRINT @(5,ENT.LINE):CLL:
END
REPEAT
RETURN
!
Journal.Write: * Write a journal onto the Message File.
Routine = 'Journal.Write'
GOSUB Routine.Display
JR.REC = MY.RECORD(5):AM:MY.ACCT:AM:USER.NAME:AM:MY.LINE:AM:DATE():AM:TIME():AM:MY.PRIORITY:AM:'N'
JR.REC = JR.REC:AM:THEIR.ACCT:AM:THEIR.USER:AM:THEIR.LINE:AM:0:AM:0:AM:'N':AM:'N':AM:'16':AM:'17':AM:'18':AM:'19'
JR.REC = JR.REC:AM:MESS.LN
WRITE JR.REC ON SY.FILE,'@MSG@':JOURNAL
RETURN
!
Journal.Next: * Get and reserve next available Journal #.
Routine = 'Journal.Next'
GOSUB Routine.Display
LCK.ID = MSG.JOURNAL.KEY
GOSUB Lock.A.Record 
IF STAT THEN
GOSUB Unlock.A.Record
GOTO Journal.Next
END
READV NEXT.JOURNAL FROM SY.FILE,MSG.JOURNAL.KEY,1 ELSE NEXT.JOURNAL = 0
IF NOT(NUM(NEXT.JOURNAL)) THEN NEXT.JOURNAL = 0
NEXT.JOURNAL = NEXT.JOURNAL + 1
NEXT.JOURNAL = STR('0',(5-LEN(NEXT.JOURNAL))):NEXT.JOURNAL
WRITEV NEXT.JOURNAL ON SY.FILE,MSG.JOURNAL.KEY,1
LCK.ID = MSG.JOURNAL.KEY
GOSUB Unlock.A.Record
JOURNAL = NEXT.JOURNAL
PRINT @(55,0):CLL:BELL:JOURNAL:
RETURN
!
My.Journal.Remove: * Remove a Journal from my Stack.
Routine = 'My.Journal.Remove'
GOSUB Routine.Display
FOR CN.DEL = 10 TO 15
MY.RECORD(CN.DEL) = DELETE(MY.RECORD(CN.DEL),1,1)
NEXT CN.DEL
WRITEV MY.RECORD(10) ON SY.FILE,MY.KEY,10
RETURN
!
My.Journal.Add: * Add a journal to my Stack. (Memo to myself).
Routine = 'My.Journal.Add'
GOSUB Routine.Display
MY.RECORD(10) = MY.RECORD(10):JOURNAL:VM
MY.RECORD(11) = MY.RECORD(11):USER.NAME:VM
MY.RECORD(12) = MY.RECORD(12):MY.LINE:VM
MY.RECORD(13) = MY.RECORD(13):MY.ACCT:VM
MY.RECORD(14) = MY.RECORD(14):MY.PRIORITY:VM
MY.RECORD(15) = MY.RECORD(15):MY.RECORD(5):VM
RETURN
!
Their.Journal.Remove: * Delete a Journal from their Stack.
Routine = 'Their.Journal.Remove'
GOSUB Routine.Display
FOR CN.DEL = 10 TO 15
THEIR.RECORD(CN.DEL) = DELETE(THEIR.RECORD(CN.DEL),1,1)
NEXT CN.DEL
RETURN
!
Their.Journal.Add: * Add a Journal to their Stack.
Routine = 'Their.Journal.Add'
GOSUB Routine.Display
THEIR.RECORD(10) = THEIR.RECORD(10):JOURNAL:VM
THEIR.RECORD(11) = THEIR.RECORD(11):USER.NAME:VM
THEIR.RECORD(12) = THEIR.RECORD(12):MY.LINE:VM
THEIR.RECORD(13) = THEIR.RECORD(13):MY.ACCT:VM
THEIR.RECORD(14) = THEIR.RECORD(14):MY.PRIORITY:VM
THEIR.RECORD(15) = THEIR.RECORD(15):MY.RECORD(5):VM
RETURN
!
My.Record.Lock: * Wait for "my token" or "no token" and lock my control
* record.
Routine = 'My.Record.Lock'
GOSUB Routine.Display
LCK.ID = MY.KEY 
GOSUB Lock.A.Record 
MY.STATUS = 0
IF STAT THEN
IF STAT # 999 THEN GOSUB Wait.For.Token
IF MY.STATUS # 5 THEN GOTO My.Record.Lock
END
MATREAD MY.RECORD FROM SY.FILE,MY.KEY ELSE
MAT MY.RECORD = ''
MY.RECORD(6) = 0
MY.RECORD(5) = 0
END
MY.RECORD(2) = PORT
MY.RECORD(3) = ACCT
MY.RECORD(4) = USER.NAME
IF STAT THEN MY.RECORD(6) = 2
MY.RECORD(8)<1,1> = THEIR.LINE
MY.RECORD(8)<1,2> = THEIR.ACCT
MY.RECORD(8)<1,3> = THEIR.USER
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
RETURN
*
!
My.Record.Unlock: * Unlock my record.
Routine = 'My.Record.Unlock'
GOSUB Routine.Display
LCK.ID = MY.KEY
GOSUB Unlock.A.Record
RETURN
!
Their.Record.Lock: * If token is mine then lock their record, or give token
Routine = 'Their.Record.Lock'
GOSUB Routine.Display
LCK.ID = THEIR.KEY
GOSUB Lock.A.Record 
IF STAT THEN
GOSUB Unlock.A.Record
GOTO Their.Record.Lock
END
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE
MAT THEIR.RECORD = ''
THEIR.RECORD(6) = 2
THEIR.RECORD(5) = MY.RECORD(5)
END
RETURN
!
Their.Record.Unlock: * Unlock their record.
Routine = 'Their.Record.Unlock'
GOSUB Routine.Display
LCK.ID = THEIR.KEY
GOSUB Unlock.A.Record
RETURN
!
Wait.For.Token: * Routine to Cycle until token is available.
Routine = 'Wait.For.Token'
GOSUB Routine.Display
MY.STATUS = 0
IF MY.RECORD(5) # 1 THEN
MY.RECORD(6) = 1
THEIR.RECORD(6) = 0
IF THEIR.RECORD(8) = '' THEN THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
GOSUB Their.Record.Unlock
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
GOSUB My.Record.Unlock
END ELSE
MY.RECORD(6) = 2
THEIR.RECORD(6) = 1
THEIR.RECORD(5) = MY.RECORD(5)
THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
GOSUB Their.Record.Unlock
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
GOSUB My.Record.Unlock
MY.STATUS = 2
SYS11.ELP = 10
LOOP WHILE MY.STATUS = 2 DO
PRINT @(0,22):CLS:'You are waiting for ':THEIR.USER:
MATREAD THEIR.RECORD FROM SY.FILE,THEIR.KEY ELSE MAT THEIR.RECORD = ''
THEIR.RECORD(1) = THEIR.RECORD(1) + 0
THEIR.RECORD(6) = THEIR.RECORD(6) + 0
IF THEIR.RECORD(1) # 1 THEN
PRINT @(0,23):CLL:BELL:THEIR.USER:' is not in the message send program.':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
THEIR.RECORD(5) = 0
THEIR.RECORD(6) = 0
IF THEIR.RECORD(8) = '' THEN THEIR.RECORD(8) = MY.LINE:VM:MY.ACCT:VM:USER.NAME
MY.RECORD(5) = 0
MY.RECORD(6) = 0
IF MY.RECORD(8) = '' THEN MY.RECORD(8) = THEIR.LINE:VM:THEIR.ACCT:VM:THEIR.USER
MATWRITE MY.RECORD ON SY.FILE,MY.KEY
MATWRITE THEIR.RECORD ON SY.FILE,THEIR.KEY
END
PRINT @(0,23):CLL:THEIR.USER:' is ':MY.STAT.DESC(THEIR.RECORD(6)+1):   
IF WAIT.FLAG THEN
IF SYS11.ELP > 3 THEN SYS11.ELP = SYS11.ELP - 1
FOR CNTOKEN = 1 TO SYS11.ELP
RQM
NEXT CNTOKEN
END
IF SYSTEM(11) # 0 THEN
SAVE.ACTION = MY.RECORD(5)
GOSUB Input.Action
IF YES.NO = 'E' ! YES.NO = 'END' THEN
MY.RECORD(6) = 0
WRITEV MY.RECORD(6) ON SY.FILE,MY.KEY,6
MY.STATUS = 5
END
MY.RECORD(5) = SAVE.ACTION
END
MY.STATUS = 0
MATREAD MY.RECORD FROM SY.FILE,MY.KEY THEN
MY.RECORD(2) = PORT
MY.RECORD(3) = ACCT
MY.RECORD(4) = USER.NAME
IF MY.RECORD(10) # '' THEN MY.STATUS = 3
IF LEN(MY.RECORD(8)) # 0 THEN
THEIR.LINE = MY.RECORD(8)<1,1>
THEIR.ACCT = MY.RECORD(8)<1,2>
THEIR.USER = MY.RECORD(8)<1,3>
END
THEIR.KEY = '@MSG@TRACE@':THEIR.USER
END ELSE
MAT MY.RECORD = ''
MY.RECORD(6) = 0
END
IF MY.STATUS # 3 & MY.STATUS # 5 THEN MY.STATUS = MY.RECORD(6)
PRINT @(0,22):CLL:@(0,23):CLL:USER.NAME:', you are ':MY.STAT.DESC(MY.STATUS+1):
IF WAIT.FLAG THEN RQM; RQM; RQM
REPEAT
END
PRINT @(0,22):CLS:@(0,23):BELL:USER.NAME:', you are finished waiting.':
IF WAIT.FLAG THEN PRINT BELL:; RQM; RQM; RQM
RETURN
!
History.Access: * Routine to allow access to previous journals.
Routine = 'History.Access'
GOSUB Routine.Display
RETURN
!
You.Are.No.Disturb: * Routine reminds you that you are locked
Routine = 'You.Are.No.Disturb'
GOSUB Routine.Display
RETURN
!
Routine.Display: * Routine to display trace for testing.
PRINT @(0,23):CLL:Routine:
IF WAIT.FLAG THEN RQM; RQM
RETURN
!
End.prog: * End of program
PRINT @(0,0):CLS:
PRINT
PRINT
PRINT 'Thank you. Now ending....'
IF WAIT.FLAG THEN RQM; RQM; RQM
PRINT
PRINT
END
~SYS.PKH~
SUBROUTINE SYS.PKH
*PROGRAM: SYS.PKH
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EXECUTE "*HARMONY"
*
RETURN
*
END
~SYS.PORT.LINK~
SUBROUTINE SYS.PORT.LINK
*SUBROUTINE: SYS.PORT.LINK
*
* AUTHOR: DAVID G. HORSMAN
*
*#    Common Area
$INCLUDE IBP SYS.COMMON
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#    Controlling port
$INCLUDE IBP SYS.INCL.CPORT
*#
DIM MODE.DESC(30)
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.LIST.RSP
$INCLUDE IBP SYS.INCL.BATCH.RSP
$INCLUDE IBP SYS.INCL.MAIN.RSP
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
*#
*#    System Location Area
SYS.PROG = "SYS.PORT.LINK":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
*#
*#    Initialization Area
*#
*#       Variables.
SYS.SLOC<1> = "FILES"
OLD.CALL.FUNCTION = "LOGGED"
PORT.OUTPUT.REC = ""
PORT.INPUT.REC = ""
PORT.OUTPUT.FLAG = F
PORT.INPUT.TLAG = F
DISP.PRESTORE = ""
SYS.PROG.DESC = "Macroscope PORT.LINK / Stack Manager"
SYS.LIST = ''
PORT.INPUT.CN = 0
SYS.RECORD = ''
SYS.PRINT = ''
OUT.TO.PRINT = 0; SCR.HEADING = ""
P.ENT = ""
P.DEST = 0
LOOP
LCK.STAT = 1
SYS.FILE = "SYS"; SYS.ITEM = "@PORT@STACK@CNTR@":PORT
CALL SYS.LOCK.ITEM
WHILE LCK.STAT NE PORT+1 & LCK.STAT < 9000 DO REPEAT
*#       Record locked failed.
IF LCK.STAT NE PORT+1 THEN
ERROR.TEXT = "The reading of your port stack record was unsuccessful"
ERROR.CODE = 15110
GOSUB ERROR.CONTROL
GOTO End.of.prog
*#
*#          Record lock successful.
END ELSE
*#
*#    Read PORT.INPUT.REC from file
*#
READ PORT.CNTR.REC FROM SY.FILE,SYS.ITEM ELSE PORT.CNTR.REC = ""
PORT.INPUT.CN = DCOUNT(PORT.CNTR.REC,AM)+1
*#
*#    Check if port is in use
*#
IF PORT.LINE.REC<2> NE PORT+1 & TEMP > 0 THEN
ERROR.TEXT = "you are using the PORT.LINK manager on PORT ":STRUCT(119)-1
ERROR.CODE = 19110
GOSUB ERROR.CONTROL
GOTO End.of.prog
END
*#
*#    Update user at PORT.LINK
*#
PORT.CNTR.REC<1> = USER.NAME
PORT.CNTR.REC<2> = PORT+1
PORT.CNTR.REC<3> = DATE()
PORT.CNTR.REC<4> = TIME()
PORT.CNTR.REC<5> = WHO
*#
*# Update record
*#
WRITE PORT.CNTR.REC ON SY.FILE.SYS.ITEM
*#
LCK.STAT = 0
CALL SYS.UNLOCK.ITEM
END
!
ECHO OFF
!
*#
LOOP
*# LOOP FOR PORT.LINK.INIT
PORT.LINK.INIT = FALSE
*#
ERR.CN = 0
LOOP
*# LOOP FOR LINE WAIT
PRINT "WHO"
RQM
IF NOT(SYSTEM(11)) THEN ERR.CN = ERR.CN + 1
*#
WHILE NOT(SYSTEM(11)) AND ERR.CN LT 10 DO
RQM.CN = 3; GOSUB WAIT.RTN
REPEAT
IF ERR.CN GT 10 THEN SYS.ABORT = 6 ELSE
RQM
INPUTCLEAR
RQM
PRINT "WHO"
RSP.WHO = ""
LOOP WHILE SYSTEM(11) DO
INPUT TC,1:
RSP.WHO = RSP.WHO:TC
IF SYSTEM(11) LT 3 THEN RQM
REPEAT
END
*#
S11.BEG.DT = DATE(); S11.BEG.TM = TIME()
S11.ELP = 0; S12.ELP = 0; S13.ELP = 0
*#
LOOP
*# LOOP FOR PORT TURNED ON
PORT.FLAG = TRUE
*#
S11.CN = SYSTEM(11)
*#
IF S11.CN LT 10 THEN
S11.END.DT = DATE(); S11.END.TM = TIME()
LOOP
TEMP = S11.END.DT - S11.BEG.DT
WHILE TEMP DO
S11.END.TM = S11.END.TM + 86400
S11.END.DT = S11.END.DT - 1
REPEAT
S11.ELP = S11.END.TM - S11.BEG.TM
*#
IF S11.ELP GT 900 THEN SYS.ABORT = 7
*#
IF S12.ELP - S11.ELP GT 30 THEN
GOSUB CHECK.PORT
S12.ELP = S11.ELP
END
*#
IF S13.ELP - S11.ELP GT 300 THEN
GOSUB REQUEST.ACK.PORT
S13.ELP = S12.ELP
END
*#
END; *# OF S11.CN LT 10
*#
LOOP WHILE S11.CN GT 10 DO
EOL.FLAG = FALSE
GOSUB LINE.BUILD
IF EOL.FLAG THEN GOSUB LINE.WRITE
*#
REPEAT
*# REPEAT FOR S11.CN GT 10
*#
S11 = SYSTEM(11)
*#
*IF S11 GT 80 THEN
*PRINT CTRL-S CHAR
*TURN ON CTRL-S FLAG
*END ELSE <JL>
IF SYSTEM(11) GT 120 THEN
INPUTCLEAR
*END ELSE IF CTRL-S FLAG ON
*CLEAR CTRL-S FLAG
*PRINT CTRL-Q CHAR
END
*#
IF SYSTEM(11) LT 30 THEN GOSUB CHECK.OUTPUT
*#
WHILE PORT.FLAG DO REPEAT
*#
WHILE PORT.LINK.INIT DO
IF NOT(PORT.LINK.INIT) THEN
YES.NO = ""
ERROR.TEXT = "Enter <CR> to return the menu. . . "
ERROR.CODE = "19002"
GOSUB ERROR.CONTROL
IF INDEX(NO,"*":ERROR.RSP:"*",1) NE 0 THEN
PORT.LINK.INIT = 9; CALL.FUNCTION<1> = ""
END
END
*
REPEAT; * FOR PORT.LINK.INIT
!
*
*IF OLD.CALL.FUNCTION NE "" THEN GOSUB UPDATE.TO.DISK
GOSUB UPDATE.TO.DISK
WAIT.FLAG = SAVE.WAIT.FLAG
*
End.of.prog: * bypass GOTO for abnormal end.
*#
ECHO ON
*#
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*#
RETURN
*#
!
*#
*$INCLUDE IBP SYS.PORT.LINK.PTASK
*
*#
!
CHECK.PORT: *#
*#
*PRINT @(0,23):CLL:BELL:"CHECK PORT!":
PRINT STR(CHAR(8),2):
*RQM; RQM; RQM
RQM
*#
RETURN
!
CHECK.OUTPUT: *#
*#
SYS.ITEM = "@PORT@STACK@INP@":PORT
SYS.FILE = "SYS"
*#
CALL SYS.LOCK.ITEM
*#
IF LCK.STAT NE PORT+1 THEN RETURN
*#
IF NOT(LEN(PORT.OUTPUT.REC)) OR NOT(PORT.OUTPUT.FLAG) THEN
READ PORT.OUTPUT.REC FROM SY.FILE,SYS.ITEM THEN PORT.OUTPUT.FLAG= TRUE ELSE PORT.OUTPUT.FLAG = FALSE
END
*#
IF PORT.OUTPUT.FLAG THEN
*#
LOOP WHILE LEN(PORT.OUTPUT.REC) AND SYSTEM(11) LT 30 DO
*#
TEMP = PORT.OUTPUT.REC<1>
PORT.OUTPUT.REC = DELETE(PORT.OUTPUT.REC,1,0,0)
*#
RQM.CN = 1
GOSUB WAIT.RTN
*#
IN.LINE = TEMP
GOSUB LINE.WRITE
PORT.INPUT.CN = PORT.INPUT.CN + 1
*#
*ECHO OFF
PRINT TEMP
*ECHO ON
*#
REPEAT
*#
IF NOT(LEN(PORT.OUTPUT.REC)) THEN
DELETE SY.FILE,SYS.ITEM
END ELSE
WRITE PORT.OUTPUT.REC ON SY.FILE,SYS.ITEM
END
*#
END; *# OF PORT.OUTPUT.FLAG
*#
CALL SYS.UNLOCK.ITEM
*#
RETURN
!
CLOSE.PORT: *#
*#
PRINT @(0,23):CLL:BELL:"CLOSE PORT!":
RQM; RQM
*#
RETURN
!
LINE.WRITE: *#
*#
SYS.ITEM = "@PORT@STACK@LOG@":PORT
SYS.FILE = "SYS"
*#
LOOP
CALL SYS.LOCK.ITEM
*#
WHILE LCK.STAT NE PORT+1 DO REPEAT
*#
IF NOT(LEN(IN.LINE)) OR NOT(EOL.FLAG) THEN RETURN
*#
READV PORT.INPUT.REC.AM FROM SY.FILE,SYS.ITEM,1 THEN PORT.INPUT.FLAG = TRUE ELSE PORT.INPUT.FLAG = FALSE
IF NOT(PORT.INPUT.FLAG) THEN PORT.INPUT.REC.AM = 1; PORT.INPUT.FLAG = T
*#
IF LEN(IN.LINE) THEN
*#
PORT.INPUT.REC.AM = PORT.INPUT.REC.AM + 1
*#
IF PORT.INPUT.REC.AM GT 100 THEN
EXEC.VERB =  "COPY SYS ":SYS.ITEM:" (O,D)"
EXEC.PARAMS = SYS.ITEM:"@":DATE():"@":TIME()
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS
PORT.INPUT.REC.AM = 2
WRITE PORT.INPUT.REC.AM ON SY.FILE,SYS.ITEM
END
*#
WRITEV PORT.INPUT.REC.AM ON SY.FILE,SYS.ITEM
WRITEV IN.LINE ON SY.FILE,SYS.ITEM,PORT.INPUT.REC.AM
*#
END; *# OF PORT.OUTPUT.FLAG
*#
CALL SYS.UNLOCK.ITEM
*#
EOL.FLAG = FALSE
*#
RETURN
!
*#
LINE.BUILD: *#
*#
LOOP WHILE SYSTEM(11) GT 10 AND NOT(EOL.FLAG) DO
INPUT RSP.UNIT,5:
IF LEN(RSP.UNIT) LT 5 THEN EOL.FLAG = TRUE
REPEAT
*#
PRINT @(0,23):CLL:"LINE BUILD":
RQM; RQM
*#
RETURN
!
REQUEST.ACK.PORT: *#
*#
PRINT @(0,23):CLL:BELL:"HELLO PORT!":
RQM; RQM; RQM
*#
RETURN
!
WAIT.RTN: *#
*#
FOR A = 1 TO RQM.CN
RQM
NEXT A
*#
RETURN
!
UPDATE.TO.DISK: * Subroutine to update SPTM file with Daily records.
IF NOT(LEN(OLD.CALL.FUNCTION)) THEN OLD.CALL.FUNCTION = CALL.FUNCTION<1>
IF OLD.CALL.FUNCTION = "LOGGED" THEN
SYS.ITEM = "@PORT@STACK@":PORT
WRITE P.S ON SY.FILE,SYS.ITEM
WRITE.FLAG = ""
PRINT @(60,23):RVB:"Stack   ":@(70,23):"UPDated ":RVE:
END ELSE IF OLD.CALL.FUNCTION = "PRESTORED" THEN
IF DISP.PRESTORE[1,10] EQ "@LIST@HELP@" THEN
SYS.ITEM = "@PORT@":CO.DATA<3>:"@":DISP.PRESTORE
PORT.INPUT.REC = PORT.INPUT.REC<1>:P.S
WRITE PORT.INPUT.REC ON PS.FILE,SYS.ITEM
END ELSE
SYS.ITEM = "@PORT@":CO.DATA<3>:"@":DISP.PRESTORE
PORT.INPUT.REC = PORT.INPUT.REC<1>:AM:P.S
WRITE PORT.INPUT.REC ON PS.FILE,SYS.ITEM
END
WRITE.FLAG = ""
*ERROR.TEXT = "finished updating files."
*ERROR.CODE = "19010"
*GOSUB ERROR.CONTROL
PRINT @(60,23):RVB:"Prestore":@(70,23):"UPDated ":RVE:
END ELSE
PRINT @(70,23):"SKIpped ":
END
OLD.CALL.FUNCTION = CALL.FUNCTION<1>
OLD.CALL.FUNCTION = "LOGGED"
RETURN
*
SYS.HEADING: *
*
RETURN
$INCLUDE IBP SYS.HEADING
*
RETURN
*
HELP.CONTROL: *
*
RETURN
EXECUTE "COPY SYS @DOC@SYS.PORT.LINK (T)"
PR.DISP = 2
*GOSUB S.DISP
*
RETURN
*
!
*
*$INCLUDE IBP SYS.PORT.LINK.UPD
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*
$INCLUDE IBP SYS.INCL.RECORD.TIME
*
$INCLUDE IBP SYS.INCL.RECORD.USER.CALL
*
END
~SYS.PRINTER.CLOSE~
*PROGRAM: SYS.PRINTER.CLOSE
*
* AUTHOR: DAVID HORSMAN
*
PRINTER OFF
PRINTER CLOSE
*
END
~SYS.RSP~
XSUBROUTINE SYS.RSP
*SUBROUTINE: SYS.RSP
*
* AUTHOR: DAVID G. HORSMAN
*
!
$INCLUDE IBP SYS.COMMON
*# 
$INCLUDE IBP STANDARD.FUNCTIONS
*# 
SYS.PROG = "SYS.RSP":AM:SYS.PROG
SYS.PROG.TYPE = 8
EQ.PROG.TYPE = 8
EQ.PROG.STATUS = 11
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "EQUATES":AM:SYS.SLOC
DIM MODE.DESC(30),STAT.DESC(15)
*# 
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*# 
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
$INCLUDE IBP SYS.INCL.BATCH.RSP
$INCLUDE IBP SYS.INCL.LIST.RSP
$INCLUDE IBP SYS.INCL.MENU.RSP
$INCLUDE IBP SYS.INCL.MENU.RSP.SYNONYM
SYS.SLOC<1> = "OPEN"
*# 
SYS.SLOC<1> = "VALUES"
SYS.ENTRY.DATE = DATE(); SYS.ENTRY.TIME = TIME()
IF PORTD<5> NE "D" THEN PRINT @(0,0):RVB:OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS"):RVE:
*# 
EQ.CN = F; EQ.TOT = F; EQIOW = F; EV = F
ESP = PORT; IF STRUCT(27)<1,PORT+1> EQ 4 THEN ESP = "QUE"
RSP = F; SCK.SCHED = F; SCK.MESSG = F
*#
PRINT @(0,23):RVB:"[=| ":RVE:@(34,23):RVB:" | Get Rsp | ":RVE:@(75):RVB:" |=]":RVE:
$INCLUDE IBP SYS.INCL.142127
GOSUB SLV.PROG
GOSUB SLV.CNTR
GOSUB SLV.TEXT
*#
IF STRUCT(27)<1,PORT+1> LT 11 AND NOT(SYSTEM(11)) THEN RSP = EQ.RSP
*#
EQ.LCK.CN = F; MENU.ERROR = F; EQ.ERROR = F
*# 
*# 
!
LOOP
Input.rsp: *# Return point that resets wait status and time recording.
EQ.ERROR = F
*#
SYS.LOCT<1> = "FUNCTION"
SYS.SLOC<1> = "INIT"
*# 
TEMP.TEXT = F
PRINT @(EQ.CL,EQ.LN):
IF EQ.CLS THEN PRINT CLS:
IF EQ.CLL THEN PRINT CLL:
IF EQ.BEL THEN PRINT BELL:
PRINT EQ.TEXT:
*#
IF NOT(EQ.SLN) THEN
IF EQ.DFLT NE "" THEN
PRINT EQ.DFLT:STR(".",EQ.LENG-LEN(EQ.DFLT)):
EV.ANSW = EV.DFLT
END ELSE PRINT STR(".",EQ.LENG):
END ELSE EQ.CL = EQ.CL+LEN(EQ.TEXT)
*#
IF NOT(SYSTEM(11)) THEN PRINT @(75,EQ.LN):RVB:"<||]":RVE:
PRINT @(EQ.CL+LEN(EQ.TEXT),EQ.LN):
*#
IF STRUCT(27)<1,PORT+1> LT 11 AND NOT(SYSTEM(11)) AND EQ.CN LE EQ.TOT THEN
*# SLAVE MODE
RSP = EQ.RSP
IF LEN(RSP) THEN
IF EQ.LENG THEN PRINT RSP[1,EQ.LENG]: ELSE PRINT RSP: 
END; * OF LEN(RSP)
$INCLUDE IBP SYS.INCL.142127
IF LEN(RSP) THEN
ERROR.TEXT = "Q: ":EQ.TEXT:AM:"A: ":RSP
ERROR.CODE = "09100":AM:"09100"
GOSUB ERROR.CONTROL
END; *# OF LEN(RSP)
END; *# OF SLAVE MODE
*#
*# 
S11PR = F; S11ELP = F; O.S11ELP = F
O.S11ELP1 = F; O.S11ELP2 = F; RSP = F; PRMPTING = F
DISP.ENT = "this terminal is waiting for your response. "
*# 
S11DT=DATE(); S11TM=TIME()
*# 
IF NOT(LEN(RSP)) THEN
IF STRUCT(23)<1,PORT+1> THEN
Input.rsp.save.wait: *# Return point that retains wait status.
LOOP
*# 
S11N.DT=DATE(); S11N.TM=TIME()
IF S11DT NE S11N.DT THEN
S11ELP = (S11N.DT-S11DT-1) * 86400+86400-S11TM+S11N.TM
END ELSE
S11ELP = ABS(S11N.TM-S11TM)
END
*# 
IF USER.UPD(20) AND SYS.PROG<2> EQ "SYS.APEX" THEN
USER.UPD(20) = USER.UPD(20)-T
IF USER.UPD(20) LT 0 THEN USER.UPD(20) = F
END
*#
WHILE NOT(SYSTEM(11)) AND NOT(LEN(RSP)) AND (S11ELP LE EQ.SECS OR NOT(EQ.SECS)) DO
*# 
IF PORTD<5> NE "D" THEN
TEMP = EQ.SECS-S11ELP
TEMP = TEMP+100000000
PRINT @(64,23):RVB:" |e":TEMP "R#7":" | ":@(75):" |=]":RVE:
END
*# 
*# 30 Second repetition
IF S11ELP-30 GT O.S11ELP THEN
*
LOOP O.S11ELP = O.S11ELP + 30 WHILE S11ELP-30 GT O.S11ELP DO REPEAT
*#
$INCLUDE IBP SYS.INCL.142127
*#
IF PORTD<5> NE "D" THEN
PRINT @(0,0):RVB:OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS"):RVE:
PRINT @(0,5):RVB:"|":RVE:("Elapsed time is ":OCONV(S11ELP,"MTS"):" . . . ") "L#48":RVB:"|":RVE:
PRINT @(0,6):RVB:"|":STR("-",48):"|":RVE:
PRINT @(0,22):"[=| ":USER.NAME:", ":DISP.ENT:
*#
IF STRUCT(27)<1,PORT+1> GE 11 THEN
PRINT @(0,23):RVB:"[=| ":RVE:@(54,23):RVB:" | Master  | ":RVE:@(75):RVB:" |=]":RVE:
END ELSE
PRINT @(0,23):RVB:"[=| ":RVE:@(54,23):RVB:" | Slave L | ":RVE:@(75):RVB:" |=]":RVE:
END
RQM
END; *# of <5> NE "D"
*#
IF STRUCT(27)<1,PORT+1> LT 11 AND NOT(SYSTEM(11)) AND NOT(LEN(RSP)) THEN
GOSUB SLV.PROG
GOSUB SLV.CNTR
GOSUB SLV.TEXT
IF EQ.CN LE EQ.TOT THEN RSP = EQ.RSP
END; *# of slave mode rsp load
*#
END; *# of S11ELP time click (30)
*# 
*# Load controlling port number
READV STRUCT(14) FROM SY.FILE,"@SYS@USER@":USER.NAME,14 ELSE STRUCT(14) = F
IF PORTD<5> NE "D" AND NOT(SYSTEM(11)) THEN
PRINT @(44,23):RVB:" | Cport":STRUCT(14)-1 "R#2":" | ":RVE:@(75,EQ.LN):RVB:"<||]":RVE:
END
*#
PRINT @(EQ.CL+LEN(EQ.TEXT),EQ.LN):
IF LEN(RSP) THEN PRINT RSP:
*# 
*# 5 Sec mark
IF S11ELP GT 5 AND NOT(SYSTEM(11)) THEN
RQM
*# 60 second mark
IF S11ELP GT 60 THEN
*# 
RQM
IF USER.MODE LE HI.S.M THEN RSP = "BYE" ELSE
*# 5 min mark
IF S11ELP GT 300 AND NOT(SYSTEM(11)) THEN
IF S11ELP LT 1700 THEN RQM; RQM
*# 5 min mode change init
IF NOT(S11PR) OR S11PR EQ 2 THEN
IF CHECK.TIME THEN CHECK.TIME = 8; GOSUB RECORD.TIME
DISP.ENT = "Were you working? "
S11PR = T
PRMPTING = "WAIT.STATUS"; GOSUB RECORD.LOCATION
*# 
IF PORTD<5> EQ "D" AND S11ELP GT 900 THEN
CALL.FUNCTION = "DIAL.USER ":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = PORT:" HUNG ":OCONV(TIME(),"MTS")
CALL SYS.DIAL.USER
*#
END ELSE
DISP.ENT = "this terminal is in a waiting status."
END; *# OF ELP GT 900
*#
END; *# OF NOT S11.PR OR S11.PR EQ 2
*# 
IF S11ELP-30 GT O.S11ELP2 THEN
O.S11ELP2 = S11ELP
GOSUB CHECK.USER.RESET
IF STRUCT(27)<1,PORT+1> GT 10 THEN GOSUB CHECK.CONTROL
END
*# 
*# 15 min mark (sleep)
IF S11ELP GT 900 AND NOT(SYSTEM(11)) THEN
IF S11ELP LT 1700 THEN FOR A = T TO 10; RQM; NEXT A
*# 
IF EQ.PROG.TYPE EQ T OR EQ.PROG.TYPE EQ 8 THEN
*# 25 min mark
*#  1 hr. logoff
IF S11ELP GT 1500 THEN PRINT @(0,22):CLL:RVB:("[=| Logging off in ":1800-S11ELP:" seconds . . . ") "L#35":RVE:
PRINT @(EQ.CL+LEN(EQ.TEXT),EQ.LN):
*# 20 sec warning bell
IF S11ELP GT 1788 THEN PRINT BELL:
*#  1 hr. shutdown
IF S11ELP GT 1800 THEN RSP = "OFF"
END
*#
END; *# OF ELP GT 900
*# 
END; *# OF HI.S.MODE EXIT
*# 
END; *# OF ELP GT 300
*# 
END; *# OF ELP GT 60
*#
END; *# OF ELP GT 10
*# 
REPEAT
*# 
IF SYSTEM(11) GT 30 THEN PRINT @(54,23):BELL:RVB:" | ClearIO | ":RVE:; INPUTCLEAR; RQM; *#
*# 
IF S11PR AND SYSTEM(11) AND NOT(LEN(RSP)) THEN
*# Timed out or elapsed time GT 60 x 60 (3600 = Thr.)
PRINT @(0,22):CLL:"[=| Welcome back . . . ":
IF S11PR THEN S11PR = 2
ANSW = F
LOOP
PRINT @(0,22):CLL:RVB:"[=| Were you working? " "L#17":
FOR TEMP = T TO 25 UNTIL SYSTEM(11); RQM; NEXT TEMP
IF SYSTEM(11) THEN
S11PR = 2
INPUT YES.NO,1:
RSP = "RED"
END ELSE YES.NO = "N"
*#
IF INDEX(YES,"*":YES.NO:"*",1) NE 0 THEN
ANSW = T
END ELSE IF INDEX(NO,"*":YES.NO:"*",1) NE 0 THEN
PRMPTING = "WAIT.STATUS"
IF CHECK.TIME THEN CHECK.TIME = T; GOSUB RECORD.TIME
ANSW = T
STRUCT(33)<1,PORT+1> = F
END ELSE
IF YES.NO[1,4] EQ "TASK" THEN YES.NO = YES.NO[6,999]
IF YES.NO[1,8] EQ "SYS.TASK" THEN YES.NO = YES.NO[10,999]
TEMP = FIELD(YES.NO," ",1)
TEMP1 = FIELD(YES.NO," ",2)
TEMP2 = FIELD(YES.NO," ",3)
IF NOT(LEN(TEMP2)) AND NOT(LEN(TEMP1)) AND NUM(TEMP) THEN TEMP1 = "1"
IF NOT(LEN(TEMP2)) AND NUM(TEMP) AND NUM(TEMP1) THEN
TEMP = STR("0",5-LEN(TEMP)):TEMP
RSP = "TASK ":TEMP:" ":TEMP1
ANSW = T
END ELSE
ERROR.TEXT = 'your answer must be "Y", "N", or a Task and Step'
ERROR.CODE = "16000"
GOSUB ERROR.CONTROL
INPUTCLEAR
END
*#
END; *# of YES.NO not Y or N
*# 
WHILE NOT(ANSW) DO REPEAT
*#
PRMPTING = F; GOSUB RECORD.LOCATION
S11DT=DATE()
S11TM=TIME()
IF NOT(LEN(RSP)) THEN RSP = "RED"
*#
END; *# OF S11.PR AND SYS11
*#
END; *# OF STRUCT(23)
*#
IF SYSTEM(11) AND NOT(LEN(RSP)) THEN
$INCLUDE IBP SYS.INCL.142127
IF EQ.SLN OR WAIT.FLAG THEN
TEMP = EQ.DFLT
IF EQ.LENG EQ F AND TEMP EQ "" THEN EQ.LENG = 50 ; *#
RSP.CL = EQ.CL+LEN(EQ.TEXT)
CALL SYS.LINE.INPUT(RSP.CL,EQ.LN,EQ.LENG,TEMP,RSP,EQ.UOD,EQ.LOR,EQ.LPS,0)
END ELSE
PRINT @(EQ.CL+LEN(EQ.TEXT),EQ.LN):
IF EQ.LENG EQ F THEN
INPUT RSP:
END ELSE
INPUT RSP,EQ.LENG:
END
END; *# OF EQ.SLN OR WAIT FLAG
*#
END; *# OF SYS 11 AND NO RSP
*# 
IF EQ.UPC THEN
CALL SYS.RSP.CASE.UPPER(RSP)
END
*# 
END; *# OF NOT(LEN(RSP))
*#
IF NOT(SYSTEM(11)) THEN
PRINT @(0,0):RVB:OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS"):RVE:
END
!
IF FIELD(RSP," ",1) EQ "MODE" AND (USER.MODE GE HI.S.M OR STRUCT(6) GE HI.S.M) THEN
SYS.SLOC<1> = RSP
MODE.ENT = FIELD(RSP," ",2)
IF MODE.ENT EQ "PRINT" THEN
IF STRUCT(25)<1,PORT+1> EQ T THEN STRUCT(25)<1,PORT+1> = F ELSE STRUCT(25)<1,PORT+1> = T
USER.UPD(1) = T
END
IF MODE.ENT EQ "NEXT" AND (USER.MODE LT LO.D.M OR STRUCT(6) GE LO.D.M) AND USER.MODE LT 21 THEN
MODE.ENT = USER.MODE+1
END ELSE
IF NUM(MODE.ENT) THEN
IF MODE.ENT GT 0 AND MODE.ENT LT 21 AND NOT(MODE.ENT GT STRUCT(6)) THEN
USER.MODE = MODE.ENT
STRUCT(24)<1,PORT+1> = USER.MODE
USER.UPD(1) = T
END ELSE
ERROR.TEXT = "your mode was not reset"
ERROR.CODE = "15100"
GOSUB ERROR.CONTROL
END
END
END
ERROR.TEXT = "your mode is ":USER.MODE
ERROR.CODE = "18100"
GOSUB ERROR.CONTROL
GOTO Input.rsp
!
END ELSE IF RSP[1,4] EQ "WAIT" THEN
SYS.SLOC<1> = RSP[1,4]
TEMP = FIELD(RSP," ",2)
IF LEN(TEMP) EQ F THEN TEMP = WAIT.FLAG
IF NOT(NUM(TEMP)) THEN TEMP = WAIT.FLAG
IF TEMP LE 0 AND NOT(STRUCT(10)) THEN TEMP = T
IF TEMP LT 7-STRUCT(6) THEN TEMP = 7-STRUCT(6)
IF TEMP LT 0 THEN TEMP = F
IF TEMP GT 10 THEN TEMP = 10
WAIT.FLAG = TEMP
ERROR.TEXT = "you have ":WAIT.FLAG:" waits after each message"
ERROR.CODE = "18100"
GOSUB ERROR.CONTROL
USER.UPD(1) = T
GOTO Input.rsp
!
END ELSE IF INDEX("*POP.STACK*CLEAR.STACK*DISPLAY.STACK*","*":RSP:"*",1) NE 0 THEN
IF FIELD(RSP,".",1) EQ "CLEAR" THEN
MENU.PREV = F
ERROR.TEXT = "your menu stack has been cleared."
END ELSE IF FIELD(RSP,".",1) EQ "POP" THEN
TEMP = MENU.PREV<1,1>
MENU.PREV = DELETE(MENU.PREV,1,1)
ERROR.TEXT = "your menu stack had the first entry (TEMP) removed"
END
ERROR.CODE = "1610021"
GOSUB ERROR.CONTROL
ERROR.TEXT = "your current stack is: ":MENU.PREV
ERROR.CODE = "18100"
GOSUB ERROR.CONTROL
GOTO Input.rsp
!
END ELSE IF FIELD(RSP," ",1) EQ "SCHEDULE" OR FIELD(RSP," ",1) EQ "SPTM" OR FIELD(RSP," ",1) EQ "STEP" THEN
SYS.SLOC<1> = FIELD(RSP," ",1)
IF SYS.SLOC<1> EQ "SCHEDULE" THEN SCH.FLAG = 4 ELSE SCH.FLAG = 11
GOSUB SCHEDULE.CALL
SCH.FLAG = F
!
END ELSE IF INDEX("*COMPLETED*HOLD*IN.PROGRESS*CANCELLED*NOT.STARTED*","*":FIELD(RSP," ",1):"*",1) NE 0 THEN
EQ.ERROR = F
!
END ELSE IF RSP EQ "MESSAGE" THEN
SYS.SLOC<1> = RSP
IF CHECK.TIME THEN CHECK.TIME = T; GOSUB RECORD.TIME
PRMPTING = RSP
GOSUB RECORD.LOCATION
EXECUTE "SYS.MESSAGE"
IF CHECK.TIME THEN CHECK.TIME = T; GOSUB RECORD.TIME
PRMPTING = F
GOSUB RECORD.LOCATION
RSP = MENU.NAME
!
END ELSE IF RSP EQ "TIME" THEN
IF CHECK.TIME THEN CHECK.TIME = 3; GOSUB RECORD.TIME
PRMPTING = F
RSP = MENU.NAME
!
END ELSE IF FIELD(RSP," ",1) EQ "TIME.REPORT" THEN
SYS.SLOC<1> = RSP
IF CHECK.TIME THEN GOSUB RECORD.TIME
PRMPTING = RSP
GOSUB RECORD.LOCATION
CALL.FUNCTION = "TIME.REPORT":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = FIELD(RSP," ",2):AM:CALL.SUB.FUNCTION
CALL SYS.TIME.REPORT
IF CHECK.TIME THEN GOSUB RECORD.TIME
PRMPTING = F
GOSUB RECORD.LOCATION
RSP = MENU.NAME
!
END ELSE IF NOT(LEN(RSP)) THEN
IF NOT(EQ.NUL) THEN EQ.ERROR = T
!
END ELSE IF INDEX("*EDIT TOPIC*EDIT MENU*EDIT APPL*EDIT.MENU*EDIT.APPL*EDIT.TOPIC*MENU*","*":RSP:"*",1) NE 0 THEN
EQ.ERROR = F
!
END ELSE IF RSP[1,5] EQ "SLAVE" THEN
EQ.ERROR = F
RSP = TRIM(RSP[6,999])
TEMP = TRIM(FIELD(RSP,",",1))
IF LEN(TEMP) THEN
RSP = RSP[COL2()+1,999]
LOOP WHILE TEMP[1,1] EQ " " DO TEMP = TEMP[2,999] REPEAT
IF NUM(TEMP) THEN
IF TEMP GE 0 AND TEMP LE 100 THEN
TEMP = STR("0",2-LEN(TEMP)):TEMP; ESP = TEMP[1,2]
END ELSE ESP = "QUE"; *# SLAVE QUE GE 0, LE 100
END ELSE ESP = "QUE"; *# NUM(SLAVE QUE)
END ELSE ESP = "QUE"; *# LEN(TEMP)
IF RSP MATCHES "0N" THEN
RSP = "SLAVE ":RSP
END ELSE
GOSUB SLV.TEXT
EQ.RSP = RSP; RSP = "SERVANT COMMAND SENT"
EQ.SAVE = STRUCT(27)<1,PORT+1>
LOOP WHILE EQ.SAVE LE 10 DO EQ.SAVE = EQ.SAVE+10 REPEAT
IF NUM(ESP) THEN
STRUCT(27)<1,PORT+1> = 23
END ELSE
STRUCT(27)<1,PORT+1> = 24
END
GOSUB SLV.IOW; *#
STRUCT(27)<1,PORT+1> = EQ.SAVE
EQ.ERROR = 2
END
!
END ELSE IF RSP MATCHES '"TASK "0N" "0N' OR RSP MATCHES '"TASK "0N' OR RSP MATCHES '5N1A0N' THEN
IF RSP MATCHES '5N1A0N' THEN RSP = "TASK ":RSP
ERROR.TEXT = "SYS.RSP request for TASK change"
ERROR.CODE = "16100"
GOSUB ERROR.CONTROL
PRMPTING = RSP
CALL SYS.TASK
EQ.ERROR = F
RSP = MENU.NAME
PRMPTING = F
!
END ELSE IF RSP[1,8] EQ "COMPANY "  OR RSP[1,11] EQ "SYS.COMPANY" THEN
ERROR.TEXT = "SYS.RSP request for COMPANY change"
ERROR.CODE = "16100"
GOSUB ERROR.CONTROL
PRMPTING = RSP
CALL.FUNCTION = "COMPANY"
CALL.SUB.FUNCTION = FIELD(RSP," ",2)
CALL SYS.COMPANY
EQ.ERROR = F
RSP = MENU.NAME
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
PRMPTING = F
!
END ELSE IF RSP EQ "RED" OR (RSP[1,1] EQ "/" AND USER.MODE GE LO.D.M AND USER.MODE LE HI.D.M) THEN
EQ.ERROR = F
!
END ELSE IF RSP[1,5] EQ "TOPIC" AND MENU.CONTROL<1,2,1> GT 0 THEN
SYS.SLOC<1> = RSP
CALL.FUNCTION = "MENU":AM:CALL.FUNCTION
CALL.SUB.FUNCTION = F:AM:CALL.SUB.FUNCTION
IF MENU.CONTROL<1,8>[1,1] EQ "P" THEN CALL.SUB.FUNCTION<1> = 2 ELSE CALL.SUB.FUNCTION<1> = T
PRMPTING = RSP
CALL SYS.TOPIC
PRMPTING = F
RSP = MENU.NAME
!
!
END ELSE IF INDEX(OFF.RSP,"*":RSP:"*",1) NE 0 AND USER.MODE GT HI.S.M THEN
RSP = "OFF"
EQ.ERROR = F
!
END ELSE IF INDEX(TCL.RSP,"*":RSP:"*",1) NE 0 AND USER.MODE GE LO.TCL.M THEN
RSP = "EXIT"
EQ.ERROR = F
!
END ELSE IF RSP[1,1] EQ "?" OR INDEX(RSP,"HELP",1) THEN
SYS.SLOC<1> = "SYS.HELP"
PRMPTING = "HELP"
GOSUB RECORD.LOCATION
HELP = RSP; RSP = F
CALL SYS.HELP(HELP,RSP)
PRMPTING = F
GOSUB RECORD.LOCATION
RSP = MENU.NAME
!
END ELSE IF RSP[1,4] EQ "SYS." OR RSP[1,4] EQ "SYS " OR INDEX(SYS.RSP,"*":FIELD(RSP," ",1):"*",1) THEN
IF RSP[1,4] EQ "SYS." THEN RSP = RSP[5,999]
IF RSP[1,4] EQ "SYS " THEN RSP = RSP[5,999]
RSP.SYN  = FIELD(RSP," ",1)
TEMP1 = COL2()
RSP.PARAM = RSP[TEMP1,999]
TEMP = INDEX(SYS.RSP,"*":RSP.SYN:"*",1)
IF TEMP THEN
RSP.LOCT = COUNT(SYS.RSP[1,TEMP],"*")+1
RSP.ROOT = FIELD(SYS.RSP.SYN,"*",RSP.LOCT)
END ELSE
RSP.ROOT = RSP.SYN
END
PRINT @(24,23):RVB:" | ":(RSP.ROOT:"+":RSP.SYN) "L#17":" | ":RVE:
RSP = "SYS.":RSP.ROOT
SYS.SLOC<1> = RSP.ROOT
*:" # ":RSP.LOCT
GOSUB RECORD.LOCATION
PRMPTING = "SYS.":RSP.ROOT
PRINT @(4,23):RVB:" | ":PRMPTING "L#17":" | ":RVE:
FOR A = T TO WAIT.FLAG
RQM
NEXT A
RQM
CALL.FUNCTION = RSP.ROOT:AM:CALL.FUNCTION
CALL.SUB.FUNCTION = RSP.PARAM:AM:CALL.SUB.FUNCTION
MD.OPEN = T
OPEN "MD" TO MD.FILE ELSE MD.OPEN = F
IF MD.OPEN THEN
READ CALL.MD FROM MD.FILE,PRMPTING THEN
CALL.ON.FILE = T
END ELSE
CALL.ON.FILE = F
CALL.MD = F
END
END ELSE CALL.ON.FILE = F
IF CALL.ON.FILE AND CALL.MD<1> EQ "PC" AND CALL.MD<2> EQ "E6" THEN
CALL @PRMPTING
IF SYS.ABORT OR USER.ABORT THEN
PRINT BELL:
SYS.ABORT = F
USER.ABORT = F
END
END ELSE
ERROR.TEXT = "System Function is not installed here!"
ERROR.CODE = "1611016"
GOSUB ERROR.CONTROL
END
IF CHECK.TIME THEN CHECK.TIME = T; GOSUB RECORD.TIME
PRMPTING = F
GOSUB RECORD.LOCATION
RSP = MENU.NAME
!
END ELSE IF RSP EQ "RED" THEN
*# 
!
END ELSE IF RSP[1,1] EQ "/" OR RSP[1,5] EQ "MENU." OR RSP[1,5] EQ "MENU " OR INDEX(MENU.RSP,"*":FIELD(RSP," ",1):"*",1) NE 0 THEN
IF RSP[1,5] EQ "MENU." THEN RSP = RSP[6,999]
IF RSP[1,5] EQ "MENU " THEN RSP = RSP[6,999]
RSP.SYN  = FIELD(RSP," ",1)
TEMP1 = COL2()
RSP.PARAM = RSP[TEMP1,999]
TEMP = INDEX(MENU.RSP,"*":RSP.SYN:"*",1)
RSP.LOCT = COUNT(MENU.RSP[1,TEMP],"*")+1
RSP.ROOT = FIELD(MENU.RSP.SYN,"*",RSP.LOCT)
PRINT @(24,23):RVB:" | ":(RSP.ROOT:"+":RSP.SYN) "L#17":" | ":RVE:
RSP = RSP.ROOT
SYS.SLOC<1> = RSP.ROOT
PRMPTING = RSP.ROOT
PRINT @(4,23):RVB:" | ":PRMPTING "L#17":" | ":RVE:
FOR A = T TO WAIT.FLAG UNTIL SYSTEM(11)
RQM
NEXT A
MENU.OPEN = T
OPEN "MENUS" TO MU.FILE ELSE MENU.OPEN = F
MENU.ON.FILE = F
IF MENU.OPEN THEN
READ TEMP FROM MU.FILE,"@AS@":PRMPTING THEN MENU.ON.FILE = T ELSE MENU.ON.FILE = F
END
IF NOT(MENU.ON.FILE) THEN RSP = MENU.NAME
!
END ELSE
EQ.MTCH.CN = 2
EQ.MTCH.TYPE = EQ.MTCH<1,1,1>[1,2]
IF EQ.MTCH.TYPE EQ "EX" THEN EQ.ERROR = T
EQ.CONT = T
LOOP
EQ.COMPARE = EQ.MTCH<1,1,EQ.MTCH.CN>
IF EQ.COMPARE EQ "" THEN EQ.CONT = F ELSE
IF NOT(RSP MATCH EQ.COMPARE) THEN
GOSUB CHECK.CONTROL
IF EQ.MTCH.TYPE EQ "IN" THEN
EQ.ERROR = T
EQ.CONT = F
ERROR.TEXT = EQ.ERRS<1,1,EQ.ERNO<1,1,EQ.MTCH.CN>>
ERROR.CODE = "19010"
GOSUB ERROR.CONTROL
END
*ALL MUST MATCH
END ELSE IF EQ.MTCH.TYPE EQ "EX" THEN
EQ.ERROR = F
EQ.CONT = F
*ANY SINGLE MATCH
END
EQ.MTCH.CN = EQ.MTCH.CN+1
END
WHILE EQ.CONT DO REPEAT
IF EQ.ERROR AND EQ.MTCH.TYPE EQ "EX" THEN
ERROR.TEXT = EQ.ERRS<1,1,1>
ERROR.CODE = "19010"
GOSUB ERROR.CONTROL
EQ.ERROR = 2
END
END
!
WHILE EQ.ERROR DO
*# 
IF EQ.ERROR NE 2 THEN
MENU.ERROR = MENU.ERROR+1
ERROR.TEXT = "your entry, ":TRIM(RSP[1,30]):", was invalid"
ERROR.CODE = "18000"
IF LEN(RSP) GT 5 THEN ERROR.CODE = "17100"
GOSUB ERROR.CONTROL
END
TEMP = F; TEMP1 = "?RSP 2"
IF MENU.ERROR GT 3 THEN CALL SYS.HELP(TEMP1,TEMP)
RSP = ""
REPEAT
*# 
ESP = PORT; IF STRUCT(27)<1,PORT+1> EQ 4 THEN ESP = "QUE"
$INCLUDE IBP SYS.INCL.RSP.KEY
*#
TEMP = RSP
IF TEMP EQ "" THEN TEMP = "null"
SYS.ES<EQ.CN+1,11> = TEMP
*#
WRITE SYS.ES ON SY.FILE,SYS.ITEM
IF TEMP EQ "null" THEN SYS.ES<EQ.CN+1,11> = RSP
*# 
PRINT @(EQ.CL+LEN(EQ.TEXT),EQ.LN):
PRINT @(75,EQ.LN):RVB:" |=]":RVE:
*#
$INCLUDE IBP SYS.INCL.21.BUSY
*# 
End.of.prog: *# Return to calling program
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
CALL.FUNCTION = DELETE(CALL.FUNCTION,1)
CALL.SUB.FUNCTION = DELETE(CALL.SUB.FUNCTION,1)
*# 
RETURN
!
SLV.PROG: *# Subroutine to extract program parameters
*# 
EQ.AVG.ELP    = SYS.EV<1,1,10>
EQ.APPL       = SYS.EV<1,1,11>
EQ.MENU       = SYS.EV<1,1,12>
EQ.PROG       = SYS.EV<1,1,13>
EQ.PROG.NUM   = SYS.EV<1,1,14>
*# 
EQ.USER       = SYS.EV<1,1,15>
EQ.TRACE      = SYS.EV<1,1,16>
EQ.RQD.DATE   = SYS.EV<1,1,17>
EQ.RQD.TIME   = SYS.EV<1,1,18>
EQ.PRIORITY   = SYS.EV<1,1,19>
*# 
RETURN
!
SLV.TEXT: *# Subroutine to extract question data
*# 
*EV = SYS.EV<EQ.CN+1>
*# 
EQ.CL = EV<1,1>; *# COLUMN
*# 
EQ.LN = EV<1,2>; *# LINE
*# 
EQ.TEXT = EV<1,3>; *# TEXT (QUESTION)
*# 
EQ.IO = EV<1,4>; *# CODES
IF EQ.IO[1,1] EQ "1" THEN EQ.CLL = T ELSE EQ.CLL = F
IF EQ.IO[1,1] EQ "2" THEN EQ.CLS = T ELSE EQ.CLS = F
IF EQ.IO[2,1] EQ "1" THEN EQ.BEL = T ELSE EQ.BEL = F
IF EQ.IO[3,1] EQ "1" THEN EQ.NUL = T ELSE EQ.NUL = F
IF EQ.IO[4,1] EQ "1" THEN EQ.TRC = T ELSE EQ.TRC = F; *# (Trace flag)
IF EQ.IO[5,1] EQ "1" THEN EQ.SLN = T ELSE EQ.SLN = F; *# (Sys.line flag)
IF EQ.SLN THEN
IF EQ.IO[6,1] EQ "1" THEN EQ.UOD = T ELSE EQ.UOD = F
IF EQ.IO[7,1] EQ "1" THEN EQ.LOR = T ELSE EQ.LOR = F
IF EQ.IO[8,1] EQ "1" THEN EQ.LPS = T ELSE EQ.LPS = F
IF EQ.IO[9,1] EQ "1" THEN EQ.UPC = T ELSE EQ.UPC = F
END ELSE EQ.UOD = F; EQ.LOR = F; EQ.LPS = F; EQ.UPC = F
*# 
EQ.LENG = EV<1,5>; *# Length of field, 0 for <CR> required.
*# 
EQ.SECS = EV<1,6>; *# Wait time before exhausted and timed out.
*# 
EQ.MTCH = EV<1,7>; *# Match patterns for validation.
*# 
EQ.ERNO = EV<1,8>; *# If not matched then use this error message.
*# 
EQ.ERRS = EV<1,9>; *# Error messages referenced above.
*# 
*# First sub-value of EQ.MTCH is the matching type,
*#   IN for inclusive (all must match)
*#   EX for exclusive (any match is valid)
*# 
*#   when EX then an error always uses EQ.ERRS<1,1,1>
*# 
EQ.DFLT = EV<1,10>; *# Default value
*#
EQ.RSP = EV<1,11>; *# RSP
*# 
RETURN
*# 
!
SLV.IOW: *# Subroutine to send question data
*# 
IF EQ.RSP EQ "" THEN EQ.RSP = "null"
EV<1,11> = EQ.RSP ; *# Response
*# 
IF NOT(STRUCT(27)<1,PORT+1> LT 11) THEN
EQIOW = T
GOSUB SLV.CNTR
*#
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@USER@":STRUCT(2)
CALL SYS.LOCK.ITEM
*#
IF LCK.STAT EQ PORT+1 THEN
READV TEMP FROM SY.FILE,SYS.ITEM,21 THEN
IF NUM(ESP) THEN
IF TEMP<1,ESP+1> THEN TEMP<1,ESP+1> = 3
END ELSE
FOR A = T TO 20 UNTIL TEMP<1,A> EQ ""
IF TEMP<1,A> THEN TEMP<1,A> = 4
NEXT A
END
STRUCT(21) = TEMP
END ELSE TEMP = F
WRITEV TEMP ON SY.FILE,SYS.ITEM,21
CALL SYS.UNLOCK.ITEM
END; *# OF LCK.STAT = PORT+1
*#
END; *# OF NOT(SLAVE MODE)
EQIOW = F
RETURN
*# 
!
SLV.CNTR: *# Subroutine to read and/or update the question record
*# 
S27 = STRUCT(27)<1,PORT+1>; S27.SAVE = S27; S27 = S27[LEN(S27),1]
IF NOT(EQIOW) THEN
ESP = PORT; IF STRUCT(27)<1,PORT+1> EQ 4 THEN ESP = "QUE"
END
$INCLUDE IBP SYS.INCL.RSP.KEY
*#
EQ.LOCKED = F; EQ.ERROR = F; EQ.ERR.CN = F
*# 
LOOP WHILE (EQ.ERROR OR EQ.LOCKED NE PORT+1 AND EQ.LOCKED LE 9000) AND NOT(SYS.ABORT OR USER.ABORT) DO
*#
EQ.ERROR = F
LCK.STAT = F
EQ.LOCKED = PORT+1
SYS.ES = F
*#
IF STRUCT(27)<1,PORT+1> LT 11 OR EQIOW THEN
LCK.STAT = F
CALL SYS.LOCK.ITEM
EQ.LOCKED = LCK.STAT
END ELSE
EQ.LOCKED = PORT+1
END
*#
IF EQ.LOCKED EQ PORT+1 THEN
*# 
IF (NOT(SYSTEM(11)) AND STRUCT(27)<1,PORT+1> LT 11) OR EQIOW THEN
READ SYS.ES FROM SY.FILE,SYS.ITEM THEN
SYS.ES<1,1,3> = SYS.EV<1,1,3>
SYS.ES<1,1,4> = SYS.EV<1,1,4>
SYS.ES<1,1,10> = SYS.EV<1,1,10>
SYS.ES<1,1,11> = SYS.EV<1,1,11>
SYS.ES<1,1,12> = SYS.EV<1,1,12>
SYS.ES<1,1,13> = SYS.EV<1,1,13>
SYS.ES<1,1,14> = SYS.EV<1,1,14>
END ELSE SYS.ES = SYS.EV
END ELSE SYS.ES = SYS.EV
*#
EQ.CN  = SYS.ES<1,1,1>
EQ.TOT = SYS.ES<1,1,2>
*# 
IF EQIOW THEN
TEMP = STRUCT(27)<1,PORT+1>
LOOP WHILE TEMP LE 10 DO TEMP = TEMP+10 REPEAT
LOOP WHILE TEMP GE 21 DO TEMP = TEMP-10 REPEAT
IF TEMP NE STRUCT(27)<1,PORT+1> THEN
STRUCT(27)<1,PORT+1> = TEMP
EQ.SAVE = TEMP
WRITEV STRUCT(27) ON SY.FILE,"@SYS@USER@":USER.NAME,27
END
IF EV<1,11> NE "" THEN
IF SYS.ES<EQ.TOT+1,11> NE "" THEN EQ.TOT = EQ.TOT + 1
*SYS.ES<EQ.CN+1> = EV
SYS.ES<EQ.TOT+1> = EV
SYS.ES<1,1,2> = EQ.TOT
SYS.ES<1,1,4> = STRUCT(27)<1,PORT+1>
* SYS.ES<1,1,1> = 0
WRITE SYS.ES ON SY.FILE,SYS.ITEM
END ELSE
WRITEV SYS.ES<1> ON SY.FILE,SYS.ITEM,1
END
PRMPTING = EQ.PROG
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
ERROR.TEXT = "the slave command has been sent (":EV<1,11>:") to ":ESP
ERROR.CODE = "19100"
GOSUB ERROR.CONTROL
$INCLUDE IBP SYS.INCL.RSP.KEY
*#
*#END OF EQIOW (SENDING COMMANDS)
END ELSE
*#
IF EQ.PROG NE SYS.ES<1,1,13> THEN
PRINT BELL:
EQ.CN = EQ.TOT
LOOP WHILE S27.SAVE LE 10 DO S27.SAVE = S27.SAVE+10 REPEAT
END
*#
*# Increment Rsp counter
IF NOT(EQ.CN) OR LEN(SYS.ES<EQ.CN+1,11>) OR NOT(LEN(SYS.ES<EQ.CN+1>)) THEN EQ.CN = EQ.CN+1
*#
*# Is this the end of the stack
IF EQ.CN GT EQ.TOT THEN
IF (SYS.ES<1,1,4> EQ F OR STRUCT(27)<1,PORT+1> LT 11) AND NOT(SYSTEM(11)) THEN
RQM
ERROR.TEXT = "this slave is waiting for instructions"
ERROR.CODE = "19000"
GOSUB ERROR.CONTROL
RQM
END; *# OF SLAVE MODE WITH AN ACTIVE BUFFER
EQ.RSP = F
*EQ.ERROR = 2
IF STRUCT(27)<1,PORT+1> LT 11 THEN
IF S27.SAVE LT 11 THEN
READ TEMP FROM SY.FILE,SYS.ITEM:"@C" ELSE TEMP = ""
SYS.ES<-1> = TEMP
WRITE SYS.ES ON SY.FILE,SYS.ITEM:"@C"
DELETE SY.FILE,SYS.ITEM
END; *# OF S27.SAVE
END; *# OF STRUCT(27) SLAVE
SYS.ES = SYS.EV
EQ.CN = SYS.ES<1,1,1>
EQ.TOT = SYS.ES<1,1,2>
IF NOT(NUM(EQ.CN)) THEN EQ.CN = T
IF EQ.CN LT 1 THEN EQ.CN = T
IF NOT(NUM(EQ.TOT)) THEN EQ.TOT = T
IF EQ.TOT LT 1 THEN EQ.TOT = T
LOOP WHILE EQ.CN GT EQ.TOT AND EQ.TOT GT 0 DO EQ.CN = EQ.CN - 1 REPEAT
*#
END; *# OF EQ.CN NOT GT EQ.TOT
*#
EV = SYS.ES<EQ.CN+1>
*#
SYS.ES<1,1,1> = EQ.CN
SYS.ES<1,1,2> = EQ.TOT
*#
IF EQIOW OR EV<1,11> NE "" THEN
WRITE SYS.ES ON SY.FILE,SYS.ITEM
END ELSE
WRITEV SYS.ES<1> ON SY.FILE,SYS.ITEM,1
END
EQ.ERROR = F
*#
*#
END; *# OF NOT EQIOW (SENDING COMMANDS)
*#
*SYS.EV<1> = SYS.ES<1>
*# 
EQ.PROG.STATUS = STRUCT(27)<1,PORT+1>
EQ.START.DATE  = SYS.ES<1,1,5>
EQ.START.TIME  = SYS.ES<1,1,6>
EQ.EST.ELP     = SYS.ES<1,1,7>
EQ.ELP         = SYS.ES<1,1,8>
EQ.COMPL.ELP   = SYS.ES<1,1,9>
*# 
IF STRUCT(27)<1,PORT+1> LT 11 OR EQIOW THEN
LCK.STAT = F
CALL SYS.UNLOCK.ITEM
EQ.UNLOCKED = LCK.STAT
IF EQ.UNLOCKED EQ F THEN EQ.LOCKED = 9999
END
*#
END ELSE
ERROR.TEXT = "This slave is waiting for the control record"
ERROR.CODE = "19100"
GOSUB ERROR.CONTROL
EQ.ERROR = T
END; *# OF REC LOCKED OR NOT LOCKED
*#
IF STRUCT(27)<1,PORT+1> LT 11 OR EQ.LOCKED NE PORT+1 OR SYSTEM(11) THEN GOSUB CHECK.USER.RESET
*# 
IF EQ.ERROR OR EQ.LOCKED NE PORT+1 OR LEN(SYS.ES<1,1>) EQ F THEN
EQ.ERR.CN = EQ.ERR.CN+1
IF EQ.ERR.CN GT 10 THEN EQ.ERR.CN = 10
FOR TEMP1 = T TO EQ.ERR.CN
RQM
NEXT TEMP1
END
*# 
REPEAT
*# 
RETURN
*#
!
CHECK.CONTROL: *# Subroutine to monitor user system functions.
*# 
IF CHECK.TIME AND INDEX(SYS.PROG,"SYS.TIME",1) EQ F THEN
CN = F
LOOP CN = CN+1 WHILE SYS.PROG<CN> NE "" DO
IF INDEX(SYS.RSP,"*":SYS.PROG<CN>[4,99]:"*",1) AND SYS.PROG<CN> NE "SYS.APEX" AND SYS.PROG<CN> NE "SYS.RSP" THEN RETURN
REPEAT
*# 
SYS.FILE = "SYS"
*# 
LOOP
RELOOP = F
IF SCK.MESSG NE 0 THEN
TEMP.LAST = SCK.MESSG; TEMP.NELP = "S":VM:STRUCT(48)
GOSUB CHECK.ELP
CHECK.MESSG = TEMP.CK
END ELSE CHECK.MESSG = T
*# 
IF SCK.SCHED NE 0 THEN
TEMP.LAST = SCK.SCHED; TEMP.NELP = "S":VM:STRUCT(48)
GOSUB CHECK.ELP
CHECK.SCHED = TEMP.CK
END ELSE CHECK.SCHED = T
*# 
IF CHECK.SCHED NE 0 THEN
SYS.ITEM = "@SYS@USER@":STRUCT(2); SYS.FILE = "SYS"
READV CK.SCH FROM SY.FILE,SYS.ITEM,70 ELSE CK.SCH = F; SYS.ABORT = T
IF CK.SCH AND CK.SCH NE PORT+1 THEN
ERROR.TEXT = "your SCHEDULE is in use at port ":CK.SCH-1
ERROR.CODE = "17100"
GOSUB ERROR.CONTROL
SCK.SCHED = (100000+DATE())[2,5]:(100000+TIME())[2,5]
END ELSE
IF NOT(SCH.FLAG) THEN
TEMP.LAST = STRUCT(65)
TEMP.NELP = STRUCT(63)
GOSUB CHECK.ELP
IF TEMP.CK EQ F THEN SCH.FLAG = 2 ELSE 
TEMP.LAST = STRUCT(68)
TEMP.NELP = STRUCT(66)
GOSUB CHECK.ELP
IF TEMP.CK EQ F THEN SCH.FLAG = 3 ELSE
TEMP.LAST = STRUCT(71)
TEMP.NELP = STRUCT(72)
GOSUB CHECK.ELP
IF TEMP.CK EQ F THEN SCH.FLAG = 4
END
END
END
*# 
IF SCH.FLAG AND NOT(STRUCT(14) NE PORT+1 OR (SCH.FLAG LE 1 OR SCH.FLAG GT 4)) THEN
SCHED.TEMP = FIELD("POOP*LOAD*PURGE*VEIWING*TASK*","*",SCH.FLAG)
ERROR.RSP = F
FOR A = T TO 10 UNTIL SYSTEM(11); RQM; NEXT A
ERROR.TEXT = "your schedule needs a ":SCHED.TEMP
ERROR.TEXT = ERROR.TEXT:AM:"your regular activities are being interupted"
ERROR.CODE = "17111":AM:"17111"
IF SCHED.TEMP EQ "VEIWING" THEN SCHED.TEMP = "DAILY"; ERROR.CODE = "17100"
GOSUB ERROR.CONTROL
IF NOT(INDEX(NO,"*":ERROR.RSP:"*",1)) THEN
RSP = "SCHEDULE ":SCHED.TEMP
GOSUB SCHEDULE.CALL
PRMPTING = F
RSP = MENU.NAME
END
SCK.SCHED = (100000+DATE())[2,5]:(100000+TIME())[2,5]
SCH.FLAG = F
RELOOP = T
END
END
END
!
IF NOT(RELOOP) THEN
IF CHECK.MESSG NE 0 THEN
SYS.ITEM = "@SYS@USER@":STRUCT(2); SYS.FILE = "SYS"
READV CK.MSG FROM SY.FILE,SYS.ITEM,91 ELSE CK.MSG = F; SYS.ABORT = T
**IF CK.MSG AND CK.MSG NE PORT+1 THEN
**ERROR.TEXT = "your MESSAGE is in use at port ":CK.MSG - 1
**ERROR.CODE = "17100"
**GOSUB ERROR.CONTROL
**SCK.MESSG = (100000+DATE())[2,5]:(100000+TIME())[2,5]
**END ELSE
TEMP.PRIOR = 100
TEMP.USER = F
TEMP.LOCN = F
FOR TEMP = T TO 20 UNTIL STRUCT(86)<1,TEMP> = F
IF STRUCT(87)<1,TEMP> LT TEMP.PRIOR THEN
TEMP.PRIOR = STRUCT(87)<1,TEMP>
TEMP.USER = STRUCT(88)<1,TEMP>
TEMP.LOCN = TEMP
END
NEXT TEMP
IF TEMP.PRIOR NE 100 THEN
ERROR.TEXT = "there is a priority ":TEMP.PRIOR:" message from ":TEMP.USER
ERROR.CODE = "17110"
GOSUB ERROR.CONTROL
IF TEMP.PRIOR LE STRUCT(84) THEN
ERROR.TEXT = "you will have to view it immediately"
ERROR.CODE = "17111"
GOSUB ERROR.CONTROL
MSG.FLAG = T
END ELSE
IF STRUCT(83) NE 0 THEN
TEMP.MSG = (100000+DATE())[2,5]:(100000+TIME())[2,5]
IF STRUCT(83) LE TEMP.MSG THEN
ERROR.TEXT = "you are now available to accept mail"
ERROR.CODE = "17101"
GOSUB ERROR.CONTROL
STRUCT(83) = F
END ELSE
ERROR.TEXT = "you are not taking mail until ":OCONV(STRUCT(83)[6,5],"MT"):" on ":OCONV(STRUCT(83)[1,5],"D2")
ERROR.CODE = "17100"
GOSUB ERROR.CONTROL
END
END
IF STRUCT(83) EQ F THEN
TEMP = WAIT.FLAG
IF TEMP LT 5 THEN TEMP = TEMP+1
IF USER.MODE LT LO.D.M THEN TEMP = 5
TEMP1 = TEMP
LOOP
PRINT @(0,22):CLL:RVB:"[=| ":"Do you want to see this message? " "L#40":RVE:
IF SYSTEM(11) OR STRUCT(14) EQ PORT+1 THEN
INPUT YES.NO,1:
END ELSE
YES.NO = "."
TEMP1 = TEMP1 + 1
EXECUTE "SLEEP ":TEMP1
IF TEMP1 GT 10 THEN YES.NO = "N"
END
IF INDEX(YES,"*":YES.NO:"*",1) NE 0 THEN MSG.FLAG = T
WHILE NOT(INDEX(NO,"*":YES.NO:"*",1)) AND NOT(MSG.FLAG) DO YES.NO = F REPEAT
END
END
*# 
IF MSG.FLAG AND STRUCT(14) EQ PORT+1 THEN
IF CHECK.TIME THEN CHECK.TIME = T; GOSUB RECORD.TIME
USER.UPD(2) = T
PRMPTING = "MESSAGE"
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
EXECUTE "SYS.MESSAGE"
IF CHECK.TIME THEN CHECK.TIME = T; GOSUB RECORD.TIME
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNTION = "RESET"
GOSUB RECORD.USER.CALL
RSP = MENU.NAME
*#RSP = F
MSG.FLAG = F
PRMPTING = F
GOSUB RECORD.LOCATION
END; *# OF MSG FLAG
END; *# OF PRIOR NE 100
**END; *# OF MSG NOT IN USE
END; *# OF CHECK MSG
*# 
IF CO.DATA<2,1,1> NE DATE() THEN
IF NOT(DATE() EQ CO.DATA<2,1,1>+1 AND TIME() LT 10000) THEN
CALL SYS.CONTROL.DATE
RSP = MENU.NAME
*#RSP = F
END
END
END; *# OF RELOOP
*# 
WHILE RELOOP DO REPEAT
END; *# OF CHECK.TIME AND NOT 'SYS.TIME'
*# 
RETURN
!
CHECK.ELP: *# Last date checked, # of elp units/type, ck flag.
*# 
IF INDEX(SYS.PROG,"SYS.TIME",1) EQ F THEN
TEMP.CK = F
CALL SCK.ELP(TEMP.LAST,TEMP.NELP,TEMP.CK)
TEMP.CK = TEMP.CK<1>
END ELSE TEMP.CK = F
*# 
RETURN
!
SCHEDULE.CALL: *# subroutine to call daily schedule
SYS.SLOC<1> = RSP
LOOP
LCK.STAT = F
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.LOCK.ITEM
WHILE LCK.STAT NE PORT+1 AND LCK.STAT LT 9000 AND NOT(SYS.ABORT OR USER.ABORT) DO REPEAT
*# 
IF LCK.STAT EQ PORT+1 THEN
READV TEMP FROM SY.FILE,SYS.ITEM,70 ELSE TEMP = F
STRUCT(70) = TEMP
LCK.STAT = F
CALL SYS.UNLOCK.ITEM
*# 
IF TEMP NE PORT+1 AND TEMP GT 0 THEN
ERROR.TEXT = "you are using the scheduler on PORT ":STRUCT(70) - 1
ERROR.CODE = "15101"
GOSUB ERROR.CONTROL
IF ERROR.RSP EQ 'SYS FORCE' THEN
TEMP = PORT+1
WRITEV TEMP ON SY.FILE,SYS.ITEM,70
ERROR.TEXT = "Access to Schedule is FORCED!"
ERROR.CODE = "15110"
GOSUB ERROR.CONTROL
END
END
*# 
TEMP.RSP = RSP
IF TEMP EQ PORT+1 OR NOT(TEMP) THEN
TEMP = PORT+1
STRUCT(70) = PORT+1
IF CHECK.TIME THEN CHECK.TIME = 9; GOSUB RECORD.TIME
USER.UPD(2) = T
PRMPTING = SYS.SLOC<1>
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
CALL.FUNCTION<1> = TEMP.RSP
TEMP = FIELD(CALL.FUNCTION<1>," ",1)
CALL.SUB.FUNCTION<1> = FIELD(TEMP.RSP," ",2)
*# 
IF TEMP EQ "SCHEDULE" AND SCH.FLAG AND SCH.FLAG LT 6 THEN
IF LEN(CALL.SUB.FUNCTION<1>) EQ F THEN CALL.SUB.FUNCTION<1> = "DAILY"
IF CALL.SUB.FUNCTION<1> EQ "LOAD" THEN
*CALL SYS.SCHED.LOAD
ERROR.RSP = F
ERROR.TEXT = "Schedule load required . . . "
ERROR.CODE = "19101"
GOSUB ERROR.CONTROL
IF NOT(INDEX(NO.RSP,"*":ERROR.RSP:"*",1)) THEN
CALL SYS.SCHED.LOAD
END ELSE
ERROR.TEXT = "Schedule LOAD cancelled (X)."
ERROR.CODE = "16100"
GOSUB ERROR.CONTROL
END
END ELSE
CALL SYS.SCHEDULE
END
*# 
END ELSE IF TEMP EQ "STEP" THEN
CALL SYS.STEP
*# 
END ELSE
CALL SYS.SPTM.STRUCT
END
*# 
PRMPTING = F
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
PRMPTING = F
END
RSP = MENU.NAME
*#RSP = F
END
RETURN
!
RECORD.USER.CALL: *Subroutine to update user info
*# 
SYS.SLOC<1> = "RECORD.USER.CALL"
IF CALL.FUNCTION<1> NE "LOGON" AND CALL.FUNCTION<1> NE "LOGOFF" AND CALL.FUNCTION<1> NE "MENU" THEN CALL.FUNCTION<1> = "UNKNOWN"
IF CALL.SUB.FUNCTION<1> NE "UPDATE" AND CALL.SUB.FUNCTION<1> NE "READ" THEN
IF CALL.SUB.FUNCTION<1> NE "WRITE" AND CALL.SUB.FUNCTION<1> NE "RESET" THEN RETURN
END
LOOP
SYS.FILE = "SYS"
USER.LOCK = F
IF STRUCT(2) NE "" THEN USER.NAME = STRUCT(2)
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
WHILE (USER.LOCKED AND USER.LOCKED NE PORT+1) AND NOT(SYS.ABORT OR USER.ABORT) DO REPEAT
*# 
RETURN
!
RECORD.LOCATION: *# to record you menu location AND topics
USER.UPD(2) = T
TEMP = (100000+DATE())[2,5]
TEMP = TEMP:(100000+TIME())[2,5]
IF TEMP GT LAST.LOCT+(STRUCT(48) * 5) OR INDEX(SYS.RSP,"*":PRMPTING:"*",1) THEN
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
LAST.LOCT = TEMP
END ELSE
STRUCT(29)<1,PORT+1> = USER.CO.CODE
STRUCT(30)<1,PORT+1> = MENU.APPL:SVM:MENU.SUB.APPL:SVM:MENU.GRP.APPL
STRUCT(31)<1,PORT+1> = MENU.CONTROL<1,7>
STRUCT(32)<1,PORT+1> = MENU.NAME
STRUCT(33)<1,PORT+1> = PRMPTING
STRUCT(34)<1,PORT+1> = TOPIC.KEY
STRUCT(35)<1,PORT+1> = MENU.CONTROL<1,9>
END
RETURN
!
RECORD.TIME: *# to record time usage
*# 
IF CHECK.TIME AND INDEX(SYS.PROG,"SYS.TIME",1) NE 0 THEN RETURN
IF CHECK.TIME LT 3 OR CHECK.TIME GT 7 THEN
IF EQ.PROG.TYPE GT 1 THEN CHECK.TIME = T ELSE CHECK.TIME = 9
END
CALL SYS.TIME
*END
*# 
RETURN
!
CHECK.USER.RESET: *# subroutine to check if a reset is required
*#
$INCLUDE IBP SYS.INCL.142127
$INCLUDE IBP SYS.INCL.21.CHECK
*# PRINT @(34,23):RVB:" | ":"C Reset" "L#7":" | ":RVE:; PRINT BELL:
*#
RETURN
!
$INCLUDE IBP SYS.ERROR.STRUCT
*# 
*# 
END
~SYS.RSP.CASE.UPPER~
SUBROUTINE SYS.RSP.CASE.UPPER(SUBJECT)
*SUBROUTINE: SYS.RSP.CASE.UPPER
*
*CREDIT THE ACCOUNT OF *SUBROUTINE DATASENSE.CASE.UPPER (SUBJECT)
*
*      This program converts lower case text to upper case.
*  It is necessary because Microdatas don't support OCONV(X,'MCU')
*
*
PROGRAM="SYS.RSP.CASE.UPPER"
IF SUBJECT > "" THEN
    RESULT=""
    FOR X=1 TO LEN(SUBJECT)
        A=SUBJECT[X,1]
        IF A >= "a" AND A <= "z" THEN
            A=CHAR(SEQ(A)-32)
        END
        RESULT=RESULT:A
    NEXT X
    SUBJECT=RESULT
END
RETURN; * TO CALLING PROGRAM
*
END
~SYS.SCR.SEL~
SUBROUTINE SYS.SCR.SEL(DP,DL,DCN,DI,DM,DNL,DNC,DLN,DOV,DS,DM,DD,DCF,D.R,RSP,DLG,DAM,DVM,DSM)
*  DP = PAGE NUMBER        DL = CURRENT LINE       DCN = CURRENT MARK
*  DI = PAGE INCREMENT     DM = MAX # OF MARKS     DNL = # OF LINES/PAGE
*  DNC= # OF COL'S/LINE    DOV= KEEP LEN OVERFLOW  DS  = RSP SELECT ON
*  DMD= MODIFICATIONS ON   DD = DISPLAY DEVICES    DCF = MARKER TO INCR
*  D.R= RECORD             RSP= USER'S RESPONSE    DLN = LINE POSITION
*  DLG= LENGTH FOR INPUT   DCL = COLUMN FOR DISPLAY
*  DAM= ATTRIBUTE MARK     DVM = VALUE MARK        DSM = SUB VALUE MARK
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
SYS.PROG = "SYS.SCR.SEL":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "VAR":AM:SYS.SLOC
Prog.restart: *
*
GOSUB SCR.SEL
*
End.of.prog: *
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
SYS.FILE = ""
SYS.ITEM = ""
RETURN
!
SCR.SEL: * Display table and select
SYS.LOCT<1> = "STEP.DESC"
SYS.SLOC<1> = "DISPLAY"
*
DCONT = 1; DCONT1 = 1
DCN   = 1; DSTOP  = DI 
SEL.CN = 0; DCNC = 1
*
LOOP
SEL.CN =0
PRINT @(0,DLN):CLL:
TC = ""
LOOP
SEL.CN = 0
IF DCN = DSTOP - DI + 1 THEN GOSUB DCLEAR
IF D.R<DAM,DVM,DCN> = "" THEN
IF SEL.RSP # "A" THEN
DCONT = 0
END ELSE
IF DCONT = 1 THEN DCONT = 2
END
END
WHILE DCONT AND DCN <= DM DO
IF DCN < DSTOP + 1 THEN
TEMP.LN = DCN - INT((DCN - 1) / DI) * DI + 6
PRINT @(DCL*DCNC,TEMP.LN):CLL:(DCN:") ") "R#4":
IF SEL.RSP # "A" OR DCONT # 2 THEN
PRINT D.R<DAM,DVM,DCN> "L#":DLG:
END ELSE
IF TC # "" THEN PRINT TC:
INPUT RSP,(DLG-LEN(TC)):
IF DOV AND TC # "" THEN RSP = TC:RSP; TC = ""
IF LEN(RSP) = DLG THEN
PRINT BELL:
LOOP UNTIL RSP[LEN(RSP),1] = " " DO TC = RSP[LEN(RSP),1]:TC; RSP = RSP[1,LEN(RSP)-1] REPEAT
PRINT @((DCL*DCNC) + LEN(RSP) + 4):SPACE(DLG-LEN(RSP)):
END
IF LEN(RSP) = 0 THEN DCONT = 0 ELSE D.R<DAM,DVM,DCN> = RSP
END
DCN = DCN + 1
END ELSE
IF NOT(STEP.FIRST) AND SEL.RSP # "A" THEN DCONT = 0 ELSE
IF NOT(SYSTEM(11) AND DCONT = 1) THEN RQM
IF SYSTEM(11) AND DCONT = 1 THEN DCONT = 0; INPUT RSP.CONT,1: ELSE RQM
END
IF DSTOP <= DM - DI AND DCONT THEN
DSTOP = DSTOP + DI 
DCN = DSTOP - DI + 1
END ELSE DCONT = 0
END
REPEAT
STEP.FIRST = 0
*
IF D.R<DAM,DVM,DCN> # "" THEN PRINT @(0,16):RVB:"More. . .":RVE: ELSE PRINT @(0,16):CLL:
PRINT @(0,22):CLS:STRUCT(2):OPT.LINE1:
PRINT @(0,23):CLL:SPACE(5):OPT.LINE2:
*
!
Input.rsp: * Return point that resets wait status and time recording.
SYS.LOCT = "FUNCTION"
SYS.SLOC = "INIT"
READV INP.MODE FROM SY.FILE,"@SYS@USER@":USER.NAME,27 ELSE INP.MODE<1,PORT+1> = "11"
INP.MODE = INP.MODE<1,PORT+1>
SYS.EV = "0":SVM:"1":SVM:"1":SVM:INP.MODE:SVM:SVM
SYS.EV = SYS.EV:SVM:SVM:SVM:SVM:SVM
SYS.EV = SYS.EV:MENU.APPL:SVM:MENU.NAME:SVM:"SYS.SCR.SEL":SVM:"9900":SVM:USER.NAME:SVM
SYS.EV = SYS.EV:"1":SVM:"0":SVM:"0":SVM:"100"
SYS.EV<2> = "20":VM:"22":VM:OPT.LINE1:SVM:OPT.LINE2:VM:"2010":VM:"0":VM
SYS.EV<2> = SYS.EV<2>:"7200":VM:"EX":SVM
SYS.EV = '"SELECT"':SVM
SYS.EV = SYS.EV:VM:"1":VM:"your entry was invalid":VM:""
SYS.ES = ""
CALL SYS.RSP
SEL.RSP = SYS.ES<SYS.ES<1,1,1>+1,1,11>
*
*
*
PRINT @(0,0):RVB:OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS"):RVE:
!
*
IF SEL.RSP = "C" THEN STEP.FIRST = 1
*
RSP.RELOOP: *
IF SEL.RSP = "A" THEN
DSTOP = DI 
DCN = 1
DCONT = 1
*
END ELSE IF SEL.RSP = "B" THEN
IF DSTOP > DI THEN
DSTOP = DSTOP - DI 
DCN = DSTOP - DI + 1
END ELSE
PRINT BELL:
DSTOP = DI 
DCN = 1
END
DCONT = 1
*
END ELSE IF SEL.RSP = "C" OR SEL.RSP = "" OR SEL.RSP = "END" THEN
DCONT = 0; DCONT1 = 0
*
END ELSE IF DMD AND SEL.RSP MATCHES '"D"0N' OR SEL.RSP MATCHES '"D"0N"-"0N' THEN
SEL.RSP = SEL.RSP[2,99]
SEL.CN = FIELD(SEL.RSP,"-",1)
DCN2 = FIELD(SEL.RSP,"-",2)
IF LEN(DCN2) = 0 THEN DCN2 = SEL.CN
IF NUM(SEL.CN) AND NUM(DCN2) THEN
ERROR.TEXT = "are you sure?"
ERROR.CODE = "19002"
GOSUB ERROR.CONTROL
IF INDEX(YES,"*":ERROR.RSP:"*",1) # 0 THEN
SEL.START = SEL.CN
FOR SEL.CN = SEL.START TO DCN2
GOSUB DSET.MARK
IF LEN(D.R<DAM,DVM,SEL.CN>) # 0 THEN
D.R = DELETE(D.R,DAM,DVM,DSM)
ERROR.TEXT = "line number ":SEL.CN:" has been deleted"
ERROR.CODE = "17010"
GOSUB ERROR.CONTROL
END
NEXT TEMP
ERROR.TEXT = "deletion cycles completed"
ERROR.CODE = "19000"
END
END ELSE
ERROR.TEXT = "your choice for deletion was non numeric"
ERROR.CODE = "18010"
END
GOSUB ERROR.CONTROL
DSTOP = DI 
DCN = 1
DCONT = 1
*
END ELSE IF DMD AND SEL.RSP = "I" THEN
ERROR.TEXT = "the insert has not yet been released"
ERROR.CODE = "16010"
GOSUB ERROR.CONTROL
*
END ELSE IF SEL.RSP = "N" THEN
IF DSTOP < DM AND D.R<DAM,DVM,DSTOP + 1> # "" THEN
DSTOP = DSTOP + DI 
DCN = DSTOP - DI + 1
END ELSE
PRINT BELL:
DSTOP = DI 
DCN = 1
END
DCONT = 1
*
END ELSE IF DMD AND SEL.RSP MATCHES '"M"0N"-"0N' THEN
SEL.RSP = SEL.RSP[2,99]
SEL.CN = FIELD(SEL.RSP,"-",1)
IF NOT(NUM(SEL.CN)) THEN SEL.CN = 1
IF SEL.CN < 1 OR SEL.CN > DM THEN SEL.CN = 1
D.ORIG.CN = SEL.CN
GOSUB DSET.MARK
IF D.R<DAM,DVM,DSM> # "" THEN
D.DEST.CN = FIELD(SEL.RSP,"-",2)
IF NOT(NUM(D.DEST.CN)) THEN D.DEST.CN = 1
IF D.DEST.CN < 1 OR D.DEST.CN > DM THEN D.DEST.CN = 1
DSAVE = DCN
DCN = D.DEST.CN
LOOP
SEL.CN = DCN
GOSUB DSET.MARK
WHILE DCN > 1 AND D.R<DAM,DVM,DSM> = "" DO
IF D.R<DAM,DVM,DSM> = "" THEN DCN = DCN - 1
REPEAT
DCN = DSAVE
IF D.DEST.CN # D.ORIG.CN AND D.R<DAM,DVM,DM> = "" THEN
SEL.CN = D.ORIG.CN
GOSUB DSET.MARK
TEMP = D.R<DAM,DVM,DSM>
CN = 0
IF D.DEST.CN > CN THEN CN = D.DEST.CN
IF SEL.CN > CN THEN CN = SEL.CN
SEL.CN = CN
GOSUB DSET.MARK
TEMP2 = D.R<DAM,DVM,DSM>
LOOP
IF CN < D.ORIG.CN AND CN < D.DEST.CN THEN CN = 0
WHILE CN > 0 DO
IF NOT(CN > D.ORIG.CN AND CN > D.DEST.CN) THEN
IF D.DEST.CN < D.ORIG.CN AND CN > 1 THEN
SEL.CN = CN
GOSUB DSET.MARK
SSA = DAM
SSV = DVM
SSS = DSM
SEL.CN = SEL.CN - 1
GOSUB DSET.MARK
D.R<SSA,SSV,SSS> = D.R<DAM,DVM,DSM>
IF CN # D.DEST.CN THEN D.R<DAM,DVM,DSM> = ""
END ELSE IF CN > 1 AND CN > D.ORIG.CN THEN
TEMP1 = D.R<DAM,DVM,DSM>
D.R<DAM,DVM,DSM> = TEMP2
TEMP2 = TEMP1
END
IF DSM = D.DEST.CN THEN D.R<DAM,DVM,DSM> = TEMP
END
CN = CN-1
REPEAT
IF D.DEST.CN = 1 THEN D.R<DAM,DVM,DSM> = TEMP
END
END
SEL.RSP = "B"
GOTO RSP.RELOOP
*
END ELSE IF DMD AND SEL.RSP MATCHES '"M"0N' THEN
SEL.CN = SEL.RSP[2,99]
IF NOT(NUM(SEL.CN)) THEN SEL.CN = 1
IF SEL.CN < 1 OR SEL.CN > DM THEN SEL.CN = 1
IF SEL.CN > DSTOP OR SEL.CN < DSTOP - DI + 1 THEN PRINT BELL: ELSE
TEMP.LN = SEL.CN - INT((SEL.CN - 1) / DI) * DI + 6
PRINT @(DCL*DCNC,TEMP.LN):CLL:(SEL.CN:") ") "R#4":
RSP = ""
TEMP.CL = (DCL*DCNC) + 4
TEMP.LEN = DLG
GOSUB DSET.MARK
CALL SYS.LINE.INPUT(TEMP.CL,TEMP.LN,TEMP.LEN,D.R<DAM,DVM,DSM>,RSP,"0","1")
IF LEN(RSP) # 0 THEN
IF LEN(RSP) = DLG THEN
PRINT BELL:
LOOP UNTIL RSP[LEN(RSP)-1,1] = " " DO RSP = RSP[1,LEN(RSP)-1] REPEAT
INPUTCLEAR
END
D.R<DAM,DVM,SEL.RSP> = RSP
END
PRINT @((DCL*DCNC),TEMP.LN):CLL:(SEL.RSP:") ") "R#4":D.R<DAM,DVM,SEL.RSP> "L#":DLG:
END
*
END ELSE IF LEN(SEL.RSP) = 0 THEN
DCONT1 = 0
*
END ELSE IF NUM(SEL.RSP) AND DS THEN
SEL.CN = SEL.RSP
GOSUB DSET.MARK
IF DSM > 0 AND DSM < DM AND LEN(D.R<DAM,DVM,DSM>) > 0  THEN
RSP = D.R<DAM,DVM,DSM>
DCONT1 = 0
DCONT = 0
SEL.RSP = "END"
END
*
END ELSE
ERROR.TEXT = "that was an invalid entry"
ERROR.CODE = "19011"
GOSUB ERROR.CONTROL
END
WHILE DCONT1 DO REPEAT
*
RETURN
!
DCLEAR: * Clears lines with CLL
FOR TEMP1 = 1 TO DNC
FOR TEMP = 1 TO 10
PRINT @((DCL*TEMP1),TEMP+DLN):SPACE(DLG+4):
NEXT TEMP
NEXT TEMP1
*
RETURN
!
DSET.MARK: *
IF SEL.CN = 0 THEN TEMP = DCN ELSE TEMP = SEL.CN
IF NOT(NUM(TEMP)) THEN TEMP = 1
IF TEMP < 1 THEN TEMP = 1
IF DI = 1 THEN
DAM = TEMP
END ELSE IF DI = 2 THEN
DVM = TEMP
END ELSE
DSM = TEMP
END
*
RETURN
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*
END
~SYS.SEQ~
*PROGRAM: SYS.SEQ
*
PRINT
PRINT
*
LOOP
INPUT A
WHILE LEN(A) > 0 DO
IF LEN(A) = 1 THEN
PRINT SEQ(A)
PRINT
PRINT
END
REPEAT
*
PRINT
PRINT
*
END
~SYS.SLAVE~
XSUBROUTINE SYS.SLAVE
*"*0400*0420*0440*0460*0480*04A0*04C0*04E0*0510*"
!
$INCLUDE IBP SYS.COMMON
*# 
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*# 
DIM MODE.DESC(30), STAT.DESC(15)
*# 
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*# 
SYS.PROG = "SYS.SLAVE":AM:SYS.PROG
SYS.PROG.TYPE = 8
EQ.PROG.TYPE = 8
EQ.PROG.STATUS = TRUE
*#
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "OPEN":AM:SYS.SLOC
SLAVE.FUNCTION = CALL.FUNCTION<1>
SLAVE.SUB.FUNCTION = CALL.SUB.FUNCTION<1>
*# 
!
SLAVE.OK = 1
SLAVE.ACCESS.OK = 1
SLAVE.AVAIL.OK = 1
SLAVE.NEW.PORT = ""
*# 
SYS.FILE = "MENUS"
OPEN SYS.FILE TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*# 
SYS.FILE = "ACC"
OPEN SYS.FILE TO AC.FILE ELSE
ERROR.TEXT = "No ACC file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*# 
SYS.SLOC<1> = "DIM"
DIM SLAVE.REC(100)
MAT SLAVE.REC = ""
*# 
!
LOOP
!
LOOP
*# 
SYS.SLOC<1> = "VERIFY"
CALL.FUNCTION<1> = "SLAVE"
CALL.SUB.FUNCTION<1> = "PORT"
IF SLAVE.NEW.PORT # "" THEN
SLAVE.SUB.FUNCTION = SLAVE.NEW.PORT
SLAVE.NEW.PORT = ""
END
*#
IF NOT(NUM(SLAVE.SUB.FUNCTION)) THEN
ERROR.TEXT = "the port requested in this slave call is invalid"
ERROR.CODE = "14111"
GOSUB ERROR.CONTROL
*SLAVE.OK = 0
SLAVE.FUNCTION = DEFAULT.PORT
END
*# 
IF SLAVE.FUNCTION # "SLAVE" THEN
ERROR.TEXT = "the SLAVE function was improperly called"
ERROR.CODE = "14111"
GOSUB ERROR.CONTROL
*SLAVE.OK = 0
SLAVE.FUNCTION = "SLAVE"
END
*# 
IF SLAVE.SUB.FUNCTION = PORT THEN
ERROR.TEXT = "you should not initiate a slave from the same port"
ERROR.CODE = "14111"
GOSUB ERROR.CONTROL
*SLAVE.OK = 0
END
*# 
IF STRUCT(27)<1,PORT+1> < 11 THEN
ERROR.TEXT = "a slave should not initiate a slave"
ERROR.CODE = "14111"
GOSUB ERROR.CONTROL
*SLAVE.OK = 0
END
*# 
*#
PORT.CONT = 0
SYS.FILE = "SYS"
*#
SLAVE.SUB.FUNCTION = (STR("0",2-LEN(SLAVE.SUB.FUNCTION)):SLAVE.SUB.FUNCTION)[LEN(SLAVE.SUB.FUNCTION)-1,2]
*#
SYS.ITEM = "@SYS@PORT@":SLAVE.SUB.FUNCTION
READ PORT.REC FROM SY.FILE,SYS.ITEM THEN PORT.ON.FILE = TRUE ELSE PORT.ON.FILE = FALSE; PORT.REC = ""
*#
SYS.ITEM = PORT.REC<14>
READ PORT.OPSYS.REC FROM SY.FILE,SYS.ITEM THEN OPSYS.ON.FILE = TRUE ELSE OPSYS.ON.FILE = FALSE; PORT.OPSYS.REC = ""; *#
*#
SYS.ITEM = "MENU.":SLAVE.SUB.FUNCTION
READ USER.VERIFY FROM SY.FILE,SYS.ITEM THEN SYS.ON.FILE = TRUE ELSE SYS.ON.FILE = FALSE; USER.VERIFY = ""
*#
READ USER.ACC FROM AC.FILE,SYS.ITEM THEN ACC.ON.FILE = TRUE ELSE ACC.ON.FILE = FALSE; USER.ACC = ""
*#
IF OPSYS.ON.FILE OR SYS.ON.FILE OR ACC.ON.FILE THEN
ERROR.TEXT = "That port is under the control of ":USER.VERIFY<2>
ERROR.RSP = ""
ERROR.CODE = "15111"
GOSUB ERROR.CONTROL
*SLAVE.AVAIL.OK = 0
END
*#
IF NOT(OPSYS.ON.FILE) OR (ERROR.RSP[1,3] EQ "SYS" OR USER.VERIFY<2> NE USER.NAME) THEN
PRINT @(0,5):CLS:@(20,8):
IF NOT(SYSTEM(11)) THEN EXECUTE "SYS.UL"
ERROR.TEXT = "Enter the port you wish to use: "
ERROR.CODE = "16112"
GOSUB ERROR.CONTROL
*#
IF ERROR.RSP = SLAVE.SUB.FUNCTION THEN
ERROR.TEXT = "Delete the activity ":USER.VERIFY<2>:" (Y/N): "
ERROR.CODE = "16112"
GOSUB ERROR.CONTROL
IF INDEX(YES,ERROR.RSP,1) # 0 THEN DELETE SY.FILE,SYS.ITEM
END ELSE
SLAVE.NEW.PORT = ERROR.RSP
END
*#
IF (USER.VERIFY<2> NE USER.NAME AND LEN(USER.VERIFY<2>)) AND OPSYS.ON.FILE THEN PORT.CONT = 1
*#
END ELSE
ERROR.TEXT = "That port is available"
ERROR.CODE = "16100"
GOSUB ERROR.CONTROL
USER.VERIFY<2> = ""
*CALL SYS.LOGON.SLAVE
END
WHILE PORT.CONT DO REPEAT
*
!
SUBR.FUNCTION = ""
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@USER@":STRUCT(2)
LOOP
LCK.STAT = 0
CALL SYS.LOCK.ITEM
WHILE LCK.STAT # PORT+1 AND LCK.STAT # 9998 DO
IF LCK.STAT > 9000 THEN
ERROR.TEXT = "your control record is locked":AM:"Enter 'Y' to try again"
ERROR.CODE = "14110":AM:"14110"
GOSUB ERROR.CONTROL
IF INDEX(YES,"*":ERROR.RSP:"*",1) EQ 0 THEN
SLAVE.ACCESS.OK = 0
GOTO End.of.prog
END
TEMP = 9997
END
REPEAT
*
LCK.STAT = 0
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@USER@":STRUCT(2)
CALL SYS.UNLOCK.ITEM
*
!
LOOP
*
SYS.SLOC<1> = "READ"
READ.CONT = 0
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@RSP-STACK@SLAVE@":SLAVE.SUB.FUNCTION
LCK.STAT = 0
CALL SYS.LOCK.ITEM
IF LCK.STAT # PORT+1 AND LCK.STAT # 9998 THEN
ERROR.TEXT = "the slave record is locked":AM:"Enter 'Y' to try again"
ERROR.CODE = "18011":AM:"18011"
GOSUB ERROR.CONTROL
IF INDEX(YES,"*":ERROR.RSP:"*",1) EQ 0 THEN
TEMP = 9997
END ELSE
IF TEMP = 9998 THEN SLAVE.AVAIL.OK = 0
END
END
MATREAD SLAVE.REC FROM SY.FILE,SYS.ITEM ELSE
MAT SLAVE.REC = ""
ERROR.TEXT = "that slave record is not currently on file"
ERROR.CODE = "14010"
GOSUB ERROR.CONTROL
END
*
IF SLAVE.OK THEN
PRINT @(0,21):BELL:RVB:"Slave status OK!":RVE:
END
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
SUBR.FUNCTION = "DISPLAY"
*
LOOP
IF SUBR.FUNCTION = "DISPLAY" THEN GOSUB Slave.display
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
*
IF SLAVE.INP = "EDIT" OR SUBR.FUNCTION = "EDIT" THEN
IF USER.MODE >= LO.D.M AND USER.MODE <= HI.D.M THEN
PRINT @(0,5):CLS:@(0,6):"Ready for edit."
EXECUTE SLAVE.INP:" SYS ":SYS.ITEM
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
IF SUBR.FUNCTION = "EDIT" THEN SLAVE.INP = "END"
READ.CONT = 1
END
*
*END ELSE
*
END
WHILE SUBR.FUNCTION = "DISPLAY" AND SLAVE.INP # "END" AND SLAVE.INP[1,5] # "PORT " AND NOT(READ.CONT) DO REPEAT
!
*
WHILE READ.CONT = 1 DO REPEAT
!
* END OF SLAVE.OK
LCK.STAT = 0
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@RSP-STACK@SLAVE@":SLAVE.SUB.FUNCTION
CALL SYS.UNLOCK.ITEM
WHILE SLAVE.NEW.PORT # "" DO REPEAT
!
End.of.prog: *
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*SYS.FUNCTION = DELETE(SYS.FUNCTION,1)
*SYS.SUB.FUNCTION = DELETE(SYS.SUB.FUNCTION,1)
RETURN
!
Slave.display: * Main program.
SYS.LOCT<1> = "SLAVE"
SYS.SLOC<1> = "DISPLAY"
*
SLAVE.INP.FLAG = 0
SLAVE.CONT = 1; SLAVE.CONT1 = 1; SLAVE.CONT2 = 1
IF NOT(SLAVE.INP.FLAG) THEN SLAVE.CN   = 1
SLAVE.CN1  = 1
SLAVE.STOP  = 10; SLAVE.DETL  = 0
HEADER = RVB:"REF USER.... STEP TOTAL SCHD.DATE TIME. ES.ELP PRIOR DESCRIPTION......":RVE
*
LOOP
PRINT @(0,5):CLS:
PRINT @(0,6):CLL:"User Slave Utility for ":USER.NAME:".  To be run on port: ":SLAVE.SUB.FUNCTION:
PRINT @(0,8):CLL:HEADER:
LOOP WHILE SLAVE.REC(SLAVE.CN)<1,1,4> # "" AND SLAVE.CONT AND SLAVE.CN <= 100 DO
IF SLAVE.CN < SLAVE.STOP + 1 THEN
IF SLAVE.DETL THEN TEMP.LN = 9 ELSE TEMP.LN = SLAVE.CN - INT((SLAVE.CN - 1) / 10) * 10 + 8
IF NOT(SLAVE.INP.FLAG) THEN
PRINT @(0,TEMP.LN):CLL:
PRINT SLAVE.CN "R#3":" ":SLAVE.REC(SLAVE.CN)<1,1,15> "L#8":" ":
PRINT SLAVE.REC(SLAVE.CN)<1,1,1> "R#3":SLAVE.REC(SLAVE.CN)<1,1,2> "R#6":"  ":
PRINT OCONV(SLAVE.REC(SLAVE.CN)<1,1,17>,"D2") "L#10":OCONV(SLAVE.REC(SLAVE.CN)<1,1,18>,"MT") "L#6":
PRINT OCONV(SLAVE.REC(SLAVE.CN)<1,1,7>,"MT") "R#6":"   ":SLAVE.REC(SLAVE.CN)<1,1,19> "L#4":
PRINT SLAVE.REC(SLAVE.CN)<1,1,13> "L#25":
END ELSE
PRINT @(0,TEMP.LN):CLL:SLAVE.CN "R#3":" ":
INPUT RSP:
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,15> = RSP
PRINT @(13):
IF RSP NE "END" THEN INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,1> = RSP
PRINT @(17):
INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,2> = RSP
PRINT @(23):
IF RSP NE "END" THEN INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,17> = ICONV(RSP,"D2")
PRINT @(32):
IF RSP NE "END" THEN INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,18> = ICONV(RSP,"MT")
PRINT @(38):
IF RSP NE "END" THEN INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,7>  = ICONV(RSP,"D2")
PRINT @(47):
IF RSP NE "END" THEN INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,19> = RSP
PRINT @(51):
IF RSP NE "END" THEN INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,1,13> = RSP
END
IF SLAVE.DETL THEN SLAVE.CONT = 0 ELSE
SLAVE.CN = SLAVE.CN + 1
END
END ELSE SLAVE.CONT = 0
*
IF SLAVE.DETL THEN
LOOP WHILE SLAVE.REC(SLAVE.CN)<1,SLAVE.CN1+1> # "" AND SLAVE.CONT1 AND SLAVE.CN1 <= 100 DO
IF SLAVE.CN1 < SLAVE.STOP + 1 THEN
TEMP.LN = SLAVE.CN1 - INT((SLAVE.CN1 - 1) / 10) * 10 + 9
IF NOT(SLAVE.INP.MODE) THEN
PRINT @(0,TEMP.LN):CLL:@(10):SLAVE.REC(SLAVE.CN)<1,SLAVE.CN1+1> "L#50":
END ELSE
PRINT @(0,TEMP.LN):CLL:@(10):
IF RSP NE "END" THEN INPUT RSP
IF LEN(RSP) AND RSP NE "END" THEN SLAVE.REC(SLAVE.CN)<1,SLAVE.CN1+1> = RSP
END
SLAVE.CN1 = SLAVE.CN1 + 1
END ELSE SLAVE.CONT1 = 0
REPEAT
END
REPEAT
*
IF (NOT(SLAVE.DETL) AND SLAVE.REC(SLAVE.CN)<1,1,4> # "") OR (SLAVE.DETL AND SLAVE.REC(SLAVE.CN)<1,SLAVE.CN1+1> # "") THEN
PRINT @(0,21):RVB:"(MORE)":RVE:
END ELSE PRINT @(0,21):"      ":
*
!
*
RSP.VALID = ""
LOOP UNTIL RSP.VALID DO
RSP.VALID = 1
PRINT @(0,22):CLS:STRUCT(2):', Enter "B", "N", "M##-##", "EDIT" the stack,':
PRINT @(0,23):CLL:SPACE(5):' "PORT ##", "V##", or "END"  to end: ':
INPUT SLAVE.INP:
RSP.RELOOP: *
IF SLAVE.INP = "" THEN SLAVE.INP = "B"
IF SLAVE.INP = "END" THEN
SLAVE.CONT = 0; SLAVE.CONT1 = 0; SLAVE.CONT2 = 0
*
END ELSE IF SLAVE.INP = "B" THEN
SLAVE.DETL = 0
IF SLAVE.STOP >10 THEN
SLAVE.STOP = SLAVE.STOP - 10
SLAVE.CN = SLAVE.STOP - 10 + 1
END ELSE
SLAVE.STOP = 10
SLAVE.CN = 1
END
SLAVE.CONT = 1
*
END ELSE IF SLAVE.INP = "N" THEN
IF SLAVE.STOP < 100 AND ((NOT(SLAVE.DETL) AND SLAVE.REC(SLAVE.CN)<1,1,4> # "") OR (SLAVE.DETL AND SLAVE.REC(SLAVE.CN)<1,SLAVE.CN1+1> # "")) THEN
SLAVE.STOP = SLAVE.STOP + 10
TEMP = SLAVE.STOP - 10 + 1
IF SLAVE.DETL THEN SLAVE.CN1 = TEMP ELSE SLAVE.CN = TEMP
END ELSE
PRINT BELL:
SLAVE.STOP = 10
IF SLAVE.DETL THEN SLAVE.CN1 = 1 ELSE SLAVE.CN = 1
END
SLAVE.CONT = 1; SLAVE.CONT1 = 1
*
END ELSE IF SLAVE.INP[1,1] = "M" THEN
SLAVE.INP = SLAVE.INP[2,99]
SLAVE.MOVE.CN = FIELD(SLAVE.INP,"-",1)
IF NOT(NUM(SLAVE.MOVE.CN)) THEN SLAVE.MOVE.CN = 1
IF SLAVE.MOVE.CN < 1 OR SLAVE.MOVE.CN > 100 THEN SLAVE.MOVE.CN = 1
IF SLAVE.REC(SLAVE.MOVE.CN)<1,1,4> # "" THEN
SLAVE.DEST.CN = FIELD(SLAVE.INP,"-",2)
IF NOT(NUM(SLAVE.DEST.CN)) THEN SLAVE.DEST.CN = 1
IF SLAVE.DEST.CN < 1 OR SLAVE.DEST.CN > 100 THEN SLAVE.DEST.CN = 1
LOOP WHILE SLAVE.DEST.CN > 1 AND SLAVE.REC(SLAVE.DEST.CN)<1,1,4> = "" DO
IF SLAVE.REC(SLAVE.DEST.CN)<1,1,4> = "" THEN SLAVE.DEST.CN = SLAVE.DEST.CN - 1
REPEAT
IF SLAVE.DEST.CN # SLAVE.MOVE.CN AND SLAVE.REC(100) = "" THEN
TEMP = SLAVE.REC(SLAVE.MOVE.CN)
CN = 0
IF SLAVE.DEST.CN > CN THEN CN = SLAVE.DEST.CN
IF SLAVE.MOVE.CN > CN THEN CN = SLAVE.MOVE.CN
TEMP2 = SLAVE.REC(CN)
LOOP
IF CN < SLAVE.MOVE.CN AND CN < SLAVE.DEST.CN THEN CN = 0
WHILE CN > 0 DO
IF NOT(CN > SLAVE.MOVE.CN AND CN > SLAVE.DEST.CN) THEN
IF SLAVE.DEST.CN < SLAVE.MOVE.CN THEN
SLAVE.REC(CN) = SLAVE.REC(CN-1)
IF CN # SLAVE.DEST.CN THEN SLAVE.REC(CN-1) = ""
END ELSE IF CN > 1 AND CN > SLAVE.MOVE.CN THEN
TEMP1 = SLAVE.REC(CN-1)
SLAVE.REC(CN-1) = TEMP2
TEMP2 = TEMP1
END
IF CN = SLAVE.DEST.CN THEN SLAVE.REC(CN) = TEMP
END
CN = CN-1
REPEAT
IF SLAVE.DEST.CN = 1 THEN SLAVE.REC(1) = TEMP
END
SLAVE.STOP = INT(SLAVE.DESC.CN/10)*10+10
SLAVE.CN = SLAVE.DESC.CN
END
SLAVE.INP = "B"
*
END ELSE IF SLAVE.INP[1,5] = "PORT " THEN
SLAVE.NEW.PORT = FIELD(SLAVE.INP," ",2)
SLAVE.CONT = 0; SLAVE.CONT1 = 0; SLAVE.CONT2 = 0
*
END ELSE IF SLAVE.INP[1,1] = "V" THEN
SLAVE.CN = SLAVE.INP[2,99]
IF NOT(NUM(SLAVE.CN)) THEN SLAVE.CN = 1
IF SLAVE.CN < 1 THEN SLAVE.CN = 1
IF SLAVE.REC(SLAVE.CN)<1,1,4> = "" THEN SLAVE.CN = 1
SLAVE.DETL = 1; SLAVE.CN1 = 1; SLAVE.CONT = 1; SLAVE.CONT1 = 1; SLAVE.STOP = 10
*
END ELSE IF SLAVE.INP = "EDIT" THEN
SLAVE.CONT2 = 0
*
*
END ELSE
ERROR.TEXT = "that was an invalid entry"
ERROR.CODE = "14011"
GOSUB ERROR.CONTROL
RSP.VALID = ""
END
REPEAT
*
WHILE SLAVE.CONT2 DO REPEAT
*
RETURN
!
*
*
*
!
$INCLUDE IBP SYS.ERROR.STRUCT
*
END
~SYS.SP.DELETE.ALL~
*PROGRAM: SYS.SP.DELETE.ALL
*#
*# AUTHOR:  DAVID HORSMAN
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#
RSP = ""
LOOP
EXEC.VERB = "SP-EDIT"
EXEC.PARAMS = "D":AM:"Y":AM:"X"
EXEC.RESULTS = ""
*#
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS, //OUT. > EXEC.RESULTS
*#
IF LEN(EXEC.RESULTS) THEN
EXEC.RES.MAX = DCOUNT(EXEC.RESULTS,AM)
IF EXEC.RESULTS<1> EQ "[1162]" AND RSP EQ "GO" THEN RSP = ""
PRINT
FOR A = 1 TO EXEC.RES.MAX
PRINT EXEC.RESULTS<A>:" . . . "
NEXT A
END
*#
IF RSP NE "GO" THEN
PRINT
PRINT "Enter END or KILL to stop, GO to do the rest: ":
INPUT RSP
PRINT
IF RSP = "GO" THEN
PRINT BELL:"Delete how many print files: ":
INPUT SP.DEL.MAX
PRINT
IF NOT(NUM(SP.DEL.MAX)) THEN SP.DEL.MAX = 1
IF SP.DEL.MAX LE 0 THEN SP.DEL.MAX = 1
IF SP.DEL.MAX GT 500 THEN SP.DEL.MAX = 500
END
END ELSE
SP.DEL.MAX = SP.DEL.MAX - 1
IF SP.DEL.MAX LE 1 THEN RSP = ""
END
*#
WHILE RSP NE "END" AND RSP NE "KILL" DO REPEAT
*#
END
*
*
*
~SYS.SUBR.HEADING~
SUBROUTINE SYS.SUBR.HEADING(OUT.TO.PRINT,SYS.PROG.DESC,SCR.HEADING)
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*#SYS.PROG = "SYS.SUBR.HEADING":AM:SYS.PROG
*#SYS.LOCT = "INIT":AM:SYS.LOCT
*#SYS.SLOC = "EQUATES":AM:SYS.SLOC
SYS.SLOC<1> = "SYS.SUBR.HEADING"
DIM MODE.DESC(30),STAT.DESC(15)
*#*
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
$INCLUDE IBP SYS.INCL.BATCH.RSP
$INCLUDE IBP SYS.INCL.LIST.RSP
$INCLUDE IBP SYS.INCL.STAT.LINE
*#
*#
*#*
*#*SYS.PROG = "SYS.SUBR.HEADING":AM:SYS.PROG
*#*SYS.LOCT = "INIT":AM:SYS.LOCT
*#*SYS.SLOC = "":AM:SYS.SLOC
SYS.SLOC<1>="HEADING"
*#**
*#*GOSUB S.HEADING
*#**
*#*End.of.prog: * bypass GOTO for abnormal end.
*#**
*#*SYS.PROG = DELETE(SYS.PROG,1)
*#*SYS.LOCT = DELETE(SYS.LOCT,1)
*#*SYS.SLOC = DELETE(SYS.SLOC,1)
*#*RETURN
*#*!
*#**
*#**
*#*S.HEADING: * Subroutine to print screen heading.
TEMP = 0
TEMP1 = 0
TEMP2 = 0
SCR.PORT = ""
SCR.UPD = ""
SCR.CNTR = ""
*
*
IF STRUCT(25)<1,PORT+1> THEN
*
IF STRUCT(70) > 0 THEN SCR.CNTR = (STRUCT(70)-1)[1,1] ELSE SCR.CNTR = "s"
IF STRUCT(91) > 0 THEN SCR.CNTR = SCR.CNTR:(STRUCT(91)-1)[1,1] ELSE SCR.CNTR = SCR.CNTR:"m"
IF WAIT.FLAG THEN SCR.CNTR = SCR.CNTR:WAIT.FLAG[1,1] ELSE SCR.CNTR = SCR.CNTR:"w"
*
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF STRUCT(21)<1,TEMP> # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVE
SCR.PORT = SCR.PORT:STRUCT(21)<1,TEMP>[1,1]
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVB; TEMP1 = 2
END ELSE
SCR.PORT = SCR.PORT:"o"
END
REPEAT
SCR.PORT = SCR.PORT[1,10+TEMP1]
*
TEMP = 0
TEMP2 = 0
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF USER.UPD(TEMP) # 0 THEN
SCR.UPD = SCR.UPD:RVE
SCR.UPD = SCR.UPD:USER.UPD(TEMP)[1,1]
SCR.UPD = SCR.UPD:RVB
TEMP2 = TEMP2 + 2
END ELSE
SCR.UPD = SCR.UPD:"o"
END
REPEAT
SCR.UPD = SCR.UPD[1,10+TEMP2]
*
END
*
*
IF OUT.TO.PRINT THEN
PRINTER ON
PRINT FF
PRINTER OFF
PRINTER CLOSE
PRINTER ON
MAX.COL = 132
MAX.LN = 60
END ELSE
*
*# LINE 0 - LINE 0 - LINE 0
PRINT @(0,0):CLL:RVB: ; *#
MAX.COL = 80
MAX.LN = 20
END
*
*
PRINT (OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS")) "L#20": ; *#
PRINT (PORT:".":ACCT:".":STRUCT(2)) "L#13":" ": ; *#
*
*
IF STRUCT(25)<1,PORT+1> THEN PRINT " ":MODE.DESC(USER.MODE) "L#5":" ": ELSE PRINT SPACE(7): ; *#
PRINT MENU.APPL.DESC "L#39":
*#
*#v
*# LINE 1 - LINE 1 - LINE 1
IF OUT.TO.PRINT THEN PRINT ELSE
PRINT @(0,1):CLL: ; *#
END
*#^
IF STRUCT(25)<1,PORT+1> THEN 
PRINT "[P|": ; *#
TEMP3 = "R#":TEMP1+10
PRINT SCR.PORT TEMP3: ; *#
PRINT "]": ; *#
END ELSE PRINT SPACE(14): ; *#
*
*
IF STRUCT(25)<1,PORT+1> THEN
PRINT "[U|": ; *#
TEMP3 = "L#":TEMP2 + 10
PRINT SCR.UPD TEMP3: ; *#
PRINT "]": ; *#
END ELSE PRINT SPACE(14): ; *#
IF STRUCT(25)<1,PORT+1> THEN PRINT ("[":SCR.CNTR[1,3]:"]") "L#5": ELSE PRINT SPACE(5): ; *#
PRINT "  ":
*# 40 CHARS AVAIL.
PRINT MENU.CONTROL<1,1> "L#45": ; *#
*
*# LINE 2 - LINE 2 - LINE 2
IF OUT.TO.PRINT THEN PRINT ELSE
PRINT @(0,2):CLL: ; *#
END
PRINT CO.DATA<1,1,1> "L#35": ; *#
PRINT SYS.PROG.DESC "L#45": ; *#
*# LINE 3 - LINE 3 - LINE 3
IF OUT.TO.PRINT THEN PRINT ELSE
PRINT @(0,3):CLL: ; *#
END
LN = 3
*
*
IF NOT(OUT.TO.PRINT) THEN PRINT RVE: ELSE PRINT
TEMP = 0
LOOP TEMP = TEMP + 1 WHILE LEN(SCR.HEADING<TEMP>) DO
PRINT SCR.HEADING[1,MAX.COL-1]: ; *#
LN = LN + 1
IF OUT.TO.PRINT THEN PRINT ELSE PRINT @(0,LN):CLL: ; *#
REPEAT
*
LN = LN + 1
IF OUT.TO.PRINT THEN
PRINT
PRINTER OFF
END ELSE
PRINT @(0,LN):CLS: ; *#
END
*
RETURN
*#**
*#**
END
~SYS.SUBR.WHERE~
SUBROUTINE SYS.SUBR.WHERE (SYS.FILE,WHERE.PORT,WHERE.REC,TERM.DISP,STAT)
*PROGRAM: SYS.WHERE
*
* Athor: David G. Horsman
* Company: Macroscope Design Matrix
*
* (C) 1992 All rights reserved
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
! : * Input Parameters
*
** INPUT WHERE.PORT:
*
* : * Init INternal VARiables
*
STAT = FALSE
WHERE.REC = EMPTY
WHERE.TEXT = EMPTY
*
* Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
MAT CNT.TST = EMPTY
*
* : * System Files
*
** OPEN "SYS" TO SYS.FILE ELSE STOP
*
* : * MAIN
*
$INCLUDE IBP SYS.INCL.WHERE
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
*
RETURN
*
END
~SYS.SUBR.WHO~
SUBROUTINE SYS.SUBR.WHO(SYS.FILE,WHO.PORT,WHO.REC,WHO.TEXT,STAT)
*
* Athor: David G. Horsman
* Company: Macroscope Design Matrix
*
* (C) 1992 All rights reserved
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
! : * Input Parameters
*
* : * Init INternal VARiables
*
STAT = FALSE
WHO.REC = EMPTY
WHO.TEXT = EMPTY
*
* Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
* : * System Files
*
* : * MAIN
*
$INCLUDE DH.BP SYS.INCL.WHO
*
IF NOT(STAT) THEN
SYS.ID = "WHO.":("0000":WHO.REC<ONE,ONE>) "R#4"
WRITE WHO.REC ON SYS.FILE,SYS.ID
END
*
RETURN
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
*
RETURN
*
END
~SYS.SYSTEM.ELEVEN~
*PROGRAM: SYS.SYSTEM.ELEVEN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
CN = 0
PRINT
PRINT "NUMBER OF SECONDS TO CYCLE FOR: ":
INPUT CYC.NUM
PRINT
PRINT "NUMBER OF CHARACTERS TO INPUT: ":
INPUT CHARS.TO.INP
PRINT
PRINT "USE ONE RQM LOOP (0/1): ":
INPUT RQM.FLAG
PRINT
PRINT "CLEAR INPUT AFTER COMPLETION (0/1): ":
INPUT CLEAR.INP.FLAG
PRINT
PRINT "DISPLAY RESPONSE (0/1): ":
INPUT DISP.INP
PRINT
START.TIME = TIME()
*
LOOP
SYS.11.VAL = SYSTEM(11)
PRINT @(0):"[}> ":SYS.11.VAL:" <{]": 
CN = CN + 1
IF RQM.FLAG THEN RQM
WHILE TIME()-START.TIME LT CYC.NUM OR SYS.11.VAL LT CHARS.TO.INP DO REPEAT
*
IF CLEAR.INP.FLAG THEN INPUTCLEAR
IF DISP.INP THEN
INPUT RSP
PRINT "v"
PRINT RSP
PRINT "^"
END
*
END
~SYS.TCL~
SUBROUTINE SYS.TCL
*#    Common Area
$INCLUDE IBP SYS.COMMON
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#    Controlling port
$INCLUDE IBP SYS.INCL.CPORT
*#
DIM MODE.DESC(30)
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.LIST.RSP
$INCLUDE IBP SYS.INCL.BATCH.RSP
$INCLUDE IBP SYS.INCL.MAIN.RSP
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
*#
*#    System Location Area
SYS.PROG = "SYS.TCL":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
*#
*#    Initialization Area
*#
*#       Variables.
SYS.SLOC<1> = "FILES"
OLD.CALL.FUNCTION = ""
DISP.PRESTORE = ""
SYS.PROG.DESC = "Macroscope TCL / Stack Manager"
SYS.LIST = ''
SYS.RECORD = ''
SYS.PRINT = ''
OUT.TO.PRINT = 0; SCR.HEADING = ""
P.ENT = ""
P.DEST = 0
*LIST.RSP = "*GET-LIST*QSELECT*FORM-LIST*SELECT*SSELECT*"
*#
*#       Clear screen.
PRINT @(0,5):CLS:
*#
*#       Lock User record.
*LOOP
*LCK.STAT = 1
*SYS.FILE = "SYS"; SYS.ITEM = "@SYS@USER@":USER.NAME
*CALL SYS.LOCK.ITEM
*WHILE LCK.STAT NE PORT+1 & LCK.STAT < 9000 DO REPEAT
**#       Record locked failed.
*IF LCK.STAT NE PORT+1 THEN
*ERROR.TEXT = "The reading of your user record was unsuccessful"
*ERROR.CODE = 15110
*GOSUB ERROR.CONTROL
*GOTO End.of.prog
**#
**#          Record lock successful.
*END ELSE
*READV TEMP FROM SY.FILE,SYS.ITEM,119 ELSE TEMP = 0
*IF TEMP = 0 THEN
*TEMP = PORT+1
*WRITEV TEMP ON SY.FILE,SYS.ITEM,119
*END
**#
**#    Update user at TCL
*STRUCT(119) = TEMP
*LCK.STAT = 0
*CALL SYS.UNLOCK.ITEM
**
*IF TEMP NE PORT+1 & TEMP > 0 THEN
*ERROR.TEXT = "you are using the TCL manager on PORT ":STRUCT(119)-1
*ERROR.CODE = 19110
*GOSUB ERROR.CONTROL
*********************GOTO End.of.prog
*END
*END
*
IF USER.ABORT ! SYS.ABORT THEN PRINT BELL:" ABORT!":; STOP
*
*
IF LEN(CO.DATA<1,1,1>) = 0 THEN CO.DATA<1,1,1> = SPACE(10)
SYS.PROG.DESC = "Macroscope TCL / Stack Manager for Company Code ":CO.DATA<3>
L.W = 0; L.W = 1; SCR.LINES = 10; SCR.HEADING = ""; VRF.EXTRA = 0
CPAGE = 0; MAX.L.W = 1; OUT.TO.PRINT = ""
SAVE.L.W = 1
SAVE.WAIT.FLAG = WAIT.FLAG; WAIT.FLAG = SAVE.WAIT.FLAG - 1
TCL.INIT = 1; REVIEW.FLAG = 2
*
LOOP WHILE TCL.INIT DO
LOOP
*
IF TCL.INIT THEN
TCL.INIT = 0
IF OLD.CALL.FUNCTION NE "" THEN GOSUB UPDATE.TO.DISK
SCR.HEADING = ""
IF REVIEW.FLAG = 2 THEN REVIEW.FLAG = 1 ELSE REVIEW.FLAG = ""
*
IF NOT(INDEX("*LOGGED*PRESTORED*SYS*","*":CALL.FUNCTION<1>:"*",1)) THEN
ERROR.TEXT = "Enter your function (LOGGED or PRESTORED or SYS) : "
ERROR.CODE = "19002"
GOSUB ERROR.CONTROL
TEMP = "*":TRIM(ERROR.RSP):"*"
IF INDEX(END.RSP,"*":TEMP:"*",1) THEN RETURN; * TO CALLING PROGRAM
IF ERROR.RSP EQ "" THEN ERROR.RSP = "LOGGED"
IF INDEX(TCL.RSP,TEMP,1) THEN
ERROR.RSP = "PRESTORED"
DISP.PRESTORE = "@LIST@HELP@TCL"
END
CALL.FUNCTION<1> = ERROR.RSP
END ELSE
ERROR.TEXT = CALL.FUNCTION<1>
ERROR.CODE = "19000"
GOSUB ERROR.CONTROL
END
TEMP1 = "LOAD":AM:"PURGE":AM:"LOGGED":AM:"PRESTORED":AM:"SYS"
LOCATE(CALL.FUNCTION<1>,TEMP1;TEMP) ELSE TEMP = 0
IF TEMP < 3 THEN TEMP = 0
IF TEMP NE 0 THEN TEMP = TEMP + 1
TCL.FUNC = TEMP
IF NOT(TCL.FUNC) THEN
ERROR.TEXT = "your entry was invalid"
ERROR.CODE = "15010"
GOSUB ERROR.CONTROL
CALL.FUNCTION<1> = ""; TCL.INIT = 2
END ELSE
*
*
IF TCL.FUNC EQ 4 OR TCL.FUNC EQ 6 THEN
IF TCL.FUNC EQ 4 THEN
CALL.FUNCTION<1> = "LOGGED"
*@*LOCK
SYS.ITEM = "@TCL@STACK@":CO.DATA<3>:"@":STRUCT(2)
READ P.S FROM SY.FILE,SYS.ITEM ELSE P.S = ""
END ELSE
*
CALL.FUNCTION<1> = "SYS"
SYS.ITEM= "@TCL@SYS@":CO.DATA<3>:"@":STRUCT(2)
P.S = CALL.SUB.FUNCTION
END
MAX.L.W = DCOUNT(P.S,AM)
IF MAX.L.W < 1 THEN MAX.L.W = 1
*
*
END ELSE IF TCL.FUNC >= 5 THEN
TCL.FUNC = 5
CALL.FUNCTION<1> = "PRESTORED"
*
* PRESTORE
*
MAX.L.W = 1
PRINT @(0,21):CLL:@(0,22):CLL:@(0,23):CLL:"Enter the PRESTORE ID you wish to display: ":
IF NUM(SUBR.FUNCTION<1>) & LEN(SUBR.FUNCTION<1>) > 0 THEN
IF DISP.PRESTORE EQ "" THEN DISP.PRESTORE = SUBR.FUNCTION<1> 
IF NUM(DISP.PRESTORE) THEN DISP.PRESTORE = STR("0",(5-LEN(DISP.PRESTORE))):DISP.PRESTORE
PRINT DISP.PRESTORE:
END ELSE
IF DISP.PRESTORE EQ "" THEN INPUT DISP.PRESTORE:
CALL DATASENSE.UPPER.CASE(DISP.RESTORE)
END
SUBR.FUNCTION<1> = ""
*IF NOT(NUM(DISP.PRESTORE)) THEN DISP.PRESTORE = TCL.NUM
*IF LEN(DISP.PRESTORE) = 0 THEN DISP.PRESTORE = TCL.NUM
IF NUM(DISP.PRESTORE) THEN DISP.PRESTORE = STR("0",5-LEN(DISP.PRESTORE)):DISP.PRESTORE
*
PRINT @(0,21):CLL:@(0,22):CLL:@(0,23):CLL:"Should I print it on the printer? ":
YES.NO = ""
INPUT YES.NO:
IF INDEX(YES,"*":YES.NO:"*",1) NE 0 THEN
OUT.TO.PRINT = 1
END ELSE OUT.TO.PRINT = ""
*
*@*LOCK
P.S = ""
P.S.FLAG = 1
IF DISP.PRESTORE[1,10] EQ "@LIST@HELP@" THEN
SYS.ITEM = "@TCL@":CO.DATA<3>:"@":DISP.PRESTORE
READ TCL.REC FROM PS.FILE,SYS.ITEM ELSE P.S.FLAG = 0
END ELSE
SYS.ITEM = "@TCL@":CO.DATA<3>:"@":DISP.PRESTORE
READ TCL.REC FROM PS.FILE,SYS.ITEM ELSE P.S.FLAG = 0
END
IF P.S.FLAG THEN
P.S = DELETE(TCL.REC,1)
!
MAX.L.W = DCOUNT(TCL.REC,AM)
IF MAX.L.W LE 1 THEN MAX.L.W = 1
DISP.TCL.DESC = TCL.REC<1>
IF WAIT.FLAG OR NOT(LEN(DISP.TCL.DESC)) THEN
PRINT @(0,23):CLL:BELL:"Enter Function Desc for NE ":DISP.PRESTORE "L#6":" : ":DISP.TCL.DESC "L#45":
DISP.TCL.DESC = DISP.PRESTORE
PRINT @(31):
RSP = ""
INPUT RSP:
IF LEN(RSP) > 0 THEN DISP.TCL.DESC = RSP
TCL.REC<1> = DISP.TCL.DESC
END
SCR.HEADING = "***** Function NE ":DISP.PRESTORE:", ":DISP.TCL.DESC:" *****"
*@*FUNCTION<1>S
END ELSE
ERROR.TEXT = "This item does not exist..."
ERROR.CODE = "19010"
TCL.REC = DISP.PRESTORE:AM:"TIME":AM:"WHO":AM:"WHERE"
GOSUB ERROR.CONTROL
*@*UNLOCK
CALL.FUNCTION<1> = "PRESTORED"
END
END ELSE
CALL.FUNCTION<1> = "PRESTORED"
END
*
OLD.CALL.FUNCTION = CALL.FUNCTION<1>
END
END
*
WHILE TCL.INIT DO REPEAT
!
*
IF NOT(OUT.TO.PRINT) THEN
PRINT @(0,18):CLL:"Thank you . . .":
RQM
END
*
GOSUB SYS.HEADING
*
CPAGE1 = 1
L.W = MAX.L.W; CPAGETEN = INT((L.W - 1) / SCR.LINES) * SCR.LINES; CPAGE = INT(L.W/SCR.LINES) + 1; CONT.DISP = 2; PR.FL = 0; PR.DISP = 2
PURGED = 0; TOP.DISPLAY.FLAG = 0; FIRST = 1
SAVE.L.W = L.W
GOSUB S.DISP
*
IF OUT.TO.PRINT THEN
OUT.TO.PRINT = ""
PRINTER CLOSE
SCR.HEADING = ""
ERROR.TEXT = "printing completed"
ERROR.CODE = "19010"
GOSUB ERROR.CONTROL
PRINTER CLOSE
CALL.FUNCTION<1> = ""; TCL.INIT = 3
END ELSE
REVIEW.FLAG = ""
IF CALL.FUNCTION<1> = "PRESTORED" THEN
PRINT @(0,21):CLS:"Function NE ":DISP.PRESTORE:", ":TCL.REC<1>[1,60]:
END
!
CONT0 = 1; CONT1 = 1
LOOP WHILE CONT0 AND NOT(TCL.INIT) DO
CONT0 = 1
PRINT @(0,21):CLL:@(0,22):CLL:@(0,23):CLL:"Enter the item you wish to access: ":
*IF LEN(SUBR.FUNCTION<1>) NE 0 THEN L.W = "" ELSE INPUT L.W:
*INPUT L.W:
*IF NOT(FIRST) THEN F.T = "" ELSE F.T =  "R"; FIRST = ""
FIRST = ""
F.T = ""
CONT3 = 1
LOOP
IF SYS.PRINT THEN PRINT @(40,23):RVB:"PRINT" "L#8":RVE:"  ": ELSE PRINT @(40,23):SPACE(10):
IF SYS.RECORD THEN PRINT @(50,23):RVB:"RECORD" "L#8":RVE:"  ": ELSE PRINT @(50,23):SPACE(10):
L.ADJ = 0
*
*
IF NOT(OUT.TO.PRINT) THEN PRINT @(0,L.W-CPAGETEN+7):CLL:"  ":RVB:"[=>":@(5):
P.V = P.S<L.W>
P.V3 = P.V<1,3>
P.V2 = P.V<1,2>
P.V1 = P.V<1,1>
*
PRINT L.W "R#3":"| ":
*IF PR.FL & NOT(OUT.TO.PRINT) THEN
IF NOT(OUT.TO.PRINT) THEN
PRINT RVB:P.V2 "L#60":"  ":FIELD(P.V1,"*",1) "L#1":" |":@(75):"<=]":RVE:@(0):
END ELSE
PRINT P.V2 "L#55":"  ":FIELD(P.V1,"*",1) "L#1":
END
ECHO OFF
INPUT IC,1:
ECHO ON
IF IC EQ CHAR(27) OR IC EQ CHAR(251) THEN
F.T = "END"
CONT3 = 0
IC = 13
END
CALL DATASENSE.UPPER.CASE(IC)
IF IC EQ "E" THEN F.T = IC; IC = 11; CONT3 = 0
IF IC EQ "." THEN F.T = ""; IC = -1
IF IC EQ "G" THEN
INPUT TEMP:
IF NUM(TEMP) THEN
L.ADJ = TEMP - L.W
END
IC = 10
END
IF NOT(NUM(IC)) THEN IC=10
BEGIN CASE
CASE IC EQ 0
L.ADJ = CPAGETEN + SCR.LINES - L.W
CASE IC = -1
L.ADJ = CPAGETEN - L.W + 1
CASE IC EQ 1
L.ADJ = MAX.L.W - L.W
CASE IC EQ 2
L.ADJ = 1
CASE IC EQ 3
L.ADJ = SCR.LINES
CASE IC EQ 4
L.ADJ = -1
CASE IC EQ 5
CONT3 = 0
F.T = "E"
CASE IC EQ 6
L.ADJ = 1
CASE IC EQ 7
L.ADJ = -CPAGETEN + 1 - L.W
CASE IC EQ 8
L.ADJ = -1
CASE IC EQ 9
L.ADJ = -SCR.LINES
CASE IC EQ ""
*F.T = "END"
CONT3 = 0
CASE 1
PRINT BELL:
END CASE
PRINT @(0,L.W-CPAGETEN+7):"    ":@(70):"   ":
GOSUB P.TASK
L.W = L.W + L.ADJ
IF L.W LT 1 THEN L.W=1
IF L.W LE CPAGETEN OR L.W GT CPAGETEN+SCR.LINES THEN
GOSUB SYS.HEADING
PR.DISP = 2
GOSUB S.DISP
END
WHILE CONT3 DO REPEAT
*
IF NOT(LEN(L.W)) THEN L.W = SAVE.L.W
IF LEN(L.W) = 0 THEN L.W = MAX.L.W
IF NOT(NUM(L.W)) THEN L.W = 1
IF L.W < 1 THEN L.W = 1
*
IF L.W NE "END" THEN
IF NOT(NUM(L.W)) THEN
ERROR.TEXT = "Sorry but your entry must be numeric!"
ERROR.CODE = "19010"
GOSUB ERROR.CONTROL
END ELSE
IF L.W > MAX.L.W THEN
ERROR.TEXT = "WARNING!! Entry is greater than your highest item number!"
ERROR.CODE =  "19010"
GOSUB ERROR.CONTROL
END
*
PR.FL = 1
IF L.W = 0 AND CALL.FUNCTION<1> NE "PRESTORED" THEN L.W = MAX.L.W
IF L.W > 0 THEN
IF L.W LE CPAGETEN OR L.W GT CPAGETEN+SCR.LINES THEN
PR.DISP = 2
GOSUB S.DISP
END
*PR.DISP = 1
PR.FL = 1
P.V = P.S<L.W>
GOSUB P.TASK
END
CONT1 = 1
!
LOOP WHILE CONT1 AND NOT(TCL.INIT) DO
CONT1 = 1
PRINT @(0,21):CLL:RVB:
IF F.T = "" THEN
PLINE ="  (E)xecute or (.), (R)edisplay, (A)dd, (M)odify, (D)elete, insert a (L)ine, "
PRINT PLINE "L#75":
END
PRINT @(0,22):CLL:
IF F.T = "" THEN
PLINE = "(F)uction #, (PRESTORE), (V)iew, (PRINT), or (N,O,I,H,C,Z, or X) . . . "
PRINT PLINE "L#75":RVE:
END
PRINT @(0,23):CLL:RVB:"[=|":RVE:
IF SYS.LIST THEN
PRINT "> ":
END ELSE
PRINT ": ":
END
PRINT @(74):RVB:" |<=]":RVE:@(5):
IF F.T = "" THEN
INPUT F.T,1:
END ELSE PRINT F.T:
TEMP = ""
P.DEST = 0
IF F.T = "5" THEN F.T = "E"
CALL DATASENSE.UPPER.CASE(F.T)
IF INDEX("*.*E*P*F*","*":F.T:"*",1) THEN
INPUT TEMP:
IF TEMP EQ "E" OR TEMP = "." OR TEMP = "D" THEN TEMP = ""
IF NUM(TEMP) THEN
IF TEMP > 0 THEN TEMP = " ":TEMP ELSE TEMP = " 1"
END
F.T = F.T:TEMP
END
IF F.T[1,1] = "." THEN
IF F.T NE "." THEN
* Load test on to bottom of STACK.
F.T = F.T[2,999]
MAX.L.W = MAX.L.W + 1
L.W = MAX.L.W
P.S<MAX.L.W,2> = F.T
* set fuction to execute current STACK #.
F.T = "E"
END; * of text or execute STACK #.
END; * of F.T EQ "."
*IF F.T EQ "E" THEN F.T = P.S<L.W,2>
*PRINT F.T:
IF F.T[1,1] EQ "E" THEN
P.DEST = FIELD(F.T," ",2)
F.T =FIELD(F.T," ",1)
IF NOT(NUM(P.DEST)) THEN P.DEST = L.W
IF P.DEST < L.W + P.DEST THEN P.DEST = L.W + P.DEST - 1
IF P.DEST < L.W THEN P.DEST = L.W
SUBR.FUNCTION<1> = ""
END
*
*PRINT @(0,21):CLS:
*
IF F.T EQ CHAR(27) OR F.T EQ CHAR(251) THEN CONT1 = 0; F.T = "END" ELSE
*
IF F.T[1,4] = "WAIT" THEN
WAIT.TEMP = F.T
GOSUB WAIT.RTN
F.T = ""
*
END ELSE IF INDEX("*F*END*E*.*R*PRINT*A*M*D*L*PRESTORE*V**N*O*I*H*C*Z*X*","*":F.T[1,1]:"*",1) = 0 THEN 
ERROR.TEXT = "Sorry but (":F.T:") is an invalid action!"
ERROR.CODE =  "19000"
GOSUB ERROR.CONTROL
F.T = ""
*
END ELSE IF L.W = 0 THEN
IF INDEX("*R*L*D**","*":F.T:"*",1) = 0 & MAX.L.W NE 0 THEN
L.W = MAX.L.W
CONT1 = 0
END ELSE
ERROR.TEXT = "Sorry  but zero is not a valid number for that action!"
ERROR.CODE = "19000"
GOSUB ERROR.CONTROL
RQM
END
*#
END ELSE IF L.W > MAX.L.W & F.T NE "A" & F.T NE "L" THEN
ERROR.TEXT = "Entry is greater than your highest item number!"
ERROR.CODE = "19000"
GOSUB ERROR.CONTROL
CONT1 = 0
RQM
END ELSE CONT1 = 0
END; * OF F.T NE "END"
REPEAT
!
*
IF F.T NE "END" OR F.T EQ "F10" THEN
P.V = P.S<L.W>
*
IF F.T[1,1] EQ "F" THEN
LOOP F.T = F.T[2,99] WHILE F.T[1,1] EQ " " OR NOT(NUM(F.T[1,1])) DO REPEAT
IF NOT(NUM(F.T)) THEN F.T = 1
IF F.T < 1 OR F.T > 10 THEN F.T = 1
IF F.T EQ 1 THEN GOSUB HELP.CONTROL
IF F.T EQ 3 THEN SYS.PRINT = 1 ELSE
IF F.T EQ 4 THEN SYS.PRINT = "" ELSE
IF F.T EQ 5 THEN SYS.RECORD = 1 ELSE
IF F.T EQ 6 THEN SYS.RECORD = ""
END
END
END
IF SYS.PRINT THEN PRINT @(40,23):RVB:"PRINT" "L#8":RVE:"  ": ELSE PRINT @(40,23):SPACE(10):
IF SYS.RECORD THEN PRINT @(50,23):RVB:"RECORD" "L#8":RVE:"  ": ELSE PRINT @(50,23):SPACE(10):
!
END ELSE IF (F.T[1,1] EQ "E" OR F.T[1,1] EQ ".") AND L.W NE 0 THEN
GOSUB CLEAR.PORT
IF NOT(NUM(L.W)) THEN L.W = MAX.L.W
IF L.W < 0 OR L.W > MAX.L.W THEN L.W = MAX.L.W
IF L.W < 1 THEN L.W = 1
IF CPAGE1 = INT(( L.W - 1) / SCR.LINES) + 1 THEN
PR.FL = 0
P.V = P.S<L.W>
GOSUB P.TASK
END
PRINT @(0,5):CLS
USER.ABORT = ''
LOOP UNTIL L.W GT P.DEST OR L.W GT MAX.L.W AND NOT(USER.ABORT) DO
EXEC.RESULTS = ""
EXEC.VERB = P.S<L.W,2>
*
IF EXEC.VERB[1,1] EQ "." THEN
* Load addition text to execute text.
PRINT @(0):CLL:RVB:"[?| ":@(75):" |?]":RVE:@(5):EXEC.VERB[2,999]:BELL:
INPUT TEMP:
EXEC.VERB = EXEC.VERB[2,999]:TEMP
END ELSE
PRINT @(0):CLL:EXEC.VERB:
END
*#
PRINT
EXEC.INPUT = ""
LOOP
EXEC.TEMP = PS.<L.W+1,2>
PRINT EXEC.TEMP:
WHILE EXEC.TEMP[1,1] EQ "+" DO
EXEC.TEMP = EXEC.TEMP[2,999]
IF EXEC.TEMP[1,1] EQ "." THEN
PRINT BELL:
INPUT RSP:
EXEC.TEMP = EXEC.TEMP:RSP
END
EXEC.INPUT<-1> = EXEC.TEMP
L.W = L.W + 1
REPEAT
IF LEN(EXEC.INPUT) THEN EXEC.INPUT.FLAG = TRUE ELSE EXEC.INPUT.FLAG = FALSE
*#
PRINT
*PRINT EXEC.VERB
WORD = FIELD(EXEC.VERB," ",1)
WORD = "*":WORD:"*"
IF NOT(SYS.LIST) THEN
*# no List currently in effect
*# Is a new LIST being formed?
*WORD = FIELD(EXEC.VERB," ",1)
SYS.LIST = INDEX(LIST.RSP,WORD,1)
IF SYS.LIST THEN
* a new LIST is being formed
IF NOT(EXEC.INPUT.FLAG) THEN
EXECUTE EXEC.VERB, //SELECT. > SLIST, //OUT. > EXEC.RESULTS
END ELSE
EXECUTE EXEC.VERB, //SELECT. > SLIST, //IN. < EXEC.INPUT, //OUT. > EXEC.RESULTS
END
END ELSE
* No LIST in effect.
BATCH.FLAG = INDEX(BATCH.RSP,WORD,1)
IF BATCH.FLAG THEN
IF INDEX(FIELD(FIELD(EXEC.VERB,"(",2),")",1),"P",1) THEN BATCH.FLAG = 0
END
IF BATCH.FLAG OR SYS.RECORD OR SYS.PRINT THEN
*# a Batch command with no previous List
IF NOT(EXEC.INPUT.FLAG) THEN
EXECUTE EXEC.VERB, //OUT. > EXEC.RESULTS
END ELSE
EXECUTE EXEC.VERB, //OUT. > EXEC.RESULTS, //IN. < EXEC.INPUT
END
END ELSE
*# a Normal command with no previous List
IF NOT(EXEC.INPUT.FLAG) THEN
EXECUTE EXEC.VERB
END ELSE
EXECUTE EXEC.VERB, //IN. < EXEC.INPUT
END
END
END; * of no previous LIST
END ELSE
* a LIST is already in use.
*WORD = FIELD(EXEC.VERB," ",1)
IF INDEX(LIST.RSP,WORD,1) THEN
*# another List command
EXECUTE EXEC.VERB, //SELECT. < SLIST, //SELECT. > SLIST, //OUT. > EXEC.RESULTS
SYS.LIST = 1
END ELSE
*# not a List command
BATCH.FLAG = INDEX(BATCH.RSP,WORD,1)
IF BATCH.FLAG THEN
IF INDEX(FIELD(FIELD(EXEC.VERB,"(",2),")",1),"P",1) THEN BATCH.FLAG = 0
END
IF BATCH.FLAG OR SYS.RECORD OR SYS.PRINT THEN
*# Batch command from List
EXECUTE EXEC.VERB, //SELECT. < SLIST, //OUT. > EXEC.RESULTS
END ELSE
*# Normal command from List
EXECUTE EXEC.VERB, //SELECT. < SLIST
END
SYS.LIST = ""
END; *# of not a List command
END; * of a previous existing LIST
*SYS.ITEM = "@TCL@":CO.DATA<3>:"@LOG@":(100000+DATE())[2,5]:(100000+TIME())[2,5]
SYS.ITEM = "@TCL@":CO.DATA<3>:"@LOG@":(100000+DATE())[2,5]
*:(100000+TIME())[2,5]
READ LOG.ITEM FROM SY.FILE,SYS.ITEM ELSE LOG.ITEM = ""
TEMP = "[=== ":STRUCT(2):" === ":TIMEDATE():" ===] "
IF SYS.PRINT THEN
PRINTER ON
PRINT
PRINT TEMP
PRINT EXEC.VERB
PRINTER OFF
END
LOG.ITEM = LOG.ITEM:AM:TEMP:AM:EXEC.VERB
IF LEN(EXEC.INPUT) THEN LOG.ITEM = LOG.ITEM:AM:EXEC.INPUT
LOG.ITEM = LOG.ITEM:AM:EXEC.RESULTS
WRITE LOG.ITEM ON PS.FILE,SYS.ITEM
IF LEN(EXEC.RESULTS) THEN
LOOP WHILE LEN(EXEC.RESULTS) DO
PRINT RVB:"[=| ":RVE:EXEC.RESULTS<1> "L#70":" ":RVB:" |=]":RVE
IF SYS.PRINT THEN
PRINTER ON
PRINT RVB:"[=| ":RVE:EXEC.RESULTS<1> "L#70":" ":RVB:" |=]":RVE
PRINTER OFF
END
DEL EXEC.RESULTS<1>
$INCLUDE IBP SYS.INCL.11.ABORT
REPEAT
END
L.W = L.W + 1
RQM; RQM
REPEAT
PRINT
PRINT
PRINT
PRINTER CLOSE
L.W = SAVE.L.W
ERROR.TEXT = "Enter <CR> to return the TCL Monitor. . . "
ERROR.CODE = "19002"
GOSUB ERROR.CONTROL
GOSUB RECORD.PORT
PR.FL = 1
GOSUB SYS.HEADING
P.V = P.S<L.W>
PR.DISP = 2
GOSUB S.DISP
CONT1 = 1
*
END ELSE IF F.T = "PRESTORED" THEN
F.T = ""; TCL.INIT = 4; CALL.FUNCTION<1> = "PRESTORED"
*
END ELSE IF F.T = "V" THEN
SUBR.FUNCTION = 2:AM:SUBR.FUNCTION
SUBR.SUB.FUNCTION = H.T:AM:SUBR.SUB.FUNCTION
CALL SYS.TCL.HTROUTINE
P.ENT = SUBR.FUNCTION
H.T = SUBR.SUB.FUNCTION
SUBR.FUNCTION = DELETE(SUBR.FUNCTION,1)
SUBR.SUB.FUNCTION = DELETE(SUBR.SUB.FUNCTION,1)
PRINTER CLOSE
*
END ELSE IF F.T = "R" THEN
F.T = ""; TCL.INIT = 5; CALL.FUNCTION<1> = ""
*
END ELSE IF F.T = "PRINT" THEN
F.T = ""; TCL.INIT = 6; OUT.TO.PRINT = 1
*
END ELSE IF F.T = "M" THEN
P.V = P.S<L.W>
P.ENT = ""
CALL SYS.TCL.INPUT(F.T,CONT.DISP,SCR.LINES,L.W,P.S,P.V,P.ENT,DISP.PRESTORE)
IF P.ENT NE "END" THEN GOSUB P.TASK
CONT0 = 1
*
END ELSE IF F.T[1,1] = "D" THEN
P.DEST = FIELD(F.T," ",2)
F.T =FIELD(F.T," ",1)
IF NOT(NUM(P.DEST)) THEN P.DEST = 1
YES.NO = "N"
ERROR.TEXT = "Are you sure?"
ERROR.CODE = "19012"
GOSUB ERROR.CONTROL
IF INDEX(YES,"*":ERROR.RSP:"*",1) NE 0 THEN
FOR A = 1 TO PDEST
P.S = DELETE(P.S,L.W)
MAX.L.W = MAX.L.W - 1
NEXT A
END
PR.DISP = 2
GOSUB S.DISP
CONT0 = 1
*
END ELSE IF INDEX("*N*I*O*H*C*X*Z*","*":F.T:"*",1) THEN
P.V1 = P.S<L.W,1>
P.V1 = F.T:"*":USER.NAME:"*":DATE():"*":TIME():"*":WHO:SVM:P.V1
P.S<L.W,1> = P.V1
*
END ELSE IF F.T = "A" ! F.T = "L" THEN
PRINT @(0,11):CLS
L.W1 = 0
P.SAVE = ""
LOOP
L.W1 = L.W1 + 1
WHILE (F.T = "A" & L.W1 < (L.W + 1)) ! (F.T = "L" & L.W1 < L.W) DO
IF P.S<L.W1> = "" THEN P.S<L.W1> = " "
P.SAVE<L.W1> = P.S<L.W1>
REPEAT
L.W1 = L.W1 - 1
L.W2  = L.W1
P.SAVE1 = ""
LOOP
L.W2 = L.W2 + 1
WHILE P.S<L.W2> NE "" DO
P.SAVE1<L.W2-L.W1> = P.S<L.W2>
REPEAT
PR.DISP = 0
L.W = 0
CONT.DISP = 1
P.S = ""
PR.FL = 0
GOSUB S.DISP
IF LEN(P.S) > 0 THEN
IF P.SAVE1<1> NE "" THEN P.S = P.S:AM
P.S = P.S:P.SAVE1
END ELSE
P.S = P.SAVE1
END
IF P.S <1> NE "" & LEN(P.SAVE) NE 0 THEN
P.S = P.SAVE:AM:P.S
END ELSE P.S = P.SAVE:P.S
MAX.L.W = MAX.L.W + 1
PR.DISP = 2
P.SAVE=''; P.SAVE1=''
GOSUB S.DISP
CONT0 = 1
*
END ELSE
IF L.W NE 0 THEN
P.V = P.S<L.W>
GOSUB P.TASK
END
CONT0 = 1
END
*IF L.W NE 0 THEN
*CPAGE = INT(( L.W - 1) / SCR.LINES) + 1; *# S.DISP
*CPAGE1 = CPAGE
*SAVE.L.W = L.W
*END
END ELSE CONT0 = 0; * F.T = "END"
END; * OF NUM LINE NUMBER
END; * OF LINE NUMBER NE "END"
REPEAT; * OF CONT0 AND NOT(TCL.INIT)
END; * OF NOT(OUT.TO.PRINT)
!
*
IF NOT(TCL.INIT) THEN
YES.NO = ""
ERROR.TEXT = "Enter <CR> to return the menu. . . "
ERROR.CODE = "19002"
GOSUB ERROR.CONTROL
IF INDEX(NO,"*":ERROR.RSP:"*",1) NE 0 THEN
TCL.INIT = 9; CALL.FUNCTION<1> = ""
END
END
*
REPEAT; * FOR TCL.INIT
!
*
*IF OLD.CALL.FUNCTION NE "" THEN GOSUB UPDATE.TO.DISK
GOSUB UPDATE.TO.DISK
WAIT.FLAG = SAVE.WAIT.FLAG
*
End.of.prog: * bypass GOTO for abnormal end.
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
RETURN
*
!
*
*
*
*
$INCLUDE IBP SYS.TCL.PTASK
*
!
S.DISP: * Loop to display screen
*
SAVE.L.W = L.W
CPAGE = INT(( L.W - 1) / SCR.LINES) + 1
*
IF OUT.TO.PRINT THEN
SCR.LINES = 30
END ELSE
SCR.LINES = 10
PRINT @(0,6):CLS:RVB:"   Item | LINE ===========================================================|":RVE:"Page":
PRINT @(0,7):RVB:"  =======|================================================================|":RVE:" ":CPAGE1 "R#2":
END
VRF.EXTRA = 0
YES.NO = ""
*
*
IF PR.DISP = 1 THEN
CPAGE = 1
SAVE.L.W = 1
L.W = 0
END ELSE IF PR.DISP = 2 THEN
L.W = INT((L.W - 1) / SCR.LINES) * SCR.LINES
IF L.W < 0 THEN L.W = 0
END ELSE
L.W = INT(L.W/SCR.LINES) * SCR.LINES
END
CPAGE1 = INT(( L.W - 1) / SCR.LINES) + 1
CPAGETEN = INT(( L.W - 1) / SCR.LINES ) * SCR.LINES
*
*
CONT.DISP = 1
MAX.L.W = DCOUNT(P.S,AM)
LOOP
L.W = L.W + 1; VRF.EXTRA = VRF.EXTRA + 1
P.V = P.S<L.W>
*
IF (PR.DISP AND L.W GT CPAGE*SCR.LINES) THEN
CONT.DISP = 0
END ELSE IF L.W > MAX.L.W THEN
CONT.DISP = 0
END
*
WHILE CONT.DISP DO
YES.NO = ""
IF L.W > CPAGETEN+SCR.LINES OR VRF.EXTRA > 45 THEN
IF OUT.TO.PRINT THEN
YES.NO = "N"
WAIT.FL = 1
END ELSE IF PR.DISP = 2 THEN
IF L.W < CPAGE*SCR.LINES AND L.W < MAX.L.W THEN
YES.NO = "N"
WAIT.FL = 1
END ELSE YES.NO = ""
END
IF NOT(OUT.TO.PRINT) AND (NOT(WAIT.FLAG) AND YES.NO NE "N") OR PR.DISP < 1 THEN
YES.NO = ""
PRINT @(0,23):CLL:'Enter "N" for next page or <CR> to end... ':
IF PR.DISP LT 2 THEN INPUT YES.NO,1:
CALL DATASENSE.UPPER.CASE(YES.NO)
IF YES.NO[1,4] = "WAIT" THEN
WAIT.TEMP = YES.NO
GOSUB WAIT.RTN
YES.NO = "N"
END
IF YES.NO NE "N" THEN
CONT.DISP = 0
CPAGE = CPAGE1
L.W = CPAGE1*SCR.LINES - SCR.LINES + 1
SAVE.L.W = L.W
IF L.W LT 0 THEN L.W = 1
END ELSE
IF OUT.TO.PRINT THEN
VRF.EXTRA = 0
GOSUB SYS.HEADING
END ELSE
IF WAIT.FLAG AND WAIT.FL THEN FOR WAIT.TEMP = 1 TO WAIT.FLAG; RQM; NEXT WAIT.TEMP
PRINT @(0,6):CLS:RVB:"Item LINE...............................................[":MAX.L.W "R#3":" ]..":RVE:
VRF.EXTRA = 0
END
CPAGE1 = INT(( L.W - 1) / SCR.LINES) + 1; *# S.DISP
CPAGETEN = INT(( L.W - 1) / SCR.LINES ) * SCR.LINES
*CPAGE = INT(CPAGETEN / SCR.LINES) + 1
END
END
IF CONT.DISP AND NOT(PR.DISP) THEN
P.ENT = ""
CALL SYS.TCL.INPUT(F.T,CONT.DISP,SCR.LINES,L.W,P.S,P.V,P.ENT,DISP.PRESTORE)
END
IF OUT.TO.PRINT THEN
PRINTER ON
PRINT
PRINTER OFF
END
END
IF CONT.DISP AND P.ENT NE "END" THEN GOSUB P.TASK
REPEAT
IF PR.DISP THEN
MAX.L.W = DCOUNT(P.S,AM)
END
L.W = SAVE.L.W
CPAGE = CPAGE1
*
GOSUB UPDATE.TO.DISK
RETURN
*
!
*
UPDATE.TO.DISK: * Subroutine to update SPTM file with Daily records.
IF NOT(LEN(OLD.CALL.FUNCTION)) THEN OLD.CALL.FUNCTION = CALL.FUNCTION<1>
IF OLD.CALL.FUNCTION = "LOGGED" THEN
SYS.ITEM = "@TCL@STACK@":CO.DATA<3>:"@":STRUCT(2)
WRITE P.S ON SY.FILE,SYS.ITEM
WRITE.FLAG = ""
PRINT @(60,23):RVB:"Stack   ":@(70,23):"UPDated ":RVE:
END ELSE IF OLD.CALL.FUNCTION = "PRESTORED" THEN
IF DISP.PRESTORE[1,10] EQ "@LIST@HELP@" THEN
SYS.ITEM = "@TCL@":CO.DATA<3>:"@":DISP.PRESTORE
TCL.REC = TCL.REC<1>:P.S
WRITE TCL.REC ON PS.FILE,SYS.ITEM
END ELSE
SYS.ITEM = "@TCL@":CO.DATA<3>:"@":DISP.PRESTORE
TCL.REC = TCL.REC<1>:AM:P.S
WRITE TCL.REC ON PS.FILE,SYS.ITEM
END
WRITE.FLAG = ""
*ERROR.TEXT = "finished updating files."
*ERROR.CODE = "19010"
*GOSUB ERROR.CONTROL
PRINT @(60,23):RVB:"Prestore":@(70,23):"UPDated ":RVE:
END ELSE
PRINT @(70,23):"SKIpped ":
END
OLD.CALL.FUNCTION = CALL.FUNCTION<1>
RETURN
*
SYS.HEADING: *
*
$INCLUDE IBP SYS.HEADING
*
RETURN
*
HELP.CONTROL: *
*
EXECUTE "COPY SYS @DOC@SYS.TCL (T)"
PR.DISP = 2
GOSUB S.DISP
*
RETURN
*
!
*
$INCLUDE IBP SYS.TCL.UPD
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*
$INCLUDE IBP SYS.INCL.RECORD.TIME
*
$INCLUDE IBP SYS.INCL.RECORD.USER.CALL
*
END
~SYS.TCL.INPUT~
SUBROUTINE SYS.TCL.INPUT(F.T,CONT.DISP,SCR.LINES,L.W,P.S,P.V,P.ENT,DISP.PRESTORE)
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
SYS.PROG = "SYS.TCL.INPUT":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
SYS.PROG.DESC = "System Scheduler Input Line Subroutine"
*
*
CPAGETEN = INT( ( L.W - 1) / SCR.LINES ) * SCR.LINES
ENT.LN =L.W-CPAGETEN+7
P.V1 = P.V<1,1>
P.V2 = P.V<1,2>
P.V3 = P.V<1,3>
P.ENT = P.V2
INPUT @(10,ENT.LN):P.ENT:
IF LEN(P.ENT) = 0 THEN P.ENT = P.V2
IF P.ENT = "END" THEN CONT.DISP = 0 ELSE
P.V2 = P.ENT
P.ENT = P.V3
INPUT @(72,ENT.LN):P.ENT:
IF LEN(P.ENT) = 0 THEN P.ENT = P.V3
IF LEN(P.ENT) = 0 THEN P.ENT = "TCL I/II"
IF P.ENT = "END" THEN CONT.DISP = 0 ELSE
P.V3 = P.ENT
IF P.ENT = "H" OR P.ENT = "START" THEN
SAVE.F.T = F.T
F.T = P.ENT
CN = L.W
DATE.CODE.VM = 6
GOSUB INPUT.DATE.CODE
F.T = SAVE.F.T
IF P.ENT EQ "START" THEN SAVE.L.START = L.W
END ELSE IF P.ENT = "REPEAT" THEN
SAVE.F.T = F.T
F.T = P.ENT
CN = L.W
FREQ.VM = 7
GOSUB INPUT.FREQUENCY
F.T = SAVE.F.T
END
*IF F.T NE "M" THEN
P.V1 = F.T:"*":USER.NAME:"*":DATE():"*":TIME():SVM:P.V1
*END ELSE
*IF P.V<1,3> # P.ENT THEN P.V1 = P.ENT:"*":USER.NAME:"*":DATE():"*":TIME():SVM:P.V1
*END
END
END
IF P.ENT # "END" THEN
P.S<L.W,1> = P.V1
P.S<L.W,2> = P.V2
P.S<L.W,3> = P.V3
P.V = P.S<L.W>
PR.FL = 0
*GOSUB P.TASK
END
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
*
RETURN
*
$INCLUDE IBP SYS.INPUT.DATE.CODE
*
$INCLUDE IBP SYS.INPUT.FREQUENCY
*
!
END
~SYS.TEMP~
SUBROUTINE SYS.STEP
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
$INCLUDE IBP SYS.INCL.END.RSP
*
*
CLS.LO = 5
CLS.HI = 20
MENU.TYPE = "P"
TASK.CL = 0
TASK.LN = 5
TASK.RSP = 'INIT'
ERROR.RSP = 'INIT'
*
*
IF INDEX(SYS.PROG,"SYS.STEP",1) # 0 THEN RETURN
*
SYS.PROG = "SYS.STEP":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
*
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@USER@":CO.DATA<3>:"@":STRUCT(2):"@RECENT.TASK"
READ TASK.RECENT.REC FROM SY.FILE,SYS.ITEM ELSE TASK.RECENT.REC = ""
*
*
!
RECENT.TASK: * recently used task numbers
*#SYS.FILE = "PSD"; SYS.ITEM = PSD.KEY:"@":TIME.TEMP:"@":TEMP.KEY
*#WRITEV PSD.REC ON PS.FILE,SYS.ITEM,STRUCT(69)<1,PORT+1> + 1
*#PSD.REC = ""
*
*#
LOOP
*# FOR END OF PROGRAM OR TASK.SELECTED AND FOUND
LOOP
*# FOR TASK.RSP SELECTION  NUM
SYS.SLOC<1> = "RECENT.TASK"
*#SYS.FILE = "SYS"
*#SYS.ITEM = "@SYS@USER@":CO.DATA<3>:"@":STRUCT(2):"@RECENT.TASK"
*#READ TASK.RECENT.REC FROM SY.FILE,SYS.ITEM ELSE TASK.RECENT.REC = ""
IF TASK.RECENT.REC NE "" THEN
PRINT @(TASK.CL,TASK.LN):RVB:"Most.recently.used.tasks.are............." "L#25":RVE
PRINT @(TASK.CL,TASK.LN+1):RVB:"!":RVE:SPACE(23):RVB:"|":RVE:
TASK.MAX = DCOUNT(TASK.RECENT.REC,AM)
TASK.CN = 0
LOOP
*# LOOP FOR PRINT RECENT TASKS
TASK.CN = TASK.CN + 1
TASK.DESC = TASK.RECENT.REC<TASK.CN>
WHILE TASK.CN LE TASK.MAX AND NOT(SYSTEM(11)) DO
PRINT @(TASK.CL,TASK.LN+2+TASK.CN):RVB:"|":TASK.CN "R#4":RVE:" - ":TASK.DESC "L#15":" ":RVB:"|":RVE:
REPEAT
PRINT @(TASK.CL,TASK.LN+2+TASK.CN):RVB:STR("-",25):RVE:
*
END; *# OF TASK.RECENT.REC NE ''
*
LOOP
*# LOOP FOR TASK.RSP 'END'
ERROR.TEXT = "Enter the number of your selection: "
ERROR.CODE = "1910221"
GOSUB ERROR.CONTROL
TASK.RSP = ERROR.RSP
WHILE TASK.RSP = "" AND NOT(INDEX(END.RSP,"*":TASK.RSP:"*",1)) DO REPEAT
TEMP = ''
IF NUM(TASK.RSP) THEN
IF TASK.RSP > TASK.MAX THEN TEMP = 1
END ELSE TEMP = 1
WHILE TEMP AND NOT(INDEX(END.RSP,"*":TASK.RSP:"*",1)) DO REPEAT
*
*
*#
*#
IF TASK.RSP NE '' AND NUM(TASK.RSP) THEN
IF TASK.RSP LE TASK.MAX THEN
TASK.NUM = TASK.RECENT.REC<TASK.RSP>
LOC = 0
FOUND = 1
LOCATE TASK.NUM IN TASK.RECENT.REC<1> BY "AL" SETTING LOC ELSE FOUND = 0
IF NOT(FOUND) THEN LOC = 10
TASK.RECENT.REC<1> = DELETE(TEMP<1>,1,LOC)
TASK.RECENT.REC<2> = DELETE(TEMP<2>,1,LOC)
TASK.RECENT.REC<1> = TASK.NUM:VM:TEMP<1>
TASK.RECENT.REC<2> = TASK.STEP:VM:TEMP<2>
WRITE TASK.RECENT.REC ON SY.FILE,SYS.ITEM
END; *# OF LE TASK.MAX
END; *# OF NUM(TASK.RSP)
IF FOUND THEN TASK.RSP = "END"
WHILE NOT(INDEX(END.RSP,"*":TASK.RSP:"*",1)) DO REPEAT
*
!
*
SYS.PROG = DELETE(SYS.PROG,1,0,0)
SYS.LOCT = DELETE(SYS.LOCT,1,0,0)
SYS.SLOC = DELETE(SYS.SLOC,1,0,0)
*
*
RETURN; *# To CALLing program
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*
END
~SYS.UL~
*PROGRAM: USERS
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       DISPLAYS USER STATUS
* DATE RELEASED:     22 OCT 82
!
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
!
OPEN "DICT","ACC" TO D.AC.FILE ELSE STOP
OPEN "SYS" TO SY.FILE ELSE STOP
OPEN "ACC" TO AC.FILE ELSE STOP
PRINT @(0,0):CLS:"Port Account      Location             Date    Time   User.or.Activity":CR:LF
*EXECUTE 'SSELECT ACC < "A" WITH NAME.'
ID.PORT.LIST = "*0400*0420*0440*0460*0480*04A0*04C0*04E0*"
ID.MENU.LIST = "*"
FOR A = 0 TO 7; ID.MENU.LIST = ID.MENU.LIST:"MENU.0":A:"*"; NEXT A
ID.MAX = 8
ID.CN = 1
*#
NEXT.LINE: *#
*#
*READNEXT KEY ELSE
ID.CN = ID.CN + 1
*#
IF ID.CN GT ID.MAX THEN
PDATE = OCONV(DATE(),"D2"); PDATE = PDATE[1,2]:PDATE[4,3]:PDATE[8,2]
PRINT CR:LF:"Current date and time:" "L#39":PDATE "L#8":OCONV(TIME(),"MT")
PRINT
PRINT " HIT ANY KEY TO STOP DISPLAYS . . ."
PRINT
FOR A = 1 TO 10 UNTIL SYSTEM(11); RQM; NEXT A
IF NOT(SYSTEM(11)) THEN EXECUTE "SP-STATUS"
IF NOT(SYSTEM(11)) THEN RQM; RQM
IF NOT(SYSTEM(11)) THEN EXECUTE "WHERE"
IF NOT(SYSTEM(11)) THEN RQM; RQM
IF NOT(SYSTEM(11)) THEN EXECUTE "WHAT"
IF NOT(SYSTEM(11)) THEN RQM; RQM
INPUTCLEAR
STOP
*#
END ELSE
KEY = FIELD(ID.MENU.LIST,"*",ID.CN)
END
*#
ALT.KEY = FIELD(ID.PORT.LIST,"*",ID.CN)
*#
READV ALT.ACCT FROM AC.FILE,ALT.KEY,1 THEN
READV ACCT FROM AC.FILE,KEY,1 ELSE
ACCT = ALT.ACCT
END
DEL.FLAG = FALSE
*#
END ELSE
ACCT = "none"
DEL.FLAG = TRUE
END
*#
DISP.PORT = OCONV(ALT.KEY,"U3079"); KEY = DISP.PORT[LEN(DISP.PORT)-1,2]
*#
READ ITEM FROM AC.FILE,"MENU.":KEY THEN
IF DEL.FLAG THEN DELETE AC.FILE,"MENU.":KEY
END ELSE ITEM = ""
*#
READ ITEM FROM SY.FILE,"MENU.":KEY THEN
IF DEL.FLAG THEN DELETE SY.FILE,"MENU.":KEY
END ELSE
TEMP = STR("0",5-LEN(DATE())):DATE():STR("0",5-LEN(TIME())):TIME()
IF NOT(LEN(ITEM)) THEN
ITEM = AM:"no user on this port":AM:TEMP:AM:"":AM
DEL.FLAG = FALSE
END
END
*#
PDATE = OCONV(ITEM<3>[1,5],"D2"); PDATE = PDATE[1,2]:PDATE[4,3]:PDATE[8,2]
READV LOC FROM D.AC.FILE,"0":KEY,1 ELSE LOC = ""
PRINT DISP.PORT "L#5":ACCT "L#12":" ":LOC "L#20":" ":PDATE "L#8":OCONV(ITEM<3>[6,5],"MT") "L#7":ITEM<2> "L#20":
*#
IF DEL.FLAG THEN PRINT RVB:"***":RVE ELSE PRINT
*#
GOTO NEXT.LINE
*#
END
~SYS.UNLOCK.ITEM~
SUBROUTINE SYS.UNLOCK.ITEM
*
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
*
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
*
!
*
* PROGRAM:           SYS.UNLOCK.ITEM
* AUTHOR:            David Horsman - AIM Services
* DESCRIPTION:       Unlock a record within SYS.STRUCT
*
*             RTRN.STAT      MEANING
*                0      SUCCESSFULLY UNLOCKED
*                #      ALREADY LOCKED AT ANOTHER TERMINAL
*              9999      OPERATOR 'KILL' REQUEST
*
!
*
SYS.PROG = "UNLOCK.ITEM":AM:SYS.PROG
SYS.LOCT = "OPEN":AM:SYS.LOCT
SYS.SLOC = "ERROR.CONTROL":AM:SYS.SLOC
SYS.PROG.TYPE = 8
EQ.PROG.TYPE = 8
EQ.PROG.STATUS = TRUE
ERROR.RSP = ""
*
RTRN.STAT = 0
*
SYS.LOCT<1> = "MAIN"
SYS.SLOC<1> = "READ"
!
* ATTEMPT TO READ THE LOCK ITEM
SYS.FILE = "SYS"
LOCK.ITEM.ID = "@LOCK@":SYS.FILE:"*":SYS.ITEM
READ UNLOCK.ITEM FROM SY.FILE,LOCK.ITEM.ID THEN
*
SYS.SLOC<1> = "CHECK.PORT"
IF UNLOCK.ITEM<1> # PORT+1 THEN
ERROR.TEXT = SYS.FILE:" ":LOCK.ITEM.ID:" was not locked by you"
ERROR.CODE = "17100"
GOSUB ERROR.CONTROL
END ELSE
*
SYS.SLOC<1> = "DELETE"
DELETE SY.FILE,LOCK.ITEM.ID
IF PORTD<5> = "D" THEN
ERROR.TEXT = SYS.FILE:" ":LOCK.ITEM.ID:" has been unlocked"
ERROR.CODE = "29000"
GOSUB ERROR.CONTROL
END
END
*
END ELSE
ERROR.TEXT = SYS.FILE:" ":LOCK.ITEM.ID:" was not on file for you"
ERROR.CODE = "17100"
GOSUB ERROR.CONTROL
END
*
LCK.STAT = RTRN.STAT
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
RETURN
*
!
$INCLUDE IBP SYS.ERROR.STRUCT
*
END
~SYS.USER.LIST~
SUBROUTINE SYS.USER.LIST
* PROGRAM:           USERS
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       DISPLAYS USER STATUS
* DATE RELEASED:     22 OCT 82
!
$INCLUDE IBP SYS.COMMON
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "DICT","ACC" TO D.AC.FILE ELSE STOP
OPEN "ACC" TO AC.FILE ELSE STOP
PRINT @(0,0):CLS:"Port Account      Location             Date    Time   User.or.Activity":CR:LF
EXECUTE 'SSELECT ACC < "A" WITH NAME.'
LOOP
CONT = 1
*NEXT.LINE:
READNEXT KEY ELSE
PDATE = OCONV(DATE(),"D2"); PDATE = PDATE[1,2]:PDATE[4,3]:PDATE[8,2]
PRINT CR:LF:"Current date and time:" "L#39":PDATE "L#8":OCONV(TIME(),"MT")
CONT = 0
END
WHILE CONT DO
ITEM.FOUND = 1
READV ACCT FROM AC.FILE,KEY,1 ELSE ITEM.FOUND = ''
IF ITEM.FOUND THEN
PORT = OCONV(KEY,"U3079"); KEY = PORT[LEN(PORT)-1,2]
READ ITEM FROM AC.FILE,"MENU.":KEY ELSE ITEM = ""
PDATE = OCONV(ITEM<3>[1,5],"D2"); PDATE = PDATE[1,2]:PDATE[4,3]:PDATE[8,2]
READV LOC FROM D.AC.FILE,"0":KEY,1 ELSE LOC = ""
PRINT PORT "L#5":ACCT "L#12":" ":LOC "L#20":" ":PDATE "L#8":OCONV(ITEM<3>[6,5],"MT") "L#7":ITEM<2> "L#25"
*GOTO NEXT.LINE
END
REPEAT
*
PRINT
*
PRINT " . . . ":
INPUT TEMP.RSP
PRINT
EXEC.PARAM = "LIST SYS ID-SUPP 1 2 0"
EXECUTE 'SSELECT SYS EQ "@SYS@USER@]"', //SELECT. > EXEC.LIST
EXECUTE EXEC.PARAM, //SELECT. < EXEC.LIST
PRINT
*
PRINT " . . . ":
INPUT TEMP.RSP
PRINT
*
PRINT
PRINT
PRINT "[":USER.NAME:"]"
DESC = ""
DESC<1> = "Active "
DESC<2> = "For user name "
DESC<3> = "Password is "
DESC<4> = "Company  is "
DESC<5> = "         ?? "
DESC<6> = "........... "
DESC<7> = "........... "
DESC<8> = "........... "
DESC<9> = "........... "
DESC<10>= "Number of waits is "
DESC<11> = "Frequency to view "
DESC<12> = "Frequency to purge is "
DESC<13> = ".......... "
DESC<14> = "Last Access by "
FOR A = 1 TO 14
*
PRINT "[":A "R#2":" . ":(DESC<A>:STRUCT(A)) "L#33":"]"
NEXT A
PRINT
PRINT " (D)aily, (W)eekly, (H)ourly, (M)onthly, etc. . . "
PRINT
PRINT " . . . ":
INPUT TEMP.RSP
PRINT
*
RETURN ; *# TO CALLING PROGRAM
*
END
~SYS.USER.LOAD~
SUBROUTINE SYS.USER.LOAD
*#    
$INCLUDE IBP SYS.COMMON
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
*#
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
*#
!
*#
SYS.PROG = 'SYS.USER.LOAD':AM:SYS.PROG
SYS.PROG.TYPE = 8
EQ.PROG.TYPE = 8
EQ.PROG.STATUS = TRUE
*#
SYS.LOCT = '':AM:SYS.LOCT
SYS.SLOC = '':AM:SYS.SLOC
SYS.PROG.DESC = "System User Load and Update"
*# 
*# PROGRAM:           SYS.USER.LOAD
*#    
*# AUTHOR:             DAVID HORSMAN
*# COMPANY:            APPROPRIATE INFORMATION MANAGEMENT
*# DATE WRITEN:        8 MAR 85
*# UPDATES:
*#    
DIM STR.REPLACE(120)
MAT STR.REPLACE = ""
FUNCTION = CALL.FUNCTION<1>
SUB.FUNCTION = CALL.SUB.FUNCTION<1>
*#    
SYS.SLOC<1> = "MAIN"
USER.LOCKED = 9999
SYS.FILE = "SYS"
FIRST = 0
ERROR.RSP = ""; ERROR.TEXT = ""; ERROR.CODE = ""
*#    
*#    
LOOP WHILE USER.LOCKED & USER.LOCKED # PORT + 1 & NOT(USER.ABORT ! SYS.ABORT) DO
*#    
IF SUB.FUNCTION = "READ" ! SUB.FUNCTION = "RESET" ! SUB.FUNCTION = "LOCK" THEN
IF USER.LOCKED = 9999 & SUB.FUNCTION = "RESET" THEN GOSUB EXTRACT.USER.DATA
GOSUB READ.USER.DATA
IF USER.LOCKED = PORT + 1 THEN
GOSUB SYS.CNTR
STRUCT(21)<1,PORT+1> = 1
IF SUB.FUNCTION = "RESET" THEN
ERROR.TEXT = "User data reset . . ."
ERROR.CODE = "19000"
GOSUB ERROR.CONTROL
END
END
*#    
END ELSE IF SUB.FUNCTION = "UPDATE" THEN
IF USER.LOCKED = 9999 THEN GOSUB EXTRACT.USER.DATA
GOSUB READ.USER.DATA
IF USER.LOCKED = PORT + 1 THEN GOSUB UPDATE.USER.DATA
*#    
END ELSE IF SUB.FUNCTION = "UNLOCK" THEN
PRINT @(0,23):CLL:BELL:SUB.FUNCTION:
*# 
END ELSE
ERROR.TEXT = "the activity requested is invalid"
ERROR.CODE = "13111"
GOSUB ERROR.CONTROL
END
*# 
REPEAT
*#    
*#    
IF SUB.FUNCTION = "UPDATE" ! SUB.FUNCTION = "UNLOCK" ! SUB.FUNCTION = "RESET" THEN
GOSUB WRITE.USER.DATA
END ELSE
IF SUB.FUNCTION # "LOCK" THEN GOSUB UNLCK.USER.DATA
END
*#    
STRUCT(51) = ""
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
CALL.FUNCTION = DELETE(CALL.FUNCTION,1)
CALL.SUB.FUNCTION = DELETE(CALL.SUB.FUNCTION,1)
RETURN
!
READ.USER.DATA: * Subroutine to read user control record
*#    
SYS.LOCT<1> = "READ.USER.DATA"
SYS.SLOC<1> = "READ"
*#    
Read.user.again: * Reloop point when user name # struct(2)
*# lock user record (not implemented)
IF STRUCT(2) # "" THEN STRUCT(2) = USER.NAME
LCK.STAT = 0
CALL SYS.LOCK.ITEM
*#    
IF LCK.STAT < 900 THEN
USER.LOCKED = LCK.STAT
IF  LCK.STAT # PORT + 1 THEN
ERROR.TEXT = "your control information is in use by port ":LCK.STAT+1
ERROR.CODE = "17110"
GOSUB ERROR.CONTROL
RETURN
END
END
*#    
*# 
CPORT = STRUCT(14)
*#    
MATREAD STRUCT FROM SY.FILE,SYS.ITEM THEN
*# 
IF USER.NAME # STRUCT(2) THEN
LCK.STAT = 0
CALL SYS.UNLOCK.ITEM
USER.NAME = STRUCT(2)
SYS.ITEM = "@SYS@USER@":USER.NAME
GOTO Read.user.again
END; *# OF USER.NAME # STRUCT(2)
*#    
IF NOT(STRUCT(15)<1,PORT + 1>) THEN
SYS.SLOC<1> = "VALID.PORTS"
SYS.ABORT = 1
ERROR.TEXT = "you are not allowed to use this port"
ERROR.TEXT = ERROR.TEXT:AM:"control over your port been taken from you"
ERROR.TEXT = ERROR.TEXT:AM:"ask you system manager about ":SYS.LOCT<1>:", ":SYS.SLOC<1>
ERROR.CODE = "13111":AM:"13111":AM:"11111"
GOSUB ERROR.CONTROL
END ELSE
*# ELSE OF NOT(STRUCT(15)<1,PORT + 1>) 
*# 
ERROR.TEXT = ""
ERROR.CODE = ""
USER.LOCKED = PORT + 1
*# 
IF FUNCTION[1,3] EQ "LOG" THEN
IF SUB.FUNCTION NE "READ" THEN
TEMP.PR = ""
*# 
IF NOT(STRUCT(21)<1,PORT+1>) THEN
IF CPORT NE PORT+1 AND CPORT THEN
ERROR.TEXT = ERROR.TEXT:AM:"set this port to your controlling port (":CPORT-1:")"
ERROR.CODE = ERROR.CODE:AM:"17112"
ERROR.RSP = "Y"
GOSUB ERROR.CONTROL
ERROR.TEXT = ""
ERROR.CODE = ""
IF ERROR.RSP EQ "Y" THEN
TEMP.PR <1> = RVB:"[":RVE:" ":RVB:"*":RVE:" ":STRUCT(29)<1,PORT+1> "L#10":" ":STRUCT(36)<1,PORT+1> "R#20":" ":"*-":STRUCT(61)<1,PORT+1> "R#5":"-":STRUCT(69)<1,PORT+1> "L#3":" ":STRUCT(62)<1,PORT+1> "L#29"
TEMP.PR<2> = RVB:"[":RVE:SPACE(2):" ":STRUCT(30)<1,PORT+1> "L#10":" ":STRUCT(32)<1,PORT+1> "L#10":" ":STRUCT(21)<1,PORT+1> "R#3":"  ":STRUCT(34)<1,PORT+1> "L#20":" ":STRUCT(33)<1,PORT+1> "L#20"
STRUCT(15)<1,PORT+1> = STRUCT(15)<1,CPORT>
STRUCT(21)<1,PORT+1> = 4
STRUCT(22)<1,PORT+1> = STRUCT(22)<1,CPORT>
STRUCT(23)<1,PORT+1> = STRUCT(23)<1,CPORT>
STRUCT(24)<1,PORT+1> = STRUCT(24)<1,CPORT>
STRUCT(25)<1,PORT+1> = STRUCT(25)<1,CPORT>
STRUCT(26)<1,PORT+1> = STRUCT(26)<1,CPORT>
STRUCT(29)<1,PORT+1> = STRUCT(29)<1,CPORT>
STRUCT(30)<1,PORT+1> = STRUCT(30)<1,CPORT>
STRUCT(31)<1,PORT+1> = STRUCT(31)<1,CPORT>
STRUCT(32)<1,PORT+1> = STRUCT(32)<1,CPORT>
STRUCT(33)<1,PORT+1> = STRUCT(33)<1,CPORT>
STRUCT(34)<1,PORT+1> = STRUCT(34)<1,CPORT>
STRUCT(35)<1,PORT+1> = STRUCT(35)<1,CPORT>
STRUCT(36)<1,PORT+1> = STRUCT(36)<1,CPORT>
STRUCT(43)<1,PORT+1> = STRUCT(43)<1,CPORT>
STRUCT(44)<1,PORT+1> = STRUCT(44)<1,CPORT>
STRUCT(51)<1,PORT+1> = STRUCT(51)<1,CPORT>
STRUCT(60)<1,PORT+1> = STRUCT(60)<1,CPORT>
STRUCT(61)<1,PORT+1> = STRUCT(61)<1,CPORT>
STRUCT(62)<1,PORT+1> = STRUCT(62)<1,CPORT>
STRUCT(69)<1,PORT+1> = STRUCT(69)<1,CPORT>
GOSUB SYS.CNTR
END; *# OF 'Y' FOR SET TO CONTROLLING PORT
END; *# OF CPORT NE PORT+1 AND CPORT 
END; *# OF NOT(S(21)<1,P+1>)
*# 
*# 
PORT.CN = -1
PORT.CN.MAX = DCOUNT(STRUCT(21),VM)
*# 
LOOP
PORT.CN = PORT.CN + 1
*# 
WHILE PORT.CN LT PORT.CN.MAX DO
*#IF PORT.CN # PORT & STRUCT(21)<1,PORT.CN + 1> THEN
IF STRUCT(21)<1,PORT.CN+1> THEN
ERROR.TEXT = ERROR.TEXT:AM:"you are"
ERROR.CODE = ERROR.CODE:AM:"18000"
IF NOT(FIRST) THEN
IF PORTD<5> #  "D" THEN
CLS.LO = 7
CLS.HI = 21
GOSUB SYS.CLEAR.PAGE.MID
PRINT @(0,8):
PRINT CLL:RVB:" * * ":USER.NAME:", I AM JUST DISPLAYING YOUR ACTIVE PORTS, DO NOT GET CONFUSED * * ":RVE
*FOR A = 1 TO 10 UNTIL SYSTEM(11); RQM; NEXT A
PRINT RVB:"[Po Company... ........SPTM........ *-Task-Step Description...................]":RVE
PRINT RVB:"[  Application Menu...... Stat ...............Topic Rsp......................]":RVE
END ELSE PRINT @(0,8):CLS
PRINT
IF LEN(TEMP.PR) THEN
PRINT TEMP.PR<1>
PRINT TEMP.PR<2>
TEMP.PR = ""
END
FIRST = FIRST + 1
END ELSE
ERROR.TEXT = ERROR.TEXT:" also"
END
ERROR.TEXT = ERROR.TEXT:" logged on port ":PORT.CN
PRINT RVB:"[":RVE:PORT.CN "R#2":" ":STRUCT(29)<1,PORT.CN+1> "L#10":" ":STRUCT(36)<1,PORT.CN+1> "R#20":" ":"*-":STRUCT(61)<1,PORT.CN+1> "R#5":"-":STRUCT(69)<1,PORT.CN+1> "L#3":" ":STRUCT(62)<1,PORT.CN+1> "L#29"
PRINT RVB:"[":RVE:SPACE(2):" ":STRUCT(30)<1,PORT.CN+1> "L#10":" ":STRUCT(32)<1,PORT.CN+1> "L#10":" ":STRUCT(21)<1,PORT+1> "R#3":"  ":STRUCT(34)<1,PORT.CN+1> "L#20":" ":STRUCT(33)<1,PORT.CN+1> "L#20"
END
REPEAT
*# 
IF NOT(FIRST) THEN
USER.UPD(7) = 1
ERROR.TEXT = ERROR.TEXT:AM:"this port (":PORT:")  is the first you have logged on"
ERROR.CODE = ERROR.CODE:AM:"17000"
*FIRST = ""
END ELSE
PRINT RVB:"[":RVE
PRINT RVB:"[":RVE
*PRINT RVB:"[":RVE
*PRINT RVB:"[":RVE
*PRINT RVB:"[":RVE
ERROR.TEXT = ERROR.TEXT:AM:"this is port ":PORT
ERROR.CODE = ERROR.CODE:AM:"18000"
END
ERROR.TEXT = DELETE(ERROR.TEXT,1)
ERROR.CODE = DELETE(ERROR.CODE,1)
IF LEN(ERROR.CODE) THEN
GOSUB ERROR.CONTROL
END
*# 
END; *# OF ? # READ
*# 
END; *# FUNCT[1,3] = "LOG" AND ? # READ
END; *# END OF STRUCT(15)<1,PORT + 1> 
*# 
END ELSE
*# ELSE OF READ FOR USER!
*# 
MAT STRUCT=''
MAT STR.REPLACE=''
SYS.SLOC<1> = "READ"
SYS.ABORT = 1
ERROR.TEXT = "you are not an accepted user of this system":AM:"this port is being logged off"
ERROR.CODE = "13111":AM:"11101"
GOSUB ERROR.CONTROL
END; *# OF READ FOR USER
*# 
RETURN
*#    
UPDATE.USER.DATA: * Subroutine to update user control data
*#    
SYS.LOCT<1> = "UPDATE.USER.DATA"
SYS.SLOC<1> = "INIT"
*#    
IF NOT(STRUCT(1)) AND FIRST GT 1 THEN STRUCT(1) = 90
IF (FUNCTION EQ "LOGOFF" OR OFF.FLAG) AND EXEC.VERB EQ "OFF" THEN
IF STRUCT(14) EQ PORT + 1 THEN
ERROR.TEXT = "this is the controlling port":AM:"port control cleared"
ERROR.CODE = "18000"
GOSUB ERROR.CONTROL
STRUCT(14) = 0
IF FIRST LE 1 THEN STRUCT(1) = 0 ELSE IF NOT(STRUCT(1)) THEN STRUCT(1) = 91 
END
STRUCT(21)<1,PORT + 1> = 0
PORT.CN = 0
*IF INDEX(STRUCT(21),'1',1) = 0 THEN STRUCT(1) = 0
END ELSE
*#    
STRUCT(1) = 1
IF SYSTEM(11) THEN
STRUCT(14) = PORT + 1
END
END; *# OF "LOGOFF" OR OFF.FLAG
*#    
*# 2-13, 16-20
*#    
SYS.SLOC<1> = "CNTR"; * CONTROL INFORMATION
*IF USER.UPD(1) THEN
*#IF FUNCTION = "LOGOFF" THEN
*#STRUCT(21)<1,PORT + 1> = 0
*#END ELSE
*#STRUCT(21)<1,PORT + 1> = 1
*#END
IF USER.UPD(1) THEN
STRUCT(15)<1,PORT + 1> = STR.REPLACE(15)<1,PORT + 1>
STRUCT(22)<1,PORT + 1> = ACCT
STRUCT(23)<1,PORT + 1> = STR.REPLACE(23)<1,PORT + 1>
STRUCT(24)<1,PORT + 1> = USER.MODE
*INPUT MODE TEMPORARILY 25
STRUCT(25)<1,PORT + 1> = STR.REPLACE(25)<1,PORT + 1>
STRUCT(26)<1,PORT + 1> = WAIT.FLAG
USER.UPD(1) = 0
END
*#    
*# 27 - 28
SYS.SLOC<1> = "LOCT"; * LOCATION INFORMATION
IF USER.UPD(2) THEN
STRUCT(29)<1,PORT + 1> = USER.CO.CODE
STRUCT(30)<1,PORT + 1> = MENU.APPL:SVM:MENU.SUB.APPL:SVM:MENU.GRP.APPL
STRUCT(31)<1,PORT + 1> = MENU.CONTROL<1,7>
STRUCT(32)<1,PORT + 1> = MENU.NAME
STRUCT(33)<1,PORT + 1> = PRMPTING
STRUCT(34)<1,PORT + 1> = TOPIC.KEY
STRUCT(35)<1,PORT + 1> = MENU.CONTROL<1,9>
STRUCT(36)<1,PORT + 1> = STR.REPLACE(36)<1,PORT + 1>
*#    
USER.UPD(2) = 0
END
*#    
*# WHAT ABOUT USER.KEY (COMPLETION)
*# 37 - 42
*#    
SYS.SLOC<1> = "TIME"; * TIME RECORDING INFORMATION
*#    
IF USER.UPD(3) THEN
STRUCT(43)<1,PORT + 1> = STR.REPLACE(43)<1,PORT + 1>
STRUCT(44)<1,PORT + 1> = PSD.KEY
*# 
IF LEN(STR.REPLACE(51)) # 0 THEN
IF LEN(STRUCT(51)) # 0 THEN STRUCT(51) = STRUCT(51):VM
STRUCT(51) = STRUCT(51):STR.REPLACE(51)
END
USER.UPD(3) = 0
END
*#    
*# 45 - 50 , 52 - 59
SYS.SLOC<1> = "SCHD"
IF USER.UPD(4) THEN
STRUCT(60)<1,PORT + 1> = STR.REPLACE(60)<1,PORT + 1>
STRUCT(61)<1,PORT + 1> = TASK.NUM
STRUCT(62)<1,PORT + 1> = STR.REPLACE(62)<1,PORT + 1>
STRUCT(69)<1,PORT + 1> = TASK.STEP
*TASK.COMPANY*****
USER.UPD(4) = 0
END
*#    
*# 63 - 68 , 70 - 84
SYS.LOCT<1> = "MAIL"
IF USER.UPD(5) THEN
*NO FIELDS ON STRUCT
USER.UPD(5) = 0
END
*#    
SYS.SLOC<1> = "MESG"
IF USER.UPD(6) THEN
STRUCT(80) = STR.REPLACE(80)
STRUCT(81) = STR.REPLACE(81)
STRUCT(82) = STR.REPLACE(82)
STRUCT(83) = STR.REPLACE(83)
STRUCT(84) = STR.REPLACE(84)
STRUCT(85) = STR.REPLACE(85)
STRUCT(86) = STR.REPLACE(86)
STRUCT(87) = STR.REPLACE(87)
STRUCT(88) = STR.REPLACE(88)
STRUCT(89) = STR.REPLACE(89)
USER.UPD(6) = 0
END
*#    
RETURN
*#    
!
*#    
SYS.CNTR: * Subroutine to transer STRUCT to user variables
*#    
*#    
*USER
*ACCT
USER.MODE    = STRUCT(24)<1,PORT + 1>
WAIT.FLAG    = STRUCT(26)<1,PORT + 1>
USER.CO.CODE = STRUCT(29)<1,PORT + 1>
MENU.APPL    = STRUCT(30)<1,PORT + 1,1>
MENU.SUB.APPL = STRUCT(30)<1,PORT+ 1,2>
MENU.GRP.APPL = STRUCT(30)<1,PORT+ 1,3>
MENU.CONTROL<1,7> = STRUCT(31)<1,PORT + 1>
MENU.NAME    = STRUCT(32)<1,PORT + 1>
*PRMPTING     = STRUCT(33)<1,PORT + 1>
TOPIC.KEY    = STRUCT(34)<1,PORT + 1>
MENU.CONTROL<1,9>     = STRUCT(35)<1,PORT + 1>
PSD.KEY      = STRUCT(44)<1,PORT + 1>
TASK.NUM     = STRUCT(61)<1,PORT + 1> + 0
TASK.NUM = STR("0",(5-LEN(TASK.NUM))):TASK.NUM
TASK.STEP    = STRUCT(69)<1,PORT + 1> + 0
*TASK.COMPANY***
*#    
RETURN
!
WRITE.USER.DATA: * Subroutine to write & unlock user data.
*#    
MATWRITE STRUCT ON SY.FILE,"@SYS@USER@":STRUCT(2)
*#    
GOSUB UNLCK.USER.DATA
*# 
RETURN
!
UNLCK.USER.DATA: * Subroutine to unlock user record
*# 
IF SUB.FUNCTION # "LOCK" THEN
LCK.STAT = 0
SYS.ITEM = "@SYS@USER@":STRUCT(2)
CALL SYS.UNLOCK.ITEM
USER.LOCKED = LCK.STAT
END
*#    
*#    
*#    
RETURN
!
EXTRACT.USER.DATA: * Subroutine to extract a port's record.
*#    
*#    
*# Place where menu code stored data is return to STRUCT matrix.
*#    
*#    
MAT STR.REPLACE = MAT STRUCT
*#    
*STR.REPLACE(24)<1,PORT + 1> = USER.MODE
*STR.REPLACE(26)<1,PORT + 1> = WAIT.FLAG
*STR.REPLACE(29)<1,PORT + 1> = USER.CO.CODE
*STR.REPLACE(30)<1,PORT + 1> = MENU.APPL
*STR.REPLACE(31)<1,PORT + 1> = MENU.CONTROL<1,7>
*STR.REPLACE(32)<1,PORT + 1> = MENU.NAME
*STR.REPLACE(33)<1,PORT + 1> = PRMPTING 
*STR.REPLACE(34)<1,PORT + 1> = TOPIC.KEY
*STR.REPLACE(35)<1,PORT + 1> = MENU.CONTROL<1,9> 
*STR.REPLACE(44)<1,PORT + 1> = PSD.KEY
*STR.REPLACE(61)<1,PORT + 1> = TASK.NUM 
*STR.REPLACE(69)<1,PORT + 1> = TASK.STEP
*#    
RETURN
*#    
$INCLUDE IBP SYS.ERROR.STRUCT
*#    
*#    
END
~SYS.USER.PORT.NEW~
SUBROUTINE SYS.USER.PORT.NEW
*
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
SYS.PROG = "SYS.USER.PORT.NEW":AM:SYS.PROG
SYS.LOCT = "OPEN":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
SYS.LOCT<1> = "INIT"
* 
IF STRUCT(15)<1,PORT+1> = 9 THEN
*     REMOVE FIRST USE SETTING
STRUCT(15)<1,PORT+1> = 1
*44 IS PSD.REC KEY
STRUCT(44)<1,PORT+1> = STRUCT(9)
*43 IS DATE/TIME
STRUCT(43) = (DATE()+100000)[2,5]:(TIME()+100000)[2,5]
*29 IS COMPANY CODE
STRUCT(29)<1,PORT+1> = ""
*30 IS APPLICATION
STRUCT(30)<1,PORT+1> = ""
*31 IS ENTITY INFO APPLICATION
STRUCT(31)<1,PORT+1> = ""
*32 IS MENU NAME
STRUCT(32)<1,PORT+1> = STRUCT(9)
MENU.NAME = STRUCT(9)
*33 IS OPTION
STRUCT(33)<1,PORT+1> = ""
*34 IS TOPIC.KEY
STRUCT(34)<1,PORT+1> = ""
*35 IS MENU.CONTROL<1,9>
STRUCT(35)<1,PORT+1> = ""
*24 IS CURR.MODE
STRUCT(24)<1,PORT+1> = STRUCT(7)
*23 IS SYS11
STRUCT(23)<1,PORT+1> = STRUCT(8)
*25 IS MODE.PRINT
STRUCT(25)<1,PORT+1> = 1
*  CALL TO GET TASK.NUM & STRUCT(62)<1,PORT+1>
TASK.NUM = 0
TASK.STEP = 0
SCH.FLAG = 1
* 
*60 IS CURR.W
STRUCT(60)<1,PORT+1> = 0
*61 IS JOUNAL NUMBER FOR WORK ASSIGNMENT
STRUCT(61)<1,PORT+1> = TASK.NUM
*62 IS DESTINATION STACK FOR WORK ASSIGNMENT
STRUCT(62)<1,PORT+1> = ""
*69 IS TASK.STEP
STRUCT(69)<1,PORT+1> = TASK.STEP
* 
MAT USER.UPD = 1
ERROR.TEXT = "initialized to use this port on ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS")
ERROR.CODE = "14111"
GOSUB ERROR.CONTROL
END
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
RETURN
*
* 
$INCLUDE IBP SYS.ERROR.STRUCT
* 
END
~SYS.UTILS.SPEED~
SUBROUTINE SYS.UTILS.SPEED
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
*
*
IF INDEX(SYS.PROG,"SYS.UTILS.SPEED",1) # 0 THEN RETURN
*
SYS.PROG = "SYS.UTILS.SPEED":AM:SYS.PROG
SYS.LOCT = "INIT":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
*
!
SYS.SLOC<1> = "DATES"
NEW.DATE = DATE()
NEW.TIME = TIME()
OLD.DATE = STRUCT(43)<1,PORT+1>[1,5]
OLD.TIME = STRUCT(43)<1,PORT+1>[6,5]
START.LN = 16
END.LINE = START.LN + 4
LN.CL = 20
LN.WDTH = 40
*
IF NEW.DATE # OLD.DATE THEN
ELP.TIME = 86400 - OLD.TIME + NEW.TIME
END ELSE
ELP.TIME = NEW.TIME - OLD.TIME
END
PRINT @(0,23):OCONV(ELP.TIME,"MTS") "L#10":
*
*
*
TEMP = ""
LOOP
GOSUB SYS.CLEAR.PAGE.MID
PRINT @(LN.CL,START.LN):"/":STR("=",LN.WDTH-2):"\":
PRINT @(LN.CL,START.LN+1):"|":@(LN.CL+LN.WDTH):"|":
PRINT @(LN.CL,START.LN+2):"\":
TEMP2 = "L#":(LN.WDTH-2)
PRINT "....^....^....^....^....^....^....^....^....^....^....^....^" TEMP2:
PRINT "/":
PRINT @(LN.CL+1,START.LN+1):RVB:
PRINT TEMP:RVE:
PRINT @(LN.CL+1,START.LN+1):RVB:
TEMP = ""
NEW.TIME = TIME()
*
LOOP
NEXT.TIME = TIME()
WHILE NEXT.TIME > NEW.TIME AND NEXT.TIME - NEW.TIME LT 15 AND NOT(SYSTEM(11)) DO
TEMP = TEMP:"*"
FOR A = 1 TO 1000
*
NEXT A
REPEAT
*
PRINT TEMP:RVE:
WHILE NOT(SYSTEM(11)) DO REPEAT
*
*
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*
CALL.FUNCTION = DELETE(CALL.FUNCTION,1)
CALL.SUB.FUNCTION = DELETE(CALL.SUB.FUNCTION,1)
SYS.FILE = ""
SYS.ITEM = ""
*
RETURN
*
SYS.CLEAR.PAGE.MID: *
FOR TEMP = START.LN TO END.LN WHILE NOT(SYSTEM(11)) OR TEMP LT 12
IF LN.CL = 0 THEN
PRINT @(0,TEMP):CLL:
END ELSE IF LN.WDTH NE 0 THEN
PRINT @(LN.CL,TEMP):SPACE(LN.WDTH):" ":
END
NEXT TEMP
*#
RETURN; * from gosub...
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
END
~SYS.WHERE~
*PROGRAM: SYS.WHERE
*
* Athor: David G. Horsman
* Company: Macroscope Design Matrix
*
*  WHERE.REP.MAX
*
*
* (C) 1992 All rights reserved
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
! : * Input Parameters
*
INPUT WHERE.PORT:
*
* : * Init INternal VARiables
*
STAT = FALSE
WHERE.REC = EMPTY
WHERE.TEXT = EMPTY
*
* Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
MAT CNT.TST = EMPTY
*
* : * System Files
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
* : * MAIN
*
$INCLUDE DH.IBP SYS.INCL.WHERE
*
STOP
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
*
RETURN
*
END
~SYS.WHO~
*PROGRAM: SYS.WHO
*
* Athor: David G. Horsman
* Company: Macroscope Design Matrix
*
* (C) 1992 All rights reserved
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
! : * Input Parameters
*
* : * Init INternal VARiables
*
STAT = FALSE
WHO.REC = EMPTY
WHO.TEXT = EMPTY
*
* Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
MAT CNT.TST = EMPTY
*
* : * System Files
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
* : * MAIN
*
$INCLUDE DH.BP SYS.INCL.WHO
*
PRINT WHO.TEXT
*
PRINT "*****************"
*
PRINT WHO.REC
*
PRINT "*****************"
*
PRINT "STAT: ":STAT
*
IF NOT(STAT) THEN
SYS.ID = "WHO.":("0000":WHO.REC<ONE,ONE>) "R#4"
WRITE WHO.REC ON SYS.FILE,SYS.ID
END
*
STOP
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
*
RETURN
*
END
~TEMP~
*PROGRAM: TEMP
*
DT=DATE()
PRINT
PRINT DT-(INT(DT/7)*7)
PRINT "DAY: ":(OCONV(DT,"D2"))[1,2]
PRINT DT
PRINT OCONV(DT,"D2")
PRINT OCONV(DT,"D2/")
END
~TEMP1~
*PROGRAM: TEMP1
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
TMP = ""
TMP<6> = "0":VM:"7930":VM:"7941"
DT = DATE()
*
LOCATE DT IN TMP<6> BY "AL" SETTING DT.VM ELSE NULL
*
PRINT DT.VM
*
END
~TEMP2~
*PROGRAM: TEMP2
*
DT = DATE()
*
FOR A = 1 TO 7
PRINT DT:" _ ":
PRINT DT - (INT(DT/7) * 7)
DT = DT + 1
NEXT A
*
END
~TEMP3~
*PROGRAM: TEMP3
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
MD.FILE.NAME = "MD"
DICT.NAME    = "OLD.BP"
DICT.BASE    = 0
DICT.MOD     = 3
DICT.SEP     = 1
FILE.NAME    = "OLD.BP"
FILE.BASE    = 0
FILE.MOD     = 17
FILE.SEP     = 1
*OPTION       = "S,FC,MC,DC,DAC"
OPTION       = "S,MC"
STAT         = 0
PROG.DEBUG   = 1
*
GOSUB PRINT.SUBR
*
CALL SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,OPTION,FILE.NAME,FILE.BASE,STAT,PROG.DEBUG)
*
GOSUB PRINT.SUBR
*
STOP
*
PRINT.SUBR: *#
*
PRINT
PRINT "MD.FILE    : ":MD.FILE.NAME
PRINT "DICT.NAME  : ":DICT.NAME
PRINT "DICT.BASE  : ":DICT.BASE
PRINT "DICT.MOD   : ":DICT.MOD
PRINT "DICT.SEP   : ":DICT.SEP
PRINT "FILE.NAME  : ":FILE.NAME
PRINT "FILE.BASE  : ":FILE.BASE
PRINT "FILE.MOD   : ":FILE.MOD
PRINT "FILE.SEP   : ":FILE.SEP
PRINT "OPTIONS    : ":OPTION
PRINT "STAT       : ":STAT
PRINT "DEBUG      : ":PROG.DEBUG
PRINT
*
RETURN
*
END
~TEMP8~
*PROGRAM: TEMP8
*
INPUT A.MAX
TEMP = TIME()
A = 0
LOOP A = A + 1 WHILE A LE A.MAX DO
NULL
REPEAT
PRINT A / (TIME()-TEMP)
*
END
~TEMP9~
*PROGRAM: TEMP9
*
INPUT A.MAX
TEMP = TIME()
FOR A = 1 TO A.MAX
NULL
NEXT A
PRINT A / (TIME()-TEMP)
*
END
~TEST1~
*
*
*
PRINT TIME()
INPUT TMP,170: FOR 1000 ELSE TMP = EMPTY
PRINT TIME()
*
STOP
END
~TM~
*PROGRAM: TM
*
*
TM = TIME()
DT = DATE()
PRINT TM:" ":OCONV(TIME(),"MT")
PRINT DT:" ":OCONV(DT,"D2")
*
END
~UPDATE.INDEXES.STD~
SUBROUTINE UPDATE.INDEXES.STD(INDX.ID ,XREF.ID ,FILE.NAME ,FUNC ,INDX.LEN ,INDX.SEQ ,INDX.CN.MAX ,INDX.CN.MIN ,LCK.ITM ,LCK.TYPE ,LCK.STAT ,LCK.FILE ,STAT ,CO.DATA ,MAT CNT.TST ,CNT.TST.ID)
*PROGRAM: UPDATE.INDEX.STD
EQU VS TO "1.0"
*
* COPYRIGHT:         AXION COMPUTER SYSTEMS LTD.
*    199990               ALL RIGHTS RESERVED
*
* DESCRIPTION:       STANDARDIZED UPDATE OF INDEXES
*                    STAT     MEANING
*                       ZERO     SUCCESSFUL ADD
*                      9999     UNABLE TO ADD (E.G. INVALID NAME KEY)
* DATE WRITTEN:      30 MAY 92
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERCALL
*
! Open files
*
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN FILE.NAME TO INDX.FILE ELSE
PRINT CLB:"Can't open ":FILE.NAME:"! Enter <cr> . . . ":;INPUT TMP:
STAT = TRUE
RETURN
END
*
! System Control
*
* System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "SYS"
SYS.APPL.SUB = "INDEX"; SYS.PROG = "UPDATE.INDEXES.STD"; SYS.LOC = "INIT"
SYS.APPL.LOC = ONE
VERSION = VS; AUTO.RUN = FALSE; REDISP = FALSE; DISP.ONLY = FALSE
* STAT = FALSE
*
DT = DATE(); TIME = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
*
*: * Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
* CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
CNT.ID = EMPTY; CNT.ID.SAVE = EMPTY
* GOSUB LOAD.TST; * : *
*
SYS.LOC = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOC) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
! Main program
*
START: *
*
* IF LEN(INDX.STR) LT INDX.LEN THEN TEXT = "String was too short to be indexed"; GOSUB ERROR; RETURN
*
POS.START = INDX.LEN
STRINGS.SAVE = EMPTY
IDS.SAVE = EMPTY
INDX.STR.SAVE = EMPTY
UPD.SAVE = FALSE
INDX.CN = ZERO
*
*
LOOP
*
*
INDX.STR = INDX.ID[ONE,POS.START]
INDX.CHK = INDX.ID[POS.START + ONE,INDX.LEN]
LOOP WHILE LEN(INDX.CHK) LT INDX.LEN DO
INDX.CHK = INDX.CHK:" "
REPEAT
CONT.READ = TRUE; CONT.SEARCH = TRUE
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(INDX.FILE,FILE.NAME,INDX.STR,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 99999 OR LCK.STAT EQ 900 THEN STAT = LCK.STAT; RETURN
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ":FILE.NAME:" file - item ":INDX.STR:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
READ INDX.ITEM FROM INDX.FILE,INDX.STR ELSE
IF FUNC EQ "D" THEN CONT.READ = FALSE; CONT.SEARCH = FALSE
INDX.ITEM = EMPTY
END
*
*
IF CONT.READ THEN
*
LOCATE INDX.CHK IN INDX.ITEM<ONE> BY INDX.SEQ SETTING CHK.LOC THEN
*
IF INDX.ITEM<TWO,CHK.LOC> EQ "*" THEN CONT.READ = TRUE
*
END ELSE CONT.READ = FALSE
*
END; * Of CONT.READ
*
WHILE CONT.READ AND POS.START LT LEN(INDX.ID) DO
*
PRINT @(ZERO,10):CLL:"Overflow on ":INDX.CHK:" in ":INDX.STR:
*
CALL UNLOCK.ITEM(INDX.FILE,FILE.NAME,INDX.STR,LCK.FILE)
*
INDX.STR.SAVE = INDX.STR
*
POS.START = POS.START + INDX.LEN
*
REPEAT
*
! Locate ID in this index record
*
*
ACCESS.KEY = INDX.ID[POS.START + ONE,9999]
LOOP WHILE LEN(ACCESS.KEY) LT INDX.LEN DO
ACCESS.KEY = ACCESS.KEY:" "
REPEAT
STRINGS = INDX.ITEM<ONE>
IDS   = INDX.ITEM<TWO>
*
IF CONT.SEARCH THEN
*
* Locate ID in IDS
*
LOCATE ACCESS.KEY IN STRINGS<ONE> BY INDX.SEQ SETTING LOC THEN
*
LOOP WHILE XREF.ID GT IDS<ONE,LOC> AND ACCESS.KEY EQ STRINGS<ONE,LOC> DO
LOC = LOC + ONE
REPEAT
*
IF XREF.ID = IDS<ONE,LOC> THEN
*
IF FUNC EQ "I" THEN
PRINT @(ZERO,12):CLL:"Found ":ACCESS.KEY:"&":XREF.ID:" in ":INDX.STR:" with ":INDX.CHK:
CONT.SEARCH = FALSE
END
*
END ELSE IF FUNC EQ "D" THEN
PRINT @(ZERO,13):CLL:"Didn't Find ":ACCESS.KEY:"&":XREF.ID:" in ":INDX.STR:" with ":INDX.CHK:
CONT.SEARCH = FALSE
END
*
END ELSE NULL
*
END; * Of CONT.SEARCH
*
! Update index
*
IF CONT.SEARCH THEN
*
IF FUNC EQ "I" THEN
*
INS ACCESS.KEY BEFORE STRINGS<ONE,LOC>
INS XREF.ID    BEFORE IDS<ONE,LOC>
PRINT @(ZERO,15):CLL:"Insert ":ACCESS.KEY:"&":XREF.ID:" in ":INDX.STR:" with ":INDX.CHK:
*
END ELSE IF FUNC EQ "D" THEN
*
DEL STRINGS<ONE,LOC>
DEL IDS<ONE,LOC>
PRINT @(ZERO,16):CLL:"Delete ":ACCESS.KEY:"&":XREF.ID:" in ":INDX.STR:" with ":INDX.CHK:
*
END; * Of I or D
*
END; * Of CONT.SEARCH
*
OVFL.FL = FALSE
*
! Loop for multiple overflows
*
LOOP
*
IF OVFL.FL THEN
*
PRINT CLB:"I am in the overflow reloop area ":
*
* LOOP
* LCK.STAT = LCK.TYPE
* CALL LOCK.ITEM(INDX.FILE,FILE.NAME,INDX.STR,LCK.FILE,LCK.STAT)
* IF LCK.STAT EQ 99999 OR LCK.STAT EQ 900 THEN STAT = LCK.STAT; RETURN
* WHILE LCK.STAT DO
* PRINT @(ZERO,22):CLL:"You must unlock ":FILE.NAME:" file - item ":INDX.STR:" then hit <cr> to continue ":; INPUT RSP:
* REPEAT
* *
* READ INDX.ITEM FROM INDX.FILE,INDX.STR ELSE INDX.ITEM = EMPTY
*
STRINGS = INDX.ITEM<ONE>
IDS     = INDX.ITEM<TWO>
*
END
*
* Set start of INDX.STRs
*
LOCATE INDX.CHK IN STRINGS<ONE> BY INDX.SEQ SETTING INDX.LOC.BEG ELSE NULL
IF NOT(INDX.LOC.BEG) THEN
PRINT CLB:"INDX.LOC.BEG NOT SET":; INPUT TMP
INDX.LOC.BEG = ONE
END
*
* Set end of INDX.STRs
*
INDX.LOC.END = INDX.LOC.BEG
LOOP WHILE STRINGS<ONE,INDX.LOC.END>[ONE,INDX.LEN] EQ INDX.CHK DO
INDX.LOC.END = INDX.LOC.END + ONE
REPEAT
*
* Count strings
*
INDX.VM.MAX = DCOUNT(STRINGS,VM)
*
* Check for update previous
*
UPD.SAVE = FALSE
INDX.CN = INDX.LOC.END - INDX.LOC.BEG
IF INDX.CN GT INDX.CN.MAX THEN UPD.SAVE = TRUE
IF INDX.CN LT INDX.CN.MIN THEN UPD.SAVE = FALSE
*
PRINT @(ZERO,19):CLL:"IL ":LOC "R#4":" ILB ":INDX.LOC.BEG "R#4":" ILE ":INDX.LOC.END "R#4":" ICN ":INDX.CN "R#4":" UPD ":UPD.SAVE:
*
WHILE (UPD.SAVE AND INDX.CN LT INDX.VM.MAX - INDX.CN.MIN) OR NOT(OVFL.FL) DO
*
OVFL.FL = TRUE
*
IF FUNC EQ "I" AND UPD.SAVE THEN
*
FOR CN = ONE TO INDX.CN
*
IF INDX.CN GT INDX.CN.MAX THEN
TMP = STRINGS<ONE,INDX.LOC.BEG>[INDX.LEN + ONE,99999]
LOOP WHILE LEN(TMP) LT INDX.LEN DO
TMP = TMP:" "
REPEAT
STRINGS.SAVE<ONE,CN> = TMP
END ELSE IF INDX.CN LT INDX.CN.MIN THEN
STRINGS.SAVE<ONE,CN> = INDX.CHK:STRING<ONE,INDX.LOC.BEG>
END
IDS.SAVE<ONE,CN>     = IDS<ONE,INDX.LOC.BEG>
*
DEL STRINGS<ONE,INDX.LOC.BEG>
DEL IDS<ONE,INDX.LOC.BEG>
*
NEXT CN
*
PRINT @(ZERO,8):CLL:STRINGS.SAVE "L#70":
PRINT @(ZERO,9):CLL:IDS.SAVE "L#70":
*
IF INDX.CN GT INDX.CN.MAX THEN
INS INDX.CHK BEFORE STRINGS<ONE,INDX.LOC.BEG>
INS "*"      BEFORE IDS<ONE,INDX.LOC.BEG>
END; * Of gt indx.cn.max
*
END; * Of 'I' and upd.save
*
! Write index
*
IF STRINGS NE EMPTY THEN
*
INDX.ITEM<ONE> = STRINGS
INDX.ITEM<TWO> = IDS
*
WRITE INDX.ITEM ON INDX.FILE,INDX.STR
PRINT @(ZERO,18):CLL:"Write ":INDX.STR:
*
END ELSE
*
DELETE INDX.FILE,INDX.STR
PRINT @(ZERO,19):CLL:"Delete ":INDX.STR:
*
END; * Of STRING or EMPTY STRING
*
! Unlock indx
*
CALL UNLOCK.ITEM(INDX.FILE,FILE.NAME,INDX.STR,LCK.FILE)
*
! Detect overflow on string[x,len] or empty & "*" in prev index
*
IF UPD.SAVE THEN
*
PRINT CLB:"I am in the overflow update area ":
*
IF INDX.CN LT INDX.CN.MIN THEN
POS.START = POS.START - INDX.LEN
END ELSE IF INDX.CN GT INDX.CN.MAX THEN
POS.START = POS.START + INDX.LEN
END
*
* Check len of post.start
*
IF POS.START GT ZERO THEN
*
INDX.STR = INDX.ID[ONE,POS.START]
INDX.CHK = INDX.ID[POS.START + ONE,INDX.LEN]
LOOP WHILE LEN(INDX.CHK) LT INDX.LEN DO
INDX.CHK = INDX.CHK:" "
REPEAT
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(INDX.FILE,FILE.NAME,INDX.STR,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 99999 OR LCK.STAT EQ 900 THEN STAT = LCK.STAT; RETURN
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ":FILE.NAME:" file - item ":INDX.STR:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
READ INDX.ITEM FROM INDX.FILE,INDX.STR ELSE INDX.ITEM = EMPTY
*
LOCATE INDX.CHK IN INDX.ITEM<ONE> BY INDX.SEQ SETTING CHK.LOC ELSE NULL
*
IF FUNC EQ "I" OR FUNC EQ "D" THEN
DEL INDX.ITEM<ONE,CHK.LOC>
DEL INDX.ITEM<TWO,CHK.LOC>
END
*
IF FUNC EQ "I" THEN
*
IF INDX.CN LT INDX.CN.MIN THEN
INS STRINGS.SAVE BEFORE INDX.ITEM<ONE,CHK.LOC>
INS IDS.SAVE     BEFORE INDX.ITEM<TWO,CHK.LOC>
*
END ELSE IF INDX.CN GT INDX.CN.MAX THEN
INDX.ITEM      = STRINGS.SAVE
INDX.ITEM<TWO> = IDS.SAVE
END
*
END; * of I or D
*
PRINT @(ZERO,7):CLL:"Write ":INDX.STR:
WRITE INDX.ITEM ON INDX.FILE,INDX.STR
*
END; * Of pos.start gt 0
*
END; * Of cont.search and upd
*
REPEAT
*
CALL UNLOCK.ITEM(INDX.FILE,FILE.NAME,INDX.STR,LCK.FILE)
*
*
RETURN
*
!
*
ERROR: *
*
PRINT CLB:RVB:TEXT:RVE:; INPUT TMP:
TEXT = EMPTY 
*
RETURN
*
*
END
~WP.DOC.GENERATE~
*PROGRAM: WP.DOC.GENERATE
!
$INCLUDE IBP SYS.COMMON
TERMINAL = "?"
$INCLUDE IBP STANDARD.FUNCTIONS
*
SYS.PROG.DESC = "Word Processor Document Generator"
SYS.PROG = "WP.DOC.GENERATE"
SYS.LOCT = "INIT"
SYS.SLOC = "ERROR.CONTROL"
*
*
OFF.RSP = "*OFF*off*Off*END*end*End*STOP*stop*HALT*halt*Halt*BYE*bye*Bye*LOGOFF*logoff*Logoff*"
TCL.RSP ="*COMMAND*TCL*tcl*Tcl*"
USER.NAME = ""
MENU.NAME = ""
MENU.NUM = 1
MENU.APPL = "LOGON"
PRMPTING = ""
TOPIC.KEY = ""
MAT STRUCT = ""
STRUCT(1) = 0
WAIT.FLAG = 2
!
SYS.SLOC = "FILES"
SYS.FILE = "SYS"
OPEN "SYS" TO SY.FILE ELSE
ERROR.TEXT = "No SYS file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "MENUS"
OPEN "MENUS" TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
CHECK.MAIL = 0
*
SYS.FILE = "HLP"
OPEN "HLP" TO HLP.FILE THEN CHECK.HELP = 1 ELSE
CHECK.HELP = 0
ERROR.TEXT = "No HLP file"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "PSD"
OPEN "PSD" TO PS.FILE THEN CHECK.TIME = 2 ELSE
CHECK.TIME = 0
ERROR.TEXT = "No PSD file"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "ACC"
OPEN "ACC" TO AC.FILE ELSE
ERROR.TEXT = "No ACC file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
*
SYS.SLOC = "TABLES"
SYS.FILE = "ACC"
SYS11.ELP = 0; USER.FLAG = 1
CALL.ID = "MENU.":PORT
SYS.ITEM = CALL.ID
READV USER.NAME FROM AC.FILE,CALL.ID,2 ELSE USER.NAME = ""; USER.FLAG = 0
MENU.NAME = ""
*
SYS.FILE = "SYS"
SYS.ITEM = "CO.DATA"
READ CO.DATA FROM SY.FILE,SYS.ITEM ELSE CO.DATA =AM:DATE():AM:"* Not on file *"
EXEC.VERB = ""; PRMPTING = ""
*
*
SYS.FILE = "SYS"
SYS.ITEM = "@M@USER.MODE.DESC"
MATREAD MODE.DESC FROM SY.FILE,SYS.ITEM ELSE
MAT MODE.DESC = "?"
ERROR.TEXT = "user mode descriptions missing"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.ITEM = "@M@STATUS@CHECK"
READ STAT.CHECK FROM SY.FILE,SYS.ITEM ELSE
STAT.CHECK = "?"
ERROR.TEXT = "No STATUS flag verifiers"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.ITEM = "@M@STATUS@DESC"
MATREAD STAT.DESC FROM SY.FILE,SYS.ITEM ELSE
MAT STAT.DESC = ""
ERROR.TEXT = "No STATUS descriptions"
ERROR.CODE = 13111
GOSUB ERROR.CONTROL
END
*
SYS.ITEM = "@SYS@LO.DEV.MODE"
READ LO.D.M FROM SY.FILE,SYS.ITEM ELSE LOW.DEV.MODE = 0
SYS.ITEM = "@SYS@HI.DEV.MODE"
READ HI.D.M FROM SY.FILE,SYS.ITEM ELSE HI.D.M = 0
SYS.ITEM = "@SYS@HI.SALES.MODE"
READ HI.S.M FROM SY.FILE,SYS.ITEM ELSE HI.S.M = 0
SYS.ITEM = "@SYS@LO.TCL.MODE"
READ LO.TCL.M FROM SY.FILE,SYS.ITEM ELSE LO.TCL.M = 0
SYS.ITEM = "@SYS@LO.TRAIN.MODE"
READ LO.T.M FROM SY.FILE,SYS.ITEM ELSE LO.T.M = 0
SYS.ITEM = "@SYS@HI.TRAIN.MODE"
READ HI.T.M FROM SY.FILE,SYS.ITEM ELSE HI.T.M = 0
*
*
SYS.SLOC = "USER"
MAT USER.UPD = 0
USER.LOCKED = 0; USER.ABORT = 0; SYS.ABORT = 0
PRINT @(0,5):CLS:
*
GOSUB LOG.IN.TO.MENU
*
IF USER.ABORT ! SYS.ABORT THEN PRINT BELL:" ABORT!":; STOP
*
IF OFF.FLAG THEN PRMPTING = "OFF"
IF TCL.FLAG THEN PRMPTING = "TCL"
OFF.FLAG = 0
*
MENU.APPL.DESC = ""
SYS.LOCT = "MENU"
SYS.SLOC = "READ"
SYS.FILE = "MENUS"
SYS.ITEM = "@AS@":MENU.NAME
*
*
MENU.KEY = MENU.NAME
GOSUB READ.MENU
*
*
IF LEN(CO.DATA<1,1,1>) = 0 THEN CO.DATA<1,1,1> = SPACE(10)
SYS.ITEM = "@SCHED@STACK@":CO.DATA<3>:"@":STRUCT(2)
READ P.S FROM SY.FILE,SYS.ITEM ELSE P.S = ""
CN = 1
SCR.LINES = 10
SCR.HEADING = ""
VRF.EXTRA = 0
OUT.TO.PRINT = ""
WAIT.QUESTION = "Yes"
WAIT.FLAG = 1
TRANS.TASK.DESC = ""
*
REDISPLAY.SCREEN: * Return point for redisplaying screen.
GOSUB S.HEADING
CONT.SCAN.STACK = 1
MENU.ATTR = 0
DOCUMENT.LEVEL = 0
LEVEL.STACK = 0
MENU.STACK = MENU.NAME
ATTR.STACK = 1
FILE.STACK = "MENUS"
DOCUMENT.STACK = MENU.NAME
STACK.COUNTER = 0
SAVE.STACK.COUNTER = 0
HIGH.STACK = 0
MENU.FLAG = 1
PRINT @(0,7):CLS:
LOOP
GOSUB SCAN.STACK
WHILE MENU.FLAG & CONT.SCAN.STACK DO
GOSUB SCAN.MENU
REPEAT
*
PRINTER ON
PRINT "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"; PRINT
PRINT STACK.COUNTER:"<<<<<<"
PRINT LEVEL.STACK:"<<<<<"
PRINT; PRINT MENU.STACK:"<<<<"
PRINT; PRINT ATTR.STACK:"<<<"
PRINT; PRINT FILE.STACK:"<<"
PRINT; PRINT DOCUMENT.STACK:"<"
PRINT; PRINT; PRINT "^^^^^^^^^^^^^^^^^^^^^^^"
PRINTER OFF
*
GOSUB PRINT.INDEX
*
GOSUB PRINT.DOCUMENTS
GOTO End.prog
!
SCAN.STACK: *
CONT.SCAN.STACK = 1
STACK.COUNTER = SAVE.STACK.COUNTER
MENU.FLAG = 0
LOOP
STACK.COUNTER = STACK.COUNTER + 1
IF DOCUMENT.STACK<STACK.COUNTER>[1,1] = "/" THEN
MENU.FLAG = 1
MENU.KEY = DOCUMENT.STACK<STACK.COUNTER>
DOCUMENT.STACK<STACK.COUNTER> = ""
DOCUMENT.LEVEL = LEVEL.STACK<STACK.COUNTER>
END
IF FILE.STACK<STACK.COUNTER> = "" THEN CONT.SCAN.STACK = 0
WHILE NOT(MENU.FLAG) & CONT.SCAN.STACK DO REPEAT
*
SAVE.STACK.COUNTER = STACK.COUNTER
PRINTER ON; PRINT "!":; PRINTER OFF; PRINT "!":
RETURN
!
SCAN.MENU: *
GOSUB READ.MENU
IF MENU(1) # "" THEN
DOCUMENT.LEVEL = DOCUMENT.LEVEL + 1
MENU.ATTR = 1
LOOP MENU.ATTR = MENU.ATTR + 1 WHILE LEN(MENU(MENU.ATTR)) # 0 DO
PRINTER ON; PRINT "*":; PRINTER OFF; PRINT "*":
LEVEL.ID = DOCUMENT.LEVEL
FILE.ID = ""
MENU.ID = MENU.KEY
ATTR.ID = MENU.ATTR
DOCUMENT.ID = ""
IF INDEX("*WP-INPUT*WP-OUTPUT*ED*EDIT*","*":MENU(MENU.ATTR)<1,2>:"*",1) # 0 THEN
GOSUB FORMAT.KEY
DOCUMENT.ID = EXEC.FILE.ITEM
FILE.ID = MENU.FILE
IF LEN(FILE.ID) = 0 THEN FILE.ID = "WPD"
END ELSE IF MENU(MENU.ATTR)<1,2>[1,1] = "/" THEN
DOCUMENT.ID = MENU(MENU.ATTR)<1,2>
FILE.ID = "MENUS"
*ATTR.ID = 1
END
IF DOCUMENT.ID # "" THEN
STACK.COUNTER = STACK.COUNTER + 1
LEVEL.STACK = INSERT(LEVEL.STACK,STACK.COUNTER;LEVEL.ID)
MENU.STACK = INSERT(MENU.STACK,STACK.COUNTER;MENU.ID)
ATTR.STACK = INSERT(ATTR.STACK,STACK.COUNTER;ATTR.ID)
FILE.STACK = INSERT(FILE.STACK,STACK.COUNTER;FILE.ID)
DOCUMENT.STACK = INSERT(DOCUMENT.STACK,STACK.COUNTER;DOCUMENT.ID)
END
REPEAT
END
*
RETURN
!
FORMAT.KEY: *
GOSUB MENU.ITEM
S.F.I.EXEC = EXEC.FILE.ITEM
S.F.I.PARAMS = MENU.PARAMS
CALL SYS.FILE.ITEM(S.F.I.PARAMS,S.F.I.EXEC)
EXEC.FILE.ITEM = S.F.I.EXEC
RETURN
*
!
PRINT.INDEX: *
*
CN = 0
CONT = 1
CURRENT.FILE = ""
LAST.REP.LEVEL = 0
PRINT; PRINT
LOOP
CN = CN + 1
IF LEVEL.STACK<CN> = "" THEN
CONT = 0
PRINTER ON; PRINT FF; PRINTER OFF
END ELSE
REP.LEVEL = LEVEL.STACK<CN>
REP.MENU  = MENU.STACK<CN>
REP.ATTR  = ATTR.STACK<CN>
REP.FILE  = FILE.STACK<CN>
REP.DOCM  = DOCUMENT.STACK<CN>
END
*
WHILE CONT DO
IF REP.LEVEL = 0 THEN
PRINT "$":
REP.PAGE = 0
REP.LINE = 99
REP.NUMB = ""
MENU.KEY = REP.MENU
GOSUB READ.MENU
REP.HEADING = ""
CN1 = 0
LOOP CN1 = CN1 + 1 WHILE MENU(1)<1,2,CN1> # "" DO
REP.HEADING<CN1> = MENU(1)<1,3,CN1>:" ":FIELD(TOPIC.KEY,"#",CN1)
REPEAT
TITLE.FLAG = 1
GOSUB PRINT.HEADING
TITLE.FLAG = 0
GOSUB PRINT.HEADING
*
*
END ELSE IF REP.LEVEL > 0 THEN
PRINT REP.LEVEL:
REP.TAB = REP.LEVEL
*
IF REP.LEVEL # LAST.REP.LEVEL THEN
IF REP.LEVEL > LAST.REP.LEVEL THEN REP.NUMB<REP.LEVEL> = 0
IF REP.LINE > 10 THEN
PRINTER ON
PRINT; PRINT; REP.LINE = REP.LINE + 2
PRINTER OFF
END
LAST.REP.LEVEL = REP.LEVEL
END
*
IF LEN(REP.NUMB<REP.LEVEL>) = 0 THEN REP.NUMB<REP.LEVEL> = 0
REP.NUMB<REP.LEVEL> = REP.NUMB<REP.LEVEL> + 1
*
IF REP.LEVEL < 3 & REP.LINE > 45 THEN
GOSUB PRINT.HEADING
END ELSE IF REP.LINE > 55 THEN
GOSUB PRINT.HEADING
END
*
MENU.KEY = REP.MENU
GOSUB READ.MENU
REP.DESC = MENU(REP.ATTR)<1,1>
*
LOOP
TEMP.TC = REP.DESC<1,1,1>[1,1] 
WHILE TEMP.TC = "*" DO
REP.DESC = DELETE(REP.DESC,1,1,1)
REPEAT
*
TEMP.REP.DESC = ""
LOOP
TEMP.TC = REP.DESC<1,1,1> 
WHILE TEMP.TC # "" DO
IF TEMP.TC[1,1] = "+" THEN TEMP.TC = TEMP.TC[2,999]
TEMP.REP.DESC = TEMP.REP.DESC:TEMP.TC:" "
REP.DESC = DELETE(REP.DESC,1,1,1)
REPEAT
REP.DESC = TEMP.REP.DESC
*
*
PRINTER ON
TEMP = REP.DESC
TEMP.CN = 0
LOOP WHILE LEN(TEMP) > 0 DO
TEMP.CN = TEMP.CN + 1
IF TEMP.CN = 1 THEN
PRINT SPACE(3*REP.TAB):(REP.NUMB<REP.LEVEL>:".") "R#4":" ":
END ELSE
PRINT SPACE(3*REP.TAB+10):
END
*
IF LEN(TEMP) > 80 THEN
REP.CHAR = 80
LOOP WHILE TEMP[REP.CHAR,1] # " " & REP.CHAR > 40 DO REP.CHAR = REP.CHAR - 1 REPEAT
PRINT TEMP[1,REP.CHAR]:
IF REP.CHAR = 40 THEN PRINT "-" ELSE PRINT
TEMP = TEMP[REP.CHAR + 1,999]
END ELSE PRINT TEMP; TEMP = ""
REP.LINE = REP.LINE + 1
REPEAT
PRINTER OFF
END
REPEAT
*
PRINTER ON
PRINT; PRINT
PRINT "PRINT.INDEX"; PRINT; PRINT
PRINTER OFF
*
RETURN
!
PRINT.HEADING: *
IF REP.PAGE > 1 THEN
PRINTER ON
LOOP REP.LINE = REP.LINE + 1 UNTIL REP.LINE = 60 DO PRINT REPEAT
PRINT SPACE(60):"Cont'd . . ."
PRINTER OFF
END
REP.PAGE = REP.PAGE + 1
REP.LINE = 10
PRINTER ON
PRINT FF:
PRINT OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.DATA<1,1,1>)/2+.5):CO.DATA<1,1,1>) "L#50":("Page: ":REP.PAGE) "R#15"
*
PRINT OCONV(TIME(),"MTS") "L#15":(SPACE(25-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#50"
*
PRINT SPACE(20):(SPACE(20-LEN(MENU(1)<1,1>)/2+.5):MENU(1)<1,1>) "L#40"
*
PRINT
IF TITLE.FLAG THEN
REP.LINE = REP.LINE + 20
FOR TEMP = 1 TO 20; PRINT; NEXT TEMP
END
TEMP.CN = 0
LOOP
TEMP.CN = TEMP.CN + 1
REP.HEADER = REP.HEADING<TEMP.CN>
WHILE REP.HEADER # "" DO
PRINT (SPACE((80-LEN(REP.HEADER)) / 2):REP.HEADER) "L#80"
REP.LINE  = REP.LINE + 1
IF TITLE.FLAG THEN PRINT; PRINT; REP.LINE = REP.LINE + 2
REPEAT
*
*
PRINT
PRINTER OFF
RETURN
!
PRINT.DOCUMENTS: *
*
*
PRINTER ON
PRINT; PRINT; PRINT
PRINT "PRINT.DOCUMENTS"; PRINT; PRINT
PRINTER OFF
*
RETURN
!
S.HEADING: * Subroutine to print screen heading.
CPAGETEN = INT( ( CN - 1) / SCR.LINES ) * SCR.LINES
CPAGE = INT(CPAGETEN / SCR.LINES) + 1
IF OUT.TO.PRINT THEN
PRINTER ON
PRINT FF
PRINT OCONV(DATE(),"D2") "L#20":(SPACE(20-LEN(CO.DATA<1,1,1>)/2+.5):CO.DATA<1,1,1>) "L#40":("Port: ":PORT) "R#20"
*
PRINT OCONV(TIME(),"MTS") "L#15":(SPACE(25-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#50":("Acct: ":ACCT) "R#15"
*
IF STRUCT(25)<1,PORT+1> THEN PRINT (MODE.DESC(USER.MODE):" mode") "L#20": ELSE PRINT SPACE(20): 
*
PRINT (SPACE(20-LEN(MENU(1)<1,1>)/2+.5):MENU(1)<1,1>) "L#40":("User: ":STRUCT(2)) "R#20"
*
PRINT
PRINT (SPACE((80-LEN(SYS.PROG.DESC)) / 2):SYS.PROG.DESC) "L#80"
PRINT
PRINTER OFF
END ELSE
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#20":(SPACE(20-LEN(CO.DATA<1,1,1>)/2+.5):CO.DATA<1,1,1>) "L#40":("Port: ":PORT) "R#20":
*
PRINT @(0,1):OCONV(TIME(),"MTS") "L#15":(SPACE(25-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#50":("Acct: ":ACCT) "R#15":
*
IF STRUCT(25)<1,PORT+1> THEN PRINT @(0,2):(MODE.DESC(USER.MODE):" mode") "L#20": ELSE PRINT @(0,2):SPACE(20): 
*
PRINT (SPACE(20-LEN(MENU(1)<1,1>)/2+.5):MENU(1)<1,1>) "L#40":("User: ":STRUCT(2)) "R#20":
*
PRINT @(0,3):(SPACE((80-LEN(SYS.PROG.DESC)) / 2):SYS.PROG.DESC) "L#80":RVE:
*
END
VRF.EXTRA = 0
RETURN
!
!
LOG.IN.TO.MENU: *#* WRITE TIME RECORD WITH ELASPED TIME AND SUBR.FUNCTION
*
*
OFF.FLAG = 0
SCH.FLAG = 0
TCL.FLAG = 0
MSG.FLAG = 0
MAL.FLAG = 0
PASS.INPUT = ""
PASS.FLAG = 0
*
LOG.IN.RETURN: * reloop point
IF USER.NAME # ""  THEN
CALL.FUNCTION = "LOGON"
CALL.SUB.FUNCTION = "READ"
GOSUB RECORD.USER.CALL
IF USER.ABORT THEN RETURN
*
IF NOT(STRUCT(1)) THEN OFF.FLAG = 1; SCH.FLAG = 4
*
IF NOT(STRUCT(21)<1,PORT+1>) THEN OFF.FLAG = 1
IF STRUCT(33)<1,PORT+1> = "TCL" THEN TCL.FLAG = 1
IF STRUCT(33)<1,PORT+1> = "OFF" THEN OFF.FLAG = 1
IF NOT(OFF.FLAG) & NOT(TCL.FLAG) THEN PASS.FLAG = 0
END ELSE MAT STRUCT = ""; USER.FLAG = 0; PASS.FLAG = 1
*
*
IF NOT(USER.FLAG) THEN
PASS.INPUT = ""
PRINT @(0,5):CLS:@(0,7):"Who is there? ":
ECHO OFF; INPUT USER.NAME:; ECHO ON
PASS.INPUT = FIELD(USER.NAME,",",2)
USER.NAME  = FIELD(USER.NAME,",",1)
USER.FLAG = 1; PASS.FLAG = 1
GOTO LOG.IN.RETURN
END
*
*
IF PASS.FLAG THEN
LOOP WHILE PASS.INPUT # STRUCT(3) & PASS.FLAG < 6 DO
PRINT @(0,9):"What is your password ":USER.NAME:"? ":
IF LEN(PASS.INPUT) = 0 THEN ECHO OFF; INPUT PASS.INPUT:; ECHO ON
IF PASS.INPUT # STRUCT(3) THEN
PASS.FLAG = PASS.FLAG + 1
ERROR.TEXT = "Invalid password (":PASS.INPUT:" # ":STRUCT(3):", attempt no. ":PASS.FLAG:")"
ERROR.CODE = 14110
GOSUB ERROR.CONTROL
PASS.INPUT = ""
END ELSE
WRITE AM:USER.NAME:AM:(DATE()+100000)[2,5]:(TIME()+100000)[2,5] ON AC.FILE,CALL.ID
END
REPEAT
END
IF PASS.FLAG > 5 THEN CHAIN "MENU-RUN OFF"
*
IF STRUCT(15)<1,PORT+1> = 9 THEN
CALL.FUNCTION = "LOGON"
CALL.SUB.FUNCTION = "NEW.USER"
CALL SYS.USER.PORT.NEW
END
*
CALL.FUNCTION = "LOGON"
CALL.SUB.FUNCTION = "UPDATE"
GOSUB RECORD.USER.CALL
IF USER.ABORT THEN RETURN
*
RETURN
!
RECORD.USER.CALL: *Subroutine to update user info
*
SYS.SLOC = "RECORD.USER.CALL"
IF CALL.FUNCTION # "LOGON" & CALL.FUNCTION # "LOGOFF" & CALL.FUNCTION # "MENU" THEN CALL.FUNCTION = "UNKNOWN"
IF CALL.SUB.FUNCTION # "UPDATE" & CALL.SUB.FUNCTION # "READ" THEN
IF CALL.SUB.FUNCTION # "WRITE" & CALL.SUB.FUNCTION # "RESET" THEN RETURN
END
LOOP
SYS.FILE = "SYS"
IF STRUCT(2) # "" THEN USER.NAME = STRUCT(2)
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
WHILE (USER.LOCKED & USER.LOCKED # PORT+1) & NOT(USER.ABORT) DO REPEAT
RETURN
!
RECORD.SCHEDULE: * to record a change in task or step
STRUCT(61)<1,PORT+1> = TASK.NUM
STRUCT(69)<1,PORT+1> = TASK.STEP
USER.UPD(4) = 1
RETURN
!
READ.MENU: *
*
MENU.APPL.DESC = ""
SYS.LOCT = "MENU"
SYS.SLOC = "READ"
SYS.FILE = "MENUS"
SYS.ITEM = "@AS@":MENU.KEY
MENU.NAME = MENU.KEY
MATREAD MENU FROM MU.FILE,SYS.ITEM THEN
SYS.SLOC = "APPL"
*
MENU.PREV = MENU(1)<1,5>
MENU.APPL = MENU(1)<1,6>
SYS.FILE = "SYS"
SYS.ITEM = "@APPL@":MENU.APPL
READ MENU.APPL.REC FROM SY.FILE,SYS.ITEM ELSE
MENU.APPL.REC = ""
ERROR.TEXT = "Application description not on file for ":MENU.APPL
ERROR.CODE = 13110
GOSUB ERROR.CONTROL
END
*
MENU.APPL.DESC = MENU.APPL.REC<1>
MENU.APPL.REC = ""
*
MENU.EI.APPL = MENU(1)<1,7>
MENU.TYPE = MENU(1)<1,8>[1,1]
MENU.SPLIT = MENU(1)<1,8>[2,99]
MENU.NUM = MENU(1)<1,9>
IF NOT(NUM(MENU.NUM)) THEN MENU.NUM = 0
END ELSE
MENU.APPL = "* Not on file *"
MENU.APPL.DESC  = ""
MENU(1) = ""
END
RETURN
!
MENU.ITEM: *
*
LINE = MENU(MENU.ATTR)
EXEC.VERB = LINE<1,2>
PRMPTING = LINE<1,3>
VALID.ACCTS = LINE<1,4>
VALID.USER = LINE<1,5>
MENU.PARAMS = LINE<1,6>
LOOP WHILE MENU.PARAMS[1,1] = " " ! MENU.PARAMS[1,1] = "F" DO MENU.PARAMS = MENU.PARAMS[2,999] REPEAT
MENU.FILE = LINE<1,7>
MENU.STEP = LINE<1,8>
MENU.SUBJCT = LINE<1,9>
*
RETURN
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
End.prog: * End of program.
*
STOP
END
*IF REP.FILE = "MENUS" THEN
*MENU.KEY = REP.MENU
*GOSUB READ.MENU
*REP.DESC = MENU(REP.ATTR)<1,1>
*END ELSE
*IF REP.FILE # CURRENT.FILE THEN
*CURRENT.FILE = REP.FILE
*OPEN CURRENT.FILE TO DOC.FILE ELSE
*ERROR.TEXT = "the file call ":CURRENT.FILE:" does not exist."
*ERROR.CODE = 13111
*GOSUB ERROR.CONTROL
*END
*END
*READV REP.DESC FROM DOC.FILE,REP.MENU,REP.ATTR THEN
*REP.DESC = REP.DESC<1,1>
*END ELSE REP.DESC = ""
*END
~WPD.LIST~
*PROGRAM: WPD.LIST
*
SLIST=""
EXECUTE "SSELECT WPD", //SELECT. > SLIST
EXECUTE "LIST WPD 0 ID-SUPP", //SELECT. < SLIST
*
END
~WPD.SCAN~
*PROGRAM: WPD.SCAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT @(0,5):CLS:"Word Processor Document Listing":
PRINT @(0,21):CLS:@(0,22):"Enter <CR> to continue. . .":
INPUT TEMP:
*
LOOP
*
SLIST = ""
USER.TO.LIST = ""
LOC = ""
PRINT @(0,5):CLS:"Word Processor Document Listing":
PRINT @(0,7):"Enter the user to be listed: ":
INPUT USER.TO.LIST:
IF USER.TO.LIST = "" THEN STOP
*
WHILE USER.TO.LIST # "" DO
*
LOOP
*
PRINT @(0,9):"List this on the (T)erminal or (P)rinter? ":
INPUT LOC:
IF LOC = "" THEN LOC = "T"
*
WHILE LOC # "T" AND LOC # "P" DO
*
IF LOC = "END" THEN STOP
*
REPEAT
*
LOC = " (":LOC:")"
PRINT @(0,11):"Selecting documents. . . ":
*
EXECUTE 'SSELECT WPD,':USER.TO.LIST:' # "0"', //SELECT. > SLIST
PRINT @(0,13):"Starting report at ":OCONV(TIME(),"MTS"):
*
EXECUTE 'LIST WPD,':USER.TO.LIST:' 0 ID-SUPP':LOC, //SELECT. < SLIST
PRINT @(0,23):BELL:"Thank you, listing completed. Enter <CR>. . .":
INPUT TEMP:
*
REPEAT
*
END
~WPD.USER.LIST~
*PROGRAM: WPD.USER.LIST
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT @(0,5):CLS:"Word Processor User Listing":
SLIST = ""
PRINT @(0,21):CLS:@(0,22):"Enter <CR> to continue. . .":
INPUT TEMP:
EXECUTE 'SSELECT WPD # "0"', //SELECT. > SLIST
EXECUTE "LIST WPD 0 ID-SUPP", //SELECT. < SLIST
*
END
~WPD.USER.PRINT~
*PROGRAM: WPD.USER.PRINT
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT @(0,5):CLS:"Word Processor User Listing":
PRINT @(0,21):CLS:@(0,22):"Enter <CR> to continue. . .":
INPUT TEMP:
EXECUTE 'SSELECT WPD # "0"', //SELECT. > SLIST
EXECUTE "LIST WPD 0 ID-SUPP (P)", //SELECT. < SLIST
*
END
