~BU1.SOURCEGEN~
X*PROGRAM: SOURCEGEN 
*
$INCLUDE IBP SOURCEGEN.DOC.HDR
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
!
*
STAT = FALSE
SIR = EMPTY; SIR.HDR = EMPTY; SIR.TEXTS = EMPTY; SIR.KEY = EMPTY; SIR.PMPT = EMPTY; FLNMS = EMPTY
!
CALL SOURCEGEN.INP.PARAMS(CNT.FILE,PAR.FILE,SCR.FILE.ID,SCR.FILE,OUT.FL.ID,BPF,IBPF,SCR.ID,TF,STAT)
*
!
* READ SCREEN
*
READ SIR FROM SCR.FILE,SCR.ID ELSE PRINT SCR.ID; SIR = EMPTY
*
CALL SOURCEGEN.LOAD(SCR.FILE,SCR.ID,TF,TEXT.AC,ID.AC,PMPT.AC,SIR.HDR,REDISP,TRANSL,ID.MAX,SIR,FIXED,SIR.TEXTS,SIR.KEY,SIR.PMPT,STAT)
*
IF STAT THEN PRINT "Error on ":SCR.ID; STOP
*
*
IF TF THEN
PRINT @(ZERO,ZERO):CLS:
PRINT RVB:"Application Generator Output ":OUT.FL.ID:" ":SCR.ID:RVE:
PRINT CLB:"< Init : ":
END
*
FLNMS = SIR<SCR.HDR$FILE.NAME>
IF TF THEN PRINT CLB:"< Files : ":FLNMS:; * RQM 
*
ALLOWED = SIR<SCR.HDR$ALLOWED>; IF ALLOWED EQ EMPTY THEN ALLOWED = "ACD"
IF TF THEN PRINT CLB:"< Allowed functions are: ":ALLOWED:" >":; * RQM
*
NO.DIM = SIR<SCR.HDR$NO.EQUATES>
*
CALL SOURCEGEN.CALLS(TF,SIR,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPD.S,UPDB.C,UPDE.C,DEL.S,DELB.C,DELE.C,ID.S,IDB.C,IDE.C,READ.S,READB.C,READE.C,ABO.C,INP.C,OPE.S,OPE.C,INIT.C,STAT)
*
SCRN.TYPE = SIR<SCR.HDR$SCREEN.TYPE>
IF SCRN.TYPE EQ EMPTY THEN SCRN.TYPE = "PSI"
IF INDEX(SCRN.TYPE,"S",ONE) THEN SBR = TRUE ELSE SBR = FALSE
SBR.F = EMPTY; SBR.LINE = EMPTY
IF TF THEN PRINT CLB:"< Rtn type : ":SCRN.TYPE:" >":; * RQM 
*
RELEASE.ID = SIR<SCR.HDR$RELEASE>
IF TF THEN PRINT CLB:"< Release : ":RELEASE.ID:" >":; * RQM 
*
INPUT.TYPE = SIR<SCR.HDR$INPUT.TYPE>
IF TF THEN PRINT CLB:"< Input Type : ":INPUT.TYPE:" >":; * RQM
*
*
* SPLIT 19 APR 91
* DGH
*
*
*
IF TF THEN PRINT CLB:"<Start : ":; * RQM
*
LNS = EMPTY
CALL SOURCEGEN.START(TOP.LNS,SCR.ID,RELEASE.ID,INP.C,SBR,STAT)
LNS<-ONE> = TOP.LNS
*
IF TF THEN PRINT CLB:"<Opens : ":; * RQM
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CALL SOURCEGEN.OPEN(IBPF,EQF.FILE,MAT EQT,MAT EQF,EQT.F,EQF.MAX,EQF.IND,INIT.LNS,OPEN.LNS,DIM.LNS,EQU.LNS,FLNMS,ID,SCR.ID,SBR,SBR.F,SBR.LN,TF,CO.DATA,NO.DIM,OPE.C,OPE.S,INIT.C,STAT)
LNS<-ONE> = INIT.LNS
CO.NAME = CO.DATA<ONE,ONE>
*
IF TF THEN PRINT CLB:"<Refs : ":; * RQM 
ID = FLNMS<ONE,ONE>:".ID"
CALL SOURCEGEN.VALID.REFS(REF.LNS,MAX.REF,PMPT.AC,SIR,TF,POS.LOC,POS.REF,POS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,STAT)
LNS<-ONE> = REF.LNS
*
IF TF THEN PRINT CLB:"<Main : ":; * RQM 
CALL SOURCEGEN.MAINLINE(MAIN.LNS,ID,ID.MAX,ID.AC,ID.S,IDB.C,IDE.C,MAT EQT,READB.C,READE.C,FIXED,ALLOWED,NO.DIM,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,MAX.REF,MSG,DELB.C,DELE.C,UPDB.C,UPDE.C,ABO.C,INP.C,OPE.C,INIT.C,FLNMS,READ.S,DEL.S,UPD.S,STAT)
LNS<-ONE> = MAIN.LNS
*
IF TF THEN PRINT CLB:"<Back : ":; * RQM 
CALL SOURCEGEN.BG.DISP(SCR.FILE,SCR.ID,MAT SCR.LNS,MAT LPT.LNS,BGR.LNS,MAX.REF,TEXT.AC,SIR,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,BG.C,TF,STAT)
LNS<-ONE> = BGR.LNS
*
IF TF THEN PRINT CLB:"<Fore : ":; * RQM 
GOSUB FG.DISP
*
IF TF THEN PRINT CLB:"<Key  : ":; * RQM 
CALL SOURCEGEN.KEY(KEY.LNS,MAT EQF,TF,SIR,IDB.C,IDE.C,FIXED,ID.MAX,EQF.IND,ID.AC,ID,REDISP,FLNMS,MAT EQT,EQ.F,READ.ITEMS,NO.DIM,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,ID.S,STAT)
LNS<-ONE> = KEY.LNS
*
IF TF THEN PRINT CLB:"<Lprt : ":; * RQM
IF NOT(LP.S) THEN GOSUB LP.DISP
*
IF TF THEN PRINT CLB:"<InputCalls : ":; * RQM 
GOSUB INPUT.CS
*
IF TF THEN PRINT CLB:"<InputFeild : ":; * RQM 
IF TF THEN PRINT @(10,23):"<Rtn Lns ":; * RQM
LNS<-ONE> = RTN.LNS
LNS<-ONE> = '*':AM:'!':AM:'*'
IF TRN.LNS NE EMPTY THEN
IF TF THEN PRINT @(20,23):"Trans ":; * RQM
LNS<-ONE> = TRN.LNS
LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF TF THEN PRINT CLB:"<Errors : ":; * RQM 
GOSUB ERROR.ROUTINE
LNS<-ONE> = ERR.LNS
*
IF TF THEN PRINT CLB:"<Reads : ":; * RQM 
GOSUB SET.UP.READ.ITEMS
*
IF TF THEN PRINT CLB:"<Custom : ":; * RQM 
CALL SOURCEGEN.CUSTOM(CALL.LNS,BG.C,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPDB.C,UPDE.C,DELB.C,DELE.C,IDB.C,IDE.C,READB.C,READE.C,ABO.C,INP.C,OPE.C,INIT.C,STAT)
LNS<-ONE> = CALL.LNS
*
IF TF THEN PRINT CLB:"<SpecialChars : ":; * RQM 
GOSUB REMOVE.SVM.VM
*
*SOURCEGEN.MAIN.END*
*
*
*********************
* ASSEMBLE PROGRAM HERE !!!
*********************
*
LNS<-ONE> = "END"
*
IF TF THEN 
PRINT CLB:"< WritePGM >":
PRINT @(20,23):"< * Bytes : ":LEN(LNS) "R#5":" >":
PRINT @(40,23):"< * Lines : ":DCOUNT(LNS,AM) "R#5":" >":
* RQM
END
*
CALL SOURCEGEN.WRITE(LNS,SBR,SCR.ID,SBR.LN,BPF,PAR.FILE,SCR.FILE,EQF.FILE,SPOS.LOC,SPOS.REF,SPOS.DISP,MAT SCR.LNS,SIR,SIR.HDR,SIR.TEXTS,SIR.KEY,SIR.PMPT,MAT EQF,TF,EQF.MAX)
*
IF TF THEN PRINT @(70,23):'Done':; * RQM
*
STOP
!
*
FG.DISP: * GEN FG DISPLAY AND INPUT SUBROUTINES
*
RTN.LNS = EMPTY; TRN.LNS = EMPTY; INP.NUM = ONE; TRN.NUM = ONE; READ.ITEMS = EMPTY
LNS<-ONE> = 'DISP.FG: *'
LNS<-ONE> = '*'
IF NOT(ID.S) OR LEN(IDB.C) OR LEN(IDE.C) THEN
LNS<-ONE> = 'IF REDISP THEN'
LNS<-ONE> = 'REDISP = FALSE'
LNS<-ONE> = 'TEMP = ':ID:'; FOR ID.CN = ONE TO ':ID.MAX - ID.AC + ONE:'; ':ID:'.SAVE<ID.CN> = "!":':ID:'.SAVE<ID.CN>':'; NEXT ID.CN; GOSUB GET.KEY; ':ID:' = TEMP'
LNS<-ONE> = 'END'
LNS<-ONE> = '*'
END
*
IF PMPT.AC THEN
CURR.AC = PMPT.AC
WINDOW.CN = ZERO; FIELD.CN = ZERO
*
LOOP
WINDOW.CN = WINDOW.CN + ONE 
IF TF THEN
PRINT @(40,23):CLL:" < W ":WINDOW.CN:" > ":; * RQM
END
FIRST.AC = CURR.AC; LAST.AC = CURR.AC; MAX.NUM = ONE
*
LOOP
SIR.AC = LAST.AC + ONE; REF = SIR<SIR.AC,ONE,ONE>[ONE,ONE]; IF REF = '"' THEN MAX.NUM = MAX.NUM + ONE
WHILE SIR<SIR.AC> NE EMPTY AND (REF EQ EMPTY OR REF EQ "," OR REF EQ '"' OR REF EQ "'") DO 
IF TF THEN
FIELD.CN = FIELD.CN + ONE 
PRINT @(60,23):" <F":FIELD.CN:">":; * RQM
END
LAST.AC = LAST.AC + ONE
REPEAT
*
LN = ZERO; CL = ZERO; LH = ZERO
SIR.AC = FIRST.AC; GOSUB EXTR.PMPT.DT
IF INPUT.REQD THEN ANY.INPUT = ONE ELSE ANY.INPUT = ZERO
*
IF TF THEN
IF LAST.AC NE FIRST.AC THEN FIELD.CN = ZERO
IF (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
END
*
IF VF THEN GOSUB VAR.DISP ELSE GOSUB NON.VAR.DISP
*
UNTIL SIR<CURR.AC> EQ EMPTY DO REPEAT
*
END
*
LNS<-ONE> = '*'
*
IF FG.C NE EMPTY THEN
LNS<-ONE> = 'GOSUB FG.C'
LNS<-ONE> = '*'
END
*
LNS<-ONE> = 'RETURN'
LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN
*
!
LP.DISP: *
*
LNS<-ONE> = 'DISP.LP: *'
LNS<-ONE> = '*'
LNS<-ONE> = 'IF PRINTER.FLAG THEN'
LNS<-ONE> = 'PRINTER ON'
LNS<-ONE> = 'END'
LNS<-ONE> = '*'
*
CALL SOURCEGEN.LP.DISP(SCR.FILE,SCR.ID,MAT SCR.LNS,MAT LPT.LNS,SLP.LNS,MAX.REF,TEXT.AC,SIR,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,LP.C,TF,STAT)
LNS<-ONE> = SLP.LNS
*
LNS<-ONE> = '*'
LNS<-ONE> = 'IF PRINTER.FLAG THEN'
LNS<-ONE> = 'PRINTER OFF'
LNS<-ONE> = 'END'
LNS<-ONE> = '*'
*
LNS<-ONE> = 'RETURN'
LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN
*
!
*
NON.VAR.DISP: *
*
FOR CURR.AC = FIRST.AC TO LAST.AC
*
IF CURR.AC NE FIRST.AC THEN SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT ELSE SAVE.PMPT.TYPE = PMPT.TYPE
IF SIR<CURR.AC + ONE,ONE,TWO>[ONE,ONE] EQ "*" THEN TRANSL = ONE ELSE TRANSL = EMPTY
*
IF INPUT.REQD THEN
RTN.LN = 'I':(INP.NUM + 100)[TWO,TWO]:': *'
* MAX.NUM = (LM - LN + ONE) * MAX.NUM
*
IF CURR.AC EQ FIRST.AC THEN IF MAX.NUM GT ONE THEN
RTN.LNS<-ONE> = RTN.LN
RTN.LNS<-ONE> = 'FOR SUB.REF = ONE TO ':MAX.NUM
LINE = EMPTY
*
FOR SUB.NUM = ONE TO MAX.NUM
LINE = LINE:'I':(INP.NUM + 100)[TWO,TWO]:CHAR(SUB.NUM+64):','
NEXT SUB.NUM
*
RTN.LNS<-ONE> = 'IF SUB.REF GE SUB.REF.LOC THEN'
RTN.LNS<-ONE> = 'ON SUB.REF GOSUB ':LINE[ONE,LEN(LINE) - ONE]
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO; IF SUB.REF LT ZERO THEN SUB.REF = ':MAX.NUM
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'NEXT SUB.REF'
RTN.LNS<-ONE> = 'SUB.REF.LOC = ZERO'
RTN.LNS<-ONE> = 'RETURN'
SUB.NUM = ONE
*
END
*
END
*
*
START.LN = LN
FOR LN = START.LN TO LM
*
IF INPUT.REQD THEN
*
LOCATE CL IN SPOS.LOC<LN + ONE> BY "AR" SETTING SCL.LOC ELSE
IF LN GT SPOS.LOC.MAX THEN SPOS.LOC.MAX = LN; SPOS.LOC<LN + ONE> = EMPTY; SPOS.REF<LN + ONE> = EMPTY
INS CL BEFORE SPOS.LOC<LN + ONE,SCL.LOC>
INS EMPTY BEFORE SPOS.REF<LN + ONE,SCL.LOC>
INS EMPTY BEFORE SPOS.DISP<LN + ONE,SCL.LOC>
END
SPOS.REF<LN + ONE,SCL.LOC> = SAVE.PMPT.TYPE:"|":LN - START.LN + ONE:"|":CURR.AC - FIRST.AC + ONE
*
IF LN EQ START.LN THEN
*
IF MAX.NUM GT ONE THEN RTN.LNS<-ONE> = "I":(INP.NUM + 100)[TWO,TWO]:CHAR(SUB.NUM + 64):": *"; SUB.NUM = SUB.NUM + ONE ELSE RTN.LNS<-ONE> = RTN.LN
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = LOCN
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":TMP
LINE = 'CALL INPUT.DATA.SG("':TMP1:'","':TMP:'",':FLNM:',':CL:',':LN:',"':MS[ONE,ONE]:MS[3,9]:'","':LHM:'",'
LINE = LINE:LOCN:',"':CONV:'","':EDIT:'",':EDIT.FILE:',RSP,REDISP,STAT)'
IF TRANSL THEN
RTN.LNS<-ONE> = LINE
LINE = 'IF STAT THEN RETURN ELSE LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
END
RTN.LNS<-ONE> = LINE
*
IF REDISP THEN
RTN.LNS<-ONE> = 'GOSUB DISP.BG; GOSUB DISP.FG'; REDISP = FALSE
RTN.LNS<-ONE> = 'RETURN'
END ELSE IF INPUT.REQD AND LN EQ START.LN THEN
RTN.LNS<-ONE> = 'RETURN'
END
*
END; * of start.ln
*
END; * of input.reqd
*
IF FL NE EMPTY THEN
*
DISP.LN = FLNM
*
IF NUM(AC) OR VC NE EMPTY THEN
*
DISP.LN = DISP.LN:EXTR
*
END
IF SB NE EMPTY THEN DISP.LN = 'FIELD(':DISP.LN:',"':SB[ONE,ONE]:'",':SB[TWO,TWO]:')'
IF CONV[ONE,ONE] = "D" OR CONV[ONE,ONE] = "M" THEN DISP.LN = 'OCONV(':DISP.LN:',"':CONV:'")'
LINE = 'PRINT @(':CL:',':LN:'):':DISP.LN:' "':MS:'":'
IF TRANSL THEN LINE = LINE:'; LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
LNS<-ONE> = LINE
SPOS.DISP<LN + ONE,SCL.LOC> = DISP.LN:' "':MS:'"'
IF TF AND (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
END
IF SB NE EMPTY THEN SB = SB[ONE,ONE]:SB[TWO,TWO] + ONE ELSE
IF SC NE EMPTY THEN
IF NUM(SC) THEN SC = SC + ONE
END ELSE IF VC NE EMPTY THEN
IF NUM(VC) THEN VC = VC + ONE
END ELSE
IF NUM(AC) THEN AC = AC + ONE
END
END
*
IF LN LT LM THEN GOSUB SET.UP.STRINGS
*
NEXT LN
*
*
IF TRANSL THEN
CURR.AC = CURR.AC + ONE
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
TRN.LN = FLNM:EXTR; IF SB NE EMPTY THEN TRN.LN = 'FIELD(':TRN.LN:',"':SB[ONE,ONE]:'",':SB[TWO,TWO]:')'
TRN.LNS<-ONE> = 'T':(TRN.NUM + 100)[TWO,TWO]:': TRN.FLD = ':TRN.LN
IF DT<ONE,ONE,3> MATCHES "0N" THEN
TRN.LNS<-ONE> = 'READV TRN.FLD FROM ':FIELD(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".",ONE):'.FILE,TRN.FLD,':DT<ONE,ONE,3>:' ELSE TRN.FLD = EMPTY'
IF DT<ONE,ONE,5> NE EMPTY THEN
TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:',':DT<ONE,ONE,5>:'>'
END ELSE IF DT<ONE,ONE,4> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:'>'
IF DT<ONE,ONE,6> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = FIELD(TRN.FLD,"':DT<ONE,ONE,6>[ONE,ONE]:'",':DT<ONE,ONE,6>[TWO,TWO]:')'
END ELSE
*
READ.ITEM = FIELD(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".",ONE):'*':DT<ONE,ONE,3>
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
TRN.LNS<-ONE> = 'LOCATE TRN.FLD IN ':DT<ONE,ONE,3>:'<ONE> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
END
*
TRN.LNS<-ONE> = 'PRINT @(':CL:',LN):TRN.FLD "':MS:'":'
TRN.LNS<-ONE> = 'RETURN'
IF TF AND (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
TRN.NUM = TRN.NUM + ONE; TRANSL = EMPTY
END
*
NEXT CURR.AC
*
INP.NUM = INP.NUM+ANY.INPUT
*
RETURN
*
!
*
VAR.DISP: *
*
IF SQ EQ "FI" THEN SORTED = 0 ELSE SORTED = ONE
DSP.LNS = EMPTY
INP.LNS = EMPTY
CLR.LNS = EMPTY
ADD.LNS = EMPTY
DEL.LNS = EMPTY
REF.LNS = EMPTY
REF.LN = EMPTY
CURR.AC = FIRST.AC
SAVE.PMPT.TYPE = PMPT.TYPE
*
*
FOR SUB.NUM = ONE TO MAX.NUM
*
IF SIR<CURR.AC + ONE,ONE,TWO>[ONE,ONE] EQ "*" THEN TRANSL = ONE ELSE TRANSL = EMPTY
*
IF INPUT.REQD THEN
IF REF.LN EQ EMPTY THEN
IF EDIT EQ EMPTY THEN TEMP = "SE":VM:"OP" ELSE TEMP = "SE":VM:"OP":VM:EDIT
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = EXTR
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":TMP
REF.LN = 'FLD = EMPTY; CALL INPUT.DATA.SG("':TMP1:'","':TMP:'",FLD,':LEN(PMPT.TEXT) + 8:',23,"'
REF.LN = REF.LN:MS[ONE,ONE]:MS[3,9]:'","':LHM:'",ONE,"':CONV:'","':TEMP:'",':EDIT.FILE:',RSP,REDISP,STAT)'
END
INP.LNS<-ONE> = 'I':(INP.NUM + 100)[TWO,TWO]:CHAR(SUB.NUM+64):': *'
TEMP = EDIT
IF NOT(SORTED) THEN IF SUB.NUM = ONE THEN
INP.LNS<-ONE> = 'IF ':FLNM:EXTR:' EQ " " THEN ':FLNM:EXTR:' = EMPTY'
INP.LNS<-ONE> = 'PRINT @(':CL-3:',LN):SPACE(2-LEN(':VTYPE:')):RVB:':VTYPE:':RVE:" ":'
IF TEMP EQ EMPTY THEN TEMP = "OP" ELSE TEMP = "OP":VM:TEMP
END
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = EXTR
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":TMP
LINE = 'CALL INPUT.DATA.SG("':TMP1:'","':TMP:'",':FLNM:',':CL:',LN,"':MS[ONE,ONE]:MS[3,9]:'","':LHM:'",'
INP.LNS<-ONE> = LINE:LOCN:',"':CONV:'","':TEMP:'",':EDIT.FILE:',RSP,REDISP,STAT)'
IF NOT(SORTED) THEN IF SUB.NUM EQ ONE THEN
INP.LNS<-ONE> = 'IF RSP EQ EMPTY THEN IF DYN NE "N" THEN PRINT BELL:; GOTO I':(INP.NUM + 100)[TWO,TWO]:CHAR(SUB.NUM+64)
END
IF TRANSL THEN INP.LNS<-ONE> = 'IF STAT THEN RETURN ELSE GOSUB T':(TRN.NUM + 100)[TWO,TWO]
INP.LNS<-ONE> = 'RETURN'
END
*
*
DISP.LN = FLNM:EXTR
IF CONV[ONE,ONE] EQ "D" OR CONV[ONE,ONE] EQ "M" THEN DISP.LN = 'OCONV(':DISP.LN:',"':CONV:'")'
*
IF NOT(SORTED) AND SUB.NUM EQ ONE THEN
* SPOS.DISP<LN + ONE,SCL.LOC> = 'SPACE(TWO - LEN(':VTYPE:')):':VTYPE:':" ":':DISP.LN:' "':MS:'"'
DISP.LN = 'PRINT @(':CL - 3:',LN):SPACE(TWO - LEN(':VTYPE:')):RVB:':VTYPE:':RVE:" ":':DISP.LN:' "':MS:'":'
CLEAR.LN = 'PRINT @(':CL-3:',LN):SPACE(':MS[3,TWO]+3:'):'
TEMP = '" "'
* ? *IF SUB.NUM EQ ONE THEN TEMP = 'RSP' ELSE TEMP = '" "'
END ELSE
* SPOS.DISP<LN + ONE,SCL.LOC> = DISP.LN:' "':MS:'"'
DISP.LN = 'PRINT @(':CL:',LN):':DISP.LN:' "':MS:'":'
CLEAR.LN = 'PRINT @(':CL:',LN):SPACE(':MS[3,TWO]:'):'
IF SUB.NUM EQ ONE THEN TEMP = 'RSP' ELSE TEMP = '" "'
END
*
IF TRANSL THEN
DISP.LN = DISP.LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
CLEAR.LN = CLEAR.LN:'; GOSUB TC':(TRN.NUM + 100)[TWO,TWO]
END
*
DSP.LNS<-ONE> = DISP.LN
CLR.LNS<-ONE> = CLEAR.LN
*
IF INPUT.REQD AND (SUB.NUM EQ ONE OR NOT(VTYPE.FL)) THEN
ADD.LNS<-ONE> = 'INS ':TEMP:' BEFORE ':FLNM:INST
DEL.LNS<-ONE> = 'DEL ':FLNM:INST
END
*
IF (LN OR CL) THEN
*
*
START.LN = LN
FOR TMP.LN = LN TO LM
*
LOCATE CL IN SPOS.LOC<TMP.LN + ONE> BY "AR" SETTING SCL.LOC ELSE
IF TMP.LN GT SPOS.LOC.MAX THEN SPOS.LOC.MAX = TMP.LN; SPOS.LOC<TMP.LN + ONE> = EMPTY; SPOS.REF<TMP.LN + ONE> = EMPTY; SPOS.DISP<TMP.LN + ONE> = EMPTY
INS CL BEFORE SPOS.LOC<TMP.LN + ONE,SCL.LOC>
INS PMPT.TYPE BEFORE SPOS.REF<TMP.LN + ONE,SCL.LOC>
INS EMPTY BEFORE SPOS.DISP<TMP.LN + ONE,SCL.LOC>
END
SPOS.REF<TMP.LN + ONE,SCL.LOC> = SAVE.PMPT.TYPE:"|":TMP.LN - START.LN + ONE:"|":CURR.AC - FIRST.AC + ONE
*
IF TF AND LH THEN
PRINT @(CL,TMP.LN):RVB:STR("#",LH):RVE:
END
*
IF SPOS.MAX THEN
TMP = FLNM:'<'
TMP1 = 'TOP.DISP.LOC(':INP.NUM:') + ':TMP.LN - LN
*
FOR SPOS.CN = ONE TO SPOS.MAX
IF SPOS.CN GT ONE THEN TMP = TMP:','
IF SPOS.CN EQ VTYPE.VC - ONE THEN
TMP = TMP:TMP1
END ELSE
TMP = TMP:FIELD(SPOS,',',SPOS.CN)
END
NEXT SPOS.CN
*
TMP = TMP:'>'
END ELSE
TMP = FLNM:EXTR
TMP1 = EMPTY
END; * OF SPOS.MAX
*
IF NOT(SORTED) AND SUB.NUM EQ ONE THEN
SPOS.DISP<TMP.LN + ONE,SCL.LOC> = 'SPACE(TWO - LEN(':TMP1:')):':TMP1:':" ":':TMP:' "':MS:'"'
END ELSE
SPOS.DISP<TMP.LN + ONE,SCL.LOC> = TMP:' "':MS:'"'
END
*
NEXT TMP.LN
*
*
* RQM
END; * OF LN OR CL
*
IF TRANSL THEN
SAVE = AC:AM:VC:AM:SC:AM:REDISP:AM:TRUE.AC:AM:VTYPE:AM:VTYPE.VC:AM:VTYPE.FL:AM:SQ:AM:VF
CURR.AC = CURR.AC + ONE
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
TRN.LNS<-ONE> = 'T':(TRN.NUM + 100)[TWO,TWO]:': TRN.FLD = ':FLNM:EXTR
IF DT<ONE,ONE,3> MATCHES "0N" THEN
TRN.LNS<-ONE> = 'READV TRN.FLD FROM ':FIELD(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".",ONE):'.FILE,TRN.FLD,':DT<ONE,ONE,3>:' ELSE TRN.FLD = EMPTY'
IF DT<ONE,ONE,5> NE EMPTY THEN
TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:',':DT<ONE,ONE,5>:'>'
END ELSE IF DT<ONE,ONE,4> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:'>'
IF DT<ONE,ONE,6> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = FIELD(TRN.FLD,"':DT<ONE,ONE,6>[ONE,ONE]:'",':DT<ONE,ONE,6>[TWO,TWO]:')'
END ELSE
READ.ITEM = FIELD(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".",ONE):'*':DT<ONE,ONE,3>
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
TRN.LNS<-ONE> = 'LOCATE TRN.FLD IN ':DT<ONE,ONE,3>:'<ONE> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
END
TRN.LNS<-ONE> = 'PRINT @(':CL:',LN):TRN.FLD "':MS:'":'
TRN.LNS<-ONE> = 'RETURN'
TRN.LNS<-ONE> = 'TC':(TRN.NUM + 100)[TWO,TWO]:': PRINT @(':CL:',LN):SPACE(':LH:'):; RETURN'
IF TF AND (LN OR CL) AND LH THEN
FOR TMP = LN TO LM
PRINT @(CL,TMP):RVB:STR("#",LH):RVE:
NEXT TMP
* RQM
END
TRN.NUM = TRN.NUM + ONE; TRANSL = EMPTY
AC = SAVE<ONE>; VC = SAVE<TWO>; SC = SAVE<3>; REDISP = SAVE<4>
TRUE.AC = SAVE<5>; VTYPE = SAVE<6>; VTYPE.VC = SAVE<7>; VTYPE.FL = SAVE<8>
SQ = SAVE<9>; VF = SAVE<10>
END
*
IF REDISP THEN INP.LNS<-ONE> = 'GOSUB DISP.BG; GOSUB DISP.FG'; REDISP = FALSE
CURR.AC = CURR.AC + ONE
IF TRANSL THEN TRANSL = EMPTY; CURR.AC = CURR.AC + ONE
*
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
*
NEXT SUB.NUM
*
!
* DISPLAY AND CLEAR ROUTINES
SIR.AC = FIRST.AC; GOSUB EXTR.PMPT.DT
LNS<-ONE> = 'DYN = EMPTY; GOSUB D':(INP.NUM + 100)[TWO,TWO]:'; IF STAT EQ 999 THEN RETURN'
INP.LNS<-ONE> = 'D':(INP.NUM + 100)[TWO,TWO]:': *'
INP.LNS<-ONE> = 'SAVE.':VTYPE:' = ':VTYPE
INP.LNS<-ONE> = 'IF TOP.DISP.LOC(':INP.NUM:') LT ZERO THEN TOP.DISP.LOC(':INP.NUM:') = ABS(TOP.DISP.LOC(':INP.NUM:')) ELSE'
INP.LN = 'IF ':VTYPE:' GE TOP.DISP.LOC(':INP.NUM:') THEN IF '
INP.LN = INP.LN:VTYPE:' LE TOP.DISP.LOC(':INP.NUM:') + ':LM - LN:' THEN'
IF NOT(SORTED) THEN INP.LNS<-ONE> = INP.LN:' RETURN' ELSE
INP.LNS<-ONE> = INP.LN
INP.LNS<-ONE> = 'IF DYN EQ "N" THEN LN = MOD(':VTYPE:' - ONE,':LM - LN + ONE:') + ':LN:'; ':DSP.LNS<ONE>
INP.LNS<-ONE> = 'RETURN'
INP.LNS<-ONE> = 'END'
END
INP.LNS<-ONE> = 'END'
INP.LN = 'IF TOP.DISP.LOC(':INP.NUM:') THEN ':VTYPE
INP.LNS<-ONE> = INP.LN:' = ':VTYPE:'-MOD(':VTYPE:' - ONE,':LM - LN + ONE:'); CLEAR = ONE ELSE ':VTYPE:' = ONE; CLEAR = ZERO'
INP.LNS<-ONE> = 'TOP.LOC = EMPTY'
INP.LNS<-ONE> = 'LOOP'
INP.LNS<-ONE> = 'FOR LN = ':LN:' TO ':LM:' UNTIL ':FLNM:EXTR:' = EMPTY'
INP.LNS<-ONE> = 'IF LN EQ ':LN:' THEN TOP.LOC = ':VTYPE
* WRITE DSP.LNS    ON SCR.FILE,SCR.ID:"*DSP"
INP.LNS<-ONE> = DSP.LNS
INP.LNS<-ONE> = VTYPE:' = ':VTYPE:' + ONE'
INP.LNS<-ONE> = 'NEXT LN'
INP.LNS<-ONE> = 'IF TOP.DISP.LOC(':INP.NUM:') OR ':FLNM:EXTR:' EQ EMPTY THEN RSP = EMPTY ELSE'
INP.LNS<-ONE> = 'PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":'
INP.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN'
INP.LNS<-ONE> = 'IF RSP EQ "RE" THEN ':VTYPE:' = ONE; RSP = "Y"'
INP.LNS<-ONE> = 'IF RSP EQ "P" THEN'
INP.LNS<-ONE> = VTYPE:' = TOP.LOC - ':LM - LN + ONE
INP.LNS<-ONE> = 'IF ':VTYPE:' LT ZERO THEN ':VTYPE:' = ONE'
INP.LNS<-ONE> = 'RSP = "Y"'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'IF RSP EQ "N" THEN RSP = "Y"'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'WHILE RSP = "Y" DO LN = ':LN:'; GOSUB C':(INP.NUM + 100)[TWO,TWO]:' REPEAT'
INP.LNS<-ONE> = 'IF CLEAR THEN GOSUB C':(INP.NUM + 100)[TWO,TWO]:' ELSE CLEAR = 1'
INP.LNS<-ONE> = 'IF TOP.LOC THEN TOP.DISP.LOC(':INP.NUM:') = TOP.LOC'
INP.LNS<-ONE> = VTYPE:' = SAVE.':VTYPE
INP.LNS<-ONE> = 'RETURN'
INP.LNS<-ONE> = 'C':(INP.NUM + 100)[TWO,TWO]:': FOR LN = LN TO ':LM
* WRITE CLR.LNS    ON SCR.FILE,SCR.ID:"*CLR"
INP.LNS<-ONE> = CLR.LNS
INP.LNS<-ONE> = 'NEXT LN'
INP.LNS<-ONE> = 'RETURN'
IF NOT(INPUT.REQD) THEN RETURN
*
!
* FIXED OR VARIABLE LOCATIONS
IF NOT(SORTED) THEN
TEMP = 'LOCATE EMPTY IN ':FLNM
TEMP = TEMP:LOCT
TEMP = TEMP:' SETTING ':VTYPE:' ELSE NULL'
RTN.LNS<-ONE> = 'I':(INP.NUM + 100)[TWO,TWO]:': *'
RTN.LNS<-ONE> = 'IF NEW THEN'
RTN.LNS<-ONE> = TEMP
RTN.LNS<-ONE> = 'DYN = "N"'
RTN.LNS<-ONE> = 'END ELSE'
IF MAX.REF GT ONE THEN RTN.LN = 'Ref. ':PMPT.TYPE:'> - ' ELSE RTN.LN = EMPTY
RTN.LNS<-ONE> = 'PRINT CLB:"':RTN.LN:'Enter line no., N(ext line) or <cr> if okay: ":'
RTN.LNS<-ONE> = 'IF NOT(LN.LOC) THEN'
RTN.LNS<-ONE> = 'INPUT DYN:; IF DYN EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = 'DYN = TOP.DISP.LOC(':INP.NUM:'); IF DYN THEN DYN = DYN - ONE'
RTN.LNS<-ONE> = 'DYN = DYN + LN.LOC'
RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'IF DYN EQ EMPTY OR DYN = "^" THEN RETURN'
RTN.LNS<-ONE> = 'IF DYN EQ "N" THEN'
RTN.LNS<-ONE> = TEMP
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = 'IF NOT(DYN MATCHES "0N") THEN PRINT BELL:; GOTO I':(INP.NUM + 100)[TWO,TWO]
RTN.LNS<-ONE> = 'IF NOT(DYN) THEN PRINT BELL:; GOTO I':(INP.NUM + 100)[TWO,TWO]
RTN.LNS<-ONE> = VTYPE:' = DYN'
RTN.LNS<-ONE> = 'IF ':FLNM:EXTR:' EQ EMPTY THEN PRINT BELL:; GOTO I':(INP.NUM + 100)[TWO,TWO]
RTN.LNS<-ONE> = 'LOOP'
RTN.LNS<-ONE> = 'PRINT CLB:"Enter I(nsert), D(elete) or <cr> to change line: ":'
RTN.LNS<-ONE> = 'INPUT DYN:; IF DYN EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'IF NOT(DYN EQ "I" OR DYN EQ "N") THEN'
RTN.LNS<-ONE> = 'IF DYN EQ "D" THEN'
END ELSE
RTN.LNS<-ONE> = 'I':(INP.NUM + 100)[TWO,TWO]:': *'
RTN.LNS<-ONE> = 'IF NOT(LN.LOC) THEN'
RTN.LNS<-ONE> = 'PRINT CLB:"Enter ':PMPT.TEXT:': ":'
RTN.LNS<-ONE> = REF.LN
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'IF STAT THEN TEXT = RSP<TWO>; GOSUB ERROR; GOTO I':(INP.NUM + 100)[TWO,TWO]
RTN.LNS<-ONE> = 'IF FLD EQ EMPTY THEN RETURN'
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = VTYPE:' = TOP.DISP.LOC(':INP.NUM:'); IF ':VTYPE:' THEN ':VTYPE:' = ':VTYPE:' - ONE'
RTN.LNS<-ONE> = VTYPE:' = ':VTYPE:' + LN.LOC'
RTN.LNS<-ONE> = 'FLD = ':FLNM:EXTR
RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'END'
RTN.LN = 'LOCATE FLD IN ':FLNM
RTN.LN = RTN.LN:LOCT
*
RTN.LNS<-ONE> = RTN.LN:' BY "':SQ:'" SETTING ':VTYPE:' THEN'
RTN.LN = 'PRINT CLB:'
*
IF MAX.REF GT ONE THEN RTN.LN = RTN.LN:'"Ref. ':PMPT.TYPE:'> ":'
*
IF CONV EQ EMPTY THEN RTN.LN = RTN.LN:'FLD' ELSE RTN.LN = RTN.LN:'OCONV(FLD,"':CONV:'")'
*
RTN.LNS<-ONE> = RTN.LN:':" - Delete it (Y/<cr>)? ":'
RTN.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'IF RSP NE "Y" THEN DYN = EMPTY; PRINT CLB: ELSE'
END
*
* WRITE DEL.LNS    ON SCR.FILE,SCR.ID:"*DEL"
RTN.LNS<-ONE> = DEL.LNS
*
RTN.LNS<-ONE> = 'TOP.DISP.LOC(':INP.NUM:') = -ABS(TOP.DISP.LOC(':INP.NUM:'))'
RTN.LNS<-ONE> = 'DYN = "D"; GOSUB D':(INP.NUM + 100)[TWO,TWO]:'; IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'GOTO I':(INP.NUM + 100)[TWO,TWO]
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'END ELSE'
*
IF SORTED THEN RTN.LNS<-ONE> = 'IF ':FLNM:EXTR:' EQ EMPTY THEN DYN = "N" ELSE DYN = "I"'
*
RTN.LNS<-ONE> = 'IF ':VTYPE:' GT ':VF:' THEN IF NEW AND DYN EQ "N" THEN RETURN ELSE'
RTN.LNS<-ONE> = 'TEXT = "Max. entries allowed is ':VF:'"; GOSUB ERROR; GOTO I':(INP.NUM + 100)[TWO,TWO]
RTN.LNS<-ONE> = 'END'
*
* WRITE ADD.LNS    ON SCR.FILE,SCR.ID:"*ADD"
RTN.LNS<-ONE> = ADD.LNS
*
RTN.LN = 'IF DYN EQ "I" THEN TOP.DISP.LOC(':INP.NUM:') = -ABS(TOP.DISP.LOC(':INP.NUM:')) ELSE '
RTN.LNS<-ONE> = RTN.LN:'IF NOT(TOP.DISP.LOC(':INP.NUM:')) THEN TOP.DISP.LOC(':INP.NUM:') = ONE'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'GOSUB D':(INP.NUM + 100)[TWO,TWO]:'; IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'LN = MOD(':VTYPE:' - ONE,':LM - LN + ONE:') + ':LN
*
IF MAX.NUM GT ONE OR NOT(SORTED) THEN
*
LINE = EMPTY
RTN.LNS<-ONE> = 'FOR SUB.REF = ONE TO ':MAX.NUM - SORTED
*
FOR SUB.NUM = SORTED + ONE TO MAX.NUM
LINE = LINE:'I':(INP.NUM + 100)[TWO,TWO]:CHAR(SUB.NUM+64):','
NEXT SUB.NUM
*
*
RTN.LNS<-ONE> = 'IF SUB.REF GE SUB.REF.LOC - ':SORTED + ZERO:' THEN'
RTN.LNS<-ONE> = 'ON SUB.REF GOSUB ':LINE[ONE,LEN(LINE) - ONE]
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO; IF SUB.REF LT ZERO THEN SUB.REF = ':MAX.NUM
*
IF NOT(SORTED) THEN RTN.LNS<-ONE> = 'IF SUB.REF EQ ONE THEN IF RSP EQ EMPTY THEN RETURN'
*
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'NEXT SUB.REF'
RTN.LNS<-ONE> = 'SUB.REF.LOC = ZERO'
*
END
*
RTN.LNS<-ONE> = 'GOTO I':(INP.NUM + 100)[TWO,TWO]
*
* WRITE INP.LNS    ON SCR.FILE,SCR.ID:"*INP"
RTN.LNS<-ONE> = INP.LNS
*
INP.NUM = INP.NUM + ANY.INPUT
*
RTN.LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN
*
!
*
INPUT.CS: * SET UP SOUBROUTINE CALL SEQUENCE
MAX.NUM = INP.NUM - ONE
LNS<-ONE> = 'GET.DATA: *'
LINE = EMPTY
IF INP.NUM THEN
FOR INP.NUM = ONE TO MAX.NUM
LINE = LINE:'I':(INP.NUM + 100)[TWO,TWO]:','
NEXT INP.NUM
LNS<-ONE> = 'ON REF GOSUB ':LINE[ONE,LEN(LINE) - ONE]
END
LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA'
LNS<-ONE> = 'RETURN'
LNS<-ONE> = '*':AM:'!':AM:'*'
LINE = EMPTY
*
RETURN
*
!
*
SET.UP.READ.ITEMS: *
*
READ.LNS = EMPTY
READ.NUM = ONE
READ.NUM.MAX = DCOUNT(READ.ITEMS,AM)
LOOP READ.ITEM = READ.ITEMS<READ.NUM> UNTIL READ.NUM GT READ.NUM.MAX DO
IF READ.ITEM NE EMPTY THEN
LINE = 'READ ':FIELD(READ.ITEM,"*",TWO):' FROM ':FIELD(READ.ITEM,"*",ONE):'.FILE,"':FIELD(READ.ITEM,"*",TWO)
READ.LNS<-ONE> = LINE:'" ELSE ':FIELD(READ.ITEM,"*",TWO):' = EMPTY'
IF TF THEN PRINT @(ZERO,23):FIELD(READ.ITEM,"*",ONE):" ":FIELD(READ.ITEM,"*",TWO):" ":; * RQM
END
READ.NUM = READ.NUM + ONE
REPEAT
*
IF READ.NUM EQ ONE THEN RETURN
*
READ.LNS<-ONE> = '*':AM:'*'
LOCATE '*READ.LNS*' IN LNS SETTING LOC THEN LOC = LOC + ONE ELSE LOC = DCOUNT(LNS,AM)
INS READ.LNS BEFORE LNS<LOC>
*
RETURN
*
!
*
ERROR.ROUTINE: * LOAD ERROR ROUTINE
*
ERR.LNS = EMPTY
ERR.LNS<-ONE> = '*ERR.LNS*'
ERR.LNS<-ONE> = 'ERROR: *'
ERR.LNS<-ONE> = 'IF TEXT EQ EMPTY THEN RETURN'
ERR.LNS<-ONE> = 'PRINT BELL:CLB:TEXT[ONE,80]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":'
ERR.LNS<-ONE> = 'INPUT RSP:; PRINT CLB:'
ERR.LNS<-ONE> = 'RETURN'
ERR.LNS<-ONE> = '*ERR.END*'
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN
*
!
*
EXTR.PMPT.DT: *
*
CALL SOURCEGEN.PMPT(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,LM,MS,VF,SQ,VTYPE,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX)
*
RETURN
*
!
*
SET.UP.STRINGS: *
*
CALL SOURCEGEN.SETUP.STR(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,LM,MS,VF,SQ,VTYPE,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX)
*
RETURN
*
!
*
REMOVE.SVM.VM: *
*
CN = ONE
LOOP
VM.LOC = INDEX(LNS,CHAR(27),ONE)
WHILE VM.LOC DO
LNS = LNS[ONE,VM.LOC - ONE]:'":ESC:"':LNS[VM.LOC + ONE,99999]
IF TF THEN PRINT @(30,23):'ESC ':CN:; * RQM
CN = CN + ONE 
REPEAT
*
CN = ONE
LOOP
VM.LOC = INDEX(LNS,CHAR(253),ONE)
WHILE VM.LOC DO
LNS = LNS[ONE,VM.LOC - ONE]:'":VM:"':LNS[VM.LOC + ONE,99999]
IF TF THEN PRINT @(40,23):'VM ':CN:; * RQM
CN = CN + ONE 
REPEAT
*
CN = ONE
LOOP
VM.LOC = INDEX(LNS,CHAR(252),ONE)
WHILE VM.LOC DO
LNS = LNS[ONE,VM.LOC - ONE]:'":SVM:"':LNS[VM.LOC + ONE,99999]
IF TF THEN PRINT @(50,23):'SVM ':CN:; * RQM
CN = CN + ONE
REPEAT
*
RETURN
*
!
*
END
~BU2.SOURCEGEN~
*PROGRAM: SOURCEGEN
*
$INCLUDE BP.SG SOURCEGEN.DOC.HDR
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
!
*
STAT = FALSE; ENTRY.TYPE = ZERO; OUT.FL.ID = EMPTY; SCR.ID = EMPTY
LST.END = FALSE; FIRST = TRUE
EQ.F = EMPTY; MAT EQF = EMPTY; MAT EQT = EMPTY; EQF.IND = EMPTY
SBR = FALSE; SBR.F = EMPTY; SBR.LN = EMPTY
NO.DIM = EMPTY; REC.FL = EMPTY; FLNMS = EMPTY; FLNM = EMPTY; FLNM.SUFF = EMPTY
SIR = EMPTY; SIR.AC = EMPTY; READ.ITEMS = EMPTY
TRUE.AC = EMPTY; REF.AC = EMPTY; FL = EMPTY
AC = EMPTY; VC = EMPTY; SC = EMPTY; SB = EMPTY
PMPT.TYPE = EMPTY; PMPT.TEXT = EMPTY; PMPT.RSP = EMPTY
INPUT.REQD = EMPTY; EXTR = EMPTY; INST = EMPTY; POSN = EMPTY; LOCT = EMPTY
LOCN = EMPTY; OLD.LOCN = EMPTY; CONV = EMPTY; EDIT = EMPTY
EDIT.FILE = EMPTY; CL = EMPTY; LN = EMPTY
LH = EMPTY; LHM = EMPTY; LM = EMPTY; MS = EMPTY
VF = EMPTY; CNTRL.AC = EMPTY; SQ = EMPTY
VTYPE = EMPTY; VTYPE.VC = EMPTY; VTYPE.FL = EMPTY; DT = EMPTY
SPOS = EMPTY; SPOS.MAX = EMPTY
*
!
*
MAIN: *
*
LOOP
*
SIR = EMPTY; SIR.HDR = EMPTY; SIR.TEXTS = EMPTY; SIR.KEY = EMPTY
SIR.PMPT = EMPTY; FLNMS = EMPTY
*
IF NOT(LST.END) THEN
READNEXT SCR.ID THEN LST.END = FALSE ELSE LST.END = TRUE
END ELSE SCR.ID = EMPTY
IF SCR.ID[ONE,8] EQ "SH.SUBR." THEN SCR.ID = SCR.ID[9,9999]
IF SCR.ID[ONE,3] EQ "SH." THEN SCR.ID = SCR.ID[4,9999]
!
IF (SCR.ID EQ EMPTY OR FIRST) AND NOT(ENTRY.TYPE) THEN
CALL SOURCEGEN.INP.PARAMS(CNT.FILE,SYS.FILE,SCR.FILE.ID,SCR.FILE,OUT.FL.ID,BPF.FILE,IBPF.FILE,SCR.ID,TF,ENTRY.TYPE,DISPL.FLAG,DISPL.OPT,BASIC.FLAG,BASIC.OPT,CATLG.FLAG,CATLG.OPT,FIRST,STAT)
IF SCR.ID[ONE,8] EQ "SH.SUBR." THEN SCR.ID = SCR.ID[9,9999]
IF SCR.ID[ONE,3] EQ "SH." THEN SCR.ID = SCR.ID[4,9999]
END
*
WHILE SCR.ID NE EMPTY AND NOT(STAT) DO
*
! RECORD LOCATION
*
EXEC.VERB = "ACC.UPDATE"
EXEC.IN = "S/W Inst SourceGen" "L#25":("Doing ":OUT.FL.ID:" ":SCR.ID) "L#25"
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
!
* READ SCREEN
*
READ SIR FROM SCR.FILE,SCR.ID THEN
*
IF TF THEN
PRINT @(ZERO,ZERO):CLS:
END
*
CALL SOURCEGEN.LOAD(SCR.FILE,SCR.ID,TF,TEXT.AC,ID.AC,PMPT.AC,SIR.HDR,REDISP,TRANSL,ID.MAX,SIR,FIXED.KEY,SIR.TEXTS,SIR.KEY,SIR.PMPT,STAT)
*
END ELSE PRINT SCR.ID:" missing!":BELL:; SIR = EMPTY; * SCR.ID = EMPTY
*
IF SCR.ID NE EMPTY THEN
*
*
IF TF THEN
PRINT @(ZERO,ZERO):RVB:"<Application Generator Output ":OUT.FL.ID:" ":SCR.ID:">":RVE:
PRINT @(ZERO,TWO):CLL:@(40):RVB:"<":SCR.ID:" ":OUT.FL.ID:RVE:
PRINT @(ZERO,3):CLL:@(40):"<Init: ":
END
*
IF SIR<SCR.HDR$FILE> NE EMPTY THEN
OPEN SIR<SCR.HDR$FILE> TO BPF.FILE THEN
OUT.FL.ID = SIR<SCR.HDR$FILE>
PRINT @(ZERO,ZERO):CLL:
PRINT RVB:"Application Generator Output is Set at ":OUT.FL.ID:" ":SCR.ID:RVE:
END ELSE 
PRINT 
PRINT "Can't open ":SIR<SCR.HDR$FILE>:"!"
PRINT BELL:
END
END
*
FLNMS = SIR<SCR.HDR$FILE.NAME>
IF TF THEN PRINT @(ZERO,4):CLL:@(40):"<Files: ":FLNMS:">":; * RQM 
ALLOWED = SIR<SCR.HDR$ALLOWED>; IF ALLOWED EQ EMPTY THEN ALLOWED = "ACD"
IF TF THEN PRINT @(ZERO,5):CLL:@(40):"<Allow: ":ALLOWED:">":; * RQM
*
NO.DIM = SIR<SCR.HDR$NO.EQUATES>
REC.FL = SIR<SCR.HDR$REC.FLAG>
*
CALL SOURCEGEN.CALLS(SIR,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPD.S,UPDB.C,UPDE.C,DEL.S,DELB.C,DELE.C,ID.S,IDB.C,IDE.C,READ.S,READB.C,READE.C,ABO.C,INP.C,OPE.S,OPE.C,INIT.C,TF,STAT)
*
SCRN.TYPE = SIR<SCR.HDR$SCREEN.TYPE>
IF SCRN.TYPE EQ EMPTY THEN SCRN.TYPE = "PSI"
SBR = FALSE; SBR.F = EMPTY; SBR.LN = EMPTY
IF INDEX(SCRN.TYPE,"S",ONE) THEN SBR = TRUE ELSE SBR = FALSE
IF TF THEN PRINT @(ZERO,7):CLL:@(40):"<Rtn.Type: ":SCRN.TYPE:">":; * RQM 
*
RELEASE.ID = SIR<SCR.HDR$RELEASE>
IF TF THEN PRINT @(55,3):"<Release: ":RELEASE.ID:">":; * RQM 
*
INPUT.TYPE = SIR<SCR.HDR$INPUT.TYPE>
IF TF THEN PRINT @(55,7):"<Input.Type: ":INPUT.TYPE:">":; * RQM
*
*
* SPLIT 19 APR 91
* DGH
*
*
*
IF TF THEN PRINT @(55,5):"<Start: ":; * RQM
*
LNS = EMPTY; READ.LNS = EMPTY
CALL SOURCEGEN.START(TOP.LNS,SCR.ID,RELEASE.ID,INP.C,SBR,TF,STAT)
LNS<-ONE> = TOP.LNS
TOP.LNS = EMPTY
*
IF TF THEN PRINT @(ZERO,8):CLL:@(40):"<Opens: ":; * RQM
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CALL SOURCEGEN.OPEN(IBPF.FILE,EQF.FILE,MAT EQT,MAT EQF,EQT.F,EQF.MAX,EQF.IND,INIT.LNS,OPEN.LNS,DIM.LNS,EQU.LNS,FLNMS,ID,SCR.ID,SBR,SBR.F,SBR.LN,TF,CO.DATA,NO.DIM,REC.FL,OPE.C,OPE.S,INIT.C,STAT)
* LNS<-ONE> = INIT.LNS
* INIT.LNS = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
*
IF TF THEN PRINT @(ZERO,10):CLL:@(40):"<Refs: ":; * RQM 
ID = FLNMS<ONE,ONE>:".ID"
CALL SOURCEGEN.VALID.REFS(REF.LNS,MAX.REF,PMPT.AC,SIR,TF,POS.LOC,POS.REF,POS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,STAT)
*
*
LNS<-ONE> = REF.LNS
* REF.LNS = EMPTY
*
*
LNS<-ONE> = INIT.LNS
INIT.LNS = EMPTY
*
*
** IF TF THEN PRINT @(ZERO,18):CLL:@(ZERO,19):CLL:@(ZERO,20):CLL:
IF TF THEN PRINT @(ZERO,9):CLL:@(40):"<Main: ":; * RQM 
CALL SOURCEGEN.MAINLINE(MAIN.LNS,ID,ID.MAX,ID.AC,ID.S,IDB.C,IDE.C,MAT EQT,READB.C,READE.C,FIXED.KEY,ALLOWED,NO.DIM,REC.FL,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,MAX.REF,MSG,DELB.C,DELE.C,UPDB.C,UPDE.C,ABO.C,INP.C,OPE.C,INIT.C,FLNMS,READ.S,DEL.S,UPD.S,TF,STAT)
LNS<-ONE> = MAIN.LNS
MAIN.LNS = EMPTY
*
** IF TF THEN PRINT @(ZERO,11):CLL:@(ZERO,12):CLL:@(40,12):"<Back: ":; * RQM 
IF TF THEN PRINT @(50,10):"<Back: ":; * RQM
CALL SOURCEGEN.BG.DISP(SCR.FILE,SCR.ID,MAT SCR.LNS,MAT LPT.LNS,BGR.LNS,MAX.REF,TEXT.AC,SIR,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,BG.C,TF,STAT)
LNS<-ONE> = BGR.LNS
BGR.LNS = EMPTY
*
IF TF THEN PRINT @(60,10):"<Fore: ":; * RQM 
GOSUB FG.DISP
*
IF TF THEN PRINT @(70,10):"<Key: ":; * RQM 
CALL SOURCEGEN.KEY(KEY.LNS,MAT EQF,TF,SIR,IDB.C,IDE.C,FIXED.KEY,ID.MAX,EQF.IND,ID.AC,ID,REDISP,FLNMS,MAT EQT,EQ.F,READ.ITEMS,NO.DIM,REC.FL,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,ID.S,TRN.NUM,SCR.ID,STAT)
LNS<-ONE> = KEY.LNS
KEY.LNS = EMPTY
*
IF TF THEN PRINT @(ZERO,19):"<Lptr: ":; * RQM
IF NOT(LP.S) THEN GOSUB LP.DISP
* EQU.LNS = EMPTY
* DIM.LNS = EMPTY
*
IF TF THEN PRINT @(40,17):"<InCalls: ":; * RQM 
GOSUB INPUT.CS
*
IF TF THEN PRINT @(50,17):"<InField: ":; * RQM 
IF TF THEN PRINT @(60,17):"<Rtn.Lns: ":; * RQM
* LNS<-ONE> = RTN.LNS
WRITE RTN.LNS    ON SCR.FILE,SCR.ID:"*RTN"
RTN.LNS = EMPTY
LNS<-ONE> = "@@@"
LNS<-ONE> = '*':AM:'!':AM:'*'
IF TRN.LNS NE EMPTY THEN
IF TF THEN PRINT @(70,17):"<Trans: ":; * RQM
LNS<-ONE> = TRN.LNS
TRN.LNS = EMPTY
LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF TF THEN PRINT @(70,18):"<Errors: ":; * RQM 
GOSUB ERROR.ROUTINE
LNS<-ONE> = ERR.LNS
ERR.LNS = EMPTY
*
IF TF THEN PRINT @(ZERO,18):"<Reads: ":; * RQM 
GOSUB SET.UP.READ.ITEMS
*
IF TF THEN PRINT @(60,18):"<Custom: ":; * RQM 
CALL SOURCEGEN.CUSTOM(CALL.LNS,BG.C,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPDB.C,UPDE.C,DELB.C,DELE.C,IDB.C,IDE.C,READB.C,READE.C,ABO.C,INP.C,OPE.C,INIT.C,TF,STAT)
IF LEN(CALL.LNS) THEN
LNS<-ONE> = CALL.LNS
CALL.LNS = EMPTY
END
*
CALL SOURCEGEN.WRITE(LNS,SBR,SCR.ID,SBR.LN,BPF.FILE,SYS.FILE,SCR.FILE,EQF.FILE,SPOS.LOC,SPOS.REF,SPOS.DISP,MAT SCR.LNS,SIR,SIR.HDR,SIR.TEXTS,SIR.KEY,SIR.PMPT,MAT EQF,TF,EQF.MAX,DIM.LNS,EQU.LNS,REF.LNS,FLNMS,NO.DIM,REC.FL)
*
LNS = EMPTY
*
SCR.RESULT = SCR.ID:AM:SCR.FILE.ID:AM:OUT.FL.ID
SCR.RESULT<11> = TRUE
SCR.RESULT<12> = DATE()
SCR.RESULT<13> = TIME()
WRITE SCR.RESULT ON SCR.FILE,"CURRENT.SOURCEGEN@":PORT
*
PRINT @(ZERO,ZERO):
EXECUTE "SOURCEGEN.MERGE"
*
READ SCR.RESULT FROM SYS.FILE,"CURRENT.SOURCEGEN" ELSE
PRINT "CONTROL.RECORD MISSING!":BELL
SCR.RESULT  = EMPTY
SCR.RESULT<11> = TRUE
END
MERGE.STAT = SCR.RESULT<11>
*
IF NOT(MERGE.STAT) AND BASIC.FLAG THEN
*
PRINT @(ZERO,ZERO):
EXEC.VERB = "GEN.COMPILE ":SCR.ID:" ":OUT.FL.ID
IF LEN(BASIC.OPT) THEN EXEC.VERB = EXEC.VERG:" ":BASIC.OPT
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
TMP = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
EXEC.OUT = TMP:EXEC.OUT
EXEC.OUT<-ONE> = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
WRITE EXEC.OUT ON SCR.FILE,SCR.ID:"*BAS"
IF DISPL.FLAG THEN
PRINT
PRINT
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE>
DEL EXEC.OUT<ONE>
REPEAT
PRINT
END
*
END; * OF BASIC.FLAG
*
IF NOT(MERGE.STAT) AND CATLG.FLAG THEN
*
PRINT @(ZERO,ZERO):
EXEC.VERB = "GEN.CATALOG ":SCR.ID:" ":OUT.FL.ID
IF LEN(CATLG.OPT) THEN EXEC.VERB = EXEC.VERG:" ":CATLG.OPT
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
TMP = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
EXEC.OUT = TMP:EXEC.OUT
EXEC.OUT<-ONE> = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
WRITE EXEC.OUT ON SCR.FILE,SCR.ID:"*CAT"
IF DISPL.FLAG THEN
PRINT
PRINT
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE>
DEL EXEC.OUT<ONE>
REPEAT
PRINT
END
*
END; * OF CATLG.FLAG
*
IF TF THEN PRINT @(70,23):"<Done>":; * RQM
*
END; * of screen found
*
FIRST = FALSE
*
REPEAT; * get next screen
*
*
STOP
!
*
FG.DISP: * GEN FG DISPLAY AND INPUT SUBROUTINES
*
RTN.LNS = EMPTY; TRN.LNS = EMPTY; INP.NUM = ONE; TRN.NUM = ONE; READ.ITEMS = EMPTY
LNS<-ONE> = '*':AM:'!':AM:'*'
LNS<-ONE> = 'DISP.FG: *'
LNS<-ONE> = '*'
*
IF NOT(ID.S) OR LEN(IDB.C) OR LEN(IDE.C) THEN
LNS<-ONE> = 'IF REDISP THEN'
LNS<-ONE> = 'REDISP = 99'
LINE = 'TEMP = ':ID:'; FOR ID.CN = ONE TO '
TMP1 = ZERO
FOR TMP = ID.AC TO ID.MAX
IF SIR<TMP,ONE,TWO>[ONE,ONE] NE "*" THEN TMP1 = TMP1 + ONE
NEXT TMP
LINE = LINE:TMP1 + ZERO:'; ':ID:'.SAVE<ID.CN> = "!":':ID:'.SAVE<ID.CN>':'; NEXT ID.CN; GOSUB GET.KEY; ':ID:' = TEMP'
LNS<-ONE> = LINE
LNS<-ONE> = 'END'
LNS<-ONE> = '*'
END
*
IF PMPT.AC THEN
CURR.AC = PMPT.AC
WINDOW.CN = ZERO; FIELD.CN = ZERO
PRINT @(50,13):
*
LOOP
WINDOW.CN = WINDOW.CN + ONE 
IF TF THEN
PRINT @(60,WINDOW.CN + 10):RVB:"<W ":RVE:WINDOW.CN:"> ":; * RQM
END
FIRST.AC = CURR.AC; LAST.AC = CURR.AC; MAX.NUM = ONE
*
LOOP
SIR.AC = LAST.AC + ONE; REF = SIR<SIR.AC,ONE,ONE>[ONE,ONE]; IF REF = '"' THEN MAX.NUM = MAX.NUM + ONE
WHILE SIR<SIR.AC> NE EMPTY AND (REF EQ EMPTY OR REF EQ "," OR REF EQ '"' OR REF EQ "'") DO 
IF TF THEN
FIELD.CN = FIELD.CN + ONE 
PRINT RVB:"<F":RVE:FIELD.CN:"> ":; * RQM
END
LAST.AC = LAST.AC + ONE
REPEAT
*
LN = ZERO; CL = ZERO; LH = ZERO
SIR.AC = FIRST.AC; GOSUB EXTR.PMPT.DT
IF INPUT.REQD THEN ANY.INPUT = ONE ELSE ANY.INPUT = ZERO
*
IF TF THEN
IF LAST.AC NE FIRST.AC THEN FIELD.CN = ZERO
IF (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
END
*
IF VF THEN GOSUB VAR.DISP ELSE GOSUB NON.VAR.DISP
*
UNTIL SIR<CURR.AC> EQ EMPTY DO REPEAT
*
END
*
LNS<-ONE> = '*'
*
IF FG.C NE EMPTY THEN
LNS<-ONE> = 'GOSUB FG.C'
LNS<-ONE> = '*'
END
*
LNS<-ONE> = 'REDISP = FALSE'
LNS<-ONE> = '*'
LNS<-ONE> = 'RETURN'
*
RETURN
*
!
LP.DISP: *
*
LNS<-ONE> = '*':AM:'!':AM:'*'
LNS<-ONE> = 'DISP.LP: *'
LNS<-ONE> = '*'
*
SBR.WR.FL = TRUE
CALL SOURCEGEN.LP.DISP(SCR.FILE,BPF.FILE,SCR.ID,MAT SCR.LNS,MAT LPT.LNS,SLP.LNS,MAX.REF,TEXT.AC,SIR,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,LP.C,TF,SBR.WR.FL,SBR.LN,DIM.LNS,EQU.LNS,REF.LNS,STAT)
LNS<-ONE> = SLP.LNS
SLP.LNS = EMPTY
* REF.LNS = EMPTY
*
LNS<-ONE> = '*'
*
LNS<-ONE> = 'RETURN'
*
RETURN
*
!
*
NON.VAR.DISP: *
*
REF.AC = FIRST.AC
LNS<-ONE> = '*':AM:'!':AM:'*'
FOR CURR.AC = FIRST.AC TO LAST.AC
*
IF CURR.AC NE FIRST.AC THEN SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT ELSE SAVE.PMPT.TYPE = PMPT.TYPE
IF SIR<CURR.AC + ONE,ONE,TWO>[ONE,ONE] EQ "*" THEN TRANSL = TRUE ELSE TRANSL = FALSE
*
CALL SOURCEGEN.SUBR.SUBREF(RTN.LNS,INP.LBL,INP.NUM,INPUT.REQD,CURR.AC,FIRST.AC,RTN.LN,SUB.NUM,MAX.NUM,LINE,TF,STAT)
*
*
START.LN = LN
FOR LN = START.LN TO LM
*
** IF INPUT.REQD THEN
*
CALL SOURCEGEN.SUBR.SPOS(CL,LN,SCL.LOC,SPOS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.DISP,INP.NUM,SAVE.PMPT.TYPE,START.LN,REF.AC,FIRST.AC,TF,STAT)
*
IF INPUT.REQD THEN
*
IF LN EQ START.LN THEN
*
IF MAX.NUM GT ONE THEN RTN.LNS<-ONE> = "I":INP.LBL:CHAR(SUB.NUM + 64):": *"; SUB.NUM = SUB.NUM + ONE ELSE RTN.LNS<-ONE> = RTN.LN
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = LOCN
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":TMP
LINE = 'CALL INPUT.DATA.SG1("':TMP1:'","':TMP:'",':FLNM:',':CL:',':LN:',"':MS[ONE,ONE]:MS[3,9]:'","':LHM:'",'
LINE = LINE:LOCN:',"':CONV:'","':EDIT:'",':EDIT.FILE:',RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"0",TC.FUNC,':CL:',':LN:',".",STD.SUBR.NAME,PROCBUF,STAT)'
IF TRANSL THEN
RTN.LNS<-ONE> = LINE
LINE = 'IF STAT THEN RETURN ELSE LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
END
RTN.LNS<-ONE> = LINE
*
IF REDISP THEN
RTN.LNS<-ONE> = 'REDISP = TRUE; GOSUB DISP.BG; GOSUB DISP.FG'; REDISP = FALSE
RTN.LNS<-ONE> = 'RETURN'
END ELSE IF LN EQ START.LN THEN
RTN.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG'
RTN.LNS<-ONE> = 'RETURN'
END
*
END; * of start.ln
*
END; * of input.reqd
*
IF FL NE EMPTY THEN
*
DISP.LN = FLNM
*
IF NUM(AC) OR VC NE EMPTY THEN
*
DISP.LN = DISP.LN:EXTR
*
END
*
IF SB NE EMPTY THEN DISP.LN = 'FIELD(':DISP.LN:',"':SB[ONE,ONE]:'",':SB[TWO,TWO]:')'
IF CONV[ONE,ONE] = "D" OR CONV[ONE,ONE] = "M" THEN DISP.LN = 'OCONV(':DISP.LN:',"':CONV:'")'
LINE = 'PRINT @(':CL:',':LN:'):':DISP.LN:' "':MS:'":'
IF TRANSL THEN LINE = LINE:'; LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
LNS<-ONE> = LINE
SPOS.DISP<LN + ONE,SCL.LOC> = DISP.LN:' "':MS:'"'
IF TF AND (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
*
END; * of FL ne empty
*
IF SB NE EMPTY THEN SB = SB[ONE,ONE]:SB[TWO,TWO] + ONE ELSE
IF SC NE EMPTY THEN
IF NUM(SC) THEN SC = SC + ONE
END ELSE IF VC NE EMPTY THEN
IF NUM(VC) THEN VC = VC + ONE
END ELSE
IF NUM(AC) THEN AC = AC + ONE
END
END
*
IF LN LT LM THEN SIR.AC = CURR.AC; GOSUB SET.UP.STRINGS
*
NEXT LN
*
*
IF TRANSL THEN
$INCLUDE BP.SG SOURCEGEN.TRANSL
* CURR.AC = CURR.AC + ONE
TRANSL = FALSE
END
*
NEXT CURR.AC
*
INP.NUM = INP.NUM+ANY.INPUT
*
RETURN
*
!
*
VAR.DISP: *
*
IF SQ EQ "FI" THEN SORTED = 0 ELSE SORTED = ONE
DSP.LNS = EMPTY
INP.LNS = EMPTY
CLR.LNS = EMPTY
ADD.LNS = EMPTY
DEL.LNS = EMPTY
* REF.LNS = EMPTY
REF.LN = EMPTY
CURR.AC = FIRST.AC; REF.AC = FIRST.AC
SAVE.PMPT.TYPE = PMPT.TYPE
SUB.NUM = ZERO
INP.LBL = (INP.NUM + 100)[TWO,TWO]
READ.LNS<-ONE> = 'I':INP.LBL:'.MAX = ':VF+0
*
*
* FOR SUB.NUM = ONE TO MAX.NUM
LOOP
*
IF SIR<CURR.AC + ONE,ONE,TWO>[ONE,ONE] EQ "*" THEN TRANSL = TRUE ELSE TRANSL = FALSE
*
IF (INPUT.REQD OR NOT(LN OR CL)) OR ((VF AND VTYPE.VC GT ONE)) THEN
SUB.NUM = SUB.NUM + ONE
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'I':INP.LBL:CHAR(SUB.NUM+64):': *'
INP.LNS<-ONE> = '*'
END
*
IF INPUT.REQD THEN
IF REF.LN EQ EMPTY THEN
IF EDIT EQ EMPTY THEN TEMP = "SE":VM:"OP" ELSE TEMP = "SE":VM:"OP":VM:EDIT
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = EXTR
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":TMP
IF INDEX(FLNM,".XREF",ONE) THEN
IF INDEX(FLNM,"$",ONE) THEN
TMP2 = FIELD(FLNM,"$",TWO)
END ELSE TMP2 = FLNM
TMP2 = 'GET.':TMP2
TMP3 = TMP1
TMP4 = 'FLD'
END ELSE
TMP2 = 'INPUT.DATA.SG1'
TMP3 = 'FLD'
TMP4 = 'RSP'
END
REF.LN = 'FLD = EMPTY':AM:'CALL ':TMP2:'("':TMP1:'","':TMP:'",':TMP3:',':LEN(PMPT.TEXT) + 8:',23,"'
REF.LN = REF.LN:MS[ONE,ONE]:MS[3,9]:'","':LHM:'","1","':CONV:'","':TEMP:'",':EDIT.FILE:',FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"0",TC.FUNC,':LEN(PMPT.TEXT) + 8:',23,".",STD.SUBR.NAME,PROCBUF,STAT)'
END
TEMP = EDIT
IF NOT(SORTED) THEN IF SUB.NUM = ONE THEN
INP.LNS<-ONE> = 'IF ':FLNM:EXTR:' EQ " " THEN ':FLNM:EXTR:' = EMPTY'
INP.LNS<-ONE> = 'PRINT @(':CL-3:',LN):SPACE(2-LEN(':VTYPE:')):RVB:':VTYPE:':RVE:" ":'
IF TEMP EQ EMPTY THEN TEMP = "OP" ELSE TEMP = "OP":VM:TEMP
END
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = EXTR
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":TMP
LINE = 'CALL INPUT.DATA.SG1("':TMP1:'","':TMP:'",':FLNM:',':CL:',LN,"':MS[ONE,ONE]:MS[3,9]:'","':LHM:'",'
INP.LNS<-ONE> = LINE:LOCN:',"':CONV:'","':TEMP:'",':EDIT.FILE:',RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"0",TC.FUNC,':CL:',LN,".",STD.SUBR.NAME,PROCBUF,STAT)'
INP.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I':INP.LBL:CHAR(SUB.NUM+64)
IF NOT(SORTED) THEN IF SUB.NUM EQ ONE THEN
INP.LNS<-ONE> = 'IF RSP EQ EMPTY THEN IF DYN NE "N" THEN PRINT BELL:; GOTO I':INP.LBL:CHAR(SUB.NUM+64)
END
IF TRANSL THEN INP.LNS<-ONE> = 'IF STAT THEN RETURN ELSE GOSUB T':(TRN.NUM + 100)[TWO,TWO]
* IF NOT(LN OR CL) THEN INP.LNS<-ONE> = 'RETURN'
END
*
*
DISP.LN = FLNM:EXTR
IF CONV[ONE,ONE] EQ "D" OR CONV[ONE,ONE] EQ "M" THEN DISP.LN = 'OCONV(':DISP.LN:',"':CONV:'")'
*
IF (LN OR CL) THEN
*
CALL SOURCEGEN.SUBR.DISPLN(DISP.LN,CLEAR.LN,FLNM,EXTR,CONV,LN,CL,SORTED,SUB.NUM,VTYPE,MS,TEMP.RSP,TRANSL,TRN.NUM)
*
DSP.LNS<-ONE> = DISP.LN
CLR.LNS<-ONE> = CLEAR.LN
*
IF (INPUT.REQD AND (SUB.NUM EQ ONE OR NOT(VTYPE.FL))) OR ((VF AND VTYPE.VC GT ONE) AND NOT(VTYPE.FL)) THEN
ADD.LNS<-ONE> = 'INS ':TEMP.RSP:' BEFORE ':FLNM:INST
DEL.LNS<-ONE> = 'DEL ':FLNM:INST
END
*
** IF (LN OR CL) THEN
*
*
START.LN = LN
FOR TMP.LN = LN TO LM
*
* IF INPUT.REQD THEN
CALL SOURCEGEN.SUBR.SPOS(CL,LN,SCL.LOC,SPOS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.DISP,INP.NUM,SAVE.PMPT.TYPE,START.LN,REF.AC,FIRST.AC,TF,STAT)
* END
*
IF TF AND LH THEN
PRINT @(CL,TMP.LN):RVB:STR("#",LH):RVE:
END
*
IF SPOS.MAX THEN
TMP = FLNM:'<'
TMP1 = 'TDL(':INP.NUM:') + ':TMP.LN - LN
*
FOR SPOS.CN = ONE TO SPOS.MAX
IF SPOS.CN GT ONE THEN TMP = TMP:','
IF SPOS.CN EQ VTYPE.VC - ONE THEN
TMP = TMP:TMP1
END ELSE
TMP = TMP:FIELD(SPOS,',',SPOS.CN)
END
NEXT SPOS.CN
*
TMP = TMP:'>'
END ELSE
TMP = FLNM:EXTR
TMP1 = EMPTY
END; * OF SPOS.MAX
*
IF NOT(SORTED) AND SUB.NUM EQ ONE THEN
SPOS.DISP<TMP.LN + ONE,SCL.LOC> = 'SPACE(TWO - LEN(':TMP1:')):':TMP1:':" ":':TMP:' "':MS:'"'
END ELSE
SPOS.DISP<TMP.LN + ONE,SCL.LOC> = TMP:' "':MS:'"'
END
*
NEXT TMP.LN
*
*
END ELSE
*
IF NOT(INPUT.REQD) THEN
INP.LNS<-ONE> = DISP.LN
END
*
END; * OF LN OR CL
*
IF INPUT.REQD OR NOT(LN OR CL) THEN INP.LNS<-ONE> = 'RETURN'
*
IF TRANSL THEN
$INCLUDE BP.SG SOURCEGEN.TRANSL
* CURR.AC = CURR.AC + ONE
TRANSL = FALSE
END
*
IF REDISP THEN INP.LNS<-ONE> = 'REDISP = TRUE; GOSUB DISP.BG; GOSUB DISP.FG'; REDISP = FALSE
*
WHILE CURR.AC LT LAST.AC DO
*
CURR.AC = CURR.AC + ONE; REF.AC = REF.AC + ONE
* IF TRANSL THEN TRANSL = FALSE; CURR.AC = CURR.AC + ONE
*
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
*
* NEXT SUB.NUM
REPEAT
*
* Process remaining controlled items @@@
*
CURR.AC = CURR.AC + ONE; REF.AC = REF.AC + ONE
*
!
* DISPLAY AND CLEAR ROUTINES
SIR.AC = FIRST.AC; GOSUB EXTR.PMPT.DT
LNS<-ONE> = 'IF NOT(REDISP) THEN DYN = EMPTY'
LNS<-ONE> = 'GOSUB D':INP.LBL:'; IF STAT EQ 999 THEN RETURN'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'D':INP.LBL:': *'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'SAVE.':VTYPE:' = ':VTYPE:'; SAVE.LN = LN'
INP.LNS<-ONE> = 'IF TDL(':INP.NUM:') LT ZERO OR REDISP THEN TDL(':INP.NUM:') = ABS(TDL(':INP.NUM:')) ELSE'
INP.LN = 'IF ':VTYPE:' GE TDL(':INP.NUM:') THEN IF '
INP.LN = INP.LN:VTYPE:' LE TDL(':INP.NUM:') + ':LM - LN:' THEN'
IF NOT(SORTED) THEN INP.LNS<-ONE> = INP.LN:' RETURN' ELSE
INP.LNS<-ONE> = INP.LN
INP.LNS<-ONE> = 'IF DYN EQ "N" THEN LN = MOD(':VTYPE:' - ONE,':LM - LN + ONE:') + ':LN:'; ':DSP.LNS<ONE>
INP.LNS<-ONE> = 'RETURN'
INP.LNS<-ONE> = 'END'
END
INP.LNS<-ONE> = 'END'
INP.LN = 'IF TDL(':INP.NUM:') THEN ':VTYPE
INP.LNS<-ONE> = INP.LN:' = ':VTYPE:'-MOD(':VTYPE:' - ONE,':LM - LN + ONE:'); CLEAR = ONE ELSE ':VTYPE:' = ONE; CLEAR = ZERO'
INP.LNS<-ONE> = 'TOP.LOC = EMPTY; IF ':VTYPE:' LT ONE THEN ':VTYPE:' = ONE'
INP.LNS<-ONE> = 'LOOP'
INP.LNS<-ONE> = 'FOR LN = ':LN:' TO ':LM:' UNTIL ':FLNM:EXTR:' = EMPTY'
INP.LNS<-ONE> = 'IF LN EQ ':LN:' THEN TOP.LOC = ':VTYPE
* WRITE DSP.LNS    ON SCR.FILE,SCR.ID:"*DSP"
INP.LNS<-ONE> = DSP.LNS
INP.LNS<-ONE> = VTYPE:' = ':VTYPE:' + ONE'
INP.LNS<-ONE> = 'NEXT LN'
INP.LNS<-ONE> = 'IF TDL(':INP.NUM:') OR ':FLNM:EXTR:' EQ EMPTY THEN RSP = EMPTY ELSE'
INP.LNS<-ONE> = 'PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":'
INP.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN'
INP.LNS<-ONE> = 'IF RSP EQ "RE" THEN ':VTYPE:' = ONE; RSP = "Y"'
INP.LNS<-ONE> = 'IF RSP EQ "P" THEN'
INP.LNS<-ONE> = VTYPE:' = TOP.LOC - ':LM - LN + ONE
INP.LNS<-ONE> = 'IF ':VTYPE:' LT ZERO THEN ':VTYPE:' = ONE'
INP.LNS<-ONE> = 'RSP = "Y"'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'IF RSP EQ "N" THEN RSP = "Y"'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'WHILE RSP = "Y" DO LN = ':LN:'; GOSUB C':INP.LBL:' REPEAT'
INP.LNS<-ONE> = 'IF CLEAR THEN GOSUB C':INP.LBL:' ELSE CLEAR = 1'
INP.LNS<-ONE> = 'IF TOP.LOC THEN TDL(':INP.NUM:') = TOP.LOC'
INP.LNS<-ONE> = VTYPE:' = SAVE.':VTYPE:'; LN = SAVE.LN'
INP.LNS<-ONE> = 'RETURN'
INP.LNS<-ONE> = 'C':INP.LBL:': *'
INP.LNS<-ONE> = 'FOR LN = LN TO ':LM
* WRITE CLR.LNS    ON SCR.FILE,SCR.ID:"*CLR"
INP.LNS<-ONE> = CLR.LNS
INP.LNS<-ONE> = 'NEXT LN'
INP.LNS<-ONE> = 'RETURN'
IF NOT(INPUT.REQD) THEN RETURN
*
!
* FIXED.KEY OR VARIABLE LOCATIONS
IF NOT(SORTED) THEN
TEMP = 'LOCATE EMPTY IN ':FLNM
TEMP = TEMP:LOCT
TEMP = TEMP:' SETTING ':VTYPE:' ELSE NULL'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'I':INP.LBL:': *'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF NEW THEN'
RTN.LNS<-ONE> = TEMP
RTN.LNS<-ONE> = 'DYN = "N"'
RTN.LNS<-ONE> = 'END ELSE'
IF MAX.REF GT ONE THEN RTN.LN = 'Ref. ':PMPT.TYPE:'> - ' ELSE RTN.LN = EMPTY
RTN.LN = RTN.LN:'Enter line no., N(ext line) or <cr> if okay: '
RTN.LNS<-ONE> = 'PRINT CLB:"':RTN.LN:'":'
RTN.LNS<-ONE> = 'IF NOT(LN.LOC) THEN'
TMP.LN = 'DYN = EMPTY':AM:'CALL INPUT.DATA.SG1("COM","REFLN",DYN,':LEN(RTN.LN) + ONE:',23,"'
TMP.LN = TMP.LN:'L5","5","1","","SE':VM:'OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"1",TC.FUNC,':LEN(RTN.LN) + ONE:',23,".",STD.SUBR.NAME,PROCBUF,STAT)'
RTN.LNS<-ONE> = TMP.LN
RTN.LNS<-ONE> = 'IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I':INP.LBL
* RTN.LNS<-ONE> = 'INPUT DYN:; IF DYN EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = 'DYN = TDL(':INP.NUM:'); IF DYN THEN DYN = DYN - ONE'
RTN.LNS<-ONE> = 'DYN = DYN + LN.LOC'
RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'IF DYN EQ EMPTY OR DYN = "^" THEN RETURN'
RTN.LNS<-ONE> = 'IF DYN EQ "N" THEN'
RTN.LNS<-ONE> = TEMP
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = 'IF NOT(DYN MATCHES "0N") THEN PRINT BELL:; GOTO I':INP.LBL
RTN.LNS<-ONE> = 'IF NOT(DYN) THEN PRINT BELL:; GOTO I':INP.LBL
RTN.LNS<-ONE> = VTYPE:' = DYN'
RTN.LNS<-ONE> = 'IF ':FLNM:EXTR:' EQ EMPTY THEN PRINT BELL:; GOTO I':INP.LBL
RTN.LNS<-ONE> = 'LOOP'
RTN.LNS<-ONE> = 'PRINT CLB:"Enter I(nsert), D(elete) or <cr> to change line: ":'
TMP.LN = 'DYN = EMPTY':AM:'CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"'
TMP.LN = TMP.LN:'L5","5","1","","SE':VM:'OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)'
RTN.LNS<-ONE> = TMP.LN
RTN.LNS<-ONE> = 'IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY'
* RTN.LNS<-ONE> = 'INPUT DYN:; IF DYN EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'IF NOT(DYN EQ "I" OR DYN EQ "N") THEN'
RTN.LNS<-ONE> = 'IF DYN EQ "D" THEN'
END ELSE
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'I':INP.LBL:': *'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF LN.LOC THEN'
RTN.LNS<-ONE> = VTYPE:' = TDL(':INP.NUM:'); IF ':VTYPE:' THEN ':VTYPE:' = ':VTYPE:' - ONE'
RTN.LNS<-ONE> = VTYPE:' = ':VTYPE:' + LN.LOC'
RTN.LNS<-ONE> = 'FLD = ':FLNM:EXTR
RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'END ELSE FLD = EMPTY'
RTN.LNS<-ONE> = '*'
* RTN.LNS<-ONE> = 'IF NOT(LN.LOC) THEN'
RTN.LNS<-ONE> = 'IF FLD EQ EMPTY THEN'
RTN.LNS<-ONE> = 'PRINT CLB:"Enter ':PMPT.TEXT:': ":'
RTN.LNS<-ONE> = REF.LN
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I':INP.LBL
RTN.LNS<-ONE> = 'IF STAT THEN TEXT = RSP<TWO>; GOSUB ERROR; GOTO I':INP.LBL
RTN.LNS<-ONE> = 'IF FLD EQ EMPTY THEN RETURN'
* RTN.LNS<-ONE> = 'END ELSE'
* RTN.LNS<-ONE> = VTYPE:' = TDL(':INP.NUM:'); IF ':VTYPE:' THEN ':VTYPE:' = ':VTYPE:' - ONE'
* RTN.LNS<-ONE> = VTYPE:' = ':VTYPE:' + LN.LOC'
* RTN.LNS<-ONE> = 'FLD = ':FLNM:EXTR
* RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
RTN.LN = 'LOCATE FLD IN ':FLNM
RTN.LN = RTN.LN:LOCT
*
RTN.LNS<-ONE> = RTN.LN:' BY "':SQ:'" SETTING ':VTYPE:' THEN'
RTN.LN = 'PRINT CLB:'
*
IF MAX.REF GT ONE THEN RTN.LN = RTN.LN:'"Ref. ':PMPT.TYPE:'> ":'
*
IF CONV EQ EMPTY THEN RTN.LN = RTN.LN:'FLD' ELSE RTN.LN = RTN.LN:'OCONV(FLD,"':CONV:'")'
*
RTN.LNS<-ONE> = RTN.LN:':" - Delete it (Y/<cr>)? ":'
RTN.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'IF RSP NE "Y" THEN DYN = EMPTY; PRINT CLB: ELSE'
END
*
* WRITE DEL.LNS    ON SCR.FILE,SCR.ID:"*DEL"
RTN.LNS<-ONE> = DEL.LNS
DEL.LN = EMPTY
*
RTN.LNS<-ONE> = 'TDL(':INP.NUM:') = -ABS(TDL(':INP.NUM:'))'
RTN.LNS<-ONE> = 'DYN = "D"; GOSUB D':INP.LBL:'; IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'GOTO I':INP.LBL
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'END ELSE'
*
IF SORTED THEN RTN.LNS<-ONE> = 'IF ':FLNM:EXTR:' EQ EMPTY THEN DYN = "N" ELSE DYN = "I"'
*
RTN.LNS<-ONE> = 'IF ':VTYPE:' GT I':INP.LBL:'.MAX THEN IF NEW AND DYN EQ "N" THEN RETURN ELSE'
RTN.LNS<-ONE> = 'TEXT = "Max. entries allowed is ":I':INP.LBL:'.MAX; GOSUB ERROR; GOTO I':INP.LBL
RTN.LNS<-ONE> = 'END'
*
* WRITE ADD.LNS    ON SCR.FILE,SCR.ID:"*ADD"
RTN.LNS<-ONE> = ADD.LNS
ADD.LNS = EMPTY
*
RTN.LN = 'IF DYN EQ "I" THEN TDL(':INP.NUM:') = -ABS(TDL(':INP.NUM:')) ELSE '
RTN.LNS<-ONE> = RTN.LN:'IF NOT(TDL(':INP.NUM:')) THEN TDL(':INP.NUM:') = ONE'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'GOSUB D':INP.LBL:'; IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'LN = MOD(':VTYPE:' - ONE,':LM - LN + ONE:') + ':LN
*
IF MAX.NUM GT ONE OR NOT(SORTED) THEN
*
LINE = EMPTY
RTN.LNS<-ONE> = 'FOR SUB.REF = ONE TO ':MAX.NUM - SORTED
*
FOR SUB.NUM = SORTED + ONE TO MAX.NUM
LINE = LINE:'I':INP.LBL:CHAR(SUB.NUM+64):','
NEXT SUB.NUM
*
*
RTN.LNS<-ONE> = 'IF SUB.REF GE SUB.REF.LOC - ':SORTED + ZERO:' THEN'
RTN.LNS<-ONE> = 'ON SUB.REF GOSUB ':LINE[ONE,LEN(LINE) - ONE]
RTN.LNS<-ONE> = 'TC.FUNC = EMPTY; TC.OUT = EMPTY'
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'IF STAT THEN'
RTN.LNS<-ONE> = 'IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO'
RTN.LNS<-ONE> = 'IF SUB.REF LT ZERO THEN SUB.REF = ':MAX.NUM
RTN.LNS<-ONE> = 'END ELSE'
IF NOT(SORTED) THEN RTN.LNS<-ONE> = 'IF SUB.REF EQ ONE THEN IF RSP EQ EMPTY THEN RETURN'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'SUB.REF.LOC = ZERO'
*
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'NEXT SUB.REF'
RTN.LNS<-ONE> = 'SUB.REF.LOC = ZERO'
*
END
*
RTN.LNS<-ONE> = 'GOTO I':INP.LBL
*
* WRITE INP.LNS    ON SCR.FILE,SCR.ID:"*INP"
RTN.LNS<-ONE> = INP.LNS
INP.LNS = EMPTY
*
INP.NUM = INP.NUM + ANY.INPUT
*
* RTN.LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN
*
!
*
INPUT.CS: * SET UP SOUBROUTINE CALLING SEQUENCE
MAX.NUM = INP.NUM - ONE
LNS<-ONE> = '*':AM:'!':AM:'*'
LNS<-ONE> = 'GET.DATA: *'
LNS<-ONE> = 'NUMC = TRUE'
LINE = EMPTY
IF INP.NUM THEN
FOR INP.NUM = ONE TO MAX.NUM
LINE = LINE:'I':(INP.NUM + 100)[TWO,TWO]:','
NEXT INP.NUM
LNS<-ONE> = 'ON REF GOSUB ':LINE[ONE,LEN(LINE) - ONE]
LNS<-ONE> = 'NUMC = FALSE'
LNS<-ONE> = 'TC.FUNC = EMPTY; TC.OUT = EMPTY'
END
LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA'
LNS<-ONE> = 'RETURN'
LNS<-ONE> = '*':AM:'!':AM:'*'
LINE = EMPTY
*
RETURN
*
!
*
SET.UP.READ.ITEMS: *
*
* READ.LNS = EMPTY
READ.NUM = ONE
READ.NUM.MAX = DCOUNT(READ.ITEMS,AM)
LOOP READ.ITEM = READ.ITEMS<READ.NUM> UNTIL READ.NUM GT READ.NUM.MAX DO
IF READ.ITEM NE EMPTY THEN
LINE = 'READ ':FIELD(READ.ITEM,"*",TWO):' FROM ':FIELD(READ.ITEM,"*",ONE):'.FILE,"':FIELD(READ.ITEM,"*",TWO)
READ.LNS<-ONE> = LINE:'" ELSE ':FIELD(READ.ITEM,"*",TWO):' = EMPTY'
IF TF THEN PRINT @(50,20):FIELD(READ.ITEM,"*",ONE):" ":FIELD(READ.ITEM,"*",TWO):" ":; * RQM
END
READ.NUM = READ.NUM + ONE
REPEAT
*
IF READ.LNS EQ EMPTY THEN RETURN
*
READ.LNS<-ONE> = '*':AM:'*'
LOCATE '*READ.LNS*' IN LNS SETTING LOC THEN LOC = LOC + ONE ELSE LOC = DCOUNT(LNS,AM)
INS READ.LNS BEFORE LNS<LOC>
READ.LNS = EMPTY
*
RETURN
*
!
*
ERROR.ROUTINE: * LOAD ERROR ROUTINE
*
ERR.LNS = EMPTY
*
CALL SOURCEGEN.SUBR.ERRLNS(ERR.LNS)
*
RETURN
*
!
*
EXTR.PMPT.DT: *
*
CALL SOURCEGEN.PMPT(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX,REDISP)
*
RETURN
*
!
*
SET.UP.STRINGS: *
*
CALL SOURCEGEN.SETUP.STR(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX)
*
RETURN
*
!
*
END
~BU9.INPUT.DATA.SG1~
SUBROUTINE INPUT.DATA.SG1(FILE.NAME,ITEM.NAME,ITEM,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,TM.MAX,REDISP,TT,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,STAT)
* PROGRAM:           INPUT.DATA
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       STANDARDIZED DATA INPUT
*            STAT    MEANING
*               0    GOOD RESPONSE
*              -1    REQUEST BACKUP
*               1    BAD RESPONSE (ERROR MESSAGE IN RSP<2>)
*             998    <ESC> WAS PRESSED
*             999    REQUEST KILL
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*NOTERM
*
*
*%%MDD%%=$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*OVERRIDE
*
!
*
START: *
*
SUPPRESS.ERROR.PRINT = EMPTY; CLEAR.BOTTOM.LINE = FALSE
AC = FIELD(LOCN,",",ONE); VC = FIELD(LOCN,",",TWO); SC = FIELD(LOCN,",",3)
SB = INDEX(LOCN,",",3); IF NOT(SB) THEN SB = EMPTY ELSE SB = LOCN[SB + ONE,9]
* IF LH[ONE,ONE] MATCHES "1A" THEN MS = LH[ONE,ONE]:"#":LH[TWO,999]; LH = LH[TWO,999] ELSE MS = "L#":LH
* IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,999]
MS = EMPTY
CLEAR.FLAG = FALSE
IF AC OR VC OR SC THEN FLD = ITEM<AC,VC,SC> ELSE FLD = ITEM
IF SB NE EMPTY THEN FLD = FIELD(FLD,SB[ONE,ONE],SB[TWO,9])
IF FLD[ONE,ONE] NE "!" THEN NO.PROMPT = ZERO ELSE
IF STAT EQ -ONE THEN GOTO FINISH
FLD = FLD[TWO,999]; NO.PROMPT = ONE
END
DEF.SUPP = FALSE
* IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO ELSE NON.NUMERIC.CONV = ONE
STAT = FALSE; * REDISP = FALSE
* DEF = FLD; FLD.LEN = LEN(FLD)
* IF DEF NE EMPTY THEN
* IF CONV NE EMPTY THEN
* IF NUM(DEF) OR NON.NUMERIC.CONV THEN
* IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
* DEF = OCONV(DEF,MOD.CONV)
* IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
* END
* END
* END
*
!
*
LOOP
*
$INCLUDE IBP CURSOR.STD
*
!
*
IF RSP EQ "KILL" THEN STAT = 999; GOTO FINISH
* IF RSP[ONE,ONE] EQ CHAR(27) THEN STAT = 998; GOTO FINISH
* CLEAR.FLAG = ZERO
* IF RSP EQ "\" THEN RSP = EMPTY; CLEAR.FLAG = ONE ELSE
IF NOT(CLEAR.FLAG) THEN
* IF RSP EQ EMPTY OR RSP EQ "^" THEN
IF (TC.FUNC NE "C" AND TC.FUNC NE EMPTY) OR RSP EQ "^" THEN
IF RSP EQ "^" THEN STAT = -ONE; TC.FUNC = "8"
RSP = DEF; PRINT @(RSP.CL,RSP.LN):RSP MS:; DEFAULT.USED = ONE
* IF STAT EQ -ONE THEN GOTO FINISH
* TC.FUNC = TC.OUT
**?TC.FUNC = EMPTY
GOTO FINISH
END ELSE DEFAULT.USED = EMPTY
END
QUERY = FALSE
IF RSP EQ "?" THEN QUERY = ONE
IF RSP EQ "??" THEN QUERY = TWO
IF RSP EQ "???" THEN QUERY = 3
IF QUERY THEN GOSUB QUERY.HELP ELSE
*FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
FLD = RSP
IF NOT(NON.NUMERIC.CONV) THEN
CALL GET.ICONV(FLD,CONV)
END
GOSUB DO.EDITS
END
* END
*
WHILE STAT GT ZERO DO
*
IF NOT(QUERY) THEN
IF SUPPRESS.ERROR.PRINT THEN RSP<TWO> = TEXT; GOTO FINISH ELSE GOSUB ERROR.ADVICE; STAT = FALSE
END ELSE
STAT = FALSE
IF REDISP THEN RETURN
END
*
REPEAT
*
!
*
FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
IF CONV EQ EMPTY THEN RSP = FLD ELSE
IF NUM(FLD) OR NON.NUMERIC.CONV THEN
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
RSP = OCONV(FLD,MOD.CONV)
IF MOD.CONV NE CONV THEN RSP = RSP[ONE,TWO]:RSP[4,3]:RSP[8,TWO]
END
END
PRINT @(RSP.CL,RSP.LN):RSP MS:
IF SB NE EMPTY THEN
IF AC THEN PRE.FLD = ITEM<AC,VC,SC> ELSE PRE.FLD = ITEM
PAR = SB[TWO,9]; SB = SB[ONE,ONE]; PART.FLD = FLD; FLD = EMPTY
FLD.PAR = COUNT(PRE.FLD,SB) + ONE; IF FLD.PAR LT PAR THEN FLD.PAR = PAR
FOR NUM = ONE TO FLD.PAR
IF NUM GT ONE THEN FLD = FLD:SB
IF NUM EQ PAR THEN FLD = FLD:PART.FLD ELSE FLD = FLD:FIELD(PRE.FLD,SB,NUM)
NEXT NUM
END
IF AC THEN
ITEM<AC,VC,SC> = FLD; POS = LEN(ITEM<AC>)
LOOP WHILE ITEM<AC>[POS,ONE] GT CHAR(250) DO POS = POS - ONE; ITEM<AC> = ITEM<AC>[ONE,POS] REPEAT
END ELSE ITEM = FLD
*
!
*
FINISH: *
*
IF CLEAR.BOTTOM.LINE THEN PRINT @(ZERO,CLEAR.BOTTOM.LINE):CLL:
RETURN
*
!
*
DO.EDITS: *
*
IF COUNT(RSP,AM) THEN TEXT = "attr mark was entered"; STAT = TRUE; RETURN
ED.VC = ONE; IF EDITS<ONE,ED.VC> EQ "SE" THEN SUPPRESS.ERROR.PRINT = ONE; ED.VC = ED.VC + ONE
IF LEN(RSP) GT LHM THEN STAT = TRUE; TEXT = "No more than ":LHM:" characters please"; PRINT @(RSP.CL + LH,RSP.LN):SPACE(LEN(RSP) - LH):; RETURN
IF SB NE EMPTY THEN IF COUNT(RSP,SB[ONE,ONE]) THEN STAT = TRUE; TEXT = "Don't use a '":SB[ONE,ONE]:"' please"; RETURN
LOOP ED = EDITS<ONE,ED.VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>; ED2 = ED<ONE,ONE,TWO>; ED3 = ED<ONE,ONE,3>
IF ED1 NE EMPTY THEN IF ED1 MATCHES "2A" THEN GOSUB SPECIFIC.EDIT
IF STAT LT ONE THEN ED.VC = ED.VC + ONE ELSE RETURN
REPEAT
IF NOT(STAT) THEN
IF RSP EQ "?" THEN STAT = TRUE; TEXT = "Anything up to ":LHM:" characters is okay"
END ELSE
GOSUB LOAD.EDITS; QUERY = 3; GOSUB QUERY.HELP
END
*
RETURN
*
!
*
SPECIFIC.EDIT: *
*
ED2CONV = ED2
*
BEGIN CASE
*
CASE ED1 EQ "OP"; IF RSP EQ EMPTY THEN ED.VC = 999
*
CASE ED1 EQ "RQ"; IF RSP EQ EMPTY THEN STAT = TRUE; TEXT = "Please enter something here"
*
CASE ED1 EQ "LO"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD LT ED2 THEN STAT = TRUE; TEXT = "Your entry should be at least ":ED2CONV:" please"
*
CASE ED1 EQ "HI"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD GT ED2 THEN STAT = TRUE; TEXT = "Your entry should be no more than ":ED2CONV:" please"
*
CASE ED1 EQ "NC"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter it in cents only" ELSE
IF NOT(DEFAULT.USED) THEN RSP = RSP / 100
END
*
CASE ED1 EQ "ND"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter it in dollars and cents"
*
CASE ED1 EQ "NU"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter a number"
*
CASE ED1 EQ "DT"
IF RSP NE EMPTY THEN TEMP = RSP; CALL GET.ICONV(TEMP,"D"); IF TEMP EQ EMPTY THEN STAT = TRUE; TEXT = "Enter a date please"
*
CASE ED1 EQ "DD"; IF RSP EQ EMPTY THEN RSP = OCONV(DATE(),"D0.")
*
CASE ED1 EQ "TM"; IF RSP EQ EMPTY THEN RSP = OCONV(TIME(),"MT")
*
CASE ED1 EQ "LF"
IF RSP MATCHES "0N" OR RSP MATCHES "0N'#'" OR RSP MATCHES "0N'+'" THEN
IF ED3 EQ EMPTY THEN RSP = ED2:RSP ELSE RSP = STR(ED2,ED3-LEN(RSP)):RSP
END
*
CASE ED1 EQ "RF"
IF ED3 EQ EMPTY THEN RSP = ED2:RSP ELSE IF NUM(RSP) OR NOT(NUM(ED3)) THEN RSP = RSP:STR(ED2,ED3-LEN(RSP))
*
CASE ED1 EQ "FI"; READV DUMMY FROM EDIT.FILE,RSP,ONE ELSE STAT = TRUE; TEXT = "Sorry, that's not a valid entry - please check your documentation"
*
CASE ED1 EQ "FF"
FIXED.FIELD = TRUE
*
CASE ED1 EQ "DF"
IF RSP EQ EMPTY AND NOT(CLEAR.FLAG) THEN
IF ED2[ONE,ONE] NE "*" THEN RSP = ED2 ELSE
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV RSP FROM EDIT.FILE,ED3,ED4 ELSE RSP = EMPTY
END
END
*
CASE ED1 EQ "EQ"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
TEXT = EMPTY; SCAN.VC = ONE; IF COUNT(ED,VM) THEN SCAN.SC = ZERO ELSE SCAN.SC = ONE
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC>[ONE,LHM] UNTIL TEMP EQ RSP OR TEMP EQ EMPTY DO
TEXT = TEXT:TEMP:", "; IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
IF TEMP NE EMPTY THEN RETURN
TEXT = TEXT[ONE,LEN(TEXT) - TWO]
STAT = TRUE
IF LEN(TEXT) GT 65 THEN
IF LEN(TEXT) - COUNT(TEXT,", ") GT 65 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",ONE) WHILE POS DO TEXT = TEXT[ONE,POS]:TEXT[POS + TWO,999] REPEAT
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[ONE,POS - ONE]:" or":TEXT[POS + ONE,999]
END
TEXT = "Please use ":TEXT
*
CASE ED1 EQ "MA"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
TEXT = EMPTY; SCAN.VC = ONE; IF COUNT(ED,SVM) THEN SCAN.SC = ONE ELSE SCAN.SC = ZERO
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC> UNTIL RSP MATCHES TEMP OR TEMP EQ EMPTY DO
TEXT<-ONE> = TEMP; IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
IF TEMP NE EMPTY THEN RETURN
STAT = TRUE; TEXT = AM:TEXT
LOOP OLD.TEMP = TEXT<TWO> UNTIL OLD.TEMP EQ EMPTY DO
POS = ONE; NUMERALS = EMPTY; ALL.QUOTES = ONE; QUOTES = EMPTY; TEMP = EMPTY
LOOP CHAR = OLD.TEMP[POS,ONE] UNTIL CHAR EQ EMPTY DO
BEGIN CASE
CASE CHAR EQ "'"; IF QUOTES THEN QUOTES = EMPTY ELSE QUOTES = ONE
CASE QUOTES; TEMP = TEMP:CHAR
CASE CHAR MATCHES "1N"; NUMERALS = NUMERALS:CHAR; ALL.QUOTES = EMPTY
CASE CHAR EQ "A" OR CHAR EQ "N" OR CHAR EQ "X"
IF CHAR EQ "N" THEN CHAR = "9" ELSE IF CHAR EQ "A" THEN CHAR = "X" ELSE CHAR = "x"
IF NOT(NUMERALS) THEN NUMERALS = LHM; IF NUMERALS GT 3 THEN NUMERALS = 3
TEMP = TEMP:STR(CHAR,NUMERALS); NUMERALS = EMPTY; ALL.QUOTES = EMPTY
CASE ONE; TEMP = TEMP:CHAR; ALL.QUOTES = EMPTY
END CASE
POS = POS + ONE
REPEAT
IF ALL.QUOTES THEN TEMP = "'":TEMP:"'"
DEL TEXT<TWO>; TEXT<ONE> = TEXT<ONE>:TEMP:", "
REPEAT
TEXT = TEXT[ONE,LEN(TEXT) - TWO]
IF LEN(TEXT) GT 60 THEN
IF LEN(TEXT) - COUNT(TEXT,", ") GT 60 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",ONE) WHILE POS DO TEXT = TEXT[ONE,POS]:TEXT[POS + TWO,999] REPEAT
END
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[ONE,POS - ONE]:" or":TEXT[POS + ONE,999]
TEXT = "Please use format ":TEXT
*
END CASE
*
RETURN
*
!
*
ERROR.ADVICE: *
*
IF TEXT EQ EMPTY THEN RETURN
IF NOT(QUERY) THEN PRINT BELL:
IF LN NE 23 AND RSP.LN NE 23 THEN TMP1 = 23 ELSE TMP1 = 22
PRINT @(ZERO,TMP1):CLL:TEXT[ONE,78]:
CLEAR.BOTTOM.LINE = TMP1
IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN TO UNCON.RETURN ELSE PRINT CLB:
*
UNCON.RETURN: *
*
RETURN
*
!
*
QUERY.HELP: *
*
STAT = ONE
*
IF COUNT(FILE.NAME,"$") THEN
ITEM.NAME = FIELD(FILE.NAME,"$",TWO)
FILE.NAME = FIELD(FILE.NAME,"$",ONE)
END
*
IF COUNT(ITEM.NAME,"$") THEN
FILE.NAME = FIELD(ITEM.NAME,"$",ONE)
ITEM.NAME = FIELD(ITEM.NAME,"$",TWO)
END
*
IF COUNT(FILE.NAME,".") THEN
FILE.NAME = FIELD(FILE.NAME,".",ONE)
END
*
IF QUERY NE 3 THEN
OPEN "DICT",FILE.NAME TO FILE.DICT THEN
*
IF ITEM.NAME[ONE,ONE] EQ "<" THEN
ITEM.NAME = ITEM.NAME[TWO,9999]
ITEM.NAME = FIELD(ITEM.NAME,">",ONE)
ITEM.NAME = FIELD(ITEM.NAME,",",ONE)
END
*
IF ITEM.NAME EQ "ONE" THEN ITEM.NAME = "1"
*
READ DICT.ITEM FROM FILE.DICT,ITEM.NAME ELSE DICT.ITEM = EMPTY; QUERY = 3
*
END ELSE DICT.ITEM = EMPTY; QUERY = 3
END ELSE DICT.ITEM = EMPTY
*
* PRINT CLB:DICT.ITEM<13> "L#79":
IF QUERY EQ ONE THEN QUERY.TEXT = DICT.ITEM<12>; IF NOT(LEN(QUERY.TEXT)) THEN QUERY = TWO
IF QUERY EQ TWO THEN QUERY.TEXT = DICT.ITEM<21>; IF NOT(LEN(QUERY.TEXT)) THEN QUERY = 3
IF QUERY EQ 3 THEN
GOSUB LOAD.EDITS
QUERY.TEXT = DICT.ITEM<13>
QUERY.TEXT<ONE,-ONE> = DICT.ITEM<11>
IF LEN(QT) THEN QUERY.TEXT<ONE,-ONE> = VM:VM:QT
END
*
QUERY.CN.MAX = DCOUNT(QUERY.TEXT,VM); QUERY.CN = ONE
*
IF QUERY.CN.MAX GT 5 THEN
REDISP = TRUE
PRINT @(ZERO,4):CLS:
PRINT @(ZERO,5):"   ":RVB:"File: ":FILE.NAME "L#5":"   Field: ":DICT.ITEM<TWO> "L#3":"   English: ":DICT.ITEM<3> "L#15":"   Name: ":DICT.ITEM<13> "L#19":RVE:
LOOP
FOR TMP.LN = 6 TO 20 UNTIL QUERY.CN GT QUERY.CN.MAX
PRINT @(ZERO,TMP.LN):"   ":QUERY.TEXT<ONE,QUERY.CN> "L#70":
QUERY.CN = QUERY.CN + ONE
NEXT TMP.LN
TMP = EMPTY
IF QUERY.CN LT QUERY.CN.MAX THEN
PRINT CLB:"Enter N(ext), P(rev), or <cr> to end: ":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
END ELSE
FOR TMP.LN = TMP.LN TO 20; PRINT @(ZERO,TMP.LN):CLL:; NEXT TMP.LN
END
IF TMP EQ "P" THEN
QUERY.CN = QUERY.CN - 30
IF QUERY.CN LE ONE THEN QUERY.CN = ONE
END
WHILE TMP EQ "N" OR TMP EQ "P" DO REPEAT
PRINT CLB:"Enter <cr> to resume: ":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
END ELSE IF QUERY.CN.MAX THEN
*
LOOP
IF LEN(QUERY.TEXT<ONE,QUERY.CN>) THEN
PRINT CLB:QUERY.TEXT<ONE,QUERY.CN> "L#70":" <cr>":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
END
WHILE QUERY.CN LT QUERY.CN.MAX DO
QUERY.CN = QUERY.CN + ONE
REPEAT
PRINT CLB:
*
END; * OF GT 5
*
PRINT CLB:DICT.ITEM<13> "L#79":
IF LN NE 23 THEN CLEAR.BOTTOM.LINE = ONE; RETURN
*
RETURN
*
!
*
LOAD.EDITS: *
*
ED.VC = ONE; IF EDITS<ONE,ED.VC> EQ "SE" THEN SUPPRESS.ERROR.PRINT = ONE; ED.VC = ED.VC + ONE
QT = EMPTY
*
LOOP ED = EDITS<ONE,ED.VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>; ED2 = ED<ONE,ONE,TWO>; ED3 = ED<ONE,ONE,3>
*
IF ED1 NE EMPTY THEN IF ED1 MATCHES "2A" THEN
*
BEGIN CASE
*
CASE ED1 EQ "OP"
QT<ONE,-ONE> = "An entry is not mandatory here."
*
CASE ED1 EQ "RQ"
QT<ONE,-ONE> = "An entry is mandatory here."
*
CASE ED1 EQ "LO"
QT<ONE,-ONE> = "Your entry should be at least ":ED2:"."
*
CASE ED1 EQ "HI"
QT<ONE,-ONE> = "Your entry should be no more than ":ED2:"."
*
CASE ED1 EQ "NC"
QT<ONE,-ONE> = "Enter an amount in cents only."
*
CASE ED1 EQ "ND"
QT<ONE,-ONE> = "Enter an amount in dollars and cents."
*
CASE ED1 EQ "NU"
QT<ONE,-ONE> = "Enter a number."
*
CASE ED1 EQ "DT"
QT<ONE,-ONE> = "Enter a date."
*
CASE ED1 EQ "DD"
QT<ONE,-ONE> = "The system date will be used as a default."
*
CASE ED1 EQ "LF"
QT<ONE,-ONE> = "Your entry will be right justified in a fied of ":ED3:" ":ED2:"'s."
*
CASE ED1 EQ "RF"
QT<ONE,-ONE> = "Your entry will be left justified in a field of ":ED3:" ":ED2:"'s."
*
CASE ED1 EQ "FF"
QT<ONE,-ONE> = "Your entry will be in a fixed instead of floating window."
*
CASE ED1 EQ "FI"
QT<ONE,-ONE> = "Your entry must already exist on file."
*
CASE ED1 EQ "DF"
IF ED2[ONE,ONE] NE "*" THEN
QT<ONE,-ONE> = ED2:" will be used if you do not make an entry."
END ELSE
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV TMP FROM EDIT.FILE,ED3,ED4 ELSE TMP = EMPTY
QT<ONE,-ONE> = TMP:" will be used if you do not make an entry."
END
*
CASE ED1 EQ "EQ"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
*
QTD = EMPTY; SCAN.VC = ONE; IF COUNT(ED,VM) THEN SCAN.SC = ZERO ELSE SCAN.SC = ONE
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC>[ONE,LHM] UNTIL TEMP EQ EMPTY DO
QTD<ONE,-ONE> = "     - ":TEMP
IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
*
IF QTD NE EMPTY THEN
QT<ONE,-ONE> = "Valid entries appear in the following list: ":VM:QTD
QTD = EMPTY
END
*
*
CASE ED1 EQ "MA"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
*
QTD = EMPTY; SCAN.VC = ONE; IF COUNT(ED,SVM) THEN SCAN.SC = ONE ELSE SCAN.SC = ZERO
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC> UNTIL TEMP EQ EMPTY DO
QTD<ONE,-ONE> = TEMP
IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
*
IF QTD NE EMPTY THEN
SCAN.AC = ZERO
*
LOOP SCAN.AC = SCAN.AC + ONE; OLD.TEMP = QTD<ONE,SCAN.AC> UNTIL OLD.TEMP EQ EMPTY DO
POS = ONE; NUMERALS = EMPTY;
ALL.QUOTES = TRUE; QUOTES = FALSE; TEMP = EMPTY
*
LOOP CHAR = OLD.TEMP[POS,ONE] UNTIL CHAR EQ EMPTY DO
BEGIN CASE
CASE CHAR EQ "'"; IF QUOTES THEN QUOTES = FALSE ELSE QUOTES = TRUE
CASE QUOTES; TEMP = TEMP:CHAR
CASE CHAR MATCHES "1N"; NUMERALS = NUMERALS:CHAR; ALL.QUOTES = FALSE
CASE CHAR EQ "A" OR CHAR EQ "N" OR CHAR EQ "X"
IF CHAR EQ "N" THEN CHAR = "9" ELSE IF CHAR EQ "A" THEN CHAR = "X" ELSE CHAR = "x"
IF NOT(NUMERALS) THEN NUMERALS = LHM; IF NUMERALS GT 3 THEN NUMERALS = 3
TEMP = TEMP:STR(CHAR,NUMERALS); NUMERALS = EMPTY; ALL.QUOTES = FALSE
CASE ONE; TEMP = TEMP:CHAR; ALL.QUOTES = FALSE
END CASE
POS = POS + ONE
REPEAT
*
IF ALL.QUOTES THEN TEMP = "'":TEMP:"'"
QTD<ONE,SCAN.AC> = "     - ":TEMP
REPEAT
*
QT<ONE,-ONE> = "Valid entries must match one of the following masks: ":VM:QTD
QTD = EMPTY
*
END; * of QTD
*
END CASE
*
END; * of 2A
*
ED.VC = ED.VC + ONE
*
REPEAT
*
QT<ONE,-ONE> = "Enter no more than ":LHM:" characters."
*
RETURN
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
*
END
~EI.CONV~
*PROGRAM: EI.CONV
*
DIM IN.EI(50), OUT.EI(50)
MAT OUT.EI = ''
MAT IN.EI = ''
PROGRAM.CONTROL = 'CONTINUE'
LOCT = 1
$INCLUDE AX.IBP STANDARD.FUNCTIONS
OPEN 'SYS.STRUCTURE' TO SYSS ELSE STOP
LOCT = 2
OPEN 'EI' TO IN.FILE ELSE STOP
LOCT = 7
KEY.COUNTER = 0
RSP = ""
LOOP
KEY.COUNTER = KEY.COUNTER + 1
READNEXT ID ELSE STOP
PRINT "*":
WHILE KEY.COUNTER DO
MATREAD IN.EI FROM IN.FILE,ID ELSE STOP
MAT OUT.EI = MAT IN.EI
*
VM.MAX = DCOUNT(IN.EI(15),VM)
IF VM.MAX THEN
OUT.EI(15) = ""
FOR VM.CN = 1 TO VM.MAX
OUT.EI(15)<1,1,VM.CN> = IN.EI(15)<1,VM.CN,1>
OUT.EI(15)<1,2,VM.CN> = IN.EI(15)<1,VM.CN,2>
OUT.EI(15)<1,3,VM.CN> = IN.EI(15)<1,VM.CN,3>
NEXT VM.CN
*
IF RSP NE "GO" THEN PRINT BELL:; INPUT RSP:
MATWRITE OUT.EI ON IN.FILE,ID
END
REPEAT
END
~EI.INFO.AREA.CONVERT~
*PROGRAM: EI.INFO.AREA.CONVERT
*
DIM REC.EI(100)
MAT REC.EI = ''
DIM OUT.REC(5)
MAT OUT.REC = ''
DIM OUT.REC.EI(5,20)
MAT OUT.REC.EI = ''
PC = 'To continue enter a "Y"'
LOCT = 1
$INCLUDE AX.IBP STANDARD.FUNCTIONS
OPEN 'SYS.STRUCTURE' TO SYSS ELSE STOP
Top: GOSUB REL.INPUT.SCREEN
MATREAD REC.EI FROM SYSS,INFO.AREA ELSE GOTO Top
MAT OUT.REC.EI = MAT REC.EI
MAT OUT.REC = ''
KEY.COUNTER = 0
PRINT @(10,10):PC:
INPUT CONT
IF CONT # 'Y' THEN GOTO Bottom
PRINT @(0,0):CLS:
PRINT
LOOP
KEY.COUNTER = KEY.COUNTER + 1
WHILE CONT = 'Y' AND KEY.COUNTER < 21 DO
IF KEY.COUNTER > 1 THEN
OUT.REC(1) = OUT.REC(1):'*'
OUT.REC(2) = OUT.REC(2):'*'
OUT.REC(3) = OUT.REC(3):'*'
OUT.REC(4) = OUT.REC(4):'*'
OUT.REC(5) = OUT.REC(5):'*'
END
OUT.REC(1) = OUT.REC(1):OUT.REC.EI(1,KEY.COUNTER)
OUT.REC(2) = OUT.REC(2):OUT.REC.EI(2,KEY.COUNTER)
OUT.REC(3) = OUT.REC(3):OUT.REC.EI(3,KEY.COUNTER)
OUT.REC(4) = OUT.REC(4):OUT.REC.EI(4,KEY.COUNTER)
OUT.REC(5) = OUT.REC(5):OUT.REC.EI(5,KEY.COUNTER)
PRINT @(1):'Field number ':KEY.COUNTER:'.'
REPEAT
MATWRITE OUT.REC ON SYSS,INFO.AREA.CV
GOTO Top
*
REL.INPUT.SCREEN: *#*
*
SC.top: PRINT @(0,0):CLS:
H1 = 'COPY ENTITY INFORMATION AREAS TO A HOLD RECORD'
PRINT @(40-(INT(LEN(H1)/2)),3):RVB:H1:RVE:
H2 = 'FOR MAINTENANCE DENOTED BY "@EI@INFO.AREA.CV-info.area"'
PRINT @(40-(INT(LEN(H2)/2)),5):RVB:H2:RVE:
L1 = 'Enter information area to convert: '
PRINT @(10,8):L1:
INFO.A0 = 'INFO.AREA'
A$ = INFO.A0
INPUT @(12+LEN(L1),8):A$
IF LEN(A$) = 0 THEN A$ = INFO.A0
INFO.A0 = A$
INFO.A1 = '@EI@INFO.AREA'
INFO.AREA.CV = INFO.A1:'.CV-':INFO.A0
INFO.AREA = INFO.A1:'-':INFO.A0
RETURN
*
*
Bottom: *#*
*
PRINT
PRINT
PRINT 'Thank you, I am finished...'
RQM
PRINT BELL
PRINT
PRINT
PRINT
PRINT
END
~EI.INFO.AREA.INSTALL~
*PROGRAM: EI.INFO.AREA.INSTALL
*
DIM IN.REC(5)
MAT IN.REC = ''
DIM OUT.REC(5,20)
MAT OUT.REC = ''
DIM OUT.REC.EI(100)
MAT OUT.REC.EI = ''
PC = 'To continue enter a "Y"'
LOCT = 1
$INCLUDE AX.IBP STANDARD.FUNCTIONS
OPEN 'SYS.STRUCTURE' TO SYSS ELSE STOP
Top: GOSUB REL.INPUT.SCREEN
MATREAD IN.REC FROM SYSS,INFO.AREA.CV ELSE GOTO Top
MAT OUT.REC = ''
MAT OUT.REC.EI = ''
KEY.COUNTER = 0
PRINT @(10,10):PC:
INPUT CONT
IF CONT # 'Y' THEN GOTO Bottom
PRINT @(0,0):CLS:
PRINT
LOOP
KEY.COUNTER = KEY.COUNTER + 1
WHILE CONT = 'Y' AND KEY.COUNTER < 21 DO
OUT.REC(1,KEY.COUNTER) = FIELD(IN.REC(1),'*',KEY.COUNTER)
OUT.REC(2,KEY.COUNTER) = FIELD(IN.REC(2),'*',KEY.COUNTER)
OUT.REC(3,KEY.COUNTER) = FIELD(IN.REC(3),'*',KEY.COUNTER)
OUT.REC(4,KEY.COUNTER) = FIELD(IN.REC(4),'*',KEY.COUNTER)
OUT.REC(5,KEY.COUNTER) = FIELD(IN.REC(5),'*',KEY.COUNTER)
PRINT @(1):'Field number ':KEY.COUNTER:'.'
REPEAT
MAT OUT.REC.EI = MAT OUT.REC
MATWRITE OUT.REC.EI ON SYSS,INFO.AREA
GOTO Top
*
REL.INPUT.SCREEN: *#*
*
SC.top: PRINT @(0,0):CLS:
H1 = 'INSTALL ENTITY INFORMATION AREAS IN SYS'
PRINT @(40-(INT(LEN(H1)/2)),3):RVB:H1:RVE:
H2 = 'FOR USE BY APPLICATIONS (DENOTED BY "@EI@INFO.AREA-info.area")'
PRINT @(40-(INT(LEN(H2)/2)),5):RVB:H2:RVE:
L1 = 'Enter information area to convert: '
PRINT @(10,8):L1:
INFO.A0 = 'INFO.AREA'
A$ = INFO.A0
INPUT @(12+LEN(L1),8):A$
IF LEN(A$) = 0 THEN A$ = INFO.A0
INFO.A0 = A$
INFO.A1 = '@EI@INFO.AREA'
INFO.AREA.CV = INFO.A1:'.CV-':INFO.A0
INFO.AREA = INFO.A1:'-':INFO.A0
RETURN
*
*
Bottom: *#*
*
PRINT
PRINT
PRINT 'Thank you, I am finished...'
RQM
PRINT BELL
PRINT
PRINT
PRINT
PRINT
END
~EI.SD~
SUBROUTINE EI.SD
*SUBROUTINE: EI.SD
*
$INCLUDE IBP EI.COMMON.VARIABLES
*
P.L.N = 1
$INCLUDE IBP STANDARD.FUNCTIONS
*
CALL S.I.T.EI.SPEC.DISP
CTC.ERR = 0
*
* PRINT BELL:
* INPUT TEMP:
IF NOT(INDEX("*d*N*B*A*M*D*","*":FTYPE:"*",1)) THEN
F.ERR = 1
CTC.ERR = 5
GOSUB CTC.ERR.DISP
RETURN
END
*
*          SPEC<1,1,1> is the format (C)olumns or (R)ows
CTC.JFLD = SPEC<1,1,2>; * is the next field to process if done
 N.LN.CL = SPEC<1,1,3>; * Number of lines on a page
CTC.FLEN = SPEC<1,1,4>; * is the field length
*          SPEC<1,1,5>; * is ?
CTC.CFLD = SPEC<1,1,6>; * is the controlling field
*
IF SPEC<1,1,1> = "C" THEN
B.LN = N.LN.CL + (L.P + L.A)
B.CL = C.P
END ELSE
* = "R"
B.LN = (L.P + L.A)
B.CL = C.P + (N.LN.CL * CTC.FLEN)
END
C.LN = 0
C.CL = 0
*
CTC.DONE = ""
CTC.DONE1 = ""
CTC.INPUT = ""
CTC.45FL = 0
CTC.R.F = ""
CTC.INP.FLD = ""
F.D       = CNTR<1,1,1>; * Last line displayed
*           CNTR<1,1,2>; * is the field separator (AM,VM,SV,4V,5V)
F.D.ENTER = CNTR<1,1,3>; * is the line to be accessed
CT.PAGE   = CNTR<1,1,4>; * Multi-page flag
IF CT.PAGE NE "Y" THEN CT.PAGE = "" ELSE CT.PAGE = 1
CTC.PAGE.FLAG = ""
*
* Set record pointers
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
*
TMP.ATT = CT.ATT; TMP.VAL = CT.VAL; TMP.SVL = CT.SVL; TMP.4VL = CT.4VL; TMP.5VL = CT.5VL
IF CTC.CFLD EQ L.W THEN
IF CNTR<1,1,2> = "AM" THEN TMP.5VL = 0; TMP.4VL = 0; TMP.SVL = 0; TMP.VAL = 0; TMP.ATT = 0; TMP.CHR = AM ELSE
IF CNTR<1,1,2> = "VM" THEN TMP.5VL = 0; TMP.4VL = 0; TMP.SVL = 0; TMP.VAL = 0; TMP.CHR = VM ELSE
IF CNTR<1,1,2> = "SV" THEN TMP.5VL = 0; TMP.4VL = 0; TMP.SVL = 0; TMP.CHR = SVM ELSE
IF CNTR<1,1,2> = "4V" THEN TMP.5VL = 0; TMP.4VL = 0; TMP.CHR = "*"; CTC.45FL = 1 ELSE 
IF CNTR<1,1,2> = "5V" THEN TMP.5VL = 0; TMP.CHR = "@"; CTC.45FL = 2 ELSE 
CTC.ERR = 3
GOSUB CTC.ERR.DISP
END
END
END
END
END
TMP.FIELD.CK = EI.REC(TMP.ATT)<1,TMP.VAL,TMP.SVL>
IF CTC.45FL EQ 2 THEN TMP.FIELD.CK = FIELD(TMP.FIELD.CK,"*",TMP.4VL)
F.D.MAX = DCOUNT(TMP.FIELD.CK,TMP.CHR)
CNTR<1,1,6> = F.D.MAX
F.D.CFLD = F.D
CNTR<1,1,7> = F.D.CFLD
END ELSE
F.D.MAX = CNTR<1,1,6>; * Number of lines in record
F.D.CFLD = CNTR<1,1,7>; * F.D of the controlling field
END
*
* IF INDEX("*A*M*D*","*":FTYPE:"*",1) THEN
* IF CTC.CFLD NE L.W THEN F.D.ENTER = F.D.CFLD
* END
*
P.L.N = 2
*
IF NOT(F.D.ENTER) OR INDEX("*d*N*B*A*","*":FTYPE:"*",1) THEN
IF FTYPE = "M" THEN
CTC.ERR = 6
GOSUB CTC.ERR.DISP
RETURN
END ELSE IF INDEX("*d*N*B*","*":FTYPE:"*",1) OR (FTYPE EQ "A" AND CTC.CFLD EQ L.W) THEN
IF FTYPE EQ "d" THEN FTYPE = "B"
IF FTYPE EQ "N" AND F.D GE F.D.MAX THEN FTYPE = "B"
F.D.ENTER = F.D.MAX + 1
END ELSE IF FTYPE EQ "D" THEN
* = "D"
GOSUB CTC.DEL
RETURN
END ELSE IF FTYPE EQ "A" THEN
F.D.ENTER = F.D.MAX
END
END
*
CURR.NEXT.FLAG = ""
SAVE.F.D = F.D
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
$INCLUDE IBP EI.SD.INCL.CTC.CALC.DET.TOP
*
IF INDEX("*A*M*D*","*":FTYPE:"*",1) THEN
IF F.D.ENTER > F.D THEN
END ELSE IF F.D.ENTER < F.D.TOP THEN
F.D = 0
END ELSE CTC.DONE = 1; CTC.INPUT = ""; CTC.PAGE.FLAG = ""
END ELSE CTC.DONE1 = 1
*
IF (FTYPE EQ "A" AND CTC.CFLD EQ L.W) OR (F.D.ENTER GT F.D OR F.D LT F.D.TOP) THEN
C.LN = 0
END ELSE
* Load F.D.ENTER if we are on the right page
IF F.D.ENTER GE F.D.TOP AND F.D.ENTER LE F.D THEN CTC.DONE = 1; CTC.PAGE.FLAG = ""; F.D = F.D.ENTER
END; * of decrement counter
*
LOOP WHILE NOT(CTC.DONE AND CTC.DONE1) AND NOT(CTC.ERR) DO
*
P.L.N = 3
*
* INCREMENT COUNTER
IF NOT(CTC.DONE) THEN
F.D = F.D + 1
CURR.NEXT.FLAG = 1
END ELSE
CURR.NEXT.FLAG = ""
END; * of increment counter
*
* PREPARE FOR NEXT LINE
*
LOOP
*
P.L.N = 4
*
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
*
IF CTC.PAGE.FLAG THEN
CNTR<1,1,5> = 1
GOSUB CTC.PAGE.FULL
SAVE.F.D = F.D - 1
IF (F.D.ENTER GE F.D.TOP AND F.D.ENTER LE F.D) OR F.D GE F.D.MAX THEN
CTC.DONE = 1
IF NOT(CTC.DONE1) THEN
SAVE.F.D = F.D
IF F.D LT F.D.MAX THEN SAVE.F.D = SAVE.F.D - 1
F.D = F.D.ENTER
END
END
END
*
WHILE CTC.PAGE.FLAG DO
CTC.PAGE.FLAG = ""
CURR.NEXT.FLAG = 1
C.LN = 0
REPEAT
*
P.L.N = 5
*
* Display or input field
IF NOT(CTC.DONE AND CTC.DONE1) THEN
IF CTC.DONE AND ((FTYPE EQ "A" AND (F.D.ENTER EQ F.D OR F.D GT F.D.MAX)) OR (FTYPE EQ "M" AND F.D.ENTER EQ F.D)) THEN
GOSUB INPUT.FLD
IF FTYPE EQ "A" THEN
IF CTC.INP.FLD EQ "END" THEN F.D = F.D - 1
F.D.MAX = F.D
SAVE.F.D = F.D
END
IF NOT(CTC.DONE1) THEN CTC.DONE1 = 1
END ELSE
* D B N
GOSUB CTC.FIELD.EXTRACT
*
PRINT @(C.CL - 3,C.LN):RVB:"-":F.D:SPACE(2-LEN(F.D)):RVE:
IF F.D = F.D.ENTER THEN PRINT RVB:
IF NOT(CTC.FLEN) THEN
PRINT @(C.CL,C.LN):CT.FIELD.CK[1,50]:
END ELSE
TMP = "L#":CTC.FLEN
PRINT @(C.CL,C.LN):CT.FIELD.CK TMP:
END
IF F.D = F.D.ENTER THEN
PRINT RVE:
IF CTC.DONE THEN
IF FTYPE EQ "D" THEN
GOSUB CTC.DEL.DETL
CTC.DONE = ""
F.D = F.D - 1
CURR.NEXT.FLAG = ""
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
END
IF NOT(CTC.DONE1) THEN CTC.DONE1 = 1
END
END
END; * of ftype A/M or D/B/N
END; * of not done
*
IF F.D GE F.D.MAX THEN
CTC.DONE = 1
IF NOT(CTC.DONE1) THEN 
SAVE.F.D = F.D
F.D = F.D.ENTER
END
END
*
REPEAT
*
P.L.N = 6
*
IF CTC.DONE AND CTC.INP.FLD EQ "END" THEN CTC.ERR = 9
CNTR<1,1,1> = SAVE.F.D
CNTR<1,1,6> = F.D.MAX
*
RETURN
*
INPUT.FLD: *#*
*
P.L.N = 10
PROG.SUB.NAME = "Input the Field"
PRINT @(F.Z1,L.M):CLL:PROG.SUB.NAME:
PRINT @(C.CL - 3,C.LN):RVB:"-":F.D:SPACE(2-LEN(F.D)):SPACE(CTC.FLEN):
CTC.R.F0 = EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>
IF CTC.45FL > 0 THEN
CTC.R.F1 = FIELD(CTC.R.F0,"*",CT.4VL)
CTC.SCOL1 = COL1(); CTC.ECOL1 = COL2()
IF CTC.45FL = 2 THEN
CTC.R.F2 = FIELD(CTC.R.F1,"@",CT.5VL)
CTC.SCOL2 = COL1(); CTC.ECOL2 = COL2()
CTC.R.F = CTC.R.F2
END ELSE
CTC.R.F = CTC.R.F1
END
END ELSE CTC.R.F = CTC.R.F0
CTC.INP.FLD = CTC.R.F
INPUT @(C.CL,C.LN):CTC.INP.FLD
IF LEN(CTC.INP.FLD) # 0 & CTC.INP.FLD # "END" THEN CTC.R.F = CTC.INP.FLD
IF CTC.INP.FLD = "/" THEN CTC.R.F = ""
PRINT RVE:
PRINT @(C.CL - 3,C.LN):RVB:"-":F.D:SPACE(2-LEN(F.D)):RVE:
PRINT @(C.CL,C.LN):CTC.R.F:SPACE(CTC.FLEN-LEN(CTC.R.F)):
IF CTC.INP.FLD # "END" THEN
IF CTC.45FL > 0 THEN
IF CTC.45FL = 2 THEN
IF CTC.R.F1[CTC.SCOL2,1] # "@" & F.D # 1 ! (CTC.SCOL2 = 0 & CTC.ECOL2 = 0) THEN
CTC.R.F = "@":CTC.R.F
IF CTC.SCOL2 = 0 THEN CTC.SCOL2 = LEN(CTC.R.F1); CTC.ECOL2 = CTC.SCOL2 + 1
END
CTC.R.F1 = CTC.R.F1[1,CTC.SCOL2]:CTC.R.F:CTC.R.F1[CTC.ECOL2,9999]
END ELSE
CTC.R.F1 = CTC.R.F
END
IF CTC.R.F0[CTC.SCOL1,1] # "*" & F.D # 1 ! (CTC.SCOL1 = 0 & CTC.ECOL1 = 0) THEN
CTC.R.F1 = "*":CTC.R.F1
IF CTC.SCOL1 = 0 THEN CTC.SCOL1 = LEN(CTC.R.F0); CTC.ECOL1 = CTC.SCOL1 + 1
END
CTC.R.F0 = CTC.R.F0[1,CTC.SCOL1]:CTC.R.F1:CTC.R.F0[CTC.ECOL1,9999]
END ELSE
CTC.R.F0 = CTC.R.F
END
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = CTC.R.F0
END ELSE
PRINT @(C.CL-3,C.LN):RVB:"   ":RVE:SPACE(CTC.FLEN):
END
RETURN
*
CTC.CLEAR: *#*
*
P.L.N = 11
IF SPEC<1,1,1> = "R" THEN
PRINT @(C.P,(L.P + L.A)):SPACE(N.LN.CL * CTC.FLEN):
END ELSE
* = "C"
COUNTER = (L.P + L.A)
LOOP WHILE COUNTER < B.LN DO
PRINT @(C.P - 3,COUNTER):RVB:"   ":RVE:SPACE(CTC.FLEN):
COUNTER = COUNTER + 1
REPEAT
END
RETURN
!
CTC.FIELD.EXTRACT: *#*
P.L.N = 12
CT.FIELD.CK = EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>
IF CTC.45FL # 0 THEN
CT.FIELD.CK = FIELD(CT.FIELD.CK,"*",CT.4VL)
IF CTC.45FL = 2 THEN CT.FIELD.CK = FIELD(CT.FIELD.CK,"@",CT.5VL)
END
RETURN
!
CTC.PAGE.FULL: *#*
P.L.N = 13
* PRINT @(0,23):"PAGE.FULL":
* INPUT RSP:
* PRINT @(0):CLL:
IF CT.PAGE EQ "N" AND F.D THEN RETURN
IF INDEX("*A*M*D*","*":FTYPE:"*",1) THEN
$INCLUDE IBP EI.SD.INCL.CTC.CALC.DET.TOP
IF F.D.ENTER GT F.D OR F.D.ENTER LT F.D.TOP OR F.D.ENTER = 9999 THEN 
IF F.D.ENTER NE 9999 AND NOT(LEN(CTC.INPUT)) THEN
PRINT @(F.Z1,L.E):CLL:@(40):"Enter <CR> :"
INPUT @(F.Z4,L.E):CTC.INPUT
END
IF F.D.ENTER < F.D.TOP & NOT(F.D.ENTER = 9999) THEN CTC.INPUT = "B" ELSE CTC.INPUT = "N"
END
END ELSE
* IF LEN(CTC.INPUT) = 0 THEN
* PRINT @(F.Z1,L.E):CLL:"(B)eginning, <CR> = (N)ext page, or E to stop:"
* INPUT @(F.Z5,L.E):CTC.INPUT
* IF CTC.INPUT = "END" THEN CTC.INPUT = "E"
* IF CTC.INPUT = "" THEN CTC.INPUT = "N"
* PRINT @(F.Z5,L.E):CTC.INPUT:
* END
IF LEN(CTC.INPUT) = 0 THEN CTC.INPUT = "E"
END
IF CTC.INPUT EQ "N" OR CTC.INPUT EQ "B" THEN
IF F.D.ENTER NE 9999 THEN GOSUB CTC.CLEAR
P.L.N = 4
IF FTYPE EQ "B" THEN FTYPE = "N"
IF CTC.INPUT = "B" THEN
F.D = 1
* $INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
END
CNTR<1,1,5> = 0
END ELSE IF CTC.INPUT = "E" THEN
* E
CTC.DONE = 1
CTC.DONE1 = 1
CTC.INP.FLD = "END"
END
CTC.INPUT = ""
C.LN = 0
RETURN
!
CTC.ERR.DISP: *#*
*
PRINT @(F.Z1,L.M):CLL:BELL:TB.ERRS(CTC.ERR):", enter a <CR>.":
YES.NO = ""
INPUT @(F.Z1,L.E):YES.NO:
PRINT @(F.Z1,L.M):CLL:
RETURN
!
CTC.DEL.ALL: *#*
*
P.L.N = 17
CTC.DEL: PRINT @(F.Z1,L.E):CLL:BELL:"Are you sure you want to DELETE all of them (Y / <CR>=N): ":
YES.NO = "N"
INPUT @(F.Z5,L.E):YES.NO
IF INDEX(NO,"*":YES.NO:"*",1) # 0 THEN FTYPE = " "; RETURN
IF INDEX(YES,"*":YES.NO:"*",1) = 0 THEN GOTO CTC.DEL
IF CNTR<1,1,2> = "AM" THEN MAT EI.REC = "" ELSE
IF CNTR<1,1,2> = "VM" THEN EI.REC(CT.ATT) = "" ELSE
IF CNTR<1,1,2> = "SV" THEN EI.REC(CT.ATT)<1,CT.VAL> = "" ELSE
IF CNTR<1,1,2> = "4V" THEN EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = "" ELSE
IF CNTR<1,1,2> = "5V" THEN
CT.FIELD.CK = FIELD(EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>,"*",CT.4VL)
CTC.SCOL1 = COL1(); CTC.ECOL1 = COL2()
CT.FIELD.CK = CT.FIELD.CK[1,CTC.SCOL1]:CT.FIELD.CK[(CTC.ECOL1),9999]
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = CT.FIELD.CK
END ELSE
NULL
END
END
END
END
END
F.D = 0
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
GOSUB CTC.CLEAR
RETURN
!
CTC.DEL.DETL: *#*
*
P.L.N = 18
IF CTC.CFLD EQ L.W THEN
PRINT @(F.Z1,L.E):BELL:CLL:"DELETE THIS TEXT LINE (Y / <CR>=N): ":
YES.NO = "N"
INPUT @(F.Z3,L.E):YES.NO
IF LEN(YES.NO) = 0 THEN YES.NO = "N"
END ELSE YES.NO = "Y"
IF INDEX(YES,"*":YES.NO:"*",1) # 0 THEN
IF CNTR<1,1,2> = "AM" THEN
COUNTER = CT.ATT - 1
LOOP
COUNTER = COUNTER + 1
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = EI.REC(CT.ATT + 1)<1,CT.VAL,CT.SVL>
WHILE EI.REC(COUNTER + 1)<1,CT.VAL,CT.SVL> # "" DO
EI.REC(CT.ATT + 1)<1,CT.VAL,CT.SVL> = ""
REPEAT
END ELSE
*
IF CTC.45FL = 0 THEN
EI.REC(CT.ATT) = DELETE(EI.REC(CT.ATT),1,CT.VAL,CT.SVL)
END ELSE
*
CT.FIELD.CK = EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>
CT.FIELD.CK1 = FIELD(CT.FIELD.CK,"*",CT.4VL)
CTC.SCOL1 = COL1(); CTC.ECOL1 = COL2()
*
IF CTC.45FL = 1 THEN
CT.FIELD.CK = CT.FIELD.CK[1,CTC.SCOL1]:CT.FIELD.CK[(CTC.ECOL1+1),9999]
END ELSE
*
CT.FIELD.CK2 = FIELD(CT.FIELD.CK1,"@",CT.5VL)
CTC.SCOL2 = COL1(); CTC.ECOL2 = COL2()
CT.FIELD.CK1 = CT.FIELD.CK1[1,CTC.SCOL2]:CT.FIELD.CK1[(CTC.ECOL2+1),9999]
CT.FIELD.CK = CT.FIELD.CK[1,CTC.SCOL1]:CT.FIELD.CK1:CT.FIELD.CK[CTC.ECOL1,9999]
END
*
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = CT.FIELD.CK
END
*
END
*
* IF EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = "" THEN
IF F.D THEN
F.D = F.D - 1
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
END
* IF C.LN > (L.P + L.A) THEN C.LN = C.LN - 1
* END
IF CTC.JFLD EQ L.W AND F.D.MAX THEN F.D.MAX = F.D.MAX - 1
COUNTER = C.LN - 1
LOOP COUNTER = COUNTER + 1 WHILE COUNTER < B.LN DO PRINT @(C.CL-3,COUNTER):RVB:"   ":RVE:SPACE(CTC.FLEN): REPEAT
P.L.N = 18
END
RETURN
*!
!
END
~ENTITY.INFO~
*PROGRAM: ENTITY.INFO
*
$INCLUDE IBP EI.COMMON.VARIABLES
PROG.LOCT = 1
PROG.NAME = "Entity File Entry and Control Program"
$INCLUDE IBP CNTR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP EI.STANDARD.FUNCTIONS
*
*@* DIM STATEMENTS *@*
PROG.LOCT = 2
MAT TB.LOCT = 0; MAT TB.ERRS = 0
MAT TB.L = ""
MAT IA.C = 0
*
*
*
MAT EI.REC = ""
K.H.L = 10
*
PRINT
PRINT "EI Appl":
INPUT EI.A
PRINT "EI User":
INPUT EI.U
PRINT "EI List":
INPUT EI.A.U
PRINT "EI Run Type":
INPUT EI.RUN.TYPE
EI.MV.AM = 0; EI.KL.AM = 0; EI.ET.AM = 0; EI.CDT.AM = 0; EI.ADT.AM = 0
EI.PDT.AM = 0; EI.CR.AM = 0; EI.SK.FL = 0; EI.FI.VL = ""
*
L.A = 0; L.P = 0; C.P = 0
KEYS.SL = ""
KEY.LIST.CN = 0
KEY.LIST.DEL = 0
KEY.LIST.SAVE = ""
KEY.LIST = ""
ID = ""
KEY.ITEM = ""
REC.STATUS = 9
FUNCT.NUMBER = 1
F.T = "M"
FUNCT.SCAN = ""
FUNCT.SCAN.INP = ""
C.R = 0; NUMB.REC = 0
IA.C.RESET = 1
SD.PAGE = ""
L.W = 0; SAVE.L.W = 0; SUB.L.W = 0; SUB.FUNCT = ""; LINE.ALPHA = ""
EI.ENTY.FILE = ""; TB.FL = 0
PROMPT ""
PRINT FF
*
CONTR.FLAG = 0
KEY.P.L = 1
K.C.L = 1
K.D.L = 0
KEY.DF.L = 0
FTB.DONE = "MODIFY.INFO"
F.TIME = 1
*
*@* FILE OPEN AREA *@*
*
PROG.LOCT = 3
*
*@* OPEN SYSTEM STRUCTURE FILE
*
$INCLUDE IBP SUB.IO.OPEN.EI.SYSS
*
*#*
*#* Initialize Program Control Fields
*#*
PROG.LOCT = 4
CURRENT.DAT.INP = 0
CALL S.I.T.EI 
IF F.ERR THEN STOP
*
PROG.LOCT = 5
$INCLUDE IBP SUB.IO.OPEN.EI
*
PROG.LOCT = 6
KEY.ENTITY = ""; KEY.ENTITY.ID = KEY.ENTITY; KEY.ENTITY.INPUT = ""
KEY.CN1 = 0; KEY.CN2 = 0
*#*
*#* Determine List Handling
*#*
GOSUB ENTITY.LIST.CONTROL
*#*
*#* Input program default/control information
*#*
GOSUB ENTITY.CONTROL
*#*
*#*
*#* MAIN LOGIC AREA
*#*
*#*
10 LOOP
PROG.LOCT = 100
IF F.T # "END" THEN GOSUB KEY.INPUT.PRIMARY           
WHILE KEY.ENTITY.INPUT # "END" & F.T # "END" DO 
*
*      READ ENTITY FILE RECORD
*
F.T = ""
GOSUB ENTITY.READ           
IF REC.STATUS # 7 THEN
GOSUB IA.LOAD.CONTROL
*
*          ENTER ADDR IF NEW
*
FUNCT.SCAN = ""
F.T = ""
IF REC.STATUS = 1 THEN
IF FTB.DONE = "ADD.RECORD" THEN
FTB.DONE = "NEXT.MV"; F.T = "@"
GOSUB INPUT.CONTROL
FTB.DONE = "MODIFY.INFO"
GOSUB MAIN.LOOP
END
END ELSE
GOSUB FOREGROUND.DISPLAY
GOSUB MAIN.LOOP
END
END
REPEAT
GOSUB END.OF.PROGRAM.AREA
GOTO 99999
*
MAIN.LOOP: *#*
*
*      INPUT FUNCTION - S,L,P,A/M/D,U,I
*
100  GOSUB ACTION.SELECT
IF F.T = "END" THEN 
PRINT @(F.Z1,L.E):CLL:RVB:BELL:"END requested, (Y/<CR> = N):":RVE:
YES.NO = "N"
INPUT @(F.Z3,L.E):YES.NO:
IF YES.NO # "Y" THEN GOSUB CONTROL.DISPLAY; GOTO 100
END ELSE
IF F.T = "CAN" THEN
IF REC.STATUS = 1 ! REC.STATUS = 2 THEN
YES.NO = "Y"
END ELSE
IF REC.STATUS = 4 ! REC.STATUS = 5 ! REC.STATUS = 6 THEN
PRINT @(F.Z1,L.M):CLL:RVB:BELL:"Entity has been ":TB.STAT(REC.STATUS):" (":REC.STATUS:"), some changes have occurred.":;RQM
RQM
PRINT @(F.Z1,L.E):CLL:BELL:"CANCELL changes that occured after record ":TB.STAT(REC.STATUS):" (Y/<CR> = N):"
YES.NO = "N"
INPUT @(F.Z4,L.E):YES.NO
IF LEN(YES.NO) = 0 THEN YES.NO = "N"
END ELSE
PRINT @(F.Z1,L.E):CLL:RVB:BELL:"CANCELLATION requested, (Y or <CR>):":RVE:
YES.NO = "N"
INPUT @(F.Z3,L.E):YES.NO:
END
END
IF YES.NO # "Y" THEN GOTO 100
REC.STATUS = 7; GOSUB CONTROL.DISPLAY
END
*
*    ENTITY FILE RECORD MODIFY
*
IF F.T = "S" THEN
*    GOSUB KEY.REDEFINE.AREA
GO TO 100
END
*
*    LIST ADDR ON SCREEN
*
IF F.T = "L" THEN GOSUB SCREEN.LISTING.AREA
*
*    PRINT ADDR ON PRINTER
*
IF F.T = "P" THEN GOSUB PRINTER.LISTING.AREA
*
*    CHANGE INFO AREA
*
IF F.T = "I" THEN
F.ERR = ""
KEY.P.L = K.C.L
CALL SUB.KEY.SELECT.EI 
IF F.ERR THEN
IF F.ERR = "END" THEN F.T = "END"
IF F.ERR = "CAN" THEN REC.STATUS = 7; F.T = "U"
END ELSE
IF K.C.L = KEY.P.L THEN GOSUB BACKGROUND.DISPLAY
GOSUB IA.LOAD.CONTROL
GOSUB FOREGROUND.DISPLAY
GOTO 100
END
END
*
*@* DETAIL RECORD MODIFY *@*
*
FTB.DONE = "MODIFY.INFO"
IF F.T = "A" ! F.T = "M" ! F.T = "D" THEN 
IF NOT(K.C.L>K.H.L) THEN
IF F.T = "A" THEN FTB.DONE = "NEXT.MV"; F.T = "@"
GOSUB INPUT.CONTROL
END ELSE
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", I am unable to access than KEY LEVEL.":; RQM
END
IF F.T # "END" & F.T # "CAN" THEN GOTO 100
END
IF REC.STATUS # 7 THEN 
GOSUB UPDATE.ENTITY.RECORD
REC.STATUS = 8; GOSUB CONTROL.DISPLAY
END
IF F.T = "END" THEN GOTO 99999
END
RETURN; *: *
*
UPDATE.ENTITY.RECORD: *@* FILE UPDATE SUBROUTINE *@*
*
MATWRITE EI.REC ON ENTY,KEY.ENTITY
REC.STATUS = 4; GOSUB CONTROL.DISPLAY; RQM
RETURN; *: *
*
ENTITY.DELETE.AREA: *@*
*PRINT 'ENTITY.DELETE.AREA'
*INPUT TEMP
*IF TEMP = "END" THEN STOP
*
IF F.T = "D" THEN
IF FUNCT.SCAN THEN
PRINT @(F.Z1,L.E):CLL:"Delete this ":TB.L(K.C.L)<1,1,1>:" ( Q or Y or <CR> = N):":
FUNCT.SCAN.INP = "N"
INPUT @(F.Z4,L.E):FUNCT.SCAN.INP
END ELSE FUNCT.SCAN.INP = "Y"
IF FUNCT.SCAN.INP = "" THEN FUNCT.SCAN.INP = "N"
IF FUNCT.SCAN.INP = "Y" THEN
*PRINT ' (DELETE) FUNCT.SCAN.INP EQ "Y"'
*INPUT TEMP
*IF TEMP EQ "END" THEN STOP
*GOSUB ENTITY.DELETE.RECORD
*END
*END
*RETURN; *: *
**
*ENTITY.DELETE.RECORD: *@*
*
*PRINT 'ENTITY.DELETE.RECORD'
*INPUT TEMP
*IF TEMP EQ "END" THEN STOP
*IF F.T = "D" THEN
MAXM.FLD = TB.L(K.C.L)<1,1,6>
CN1 = 1
LOOP
CN1 = CN1 + 1
WHILE CN1 < MAXM.FLD+1 DO
CT.ATT = IA.C(3,CN1)<1,1>
EI.REC(CT.ATT) = DELETE(EI.REC(CT.ATT),1,C.R)
REPEAT
NUMB.REC = NUMB.REC-1
*END
REC.STATUS = 5; GOSUB CONTROL.DISPLAY; RQM
END
END
RETURN; *: *
*
*
ENTITY.DELETE.RECORD: *@*
*
PRINT @(F.Z1,L.E):CLL:EI.U:", are you sure you want to delete the Entity? ":
INPUT FUNCT.SCAN.INP:
IF FUNCT.SCAN.INP EQ "Y" THEN
REC.STATUS = 5; GOSUB CONTROL.DISPLAY; RQM
EI.REC(EI.ET.AM) = "*DELETED*":VM:EI.REC(EI.ET.AM)
END
RETURN; *: *
*
KEY.INPUT.PRIMARY: *@* SCREEN-KEY INPUT  *@*
*
300  PROG.SUB.NAME = "Input Entity Key"
KEY.ENTITY.INPUT = KEY.ENTITY
KEY.ENTITY.ID = KEY.ENTITY.ID<1,1>
IF EI.RUN.TYPE # 0 THEN
IF ID NE "" & EI.RUN.TYPE >= 2 THEN
LOOP
KEY.STATUS = "C"
PRINT @(F.Z1,L.E):CLL:EI.U:", enter the status of this list item: ":
INPUT KEY.STATUS:
WHILE NOT(INDEX("*H*C*X*I*N*S*","*":KEY.STATUS:"*",1)) DO REPEAT
KEY.LIST<KEY.LIST.CN> = ID:VM:VM:KEY.STATUS:SVM:EI.U:SVM:DATE():SVM:TIME():SVM:WHO:VM
END
IF EI.RUN.TYPE = 3 THEN
LOOP
CONT = 0
KEY.ITEM = KEY.LIST<KEY.LIST.CN+1>
ID = KEY.ITEM<1,1>
IF ID EQ "" THEN
PRINT @(F.Z1,L.M):CLL:BELL:EI.U:", your list has been exhausted. Enter 'Y' to start over... ":; INPUT YES.NO:
IF YES.NO EQ "Y" OR YES.NO EQ "y" THEN
GOSUB ENTITY.LIST.CONTROL
CONT = 1
END
END ELSE
KEY.STATUS = KEY.ITEM<1,3,1>
PRINT @(F.Z4,L.M):CLL:RVB:((KEY.LIST.CN+10001) "R#4":" ":KEY.STATUS:"    ":OCONV(TIME(),"MTS")) "L#18":RVE:
*IF KEY.STATUS EQ "" OR KEY.STATUS EQ "N" OR KEY.STATUS EQ "S" THEN KEY.STATUS = "I"
IF KEY.STATUS NE "X" AND KEY.STATUS NE "C" AND KEY.STATUS NE "H" THEN KEY.STATUS = "I"
IF LIST.NEW.LO NE "" THEN
IF ID[1,LEN(LIST.NEW.LO)] LT LIST.NEW.LO THEN CONT = 1
IF ID[1,LEN(LIST.NEW.HI)] GT LIST.NEW.HI THEN CONT = 1
*#*END ELSE
END
IF KEY.STATUS NE LIST.PROC.STAT AND ID NE "" AND LIST.PROC.STAT NE "*" THEN CONT = 1
*#*END
END
WHILE CONT = 1 DO
KEY.LIST.CN = KEY.LIST.CN + 1
REPEAT
IF ID EQ "" THEN EI.RUN.TYPE = 0
END ELSE IF EI.RUN.TYPE = 2 THEN
READNEXT ID FROM ENTY.LIST ELSE
EI.RUN.TYPE = 0
GOTO 300
END
KEY.ITEM=ID:VM:VM:"N"
KEY.STATUS="N"
END
KEY.LIST.CN = KEY.LIST.CN + 1
KEY.ENTITY = ID
KEY.ENTITY.INPUT = ID
END 
CN1 = 1
CONT1 = 1
LOOP
CN1 = CN1 + 1
CN2 = CN1
LOOP WHILE TB.L(K.C.L)<1,CN2> = "" & CN2 - CN1 < 3 DO
CN2 = CN2 + 1
REPEAT
IF CN2 - CN1 >= 3 THEN CONT1 = 0 ELSE CN1 = CN2
WHILE CONT1 & KEY.ENTITY.INPUT # "END" DO
IF EI.RUN.TYPE # 0 THEN
K.EXTRACT  = "G":(CN1-2):"@1"
KEY.ENTITY.INPUT = OCONV(KEY.ENTITY,K.EXTRACT)
END ELSE
KEY.ENTITY.INPUT = KEY.ENTITY.ID<1,CN1-1>
K.CP = TB.L(K.C.L)<1,CN1,1>
K.LP = TB.L(K.C.L)<1,CN1,2>
PRINT @((K.CP+LEN(KEY.ENTITY.INPUT)),K.LP):SPACE(52-LEN(KEY.ENTITY.INPUT)):
INPUT @(K.CP,K.LP):KEY.ENTITY.INPUT
END
IF KEY.ENTITY.INPUT # "END" & LEN(KEY.ENTITY.INPUT) # 0 THEN
KEY.ENTITY.ID<1,CN1-1> = KEY.ENTITY.INPUT
END
REPEAT
IF KEY.ENTITY.INPUT # "END" THEN
KEY.CN1 = CN1 - 2
KEY.CN2 = 0
IF EI.SK.FL = 1 THEN
GOSUB KEY.INPUT.SECONDARY
IF ENTITY.INPUT.VALUE = "END" THEN KEY.ENTITY.INPUT = ENTITY.INPUT.VALUE
END
END
IF KEY.ENTITY.INPUT = "END" THEN
PRINT @(F.Z4,L.M):SPACE(20):BELL:"END requested."
RETURN
END
GOSUB KEY.DISPLAY
IF LEN(KEY.ENTITY) = 0 ! KEY.ENTITY = "@" ! KEY.ENTITY = "@@" THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:" you can not have an empty ENTITY KEY":; RQM
GOTO 300
END
RETURN; *: *
*
KEY.INPUT.SECONDARY: *#*
*
CN1 = KEY.CN1
IF EI.SK.FL = 1 THEN
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE IA.C(4,CN2)<1,1> = "K" DO
IF EI.RUN.TYPE # 0 THEN
K.EXTRACT = "G":(CN2+CN1):"@1"
ENTITY.INPUT.VALUE = OCONV(KEY.ENTITY,K.EXTRACT)
END ELSE
L.W = CN2
FTB.DONE = "INPUT.KEY"; F.T = "@"
GOSUB INPUT.FLD
END
IF ENTITY.INPUT.VALUE = "END" THEN RETURN
KEY.ENTITY.ID<1,CN2+CN1> = ENTITY.INPUT.VALUE
REPEAT
KEY.CN2 = CN2 - 1
END
RETURN; *: *
*
KEY.DISPLAY: *#*
*
CN1 = 0; CN2 = 0
KEY.ENTITY = ""; KEYCHAR = ""
LOOP
IF CN1 < KEY.CN1 THEN CN1 = CN1 + 1 ELSE CN2 = CN2 + 1
WHILE CN1 < KEY.CN1 ! CN2 < KEY.CN2 + 1 DO
IF CN1 = 2 ! CN2 # 0 THEN KEYCHAR = "@"
KEY.ENTITY = KEY.ENTITY:KEYCHAR:KEY.ENTITY.ID<1,CN1+CN2>
IF CN2 = 0 THEN
K.CP = TB.L(K.C.L)<1,CN1+1,1>
K.LP = TB.L(K.C.L)<1,CN1+1,2>
K.LE = TB.L(K.C.L)<1,CN1+1,3>
END ELSE
K.CP = IA.C(2,CN2)
K.LP = IA.C(1,CN2) + L.A
K.LE = LEN(KEY.ENTITY.ID<1,CN1+CN2>)+5
END
PRINT @(K.CP,K.LP):KEY.ENTITY.ID<1,CN1+CN2>:SPACE(K.LE - LEN(KEY.ENTITY.ID<1,CN1+CN2>)):
REPEAT
RETURN; *: *
*
ENTITY.READ: *@* ENTITY FILE RECORD READ SUBROUTINE
*
PROG.SUB.NAME = "Read an Entity Record"
SD.PAGE<1,1> = "N"
*SD.PAGE<1,2> = 0
YES.NO = "N"; REC.STATUS = 2
KEY.PRE = ""; KEY.SUF = ""
IF EI.U.P.S = 3 THEN KEY.PRE = EI.U:"@":KEY.PRE
IF EI.IA.P.S = 4 THEN KEY.SUF = KEY.SUF:"@":TB.L(K.C.L)<1,1,1>[5,20]
IF EI.U.P.S = 4 THEN KEY.SUF = KEY.SUF:"@":EI.U
IF EI.IA.P.S = 3 THEN KEY.PRE = TB.L(K.C.L)<1,1,1>[5,20]:"@":KEY.PRE
MATREAD EI.REC FROM ENTY,KEY.PRE:KEY.ENTITY:KEY.SUF THEN
IF EI.KL.AM # 0 THEN
IF F.T = "I" THEN
EI.REC(EI.KL.AM) = K.C.L
END ELSE
IF K.C.L = 0 THEN K.C.L = KEY.DF.L
IF LEN(EI.REC(EI.KL.AM)) = 0 THEN EI.REC(EI.KL.AM) = K.C.L
IF EI.REC(EI.KL.AM) = 0 THEN EI.REC(EI.KL.AM) = K.C.L
K.C.L = EI.REC(EI.KL.AM)
END
END
IF EI.MV.AM # 0 THEN
C.R = EI.REC(EI.MV.AM)<1,K.C.L>
END ELSE C.R = 1
END ELSE
REC.STATUS = 1; GOSUB CONTROL.DISPLAY; MAT EI.REC = ""
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", the record for ":KEY.ENTITY:" does not exist.":
PRINT @(F.Z4,L.E):CLL:"Add this record?":
INPUT @(F.Z4+17,L.E):YES.NO
IF YES.NO # "NO" & YES.NO # "YES" & YES.NO # "Y" THEN YES.NO = "N"
IF YES.NO = "YES" ! YES.NO = "Y" THEN
FTB.DONE = "ADD.RECORD"; F.T = "@"
NUMB.REC = 0
END ELSE
REC.STATUS = 7
END
END
GOSUB CONTROL.DISPLAY
RETURN; *: *
*
REC.COUNTER: *@*
*
PROG.SUB.NAME = "Count Number of Records in Level"
*IF K.D.L = 0 THEN RETURN
IF EI.MV.AM = 0 THEN NUMB.REC = 1; C.R = 1 ELSE
IF REC.STATUS < 7 THEN
NUMB.CN1 = 0
NUMB.REC = 0
N.C.ATTR = IA.C(3,2)
IF N.C.ATTR = 0 THEN N.C.ATTR = 1
*  N.C.ATTR IS THE FILE ATTRIBUTE THAT IT"S FIRST MULTI-VALUE THAT HAS A NULL VALUE DETERMINES THERE ARE MULTI-VALUE - 1 RECORDS.
LOOP NUMB.CN1 = NUMB.CN1+1 UNTIL LEN(EI.REC(N.C.ATTR)<1,NUMB.CN1>) = 0 DO REPEAT
NUMB.REC = NUMB.CN1 - 1
END ELSE NUMB.REC = 1
END
RETURN; *: *
*
INPUT.CONTROL: *@*
*
PROG.SUB.NAME = "Entity Data Input Area"
L.W = 0; SUB.L.W = 0; SUB.FUNCT = ""
*SPEC.CONT = 1
T.of.ic: *#*
*PRINT 'DELETE T.of.ic'
*INPUT TEMP
*IF TEMP EQ "END" THEN STOP
*
IF FTB.DONE = "NEXT.IA" THEN
IF K.C.L > 0 THEN
PRINT @(F.Z1,L.E):CLL:"Do you want to add the next Info. Level? ":
INPUT A$:
IF NOT(INDEX("*Y*YES*Yes*yes*y*OK*","*":A$:"*",1)) THEN RETURN
END
K.C.L = K.C.L+1
IF K.R(K.C.L) = 0 & K.C.L < K.H.L THEN GOTO T.of.ic
FTB.DONE = "NEXT.MV"
IF K.C.L<K.H.L + 1 AND K.R(K.C.L) = 1 THEN
GOSUB IA.LOAD.CONTROL
END ELSE
PRINT @(F.Z1,L.M):CLL:RVB:"Sorry ":EI.U:", I am unable to access than KEY LEVEL.":RVE:;RQM
PRINT @(F.Z1,L.M):CLL:RVB:"ERROR AT ":PROG.SUB.NAME:RVE:;RQM
PRINT @(F.Z1,L.M):CLL:"Normal error when creating information.":;RQM
K.C.L = KEY.P.L
RETURN; *: *
END
END
IF FTB.DONE = "NEXT.MV" THEN
IF F.T EQ "D" AND FUNCT.SCAN THEN
IF C.R>NUMB.REC THEN RETURN
L.W = MAXM.FLD
END ELSE
IF F.T NE "D" THEN
IF EI.MV.AM # 0 THEN
NUMB.REC = NUMB.REC + 1
L.W = 1
END ELSE
NUMB.REC = 1
L.W = 0
END
C.R = NUMB.REC
FTB.DONE = "ADD.INFO"; F.T = "A"
END
END
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
GOSUB FOREGROUND.DISPLAY
PROG.SUB.NAME = "Entity Data Input Area"
END ELSE IF F.T EQ "D" AND NOT(LEN(LINE.ALPHA)) THEN
FTB.DONE = "DELETE.INFO"; F.T = "D"
*PRINT '(DELETE) ENTITY.DELETE.INFO'
*INPUT TEMP
*IF TEMP EQ 'END' THEN STOP
L.W = 1
*FUNCT.SCAN = ""
END
* IF FTB.DONE EQ "ADD.INFO" OR (F.T EQ "D" AND (FUNCT.SCAN OR LEN(LINE.ALPHA))) THEN
IF F.T EQ "A" OR (F.T EQ "D" AND FUNCT.SCAN) OR LEN(LINE.ALPHA) THEN
* * IA.C(4,L.W)<1,1,1> is Row/Column/Normal
* * IA.C(4,L.W)<1,1,2> is the L.W to jump to
* * IA.C(4,L.W)<1,1,6> is the controling L.W
L.W = L.W + 1
IF L.W>MAXM.FLD THEN
* IF F.T EQ "D" THEN
IF F.T EQ "D" THEN
IF NOT(LEN(LINE.ALPHA)) THEN
IF FUNCT.SCAN THEN
GOSUB  ENTITY.DELETE.AREA
END
IF FUNCT.SCAN.INP = "Q" THEN
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
RETURN; *: *
END
IF FUNCT.SCAN.INP = "N" & EI.MV.AM # 0 THEN
C.R = C.R + 1
EI.REC(EI.MV.AM)<1,K.C.L> = C.R
END
END ELSE LINE.ALPHA = ""
GOTO T.of.ic
END
FTB.DONE = "NEXT.MV.MOD"
END ELSE
* TEMP = ""
* IF FTB.DONE EQ "ADD.INFO" THEN
IF F.T EQ "A" THEN
IF LEN(EI.CR.AM) GT 1 AND NOT(INDEX(EI.CR.AM,"-":L.W:"-",1)) THEN
PRINT @(F.Z1,L.E):CLL:"   ":L.W:" not for input on add.":
IF NOT(SYSTEM(11)) THEN RQM
PRINT @(F.Z1,L.E):CLL:
* TEMP = 1
IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
IF IA.C(4,L.W)<1,1,2> EQ IA.C(4,L.W)<1,1,6> THEN
L.W = IA.C(4,L.W)<1,1,6> - 1; LINE.ALPHA = ""
GOTO T.of.ic
END
END
*
END
END
* IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
* IF IA.C(4,L.W)<1,1,2> EQ IA.C(4,L.W)<1,1,6> THEN
* IF F.T EQ "A" THEN L.W = IA.C(4,L.W)<1,1,6> - 1; TEMP = 1
* IF F.T NE "D" THEN LINE.ALPHA = ""
* END
* END
* IF TEMP THEN GOTO T.of.ic
END
****************************************INSERT SPECIAL PROCESSING
END
IF FTB.DONE # "ADD.INFO" THEN
IF F.T EQ "D" AND FUNCT.SCAN THEN
LINE.ALPHA = 1
END ELSE
IF LEN(LINE.ALPHA) = 0 THEN
LINE.ALPHA = ""
PRINT @(F.Z1,L.E):CLL:@(F.Z4,L.E):CLL:"Which line?":
INPUT @(F.Z4+12,L.E):LINE.ALPHA
END
END
IF LINE.ALPHA = "" THEN LINE.ALPHA = 0
IF LINE.ALPHA = "END" ! LINE.ALPHA = "CAN" THEN
F.T = "END"
IF LINE.ALPHA = "CAN" THEN F.T = "CAN"; REC.STATUS = 7
LINE.ALPHA = 0
RETURN; *: *
END ELSE
SUB.L.W = 0
IF LINE.ALPHA[1,1] NE "-" AND NOT(NUM(LINE.ALPHA[1,1])) THEN
SUB.FUNCT = LINE.ALPHA [1,1]
IF NOT(INDEX("*A*M*D*N*B*","*":SUB.FUNCT:"*",1)) THEN SUB.FUNCT = ""; LINE.ALPHA = ""; GOTO T.of.ic
LINE.ALPHA = LINE.ALPHA[2,99]
END ELSE SUB.FUNCT = F.T
IF FIELD(LINE.ALPHA,"-",2) # "" THEN
SUB.L.W = FIELD(LINE.ALPHA,"-",2)
IF NOT(NUM(SUB.L.W)) THEN SUB.L.W = 0
END
TEMP = FIELD(LINE.ALPHA,"-",1)
IF LEN(TEMP) THEN
L.W = FIELD(LINE.ALPHA,"-",1)
IF NOT(NUM(L.W)) THEN LINE.ALPHA = ""; GOTO T.of.ic
LINE.ALPHA = LINE.ALPHA[COL2(),99]
IF L.W THEN
TEMP = IA.C(4,L.W)<1,1,6>
IF F.T EQ "D" AND TEMP NE L.W THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", you must do a line delete on the controlling field (":TEMP:").":; RQM
LINE.ALPHA = ""; GOTO T.of.ic
END
END
END
* IF NOT(NUM(L.W)) THEN LINE.ALPHA = ""; GOTO T.of.ic
*IF SUB.FUNCT = "N" THEN SD.PAGE<1,1> = "Y"
SD.PAGE<1,1> = "Y"
IF L.W = 0 THEN
IF FTB.DONE = "NEXT.MV.MOD" THEN
FTB.DONE = "NEXT.MV"
IF EI.MV.AM = 0 THEN FTB.DONE = "NEXT.IA"
GOTO T.of.ic
END
RETURN; *: *
END
IF L.W>20 ! L.W<1 THEN LINE.ALPHA = ""; GOTO T.of.ic
IF IA.C(3,L.W) = "" ! IA.C(3,L.W) = 0 THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", that is an unaccessable field!":; RQM
LINE.ALPHA = ""; GOTO T.of.ic
END
END
END
GOSUB INPUT.FLD
IF F.T EQ "D" AND ((NOT(FUNCT.SCAN) OR FUNCT.SCAN.INP EQ "Q") AND NOT(LEN(LINE.ALPHA))) THEN RETURN
IF (F.T EQ "D" AND NOT(LEN(LINE.ALPHA))) OR (CTC.ERR EQ 9 AND F.T EQ "A") THEN
LINE.ALPHA = ""
IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
IF L.W NE IA.C(4,L.W)<1,1,2> THEN L.W = IA.C(4,L.W)<1,1,2> - 1
END
END ELSE
IF INDEX("*C*R*","*":IA.C(4,L.W)<1,1,1>:"*",1) THEN
IF IA.C(4,L.W)<1,1,2> EQ IA.C(4,L.W)<1,1,6> THEN
IF L.W NE IA.C(4,L.W)<1,1,2> THEN L.W = IA.C(4,L.W)<1,1,2> - 1
LINE.ALPHA = ""
END
END ELSE LINE.ALPHA = ""
END
IF F.T EQ "D" AND NOT(LEN(LINE.ALPHA)) THEN RETURN
IF F.T EQ "D" THEN GOTO T.of.ic
IF F.T EQ "M" THEN GOTO T.of.ic
LINE.ALPHA = ""; GOTO T.of.ic
*
INPUT.FLD: *#*
*
GOSUB IA.FIELD.CONTROL
****************************************INSERT DOC.
1790 ENTITY.INPUT.VALUE = ""
IF L.W = 1 & EI.MV.AM # 0 THEN
INPUT @(C.P,L.P+L.A):ENTITY.INPUT.VALUE
IF NOT(NUM(ENTITY.INPUT.VALUE)) ! LEN(ENTITY.INPUT.VALUE) = 0 THEN
ENTITY.INPUT.VALUE = 1
END
*
*
IF ENTITY.INPUT.VALUE > NUMB.REC ! ENTITY.INPUT.VALUE < 1 THEN
IF ENTITY.INPUT.VALUE > NUMB.REC & NUMB.REC # 0 THEN
F.T = "A"
END ELSE
IF NUMB.REC = 0 THEN
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", the info. area ":TB.L(K.C.L)<1,1,1>:" must be (A)dded."; RQM
END ELSE
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", that is not a valid ":TB.L(K.C.L)<1,1,1>:" number!":; RQM
END
FTB.DONE = "MODIFY.INFO"
RETURN; *: *
END
END
*
*
IF ENTITY.INPUT.VALUE > NUMB.REC & F.T = "A" THEN
FTB.DONE = "NEXT.MV"
ENTITY.INPUT.VALUE = NUMB.REC + 1
GOSUB CONTROL.DISPLAY
RETURN; *: *
END
*
*
C.R = ENTITY.INPUT.VALUE
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
IA.C.RESET = 1
GOSUB FOREGROUND.DISPLAY
PROG.SUB.NAME = "Entity Data Input Area"
END ELSE
IF L.W NE 0 AND NOT(F.T EQ "D" AND NOT(LEN(LINE.ALPHA))) THEN
****************** INSERT SPECIAL PROCESSING
IF IA.C(4,L.W)<1,1,1> = "R" ! IA.C(4,L.W)<1,1,1> = "C" THEN
IF NOT(LEN(SUB.FUNCT)) THEN SUB.FUNCT = F.T
FTYPE = SUB.FUNCT
IF SUB.FUNCT EQ "D" THEN F.T = "D"
IF LEN(SUB.L.W) = 0 THEN SUB.L.W = 0
GOSUB SPEC.DISP.CALL
* IF L.W EQ IA.C(4,L.W)<1,1,6> THEN
* IA.C(5,L.W)<1,1,6> = CNTR<1,1,6>
* IA.C(5,L.W)<1,1,7> = CNTR<1,1,7>
* IF (F.T EQ "D" AND NOT(LEN(LINE.ALPHA))) OR (CTC.ERR EQ 9 AND F.T EQ "A") THEN
* L.W = IA.C(4,L.W)<1,1,2> - 1
* LINE.ALPHA = ""
* END
* END
END ELSE
INPUT @(C.P,L.P+L.A):ENTITY.INPUT.VALUE
IF FTB.DONE = "INPUT.KEY" THEN RETURN
IF LEN(ENTITY.INPUT.VALUE) # 0 THEN
IF EI.MV.AM = 0 THEN
EI.REC(CT.ATT)<1,FILE.MV,CT.SVL> = ENTITY.INPUT.VALUE
END ELSE
EI.REC(CT.ATT)<1,C.R,CT.SVL> = ENTITY.INPUT.VALUE
END
END
IF REC.STATUS = 2 THEN REC.STATUS = 3; GOSUB CONTROL.DISPLAY
END
IF L.W = 2 & FTB.DONE = "ADD.INFO" & EI.MV.AM # 0 THEN 
IF ENTITY.INPUT.VALUE = "" THEN
IF FTB.DONE = "ADD.INFO" & REC.STATUS = 1 THEN
FTB.DONE = "NEXT.IA"
END ELSE
FTB.DONE = "MODIFY.INFO"
END
NUMB.REC = NUMB.REC-1
C.R = NUMB.REC
IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
GOSUB FOREGROUND.DISPLAY
PROG.SUB.NAME = "Entity Data Input Area"
END
END
!
*  INSERT SPECIAL PROCESSING
*
*IF TEMP.C = 1 ! TEMP.C = 0 AND ENTITY.INPUT.VALUE = "END" THEN
**?
*END
!
END
END
IF F.T = "D" AND NOT(LEN(LINE.ALPHA)) THEN
IF EI.MV.AM # 0 THEN
GOSUB ENTITY.DELETE.AREA
IF FUNCT.SCAN.INP = "Q" THEN RETURN
FTB.DONE = "NEXT.MV"
END ELSE
GOSUB ENTITY.DELETE.RECORD
END
END
RETURN; *: *
*
ERROR.ON.DISPLAY: *@*
*
PRINT @(F.Z1,L.M):CLL:BELL:"Sorry ":EI.U:", I am unable to display that KEY LEVEL.":
RETURN; *: *
*
ACTION.SELECT: *@* INPUT FUNCTION SUBROUTINE
*
2100 PROG.SUB.NAME = "Input function"
*PRINT @(F.Z1,L.M):CLL:
PRINT @(F.Z1,L.E):CLL:"ACTION (":
CN1 = 1
LOOP CN1 = CN1+1 WHILE TB.F.DESC(CN1) # "" DO
IF CN1 > 2 THEN PRINT ", ":
PRINT TB.F.DESC(CN1)[2,1]:
REPEAT
PRINT " or <CR> = U): ":
F.T = "U"
L.W = 0; SUB.L.W = 0; SUB.FUNCT = ""
INPUT F.T:
IF LEN(F.T) = 0 THEN F.T = "U"
IF F.T = "END" ! F.T = "CAN" THEN RETURN
LINE.ALPHA = F.T[2,10]
F.T = F.T[1,1]
CN1 = 1; CN2 = ""
LOOP CN1 = CN1+1 WHILE TB.F.DESC(CN1) # "" & NOT(CN2) DO
IF INDEX(TB.F.DESC(CN1),"(":F.T:")",1) THEN CN2 = CN1
REPEAT
IF NOT(CN2) THEN
FUNCT.NUMBER = 8
PRINT @(F.Z1,L.M):CLL:BELL:RVB:"Sorry ":EI.U:", you have enterid an invalid function":RVE:; RQM
GOSUB CONTROL.DISPLAY
GOTO 2100
END ELSE
FUNCT.NUMBER = CN2
*PRINT @(F.Z1,L.E):CLL:
GOSUB CONTROL.DISPLAY
PROG.SUB.NAME = "Input function"
END
IF (F.T = "D" AND LINE.ALPHA NE "") OR F.T = "L" THEN
*IF F.T = "D" THEN
*PRINT "Delete the entire item? ":
*INPUT ANS
*IF ANS EQ "Y" THEN
*GOSUB ENTITY.DELETE.RECORD
*REC.STATUS = 7
*RETURN
*END
*END ELSE IF EI.MV.AM NE 0 THEN F.T = ""
IF EI.MV.AM NE 0 THEN
PRINT @(F.Z1,L.E):CLL:"(C) Choose or <CR> = (S) Scan :":
FUNCT.SCAN.INP = ""
INPUT @(F.Z3,L.E):FUNCT.SCAN.INP
IF FUNCT.SCAN.INP = "" THEN FUNCT.SCAN.INP = "S"
IF FUNCT.SCAN.INP = "S" THEN FUNCT.SCAN = 1 ELSE
IF FUNCT.SCAN.INP = "C" THEN FUNCT.SCAN = "" ELSE
GOTO 2100
END
END
END
END
RETURN; *: *
*
*@* LIST ENTITY ON SCREEN SUBROUTINE
*
SCREEN.LISTING.AREA: *@*
PROG.SUB.NAME = "Screen Entity List"
RETURN; *: *
*
*@* PRINT ENTITY ON PRINTER SUBROUTINE
*
PRINTER.LISTING.AREA: *@*
PROG.SUB.NAME = "Printer Entity List"
RETURN; *: *
*
IA.LOAD.CONTROL: *@*
*
IF K.R(K.C.L) = 0 THEN K.C.L = KEY.DF.L
F.ERR = ""
IF KEY.P.L # K.C.L ! F.TIME THEN
CN1 = ""
LOOP WHILE NOT(CN1) ! (F.ERR & CN1 & K.C.L # KEY.DF.L) DO
IF F.ERR THEN K.C.L = KEY.DF.L
CALL S.I.T.INFO.EI 
CN1 = 1
REPEAT
EI.FI.VL = TB.L(K.C.L)<1,1,3>
EI.SK.FL = TB.L(K.C.L)<1,1,4>
EI.MV.AM = TB.L(K.C.L)<1,1,5>
MAXM.FLD = TB.L(K.C.L)<1,1,6>
L.A = TB.L(K.C.L)<1,1,7>
EI.KL.AM = TB.L(K.C.L)<1,1,8>
EI.ET.AM = TB.L(K.C.L)<1,1,9>
EI.CDT.AM = TB.L(K.C.L)<1,1,10>
EI.ADT.AM = TB.L(K.C.L)<1,1,11>
EI.PDT.AM = TB.L(K.C.L)<1,1,12>
EI.CR.AM = TB.L(K.C.L)<1,1,13>
*
GOSUB BACKGROUND.DISPLAY
*
*
$INCLUDE IBP SUB.IO.OPEN.EI.ENTY
*
IF NOT(F.TIME) THEN
IF TB.L(KEY.P.L)<1,1,4> = 1 THEN
CN1 = 0
KEY.CN2 = 0
KEY.ENTITY.ID = ""
LOOP CN1 = CN1 + 1 WHILE CN1 < KEY.CN1 + 1 DO
KEY.ENTITY.ID<1,CN1> = FIELD(KEY.ENTITY,"@",CN1)
REPEAT
END
*
IF EI.SK.FL = 1 THEN GOSUB KEY.INPUT.SECONDARY
GOSUB KEY.DISPLAY
IF TB.FL THEN GOSUB ENTITY.READ
END
KEY.P.L = K.C.L
END
*
IF EI.MV.AM # 0 THEN
IF LEN(EI.REC(EI.MV.AM)<1,K.C.L>) = 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
IF EI.REC(EI.MV.AM)<1,K.C.L> = 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
END
K.D.L = K.C.L
GOSUB REC.COUNTER
IF EI.MV.AM # 0 THEN C.R = EI.REC(EI.MV.AM)<1,K.C.L> ELSE C.R = 1
IF EI.KL.AM # 0 THEN EI.REC(EI.KL.AM) = K.C.L
*IF EI.MV.AM # 0 THEN EI.REC(EI.MV.AM)<1,K.C.L> = C.R
IA.C.RESET = 1
F.TIME = 0
RETURN; *: *
*
IA.FIELD.CONTROL: *#*
*
IF L.W # 0 THEN
C.P = IA.C(2,L.W)
L.P = IA.C(1,L.W)
SPEC = IA.C(4,L.W)
CNTR = IA.C(5,L.W)
IF SPEC<1,1,6> THEN
CNTR<1,1,6> = IA.C(5,SPEC<1,1,6>)<1,1,6>
CNTR<1,1,7> = IA.C(5,SPEC<1,1,6>)<1,1,7>
END
IF FTYPE EQ "d" THEN CNTR<1,1,3> = CNTR<1,1,1>
CT.ATT = IA.C(3,L.W)<1,1>
FILE.MV = IA.C(3,L.W)<1,2>
CT.SVL = IA.C(3,L.W)<1,3>
CT.4VL = IA.C(3,L.W)<1,4>
CT.5VL = IA.C(3,L.W)<1,5>
IF LEN(FILE.MV) = 0 THEN FILE.MV = 0
IF LEN(CT.SVL) = 0 THEN CT.SVL = 0
IF LEN(CT.4VL) = 0 THEN CT.4VL = 0
IF LEN(CT.5VL) = 0 THEN CT.5VL = 0
*IF SPEC<1,1,5> = "4V" OR SPEC<1,1,5> = "5V" THEN
*IF CT.ATT = 0 THEN CT.ATT = 1
*IF FILE.MV = 0 THEN FILE.MV = 1
*IF CT.SVL = 0 THEN CT.SVL = 1
*END
IF SPEC<1,1,1> = "K" & FTB.DONE # "INPUT.KEY" THEN RETURN
****************************************INSERT SPECIAL PROCESSING
END
RETURN; *: *
ENTITY.LIST.CONTROL: *#*
*
*#*
LIST.NEW.LO = ""
LIST.NEW.HI = ""
LIST.PROC.STAT = "I"
IF EI.RUN.TYPE > 2 THEN
PRINT @(F.Z1,L.M):CLL:"Enter starting ID string: ":; INPUT LIST.NEW.LO:
IF LIST.NEW.LO NE "" THEN
PRINT @(F.Z1,L.M):CLL:"Enter ending ID string: ":; INPUT LIST.NEW.HI:
IF LIST.NEW.HI EQ "" THEN LIST.NEW.HI = LIST.NEW.LO
END
LOOP
PRINT @(F.Z1,L.M):CLL:"What status will be processed? ":; INPUT LIST.PROC.STAT:
WHILE NOT(INDEX("*X*C*H*I*N*S**","*":LIST.PROC.STAT:"*",1)) DO REPEAT
IF LIST.PROC.STAT EQ "" THEN LIST.PROC.STAT = "*" ELSE
IF INDEX("*I*N*S**","*":LIST.PROC.STAT:"*",1) THEN LIST.PROC.STAT = "I"
END
END
KEY.LIST.CN = 0
ID = ""
RETURN; *: *
*
!
ENTITY.CONTROL: *#*
*
CONTR.FLAG = "N"
PRINT @(0,0):CLL:@(F.Z1,L.E):"CONTROL DISPLAY ON? ":;INPUT CONTR.FLAG:
IF LEN(CONTR.FLAG) = 0 THEN CONTR.FLAG = "N"
IF INDEX(YES,"*":CONTR.FLAG:"*",1) THEN CONTR.FLAG = 1 ELSE CONTR.FLAG = 0
IF NOT(KEYS.SL) THEN K.C.L = 0
GOSUB CONTROL.DISPLAY
GOSUB BACKGROUND.DISPLAY
*
FTYPE = ""
CALL SUB.KEY.SELECT.EI
IF FTYPE = "END" ! FTYPE = "CAN" THEN F.T = F.T; RETURN
GOSUB IA.LOAD.CONTROL
GOSUB CONTROL.DISPLAY
RETURN; *: *
*
CONTROL.DISPLAY: *@*
PRINT @(F.Z1,L.F):CLL:RVB:
IF CONTR.FLAG = "N" THEN RETURN
CN1 = K.C.L
IF LEN(CN1) = 0 ! CN1 = 0 THEN CN1 = 1
*PRINT @(F.Z1,L.F):TB.L(CN1)<1,1,1>[5,18]:
PRINT TB.L(CN1)<1,1,1> "L#20":
*PRINT @(F.Z2,L.F):TB.FTYPE(FUNCT.NUMBER)[1,18]:
PRINT TB.FTYPE(FUNCT.NUMBER) "L#20":
IF TB.L(CN1)<1,1,3> # "" THEN
*PRINT @(F.Z3,L.F):TB.L(CN1)<1,1,3>[1,18]:
PRINT TB.L(CN1)<1,1,3> "L#20":
END ELSE
*PRINT @(F.Z3,L.F):EI.P.F[1,18]:
PRINT EI.P.F "L#20":
END
*PRINT @(F.Z4,L.F):TB.STAT(REC.STATUS)[1,18]:RVE:
PRINT TB.STAT(REC.STATUS) "L#18":RVE:
RETURN
*
FOREGROUND.DISPLAY: *@*
*
IF K.R(K.C.L) = 1 THEN
K.D.L = K.C.L
C.D.R = C.R
IF C.D.R = 0 THEN C.D.R = 1
IF F.T # "A" THEN
FG.C.CALL = "SUB.SCREEN.CLEAR.":TB.L(K.C.L)<1,1,1>[5,30]
CALL @FG.C.CALL 
END
IF NUMB.REC = 0 THEN
GOSUB REC.COUNTER
END
GOSUB KEY.DISPLAY
IF NUMB.REC # 0 THEN
FG.D.CALL = "SUB.SCREEN.DISPL.":TB.L(K.C.L)<1,1,1>[5,30]
CALL @FG.D.CALL
SAVE.L.W = L.W
L.W = 0
LOOP L.W = L.W + 1 WHILE L.W < MAXM.FLD + 1 DO
IF IA.C(4,L.W)<1,1,1> = "R" ! IA.C(4,L.W)<1,1,1> = "C" THEN
SD.PAGE<1,1> = "N"
*SD.PAGE<1,2> = 0
IF IA.C.RESET = 1 THEN IA.C(5,L.W)<1,1,1> = 0
FTYPE = "d"
IF LEN(IA.C(5,L.W)<1,1,3>) = 0 THEN IA.C(5,L.W)<1,1,3> = 0
GOSUB IA.FIELD.CONTROL
GOSUB SPEC.DISP.CALL
END
REPEAT
L.W = SAVE.L.W
IA.C.RESET = 0
END
END
GOSUB CONTROL.DISPLAY
RETURN; *: *
*
*
BACKGROUND.DISPLAY: *@* DISPLAY BACKGROUND *@*
*
SP.NUM = 40 - (LEN(PROG.NAME)/2)
PRINT @(0,1):RVB:CLS:SPACE(SP.NUM):PROG.NAME:SPACE(SP.NUM-20):TIMEDATE()
SP.NUM = 40 - (LEN(EI.A)/2)
PRINT @(0,2):EI.U:SPACE(SP.NUM-LEN(EI.U)):EI.A:SPACE(SP.NUM)
*
IF K.C.L # 0 THEN
BG.D.CALL = "SUB.SCREEN.APPL.BKGRD.":EI.A
CALL @BG.D.CALL 
PRINT RVB:
IF K.R(K.C.L) = 1 THEN
BG.D.CALL = "SUB.SCREEN.BKGRD.":TB.L(K.C.L)<1,1,1>[5,30]
CALL @BG.D.CALL 
END
PRINT RVE:
END
RETURN; *: *
*
SPEC.DISP.CALL: *#*
*
IF SPEC<1,1,1> = "R" ! SPEC<1,1,1> = "C" THEN
CN4 = 0
IF EI.MV.AM # 0 THEN
CT.VAL = C.R
END ELSE
CT.VAL = FILE.MV
END
IF LEN(CNTR<1,1,1>) = 0 THEN CNTR<1,1,1> = 0
IF LEN(CNTR<1,1,2>) = 0 THEN CNTR<1,1,2> = SPEC<1,1,5>
CNTR<1,1,3> = SUB.L.W
CNTR<1,1,4> = SD.PAGE<1,1>
IF LEN(CNTR<1,1,5>) = 0 THEN CNTR<1,1,5> = 0
IF NOT(INDEX("*A*M*D*N*B*","*":FTYPE:"*",1)) THEN FTYPE = "d"
CALL EI.SD
*
IA.C(5,L.W) = CNTR
IA.C(5,L.W)<1,1,3> = 0
IF SD.PAGE<1,1> = "N" THEN CNTR<1,1,4> = IA.C(5,L.W)<1,1,4>
*SD.PAGE<1,2> = CNTR<1,1,5>
*
*Returned last value from SPEC.DISP is in CNTR<1,1>. 
*The requested input or starting value (if applicable) was passed
END
RETURN; *: *
*
END.OF.PROGRAM.AREA: *@* END OF PROGRAM *@*
IF EI.RUN.TYPE = 2 THEN
CONT = 1
KEY.LIST.CN1 = KEY.LIST.CN - KEY.LIST.DEL
LOOP
READNEXT ID FROM ENTY.LIST ELSE CONT = 0
WHILE CONT DO
KEY.LIST = KEY.LIST:AM:ID:VM:"N":VM:DATE():VM:TIME():VM:WHO
KEY.LIST.CN1 = KEY.LIST.CN1 + 1
PRINT @(F.Z4,L.M):CLL:RVB:((KEY.LIST.CN1+10000) "R#4") "L#18":RVE:
REPEAT
END
IF EI.RUN.TYPE = 3 THEN KEY.LIST.CN1 = DCOUNT(KEY.LIST,AM)
IF EI.RUN.TYPE >= 2 THEN
*WRITE KEY.LIST ON KLIST,EI.A.U
PRINT @(F.Z1,L.M):CLL:KEY.LIST.CN1:" items remaining of a total of ":(KEY.LIST.CN1 + KEY.LIST.DEL):" items.":
RQM; RQM; RQM; RQM
YES.NO = ""
PRINT @(F.Z1,L.M):CLL:"Do you want to save the changed list? ":;INPUT YES.NO:
IF NOT(INDEX(NO,"*":YES.NO:"*",1)) THEN
PRINT @(F.Z1,L.M):CLL:"Enter the list name if a new list: ":
NEW.NAME=""
INPUT NEW.NAME:
IF NEW.NAME NE "" THEN EI.A.U=NEW.NAME
WRITE KEY.LIST ON KLIST,EI.A.U
END
END
RETURN; *: *
*
99999   PROMPT "?"
END
~OLD.EI.SD.8902~
XSUBROUTINE EI.SD
*
$INCLUDE IBP EI.COMMON.VARIABLES
*
P.L.N = 1
$INCLUDE IBP STANDARD.FUNCTIONS
*
CALL S.I.T.EI.SPEC.DISP
CTC.ERR = 0
*
P.L.N = 2
*
IF INDEX("*N*B*A*M*D*","*":FTYPE:"*",1) = 0 THEN
F.ERR = 1
CTC.ERR = 5
GOSUB CTC.ERR.DISP
RETURN
END
N.LN.CL = SPEC<1,1,3>
IF SPEC<1,1,1> = "C" THEN
B.LN = N.LN.CL + (L.P + L.A)
B.CL = C.P
END ELSE
* = "R"
B.LN = (L.P + L.A)
B.CL = C.P + (N.LN.CL * SPEC<1,1,4>)
END
C.LN = 0
C.CL = 0
*
ENTER.F.D = CNTR<1,1,3>
CTC.DETL = "PRINT.MORE"
CTC.RECD.STAT = "DISP.RECD"
CTC.45FL = 0
F.D = CNTR<1,1,1>
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
CT.PAGE = CNTR<1,1,4>
CTC.INPUT = ""
*
IF ENTER.F.D = 0 THEN
IF FTYPE = "M" THEN
CTC.ERR = 6
GOSUB CTC.ERR.DISP
RETURN
END ELSE
IF INDEX("*A*N*B*","*":FTYPE:"*",1) # 0 THEN ENTER.F.D = 9999 ELSE
* = "D"
GOSUB CTC.DEL
RETURN
END
END
END
IF CNTR<1,1,5> = 0 & F.D # 0 THEN
CTC.RECD.STAT = "LAST.RECD"
IF FTYPE = "N" THEN FTYPE = "B"
END
CALC.WHAT = "CURR"
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
$INCLUDE IBP EI.SD.INCL.CTC.CALC.DET.TOP
IF CNTR<1,1,5> = 1 THEN CTC.DETL = "PAGE.FULL"; CNTR<1,1,5> = 1
IF ENTER.F.D > F.D THEN CTC.INPUT = "N" ELSE
IF ENTER.F.D < SAVE.F.D THEN CTC.INPUT = "B" ELSE
CTC.INPUT = ""
CTC.DETL = "PRINT.MORE"
END
END
IF FTYPE = "N" ! FTYPE = "B" THEN CTC.INPUT = FTYPE; CTC.DETL = "PAGE.FULL"
*
*
*IF F.D = 0 THEN GOSUB CTC.CLEAR
CALC.WHAT = ""
CTC.R.F = ""
CTC.INP.FLD = ""
SAVE.FTYPE = FTYPE
SAVE.F.D = 0
SAVE.C.LN = 0
ENTER.C.LN = 0
LOOP
P.L.N = 3
IF FTYPE = "N" & CTC.RECD.STAT = "LAST.RECD" THEN CTC.DETL = "RETURN.TO.MAIN"
WHILE (CTC.INP.FLD # "END" & CTC.DETL # "RETURN.TO.MAIN") & CTC.ERR = 0 DO
P.L.N = 4
IF CTC.DETL = "PAGE.FULL" THEN
CNTR<1,1,5> = 1
IF CT.PAGE = "N" & F.D # 0 THEN CNTR<1,1,1> = F.D; RETURN
IF INDEX("*A*M*D*","*":FTYPE:"*",1) # 0 THEN
CTC.INPUT = " "
CALC.WHAT = "CURR"
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
$INCLUDE IBP EI.SD.INCL.CTC.CALC.DET.TOP
IF ENTER.F.D > F.D ! ENTER.F.D < SAVE.F.D  ! ENTER.F.D = 9999 THEN 
IF ENTER.F.D # 9999 THEN
PRINT @(F.Z1,L.E):CLL:@(40):"Enter <CR> :"
INPUT @(F.Z4,L.E):CTC.INPUT
END
IF ENTER.F.D < SAVE.F.D & NOT(ENTER.F.D = 9999) THEN CTC.INPUT = "B" ELSE CTC.INPUT = "N"
P.L.N = 4
END
CTC.DETL = "PRINT.MORE"
END ELSE
IF LEN(CTC.INPUT) = 0 THEN
PRINT @(F.Z1,L.E):CLL:"(B)eginning, <CR> = (N)ext page, or E to stop:"
INPUT @(F.Z5,L.E):CTC.INPUT
IF CTC.INPUT = "END" THEN CTC.INPUT = "E"
IF CTC.INPUT = "" THEN CTC.INPUT = "N"
PRINT @(F.Z5,L.E):CTC.INPUT:
END
END
IF CTC.INPUT = "N" ! CTC.INPUT = "B" THEN
IF ENTER.F.D # 9999 THEN GOSUB CTC.CLEAR ELSE ENTER.F.D = 999
P.L.N = 4
IF FTYPE = "" ! FTYPE = "B" THEN FTYPE = "N"
CTC.DETL = "PRINT.MORE"
IF CTC.INPUT = "B" THEN
 F.D = 0
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
END
CNTR<1,1,5> = 0
END ELSE IF CTC.INPUT = "E" THEN
* = "E"
CTC.DETL = "RETURN.TO.MAIN"
CTC.INP.FLD = "END"
END
C.CL = 0
C.LN = 0
END
CTC.INPUT = ""
P.L.N = 5
IF CTC.INP.FLD # "END" & CTC.DETL # "RETURN.TO.MAIN" THEN
GOSUB CTC.DISP.RECD
P.L.N = 5
IF CTC.INP.FLD = "END" & FTYPE = "A" THEN
CTC.DETL = "RETURN.TO.MAIN"
CTC.RECD.STAT = "LAST.RECD"
FTYPE = "N"
END
END
REPEAT
IF CTC.INP.FLD = "END" THEN CTC.ERR = 9
P.L.N = 6
CNTR<1,1,1> = F.D
RETURN
*
INPUT.FLD: *#*
*
P.L.N = 10
PROG.SUB.NAME = "Input the Field"
PRINT @(F.Z1,L.M):CLL:PROG.SUB.NAME:
PRINT @(C.CL - 3,C.LN):RVB:"-":F.D:SPACE(2-LEN(F.D)):SPACE(SPEC<1,1,4>):
CTC.R.F0 = EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>
IF CTC.45FL > 0 THEN
CTC.R.F1 = FIELD(CTC.R.F0,"*",CT.4VL)
CTC.SCOL1 = COL1(); CTC.ECOL1 = COL2()
IF CTC.45FL = 2 THEN
CTC.R.F2 = FIELD(CTC.R.F1,"@",CT.5VL)
CTC.SCOL2 = COL1(); CTC.ECOL2 = COL2()
CTC.R.F = CTC.R.F2
END ELSE
CTC.R.F = CTC.R.F1
END
END ELSE CTC.R.F = CTC.R.F0
CTC.INP.FLD = CTC.R.F
INPUT @(C.CL,C.LN):CTC.INP.FLD
IF LEN(CTC.INP.FLD) # 0 & CTC.INP.FLD # "END" THEN CTC.R.F = CTC.INP.FLD
IF CTC.INP.FLD = "/" THEN CTC.R.F = ""
PRINT RVE:
PRINT @(C.CL - 3,C.LN):RVB:"-":F.D:SPACE(2-LEN(F.D)):RVE:
PRINT @(C.CL,C.LN):CTC.R.F:SPACE(SPEC<1,1,4>-LEN(CTC.R.F)):
IF CTC.INP.FLD # "END" THEN
IF CTC.45FL > 0 THEN
IF CTC.45FL = 2 THEN
IF CTC.R.F1[CTC.SCOL2,1] # "@" & F.D # 1 ! (CTC.SCOL2 = 0 & CTC.ECOL2 = 0) THEN
CTC.R.F = "@":CTC.R.F
IF CTC.SCOL2 = 0 THEN CTC.SCOL2 = LEN(CTC.R.F1); CTC.ECOL2 = CTC.SCOL2 + 1
END
CTC.R.F1 = CTC.R.F1[1,CTC.SCOL2]:CTC.R.F:CTC.R.F1[CTC.ECOL2,99]
END ELSE
CTC.R.F1 = CTC.R.F
END
IF CTC.R.F0[CTC.SCOL1,1] # "*" & F.D # 1 ! (CTC.SCOL1 = 0 & CTC.ECOL1 = 0) THEN
CTC.R.F1 = "*":CTC.R.F1
IF CTC.SCOL1 = 0 THEN CTC.SCOL1 = LEN(CTC.R.F0); CTC.ECOL1 = CTC.SCOL1 + 1
END
CTC.R.F0 = CTC.R.F0[1,CTC.SCOL1]:CTC.R.F1:CTC.R.F0[CTC.ECOL1,99]
END ELSE
CTC.R.F0 = CTC.R.F
END
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = CTC.R.F0
END ELSE
PRINT @(C.CL-3,C.LN):RVB:"   ":RVE:SPACE(SPEC<1,1,4>):
END
RETURN
*
CTC.CLEAR: *#*
*
P.L.N = 11
IF SPEC<1,1,1> = "R" THEN
PRINT @(C.P,(L.P + L.A)):SPACE(N.LN.CL * SPEC<1,1,4>):
END ELSE
* = "C"
COUNTER = (L.P + L.A)
LOOP WHILE COUNTER < B.LN DO
PRINT @(C.P - 3,COUNTER):RVB:"   ":RVE:SPACE(SPEC<1,1,4>):
COUNTER = COUNTER + 1
REPEAT
END
RETURN
!
CTC.NEXT.VALUE: *#*
*
P.L.N = 13
IF F.D>99 THEN F.D = 0
CTC.ERR = 0
CTC.NEXT.CN = 0
*
R.top: *#*
P.L.N = 13
F.D = F.D + 1
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
GOSUB CTC.FIELD.EXTRACT
*
IF CT.FIELD.CK # "" THEN
CTC.REC.STAT = "DISP.RECD"
F.D = F.D - CTC.NEXT.CN
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
GOSUB CTC.FIELD.EXTRACT
IF SAVE.FTYPE = "A" & NOT(ENTER.F.D > F.D) THEN ENTER.F.D = F.D + 1
*
END ELSE
IF FTYPE # "" & FTYPE # "N" & FTYPE # "A" & F.D < ENTER.F.D + 1 THEN
CTC.ERR = 1
GOSUB CTC.ERR.DISP
RETURN
END
*
IF CTC.NEXT.CN > 10 THEN
F.D = F.D - CTC.NEXT.CN
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
GOSUB CTC.FIELD.EXTRACT
CTC.RECD.STAT = "LAST.RECD"
IF SAVE.FTYPE = "A" & F.D # ENTER.F.D THEN ENTER.F.D = F.D
CTC.DETL = "RETURN.TO.MAIN"
CTC.R.F = "END"
*
END ELSE
CTC.NEXT.CN = CTC.NEXT.CN + 1
GOTO R.top
END
END
*
*
RETURN
!
*CTC.CALC.POS: *#*
**
*P.L.N = 16
*IF SPEC<1,1,1> = "C" THEN
*C.CL = C.P
*IF CALC.WHAT = "NEXT" & C.LN # 0 THEN
*IF C.LN < (L.P + L.A) THEN C.LN = (L.P + L.A) - 1
*C.LN = C.LN + 1
*IF NOT(C.LN < B.LN) THEN CTC.DETL = "PAGE.FULL"; CNTR<1,1,5> = 1
*END ELSE
*C.LN = F.D - (INT((F.D - 1) / N.LN.CL) * N.LN.CL) + (L.P + L.A) - 1 
*END
*END ELSE
** = "R"
*C.LN = (L.P + L.A)
*IF CALC.WHAT = "NEXT" THEN
*C.CL = C.CL + SPEC<1,1,4>
*IF C.CL > B.CL THEN PRINT "LINE EXCEEDED"; CTC.DET = "PAGE.FULL"; CNTR<1,1,5> = 1
*END ELSE
*C.CL = F.D - (INT((F.D - 1) / N.LN.CL) * N.LN.CL) + C.P
*C.CL = C.CL * SPEC<1,1,4> + C.P
** SPEC <3> IS THE # OF LINES/COLUMNS
** SPEC <4> IS THE LEGTH OF EACH FIELD
*END
*END
*RETURN
*
*CTC.CALC.DET.TOP: *#*
**
*SAVE.F.D = F.D - (C.LN - (L.P + L.A))
** REMOVE + 1 NO LONGER RELEVANT
*SAVE.C.LN = (L.P + L.A)
*RETURN
*
CTC.DISP.RECD: *#*
*
P.L.N = 14
CTC.ERR = 0
IF INDEX("*A*M*D*","*":FTYPE:"*",1) # 0 THEN
CALC.WHAT = "CURR"
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
$INCLUDE IBP EI.SD.INCL.CTC.CALC.DET.TOP
P.L.N = 14
IF (ENTER.F.D > F.D & CTC.RECD.STAT # "LAST.RECD") OR ENTER.F.D < SAVE.F.D THEN
ENTER.C.LN = 0
FTYPE = "N"
GOSUB CTC.DISP.RECD.LOOP
P.L.N = 14
FTYPE = SAVE.FTYPE
IF CTC.ERR # 0 THEN RETURN
IF CTC.DETL = "PAGE.FULL" & (ENTER.F.D > F.D ! ENTER.F.D < SAVE.F.D) THEN RETURN
END
IF ENTER.F.D > F.D & SAVE.FTYPE # "A" THEN
CTC.ERR = 1
GOSUB CTC.ERR.DISP
RETURN
END
CTC.DETL = "PRINT.MORE"
CTC.R.F = ""
IF FTYPE = "M" OR FTYPE = "D" THEN
F.D = ENTER.F.D
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
CALC.WHAT = "CURR"
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
P.L.N = 14
ENTER.C.LN = C.LN 
IF FTYPE = "M" THEN
GOSUB INPUT.FLD
END ELSE
GOSUB CTC.DEL.DETL
END
P.L.N = 14
END ELSE
IF FTYPE = "A" THEN
P.L.N = 14
*IF C.LN = B.LN - 1 THEN C.LN = 0;* F.D = F.D - 1
IF F.D > 0 & F.D = SAVE.F.D THEN F.D = F.D - 1; C.LN = 0
LOOP WHILE CTC.DETL # "PAGE.FULL" & CTC.INP.FLD # "END" DO
GOSUB CTC.NEXT.VALUE
ENTER.F.D = F.D
CALC.WHAT = "NEXT"
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
P.L.N = 14
IF CTC.DETL # "PAGE.FULL" THEN
IF CTC.ERR # 0 THEN RETURN
GOSUB INPUT.FLD
P.L.N = 14
IF CTC.INP.FLD = "END" THEN
F.D = F.D - 1
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
CALC.WHAT = "CURR"
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
$INCLUDE IBP EI.SD.INCL.CTC.CALC.DET.TOP
P.L.N = 14
CTC.RECD.STAT = "DISP.RECD"
CTC.DETL = "PRINT.MORE"
END
END
*END ELSE F.D = F.D - 1
*$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
*END
REPEAT
IF CTC.DETL = "PAGE.FULL" THEN RETURN
END
END
FTYPE = "N"
F.D = SAVE.F.D - 1
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
P.L.N = 14
C.LN = 0
C.CL = 0
ENTER.F.D = 999
END
GOSUB CTC.DISP.RECD.LOOP
IF CTC.DETL # "PAGE.FULL" THEN
CTC.DETL = "RETURN.TO.MAIN"
CTC.INP.FLD = "END"
END
P.L.N = 14
RETURN
*
CTC.DISP.RECD.LOOP: *#**
*
P.L.N = 15
C.LN = 0
LOOP
GOSUB CTC.NEXT.VALUE
CALC.WHAT = "NEXT"
$INCLUDE IBP EI.SD.INCL.CTC.CALC.POS
P.L.N = 15
IF CTC.ERR # 0 THEN RETURN
GOSUB CTC.FIELD.EXTRACT
WHILE CTC.RECD.STAT = "DISP.RECD" & CTC.DETL # "PAGE.FULL" DO
PRINT @(C.CL - 3,C.LN):RVB:"-":F.D:SPACE(2-LEN(F.D)):RVE:
IF F.D = ENTER.F.D THEN PRINT RVB:
PRINT @(C.CL,C.LN):CT.FIELD.CK[1,SPEC<1,1,4>]:
IF F.D = ENTER.F.D THEN 
PRINT RVE:
ENTER.C.LN = C.LN
END
REPEAT
F.D = F.D - 1
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
P.L.N = 15
IF SPEC<1,1,1> = "C" THEN C.LN = C.LN - 1
RETURN
!
CTC.FIELD.EXTRACT: *#*
CT.FIELD.CK = EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>
IF CTC.45FL # 0 THEN
CT.FIELD.CK = FIELD(CT.FIELD.CK,"*",CT.4VL)
IF CTC.45FL = 2 THEN CT.FIELD.CK = FIELD(CT.FIELD.CK,"@",CT.5VL)
END
RETURN
!
CTC.ERR.DISP: *#*
*
PRINT @(F.Z1,L.M):CLL:BELL:TB.ERRS(CTC.ERR):", enter a <CR>.":
YES.NO = ""
INPUT @(F.Z1,L.E):YES.NO:
PRINT @(F.Z1,L.M):CLL:
RETURN
!
CTC.DEL.ALL: *#*
*
P.L.N = 17
CTC.DEL: PRINT @(F.Z1,L.E):CLL:BELL:"Are you sure you want to DELETE all of them (Y / <CR>=N): ":
YES.NO = "N"
INPUT @(F.Z5,L.E):YES.NO
IF INDEX(NO,"*":YES.NO:"*",1) # 0 THEN FTYPE = " "; RETURN
IF INDEX(YES,"*":YES.NO:"*",1) = 0 THEN GOTO CTC.DEL
IF CNTR<1,1,2> = "AM" THEN MAT EI.REC = "" ELSE
IF CNTR<1,1,2> = "VM" THEN EI.REC(CT.ATT) = "" ELSE
IF CNTR<1,1,2> = "SV" THEN EI.REC(CT.ATT)<1,CT.VAL> = "" ELSE
IF CNTR<1,1,2> = "4V" THEN EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = "" ELSE
IF CNTR<1,1,2> = "5V" THEN
CT.FIELD.CK = FIELD(EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>,"*",CT.4VL)
CTC.SCOL1 = COL1(); CTC.ECOL1 = COL2()
CT.FIELD.CK = CT.FIELD.CK[1,CTC.SCOL1]:CT.FIELD.CK[(CTC.ECOL1),99]
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = CT.FIELD.CK
END ELSE
NULL
END
END
END
END
END
F.D = 0
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
GOSUB CTC.CLEAR
RETURN
!
CTC.DEL.DETL: *#*
*
P.L.N = 18
PRINT @(F.Z1,L.E):BELL:CLL:"DELETE THIS TEXT LINE (Y / <CR>=N): ":
YES.NO = "N"
INPUT @(F.Z3,L.E):YES.NO
IF LEN(YES.NO) = 0 THEN YES.NO = "N"
IF INDEX(YES,"*":YES.NO:"*",1) # 0 THEN
IF CNTR<1,1,2> = "AM" THEN
COUNTER = CT.ATT - 1
LOOP
COUNTER = COUNTER + 1
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = EI.REC(CT.ATT + 1)<1,CT.VAL,CT.SVL>
WHILE EI.REC(COUNTER + 1)<1,CT.VAL,CT.SVL> # "" DO
EI.REC(CT.ATT + 1)<1,CT.VAL,CT.SVL> = ""
REPEAT
END ELSE
IF CTC.45FL = 0 THEN
EI.REC(CT.ATT) = DELETE(EI.REC(CT.ATT),1,CT.VAL,CT.SVL)
END ELSE
CT.FIELD.CK = EI.REC(CT.ATT)<1,CT.VAL,CT.SVL>
CT.FIELD.CK1 = FIELD(CT.FIELD.CK,"*",CT.4VL)
CTC.SCOL1 = COL1(); CTC.ECOL1 = COL2()
IF CTC.45FL = 1 THEN
CT.FIELD.CK = CT.FIELD.CK[1,CTC.SCOL1]:CT.FIELD.CK[(CTC.ECOL1+1),99]
END ELSE
CT.FIELD.CK2 = FIELD(CT.FIELD.CK1,"@",CT.5VL)
CTC.SCOL2 = COL1(); CTC.ECOL2 = COL2()
CT.FIELD.CK1 = CT.FIELD.CK1[1,CTC.SCOL2]:CT.FIELD.CK1[(CTC.ECOL2+1),99]
CT.FIELD.CK = CT.FIELD.CK[1,CTC.SCOL1]:CT.FIELD.CK1:CT.FIELD.CK[CTC.ECOL1,99]
END
EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = CT.FIELD.CK
END
END
IF EI.REC(CT.ATT)<1,CT.VAL,CT.SVL> = "" THEN
IF F.D > 0 THEN
F.D = F.D - 1
$INCLUDE IBP EI.SD.INCL.CTC.F.D.SET
END
IF C.LN > (L.P + L.A) THEN C.LN = C.LN - 1
END
COUNTER = C.LN - 1
LOOP COUNTER = COUNTER + 1 WHILE COUNTER < B.LN DO PRINT @(C.CL-3,COUNTER):RVB:"   ":RVE:SPACE(SPEC<1,1,4>): REPEAT
*GOSUB CTC.DISP.RECD
P.L.N = 18
END
RETURN
*!
*CTC.F.D.SET: *#*
**
*P.L.N = 19
*IF CNTR<1,1,2> = "AM" THEN  CT.ATT = F.D ELSE
*IF CNTR<1,1,2> = "VM" THEN  CT.VAL = F.D ELSE
*IF CNTR<1,1,2> = "SV" THEN  CT.SVL = F.D ELSE
*IF CNTR<1,1,2> = "4V" THEN CT.4VL = F.D; CTC.45FL = 1 ELSE
*IF CNTR<1,1,2> = "5V" THEN CT.5VL = F.D; CTC.45FL = 2 ELSE
*CTC.ERR = 3
*GOSUB CTC.ERR.DISP
*END
*END
*END
*END
*END
*RETURN
**
**#*END OF CHANGES*#*
*CUSTOM*END OF
!
END
~S.I.T.EI~
SUBROUTINE S.I.T.EI
*SUBROUTINE : S.I.T.EI
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP EI.COMMON.VARIABLES
*
*$INCLUDE IBP STANDARD.FUNCTIONS
MAT TB.LOCT = ''; MAT TB.ERRS = ''
*
*
MAT TB.FTYPE = ''; MAT TB.STAT = ''; MAT TB.F.DESC = ''
*
*
$INCLUDE IBP EI.CNTR.EQUATES
*
$INCLUDE SUB.IO.OPEN.EI.SYSS
*
ERR.NUM = 0; F.ERR = 0
K.C.L = 1
*
MATREAD TB.FTYPE FROM SYST,'@@@@EI@@@FUNC.TYPE.DESC' ELSE 
ERR.NUM = 1
F.ERR = 1
GOSUB ERROR.CONTROL
END
*
*
*
MATREAD TB.F.DESC FROM SYST,'@@@@EI@@@FUNC.DESC' ELSE
ERR.NUM = 2
F.ERR = 1
GOSUB ERROR.CONTROL
END
*
*
*
MATREAD TB.STAT FROM SYST,'@@@@EI@@@REC.STAT.DESC' ELSE
ERR.NUM = 3
F.ERR = 1
GOSUB ERROR.CONTROL
END
*
*
CURRENT.KEY.DISPLAY = SPACE(20)
CURRENT.KEY = ''
KEY.ENTITY = SPACE(20)
CURRENT.ENTITY.TYPE = 0
*
*
*
*
MATREAD TB.ERRS FROM SYST,'@@@@EI@@@ERROR.MSG' ELSE
ERR.NUM = 9
ERR.SUB.NUM = 2
GOSUB ERROR.CONTROL
END
*
*
RETURN
*
*
ERROR.CONTROL: *#*
PRINT @(0,22):'ERROR IN TABLE INITIALIZE!!!':
PRINT @(0,21):ERR.NUM:', ':ERR.SUB.NUM:', ':F.ERR:'<<<':
INPUT A$
RETURN
END
~S.I.T.EI.SPEC.DISP~
SUBROUTINE S.I.T.EI.SPEC.DISP
*SUBROUTINE: S.I.T.EI.SPEC.DISP
*
*COMPANY: MACROSCOPE DESIGN MATRIX
*
* AUTHOR: DAVID HORMSMAN     OF    AIM SERVICES
*                                  PH: 254-9889
*                                  VAN., B.C.
*
$INCLUDE IBP EI.COMMON.VARIABLES
*
* 
$INCLUDE IBP STANDARD.FUNCTIONS
* 
MAT TB.ERRS = 'ERROR'
MAT TB.LOCT = 'PROGRAM LOCATION ??'
TB.ERRS(1) = 'That sequence # not found'
TB.ERRS(2) = 'Too many transaction, please purge'
TB.ERRS(3) = 'Error encountered in setting field location'
*TB.ERRS(3) = 'That is not a valid choice'
TB.ERRS(4) = 'That field number is invalid'
TB.ERRS(5) = 'You must enter this field'
TB.ERRS(6) = 'You must enter a seqence number on a change'
TB.ERRS(7) = 'Purge feature not yet released'
TB.ERRS(8) = 'You can not enter a detail number here'
TB.ERRS(9) = 'Enter <CR> to return to PROSPECTS INFO.'
TB.ERRS(10) = 'The "Transfer Contact Tran." is not yes released'
TB.ERRS(11) = 'A change here will loose your contact trans.'
TB.ERRS(12) = 'MESSAGE 12'
TB.ERRS(13) = 'MESSAGE 13'
TB.ERRS(14) = 'The file I am trying to access was not found.'
* 
TB.LOCT(1) = 'CCTA VISITOR main program'
TB.LOCT(2) = 'Initialization'
TB.LOCT(3) = 'Program control'
TB.LOCT(4) = 'Input fields'
TB.LOCT(5) = "Clear the screen and it's tables"
TB.LOCT(6) = 'Display the heading'
TB.LOCT(7) = 'Input a <CR>'
TB.LOCT(8) = 'Subroutine control for Displaying transactions'
TB.LOCT(9) = 'Read record from the CONTACT file'
TB.LOCT(10) = 'Derive the key for the CONTACT file'
TB.LOCT(11) = 'Display the SEQUENCE information'
TB.LOCT(12) = 'Subroutine control for Displaying TEXT'
TB.LOCT(13) = 'Display the TEXT information'
TB.LOCT(14) = 'Input persons desired action'
TB.LOCT(15) = 'Update record to the CONTACT file'
TB.LOCT(16) = 'Standard Error Display'
TB.LOCT(17) = 'Set the Purge Flag (delete all SEQUENCEs)'
TB.LOCT(18) = 'Delete one SEQUENCE'
TB.LOCT(19) = 'Delete one TEXT line'
TB.LOCT(20) = 'END OF PROGRAM'
*
*
RETURN
*
END
~S.I.T.INFO.EI~
SUBROUTINE S.I.T.INFO.EI
*SUBROUTINE: S.I.T.INFO.EI
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP EI.COMMON.VARIABLES
*
MAT IA.C = 0
DIM IA.READ(100)
*
*
$INCLUDE IBP CNTR.EQUATES
*
$INCLUDE IBP SUB.IO.OPEN.EI.SYSS
ERR.NUM = 0; F.ERR = 0
*
IA.KEY = '@EI@INFO.AREA-':TB.L(K.C.L)<1,1,1>[5,99]
*
*
MATREAD IA.READ FROM SYST,IA.KEY THEN
MAT IA.C = MAT IA.READ
END ELSE
ERR.NUM = 7
F.ERR = 1
ERR.SUB.NUM = 1
GOSUB ERROR.CONTROL
END
*
*
RETURN
*
*
ERROR.CONTROL: *#*
PRINT @(0,22):'ERROR IN TABLE INITIALIZE!!!':
PRINT @(0,21):ERR.NUM:', ':ERR.SUB.NUM:', ':F.ERR:'<<<':
CHAIN "MENU-RUN EI.DP.DEV"
RETURN
END
~SOURCEGEN~
*PROGRAM: SOURCEGEN
*
$INCLUDE BP.SG SOURCEGEN.DOC.HDR
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
DIM PMPT(100)
MAT PMPT = EMPTY
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
!
*
STAT = FALSE; ENTRY.TYPE = ZERO; OUT.FL.ID = EMPTY; SCR.ID = EMPTY
LST.END = FALSE; FIRST = TRUE
EQ.F = EMPTY; MAT EQF = EMPTY; MAT EQT = EMPTY; EQF.IND = EMPTY
SBR = FALSE; SBR.F = EMPTY; SBR.LN = EMPTY
NO.DIM = EMPTY; REC.FL = EMPTY; KEY.FL = EMPTY
FLNMS = EMPTY; FLNM = EMPTY; FLNM.SUFF = EMPTY
SIR = EMPTY; SIR.AC = EMPTY; READ.ITEMS = EMPTY
TRUE.AC = EMPTY; REF.AC = EMPTY; FL = EMPTY
AC = EMPTY; VC = EMPTY; SC = EMPTY; SB = EMPTY
PMPT.TYPE = EMPTY; PMPT.TEXT = EMPTY; PMPT.RSP = EMPTY
INPUT.REQD = EMPTY; EXTR = EMPTY; INST = EMPTY; POSN = EMPTY; LOCT = EMPTY
LOCN = EMPTY; OLD.LOCN = EMPTY; CONV = EMPTY; EDIT = EMPTY
EDIT.FILE = EMPTY; CL = EMPTY; LN = EMPTY
LH = EMPTY; LHM = EMPTY; LM = EMPTY; MS = EMPTY
VF = EMPTY; CNTRL.AC = EMPTY; SQ = EMPTY
VTYPE = EMPTY; VTYPE.SEP = EMPTY; VTYPE.VC = EMPTY; VTYPE.FL = EMPTY; DT = EMPTY
SPOS = EMPTY; SPOS.MAX = EMPTY
*
!
*
MAIN: *
*
LOOP
*
SIR = EMPTY; SIR.HDR = EMPTY; SIR.TEXTS = EMPTY; SIR.KEY = EMPTY
SIR.PMPT = EMPTY; FLNMS = EMPTY
VAR.SRT.FL = FALSE; VAR.REG.FL = FALSE
VTY.INP.REG.FL = FALSE; VTY.INP.SRT.FL = FALSE
MAT PMPT = EMPTY
*
IF NOT(LST.END) THEN
READNEXT SCR.ID THEN LST.END = FALSE ELSE LST.END = TRUE
END ELSE SCR.ID = EMPTY
IF SCR.ID[ONE,8] EQ "SH.SUBR." THEN SCR.ID = SCR.ID[9,9999]
IF SCR.ID[ONE,3] EQ "SH." THEN SCR.ID = SCR.ID[4,9999]
!
IF (SCR.ID EQ EMPTY OR FIRST) AND NOT(ENTRY.TYPE) THEN
CALL SOURCEGEN.INP.PARAMS(CNT.FILE,SYS.FILE,SCR.FILE.ID,SCR.FILE,OUT.FL.ID,BPF.FILE,IBPF.FILE,SCR.ID,TF,ENTRY.TYPE,DISPL.FLAG,DISPL.OPT,BASIC.FLAG,BASIC.OPT,CATLG.FLAG,CATLG.OPT,FIRST,STAT)
IF SCR.ID[ONE,8] EQ "SH.SUBR." THEN SCR.ID = SCR.ID[9,9999]
IF SCR.ID[ONE,3] EQ "SH." THEN SCR.ID = SCR.ID[4,9999]
END
*
WHILE SCR.ID NE EMPTY AND NOT(STAT) DO
*
! RECORD LOCATION
*
EXEC.VERB = "ACC.UPDATE"
**EXEC.IN = "S/W Inst SourceGen" "L#25":("Doing ":OUT.FL.ID:" ":SCR.ID) "L#25"
**EXEC.IN = "+SrceG: ":SCR.ID:" ":OUT.FL.ID
EXEC.IN = "+":SCR.ID:"+SGen: ":OUT.FL.ID
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
!
* READ SCREEN
*
READ SIR FROM SCR.FILE,SCR.ID THEN
*
IF TF THEN
PRINT @(ZERO,ZERO):CLS:
END
*
*
CALL SOURCEGEN.LOAD(SCR.FILE,SCR.ID,TF,TEXT.AC,ID.AC,PMPT.AC,SIR.HDR,REDISP,TRANSL,ID.MAX,SIR,FIXED.KEY,SIR.TEXTS,SIR.KEY,SIR.PMPT,STAT)
*
END ELSE PRINT SCR.ID:" missing!":BELL:; SIR = EMPTY; * SCR.ID = EMPTY
*
!
*
IF SCR.ID NE EMPTY THEN
*
*
IF TF THEN
PRINT @(ZERO,ZERO):RVB:"<Application Generator Output ":OUT.FL.ID:" ":SCR.ID:">":RVE:
PRINT @(ZERO,TWO):CLL:@(40):RVB:"<":SCR.ID:" ":OUT.FL.ID:RVE:
PRINT @(70,3):"<Init: ":
END
*
IF SIR<SCR.HDR$FILE> NE EMPTY THEN
OPEN SIR<SCR.HDR$FILE> TO BPF.FILE THEN
OUT.FL.ID = SIR<SCR.HDR$FILE>
PRINT @(ZERO,ZERO):CLL:
PRINT RVB:"Application Generator Output is Set at ":OUT.FL.ID:" ":SCR.ID:RVE:
END ELSE 
PRINT 
PRINT "Can't open ":SIR<SCR.HDR$FILE>:"!"
PRINT BELL:
END
END
*
SCR.APPL     = SIR<SCR.HDR$APPL>
SCR.SUB.APPL = SIR<SCR.HDR$SUB.APPL>
IF TF THEN PRINT @(70,6):"<Appl: ":SCR.APPL:@(70,7):"<Sub: ":SCR.SUB.APPL:
*
FLNMS = SIR<SCR.HDR$FILE.NAME>
IF TF THEN PRINT @(ZERO,4):CLL:"<Files: ":FLNMS:">":; * RQM 
ALLOWED = SIR<SCR.HDR$ALLOWED>; IF ALLOWED EQ EMPTY THEN ALLOWED = "ACD"
IF TF THEN PRINT @(70,8):"<Allow: ":ALLOWED:">":; * RQM
*
NO.DIM = SIR<SCR.HDR$NO.EQUATES>
REC.FL = SIR<SCR.HDR$REC.FLAG>
*
CALL SOURCEGEN.CALLS(SIR,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPD.S,UPDB.C,UPDE.C,DEL.S,DELB.C,DELE.C,ID.S,IDB.C,IDE.C,READ.S,READB.C,READE.C,ABO.C,INP.C,OPE.S,OPE.C,INIT.C,DEL.TBL,TF,STAT)
*
SCRN.TYPE = SIR<SCR.HDR$SCREEN.TYPE>
IF SCRN.TYPE EQ EMPTY THEN SCRN.TYPE = "PSI"
SBR = FALSE; SBR.F = EMPTY; SBR.LN = EMPTY
IF INDEX(SCRN.TYPE,"S",ONE) THEN SBR = TRUE ELSE SBR = FALSE
IF TF THEN PRINT @(70,9):"<Rtn.Ty: ":SCRN.TYPE:">":; * RQM 
*
RELEASE.ID = SIR<SCR.HDR$RELEASE>
IF TF THEN PRINT @(70,10):"<Rels: ":RELEASE.ID:">":; * RQM 
*
INPUT.TYPE = SIR<SCR.HDR$INPUT.TYPE>
IF TF THEN PRINT @(70,11):"<Inp.Ty: ":INPUT.TYPE:">":; * RQM
*
*
* SPLIT 19 APR 91
* DGH
*
*
*
IF TF THEN PRINT @(70,4):"<Start: ":; * RQM
*
LNS = EMPTY; READ.LNS = EMPTY
CALL SOURCEGEN.START(TOP.LNS,SCR.APPL,SCR.SUB.APPL,SCR.ID,RELEASE.ID,INP.C,SBR,TF,STAT)
LNS<-ONE> = TOP.LNS
TOP.LNS = EMPTY
*
IF TF THEN PRINT @(70,5):"<Opens: ":; * RQM
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CALL SOURCEGEN.OPEN(IBPF.FILE,EQF.FILE,MAT EQT,MAT EQF,EQT.F,EQF.MAX,EQF.IND,INIT.LNS,OPEN.LNS,DIM.LNS,EQU.LNS,FLNMS,ID,SCR.ID,SBR,SBR.F,SBR.LN,TF,CO.DATA,NO.DIM,REC.FL,KEY.FL,OPE.C,OPE.S,INIT.C,STAT)
* LNS<-ONE> = INIT.LNS
* INIT.LNS = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
RTN.LNS = EMPTY; TRN.LNS = EMPTY; INP.NUM = ONE; TRN.NUM = ONE; READ.ITEMS = EMPTY
VTY.LNS = EMPTY; ADD.LNS = EMPTY; DEL.LNS = EMPTY
INX.LNS = EMPTY; XTR.LNS = EMPTY
*
IF TF THEN PRINT @(70,12):"<Refs: ":; * RQM 
ID = FLNMS<ONE,ONE>:".ID"
CALL SOURCEGEN.VALID.REFS(REF.LNS,MAX.REF,PMPT.AC,SIR,TF,POS.LOC,POS.REF,POS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,STAT)
*
*
LNS<-ONE> = REF.LNS
* REF.LNS = EMPTY
*
*
LNS<-ONE> = INIT.LNS
INIT.LNS = EMPTY
*
*
IF TF THEN PRINT @(70,16):"<Key: ":; * RQM 
CALL SOURCEGEN.KEY(KEY.LNS,MAT EQF,TF,SIR,IDB.C,IDE.C,FIXED.KEY,ID.MAX,EQF.IND,ID.AC,ID,REDISP,FLNMS,MAT EQT,EQ.F,READ.ITEMS,NO.DIM,REC.FL,KEY.FL,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,ID.S,TRN.NUM,SCR.ID,STAT)
*
*
** IF TF THEN PRINT @(ZERO,18):CLL:@(ZERO,19):CLL:@(ZERO,20):CLL:
IF TF THEN PRINT @(70,13):"<Main: ":; * RQM 
CALL SOURCEGEN.MAINLINE(MAIN.LNS,ID,ID.MAX,ID.AC,ID.S,IDB.C,IDE.C,MAT EQT,READB.C,READE.C,FIXED.KEY,ALLOWED,NO.DIM,REC.FL,KEY.FL,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,MAX.REF,MSG,DELB.C,DELE.C,UPDB.C,UPDE.C,ABO.C,INP.C,OPE.C,INIT.C,FLNMS,READ.S,DEL.S,UPD.S,TF,STAT)
LNS<-ONE> = MAIN.LNS
MAIN.LNS = EMPTY
*
** IF TF THEN PRINT @(ZERO,11):CLL:@(ZERO,12):CLL:@(40,12):"<Back: ":; * RQM 
IF TF THEN PRINT @(70,14):"<Back: ":; * RQM
CALL SOURCEGEN.BG.DISP(SCR.FILE,SCR.ID,MAT SCR.LNS,MAT LPT.LNS,BGR.LNS,MAX.REF,TEXT.AC,SIR,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,BG.C,TF,STAT)
LNS<-ONE> = BGR.LNS
BGR.LNS = EMPTY
*
IF TF THEN PRINT @(70,15):"<Fore: ":; * RQM 
GOSUB FG.DISP
*
**IF TF THEN PRINT @(70,16):"<Key: ":; * RQM 
**CALL SOURCEGEN.KEY(KEY.LNS,MAT EQF,TF,SIR,IDB.C,IDE.C,FIXED.KEY,ID.MAX,EQF.IND,ID.AC,ID,REDISP,FLNMS,MAT EQT,EQ.F,READ.ITEMS,NO.DIM,REC.FL,KEY.FL,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,ID.S,TRN.NUM,SCR.ID,STAT)
LNS<-ONE> = KEY.LNS
KEY.LNS = EMPTY
*
IF TF THEN PRINT @(ZERO,ZERO):"<Lptr: ":; * RQM
IF NOT(LP.S) THEN GOSUB LP.DISP
* EQU.LNS = EMPTY
* DIM.LNS = EMPTY
IF TF THEN PRINT @(70,17):"<Lptr: ":; * RQM
*
IF TF THEN PRINT @(70,18):"<InCalls: ":; * RQM 
GOSUB INPUT.CS
*
IF TF THEN PRINT @(70,19):"<InField: ":; * RQM 
IF TF THEN PRINT @(70,20):"<Rtn.Lns: ":; * RQM
* LNS<-ONE> = RTN.LNS
WRITE RTN.LNS    ON SCR.FILE,SCR.ID:"*RTN"
WRITE TRN.LNS    ON SCR.FILE,SCR.ID:"*TRN"
WRITE KEY.LNS    ON SCR.FILE,SCR.ID:"*KEY"
RTN.LNS = EMPTY
LNS<-ONE> = "@@@"
LNS<-ONE> = '*':AM:'!':AM:'*'
IF TRN.LNS NE EMPTY THEN
IF TF THEN PRINT @(70,21):"<Trans: ":; * RQM
LNS<-ONE> = TRN.LNS
TRN.LNS = EMPTY
LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF TF THEN PRINT @(70,22):"<Errors: ":; * RQM 
GOSUB ERROR.ROUTINE
LNS<-ONE> = ERR.LNS
ERR.LNS = EMPTY
*
IF TF THEN PRINT @(ZERO,3):"<Reads: ":; * RQM 
GOSUB SET.UP.READ.ITEMS
IF TF THEN PRINT @(70,3):"<Reads: ":; * RQM 
*
IF TF THEN PRINT @(70,4):"<Custom: ":; * RQM 
CALL SOURCEGEN.CUSTOM(CALL.LNS,BG.C,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPDB.C,UPDE.C,DELB.C,DELE.C,IDB.C,IDE.C,READB.C,READE.C,ABO.C,INP.C,OPE.C,INIT.C,TF,STAT)
IF LEN(CALL.LNS) THEN
LNS<-ONE> = CALL.LNS
CALL.LNS = EMPTY
END
*
CALL SOURCEGEN.WRITE(LNS,SBR,SCR.APPL,SCR.SUB.APPL,SCR.ID,SBR.LN,BPF.FILE,SYS.FILE,SCR.FILE,EQF.FILE,SPOS.LOC,SPOS.REF,SPOS.DISP,MAT SCR.LNS,SIR,SIR.HDR,SIR.TEXTS,SIR.KEY,SIR.PMPT,MAT EQF,TF,EQF.MAX,DIM.LNS,EQU.LNS,REF.LNS,FLNMS,NO.DIM,REC.FL,KEY.FL,DEL.TBL)
*
LNS = EMPTY
*
SCR.RESULT = SCR.ID:AM:SCR.FILE.ID:AM:OUT.FL.ID
SCR.RESULT<11> = TRUE
SCR.RESULT<12> = DATE()
SCR.RESULT<13> = TIME()
WRITE SCR.RESULT ON SCR.FILE,"CURRENT.SOURCEGEN@":PORT
*
PRINT @(ZERO,ZERO):
EXECUTE "SOURCEGEN.MERGE"
*
READ SCR.RESULT FROM SYS.FILE,"CURRENT.SOURCEGEN" ELSE
PRINT "CONTROL.RECORD MISSING!":BELL
SCR.RESULT  = EMPTY
SCR.RESULT<11> = TRUE
END
MERGE.STAT = SCR.RESULT<11>
*
IF NOT(MERGE.STAT) AND BASIC.FLAG THEN
*
PRINT @(ZERO,ZERO):
EXEC.VERB = "GEN.COMPILE ":SCR.ID:" ":OUT.FL.ID
IF LEN(BASIC.OPT) THEN EXEC.VERB = EXEC.VERG:" ":BASIC.OPT
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
TMP = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
EXEC.OUT = TMP:EXEC.OUT
EXEC.OUT<-ONE> = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
WRITE EXEC.OUT ON SCR.FILE,SCR.ID:"*BAS"
IF DISPL.FLAG THEN
PRINT
PRINT
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE>
DEL EXEC.OUT<ONE>
REPEAT
PRINT
END
*
END; * of BASIC.FLAG
*
IF NOT(MERGE.STAT) AND CATLG.FLAG THEN
*
PRINT @(ZERO,ZERO):
EXEC.VERB = "GEN.CATALOG ":SCR.ID:" ":OUT.FL.ID
IF LEN(CATLG.OPT) THEN EXEC.VERB = EXEC.VERG:" ":CATLG.OPT
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
TMP = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
EXEC.OUT = TMP:EXEC.OUT
EXEC.OUT<-ONE> = OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
WRITE EXEC.OUT ON SCR.FILE,SCR.ID:"*CAT"
IF DISPL.FLAG THEN
PRINT
PRINT
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE>
DEL EXEC.OUT<ONE>
REPEAT
PRINT
END
*
END; * of CATLG.FLAG
*
IF TF THEN PRINT @(70,23):"<Done>":@(0,22):; * RQM
*
*
END; * of SCR.ID ne empty (screen found)
*
***
*
FIRST = FALSE
*
REPEAT; * get next screen
*
*
STOP
!
*
FG.DISP: * GEN FG DISPLAY AND INPUT SUBROUTINES
*
LNS<-ONE> = '*':AM:'!':AM:'*'
LNS<-ONE> = 'DISP.FG: *'
LNS<-ONE> = '*'
*
LNS<-ONE> = 'SYS11.FL = SYSTEM(11) * (SEC.USER$BF GE 10)'
LNS<-ONE> = 'IF SYS11.FL GE 3 THEN RETURN'
*
*
IF NOT(ID.S) OR LEN(IDB.C) OR LEN(IDE.C) THEN
LNS<-ONE> = 'IF REDISP THEN'
LNS<-ONE> = 'REDISP = 99'
LINE = 'TEMP = ':ID
LINE<-ONE> = 'FOR ID.CN = ONE TO '
TMP1 = ZERO
FOR TMP = ID.AC TO ID.MAX
IF SIR<TMP,ONE,TWO>[ONE,ONE] NE "*" THEN TMP1 = TMP1 + ONE
NEXT TMP
LINE = LINE:TMP1 + ZERO:'; ':ID:'.SAVE<ID.CN> = "!":':ID:'.SAVE<ID.CN>':'; NEXT ID.CN'
LINE<-ONE> = 'GOSUB GET.KEY'
LINE<-ONE> = ID:' = TEMP'
LNS<-ONE> = LINE
LNS<-ONE> = 'END'
LNS<-ONE> = '*'
END
*
***
*
IF PMPT.AC THEN
*
CURR.AC = PMPT.AC
WINDOW.CN = ZERO; FIELD.CN = ZERO
PRINT @(50,13):
*
LOOP
WINDOW.CN = WINDOW.CN + ONE 
IF TF THEN
PRINT @(60,WINDOW.CN + 10):RVB:"<W ":RVE:WINDOW.CN:"> ":; * RQM
END
FIRST.AC = CURR.AC; LAST.AC = CURR.AC; MAX.NUM = ONE
SUB.NUM = ONE
*
LOOP
SIR.AC = LAST.AC + ONE; REF = SIR<SIR.AC,ONE,ONE>[ONE,ONE]; IF REF = '"' THEN MAX.NUM = MAX.NUM + ONE
*D*SIR.AC = LAST.AC + ONE; REF = SIR<SIR.AC,ONE,ONE>[ONE,ONE]; IF REF = ',' OR REF EQ '"' THEN MAX.NUM = MAX.NUM + ONE
WHILE SIR<SIR.AC> NE EMPTY AND (REF EQ EMPTY OR REF EQ "," OR REF EQ '"' OR REF EQ "'") DO 
IF TF THEN
FIELD.CN = FIELD.CN + ONE 
PRINT RVB:"<F":RVE:FIELD.CN:"> ":; * RQM
END
LAST.AC = LAST.AC + ONE
REPEAT
*
LN = ZERO; CL = ZERO; LH = ZERO
SIR.AC = FIRST.AC; GOSUB EXTR.PMPT.DT
IF INPUT.REQD THEN ANY.INPUT = ONE ELSE ANY.INPUT = ZERO
*
IF TF THEN
IF LAST.AC NE FIRST.AC THEN FIELD.CN = ZERO
IF (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
END
*
IF VF THEN GOSUB VAR.DISP ELSE GOSUB NON.VAR.DISP
*
UNTIL SIR<CURR.AC> EQ EMPTY DO REPEAT
*
END; * of PMPT.AC
*
***
*
LNS<-ONE> = '*'
*
IF FG.C NE EMPTY THEN
LNS<-ONE> = 'GOSUB FG.C'
LNS<-ONE> = '*'
END
*
LNS<-ONE> = 'REDISP = FALSE'
LNS<-ONE> = '*'
LNS<-ONE> = 'RETURN'
*
RETURN
*
!
*
LP.DISP: *
*
LNS<-ONE> = '*':AM:'!':AM:'*'
LNS<-ONE> = 'DISP.LP: *'
LNS<-ONE> = '*'
*
SBR.WR.FL = TRUE
CALL SOURCEGEN.LP.DISP(SCR.FILE,BPF.FILE,SCR.ID,MAT SCR.LNS,MAT LPT.LNS,SLP.LNS,MAX.REF,TEXT.AC,SIR,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,LP.C,TF,SBR.WR.FL,SBR.LN,DIM.LNS,EQU.LNS,REF.LNS,STAT)
LNS<-ONE> = SLP.LNS
SLP.LNS = EMPTY
* REF.LNS = EMPTY
*
LNS<-ONE> = '*'
*
LNS<-ONE> = 'RETURN'
*
RETURN
*
!
*
NON.VAR.DISP: *
*
REF.AC = FIRST.AC
LNS<-ONE> = '*':AM:'!':AM:'*'
FOR CURR.AC = FIRST.AC TO LAST.AC
*
IF CURR.AC NE FIRST.AC THEN SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT ELSE SAVE.PMPT.TYPE = PMPT.TYPE
IF SIR<CURR.AC + ONE,ONE,TWO>[ONE,ONE] EQ "*" THEN TRANSL = TRUE ELSE TRANSL = FALSE
*
CALL SOURCEGEN.SUBR.SUBREF(RTN.LNS,INP.LBL,INP.NUM,INPUT.REQD,CURR.AC,FIRST.AC,RTN.LN,SUB.NUM,MAX.NUM,LINE,TF,STAT)
*
*
START.LN = LN
FOR LN = START.LN TO LM
*
** IF INPUT.REQD THEN
*
CALL SOURCEGEN.SUBR.SPOS(CL,LN,SCL.LOC,SPOS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.DISP,INP.NUM,SAVE.PMPT.TYPE,START.LN,REF.AC,FIRST.AC,TF,STAT)
*
***IF INPUT.REQD THEN
*
IF LN EQ START.LN THEN
*
IF INPUT.REQD THEN
***IF MAX.NUM GT ONE THEN RTN.LNS<-ONE> = "I":INP.LBL:CHAR(SUB.NUM + 64):": *"; SUB.NUM = SUB.NUM + ONE ELSE RTN.LNS<-ONE> = RTN.LN
IF MAX.NUM GT ONE THEN
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = '!'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'I':INP.LBL:CHAR(SUB.NUM + 64):': *'
RTN.LNS<-ONE> = '*'
SUB.NUM = SUB.NUM + ONE
END ELSE
RTN.LNS<-ONE> = RTN.LN
END
END
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = LOCN
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":TMP
*
IF INPUT.REQD THEN
LINE = 'CALL INPUT.DATA.SG1("':TMP1:'","':TMP:'",':FLNM:',':CL:',':LN:',"':MS[ONE,ONE]:MS[3,9]:'","':LHM:'",'
LINE = LINE:LOCN:',"':CONV:'","':EDIT:'",':EDIT.FILE:',RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"0",TC.FUNC,':CL:',':LN:',".",STD.SUBR.NAME,PROCBUF,STAT)'
IF TRANSL THEN
RTN.LNS<-ONE> = LINE
LINE = 'IF STAT THEN RETURN ELSE LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
END
RTN.LNS<-ONE> = LINE
*
IF REDISP THEN
RTN.LNS<-ONE> = 'REDISP = TRUE; GOSUB DISP.BG; GOSUB DISP.FG'; REDISP = FALSE
RTN.LNS<-ONE> = 'RETURN'
END ELSE IF LN EQ START.LN THEN
*DD*RTN.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG'
RTN.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I':INP.LBL
RTN.LNS<-ONE> = 'RETURN'
END
*
END; * of INPUT.REQD
*
END; * of START.LN
*
**END; * of INPUT.REQD
*
***
*
IF FL NE EMPTY THEN
*
DISP.LN = FLNM
*
IF NUM(AC) OR VC NE EMPTY THEN
DISP.LN = DISP.LN:EXTR
END
*
IF SB NE EMPTY THEN DISP.LN = 'FIELD(':DISP.LN:',"':SB[ONE,ONE]:'",':SB[TWO,TWO]:')'
IF CONV[ONE,ONE] = "D" OR CONV[ONE,ONE] = "M" THEN DISP.LN = 'OCONV(':DISP.LN:',"':CONV:'")'
LINE = 'PRINT @(':CL:',':LN:'):':DISP.LN:' "':MS:'":'
IF TRANSL THEN LINE = LINE:'; LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
LNS<-ONE> = LINE
SPOS.DISP<LN + ONE,SCL.LOC> = DISP.LN:' "':MS:'"'
IF TF AND (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
*
END; * of FL ne empty
*
*
IF SB NE EMPTY THEN SB = SB[ONE,ONE]:SB[TWO,TWO] + ONE ELSE
IF SC NE EMPTY THEN
IF NUM(SC) THEN SC = SC + ONE
END ELSE IF VC NE EMPTY THEN
IF NUM(VC) THEN VC = VC + ONE
END ELSE
IF NUM(AC) THEN AC = AC + ONE
END
END
*
IF LN LT LM THEN SIR.AC = CURR.AC; GOSUB SET.UP.STRINGS
*
NEXT LN
*
***
*
IF TRANSL THEN
$INCLUDE BP.SG SOURCEGEN.TRANSL
* CURR.AC = CURR.AC + ONE
TRANSL = FALSE
END
*
NEXT CURR.AC
*
INP.NUM = INP.NUM+ANY.INPUT
*
RETURN
*
!
*
VAR.DISP: *
*
IF SQ EQ "FI" THEN SORTED = 0 ELSE SORTED = ONE
DSP.LNS = EMPTY
INP.LNS = EMPTY
CLR.LNS = EMPTY
ADD.LNS = EMPTY
DEL.LNS = EMPTY
INX.LNS = EMPTY
XTR.LNS = EMPTY
* REF.LNS = EMPTY
REF.LN = EMPTY
CURR.AC = FIRST.AC; REF.AC = FIRST.AC
SAVE.PMPT.TYPE = PMPT.TYPE
SUB.NUM = ZERO
INP.LBL = (INP.NUM + 100)[TWO,TWO]
START.LN = LN
READ.LNS<-ONE> = 'I':INP.LBL:'.MAX = ':VF+0
READ.LNS<-ONE> = 'TDM(':INP.NUM:') = I':INP.LBL:'.MAX'
READ.LNS<-ONE> = 'TDS(':INP.NUM:') = ':SORTED+0
READ.LNS<-ONE> = 'TDR(':INP.NUM:') = "':PMPT.TYPE:'"'
READ.LNS<-ONE> = 'TDC(':INP.NUM:') = ':LM - LN + ONE
READ.LNS<-ONE> = 'TDT(':INP.NUM:') = ':START.LN
PMPT(INP.NUM) = VF:VM:SORTED:VM:PMPT.TYPE:VM:LAST.AC - FIRST.AC
*
!
*
* FOR SUB.NUM = ONE TO MAX.NUM
LOOP
*
IF SIR<CURR.AC + ONE,ONE,TWO>[ONE,ONE] EQ "*" THEN TRANSL = TRUE ELSE TRANSL = FALSE
*
*
*D*IF INPUT.REQD OR NOT(LN OR CL) THEN
*D*IF (INPUT.REQD OR NOT(LN OR CL)) OR ((VF AND VTYPE.VC GT ONE) AND NOT(VTYPE.FL)) THEN
**IF (INPUT.REQD OR NOT(LN OR CL)) OR ((VF AND VTYPE.VC GT ONE)) THEN
*
IF LN EQ START.LN THEN
SUB.NUM = SUB.NUM + ONE
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'I':INP.LBL:CHAR(SUB.NUM+64):': *'
INP.LNS<-ONE> = '*'
END
*
***
*
IF INPUT.REQD THEN
*
IF REF.LN EQ EMPTY THEN
*
IF EDIT EQ EMPTY THEN TEMP = "SE":VM:"OP" ELSE TEMP = "SE":VM:"OP":VM:EDIT
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = EXTR
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN
TMP = FLNM.SUFF:".":TMP
IF COUNT(FLNM,"$") THEN
TMP = FLNM.SUFF:".":FIELD(FLNM,"$",TWO)
END
END
*
IF INDEX(FLNM,".XREF",ONE) THEN
IF INDEX(FLNM,"$",ONE) THEN
TMP2 = FIELD(FLNM,"$",TWO)
END ELSE TMP2 = FLNM
TMP2 = 'GET.':TMP2
TMP3 = TMP1
TMP4 = 'FLD'
END ELSE
TMP2 = 'INPUT.DATA.SG1'
TMP3 = 'FLD'
TMP4 = 'RSP'
END
*
REF.LN = 'FLD = EMPTY':AM:'CALL ':TMP2:'("':TMP1:'","':TMP:'",':TMP3:',':LEN(PMPT.TEXT) + 9:',23,"'
*
REF.LN = REF.LN:MS[ONE,ONE]:MS[3,9]:'","':LHM:'","1","':CONV:'","':TEMP:'",':EDIT.FILE:',FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"0",TC.FUNC,':LEN(PMPT.TEXT) + 9:',23,".",STD.SUBR.NAME,PROCBUF,STAT)'
*
IF CONV NE EMPTY THEN
REF.LN<-ONE> = 'FLD.OUT = OCONV(FLD,"':CONV:'")'
END ELSE
REF.LN<-ONE> = 'FLD.OUT = FLD'
END
*
END; * of REF.LN eq empty
*
*
TEMP = EDIT
IF NOT(SORTED) THEN IF SUB.NUM = ONE THEN
INP.LNS<-ONE> = 'IF ':FLNM:EXTR:' EQ " " THEN ':FLNM:EXTR:' = EMPTY'
INP.LNS<-ONE> = 'PRINT @(':CL-3:',LN):SPACE(2-LEN(':VTYPE:')):RVB:':VTYPE:':RVE:" ":'
IF TEMP EQ EMPTY THEN TEMP = "OP" ELSE TEMP = "OP":VM:TEMP
END
*
* IF COUNT(FLNM,"$") THEN TMP = EMPTY ELSE TMP = EXTR
TMP = TRUE.AC; TMP1 = FIELD(FLNM,".",ONE)
IF LEN(FLNM.SUFF) THEN TMP = FLNM.SUFF:".":FIELD(FLNM,"$",TWO)
LINE = 'CALL INPUT.DATA.SG1("':TMP1:'","':TMP:'",':FLNM:',':CL:',LN,"':MS[ONE,ONE]:MS[3,9]:'","':LHM:'",'
INP.LNS<-ONE> = LINE:LOCN:',"':CONV:'","':TEMP:'",':EDIT.FILE:',RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"0",TC.FUNC,':CL:',LN,".",STD.SUBR.NAME,PROCBUF,STAT)'
IF SUB.NUM GT ZERO THEN
INP.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I':INP.LBL:CHAR(SUB.NUM+64)
END ELSE
INP.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I':INP.LBL
END
*
IF NOT(SORTED) THEN IF SUB.NUM EQ ONE THEN
IF SUB.NUM GT ZERO THEN
INP.LNS<-ONE> = 'IF STAT THEN RETURN'
* INP.LNS<-ONE> = 'IF RSP EQ EMPTY AND (DYN NE "N" AND DYN NE "I") THEN PRINT BELL:; GOTO I':INP.LBL:CHAR(SUB.NUM+64)
END ELSE
INP.LNS<-ONE> = 'IF STAT THEN RETURN'
* INP.LNS<-ONE> = 'IF RSP EQ EMPTY AND (DYN NE "N" AND DYN NE "I") THEN PRINT BELL:; GOTO I':INP.LBL
END
END
*
IF TRANSL THEN INP.LNS<-ONE> = 'IF STAT THEN RETURN ELSE GOSUB T':(TRN.NUM + 100)[TWO,TWO]
* IF NOT(LN OR CL) THEN INP.LNS<-ONE> = 'RETURN'
*
END; * of INPUT.REQD
*
***
*
DISP.LN = FLNM:EXTR
IF CONV[ONE,ONE] EQ "D" OR CONV[ONE,ONE] EQ "M" THEN DISP.LN = 'OCONV(':DISP.LN:',"':CONV:'")'
*
!
*
IF (LN OR CL) THEN
*
CALL SOURCEGEN.SUBR.DISPLN(DISP.LN,CLEAR.LN,FLNM,EXTR,CONV,LN,CL,SORTED,SUB.NUM,VTYPE,VTYPE.SEP,MS,TEMP.RSP,TRANSL,TRN.NUM)
*
DSP.LNS<-ONE> = DISP.LN
CLR.LNS<-ONE> = CLEAR.LN
*
*D*IF INPUT.REQD AND (SUB.NUM EQ ONE OR NOT(VTYPE.FL)) THEN
IF (INPUT.REQD AND (SUB.NUM EQ ONE OR NOT(VTYPE.FL))) OR ((VF AND VTYPE.VC GT ONE) AND NOT(VTYPE.FL)) THEN
IF FLNM NE EMPTY AND INST NE EMPTY THEN
ADD.LNS<-ONE> = 'INS ':TEMP.RSP:' BEFORE ':FLNM:INST
DEL.LNS<-ONE> = 'DEL ':FLNM:INST
END
END
*
** IF (LN OR CL) THEN
*
***
*
START.LN = LN
FOR TMP.LN = LN TO LM
*
* IF INPUT.REQD THEN
CALL SOURCEGEN.SUBR.SPOS(CL,TMP.LN,SCL.LOC,SPOS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.DISP,INP.NUM,SAVE.PMPT.TYPE,START.LN,REF.AC,FIRST.AC,TF,STAT)
* END
*
IF TF AND LH THEN
PRINT @(CL,TMP.LN):RVB:STR("#",LH):RVE:
END
*
IF SPOS.MAX THEN
TMP = FLNM:'<'
TMP1 = 'TDL(':INP.NUM:') + ':TMP.LN - LN
*
FOR SPOS.CN = ONE TO SPOS.MAX
IF SPOS.CN GT ONE THEN TMP = TMP:','
IF SPOS.CN EQ VTYPE.VC - ONE THEN
TMP = TMP:TMP1
END ELSE
TMP = TMP:FIELD(SPOS,',',SPOS.CN)
END
NEXT SPOS.CN
*
TMP = TMP:'>'
END ELSE
TMP = FLNM:EXTR
TMP1 = EMPTY
END; * of SPOS.MAX
*
IF NOT(SORTED) AND SUB.NUM EQ ONE THEN
SPOS.DISP<TMP.LN + ONE,SCL.LOC> = 'SPACE(TWO - LEN(':TMP1:')):':TMP1:':" ":':TMP:' "':MS:'"'
END ELSE
SPOS.DISP<TMP.LN + ONE,SCL.LOC> = TMP:' "':MS:'"'
END
*
NEXT TMP.LN
*
***
*
* of LN or CL
END ELSE
*
IF NOT(INPUT.REQD) THEN
INP.LNS<-ONE> = DISP.LN
END
*
END; * of LN or CL
*
!
*
IF (INPUT.REQD OR NOT(LN OR CL)) OR ((VF AND VTYPE.VC GT ONE) AND NOT(VTYPE.FL)) THEN
IF NOT(INPUT.REQD OR NOT(LN OR CL)) THEN
INP.LNS<-ONE> = DISP.LN
INP.LNS<-ONE> = '*'
END
INP.LNS<-ONE> = 'RETURN'
END
*
IF TRANSL THEN
$INCLUDE BP.SG SOURCEGEN.TRANSL
* CURR.AC = CURR.AC + ONE
TRANSL = FALSE
END
*
IF REDISP THEN INP.LNS<-ONE> = 'REDISP = TRUE; GOSUB DISP.BG; GOSUB DISP.FG'; REDISP = FALSE
*
WHILE CURR.AC LT LAST.AC DO
*
CURR.AC = CURR.AC + ONE; REF.AC = REF.AC + ONE
* IF TRANSL THEN TRANSL = FALSE; CURR.AC = CURR.AC + ONE
*
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
*
* NEXT SUB.NUM
REPEAT
*
* Process remaining controlled items @@@
*
CURR.AC = CURR.AC + ONE; REF.AC = REF.AC + ONE
*
!
* DELETE AND ADD ROUTINES
*
SIR.AC = FIRST.AC; GOSUB EXTR.PMPT.DT
*
!
* DISPLAY AND CLEAR ROUTINES
*
LNS<-ONE> = 'IF NOT(REDISP) THEN DYN = EMPTY'
LNS<-ONE> = 'GOSUB D':INP.LBL
LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
*
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'D':INP.LBL:': *'
INP.LNS<-ONE> = '*'
*960601*DGH*INP.LNS<-ONE> = 'TDX(REF) = INX.LOC; SAVE.REF = REF; REF = ':INP.LBL
INP.LNS<-ONE> = 'SAVE.REF = REF; REF = ':INP.LBL
INP.LNS<-ONE> = 'SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN'
INP.LNS<-ONE> = 'TDI(REF) = DCOUNT(':FLNM:LOCT:',':VTYPE.SEP:')'
INP.LNS<-ONE> = '*'
*960602*DGH*INP.LN = 'IF TDX(REF) GE ABS(TDL(REF)) AND '
*960602*DGH*INP.LN = INP.LN:'TDX(REF) LE ABS(TDL(REF)) + TDC(REF) - ONE THEN'
INP.LN = 'IF TDX(REF) GE TDL(REF) AND '
INP.LN = INP.LN:'TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN'
INP.LN = INP.LN:' TDL.OK = TRUE ELSE TDL.OK = FALSE'
INP.LNS<-ONE> = INP.LN
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'BEGIN CASE'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'CASE REDISP OR NOT(TDL(REF))'
INP.LNS<-ONE> = 'LN.START = TDT(REF)'
INP.LNS<-ONE> = 'IF TDL(REF) LT ONE THEN TDL(REF) = ONE'
*960602*DGH*INP.LNS<-ONE> = 'TDL(REF) = ABS(TDL(REF))'
INP.LNS<-ONE> = 'TDX(REF) = TDL(REF)'
INP.LNS<-ONE> = 'TDL.OK = FALSE'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'CASE NOT(TDL.OK)'
INP.LNS<-ONE> = 'LN.START = TDT(REF)'
INP.LNS<-ONE> = 'TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))'
INP.LNS<-ONE> = 'TDX(REF) = TDL(REF)'
INP.LNS<-ONE> = '*'
***INP.LNS<-ONE> = 'CASE DYN EQ "I" OR DYN EQ "D"'
***INP.LNS<-ONE> = 'LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)'
***INP.LNS<-ONE> = 'TDL.OK = FALSE'
***INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP'
*960602*DGH*INP.LNS<-ONE> = 'LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF); ':DSP.LNS<ONE>:'; GOTO D':INP.LBL:'.EXIT'
INP.LNS<-ONE> = 'LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)'
INP.LNS<-ONE> = DSP.LNS<ONE>
INP.LNS<-ONE> = 'LN.REDISP = FALSE'
INP.LNS<-ONE> = 'GOTO D':INP.LBL:'.EXIT'
INP.LNS<-ONE> = 'CASE DYN EQ "I" OR DYN EQ "D"'
INP.LNS<-ONE> = 'LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)'
INP.LNS<-ONE> = 'TDL.OK = FALSE'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'CASE DYN EQ EMPTY'
INP.LNS<-ONE> = 'LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)'
**INP.LNS<-ONE> = 'LN.START = TDH(REF)'
**INP.LNS<-ONE> = 'TDL.OK = FALSE'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'CASE TRUE'
INP.LNS<-ONE> = 'GOTO D':INP.LBL:'.EXIT'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'END CASE'
INP.LNS<-ONE> = '*'
*
!!!
*
*960602*DGH*INP.LN = 'IF TDX(REF) GE ABS(TDL(REF)) AND '
*960602*DGH*INP.LN = INP.LN:'TDX(REF) LE ABS(TDL(REF)) + TDC(REF) - ONE THEN'
*960602*DGH*INP.LN = INP.LN:' TDL.OK = TRUE ELSE TDL.OK = FALSE'
*960602*DGH*INP.LNS<-ONE> = INP.LN
*960602*DGH**
*960602*DGH*INP.LNS<-ONE> = 'IF REDISP THEN'
*960602*DGH*INP.LNS<-ONE> = 'TDL(REF) = ABS(TDL(REF))'
*960602*DGH*INP.LNS<-ONE> = 'TDL.OK = FALSE'
*960602*DGH*INP.LNS<-ONE> = 'LN.START = TDT(REF)'
*960602*DGH**
*960602*DGH*INP.LNS<-ONE> = 'END ELSE IF TDL(REF) LT ZERO THEN'
*960602*DGH*INP.LNS<-ONE> = 'TDL(REF) = ABS(TDL(REF))'
*960602*DGH*INP.LNS<-ONE> = 'IF INDEX("*I*D*","*":DYN:"*",ONE) OR NOT(TDL(REF)) THEN TDL.OK = FALSE'
*960602*DGH**960601*DGH*INP.LNS<-ONE> = 'LN.START = TDT(REF); ':VTYPE:' = TDL(REF)'
*960602*DGH*INP.LNS<-ONE> = 'LN.START = TDT(REF)'
*960602*DGH*INP.LNS<-ONE> = 'END ELSE'
*960602*DGH**
*960602*DGH*INP.LNS<-ONE> = 'IF DYN EQ "N" AND TDL.OK THEN LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF); ':DSP.LNS<ONE>:'; GOTO D':INP.LBL:'.EXIT'
*960602*DGH*INP.LNS<-ONE> = 'LN.START = TDT(REF)'
*960602*DGH*INP.LNS<-ONE> = 'END'
*960602*DGH**
*960602*DGH*INP.LNS<-ONE> = 'IF DYN EQ "I" AND TDL.OK THEN LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF) ELSE'
*960602*DGH*INP.LN = 'IF TDL(REF) THEN TDX(REF)'
*960602*DGH*INP.LNS<-ONE> = INP.LN:' = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF)) + (LN.START - TDT(REF)) ELSE TDX(REF) = ONE'
*960602*DGH*INP.LNS<-ONE> = 'END'
*960601*DGH*INP.LNS<-ONE> = 'TOP.LOC = EMPTY; IF TDX(REF) LT ONE THEN TDX(REF) = ONE'
*
INP.LNS<-ONE> = 'IF TDX(REF) LT ONE THEN TDX(REF) = ONE'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'LOOP'
INP.LNS<-ONE> = '*'
*960602*DGH*INP.LNS<-ONE> = 'FOR LN = LN.START TO TDT(REF) + TDC(REF) - ONE UNTIL ':FLNM:EXTR:' = EMPTY OR SYSTEM(11) GE 3'
INP.LNS<-ONE> = 'LN = LN.START'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'LOOP'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = VTYPE:' = TDX(REF)'
*
INP.LNS<-ONE> = 'SYS11.FL = SYSTEM(11) * (SEC.USER$BF GE 10)'
INP.LNS<-ONE> = 'WHILE LN LE TDT(REF) + TDC(REF) - ONE AND ':FLNM:EXTR:' NE EMPTY AND SYS11.FL LT 3 DO'
INP.LNS<-ONE> = '*'
*960601*DGH*INP.LNS<-ONE> = 'IF LN EQ TDT(REF) THEN TOP.LOC = TDX(REF)'
INP.LNS<-ONE> = 'IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)'
INP.LNS<-ONE> = 'IF NOT(TDL.OK) THEN'
* WRITE DSP.LNS    ON SCR.FILE,SCR.ID:"*DSP"
INP.LNS<-ONE> = VTYPE:' = TDX(REF)'
INP.LNS<-ONE> = DSP.LNS
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'LN = LN + ONE'
INP.LNS<-ONE> = 'TDX(REF) = TDX(REF) + ONE'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'REPEAT'
*960602*DGH*INP.LNS<-ONE> = 'NEXT LN'
INP.LNS<-ONE> = '*'
*INP.LNS<-ONE> = 'IF REDISP OR ':FLNM:EXTR:' EQ EMPTY OR SYSTEM(11) GE 3 THEN RSP = EMPTY ELSE'
INP.LNS<-ONE> = 'IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN'
INP.LNS<-ONE> = 'RSP = EMPTY'
INP.LNS<-ONE> = 'END ELSE'
INP.LNS<-ONE> = 'IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE'
INP.LNS<-ONE> = 'SYS11.FL = SYSTEM(11) * (SEC.USER$BF GE 10)'
INP.LNS<-ONE> = 'IF NOT(SYS11.FL) THEN'
INP.LNS<-ONE> = 'PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D':INP.LBL:'.EXIT'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"'
INP.LNS<-ONE> = 'IF RSP EQ "P" THEN'
*960601*DGH*INP.LNS<-ONE> = 'TDX(REF) = TOP.LOC - TDC(REF)'
INP.LNS<-ONE> = 'TDX(REF) = TDL(REF) - TDC(REF)'
INP.LNS<-ONE> = 'IF TDX(REF) LT ZERO THEN TDX(REF) = ONE'
INP.LNS<-ONE> = 'RSP = "Y"'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = 'IF RSP EQ "N" THEN RSP = "Y"'
INP.LNS<-ONE> = 'END'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'WHILE RSP EQ "Y" DO'
INP.LNS<-ONE> = 'TDH(REF) = LN'
*960601*DGH*INP.LNS<-ONE> = 'LN = ':LN
INP.LNS<-ONE> = 'LN.START = TDT(REF); LN = LN.START'
*960525*DGH*INP.LNS<-ONE> = 'GOSUB C':INP.LBL:'; * : *'
*960526*DGH*INP.LNS<-ONE> = '*CLR.LINE*'
INP.LNS<-ONE> = 'IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE'
INP.LNS<-ONE> = 'TDL.OK = FALSE'
INP.LNS<-ONE> = 'REPEAT'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'IF CLEAR OR LN LE TDH(REF) THEN'
*960525*DGH*INP.LNS<-ONE> = 'GOSUB C':INP.LBL:'; * : *'
INP.LNS<-ONE> = '*CLR.LINE*'
INP.LNS<-ONE> = 'END ELSE TDH(REF) = LN'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'D':INP.LBL:'.EXIT: *'
INP.LNS<-ONE> = '*'
*960601*DGH*INP.LNS<-ONE> = 'IF TOP.LOC THEN TDL(REF) = TOP.LOC'
INP.LNS<-ONE> = 'TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN'
INP.LNS<-ONE> = 'REF = SAVE.REF'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'RETURN'
INP.LNS<-ONE> = '*'
INP.LNS<-ONE> = 'C':INP.LBL:': *'
INP.LNS<-ONE> = 'IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE'
INP.LNS<-ONE> = 'LN.HI = TDH(REF)'
***INP.LNS<-ONE> = 'FOR LN.TMP = LN TO LN.HI WHILE NOT(SYSTEM(11))'
INP.LNS<-ONE> = 'LN.TMP = LN - ONE'
INP.LNS<-ONE> = 'LOOP'
INP.LNS<-ONE> = 'SYS11.FL = SYSTEM(11) * (SEC.USER$BF GE 10)'
INP.LNS<-ONE> = 'LN.TMP = LN.TMP + ONE'
INP.LNS<-ONE> = 'WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO'
* WRITE CLR.LNS    ON SCR.FILE,SCR.ID:"*CLR"
INP.LNS<-ONE> = CLR.LNS
***INP.LNS<-ONE> = 'NEXT LN.TMP'
INP.LNS<-ONE> = 'REPEAT'
INP.LNS<-ONE> = 'TDH(REF) = LN'
INP.LNS<-ONE> = 'CLEAR = FALSE'
INP.LNS<-ONE> = 'RETURN'
IF NOT(INPUT.REQD) THEN RETURN
*
!
* FIXED.KEY OR VARIABLE LOCATIONS
*
IF NOT(SORTED) THEN REG.SRT.FL = "REG" ELSE REG.SRT.FL = "SRT"
*
*960525*DGH*IF NOT(VTY.INP.SRT.FL OR VTY.INP.REG.FL) THEN
*
*ALWAYS
TEMP = '*':AM:'Y':INP.LBL:': *':AM:'*'
TEMP<-ONE> = 'TDX(REF) = INX.LOC; ':VTYPE:' = TDX(REF)'
TEMP<-ONE> = 'INX.STR = ':FLNM:EXTR
IF CONV NE EMPTY THEN
TEMP<-ONE> = 'INX.STR.OUT = OCONV(INX.STR,"':CONV:'")'
END ELSE
TEMP<-ONE> = 'INX.STR.OUT = INX.STR'
END
TEMP<-ONE> = '*':AM:'RETURN':AM:'*'
XTR.LNS<-ONE> = TEMP
*END ALWAYS
*
*ANY
TEMP = '*':AM:'X':INP.LBL:': *':AM:'*'
TEMP<-ONE> = 'LOCATE INX.STR IN ':FLNM
TEMP = TEMP:LOCT
IF SORTED THEN
TEMP = TEMP:' BY "':SQ:'"'
END
TEMP = TEMP:' SETTING INX.LOC THEN'
TEMP<-ONE> = 'INX.FOUND = TRUE'
TEMP<-ONE> = 'END ELSE'
TEMP<-ONE> = 'INX.FOUND = FALSE'
TEMP<-ONE> = 'END'
TEMP<-ONE> = 'TDX(REF) = INX.LOC; ':VTYPE:' = TDX(REF)'
TEMP<-ONE> = '*':AM:'RETURN':AM:'*'
INX.LNS<-ONE> = TEMP
*END ANY
*
*960525*DGH*END
*
!
*
IF (SORTED AND NOT(VTY.INP.SRT.FL)) OR (NOT(SORTED) AND NOT(VTY.INP.REG.FL)) THEN
*
TEMP = 'FLD =EMPTY; INX.STR = EMPTY'
TEMP<-ONE> = '*INX.LINE*'
TEMP<-ONE> = 'IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN'
TEMP<-ONE> = 'DYN = "N"'
TEMP<-ONE> = '*DSP.LINE*'
TEMP<-ONE> = 'END'
TEMP<-ONE> = '*'
*
TEMP9 = 'IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN'
TEMP9<-ONE> = 'DYN = "E"'
TEMP9<-ONE> = '*DSP.LINE*'
TEMP9<-ONE> = 'END'
TEMP9<-ONE> = '*'
*
*>>>*IF NOT(VAR.SRT.FL) THEN
*>>>*VAR.SRT.FL = TRUE
*>>>*IF (NOT(VAR.SRT.FL) AND SORTED) OR (NOT(VAR.REG.FL) AND NOT(SORTED)) THEN
*>>>*IF SORTED THEN VAR.SRT.FL = TRUE ELSE VAR.REG.FL = TRUE
*
!
*
IF NOT(SORTED) THEN
* NOT SORTED; * : *
*
RTN.LNS<-ONE> = '*':AM:'!':AM:'*':AM:'VTY.INP.':REG.SRT.FL:': *':AM:'*'
*
*960602*DGH*RTN.LNS<-ONE> = 'IF NEW THEN'
RTN.LNS<-ONE> = 'IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = TEMP
RTN.LNS<-ONE> = '*ADD.LINE*'
RTN.LNS<-ONE> = 'DYN = "N"'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = '*'
*
*>>>*IF MAX.REF GT ONE THEN RTN.LN = 'Ref. ':PMPT.TYPE:'> - ' ELSE RTN.LN = EMPTY
IF MAX.REF GT ONE THEN
RTN.LN = 'Ref. ":TDR(REF):"> - '
END ELSE
RTN.LN = EMPTY
END
RTN.LN = RTN.LN:'Enter line no., N(ext line) or <cr> if okay: '
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF SAVE.DYN EQ "I" THEN'
RTN.LNS<-ONE> = 'SAVE.REFLN = SAVE.REFLN + ONE'
RTN.LNS<-ONE> = 'DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN'
*
RTN.LNS<-ONE> = 'END ELSE IF NOT(LN.LOC) THEN'
*
LNS<-ONE> = 'SYS11.FL = SYSTEM(11) * (SEC.USER$BF GE 10)'
RTN.LNS<-ONE> = 'IF NOT(SYS11.FL) THEN'
RTN.LNS<-ONE> = 'DYN = EMPTY'
RTN.LNS<-ONE> = '*DSP.LINE*'
RTN.LNS<-ONE> = 'PRINT CLB:"':RTN.LN:'":'
RTN.LNS<-ONE> = 'END'
*
TMP.LN = 'DYN = EMPTY':AM:'CALL INPUT.DATA.SG1("COM","REFLN",DYN,':LEN(RTN.LN) + ONE:',23,"'
TMP.LN = TMP.LN:'L5","5","1","","SE':VM:'OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"1",TC.FUNC,':LEN(RTN.LN) + 1:',23,".",STD.SUBR.NAME,PROCBUF,STAT)'
RTN.LNS<-ONE> = TMP.LN
RTN.LNS<-ONE> = 'IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN'
RTN.LNS<-ONE> = 'IF REDISP THEN'
RTN.LNS<-ONE> = 'GOSUB DISP.BG; GOSUB DISP.FG'
RTN.LNS<-ONE> = 'GOTO VTY.INP.':REG.SRT.FL:'.EXIT; * : *'
RTN.LNS<-ONE> = 'END'
* RTN.LNS<-ONE> = 'INPUT DYN:; IF DYN EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = 'DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE'
RTN.LNS<-ONE> = 'DYN = DYN + LN.LOC'
RTN.LNS<-ONE> = 'INX.LOC = DYN'
RTN.LNS<-ONE> = '*XTR.LINE*'
RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF DYN EQ EMPTY THEN RETURN'
RTN.LNS<-ONE> = 'IF DYN EQ "^" THEN STAT = -ONE; RETURN'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF SAVE.DYN EQ "I" THEN'
RTN.LNS<-ONE> = 'DYN = "I"'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'END ELSE IF DYN EQ "N" THEN'
RTN.LNS<-ONE> = TEMP
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF NOT(DYN MATCHES "0N") THEN DYN = ZERO'
RTN.LNS<-ONE> = 'IF NOT(NUM(DYN)) THEN DYN = ZERO'
RTN.LNS<-ONE> = 'IF NOT(DYN) THEN'
RTN.LNS<-ONE> = 'GOTO VTY.INP.':REG.SRT.FL:'.EXIT; * : *'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
*
RTN.LNS<-ONE> = 'INX.LOC = DYN'
RTN.LNS<-ONE> = 'REFLN = DYN'
RTN.LNS<-ONE> = '*XTR.LINE*'
RTN.LNS<-ONE> = 'IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN'
RTN.LNS<-ONE> = 'FLD =EMPTY; INX.STR = EMPTY'
RTN.LNS<-ONE> = '*INX.LINE*'
RTN.LNS<-ONE> = 'PRINT BELL:'
*960607*DGH*RTN.LNS<-ONE> = 'GOTO VTY.INP.':REG.SRT.FL:'.EXIT; * : *'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'SAVE.REFLN = INX.LOC'
*
RTN.LNS<-ONE> = TEMP9
*
RTN.LNS<-ONE> = 'LOOP'
RTN.LNS<-ONE> = 'PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":'
*
TMP.LN = 'DYN = EMPTY':AM:'CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"'
TMP.LN = TMP.LN:'L5","5","1","","SE':VM:'OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,':FXD:',"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)'
RTN.LNS<-ONE> = TMP.LN
*
RTN.LNS<-ONE> = 'IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY'
* RTN.LNS<-ONE> = 'INPUT DYN:; IF DYN EQ "KILL" THEN STAT = 999; RETURN'
RTN.LNS<-ONE> = 'UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'END; * of DYN EQ "N"'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'END; * of NEW'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'SAVE.DYN = DYN'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF NOT(DYN EQ "I" OR DYN EQ "N") THEN'
*960611*DGH*RTN.LNS<-ONE> = 'IF DYN EQ "D" THEN'
RTN.LNS<-ONE> = 'IF DYN NE "D" THEN'
*
*
END ELSE
*   SORTED; * : *
* NOT(SORTED); * 
*
*
RTN.LNS<-ONE> = '*':AM:'!':AM:'*':AM:'VTY.INP.':REG.SRT.FL:': *':AM:'*'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF LN.LOC THEN'
RTN.LNS<-ONE> = 'INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE'
RTN.LNS<-ONE> = 'INX.LOC = INX.LOC + LN.LOC'
*
RTN.LNS<-ONE> = '*XTR.LINE*'
RTN.LNS<-ONE> = 'FLD = INX.STR'
*
RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'END ELSE FLD = EMPTY'
RTN.LNS<-ONE> = '*'
* RTN.LNS<-ONE> = 'IF NOT(LN.LOC) THEN'
RTN.LNS<-ONE> = 'IF FLD EQ EMPTY THEN'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'PRINT CLB:"Enter ":TDR(REF):": ":'
*
RTN.LNS<-ONE> = '*INP.LINE.KEY*'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'INX.STR = FLD'
*
RTN.LNS<-ONE> = 'IF REDISP THEN'
RTN.LNS<-ONE> = 'GOSUB DISP.BG; GOSUB DISP.FG'
RTN.LNS<-ONE> = 'GOTO VTY.INP.':REG.SRT.FL:'.EXIT; * : *'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF STAT THEN'
RTN.LNS<-ONE> = 'TEXT = RSP<TWO>; GOSUB ERROR'
RTN.LNS<-ONE> = 'GOTO VTY.INP.':REG.SRT.FL:'.EXIT; * : *'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF FLD EQ EMPTY THEN'
RTN.LNS<-ONE> = 'DYN = EMPTY'
RTN.LNS<-ONE> = '*DSP.LINE*'
RTN.LNS<-ONE> = 'RETURN'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
* RTN.LNS<-ONE> = 'END ELSE'
* RTN.LNS<-ONE> = VTYPE:' = TDL(':INP.NUM:'); IF ':VTYPE:' THEN ':VTYPE:' = ':VTYPE:' - ONE'
* RTN.LNS<-ONE> = VTYPE:' = ':VTYPE:' + LN.LOC'
* RTN.LNS<-ONE> = 'FLD = ':FLNM:EXTR
* RTN.LNS<-ONE> = 'LN.LOC = ZERO'
*
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
*
!
*
*
TEMP = 'INX.STR = FLD'
TEMP<-ONE> = '*INX.LINE*'
TEMP<-ONE> = 'IF INX.FOUND THEN'
RTN.LN = TEMP
*
RTN.LN<-ONE> = 'PRINT CLB:'
*
IF MAX.REF GT ONE THEN RTN.LN = RTN.LN:'"Ref. ":TDR(REF):"> ":'
*
IF CONV EQ EMPTY THEN
RTN.LN = RTN.LN:'FLD.OUT'
END ELSE
RTN.LN = RTN.LN:'FLD.OUT'
XTR.LNS<-ONE> = 'INX.STR.OUT = OCONV(INX.STR,"':CONV:'")'
END
*
RTN.LNS<-ONE> = RTN.LN:':" - Delete it (Y/<cr>)? ":'
RTN.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN'
*960611*DGH*RTN.LNS<-ONE> = 'IF RSP NE "Y" THEN DYN = EMPTY; PRINT CLB: ELSE'
RTN.LNS<-ONE> = 'IF RSP NE "Y" THEN'
RTN.LNS<-ONE> = 'DYN = EMPTY'
RTN.LNS<-ONE> = 'PRINT CLB:'
*
*
END; * of SORTED/ NOT(SORTED)
*
!
*
RTN.LNS<-ONE> = 'DYN = "E"'
RTN.LNS<-ONE> = '*DSP.LINE*'
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = '*DEL.LINE*'
*
*960602*DGH*RTN.LNS<-ONE> = 'TDL(REF) = -ABS(TDL(REF))'
*
RTN.LNS<-ONE> = 'TDI(REF) = TDI(REF) - ONE'
RTN.LNS<-ONE> = 'DYN = "D"'
RTN.LNS<-ONE> = '*DSP.LINE*'
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
*
RTN.LNS<-ONE> = 'LN.LOC = ZERO'
RTN.LNS<-ONE> = 'GOTO VTY.INP.':REG.SRT.FL:'; * : *'
*960611*DGH*RTN.LNS<-ONE> = 'END ELSE'
*960611*DGH*RTN.LNS<-ONE> = 'DYN = "E"'
*960611*DGH*RTN.LNS<-ONE> = '*DSP.LINE*'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'END ELSE'
*
IF SORTED THEN
RTN.LNS<-ONE> = 'IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"'
END
RTN.LNS<-ONE> = '*'
**RTN.LNS<-ONE> = 'IF INX.LOC GT TDM(REF) THEN IF NEW AND DYN EQ "N" THEN RETURN ELSE'
RTN.LNS<-ONE> = 'IF INX.LOC GT TDM(REF) THEN'
RTN.LNS<-ONE> = 'IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN'
RTN.LNS<-ONE> = 'TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR'
RTN.LNS<-ONE> = 'GOTO VTY.INP.':REG.SRT.FL:'.EXIT; * : *'
RTN.LNS<-ONE> = 'END'
*
IF NOT(SORTED) THEN
RTN.LNS<-ONE> = 'FLD = EMPTY; INX.STR = EMPTY'
END
RTN.LNS<-ONE> = '*ADD.LINE*'
*
*960602*DGH*RTN.LN = 'IF DYN EQ "I" THEN TDL(REF) = -ABS(TDL(REF)) ELSE '
RTN.LN = 'IF DYN NE "I" THEN'
RTN.LNS<-ONE> = RTN.LN
*
RTN.LNS<-ONE> = 'IF NOT(TDL(REF)) THEN TDL(REF) = ONE'
*
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'END'
*
*960602*DGH*RTN.LNS<-ONE> = '*DSP.LINE*'
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)'
RTN.LNS<-ONE> = 'IF DYN EQ "I" OR DYN EQ "N" THEN'
RTN.LNS<-ONE> = 'LN.REDISP = TRUE'
RTN.LNS<-ONE> = '*DSP.LINE*'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'VTY.INP.':REG.SRT.FL:'.EXIT: *'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'RETURN'
RTN.LNS<-ONE> = '*'
*
IF SORTED THEN
VTY.INP.SRT.FL = TRUE
END ELSE
VTY.INP.REG.FL = TRUE
END
*
END; * of first for REG / SRT
*
*
!
*
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'I':INP.LBL:'.KEY: *'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = REF.LN
RTN.LNS<-ONE> = '*':AM:'RETURN':AM:'*'
*
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'I':INP.LBL:': *'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'TDI(REF) = DCOUNT(':FLNM:LOCT:',':VTYPE.SEP:')'
RTN.LNS<-ONE> = 'TDL.REF = ':INP.NUM:'; GOSUB VTY.INP.':REG.SRT.FL:'; * : *'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF STAT THEN RETURN'
IF SORTED THEN
RTN.LNS<-ONE> = 'IF FLD EQ EMPTY THEN RETURN'
END
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = VTYPE:' = TDX(REF); INX.LOC = TDX(REF)'
*
*^^^*
*
RTN.LNS<-ONE> = '*'
IF MAX.NUM GT ONE OR NOT(SORTED) THEN
*
RTN.LNS<-ONE> = '!':AM:'*':AM:'I':INP.LBL:'.INP: *':AM:'*'
*
LINE = EMPTY
RTN.LNS<-ONE> = 'FOR SUB.REF = ':(SORTED + ONE):' TO ':MAX.NUM
*
* FOR SUB.NUM = SORTED + ONE TO MAX.NUM
FOR SUB.NUM = ONE TO MAX.NUM
LINE = LINE:'I':INP.LBL:CHAR(SUB.NUM+64):','
NEXT SUB.NUM
*
*
* RTN.LNS<-ONE> = 'SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY'
RTN.LNS<-ONE> = 'IF SUB.REF GE SUB.REF.LOC - ':SORTED + ZERO:' THEN'
RTN.LNS<-ONE> = 'ON SUB.REF GOSUB ':LINE[ONE,LEN(LINE) - ONE]
RTN.LNS<-ONE> = 'TC.FUNC = EMPTY; TC.OUT = EMPTY'
*
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
*
* IF NOT(SORTED) THEN
RTN.LNS<-ONE> = 'IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN'
RTN.LNS<-ONE> = 'IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN'
RTN.LNS<-ONE> = '*DEL.LINE*'
RTN.LNS<-ONE> = 'SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY'
RTN.LNS<-ONE> = 'IF TDX(REF) LE TDI(REF) THEN'
RTN.LNS<-ONE> = 'GOSUB D':INP.LBL
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'RETURN'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'END'
* END
*
RTN.LNS<-ONE> = 'IF STAT THEN'
RTN.LNS<-ONE> = 'IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO'
RTN.LNS<-ONE> = 'IF SUB.REF LT ':ONE + SORTED:' THEN SUB.REF = ':MAX.NUM
RTN.LNS<-ONE> = 'END'
*
* RTN.LNS<-ONE> = 'END ELSE'
* IF NOT(SORTED) THEN
* RTN.LNS<-ONE> = 'IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN'
* RTN.LNS<-ONE> = 'IF SAVE.DYN EQ "I" THEN'
* RTN.LNS<-ONE> = '*DEL.LINE*'
* RTN.LNS<-ONE> = 'RETURN'
* RTN.LNS<-ONE> = 'END'
* RTN.LNS<-ONE> = 'END'
* **END ELSE
* **RTN.LNS<-ONE> = 'IF SUB.REF EQ ONE THEN IF RSP EQ EMPTY THEN RETURN'
* END
* RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'SUB.REF.LOC = ZERO'
*
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'NEXT SUB.REF'
RTN.LNS<-ONE> = 'SUB.REF.LOC = ZERO'
*
END
*
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE'
* RTN.LNS<-ONE> = 'IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = DCOUNT(':FLNM:LOCT:',':VTYPE.SEP:')'
RTN.LNS<-ONE> = 'IF DYN EQ "I" THEN'
RTN.LNS<-ONE> = 'IF TDX(REF) LT TDI(REF) THEN'
RTN.LNS<-ONE> = 'GOSUB D':INP.LBL
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'IF NOT(STAT) THEN GOTO I':INP.LBL
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'RETURN'
RTN.LNS<-ONE> = '*'
*
* ADD
LINE = EMPTY
LINE<-ONE> = '*'
LINE<-ONE> = '!'
LINE<-ONE> = '*'
IF SORTED THEN TMP = 'S' ELSE TMP = 'A'
TMP = 'A'
LINE<-ONE> = TMP:INP.LBL:': *'
LINE<-ONE> = '*'
LINE<-ONE> = 'TDX(REF) = INX.LOC; ':VTYPE:' = TDX(REF)'
INS LINE BEFORE ADD.LNS<ONE>
ADD.LNS<-ONE> = '*'
ADD.LNS<-ONE> = 'RETURN'
*
* WRITE INX.LNS    ON SCR.FILE,SCR.ID:"*INX"
RTN.LNS<-ONE> = INX.LNS
INX.LNS = EMPTY
*
* WRITE XTR.LNS    ON SCR.FILE,SCR.ID:"*XTR"
RTN.LNS<-ONE> = XTR.LNS
XTR.LNS = EMPTY
*
WRITE ADD.LNS    ON SCR.FILE,SCR.ID:"*ADD"
RTN.LNS<-ONE> = ADD.LNS
ADD.LNS = EMPTY
*
* DELete
LINE = '*'
LINE<-ONE> = '!'
LINE<-ONE> = '*'
LINE<-ONE> = 'R':INP.LBL:': *'
LINE<-ONE> = '*'
LINE<-ONE> = 'TDX(REF) = INX.LOC; ':VTYPE:' = TDX(REF)'
INS LINE BEFORE DEL.LNS<ONE>
DEL.LNS<-ONE> = '*'
DEL.LNS<-ONE> = 'RETURN'
*
WRITE DEL.LNS    ON SCR.FILE,SCR.ID:"*DEL"
RTN.LNS<-ONE> = DEL.LNS
DEL.LNS = EMPTY
*
*
WRITE INP.LNS    ON SCR.FILE,SCR.ID:"*INP"
RTN.LNS<-ONE> = INP.LNS
INP.LNS = EMPTY
*
INP.NUM = INP.NUM + ANY.INPUT
*
* RTN.LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN
*
!
*
INPUT.CS: * SET UP SOUBROUTINE CALLING SEQUENCE
*
MAX.NUM = INP.NUM - ONE
*
LNS<-ONE> = '*':AM:'!':AM:'*'
LNS<-ONE> = 'GET.DATA: *'
LNS<-ONE> = 'NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY'
LNS<-ONE> = 'REFLN = EMPTY; SAVE.REFLN = EMPTY'
*
INP.LINE = EMPTY; DEL.LINE = EMPTY; ADD.LINE = EMPTY; CLR.LINE = EMPTY
DSP.LINE = EMPTY; INX.LINE = EMPTY; XTR.LINE = EMPTY; INP.LINE.GO = EMPTY
INP.LINE.KEY = EMPTY
*
*
IF INP.NUM THEN
*
FOR INP.NUM = ONE TO MAX.NUM
*
TMP = PMPT(INP.NUM)<ONE,ONE>
IF NOT(NUM(TMP)) THEN TMP = ZERO
*IF TMP THEN
TMP1 = (INP.NUM + 100)[TWO,TWO]
*END ELSE TMP1 = "01"
*
INP.LINE = INP.LINE:'I':TMP1:','
*
IF TMP THEN
INP.LINE.KEY = INP.LINE.KEY:'I':TMP1:'.KEY,'
DEL.LINE = DEL.LINE:'R':TMP1:','
ADD.LINE = ADD.LINE:'A':TMP1:','
INX.LINE = INX.LINE:'X':TMP1:','
XTR.LINE = XTR.LINE:'Y':TMP1:','
CLR.LINE = CLR.LINE:'C':TMP1:','
DSP.LINE = DSP.LINE:'D':TMP1:','
END ELSE
INP.LINE.KEY = INP.LINE.KEY:'ERROR,'
DEL.LINE = DEL.LINE:'ERROR,'
ADD.LINE = ADD.LINE:'ERROR,'
INX.LINE = INX.LINE:'ERROR,'
XTR.LINE = XTR.LINE:'ERROR,'
CLR.LINE = CLR.LINE:'ERROR,'
DSP.LINE = DSP.LINE:'ERROR,'
END
*
NEXT INP.NUM
*
*
INP.LINE.GO = 'ON REF GOTO ':INP.LINE[ONE,LEN(INP.LINE) - ONE]
INP.LINE = 'ON REF GOSUB ':INP.LINE[ONE,LEN(INP.LINE) - ONE]
INP.LINE.KEY = 'ON REF GOSUB ':INP.LINE.KEY[ONE,LEN(INP.LINE.KEY) - ONE]
DEL.LINE = 'ON REF GOSUB ':DEL.LINE[ONE,LEN(DEL.LINE) - ONE]
ADD.LINE = 'ON REF GOSUB ':ADD.LINE[ONE,LEN(ADD.LINE) - ONE]
INX.LINE = 'ON REF GOSUB ':INX.LINE[ONE,LEN(INX.LINE) - ONE]
XTR.LINE = 'ON REF GOSUB ':XTR.LINE[ONE,LEN(XTR.LINE) - ONE]
CLR.LINE = 'ON REF GOSUB ':CLR.LINE[ONE,LEN(CLR.LINE) - ONE]
DSP.LINE = 'ON REF GOSUB ':DSP.LINE[ONE,LEN(DSP.LINE) - ONE]
*
LNS<-ONE> = INP.LINE
LNS<-ONE> = 'NUMC = FALSE'
LNS<-ONE> = 'TC.FUNC = EMPTY; TC.OUT = EMPTY'
*
END
*
!
*
LNS<-ONE> = 'IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA'
LNS<-ONE> = 'RETURN'
LNS<-ONE> = '*':AM:'!':AM:'*'
LINE = EMPTY
*
LOOP
LOCATE '*INP.LINE.GO*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = INP.LINE.GO REPEAT
LOOP
LOCATE '*INP.LINE.KEY*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = INP.LINE.KEY REPEAT
LOOP
LOCATE '*INP.LINE*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = INP.LINE REPEAT
LOOP
LOCATE '*DEL.LINE*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = DEL.LINE REPEAT
LOOP
LOCATE '*ADD.LINE*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = ADD.LINE REPEAT
LOOP
LOCATE '*INX.LINE*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = INX.LINE REPEAT
LOOP
LOCATE '*XTR.LINE*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = XTR.LINE REPEAT
LOOP
LOCATE '*CLR.LINE*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = CLR.LINE REPEAT
LOOP
LOCATE '*DSP.LINE*' IN RTN.LNS SETTING TMP ELSE TMP = FALSE
WHILE TMP DO RTN.LNS<TMP> = DSP.LINE REPEAT
*
RETURN
*
!
*
SET.UP.READ.ITEMS: *
*
* READ.LNS = EMPTY
READ.NUM = ONE
READ.NUM.MAX = DCOUNT(READ.ITEMS,AM)
LOOP READ.ITEM = READ.ITEMS<READ.NUM> UNTIL READ.NUM GT READ.NUM.MAX DO
IF READ.ITEM NE EMPTY THEN
LINE = 'READ ':FIELD(READ.ITEM,"*",TWO):' FROM ':FIELD(READ.ITEM,"*",ONE):'.FILE,"':FIELD(READ.ITEM,"*",TWO)
READ.LNS<-ONE> = LINE:'" ELSE ':FIELD(READ.ITEM,"*",TWO):' = EMPTY'
IF TF THEN PRINT @(50,20):FIELD(READ.ITEM,"*",ONE):" ":FIELD(READ.ITEM,"*",TWO):" ":; * RQM
END
READ.NUM = READ.NUM + ONE
REPEAT
*
IF READ.LNS EQ EMPTY THEN RETURN
*
READ.LNS<-ONE> = '*':AM:'*'
LOCATE '*READ.LNS*' IN LNS SETTING LOC THEN LOC = LOC + ONE ELSE LOC = DCOUNT(LNS,AM)
INS READ.LNS BEFORE LNS<LOC>
READ.LNS = EMPTY
*
RETURN
*
!
*
ERROR.ROUTINE: * LOAD ERROR ROUTINE
*
ERR.LNS = EMPTY
*
CALL SOURCEGEN.SUBR.ERRLNS(ERR.LNS)
*
RETURN
*
!
*
EXTR.PMPT.DT: *
*
CALL SOURCEGEN.PMPT(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,KEY.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.SEP,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX,REDISP)
*
RETURN
*
!
*
SET.UP.STRINGS: *
*
CALL SOURCEGEN.SETUP.STR(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,KEY.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.SEP,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX)
*
RETURN
*
!
*
END
~SOURCEGEN.ADJ.COL~
*CODE.SEGMENT: SOURCEGEN.ADJ.COL 
* MACROSCOPE DESIGN MAXTRIX / AXION COMPUTER SYSTEMS
* APRIL 1991
*
IF TF THEN PRINT "a":
ADJ.CL = ONE; CHAR.COUNT = 0
LOOP UNTIL CHAR.COUNT = CL DO
CHAR = SCR.LN[ADJ.CL,ONE]
ADJ.CL = ADJ.CL + ONE
IF NOT(CHAR EQ SO OR CHAR EQ SI) THEN CHAR.COUNT = CHAR.COUNT + ONE
REPEAT
ADJ.CL = ADJ.CL - ONE
*
~SOURCEGEN.BG.DISP~
SUBROUTINE SOURCEGEN.BG.DISP(SCR.FILE,SCR.ID,MAT SCR.LNS,MAT LPT.LNS,BGR.LNS,MAX.REF,TEXT.AC,SIR,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,BG.C,TF,STAT)
*CODE.SEGMENT: SOURCEGEN.BG.DISP
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP SCR.LNS.DIM
*
*
!
BG.DISP: * GEN BGR.LNS
*
MAT SCR.LNS = EMPTY; BGR.LNS = EMPTY
MAT LPT.LNS = EMPTY
BGR.LNS<-ONE> = 'DISP.BG: *':AM:'*'
*960602*DGH*IF MAX.REF THEN BGR.LNS<-ONE> = 'IF NOT(REDISP) THEN MAT TDL = EMPTY; MAT TDH = EMPTY'
* BGR.LNS<-ONE> = 'PRINT @(0,0):CLS:'
*
IF TEXT.AC THEN
*
CURR.AC = TEXT.AC; PREV.LN = EMPTY
** IF TF THEN PRINT @(47,12):
*
LOOP DT = SIR<CURR.AC> UNTIL DT EQ EMPTY OR DT[ONE,ONE] EQ "*" DO
*
VC = ONE
IF TF THEN PRINT @(50,CURR.AC - TEXT.AC + 11):RVB:"b":RVE:CURR.AC - TEXT.AC + ONE:" ":
LOOP POSN = DT<ONE,VC> UNTIL POSN EQ EMPTY DO
CL = POSN<ONE,ONE,ONE>
LN = POSN<ONE,ONE,TWO>
LH = POSN<ONE,ONE,3>
TX = DT<ONE,VC + ONE>
CN = DT<ONE,VC + TWO>
IF LN EQ EMPTY THEN LN = PREV.LN ELSE PREV.LN = LN
IF LH EQ EMPTY THEN LH = LEN(TX)
SCR.LN = SCR.LNS(LN + ONE)
LTH = LEN(SCR.LN)-COUNT(SCR.LN,SO)-COUNT(SCR.LN,SI)
IF LTH LE CL THEN SCR.LN = SCR.LN:STR(" ",CL-LTH + ONE)
PMPT.TYPE = "bg"
*
BEGIN CASE
*
CASE CN = "CLL"
$INCLUDE BP.SG SOURCEGEN.ADJ.COL
SCR.LN = SCR.LN[ONE,ADJ.CL]:SPACE(80-CL)
*
CASE CN = "CLS"
$INCLUDE BP.SG SOURCEGEN.ADJ.COL
SCR.LN = SCR.LN[ONE,ADJ.CL]:SPACE(80-CL)
*
FOR LN = LN + TWO TO 23
SCR.LNS(LN) = EMPTY
NEXT LN
*
LN = DT<ONE,ONE,TWO>
*
CASE CN = "CTR"
TX = SPACE(LH / TWO - ((LEN(TX) / TWO) "0")):TX
*
CASE CN = "HDR"
CL = ZERO; LH = 80
TX = "*HDR*"
*
END CASE
*
IF LH THEN
MS = LH[ONE,ONE]; IF MS = "L" OR MS = "R" THEN LH = LH[TWO,9] ELSE MS = "L"
MS = MS:"#":LH
$INCLUDE BP.SG SOURCEGEN.ADJ.COL
SCR.LN = SCR.LN[ONE,ADJ.CL]:SO:TX MS:SI:SCR.LN[ADJ.CL+LH + ONE,999]
*
LOCATE CL IN SPOS.LOC<LN + ONE> BY "AR" SETTING SCL.LOC ELSE
IF LN GT SPOS.LOC.MAX THEN SPOS.LOC.MAX = LN; SPOS.LOC<LN + ONE> = EMPTY; SPOS.REF<LN + ONE> = EMPTY; SPOS.DISP<LN + ONE> = EMPTY
INS CL BEFORE SPOS.LOC<LN + ONE,SCL.LOC>
INS PMPT.TYPE BEFORE SPOS.REF<LN + ONE,SCL.LOC>
INS EMPTY BEFORE SPOS.DISP<LN + ONE,SCL.LOC>
END
SPOS.REF<LN + ONE,SCL.LOC> = PMPT.TYPE
SPOS.DISP<LN + ONE,SCL.LOC> = '"':TX:'" "':MS:'"'
*
END
*
SCR.LNS(LN + ONE) = SCR.LN
*
VC = VC+3
*
REPEAT
*
CURR.AC = CURR.AC + ONE
*
REPEAT
*
BGR.LNS<-ONE> = '*'
BGR.LNS<-ONE> = 'SYS11.FL = SYSTEM(11) * (SEC.USER$BF GE 10)'
BGR.LNS<-ONE> = 'IF SYS11.FL GE 3 THEN RETURN'
BGR.LNS<-ONE> = 'CLEAR = FALSE'
*
FOR LN = ZERO TO 22
LINE = SCR.LNS(LN + ONE)
IF LINE NE EMPTY THEN
POS = INDEX(LINE,"*HDR*",ONE)
IF POS THEN
LINE = SO:'":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"':SI
END
LOOP POS = INDEX(LINE,SO,ONE) WHILE POS DO LINE = LINE[ONE,POS - ONE]:'":RVB:"':LINE[POS + ONE,999] REPEAT
LOOP POS = INDEX(LINE,SI,ONE) WHILE POS DO LINE = LINE[ONE,POS - ONE]:'":RVE:"':LINE[POS + ONE,999] REPEAT
*
LINE = 'PRINT @(0,':LN:'):CLS:"':LINE:'":'
LOOP POS = INDEX(LINE,':EMPTY',ONE) WHILE POS DO LINE = LINE[ONE,POS - ONE]:LINE[POS+3,999] REPEAT
BGR.LNS<-ONE> = LINE
END
NEXT LN
*
END
*
IF BG.C NE EMPTY THEN
BGR.LNS<-ONE> = '*'
BGR.LNS<-ONE> = 'GOSUB BG.C'
BGR.LNS<-ONE> = '*'
END
*
BGR.LNS<-ONE> = 'RETURN'
*
IF TF THEN
PRINT BELL:@(0,0):CLL:@(0,23):RVB:STR("*",78):RVE:@(0,0):
* FOR TMP = 5 TO 19; PRINT @(ZERO,TMP):CLL:; NEXT TMP
* * PRINTER ON
* * PRINT FF:
* * * PRINT "   Screen generated: ":SCR.ID
* * PRINT
* * PRINTER OFF
FOR LN = ZERO TO 22
* PRINT @(ZERO,LN):CLL:RVB:SCR.LNS(LN + ONE):RVE
PRINT @(ZERO,LN):SCR.LNS(LN + ONE):RVE
* * PRINTER ON
* * PRINT LN "R#2":" ":SCR.LNS(LN + ONE)
* * PRINTER OFF
NEXT LN
PRINT @(0,1):
* * PRINTER CLOSE
END
*
*
RETURN
*
END
~SOURCEGEN.CALLS~
SUBROUTINE SOURCEGEN.CALLS(SIR,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPD.S,UPDB.C,UPDE.C,DEL.S,DELB.C,DELE.C,ID.S,IDB.C,IDE.C,READ.S,READB.C,READE.C,ABO.C,INP.C,OPE.S,OPE.C,INIT.C,DEL.TBL,TF,STAT)
*CODE.SEGMENT: SOURCEGEN.CALLS
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
*
IF TF THEN
* TMP1 = "Add  Updt Delt Key  Read Chng Type Xcl  "
* PRINT CLB:"< Set to:  ":
* FOR TMP = 3 TO 9
* PRINT @(((TMP - 3) * 7 + 10),23):TMP1[(TMP - 3) * 5 + ONE,5]:
* IF LEN(SIR<TMP>) THEN
* PRINT RVB:"*":RVE:
* END
* NEXT TMP
PRINT @(40,6):"<Calls: ":
FOR TMP = ONE TO 30 UNTIL SIR<3,TMP> EQ EMPTY
PRINT SIR<3,TMP>:" ":
NEXT TMP
RQM
END
*
ADDB.C = EMPTY; UPDB.C = EMPTY; DELB.C = EMPTY; IDB.C = EMPTY; READB.C = EMPTY
CHNGB.C = EMPTY
ADDE.C = EMPTY; UPDE.C = EMPTY; DELE.C = EMPTY; IDE.C = EMPTY; READE.C = EMPTY
CHNGE.C = EMPTY
BG.C = EMPTY; LP.C = EMPTY; FG.C = EMPTY; ABO.C = EMPTY
INP.C = EMPTY; OPE.C = EMPTY; INIT.C = EMPTY
OPE.S = FALSE; ID.S = FALSE; READ.S = FALSE; DEL.S = FALSE; UPD.S = FALSE
LP.S = FALSE
DEL.TBL = EMPTY
*
CALL.CN = ZERO
*
LOOP
*
CALL.CN = CALL.CN + ONE
CALL.NAME = SIR<3,CALL.CN>
*
WHILE CALL.NAME NE EMPTY DO
*
CALL.TEXT = SIR<4,CALL.CN>
*
BEGIN CASE
*
CASE CALL.NAME EQ "INPUT"
INP.C = CALL.TEXT
*
CASE CALL.NAME EQ "OPEN.S"
OPE.S = TRUE
*
CASE CALL.NAME EQ "OPEN"
OPE.C = CALL.TEXT
*
CASE CALL.NAME EQ "INIT"
INIT.C = CALL.TEXT
*
CASE CALL.NAME EQ "ADD" OR CALL.NAME EQ "ADDB"
ADDB.C = CALL.TEXT
*
CASE CALL.NAME EQ "ADDE"
ADDE.C = CALL.TEXT
*
CASE CALL.NAME EQ "UPD.S"
UPD.S = TRUE
*
CASE CALL.NAME EQ "UPD" OR CALL.NAME EQ "UPDB"
UPDB.C = CALL.TEXT
*
CASE CALL.NAME EQ "UPDE"
UPDE.C = CALL.TEXT
*
CASE CALL.NAME EQ "DEL.S"
DEL.S = TRUE
*
CASE CALL.NAME EQ "DEL" OR CALL.NAME EQ "DELB"
DELB.C = CALL.TEXT
*
CASE CALL.NAME EQ "DELE"
DELE.C = CALL.TEXT
*
CASE CALL.NAME EQ "KEY.S"
ID.S = TRUE
*
CASE CALL.NAME EQ "KEY" OR CALL.NAME EQ "KEYB"
IDB.C = CALL.TEXT
*
CASE CALL.NAME EQ "KEYE"
IDE.C = CALL.TEXT
*
CASE CALL.NAME EQ "READ.S"
READ.S = TRUE
*
CASE CALL.NAME EQ "READ" OR CALL.NAME EQ "READB"
READB.C = CALL.TEXT
*
CASE CALL.NAME EQ "READE"
READE.C = CALL.TEXT
*
CASE CALL.NAME EQ "CHNG" OR CALL.NAME EQ "CHNGB"
CHNGB.C = CALL.TEXT
*
CASE CALL.NAME EQ "CHNGE"
CHNGE.C = CALL.TEXT
*
CASE CALL.NAME EQ "XCL" OR CALL.NAME EQ "XCLB"
ABO.C = CALL.TEXT
*
CASE CALL.NAME EQ "BG"
BG.C = CALL.TEXT
*
CASE CALL.NAME EQ "LP.S"
LP.S = TRUE
*
CASE CALL.NAME EQ "LP"
LP.C = CALL.TEXT
*
CASE CALL.NAME EQ "FG"
FG.C = CALL.TEXT
*
CASE CALL.NAME EQ "DELETE"
DEL.TBL<-ONE> = CALL.TEXT
*
END CASE
*
REPEAT
*
RETURN
*
END
~SOURCEGEN.CUSTOM~
SUBROUTINE SOURCEGEN.CUSTOM(CALL.LNS,BG.C,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPDB.C,UPDE.C,DELB.C,DELE.C,IDB.C,IDE.C,READB.C,READE.C,ABO.C,INP.C,OPE.C,INIT.C,TF,STAT)
*CODE.SEGMENT: SOURCEGEN.CUSTOM
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
!
CUSTOM.CS: * LOAD CUSTOM CALLS
*
CALL.LNS = EMPTY
*
IF FG.C NE EMPTY THEN
CALL.LNS<-ONE> = 'FG.C: *'
CALL.LNS<-ONE> = FG.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF BG.C NE EMPTY THEN
CALL.LNS<-ONE> = 'BG.C: *'
CALL.LNS<-ONE> = BG.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
* IF LP.C NE EMPTY THEN
* CALL.LNS<-ONE> = 'LP.C: *'
* CALL.LNS<-ONE> = LP.C
* CALL.LNS<-ONE> = 'RETURN'
* CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
* END
*
IF INP.C NE EMPTY THEN
CALL.LNS<-ONE> = 'INP.C: *'
CALL.LNS<-ONE> = INP.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF OPE.C NE EMPTY THEN
CALL.LNS<-ONE> = 'OPE.C: *'
CALL.LNS<-ONE> = OPE.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF INIT.C NE EMPTY THEN
CALL.LNS<-ONE> = 'INIT.C: *'
CALL.LNS<-ONE> = INIT.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF ADDB.C NE EMPTY THEN
CALL.LNS<-ONE> = 'ADDB.C: *'
CALL.LNS<-ONE> = ADDB.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF ADDE.C NE EMPTY THEN
CALL.LNS<-ONE> = 'ADDE.C: *'
CALL.LNS<-ONE> = ADDE.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF CHNGB.C NE EMPTY THEN
CALL.LNS<-ONE> = 'CHNGB.C: *'
CALL.LNS<-ONE> = CHNGB.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF CHNGE.C NE EMPTY THEN
CALL.LNS<-ONE> = 'CHNGE.C: *'
CALL.LNS<-ONE> = CHNGE.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF UPDB.C NE EMPTY THEN
CALL.LNS<-ONE> = 'UPDB.C: *'
CALL.LNS<-ONE> = UPDB.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF UPDE.C NE EMPTY THEN
CALL.LNS<-ONE> = 'UPDE.C: *'
CALL.LNS<-ONE> = UPDE.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF DELB.C NE EMPTY THEN
CALL.LNS<-ONE> = 'DELB.C: *'
CALL.LNS<-ONE> = DELB.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF DELE.C NE EMPTY THEN
CALL.LNS<-ONE> = 'DELE.C: *'
CALL.LNS<-ONE> = DELE.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF IDB.C NE EMPTY THEN
CALL.LNS<-ONE> = 'IDB.C: *'
CALL.LNS<-ONE> = IDB.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF IDE.C NE EMPTY THEN
CALL.LNS<-ONE> = 'IDE.C: *'
CALL.LNS<-ONE> = IDE.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF READB.C NE EMPTY THEN
CALL.LNS<-ONE> = 'READB.C: *'
CALL.LNS<-ONE> = READB.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF READE.C NE EMPTY THEN
CALL.LNS<-ONE> = 'READE.C: *'
CALL.LNS<-ONE> = READE.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
IF ABO.C NE EMPTY THEN
CALL.LNS<-ONE> = 'ABO.C: *'
CALL.LNS<-ONE> = ABO.C
CALL.LNS<-ONE> = 'RETURN'
CALL.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
RETURN
!
END
~SOURCEGEN.DISPLAY~
*PROGRAM: SOURCEGEN.DISPLAY
*
$INCLUDE BP.SG SOURCEGEN.DOC.HDR
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
!
*
STAT = FALSE; ENTRY.TYPE = ZERO; OUT.FL.ID = EMPTY; SCR.ID = EMPTY
LST.END = FALSE; FIRST = TRUE
*
!
*
MAIN: *
*
LOOP
*
SIR = EMPTY; SIR.HDR = EMPTY; SIR.TEXTS = EMPTY; SIR.KEY = EMPTY
SIR.PMPT = EMPTY; FLNMS = EMPTY
*
IF NOT(LST.END) THEN
READNEXT SCR.ID THEN LST.END = FALSE ELSE LST.END = TRUE
END ELSE SCR.ID = EMPTY
!
IF SCR.ID EQ EMPTY OR FIRST THEN
CALL SOURCEGEN.INP.PARAMS(CNT.FILE,SYS.FILE,SCR.FILE.ID,SCR.FILE,OUT.FL.ID,BPF,IBPF,SCR.ID,TF,ENTRY.TYPE,DISPL.FLAG,DISPL.OPT,BASIC.FLAG,BASIC.OPT,CATLG.FLAG,CATLG.OPT,FIRST,STAT)
END
*
WHILE SCR.ID NE EMPTY AND NOT(STAT) DO
*
!
* READ SCREEN
*
READ SIR FROM SCR.FILE,SCR.ID THEN
*
CALL SOURCEGEN.LOAD(SCR.FILE,SCR.ID,TF,TEXT.AC,ID.AC,PMPT.AC,SIR.HDR,REDISP,TRANSL,ID.MAX,SIR,FIXED,SIR.TEXTS,SIR.KEY,SIR.PMPT,STAT)
*
END ELSE PRINT SCR.ID:" missing!":BELL:; SCR.ID = EMPTY; SIR = EMPTY
*
IF SCR.ID NE EMPTY THEN
*
*
IF TF THEN
PRINT @(ZERO,ZERO):CLS:
PRINT RVB:"Application Generator Output ":OUT.FL.ID:" ":SCR.ID:RVE:
PRINT CLB:"< Init : ":
END
*
FLNMS = SIR<SCR.HDR$FILE.NAME>
IF TF THEN PRINT CLB:"< Files : ":FLNMS:; * RQM 
*
ALLOWED = SIR<SCR.HDR$ALLOWED>; IF ALLOWED EQ EMPTY THEN ALLOWED = "ACD"
IF TF THEN PRINT CLB:"< Allowed functions are: ":ALLOWED:" >":; * RQM
*
NO.DIM = SIR<SCR.HDR$NO.EQUATES>
*
CALL SOURCEGEN.CALLS(TF,SIR,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,UPD.S,UPDB.C,UPDE.C,DEL.S,DELB.C,DELE.C,ID.S,IDB.C,IDE.C,READ.S,READB.C,READE.C,ABO.C,INP.C,OPE.S,OPE.C,INIT.C,STAT)
*
SCRN.TYPE = SIR<SCR.HDR$SCREEN.TYPE>
IF SCRN.TYPE EQ EMPTY THEN SCRN.TYPE = "PSI"
IF INDEX(SCRN.TYPE,"S",ONE) THEN SBR = TRUE ELSE SBR = FALSE
SBR.F = EMPTY; SBR.LINE = EMPTY
IF TF THEN PRINT CLB:"< Rtn type : ":SCRN.TYPE:" >":; * RQM 
*
RELEASE.ID = SIR<SCR.HDR$RELEASE>
IF TF THEN PRINT CLB:"< Release : ":RELEASE.ID:" >":; * RQM 
*
INPUT.TYPE = SIR<SCR.HDR$INPUT.TYPE>
IF TF THEN PRINT CLB:"< Input Type : ":INPUT.TYPE:" >":; * RQM
*
*
* SPLIT 19 APR 91
* DGH
*
*
*
IF TF THEN PRINT CLB:"<Start : ":; * RQM
*
LNS = EMPTY
* * CALL SOURCEGEN.START(TOP.LNS,SCR.ID,RELEASE.ID,INP.C,SBR,STAT)
* * LNS<-ONE> = TOP.LNS
*
IF TF THEN PRINT CLB:"<Opens : ":; * RQM
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CALL SOURCEGEN.OPEN(IBPF,EQF.FILE,MAT EQT,MAT EQF,EQT.F,EQF.MAX,EQF.IND,INIT.LNS,OPEN.LNS,DIM.LNS,EQU.LNS,FLNMS,ID,SCR.ID,SBR,SBR.F,SBR.LN,TF,CO.DATA,NO.DIM,REC.FL,KEY.FL,OPE.C,OPE.S,INIT.C,STAT)
LNS<-ONE> = INIT.LNS
CO.NAME = CO.DATA<ONE,ONE>
*
IF TF THEN PRINT CLB:"<Refs : ":; * RQM 
ID = FLNMS<ONE,ONE>:".ID"
CALL SOURCEGEN.VALID.REFS(REF.LNS,MAX.REF,PMPT.AC,SIR,TF,POS.LOC,POS.REF,POS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,STAT)
LNS<-ONE> = REF.LNS
*
IF TF THEN PRINT CLB:"<Main : ":; * RQM 
* * CALL SOURCEGEN.MAINLINE(MAIN.LNS,ID,ID.MAX,ID.AC,ID.S,IDB.C,IDE.C,MAT EQT,READB.C,READE.C,FIXED,ALLOWED,NO.DIM,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,MAX.REF,MSG,DELB.C,DELE.C,UPDB.C,UPDE.C,ABO.C,INP.C,OPE.C,INIT.C,FLNMS,READ.S,DEL.S,UPD.S,STAT)
* * LNS<-ONE> = MAIN.LNS
*
READ SCR.PG FROM PAR.FILE,SCR.ID:"*BGM" ELSE SCR.PG = EMPTY
*
!
*
PRINT @(ZERO,ZERO):CLS:
LN.MAX = DCOUNT(SCR.PG,AM)
LN = -ONE
LOOP
LN = LN + ONE
PRINT @(ZERO,LN):SCR.PG<LN + ONE>:
WHILE LN LT LN.MAX DO
PRINT
REPEAT
*
PRINT @(0,23):SCR.ID "L#15":
INPUT RSP:
*
!
*
END; * of id not blank
*
!
*
REPEAT
*
!
*
STOP
*
*
* * IF TF THEN PRINT CLB:"<Back : ":; * RQM 
**********************
END
~SOURCEGEN.DOC.HDR~
*CODE.SEGMENT: SOUCREGEN.DOC.HDR 
*
* NO OPeration performed - DOCumentation
*
* AUTHORS:  DAVID G. HORSMAN - MACROSCOPE DESIGN MATRIX
*           BOB CONARROE     - AXION
*           DAVID STERN      - AXION
*
* DESCRIPTION: Inputs the following parameters:
* ITEM ID
* INPUT FILE (SCREENS)
* OUTPUT FILE (BP)
* TRACE ON (NO)
*
* Loads Screen Description tables
* Generate Data Basic Source Code
* Member of SEARCH & RELease MaNaGment
*
~SOURCEGEN.INCL.START~
*CODE.SEGMENT: SOURCEGEN.INCL.START
*
* DAVID HORSMAN
TOP.LNS<-1> = '*PROGRAM:            SH.':SCREEN.ID
TOP.LNS<-1> = '* AUTHOR:            XXX'
TOP.LNS<-1> = '* DESCRIPTION:       GEN BY "SOURCEGEN" FROM "SCREEN.HANDLER"'
TOP.LNS<-1> = '* DATE WRITTEN:      ':OCONV(DATE(),"D2")
TOP.LNS<-1> = '* DATE RELEASED:     DD MMM YY'
TOP.LNS<-1> = '*       RELEASE:     ':RELEASE.ID
TOP.LNS<-1> = '* MODIFICATIONS:     DATE       NAME        DESCRIPTION'
TOP.LNS<-1> = '*                    DD MMM YY'
TOP.LNS<-1> = '!'
TOP.LNS<-1> = '*'
TOP.LNS<-1> = '$INCL':'UDE IBP STANDARD.FUNCTIONS'
TOP.LNS<-1> = '*'
TOP.LNS<-1> = 'VERSION = "(':RELEASE.ID:')"'
TOP.LNS<-1> = '*'
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
INPUT AUTO.RUN:
*INPUT.END*
*
*
SCR.ID = "MAINT.SG.TEXTS"
RELEASE.ID = "1.0"
REF = ONE; REDISP = FALSE; PRINTER.FLAG = FALSE; NEW = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO; NUMC = FALSE
*
OPEN "COM" TO COM.FILE ELSE
PRINT CLB:"COM File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "CNT" TO CNT.FILE ELSE
PRINT CLB:"CNT File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "PAR" TO PAR.FILE ELSE
PRINT CLB:"PAR File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:"ACC File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
~SOURCEGEN.INP.PARAMS~
SUBROUTINE SOURCEGEN.INP.PARAMS(CNT.FILE,SYS.FILE,SCR.FILE.ID,SCR.FILE,OUT.FL.ID,BPF,IBPF,SCR.ID,TF,ENTRY.TYPE,DISPL.FLAG,DISPL.OPT,BASIC.FLAG,BASIC.OPT,CATLG.FLAG,CATLG.OPT,FIRST,STAT)
*CODE.SEGMENT: SOURCEGEN.INP.PARAMS
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
!
*
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; STAT = 999; STOP
OPEN "SYS" TO SYS.FILE ELSE PRINT CLB:"Can't open SYS":; STAT = 999; STOP
*
!
*
IF SCR.ID EQ EMPTY OR FIRST THEN
*
READ TMP FROM SYS.FILE,"SOURCEGEN.DISPL.FLAG" ELSE TMP = EMPTY
DISPL.FLAG = TMP<ONE>
DISPL.OPT  = TMP<TWO>
IF NOT(NUM(DISPL.FLAG)) THEN DISPL.FLAG = TRUE
*
READ TMP FROM SYS.FILE,"SOURCEGEN.BASIC.FLAG" ELSE TMP = EMPTY
BASIC.FLAG = TMP<ONE>
BASIC.OPT  = TMP<TWO>
IF NOT(NUM(BASIC.FLAG)) THEN BASIC.FLAG = TRUE
*
READ TMP FROM SYS.FILE,"SOURCEGEN.CATLG.FLAG" ELSE TMP = EMPTY
CATLG.FLAG = TMP<ONE>
CATLG.OPT  = TMP<TWO>
IF NOT(NUM(CATLG.FLAG)) THEN CATLG.FLAG = TRUE
*
PRINT
PRINT "Enter entry type (0,1,2): ":
* 0 - Exhaust list then prompt for item
* 1 - Input from loaded proc buffer
* 2 - Autorun
* 3 - Exhaust list only
*
INPUT ENTRY.TYPE:
IF NOT(NUM(ENTRY.TYPE)) THEN ENTRY.TYPE = ZERO
PRINT
IF ENTRY.TYPE EQ TWO THEN AUTO.RUN = TRUE ELSE AUTO.RUN = FALSE
*
PRINT
PRINT "Enter screen file name: ":
INPUT SCR.FILE.ID:
PRINT
TMP = FALSE
IF NOT(LEN(SCR.FILE.ID)) THEN SCR.FILE.ID = "SCREENS"; TMP = TRUE
IF ENTRY.TYPE THEN TMP = TRUE
IF TMP THEN PRINT "Will use ":SCR.FILE.ID:
PRINT
OPEN SCR.FILE.ID TO SCR.FILE ELSE PRINT "Can't open ":SCR.FILE.ID; STOP
*
!
*
PRINT
PRINT "Enter output file name: ":
INPUT OUT.FL.ID:
PRINT
TMP = FALSE
IF NOT(LEN(OUT.FL.ID)) THEN OUT.FL.ID = "BP"; TMP = TRUE
IF ENTRY.TYPE THEN TMP = TRUE
IF TMP THEN PRINT "Will use ":OUT.FL.ID
PRINT
OPEN OUT.FL.ID TO BPF ELSE
PRINT "Can't open ":OUT.FL.ID
IF OUT.FL.ID EQ "BP" THEN
OUT.FL.ID = ACCT:".BP"
PRINT "Will use ":OUT.FL.ID
END
OPEN OUT.FL.ID TO BPF ELSE
PRINT "Can't open ":OUT.FL.ID; STOP
END
END
*
!
*
* IBP
PRINT
PRINT "Enter include file name: ":
INPUT OUT.IBP.ID:
PRINT
*
TMP = FALSE
IF ENTRY.TYPE THEN TMP = TRUE
*
IF NOT(LEN(OUT.IBP.ID)) THEN
TMP = TRUE
* check 1st
TEMP = FIELD(OUT.FL.ID,".",ONE)
*
IF TEMP = "BP" THEN
OUT.IBP.ID = "I":OUT.FL.ID
END ELSE
* check 2nd
TEMP = FIELD(OUT.FL.ID,".",TWO)
*
IF TEMP EQ "BP" THEN
OUT.IBP.ID = OUT.FL.ID[ONE,COL1()]:"I":OUT.FL.ID[COL1() + ONE,999]
END ELSE
* check 3rd
TEMP = FIELD(OUT.FL.ID,".",3)
IF TEMP EQ "BP" THEN
OUT.IBP.ID = OUT.FL.ID[ONE,COL1()]:"I":OUT.FL.ID[COL1() + ONE,999]
END ELSE OUT.IBP.ID = "IBP"
END; * of 2nd "." is BP or 3rd
*
END; * of 1st "." is BP or 2nd
*
END; * of IBP is empty
*
IF TMP THEN PRINT "Will use ":OUT.IBP.ID
*
!
*
OPEN OUT.IBP.ID TO IBPF ELSE
PRINT "Can't open ":OUT.IBP.ID
IF OUT.IBP.ID NE "IBP" THEN
OUT.IBP.ID = "IBP"
PRINT "Will use ":OUT.IBP.ID
OPEN OUT.IBP.ID TO IBPF ELSE PRINT "Can't open ":OUT.IBP.ID; STOP
END
END
*
INP.TF = TRUE
*
END ELSE
*
INP.TF = FALSE
*
END; * of SCR.ID is empty
*
!
*
IF NOT(SCR.ID EQ EMPTY) THEN
PRINT
PRINT "Screen: ":SCR.ID
PRINT
END ELSE
*
IF ENTRY.TYPE LT TWO THEN
PRINT
PRINT "Enter screen to be generated: ":
INPUT SCR.ID:
IF ENTRY.TYPE EQ ONE THEN PRINT SCR.ID:
PRINT
PRINT
END ELSE SCR.ID = EMPTY
*
END; * of lst.end
*
IF SCR.ID EQ "LIST" THEN SCR.ID = EMPTY; INP.TF = FALSE; TF = TRUE
*
!
*
IF INP.TF THEN
PRINT "Enter 1 for progress display: ":
INPUT TF
IF TF EQ "LIST" THEN TF = TRUE
IF NOT(NUM(TF)) THEN TF = FALSE
PRINT
PRINT
END
*
IF SCR.ID EQ EMPTY THEN PRINT "NO SCREEN"; STOP
*
RETURN
*
END
~SOURCEGEN.KEY~
SUBROUTINE SOURCEGEN.KEY(KEY.LNS,MAT EQF,TF,SIR,IDB.C,IDE.C,FIXED,ID.MAX,EQF.IND,ID.AC,ID,REDISP,FLNMS,MAT EQT,EQ.F,READ.ITEMS,NO.DIM,REC.FL,KEY.FL,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,ID.S,TRN.NUM,SCR.ID,STAT)
*CODE.SEGMENT: SOURCEGEN.KEY
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
$INCLUDE IBP DCT.EQUATES
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
!
*
ID.INPUT: * GET THE KEY
*
*
** IF TF THEN PRINT @(40,11):'<Keys: ':
KEY.LNS = EMPTY; TMP.LNS = EMPTY; TRN.LNS = EMPTY; TRANSL = FALSE
CAT.LNS = EMPTY
FIXED.FL = TRUE
*
IF ID.S AND NOT(LEN(IDB.C) OR LEN(IDE.C)) THEN RETURN
*
KEY.LNS<-ONE> = '*':AM:'!':AM:'*':AM:'GET.KEY: *':AM:'*':AM:'STAT = ZERO':AM:'*'
*
IF IDB.C NE EMPTY THEN
IF TF THEN PRINT @(70,11):RVB:"<call>":RVE:
KEY.LNS<-ONE> = 'GOSUB IDB.C'
KEY.LNS<-ONE> = '*':AM:'*'; *
END; * of not a key call *
*
IF NOT(ID.S) THEN
*
KEY.FLNM.SET = FALSE; KEY.FLNM = EMPTY; KEY.ITNM = 'ID'
*
IF FIXED AND ID.MAX EQ ID.AC THEN
IF TF THEN PRINT @(70,12):RVB:"<fixed> ":RVE:
KEY.LNS<-ONE> = EMPTY:ID:' = "':SIR<ID.AC,ONE,ONE>[TWO,999]:'"'
KEY.LNS<-ONE> = ID:'.SAVE<ONE> = "':SIR<ID.AC,ONE,ONE>[TWO,999]:'"'
KEY.FL<ONE,FL> = ID.AC
END ELSE
*
* : * Multiple Field Key
*
IF ID.AC THEN
*
*
REF.AC = ZERO
*
LINE = 'ON ID.CN GOSUB '
*
** IF TF THEN PRINT @(47,11):'<f ':
FOR TMP = ID.AC TO ID.MAX
IF TF THEN PRINT @(70,(TMP - ID.AC + 11)):RVB:"k":RVE:TMP - ID.AC + ONE:
** IF TF THEN PRINT TMP - ID.AC + ONE:" ":
IF SIR<TMP,ONE,TWO>[ONE,ONE] NE "*" THEN
IF REF.AC GT ZERO THEN LINE = LINE:','
REF.AC = REF.AC + ONE
* was TMP - ID.AC + ONE
LINE = LINE:'K':(REF.AC) + 100 "R#2"
END
NEXT TMP
KEY.MAX = REF.AC + ZERO
*
IF NOT(REF.AC) THEN REF.AC = ONE
KEY.LNS<-ONE> = 'FOR ID.CN = ONE TO ':KEY.MAX
* KEY.LNS<-ONE> = 'STAT = FALSE'
KEY.LNS<-ONE> = LINE
KEY.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
KEY.LNS<-ONE> = 'IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE'
*
* KEY.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN ID.CN = ':ID.MAX - ID.AC + ONE
KEY.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN'
*
* : * Key field loop
*
FIRST.AC = ID.AC
LAST.AC = ID.MAX
CURR.AC = FIRST.AC; FIRST.INP = ZERO; TMP.LNS = EMPTY
REF.AC = FIRST.AC
** IF TF THEN PRINT @(47,11):'<fs ':
*
LOOP
*
INPUT.REQD = FALSE
*
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
TMP.ID = ID
IF FLNM NE "" THEN TMP.ID = FLNM
*
*
EXTR = '<':REF.AC - ID.AC + ONE:'>'
*
UNTIL DT EQ EMPTY OR DT[ONE,ONE] EQ '*' DO
*
IF TF THEN PRINT @(70,(CURR.AC - ID.AC + 11)):RVB:"K":RVE:CURR.AC - ID.AC + ONE:
*
IF SIR<CURR.AC + ONE,ONE,TWO>[ONE,ONE] EQ '*' THEN TRANSL = TRUE ELSE TRANS = FALSE
*
TMP.LNS<-ONE> = 'K':(REF.AC - ID.AC + ONE) + 100 "R#2":': *'
*
IF INPUT.REQD THEN
TMP.LNS<-ONE> = 'IF STAT LT ZERO THEN RETURN'
END ELSE
TMP.LNS<-ONE> = 'STAT = ZERO'
END
*
*
*960525*DGH*IF FIXED AND ID.MAX EQ ID.AC THEN
IF DT[ONE,ONE] EQ '.' THEN
IF TF THEN PRINT @(70,12):RVB:"<fixed> ":RVE:
***TMP.LNS<-ONE> = EMPTY:TMP.ID:' = "':SIR<CURR.AC,ONE,ONE>[TWO,999]:'"'
***TMP.LNS<-ONE> = TMP.ID:'.SAVE<':REF.AC - ID.AC + ONE:'> = "':SIR<CURR.AC,ONE,ONE>[TWO,999]:'"'
TMP.LNS<-ONE> = EMPTY:'RSP = "':SIR<CURR.AC,ONE,ONE>[TWO,999]:'"'
TMP.LNS<-ONE> = 'FLD = RSP'
*
*
END ELSE IF INPUT.REQD THEN
*
FIXED.FL = FALSE
IF NOT(FIRST.INP) THEN FIRST.INP = REF.AC - ID.AC + ONE
*
IF LOCN EQ '0' THEN LOCN = '1'
*
* * IF CURR.AC GT ID.AC THEN
LINE = 'FLD = ':TMP.ID:'.SAVE<':REF.AC - ID.AC + ONE:'>':AM; TMP1 = 'RSP'; TMP = 'FLD'
* *IF LOCN EQ '0' THEN LOCN = '1'
* * END ELSE
*
IF CURR.AC EQ ID.AC THEN
IF NOT(KEY.FLNM.SET) THEN
KEY.FLNM.SET = TRUE
* IF AC THEN
* KEY.FLNM = FLNM
* END ELSE
* KEY.FLNM = FIELD(FLNM,'.',ONE)
* END
KEY.FLNM = FLNM
KEY.FLNM = FIELD(FLNM,"$",ONE)
* IF REC.FL<ONE,VC> THEN KEY.FLNM = FIELD(KEY.FLNM,'.',ONE)
END
* * LINE = EMPTY; TMP1 = FLNM; TMP = FLNM
END; * of CURR.AC EQ AC
*
LINE = LINE:'CALL INPUT.DATA.SG1("':KEY.FLNM:'","':KEY.ITNM:'",':TMP:',':CL:',':LN:',"':MS[ONE,ONE]:MS[3,9]:'","':LHM:'",1,"'
TMP.LNS<-ONE> = LINE:CONV:'","':EDIT:'",':EDIT.FILE:',RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",':FXD:',"0",TC.FUNC,':CL:',':LN:',".",STD.SUBR.NAME,PROCBUF,STAT)'
*
TMP.LNS<-ONE> = 'IF STAT THEN RETURN'
*
IF TRANSL THEN
* TMP.LNS<-ONE> = 'IF STAT THEN RETURN ELSE LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
TMP.LNS<-ONE> = 'LN = ':LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
END
*
* TMP.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
* TMP.LNS<-ONE> = 'IF ':TMP1:' EQ EMPTY THEN ':TMP.ID:' = EMPTY; RETURN'
* TMP.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN ID.CN = ':ID.MAX - ID.AC + ONE
* TMP.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN'
*
END; * of INPUT.REQD
*
!
*
IF DT[ONE,ONE] EQ "'" THEN
*
TMP.LNS<-ONE> = SIR<CURR.AC,ONE,ONE>[TWO,9999]
*
END ELSE
*
* IF CURR.AC GT ID.AC THEN TMP = 'RSP' ELSE TMP = TMP.ID
TMP = 'RSP'
IF PMPT.RSP NE EMPTY THEN TMP = PMPT.RSP
IF DT[ONE,ONE] EQ '.' THEN TMP = '"':SIR<CURR.AC,ONE,ONE>[TWO,9999]:'"'
*
** IF CURR.AC GT ID.AC THEN
** LINE = TMP.ID:' = ':TMP.ID:':':TMP
** END ELSE LINE = TMP.ID:' = ':TMP
** *
** LINE = LINE:'; ':
LINE = TMP.ID:'.SAVE<':REF.AC - ID.AC + ONE:'> = ':TMP
TMP.LNS<-ONE> = LINE
*
END; * of not "'"
*
*
* IF PMPT.RSP EQ EMPTY THEN TMP.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
IF REDISP THEN TMP.LNS<-ONE> = 'GOSUB DISP.BG; GOSUB DISP.FG'; REDISP = ZERO
*
TMP.LNS<-ONE> = 'RETURN':AM:'*'
*
!
*
IF INPUT.REQD THEN
*
LOCATE CL IN SPOS.LOC<LN + ONE> BY "AR" SETTING SCL.LOC ELSE
IF LN GT SPOS.LOC.MAX THEN SPOS.LOC.MAX = LN; SPOS.LOC<LN + ONE> = EMPTY; SPOS.REF<LN + ONE> = EMPTY; SPOS.DISP<LN + ONE> = EMPTY
INS CL BEFORE SPOS.LOC<LN + ONE,SCL.LOC>
INS 'key' BEFORE SPOS.REF<LN + ONE,SCL.LOC>
INS EMPTY BEFORE SPOS.DISP<LN + ONE,SCL.LOC>
END
*
DISP.LN = TMP.ID:'.SAVE'
*
DISP.LN = DISP.LN:EXTR
*
IF SB NE EMPTY THEN DISP.LN = 'FIELD(':DISP.LN:',"':SB[ONE,ONE]:'",':SB[TWO,TWO]:')'
IF CONV[ONE,ONE] = "D" OR CONV[ONE,ONE] = "M" THEN DISP.LN = 'OCONV(':DISP.LN:',"':CONV:'")'
LINE = 'PRINT @(':CL:',':LN:'):':DISP.LN:' "':MS:'":'
SPOS.DISP<LN + ONE,SCL.LOC> = DISP.LN:' "':MS:'"'
IF TF AND (LN OR CL) AND LH THEN PRINT @(CL,LN):RVB:STR("#",LH):RVE:; * RQM
*
END; * of INPUT.REQD
*
IF TRANSL THEN
$INCLUDE BP.SG SOURCEGEN.TRANSL
TMP.LNS<-ONE> = TRN.LNS
TRN.LNS = EMPTY
TMP.LNS<-ONE> = '*':AM:'*'
END
*
!
*
IF DT[ONE,ONE] NE "'" THEN
*
CAT.LNS<-ONE> = TMP.ID:' = ':TMP.ID:':':TMP.ID:'.SAVE<':(REF.AC - ID.AC + ONE):'>'
*
IF NOT(KEY.FL<ONE,FL>) THEN
TMP = TMP.ID:' = EMPTY'
INS TMP BEFORE CAT.LNS<ONE>
END
*
END; * of "'"
*
!
*
KEY.FL<ONE,FL> = CURR.AC
*
CURR.AC = CURR.AC + ONE
REF.AC = REF.AC + ONE
IF TRANSL THEN
TRANSL = FALSE; CURR.AC = CURR.AC + ONE
END
*
REPEAT
* : * Key field repeat
*
**KEY.LNS<-ONE> = 'IF ID.CN EQ ':FIRST.INP:' AND ':TMP.ID:'.SAVE<':FIRST.INP:'> EQ EMPTY THEN STAT = 999'
KEY.LNS<-ONE> = 'IF ID.CN EQ ':FIRST.INP:' AND ':ID:'.SAVE<':FIRST.INP:'> EQ EMPTY THEN STAT = 999'
KEY.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
KEY.LNS<-ONE> = 'NEXT ID.CN'
KEY.LNS<-ONE> = '*'
*
KEY.LNS<-ONE> = CAT.LNS
*** VC = ONE
*** *
*** LOOP WHILE KEY.FL<ONE,VC> DO
*** *
*** KEY.LNS<-ONE> = 'FOR ID.CN = ONE TO ':KEY.MAX
*** **KEY.LNS<-ONE> = 'IF ID.CN EQ ONE THEN ':TMP.ID:' = ':TMP.ID:'.SAVE<ID.CN> ELSE ':TMP.ID:' = ':TMP.ID:':':TMP.ID:'.SAVE<ID.CN>'
*** KEY.LNS<-ONE> = 'IF ID.CN EQ ONE THEN ':ID:' = ':ID:'.SAVE<ID.CN> ELSE ':ID:' = ':ID:':':ID:'.SAVE<ID.CN>'
*** KEY.LNS<-ONE> = 'NEXT ID.CN'
*** KEY.LNS<-ONE> = '*'
*** *
*** VC = VC + ONE
*** *
*** REPEAT
*
!
*
END; * of not a fixed.key
*
END; * of ID.AC
*
END; * of not(id.s)
*
FIXED = FIXED.FL
*
IF IDE.C NE EMPTY THEN
KEY.LNS<-ONE> = '*'
KEY.LNS<-ONE> = 'GOSUB IDE.C'
KEY.LNS<-ONE> = '*':AM:'*'; *
END
*
KEY.LNS<-ONE> = '* ULT ONLY'
KEY.LNS<-ONE> = 'EXEC.VERB = "ACC.UPDATE"'
KEY.LNS<-ONE> = '* ULT ONLY'
KEY.LNS<-ONE> = 'EXEC.IN = "+Rtn:':SCR.ID:' +Itm:":':TMP.ID
KEY.LNS<-ONE> = '* ULT ONLY'
KEY.LNS<-ONE> = 'EXE':'CUTE EXEC.VERB, /':'/':'IN':'. < EXEC.IN'
KEY.LNS<-ONE> = 'EXEC.VERB = EMPTY'
KEY.LNS<-ONE> = '*'
KEY.LNS<-ONE> = '*'
*
KEY.LNS<-ONE> = 'RETURN'
*
IF LEN(TMP.LNS) THEN
KEY.LNS<-ONE> = '*':AM:'!':AM:'*'
KEY.LNS<-ONE> = TMP.LNS
END
*
RETURN; * to CALLING rtn
*
!
*
EXTR.PMPT.DT: *
*
CALL SOURCEGEN.PMPT(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,KEY.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.SEP,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX,REDISP)
*
RETURN
*
*
END
~SOURCEGEN.LOAD~
SUBROUTINE SOURCEGEN.LOAD(SCR.FILE,SCR.ID,TF,TEXT.AC,ID.AC,PMPT.AC,SIR.HDR,REDISP,TRANSL,ID.MAX,SIR,FIXED,SIR.TEXTS,SIR.KEY,SIR.PMPT,STAT)
*CODE.SEGMENT: SOURCEGEN.LOAD
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
IF TF THEN PRINT @(40,15):'<ItemStruct>':; RQM
*
SIR.AC.MAX = DCOUNT(SIR,AM)
*
* TEXTS
*
READ SIR.TEXTS FROM SCR.FILE,SCR.ID:'*TEXTS' THEN
TEXT.AC = ONE
END ELSE
LOCATE '*TEXTS' IN SIR SETTING TEXT.AC THEN
SIR.TEXTS = EMPTY; CN = TEXT.AC + ONE
LOOP WHILE CN LE SIR.AC.MAX AND SIR<CN>[ONE,ONE] NE '*' DO
SIR.TEXTS<-ONE> = SIR<CN>
CN = CN + ONE
REPEAT
END ELSE TEXT.AC = ZERO; SIR.TEXTS = EMPTY
END
*
* KEY
*
READ SIR.KEY FROM SCR.FILE,SCR.ID:'*KEYS' THEN
ID.AC = ONE
END ELSE
LOCATE '*KEY' IN SIR SETTING ID.AC THEN
ID.AC = ID.AC + ONE; SIR.KEY = EMPTY; CN = ID.AC
LOOP WHILE CN LE SIR.AC.MAX AND SIR<CN>[ONE,ONE] NE '*' DO
SIR.KEY<-ONE> = SIR<CN>
CN = CN + ONE
REPEAT
END ELSE ID.AC = ZERO; SIR.KEY = EMPTY
END
*
* PROMPTS
*
READ SIR.PMPT FROM SCR.FILE,SCR.ID:'*PROMPTS' THEN
PMPT.AC = ONE
END ELSE
LOCATE '*PROMPTS' IN SIR SETTING PMPT.AC THEN
SIR.PMPT = EMPTY; CN = PMPT.AC + ONE
LOOP WHILE CN LE SIR.AC.MAX AND SIR<CN>[ONE,ONE] NE '*' DO
SIR.PMPT<-ONE> = SIR<CN>
CN = CN + ONE
REPEAT
END ELSE PMPT.AC = ZERO; SIR.PMPT = EMPTY
END
*
* SCREEN HEADER
*
READ SIR.HDR FROM SCR.FILE,SCR.ID:'*HDR' THEN
HDR.AC = ONE
END ELSE
IF SIR EQ EMPTY THEN STAT = TRUE; RETURN
SIR.HDR = EMPTY; HDR.AC = ONE; CN = ONE
LOOP WHILE CN LE SIR.AC.MAX AND SIR<CN>[ONE,ONE] NE '*' AND CN LT 20 DO
SIR.HDR = SIR.HDR:SIR<CN>:AM
CN = CN + ONE
REPEAT
* IF SIR.HDR<3> EQ EMPTY OR SIR.HDR<4> EQ EMPTY AND NOT(DCOUNT(SIR.HDR<3>,VM)) THEN
* SIR.HDR.3 = EMPTY
* SIR.HDR.4 = EMPTY
* FOR CN = 3 TO 10
* IF CN NE 9 THEN
* IF SIR.HDR<CN> NE EMPTY THEN
* SIR.HDR.3<ONE,-ONE> = FIELD("*ADD*UPD*DEL*KEY*READ*CHNG*?*XCL*","*",CN - ONE)
* SIR.HDR.4<ONE,-ONE> = SIR.HDR<CN>
* SIR.HDR<CN> = EMPTY
* END
* END
* NEXT CN
* SIR.HDR<3> = SIR.HDR.3
* SIR.HDR<4> = SIR.HDR.4
* END
END
*
* Process results
*
!
*
SIR = EMPTY
SIR<-ONE> = SIR.HDR
SIR<20> = '*TEXTS'
SIR<-ONE> = SIR.TEXTS
SIR<-ONE> = '*KEY'
SIR<-ONE> = SIR.KEY
SIR<-ONE> = '*PROMPTS'
SIR<-ONE> = SIR.PMPT
*
!
*
REDISP = ZERO; TRANSL = ZERO
*
LOCATE '*TEXTS' IN SIR SETTING TEXT.AC THEN TEXT.AC = TEXT.AC + ONE ELSE PRINT 'Primary definition *TEXTS is missing!':; STOP
LOCATE '*PROMPTS' IN SIR SETTING PMPT.AC THEN PMPT.AC = PMPT.AC + ONE ELSE PRINT 'Primary definition *PROMPTS is missing!':; STOP
*
IF NOT(ID.AC) THEN FIXED = FALSE; ID.MAX = 0 ELSE
*
LOCATE '*KEY' IN SIR SETTING ID.AC THEN
ID.MAX = ID.AC; ID.AC = ID.AC + ONE; FIXED = ID.AC
LOOP ID.MAX = ID.MAX + ONE WHILE SIR<ID.MAX> NE EMPTY AND SIR<ID.MAX>[ONE,ONE] NE '*' DO
IF SIR<ID.MAX>[ONE,ONE] NE '.' AND SIR<ID.MAX>[ONE,ONE] NE ',' THEN FIXED = FALSE
REPEAT
ID.MAX = ID.MAX - ONE
*END ELSE ID.AC = ZERO; ID.MAX = ZERO; FIXED = TRUE
END ELSE PRINT 'Primary definition *KEYS is missing!':; STOP
END
*
RETURN
*
END
~SOURCEGEN.LP.DISP~
SUBROUTINE SOURCEGEN.LP.DISP(SCR.FILE , BPF.FILE , SCR.ID , MAT SCR.LNS , MAT LPT.LNS , SLP.LNS , MAX.REF , TEXT.AC , SIR , SPOS.LOC , SPOS.REF , SPOS.LOC.MAX , SPOS.DISP , LP.C , TF , SBR.WR.FL , SBR.LN , DIM.LNS , EQU.LNS , REF.LNS , STAT)
*CODE.SEGMENT: SOURCEGEN.LP.DISP
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* SEPT 91
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP SCR.LNS.DIM
*
!
*
LP.DISP: * GEN SLP.LNS
*
SLP.LNS = EMPTY; OUT.LNS = EMPTY
*
IF TF THEN PRINT @(7,ZERO):RVB:"c ":RVE:
IF SBR.WR.FL THEN
*
OUT.LNS<-ONE> = 'SUBROUTINE SH.SUBR.LPT.':SCR.ID:'(':SBR.LN:')'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP STANDARD.FUNCTIONS.SUBR'
OUT.LNS<-ONE> = '*OVERRIDE'
*
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.DIM'
OUT.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.EQUATES'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP PAR.MENU.DIM'
OUT.LNS<-ONE> = '$INCL':'UDE IBP PAR.MENU.EQUATES'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.ON'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP CNT.TST.DIM'
OUT.LNS<-ONE> = '$INCL':'UDE IBP CNT.TST.EQUATES'
OUT.LNS<-ONE> = '*'
*
INIT.LNS = EMPTY
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*DIM.LNS*'
IF DIM.LNS NE EMPTY THEN
INIT.LNS<-ONE> = DIM.LNS
END
INIT.LNS<-ONE> = 'DIM STD(50); MAT STD = EMPTY'
INIT.LNS<-ONE> = '*DIM.END*'
*
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*EQU.LNS*'
IF EQU.LNS NE EMPTY THEN
INIT.LNS<-ONE> = EQU.LNS
END
INIT.LNS<-ONE> = '$INCL':'UDE IBP STANDARD.FUNCTIONS.CLB'
INIT.LNS<-ONE> = '*EQU.END*'
*
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*REF.LNS*'
IF REF.LNS NE EMPTY THEN
INIT.LNS<-ONE> = REF.LNS
END
INIT.LNS<-ONE> = '*REF.END*'
INIT.LNS<-ONE> = '*'
*
OUT.LNS<-ONE> = INIT.LNS
*
OUT.LNS<-ONE> = 'CO.NAME = CO.DATA<ONE>'
*
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '!'
OUT.LNS<-ONE> = '*'
*
END
*
!
*
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = 'IF LPT.FL THEN'
OUT.LNS<-ONE> = 'CALL LPT.SUBR.ON(LPT.STAT)'
OUT.LNS<-ONE> = 'END'
OUT.LNS<-ONE> = '*'
*
OUT.LNS<-ONE> = 'IF LPT.FL THEN'
OUT.LNS<-ONE> = 'PRINT FF:'
OUT.LNS<-ONE> = 'END ELSE'
OUT.LNS<-ONE> = 'PRINT @(0,0):CLS:'
OUT.LNS<-ONE> = 'IF REDISP THEN REDISP = FALSE'
OUT.LNS<-ONE> = 'END'
OUT.LNS<-ONE> = '*'
*
SPOS.LOC<ONE> = '0'
SPOS.REF<ONE> = 'hdr'
SPOS.DISP<ONE> = 'OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"'
*
CURR.AC = ONE
LOOP UNTIL CURR.AC GT SPOS.LOC.MAX + ONE DO
IF TF THEN PRINT RVB:"l":RVE:CURR.AC:" ":
LINE = 'PRINT '
VC = ONE; VC.MAX = DCOUNT(SPOS.LOC<CURR.AC>,VM)
CL.ADJ = 0
LOOP UNTIL VC GT VC.MAX DO
CL = SPOS.LOC<CURR.AC,VC>
LN = CURR.AC - ONE
TX = SPOS.DISP<CURR.AC,VC>
TMP = LEN(TX); TC = TX[TMP,ONE]; TMP1 = COUNT(TX,TC)
MS = FIELD(TX,TC,TMP1)
LH = MS[3,9999]
IF CL GT CL.ADJ THEN
LINE = LINE:'SPACE(':CL-CL.ADJ:'):'
CL.ADJ = CL
END
LINE = LINE:TX
CL.ADJ = CL.ADJ + LH
IF VC LT VC.MAX THEN LINE = LINE:':'
VC = VC + ONE
REPEAT
OUT.LNS<-ONE> = LINE
CURR.AC = CURR.AC + ONE
REPEAT
*
IF LP.C NE EMPTY THEN
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = 'GOSUB LP.C'
OUT.LNS<-ONE> = '*'
END
*
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = 'IF LPT.FL THEN'
OUT.LNS<-ONE> = 'CALL LPT.SUBR.OFF(LPT.STAT)'
OUT.LNS<-ONE> = 'CALL LPT.SUBR.CLOSE(LPT.STAT)'
OUT.LNS<-ONE> = 'END'
OUT.LNS<-ONE> = '*'
*
IF SBR.WR.FL THEN
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = 'RETURN; * To calling program'
OUT.LNS<-ONE> = '*'
END
*
OUT.LNS<-ONE> = '!'
OUT.LNS<-ONE> = '*'
*
IF SBR.WR.FL THEN
*
IF LP.C NE EMPTY THEN
OUT.LNS<-ONE> = 'LP.C: *'
OUT.LNS<-ONE> = LP.C
OUT.LNS<-ONE> = 'RETURN'
OUT.LNS<-ONE> = '*':AM:'!':AM:'*'
END
*
SLP.LNS<-ONE> = '*':AM:'!':AM:'*'
SLP.LNS<-ONE> = 'CALL SH.SUBR.LPT.':SCR.ID:'(':SBR.LN:')'
SLP.LNS<-ONE> = '*':AM:'!':AM:'*'
*
OUT.LNS<-ONE> = 'END'
WRITE OUT.LNS ON BPF.FILE,'SH.SUBR.LPT.':SCR.ID
END ELSE
SLP.LNS<-ONE> = OUT.LNS
END
*
*
RETURN
*
END
~SOURCEGEN.MAIN~
*CODE.SEGMENT: SOURCEGEN.MAIN 
*
* SPLIT 19 APR 91
* DGH
*
*
*
IF TF THEN PRINT @(ZERO,3):"< Start : ":; RQM
*
GOSUB PROGRAM.START
*
IF TF THEN PRINT @(ZERO,4):"< Opens : ":; RQM
GOSUB OPEN.FLS
*
IF TF THEN PRINT @(ZERO,5):"< Refs  : ":; RQM
ID = FLNMS<ONE,ONE>:".ID"
GOSUB VALID.REFERENCES
*
IF TF THEN PRINT @(ZERO,6):"< MAIN>"; RQM
GOSUB PROGRAM.MAINLINE
*
IF TF THEN PRINT @(ZERO,7):"< Back  : ":; RQM
GOSUB BG.DISP
*
IF TF THEN PRINT @(ZERO,8):"< Fore  : ":; RQM
GOSUB FG.DISP
*
IF TF THEN PRINT @(ZERO,9):"< Key   : ":; RQM
GOSUB KEY.INPUT
*
IF TF THEN PRINT @(ZERO,10):"< InputCalls : ":; RQM
GOSUB INPUT.CS
*
IF TF THEN PRINT @(ZERO,11):"< InputFeild : ":; RQM
GOSUB DT.INPUT
*
IF TF THEN PRINT @(ZERO,12):"< Errors    : ":; RQM
GOSUB ERROR.ROUTINE
*
IF TF THEN PRINT @(ZERO,13):"< Reads     : ":; RQM
GOSUB SET.UP.READ.ITEMS
*
IF TF THEN PRINT @(ZERO,14):"< Custom    : ":; RQM
GOSUB CUSTOM.CS
*
IF TF THEN PRINT @(ZERO,15):"< SpecialChars : ":; RQM
GOSUB REMOVE.SVM.VM
*
~SOURCEGEN.MAINLINE~
SUBROUTINE SOURCEGEN.MAINLINE(MAIN.LNS,ID,ID.MAX,ID.AC,ID.S,IDB.C,IDE.C,MAT EQT,READB.C,READE.C,FIXED,ALLOWED,NO.DIM,REC.FL,KEY.FL,BG.C,LP.S,LP.C,FG.C,ADDB.C,ADDE.C,CHNGB.C,CHNGE.C,MAX.REF,MSG,DELB.C,DELE.C,UPDB.C,UPDE.C,ABO.C,INP.C,OPE.C,INIT.C,FLNMS,READ.S,DEL.S,UPD.S,TF,STAT)
*CODE.SEGMENT: SOURCEGEN.MAINLINE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
$INCLUDE IBP EQT.DIM
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
MAIN.LNS = EMPTY
MAIN.LNS<-ONE> = 'NEXT.ITEM: *'
MAIN.LNS<-ONE> = '*MAIN.LNS*'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'STAT = FALSE; UPDATED = FALSE'
MAIN.LNS<-ONE> = 'GOSUB DISP.BG'
* TYPE.RUN 1
*          2
*          3
*          4
*          5
*          * ALLOW ACCESS TO ONE ITEM AND RETURN
*          6 - DON'T INPUT FIRST ID & SET TO TYPE 1
*          7 - INPUT ID
*          8 - INPUT ID IF EMPTY
*          9 - DON'T INPUT ID, ONLY ACCESS ON ITEM
*
MUPD.LNS = EMPTY; MUNL.LNS = EMPTY
MAIN.LNS<-ONE> = '*ID.INP.LNS*'
* 09FEB94 * IF NOT(ID.S) OR LEN(IDB.C) OR LEN(IDE.C) THEN
IF NOT(ID.S) THEN
MAIN.LNS<-ONE> = 'IF SYS.PROG.TYPE EQ "SUBR" THEN'
MAIN.LNS<-ONE> = 'IF INDEX("6789",TYPE.RUN,ONE) THEN'
MAIN.LNS<-ONE> = 'TMP = FALSE; TMP1 = FALSE'
MAIN.LNS<-ONE> = 'IF TYPE.RUN EQ "8" THEN TMP1 = TRUE'
MAIN.LNS<-ONE> = 'IF TYPE.RUN EQ "8" AND ':ID:' EQ EMPTY THEN TMP = TRUE'
MAIN.LNS<-ONE> = 'IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE'
MAIN.LNS<-ONE> = 'IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"'
MAIN.LNS<-ONE> = 'IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE'
MAIN.LNS<-ONE> = 'END ELSE TMP = TRUE; TMP1 = TRUE'
MAIN.LNS<-ONE> = 'END ELSE TMP = TRUE; TMP1 = TRUE'
*960510*DGH*MAIN.LNS<-ONE> = 'IF NOT(TMP) THEN ':ID:'.SAVE = EMPTY ELSE'
MAIN.LNS<-ONE> = 'IF NOT(TMP) THEN'
MAIN.LNS<-ONE> = 'IF TMP1 THEN ':ID:'.SAVE = EMPTY'
MAIN.LNS<-ONE> = 'END ELSE'
*960508*DGH*MAIN.LNS<-ONE> = 'IF TMP THEN'
MAIN.LNS<-ONE> = ID:' = EMPTY; ':ID:'.SAVE = EMPTY; GOSUB GET.KEY'
*960508*DGH*MAIN.LNS<-ONE> = ID:' = EMPTY; GOSUB GET.KEY'
MAIN.LNS<-ONE> = 'END'
END
IF NOT(ID.S) OR LEN(IDB.C) OR LEN(IDE.C) THEN
MAIN.LNS<-ONE> = 'IF ':ID:'.SAVE<ONE> EQ EMPTY THEN STAT = 999'
MAIN.LNS<-ONE> = 'IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN'
MAIN.LNS<-ONE> = '*SUB.RTN*'
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = 'IF STAT EQ 999 THEN GOTO FINISH'
END
MAIN.LNS<-ONE> = '*ID.INP.END*'
MAIN.LNS<-ONE> = '*'
*
MAIN.LNS<-ONE> = '*FILE.LNS*'
*
FOR VC = 1 TO 5 UNTIL FLNMS<ONE,VC> EQ EMPTY
*
IF KEY.FL<ONE,VC> THEN
*
TMP = FLNMS<ONE,VC>
TMP1 = INDEX(TMP,".FILE",ONE)
IF NOT(TMP1) THEN TMP1 = LEN(TMP) + ONE
FILE.NAME = TMP[ONE,TMP1 - ONE]
REC.NAME = FILE.NAME
ID.NAME = REC.NAME:'.ID'
IF REC.FL<ONE,VC> THEN
TMP1 = FIELD(FILE.NAME,".",ONE)
IF TMP1 NE "DICT" THEN FILE.NAME = TMP1
END
*
MAIN.LNS<-ONE> = '*LCK.LNS*':VC:'*'
* MAIN.LNS<-ONE> = 'IF NOT(DISP.ONLY) THEN CALL LOCK.ITEM(':FIELD(FLNMS<ONE,ONE>,".",ONE):'.FILE,"':FIELD(FLNMS<ONE,ONE>,".",ONE):'",':ID.NAME:',LCK.FILE,STAT)'
MAIN.LNS<-ONE> = 'IF NOT(DISP.ONLY) THEN'
MAIN.LNS<-ONE> = 'LCK.STAT = LCK.TYPE'
MAIN.LNS<-ONE> = 'LOOP'
* MAIN.LNS<-ONE> = 'CALL LOCK.ITEM(':FILE.NAME:'.FILE,"':FILE.NAME:'",':ID.NAME:',LCK.FILE,LCK.STAT)'
MAIN.LNS<-ONE> = 'CALL SYS.ITM.LCK("':FILE.NAME:'",':ID.NAME:',LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)'
IF VC EQ ONE THEN
MAIN.LNS<-ONE> = 'IF LCK.STAT EQ 999 THEN GOTO FINISH'
END ELSE
MAIN.LNS<-ONE> = 'IF LCK.STAT EQ 999 THEN GOTO LCK.RELS.':VC - ONE
END
MAIN.LNS<-ONE> = 'WHILE LCK.STAT DO REPEAT'
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = '*LCK.END*':VC:'*'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '*READ.LNS*':VC:'*'
*
IF LEN(READB.C) THEN MAIN.LNS<-ONE> = 'GOSUB READB.C; IF STAT THEN GOTO UNLOCK'
*
IF NOT(READ.S) THEN
*
IF VC EQ ONE THEN
IF EQT(VC) EQ EMPTY OR NO.DIM<ONE,VC> THEN
MAIN.LNS<-ONE> = 'READ ':REC.NAME:' FROM ':FILE.NAME:'.FILE,':ID.NAME:' THEN NEW = FALSE ELSE NEW = TRUE; ':REC.NAME:' = EMPTY'
END ELSE
* MAIN.LNS<-ONE> = 'MATREAD ':FLNMS<ONE,ONE>:' FROM ':FIELD(FLNMS<ONE,ONE>,".",ONE):'.FILE,':ID.NAME:' THEN NEW = FALSE ELSE NEW = TRUE; MAT ':FLNMS<ONE,ONE>:' = EMPTY'
MAIN.LNS<-ONE> = 'MATREAD ':REC.NAME:' FROM ':FILE.NAME:'.FILE,':ID.NAME:' THEN NEW = FALSE ELSE NEW = TRUE; MAT ':REC.NAME:' = EMPTY'
END
*
END ELSE
IF EQT(VC) EQ EMPTY OR NO.DIM<ONE,VC> THEN
MAIN.LNS<-ONE> = 'READ ':REC.NAME:' FROM ':FILE.NAME:'.FILE,':ID.NAME:' THEN NEW.':VC:' = FALSE ELSE NEW.':VC:' = TRUE; ':REC.NAME:' = EMPTY'
END ELSE
* MAIN.LNS<-ONE> = 'MATREAD ':FLNMS<ONE,ONE>:' FROM ':FIELD(FLNMS<ONE,ONE>,".",ONE):'.FILE,':ID.NAME:' THEN NEW.':VC:' = FALSE ELSE NEW.':VC:' = TRUE; MAT ':FLNMS<ONE,ONE>:' = EMPTY'
MAIN.LNS<-ONE> = 'MATREAD ':REC.NAME:' FROM ':FILE.NAME:'.FILE,':ID.NAME:' THEN NEW.':VC:' = FALSE ELSE NEW.':VC:' = TRUE; MAT ':REC.NAME:' = EMPTY'
END
END; * of vc 1/~1
*
END; * of not(read.s)
IF LEN(READE.C) THEN MAIN.LNS<-ONE> = 'GOSUB READE.C; IF STAT THEN GOTO UNLOCK'
MAIN.LNS<-ONE> = '*READ.END*':VC:'*'
MAIN.LNS<-ONE> = '*'
*
*UPDATE / UNLOCK
MUPD.LNS<-ONE> = '*UPDT.LNS*':VC:'*'
IF LEN(UPDB.C) THEN MUPD.LNS<-ONE> = 'GOSUB UPDB.C; IF STAT EQ 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES'
IF NOT(UPD.S) THEN
LINE = 'WRITE ':REC.NAME:' ON ':FILE.NAME:'.FILE,':ID.NAME:''; IF EQT(VC) NE EMPTY AND NOT(NO.DIM<ONE,VC>) THEN LINE = 'MAT':LINE
MUPD.LNS<-ONE> = LINE
END
IF LEN(UPDE.C) THEN MUPD.LNS<-ONE> = 'GOSUB UPDE.C; IF STAT EQ 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES'
*
TMP.LNS = '*'
TMP.LNS<-ONE> = 'LCK.RELS.':VC:': *'
IF LEN(ABO.C) THEN TMP.LNS<-ONE> = 'IF NOT(UPDATED) THEN GOSUB ABO.C'
* TMP.LNS<-ONE> = 'CALL UNLOCK.ITEM(':FIELD(FLNMS<ONE,ONE>,".",ONE):'.FILE,"':FIELD(FLNMS<ONE,ONE>,".",ONE):'",':ID.NAME:',LCK.FILE)'
*TMP.LNS<-ONE> = 'CALL UNLOCK.ITEM(':FILE.NAME:'.FILE,"':FILE.NAME:'",':ID.NAME:',LCK.FILE)'
MAIN.LNS<-ONE> = 'CALL SYS.ITM.RLS("':FILE.NAME:'",':ID.NAME:',LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)'
TMP.LNS<-ONE> = '*LCK.RELS.END*':VC:'*'
INS TMP.LNS BEFORE MUNL.LNS<ONE>
*
END; * of KEY.FL
*
NEXT VC
*
MUNL.LNS<-ONE> = '*'
*
MAIN.LNS<-ONE> = '*FILE.END*'
MAIN.LNS<-ONE> = '*'
*
MAIN.LNS<-ONE> = '*DISP.LNS*'
MAIN.LNS<-ONE> = 'DYN = EMPTY'
MAIN.LNS<-ONE> = 'IF NOT(NEW) THEN'
MAIN.LNS<-ONE> = 'GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK'
MAIN.LNS<-ONE> = 'IF DISP.ONLY THEN'
MAIN.LNS<-ONE> = 'LOOP'
LINE = 'PRINT CLB2:"Enter REdisplay'
IF NOT(LP.S) THEN LINE = LINE:', PRinter'
LINE = LINE:' or <cr> to end: ":'
MAIN.LNS<-ONE> = LINE
MAIN.LNS<-ONE> = 'INPUT RSP:'
LINE = 'WHILE RSP EQ "RE"'
IF NOT(LP.S) THEN LINE = LINE:' OR RSP EQ "PR"'
LINE = LINE:' DO'
MAIN.LNS<-ONE> = LINE
MAIN.LNS<-ONE> = 'IF RSP EQ "RE" THEN'
*960602*DGH*MAIN.LNS<-ONE> = 'MAT TDL = ONE; MAT TDX = ONE; MAT TDH = EMPTY'
MAIN.LNS<-ONE> = 'GOSUB DISP.BG'
MAIN.LNS<-ONE> = 'DYN = EMPTY; REDISP = 99'
MAIN.LNS<-ONE> = 'GOSUB DISP.FG'
IF NOT(LP.S) THEN
MAIN.LNS<-ONE> = 'END ELSE'
MAIN.LNS<-ONE> = 'LPT.FL = TRUE'
MAIN.LNS<-ONE> = 'GOSUB DISP.LP'
MAIN.LNS<-ONE> = 'LPT.FL = FALSE'
END
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = 'REPEAT'
IF FIXED THEN MAIN.LNS<-ONE> = 'GOTO FINISH' ELSE MAIN.LNS<-ONE> = 'GOTO NEXT.ITEM'
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = 'END ELSE'
IF COUNT(ALLOWED,"A") THEN
MAIN.LNS<-ONE> = 'IF DISP.ONLY THEN'
MAIN.LNS<-ONE> = 'PRINT CLB2:"Not on file - hit <cr> to end: ":'
MAIN.LNS<-ONE> = 'INPUT RSP:'
MAIN.LNS<-ONE> = 'GOTO NEXT.ITEM'
MAIN.LNS<-ONE> = 'END'
IF LEN(ADDB.C) THEN MAIN.LNS<-ONE> = 'GOSUB ADDB.C; IF STAT EQ 999 THEN GOTO UNLOCK'
MAIN.LNS<-ONE> = 'LOOP'
MAIN.LNS<-ONE> = 'PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":'
MAIN.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK'
MAIN.LNS<-ONE> = 'IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK'
MAIN.LNS<-ONE> = 'UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT'
MAIN.LNS<-ONE> = 'FOR REF = ONE TO ':MAX.REF
MAIN.LNS<-ONE> = 'GOSUB GET.DATA'
MAIN.LNS<-ONE> = 'IF STAT EQ 999 THEN GOTO UNLOCK'
*960510*DGH*MAIN.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ZERO'
MAIN.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ':MAX.REF
MAIN.LNS<-ONE> = 'NEXT REF'
IF LEN(ADDE.C) THEN MAIN.LNS<-ONE> = 'GOSUB ADDE.C; IF STAT EQ 999 THEN GOTO UNLOCK'
MAIN.LNS<-ONE> = 'NEW = EMPTY'
END ELSE MAIN.LNS<-ONE> = 'TEXT = "Not on file"; GOSUB ERROR; GOTO UNLOCK'
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = '*DISP.END*'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '*':AM:'!':AM:'*'
MAIN.LNS<-ONE> = 'CHANGES: *'
MAIN.LNS<-ONE> = '*CHNG.LNS*'
IF LEN(CHNGB.C) THEN MAIN.LNS<-ONE> = 'GOSUB CHNGB.C; IF STAT THEN GOTO UNLOCK'
MSG = 'TEXT = "Enter '
IF MAX.REF GT ONE THEN MSG = MSG:'screen ref., ' ELSE IF MAX.REF EQ ONE THEN MSG = MSG:'CHange, '
IF NOT(DEL.S) OR LEN(DELB.C) OR LEN(DELE.C) THEN
IF COUNT(ALLOWED,'D') THEN MSG = MSG:'DElete, '
END
MSG = MSG:'REdisplay'
IF NOT(LP.S) THEN MSG = MSG:', PRinter'
MSG = MSG:', KILL or <cr> to '
IF NOT(UPD.S) OR LEN(UPDB.C) OR LEN(UPDE.C) THEN
MSG = MSG:'update: "'
END ELSE
MSG = MSG:'end: "'
END
MAIN.LNS<-ONE> = MSG
MAIN.LNS<-ONE> = 'PRINT CLB2:TEXT:'
MAIN.LNS<-ONE> = 'IF GENERIC THEN'
MAIN.LNS<-ONE> = 'INPUT RSP:'
MAIN.LNS<-ONE> = 'END ELSE'
* MAIN.LNS<-ONE> = 'RSP.LN = 23; RSP.CL = LEN(TEXT) + ONE; RSP = EMPTY'
* MAIN.LNS<-ONE> = '$INCL':'UDE IBP CURSOR.POS.LOC'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '! Accept response from user'
* MAIN.LNS<-ONE> = '*'
* MAIN.LNS<-ONE> = 'LOOP'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '* If no cursor keys defined or generic'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '* PRINT @(ZERO,22):TEXT[1,75]:'
MAIN.LNS<-ONE> = '* * ULT ONLY'
MAIN.LNS<-ONE> = '* INPUTCLEAR'
MAIN.LNS<-ONE> = '* CLEARDATA; * REV ONLY'
MAIN.LNS<-ONE> = '* CLEARSELECT; * REV ONLY'
* 7JAN94 * MAIN.LNS<-ONE> = '*'
* 7JAN94 * MAIN.LNS<-ONE> = '* Input using cursor keys'
* 7JAN94 * MAIN.LNS<-ONE> = '*'
* 7JAN94 * MAIN.LNS<-ONE> = 'PRINT @(ZERO,TWO):CLL:'
* 7JAN94 * MAIN.LNS<-ONE> = 'VC = ONE'
* 7JAN94 * MAIN.LNS<-ONE> = '*'
* 7JAN94 * MAIN.LNS<-ONE> = '* Display function keys'
* 7JAN94 * MAIN.LNS<-ONE> = 'LOOP UNTIL CURSOR.KEYS<5,VC> EQ EMPTY OR VC GT 8 OR SYSTEM(11) GE 3 DO'
* 7JAN94 * MAIN.LNS<-ONE> = 'PRINT RVB:("F":VC):RVE:" ":CURSOR.KEYS<4,VC>:"  ":'
* 7JAN94 * MAIN.LNS<-ONE> = 'VC = VC + ONE'
* 7JAN94 * MAIN.LNS<-ONE> = 'REPEAT'
* 7JAN94 * MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '! Standard character input'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'LOOP'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY'
MAIN.LNS<-ONE> = '*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>'
MAIN.LNS<-ONE> = '*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>'
MAIN.LNS<-ONE> = 'CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL'
MAIN.LNS<-ONE> = 'IF CL THEN CL = CL - ONE'
MAIN.LNS<-ONE> = '* LH = "L25"; LHM = 135'
MAIN.LNS<-ONE> = 'LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE'
MAIN.LNS<-ONE> = 'EDITS = EMPTY; EDIT.FILE = EMPTY'
MAIN.LNS<-ONE> = 'RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE'
MAIN.LNS<-ONE> = 'LHM = 135; LH = 78 - RSP.CL - ONE'
MAIN.LNS<-ONE> = 'IF LH GT 5 THEN LH = 5'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'IF NOT(FIRST) THEN'
MAIN.LNS<-ONE> = '*'
* MAIN.LNS<-ONE> = '$INCL':'UDE IBP CURSOR.STD'
MAIN.LNS<-ONE> = 'CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'END ELSE TC.FUNC = "2"; FIRST = FALSE'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'IF TC.FUNC NE EMPTY THEN'
* MAIN.LNS<-ONE> = '$INCL':'UDE IBP CURSOR.POS'
MAIN.LNS<-ONE> = 'CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)'
MAIN.LNS<-ONE> = 'IF LEN(EXEC.VERB) THEN'
MAIN.LNS<-ONE> = 'RESET.SW = 999; CR.FLAG = TRUE'
MAIN.LNS<-ONE> = 'GOSUB ENTER.STD.EXEC'
MAIN.LNS<-ONE> = 'EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY'
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '! Process response'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = 'RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY'
MAIN.LNS<-ONE> = 'PRINT @(RSP.CL,RSP.LN):RSP MS:'
MAIN.LNS<-ONE> = '*'
*
! End of pos input
*
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = 'BEGIN CASE'
MAIN.LNS<-ONE> = 'CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK'
MAIN.LNS<-ONE> = 'CASE RSP EQ "END"; GOTO UNLOCK'
MAIN.LNS<-ONE> = 'CASE RSP EQ EMPTY; GOTO UPDATE'
IF NOT(DEL.S) OR LEN(DELB.C) OR LEN(DELE.C) THEN
IF COUNT(ALLOWED,"D") THEN
MAIN.LNS<-ONE> = 'CASE RSP EQ "DE"'
MAIN.LNS<-ONE> = 'PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":'
MAIN.LNS<-ONE> = 'INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK'
MAIN.LNS<-ONE> = 'IF RSP NE "Y" THEN GOTO CHANGES'
IF LEN(DELB.C) THEN MAIN.LNS<-ONE> = 'GOSUB DELB.C; IF STAT EQ 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES'
IF NOT(DEL.S) THEN
MAIN.LNS<-ONE> = 'DELETE ':FILE.NAME:'.FILE,':ID:'; GOTO UNLOCK'
END
IF LEN(DELE.C) THEN MAIN.LNS<-ONE> = 'GOSUB DELE.C; IF STAT EQ 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES'
END
END; * of not(del.s) or delb.c or dele.c
MAIN.LNS<-ONE> = 'CASE RSP EQ "RE"'
MAIN.LNS<-ONE> = 'GOSUB DISP.BG'
MAIN.LNS<-ONE> = 'DYN = EMPTY; REDISP = 99'
MAIN.LNS<-ONE> = 'GOSUB DISP.FG'
IF NOT(LP.S) THEN
MAIN.LNS<-ONE> = 'CASE RSP EQ "PR"'
MAIN.LNS<-ONE> = 'LPT.FL = TRUE'
MAIN.LNS<-ONE> = 'DYN = EMPTY; REDISP = 99'
MAIN.LNS<-ONE> = 'GOSUB DISP.LP'
MAIN.LNS<-ONE> = 'LPT.FL = FALSE'
END
IF MAX.REF EQ ONE THEN MAIN.LNS<-ONE> = 'CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA'
MAIN.LNS<-ONE> = 'CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:'
MAIN.LNS<-ONE> = 'END CASE'
MAIN.LNS<-ONE> = 'IF STAT EQ 999 THEN GOTO UNLOCK'
IF LEN(CHNGE.C) THEN MAIN.LNS<-ONE> = 'GOSUB CHNGE.C; IF STAT THEN GOTO UNLOCK'
MAIN.LNS<-ONE> = 'GOTO CHANGES'
MAIN.LNS<-ONE> = '*CHNG.END*'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '*':AM:'!':AM:'*'
MAIN.LNS<-ONE> = 'UPDATE: *'
MAIN.LNS<-ONE> = '*UPDT.LNS*'
MAIN.LNS<-ONE> = MUPD.LNS
MAIN.LNS<-ONE> = 'UPDATED = TRUE'
MAIN.LNS<-ONE> = '*UPDT.END*'
MAIN.LNS<-ONE> = '*':AM:'!':AM:'*'
*
MAIN.LNS<-ONE> = 'UNLOCK: *'
MAIN.LNS<-ONE> = '*LCK.RELS.LNS*'
MAIN.LNS<-ONE> = MUNL.LNS
MAIN.LNS<-ONE> = '*LCK.RELS.END*'
*
MAIN.LNS<-ONE> = '*':AM:'!':AM:'*'
MAIN.LNS<-ONE> = 'FINISH: *'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '*FIN.LNS*'
* MAIN.LNS<-ONE> = '*FIN.END*'
* 24JAN94 * MAIN.LNS<-ONE> = 'STOP'
MAIN.LNS<-ONE> = 'IF SYS.PROG.TYPE EQ "SUBR" THEN'
IF FIXED THEN
MAIN.LNS<-ONE> = '*SUB.RTN*'
END ELSE
MAIN.LNS<-ONE> = 'IF INDEX("6789",TYPE.RUN,ONE) THEN'
MAIN.LNS<-ONE> = '*SUB.RTN*'
MAIN.LNS<-ONE> = 'END'
END
MAIN.LNS<-ONE> = 'END ELSE'
IF FIXED THEN MAIN.LNS<-ONE> = 'STOP' ELSE
MAIN.LNS<-ONE> = 'IF STAT EQ 999 THEN STOP'
END
MAIN.LNS<-ONE> = 'END'
MAIN.LNS<-ONE> = 'GOTO NEXT.ITEM'
MAIN.LNS<-ONE> = '*FIN.END*'
MAIN.LNS<-ONE> = '*'
MAIN.LNS<-ONE> = '*MAIN.END*'
MAIN.LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN
*
END
~SOURCEGEN.MERGE~
*PROGRAM: SOURCEGEN.MERGE
*
$INCLUDE BP.SG SOURCEGEN.DOC.HDR
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
!
*
STAT = FALSE; ENTRY.TYPE = ZERO; OUT.FL.ID = EMPTY; SCR.ID = EMPTY
LST.END = FALSE; FIRST = TRUE; DEL.FL = TRUE
*
!
*
MAIN: *
*
OPEN "SYS" TO SYS.FILE ELSE STOP
OPEN "SCR" TO SCR.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
TF = TERM.DISP
*
READ SCR.SYSAMS FROM SCR.FILE,"CURRENT.SOURCEGEN@":PORT ELSE STOP
*
SCR.ID = SCR.SYSAMS<ONE>
SCR.FILE = SCR.SYSAMS<TWO>
SCR.OUT.FILE = SCR.SYSAMS<3>
*
OPEN SCR.FILE TO SCR.FILE ELSE STOP
OPEN SCR.OUT.FILE TO OUT.FILE ELSE STOP
*
READ LNS FROM SCR.FILE,SCR.ID:"*RTN" ELSE STOP
*
GOSUB REMOVE.VM
*
GOSUB REMOVE.SVM
*
GOSUB REMOVE.ESC
*
LNS.INP = LNS; LNS = EMPTY
*
BEGIN CASE
CASE OPSYS EQ "M"
ITM.MAX.LEN = 35000
CASE OPSYS EQ "R"
ITM.MAX.LEN = 25000
CASE TRUE
ITM.MAX.LEN = 32000
END CASE
*
!
*
FOR CN = ONE TO TWO
*
IF CN EQ ONE THEN
TMP = ""
END ELSE
TMP = "SUBR."
END
*
READ LNS.COD FROM OUT.FILE,"SH.":TMP:SCR.ID THEN
*
LEN.INP = LEN(LNS.INP); LEN.COD = LEN(LNS.COD)
LEN.TOT = LEN.INP + LEN.COD
*
IF LEN.TOT LT ITM.MAX.LEN THEN
*
LOCATE "@@@" IN LNS.COD SETTING LOC THEN
*
PRINT CLB0:"< MergeCOD >":
PRINT @(20):"< * Bytes : ":LEN.COD "R#5":" >":
PRINT @(40):"< * Lines : ":DCOUNT(LNS.COD,AM) "R#5":" >":
*
PRINT CLB1:"< MergeINP >":
PRINT @(20):"< * Bytes : ":LEN.INP "R#5":" >":
PRINT @(40):"< * Lines : ":DCOUNT(LNS.INP,AM) "R#5":" >":
*
LNS.COD<LOC> = LNS.INP
*
PRINT CLB2:"< MergePGM >":
PRINT @(20):"< * Bytes : ":LEN(LNS.COD) "R#5":" >":
PRINT @(40):"< * Lines : ":DCOUNT(LNS.COD,AM) "R#5":" >":
*
WRITE LNS.COD ON OUT.FILE,"SH.":TMP:SCR.ID
SCR.SYSAMS<11> = FALSE
WRITE SCR.SYSAMS ON SYS.FILE,"CURRENT.SOURCEGEN"
*
END ELSE NULL
*
END ELSE
*
PRINT CLB3:"Screen is too long at ":LEN.INP:"+":LEN.COD:"=":LEN.TOT:" characters!":BELL:
DEL.FL = FALSE
*
END
*
END; * Of read
*
NEXT CN
*
!
*
IF DEL.FL THEN
* DELETE SCR.FILE,SCR.ID:"*RTN"
END
*
STOP
*
!
*
REMOVE.SVM: *
*
$INCLUDE IBP SYS.INCL.REMOVE.SVM
*
RETURN
*
!
*
REMOVE.VM: *
*
$INCLUDE IBP SYS.INCL.REMOVE.VM
*
RETURN
*
!
*
REMOVE.AM: *
*
$INCLUDE IBP SYS.INCL.REMOVE.AM
*
!
*
REMOVE.ESC: *
*
$INCLUDE IBP SYS.INCL.REMOVE.ESC
*
RETURN
*
*
END
~SOURCEGEN.OPEN~
SUBROUTINE SOURCEGEN.OPEN(IBPF,EQF.FILE,MAT EQT,MAT EQF,EQT.F,EQF.MAX,EQF.IND,INIT.LNS,OPEN.LNS,DIM.LNS,EQU.LNS,FLNMS,ID,SCR.ID,SBR,SBR.F,SBR.LN,TF,CO.DATA,NO.DIM,REC.FL,KEY.FL,OPE.C,OPE.S,INIT.C,STAT)
*CODE.SEGMENT: SOURCEGEN.OPEN
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP DCT.EQUATES
*
MAT EQT = EMPTY; EQT.F = FALSE
MAT EQF = EMPTY; EQF.F = FALSE
EQF.IND = EMPTY
OPEN.LNS = EMPTY; DIM.LNS = EMPTY; EQU.LNS = EMPTY
TMP = TRUE
IF NOT(INDEX(FLNMS<ONE>,"LOCKS",ONE)) THEN TMP = FALSE
IF NOT(INDEX(FLNMS<ONE>,"LCK",ONE)) THEN TMP = FALSE
IF NOT(TMP) THEN
FLNMS<ONE,11> = "LOCKS"
* FLNMS<ONE,11> = "LCK"
NO.DIM<ONE,11> = TRUE
END
ID = "ID"; SBR.F = EMPTY; SBR.LN = EMPTY
IDC.LNS = EMPTY
*960509*DGH*SBR.F<-ONE> = 'TDL.REC':AM:ID:'.SAVE':AM:'MAT CNT.TST':AM:'CNT.TST.ID':AM:'TT':AM:'GENERIC':AM:'CURSOR.KEYS':AM:'NUMC':AM:'CO.DATA':AM:'DISP.ONLY':AM:'AUTO.RUN':AM:'REDISP':AM:'LPT.FL':AM:'TYPE.RUN':AM:'PHAN.RUN':AM:'RSPBUF':AM:'PROCBUF':AM:'TM.MAX':AM:'STAT'
*
SBR.F<-ONE> = 'TDL.REC':AM:'XYZ.SAVE':AM:'MAT CNT.TST':AM:'CNT.TST.ID':AM:'TT':AM:'GENERIC':AM:'CURSOR.KEYS':AM:'NUMC':AM:'CO.DATA':AM:'DISP.ONLY':AM:'AUTO.RUN':AM:'REDISP':AM:'LPT.FL':AM:'TYPE.RUN':AM:'PHAN.RUN':AM:'RSPBUF':AM:'PROCBUF':AM:'TM.MAX':AM:'STAT'
*
!
*
** IF TF THEN PRINT @(40,4):"<Files: ":
IF TF THEN PRINT @(ZERO,ZERO):"<Files: ":
FLNM.DONE = EMPTY
*
FOR VC = ONE TO 11
*
FLNM = FLNMS<ONE,VC>
*
TMP = FLNMS<ONE,VC>
TMP1 = INDEX(TMP,".FILE",ONE)
IF NOT(TMP1) THEN TMP1 = LEN(TMP) + ONE
FILE.NAME = TMP[ONE,TMP1 - ONE]
REC.NAME = FILE.NAME
IF REC.FL<ONE,VC> THEN
TMP1 = FIELD(FILE.NAME,".",ONE)
IF TMP1 NE "DICT" THEN FILE.NAME = TMP1
END
*
IF FLNM NE EMPTY THEN
IF TF THEN PRINT " [":VC + ZERO:"-":NO.DIM<ONE,VC> + ZERO:"-":REC.FL<ONE,VC> + ZERO:"-":FLNMS<ONE,VC>:"-":FLNM:"-":FILE.NAME:"]"
*
* IF FLNM EQ "LOCKS.FILE" THEN FLNM = "LCK.FILE"
TMP = INDEX(FLNM,".FILE",ONE)
IF NOT(TMP) THEN TMP = LEN(FLNM) + ONE
FILE.NAME = FLNM[ONE,TMP - ONE]
IF REC.FL<ONE,VC> THEN TMP = INDEX(FILE.NAME,".",ONE) ELSE TMP = ZERO
IF NOT(TMP) THEN TMP = LEN(FILE.NAME) + ONE
TRUE.FILE.NAME = FILE.NAME[ONE,TMP - ONE]
*
!
*
IF TRUE.FILE.NAME[ONE,5] EQ "DICT " THEN
*
DICT = '"DICT",'; TRUE.FILE.NAME = TRUE.FILE.NAME[6,99]
FILE.NAME = FILE.NAME[6,99]
IF FILE.NAME EQ "LOCKS" THEN FILE.NAME = "LCK"
FLNMS<ONE,VC> = "DICT.":FILE.NAME
OUT.FL.NAME = "DICT.":FILE.NAME
*
END ELSE
*
DICT = EMPTY
IF VC GE 11 THEN EQT(VC) = EMPTY ELSE
TMP = FILE.NAME
IF TMP EQ "LOCKS" THEN TMP = "LCK"
READ EQT(VC) FROM IBPF,TMP:".EQUATES" ELSE EQT(VC) = EMPTY
END
OUT.FL.NAME = FILE.NAME
IF OUT.FL.NAME EQ "LOCKS" THEN OUT.FL.NAME = "LCK"
*
END
*
IF VC LE 8 THEN
ID = OUT.FL.NAME:".ID"
IDC.LNS<-ONE> = ID:' = EMPTY; ':ID:'.SAVE = EMPTY'
GOSUB LOAD.DCT.ITEMS
END
*
!
*
IF NOT(OPE.S) THEN
*
LOCATE TRUE.FILE.NAME IN FLNM.DONE SETTING TMP.LOC ELSE
*
INS TRUE.FILE.NAME BEFORE FLNM.DONE<TMP.LOC>
IF TF THEN PRINT " O:":TRUE.FILE.NAME:" (":FILE.NAME:") ":
*
IF DICT NE EMPTY OR (TRUE.FILE.NAME NE "COM" OR TRUE.FILE.NAME NE "CNT" AND TRUE.FILE.NAME NE "PAR") THEN
TEMP = "'"
IF REC.FL<ONE,VC> THEN
* LNS.W = 'OPEN ':DICT:'"':TRUE.FILE.NAME:'" TO ':TRUE.FILE.NAME:'.FILE ELSE TEXT = "Can':TEMP:'t open ':TRUE.FILE.NAME:'"; GOSUB ERROR; STOP'
LNS.W = 'OPEN ':DICT:'"':TRUE.FILE.NAME:'" TO ':TRUE.FILE.NAME:'.FILE ELSE FILE.NAME = "':TRIM(DICT:' ':TRUE.FILE.NAME):'"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)'
END ELSE
* LNS.W = 'OPEN ':DICT:'"':TRUE.FILE.NAME:'" TO ':OUT.FL.NAME:'.FILE ELSE TEXT = "Can':TEMP:'t open ':TRUE.FILE.NAME:'"; GOSUB ERROR; STOP'
LNS.W = 'OPEN ':DICT:'"':TRUE.FILE.NAME:'" TO ':OUT.FL.NAME:'.FILE ELSE FILE.NAME = "':TRIM(DICT:' ':TRUE.FILE.NAME):'"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)'
END
IF FLNM EQ "LOCKS" THEN LNS.W = LNS.W:"; * ULT ONLY"
OPEN.LNS<-ONE> = LNS.W
IF FLNM EQ "LOCKS" OR FLNM EQ "LCK" THEN
OPEN.LNS<-ONE> = '* LCK.FILE = ZERO; * REV ONLY'
OPEN.LNS<-ONE> = 'LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE'
END
END
*
END; * of locate
*
END; * Of not(OPE.S)
*
!
*
* IF SBR THEN
*
TMP = EMPTY
* IF LEN(DICT) THEN        TMP = TMP:"DICT."
*960601*DGH*TMP = TMP:OUT.FL.NAME:".FILE"
TMP = TMP:TRUE.FILE.NAME:".FILE"
LOCATE TMP IN SBR.F SETTING TMP1 ELSE
SBR.F<-ONE> = TMP
END
*
TMP = EMPTY
IF VC LT 11 THEN
TMP = TMP:FLNMS<ONE,VC>:".ID"
LOCATE TMP IN SBR.F SETTING TMP1 ELSE
SBR.F<-ONE> = TMP
END
TMP = TMP:".SAVE"
IF VC GT ONE THEN TMP2 = TMP ELSE TMP2 = 'XYZ.SAVE'
LOCATE TMP2 IN SBR.F SETTING TMP1 THEN
SBR.F<TMP1> = TMP
END ELSE
SBR.F<-ONE> = TMP
END
*
TMP = EMPTY
IF EQT(VC) NE EMPTY AND VC LT 11 AND NOT(NO.DIM<ONE,VC>) THEN
TMP = TMP:"MAT "
END
TMP = TMP:FLNMS<ONE,VC>
END
LOCATE TMP IN SBR.F SETTING TMP1 ELSE
SBR.F<-ONE> = TMP
END
*
* END
*
END
*
NEXT VC
*
FOR VC = ONE TO 11
TMP = FLNMS<ONE,VC>
IF TMP NE "CNT.TST" AND TMP NE "PAR.MENU" AND TMP NE "SEC.USER" THEN
* IF REC.FL<ONE,VC> THEN TMP = FIELD(TMP,".",ONE)
IF EQT(VC) NE EMPTY AND VC LT 11 AND NOT(NO.DIM<ONE,VC>) THEN
DIM.LNS<-ONE> = '$INCL':'UDE IBP ':TMP:'.DIM'
EQU.LNS<-ONE> = '$INCL':'UDE IBP ':TMP:'.EQUATES'
EQT.F = TRUE
END ELSE IF EQT(VC) NE EMPTY AND VC LT 11 AND NO.DIM<ONE,VC> EQ "2" THEN
EQU.LNS<-ONE> = '$INCL':'UDE IBP ':TMP:'.VAR.EQUATES'
EQT.F = TRUE
END
END
NEXT VC
*
INIT.LNS = EMPTY
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*DIM.LNS*'
IF DIM.LNS NE EMPTY THEN
INIT.LNS<-ONE> = DIM.LNS
END
INIT.LNS<-ONE> = 'DIM STD(50); MAT STD = EMPTY'
INIT.LNS<-ONE> = '*DIM.END*'
*
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*EQU.LNS*'
IF EQU.LNS NE EMPTY THEN
INIT.LNS<-ONE> = EQU.LNS
END
INIT.LNS<-ONE> = '$INCL':'UDE IBP STANDARD.FUNCTIONS.CLB'
INIT.LNS<-ONE> = '*EQU.END*'
*
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*OPEN.LNS'
IF OPEN.LNS NE EMPTY THEN
INIT.LNS<-ONE> = OPEN.LNS
END
IF OPE.C NE EMPTY THEN
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = 'GOSUB OPE.C'
END
INIT.LNS<-ONE> = '*OPEN.END*'
*
INIT.LNS<-ONE> = '*'
** ** INIT.LNS<-ONE> = '*READ.LNS*'
** ** INIT.LNS<-ONE> = '*SCR.LNS*'
** ** INIT.LNS<-ONE> = '*SUB.LNS*'
** ** INIT.LNS<-ONE> = 'PORT.KEY = PORT'
** ** INIT.LNS<-ONE> = 'LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT'
** ** INIT.LNS<-ONE> = 'READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE'
** ** INIT.LNS<-ONE> = 'READ GENERIC FROM COM.FILE,"GENERIC" ELSE'
** ** INIT.LNS<-ONE> = 'IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE'
** ** INIT.LNS<-ONE> = 'END'
** ** INIT.LNS<-ONE> = 'END'
** ** INIT.LNS<-ONE> = 'READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY'
** ** INIT.LNS<-ONE> = '*SUB.END*'
** ** INIT.LNS<-ONE> = 'CO.NAME = CO.DATA<ONE,ONE>'
** ** INIT.LNS<-ONE> = 'READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE'
** ** INIT.LNS<-ONE> = 'READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE'
** ** INIT.LNS<-ONE> = 'POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY'
** ** INIT.LNS<-ONE> = 'END'
** ** INIT.LNS<-ONE> = 'END'
** ** INIT.LNS<-ONE> = '*'
** ** INIT.LNS<-ONE> = '*READ.END*'
INIT.LNS<-ONE> = 'IF NOT(GENERIC) THEN'
INIT.LNS<-ONE> = '*CURSOR.LNS*'
INIT.LNS<-ONE> = '*REF.LNS*'
INIT.LNS<-ONE> = 'END ELSE POS.LOC = EMPTY; POS.REF = EMPTY'
*
INIT.LNS<-ONE> = '*'
*
INIT.LNS<-ONE> = '*SCR.LNS*'
INIT.LNS<-ONE> = '*SUB.LNS*'
INIT.LNS<-ONE> = 'PORT.KEY = PORT'
INIT.LNS<-ONE> = 'LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT'
INIT.LNS<-ONE> = 'READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE'
INIT.LNS<-ONE> = 'READ GENERIC FROM COM.FILE,"GENERIC" ELSE'
INIT.LNS<-ONE> = 'IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE'
INIT.LNS<-ONE> = 'END'
INIT.LNS<-ONE> = 'END'
INIT.LNS<-ONE> = 'READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY'
*960526*DGH*INIT.LNS<-ONE> = ID:' = EMPTY; ':ID:'.SAVE = EMPTY'
INIT.LNS<-ONE> = IDC.LNS
INIT.LNS<-ONE> = '*SUB.END*'
INIT.LNS<-ONE> = 'CO.NAME = CO.DATA<ONE,ONE>'
INIT.LNS<-ONE> = 'READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE'
INIT.LNS<-ONE> = 'READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE'
INIT.LNS<-ONE> = 'POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY'
INIT.LNS<-ONE> = 'END'
INIT.LNS<-ONE> = 'END'
INIT.LNS<-ONE> = '*'
*
* IF SBR THEN
* SBR.F<-ONE> = ID:'.SAVE':AM:'GENERIC':AM:'CO.DATA':AM:'DISP.ONLY':AM:'AUTO.RUN':AM:'SYS.TST':AM:'REDISP':AM:'STAT'
* SBR.F<-ONE> = 'MAT TDL':AM:ID:'.SAVE':AM:'MAT CNT.TST':AM:'CNT.TST.ID':AM:'TT':AM:'GENERIC':AM:'CURSOR.KEYS':AM:'NUMC':AM:'CO.DATA':AM:'DISP.ONLY':AM:'AUTO.RUN':AM:'REDISP':AM:'LPT.FL':AM:'TYPE.RUN':AM:'PHAN.RUN':AM:'RSPBUF':AM:'PROCBUF':AM:'TM.MAX':AM:'STAT'
*** SBR.F<-ONE> = 'TDL.REC':AM:ID:'.SAVE':AM:'MAT CNT.TST':AM:'CNT.TST.ID':AM:'TT':AM:'GENERIC':AM:'CURSOR.KEYS':AM:'NUMC':AM:'CO.DATA':AM:'DISP.ONLY':AM:'AUTO.RUN':AM:'REDISP':AM:'LPT.FL':AM:'TYPE.RUN':AM:'PHAN.RUN':AM:'RSPBUF':AM:'PROCBUF':AM:'TM.MAX':AM:'STAT'
AM.MAX = DCOUNT(SBR.F,AM)
FOR AM.CN = ONE TO AM.MAX
IF SBR.F<AM.CN> NE "" THEN
IF LEN(SBR.LN) THEN SBR.LN = SBR.LN:","
SBR.LN = SBR.LN:SBR.F<AM.CN>
END
NEXT AM.CN
IF TF THEN PRINT @(ZERO,9):CLL:"PARAMS: ":@(ZERO,ZERO):SBR.LN
* END
*
INIT.LNS<-ONE> = '*SCR.END*'
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*READ.LNS*'
INIT.LNS<-ONE> = '*READ.END*'
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*INIT.LNS*'
INIT.LNS<-ONE> = 'FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY'
INIT.LNS<-ONE> = 'INX.LOC = ZERO; INX.FOUND = FALSE'
INIT.LNS<-ONE> = 'INX.STR = EMPTY; INX.STR.OUT = EMPTY'
INIT.LNS<-ONE> = 'LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE'
INIT.LNS<-ONE> = 'LN.HI = ZERO; LN.TMP = ZERO'
INIT.LNS<-ONE> = 'CLEAR = TRUE'
INIT.LNS<-ONE> = 'OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE'
INIT.LNS<-ONE> = 'NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY'
INIT.LNS<-ONE> = 'TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY'
INIT.LNS<-ONE> = 'STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999'
INIT.LNS<-ONE> = 'SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY'
INIT.LNS<-ONE> = 'CR.FLAG = TRUE; LOCN = EMPTY'
*
* INIT.LNS<-ONE> = 'IF NOT(GENERIC) THEN'
* INIT.LNS<-ONE> = 'POS.CN.MAX = DCOUNT(POS.LOC,AM)'
* INIT.LNS<-ONE> = 'LOOP UNTIL LN + ONE GE POS.CN.MAX OR POS.LOC<LN + ONE> NE EMPTY DO LN = LN + ONE REPEAT'
* INIT.LNS<-ONE> = 'CL = POS.LOC<LN + ONE,CL.LOC>'
* INIT.LNS<-ONE> = 'END'
IF INIT.C NE EMPTY THEN
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = 'GOSUB INIT.C'
END
INIT.LNS<-ONE> = '*INIT.END*'
INIT.LNS<-ONE> = '*'
*
RETURN
*
!
*
LOAD.DCT.ITEMS: *
*
EQF.MAX = ZERO
FLNM.SUFF = FIELD(FLNM,".",TWO)
*
IF DICT NE EMPTY THEN
OPEN 'MD' TO EQF.FILE ELSE RETURN
END ELSE
TMP.FLNM = FLNM
OPEN 'DICT',TMP.FLNM TO EQF.FILE ELSE 
TMP.FLNM = FIELD(TMP.FLNM,".",ONE)
OPEN 'DICT',TMP.FLNM TO EQF.FILE ELSE RETURN
END
END
*
* TMP = TMP.FLNM
* IF LEN(FLNM.SUFF) THEN TMP = TMP:' EQ "':FLNM.SUFF:'.]"'
IF LEN(FLNM.SUFF) THEN EQF.PREF = FLNM.SUFF:"." ELSE EQF.PREF = EMPTY
* EXECUTE 'SSELECT DICT ':TMP:' BY NUM.ORDER', //SELECT. > EQF.ID.LIST
EQF.CN = ZERO
*
IF TF THEN PRINT @(ZERO,ZERO):"<Equates: ":
LOOP
* READNEXT EQF.ID FROM EQF.ID.LIST ELSE EQF.ID = "@@@"
EQF.CN = EQF.CN + ONE
EQF.ID = EQF.PREF:EQF.CN
READ DCT.ITEM FROM EQF.FILE,EQF.ID THEN EQF.ON.FILE = TRUE ELSE EQF.ON.FILE = FALSE
*
WHILE EQF.ON.FILE DO
*
IF TF THEN PRINT EQF.ID:"_":
*
IF (NUM(EQF.ID) AND FLNM.SUFF EQ EMPTY) OR (FIELD(EQF.ID,".",ONE) EQ FLNM.SUFF AND NUM(FIELD(EQF.ID,".",TWO))) THEN
*
* READ DCT.ITEM FROM EQF.FILE,EQF.ID THEN
IF EQF.ON.FILE THEN
*
IF DCT.ITEM<ONE>[ONE,ONE] NE 'D' AND DCT.ITEM<ONE>[ONE,ONE] NE 'Q' THEN
*
IF DCT.ITEM<ONE> NE 'S' AND DCT.ITEM<ONE> NE 'X' THEN
*
IF NOT(NUM(EQF.ID)) THEN EQF.NUM = FIELD(EQF.ID,".",TWO) ELSE EQF.NUM = EQF.ID
*
IF NUM(EQF.NUM) THEN
*
IF EQF.NUM GT ZERO AND EQF.NUM LE 75 THEN
*
EQF(VC,EQF.NUM) = DCT.ITEM
EQF.IND<EQF.NUM> = FLNM:"$":DCT.ITEM<DCT.DBNAME>
IF EQF.NUM GT EQF.MAX THEN EQF.MAX = EQF.NUM
*
END; * of 0 - 75
*
END; * of num
*
END; * of not S or X
*
END; * of not file pointer
*
END ELSE NULL; * of read
*
END; * of num or id suff matches pref
*
REPEAT
*
RETURN
*
END
~SOURCEGEN.PMPT~
SUBROUTINE SOURCEGEN.PMPT(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,KEY.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.SEP,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX,REDISP)
*CODE.SEGMENT: SOURCEGEN.PMPT.DT
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
$INCLUDE BP.SG SOURCEGEN.DOC.HDR
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
!
EXTR.PMPT.DT: *
* PMPT.TYPE, PMPT.TEXT
* PMPT.RSP,  INPUT.REQD
* FLNM, POSN, LOCN, CONV, EDIT
* CONTROLLING, DEPENDANT, FREE
*
* PRINT CLB:"READY: ":; INPUT TMPRSP:
*
DT = SIR<SIR.AC>
*
IF DT EQ EMPTY OR DT[ONE,ONE] EQ '*' THEN RETURN
*
PMPT.TYPE = DT<ONE,ONE,ONE>[ONE,ONE]
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," OR PMPT.TYPE EQ "'" THEN
INPUT.REQD = ZERO; PMPT.TEXT = EMPTY
PMPT.RSP = DT<ONE,ONE,ONE>[TWO,9999]
END ELSE
INPUT.REQD = ONE
IF PMPT.TYPE EQ '"' THEN PMPT.TEXT = EMPTY ELSE PMPT.TYPE = DT<ONE,ONE,ONE>; PMPT.TEXT = DT<ONE,ONE,TWO>
END
*
POSN = DT<ONE,TWO>
LOCN = DT<ONE,3>; OLD.LOCN = LOCN
*
* LOAD COL, LINE, LENGTH, END LINE
CL  = POSN<ONE,ONE,ONE>
LN  = POSN<ONE,ONE,TWO>
LH  = POSN<ONE,ONE,3>
LHM = POSN<ONE,ONE,4>
FXD = POSN<ONE,ONE,5>
IF FXD EQ EMPTY THEN FXD = ZERO
IF NOT(NUM(FXD)) THEN FXD = ONE
LM  = FIELD(LN,"-",TWO)
IF LM EQ EMPTY THEN LM = LN ELSE LN = FIELD(LN,"-",ONE)
*
MS = LH[ONE,ONE]; IF MS EQ "L" OR MS EQ "R" THEN LH = LH[TWO,9] ELSE MS = "L"
MS = MS:"#":LH
IF LHM EQ EMPTY THEN LHM = LH
IF LH LT 10 THEN FXD = ONE
*
* Load File related variables
VF = ZERO; SQ = EMPTY; VTYPE = EMPTY; VTYPE.VC = ZERO; VTYPE.FL = FALSE; VTYPE.SEP = EMPTY
FL = LOCN<ONE,ONE,ONE>; * FILE
FLNM = EMPTY; EXTR = EMPTY
SPOS = EMPTY; SPOS.MAX = ZERO
CONV = EMPTY; EDIT = EMPTY
*
* File access
IF FL MATCHES '2X0N' AND INDEX('*FI*AL*AR*DL*DR*','*':FL[ONE,TWO]:'*',ONE) AND FL[3,9] GT ZERO THEN
SQ = FL[ONE,TWO]; VF = FL[3,9]; FL = ONE; VTYPE.VC = ONE; VTYPE = 'FL'; VTYPE.SEP = 'ID'
FLNM.SUFF = EMPTY
END ELSE IF NOT(NUM(FL)) THEN
TC = FL[ONE,ONE]
IF TC EQ '"' OR TC EQ "'" THEN
FL = FIELD(FL,TC,TWO)
LOCATE FL IN FLNMS SETTING LOC THEN
FL = LOC
END ELSE
FLNMS<ONE,LOC> = FL
SIR<ONE,LOC> = FL
FL = LOC
END
END
END ELSE
IF NOT(FL) THEN FL = ONE
END
*
IF NOT(NUM(FL)) THEN
LOCATE FL IN FLNMS SETTING LOC THEN
INS FL BEFORE FLNMS<ONE,LOC>
FL = LOC
END; * of loc
END; * of num fl name
*
* AM
TRUE.AC = ZERO
AC = FIELD(LOCN<ONE,ONE,TWO>,"-",ONE)
IF AC[ONE,ONE] EQ '"' THEN
AC = FIELD(AC,'"',TWO)
END ELSE IF AC[ONE,ONE] EQ "'" THEN
VF = ZERO; SQ = EMPTY; AC = FLNMS<ONE,FL>:'$':FIELD(AC,"'",TWO)
END ELSE IF NUM(AC) THEN
TRUE.AC = AC
END ELSE
SQ = AC[ONE,TWO]; VF = AC[3,9]; AC = 'AC'; VTYPE.VC = 2; VTYPE = 'AC'; VTYPE.SEP = 'AM'
END
*
* VM
VC = FIELD(LOCN<ONE,ONE,3>,"-",ONE)
IF VC[ONE,ONE] EQ '"' THEN
VC = FIELD(VC,'"',TWO)
END ELSE IF NUM(VC) THEN
NULL
END ELSE IF VC[ONE,ONE] EQ "'" THEN
* VF, SQ
VC = FLNMS<ONE,FL>:'$':FIELD(VC,"'",TWO)
END ELSE
SQ = VC[ONE,TWO]; VF = VC[3,9]; VC = 'VC'; VTYPE.VC = 3; VTYPE = 'VC'; VTYPE.SEP = 'VM'
END
*
* SVM
SC = FIELD(LOCN<ONE,ONE,4>,"-",ONE)
IF SC[ONE,ONE] EQ '"' THEN
SC = FIELD(SC,'"',TWO)
END ELSE IF SC[ONE,ONE] EQ "'" THEN
* VF, SQ
SC = FLNMS<ONE,FL>:'$':FIELD(SC,"'",TWO)
END ELSE IF NUM(SC) THEN
NULL
END ELSE
SQ = SC[ONE,TWO]; VF = SC[3,9]; SC = 'SC'; VTYPE.VC = 4; VTYPE = 'SC'; VTYPE.SEP = 'SVM'
END
*
IF VF THEN IF LOCN<ONE,ONE,VTYPE.VC + ONE> NE EMPTY THEN VTYPE.FL = TRUE
SB = LOCN<ONE,ONE,5>
*
CALL SOURCEGEN.SETUP.STR(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,KEY.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.SEP,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX)
*
CONV = DT<ONE,4>
* PRINT BELL:; INPUT RSP:
IF NUM(FL) THEN
IF FL LE 5 THEN
IF TRUE.AC THEN
IF CONV NE EMPTY THEN
IF EQF(FL,TRUE.AC)<DCT.CONV> EQ EMPTY THEN EQF(FL,TRUE.AC)<DCT.CONV> = CONV; EQF(FL,TRUE.AC)<DCT.WRFL> = TRUE
END ELSE IF EQF(FL,TRUE.AC)<DCT.CONV> NE EMPTY THEN
CONV = EQF(FL,TRUE.AC)<DCT.CONV>
END
END; * of true ac gt zero
END; * of file # 1
END; * of num file
*
IF OLD.LOCN EQ EMPTY THEN
PMPT.RSP = DT<ONE,ONE,ONE>
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," OR PMPT.TYPE EQ '"' OR PMPT.TYPE EQ "'" THEN PMPT.RSP = PMPT.RSP[TWO,999]
IF PMPT.TYPE NE "'" THEN PMPT.RSP = '"':PMPT.RSP:'"'
PMPT.TYPE = EMPTY; INPUT.REQD = ZERO; REDISP = ZERO
END ELSE PMPT.RSP = EMPTY
*
!
*
* EDIT, ED1, ED2, EDIT.FILE
* PRINT BELL:; INPUT RSP:
EDIT = INDEX(DT,VM,4)
EDIT.FILE = '""'
*
IF NOT(EDIT) THEN EDIT = EMPTY ELSE
*
IF NUM(FL) THEN
IF FL EQ ONE THEN
IF TRUE.AC THEN
IF EDIT NE EMPTY THEN
IF EQF(FL,TRUE.AC)<DCT.EDIT> EQ EMPTY THEN EQF(FL,TRUE.AC)<DCT.EDIT> = EDIT; EQF(FL,TRUE.AC)<DCT.WRFL> = TRUE
END ELSE IF EQF(FL,TRUE.AC)<DCT.EDIT> NE EMPTY THEN
EDIT = EQF(FL,TRUE.AC)<DCT.EDIT>
END
END; * of true ac gt zero
END; * of file # 1
END; * of num file
*
EDIT = DT[EDIT + ONE,999]
CN = ONE
*
LOOP ED = EDIT<ONE,CN> UNTIL ED EQ EMPTY DO
*
ED1 = ED<ONE,ONE,ONE>
*
IF ED1 EQ "RE" THEN
REDISP = ONE
DEL EDIT<ONE,CN>
CN = CN - ONE
*
END ELSE
*
IF ED1 EQ "FI" OR ED1 EQ "DF" OR ED1 EQ "EQ" OR ED1 EQ "MA" THEN
*
ED2 = ED<ONE,ONE,TWO>
ED3 = ED<ONE,ONE,3>
ED4 = ED<ONE,ONE,4>
ED5 = ED<ONE,ONE,5>
*
IF ED1 EQ "FI" THEN
EDIT<ONE,CN> = ED1
TMP = INDEX(FLNMS<ONE,ED2>,".FILE",ONE)
IF REC.FL<ONE,ED2> THEN TMP = INDEX(FLNMS<ONE,ED2>,".",ONE)
IF NOT(TMP) THEN TMP = LEN(FLNMS<ONE,ED2>) + ONE
EDIT.FILE = FLNMS<ONE,ED2>[ONE,TMP - ONE]:".FILE"
*
END ELSE
*
IF ED2[ONE,ONE] EQ "*" THEN
*
TMP = INDEX(FLNMS<ONE,ED2[TWO,TWO]>,".FILE",ONE)
IF REC.FL<ONE,ED2[TWO,TWO]> THEN TMP = INDEX(FLNMS<ONE,ED2[TWO,TWO]>,".",ONE)
IF NOT(TMP) THEN TMP = LEN(FLNMS<ONE,ED2[TWO,TWO]>) + ONE
READ.ITEM = FLNMS<ONE,ED2[TWO,TWO]>[ONE,TMP - ONE]:"*":ED3
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
EDIT<ONE,CN> = ED1:SVM:'@":':ED3
*
IF ED4 EQ EMPTY THEN
EDIT<ONE,CN> = EDIT<ONE,CN>:'<ONE>:"@'
*
END ELSE
IF ED5 EQ EMPTY THEN
EDIT<ONE,CN> = EDIT<ONE,CN>:'<':ED4:'>:"@'
END ELSE
EDIT<ONE,CN> = EDIT<ONE,CN>:'<':ED4:',':ED5:'>:"@'
END; * of 5
END; * of 4
*
END; * of '*'
*
END; * of not 'FI'
*
END; * of FI EQ DF MA
*
!
*
IF NUM(FL) THEN
IF FL LE 8 THEN
IF TRUE.AC THEN
IF ED NE EMPTY THEN
LOCATE ED IN EQF(FL,TRUE.AC)<DCT.EDIT> SETTING TMP ELSE
EQF(FL,TRUE.AC)<DCT.EDIT,-ONE> = ED
EQF(FL,TRUE.AC)<DCT.WRFL> = TRUE
END
END; * OF EDIT.STR
END; * OF TRUE.AC
END; * OF FL LE 8
END; * OF NUM(FL)
*
*
END; * of not RE
*
CN = CN + ONE
*
REPEAT
*
END; * of EDIT present
*
RETURN
*
END
~SOURCEGEN.PMPT.DT~

~SOURCEGEN.PMPT.DT1~
*CODE.SEGMENT: SOURCEGEN.PMPT.DT 
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
EXTR.PMPT.DT: *
* PMPT.TYPE, PMPT.TEXT, INPUT.REQD
* POSN, LOCN, CONV, EDIT
* CONTROLLING, DEPENDANT, FREE
* IF TF THEN PRINT " <e ":
PMPT.TYPE = DT<ONE,ONE,ONE>[ONE,ONE]
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," THEN INPUT.REQD = ZERO; PMPT.TEXT = EMPTY ELSE
INPUT.REQD = ONE
IF PMPT.TYPE EQ '"' THEN PMPT.TEXT = EMPTY ELSE PMPT.TYPE = DT<ONE,ONE,ONE>; PMPT.TEXT = DT<ONE,ONE,TWO>
END
POSN = DT<ONE,TWO>
LOCN = DT<ONE,3>
CONV = DT<ONE,4>
IF POSN EQ EMPTY AND LOCN EQ EMPTY AND CONV EQ EMPTY THEN
PMPT.TYPE = EMPTY; INPUT.REQD = ZERO; REDISP = ZERO
PMPT.RSP = DT<ONE,ONE,ONE>
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," OR PMPT.TYPE EQ '"' THEN PMPT.RSP = PMPT.RSP[TWO,999]
PMPT.RSP = '"':PMPT.RSP:'"'
END ELSE PMPT.RSP = EMPTY
*
* EDIT, ED1, ED2, EDIT.FILE
EDIT = INDEX(DT,VM,4)
EDIT.FILE = 'EMPTY'
IF NOT(EDIT) THEN EDIT = EMPTY ELSE
EDIT = DT[EDIT + ONE,999]
VC = ONE
LOOP ED = EDIT<ONE,VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>
IF ED1 EQ "RE" THEN
REDISP = ONE
DEL EDIT<ONE,VC>
VC = VC - ONE
END ELSE
IF ED1 EQ "FI" OR ED1 EQ "DF" OR ED1 EQ "EQ" OR ED1 EQ "MA" THEN
ED2 = ED<ONE,ONE,TWO>
IF ED1 EQ "FI" THEN EDIT<ONE,VC> = ED1; EDIT.FILE = FLNMS<ONE,ED2>:'.FILE' ELSE
IF ED2[ONE,ONE] EQ "*" THEN
READ.ITEM = FLNMS<ONE,ED2[TWO,TWO]>:'*':ED<ONE,ONE,3>
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
EDIT<ONE,VC> = ED1:SVM:'@":':ED<ONE,ONE,3>:'<ONE>:"@'
END
END
END
END
VC = VC + ONE
REPEAT
END
*
* LOAD COL, LINE, LENGTH, END LINE
CL = POSN<ONE,ONE,ONE>
LN = POSN<ONE,ONE,TWO>
LH = POSN<ONE,ONE,3>
LM = FIELD(LN,"-",TWO)
IF LM EQ EMPTY THEN LM = LN ELSE LN = FIELD(LN,"-",ONE)
*
MS = LH[ONE,ONE]; IF MS EQ "L" OR MS EQ "R" THEN LH = LH[TWO,9] ELSE MS = "L"
MS = MS:"#":LH
*
FL = LOCN<ONE,ONE,ONE>; * FILE
*IF FL[ONE,ONE] EQ '"' THEN FL = FIELD(FL,'"',TWO)
IF FL[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; FL = FIELD(FL,'"',TWO)
END ELSE IF NUM(FL) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = FL[ONE,TWO]; VF = FL[3,9]; FL = ONE
END
* AM
IF VF THEN AC = EMPTY ELSE
AC = FIELD(LOCN<ONE,ONE,TWO>,"-",ONE)
IF AC[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; AC = FIELD(AC,'"',TWO)
END ELSE IF AC[ONE,ONE] EQ "'" THEN
VF = ZERO; SQ = EMPTY; AC = FLNMS<ONE,FL>:"$":FIELD(AC,"'",TWO)
END ELSE IF NUM(AC) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = AC[ONE,TWO]; VF = AC[3,9]; AC = ONE
END
END; * of VF or AC
* VM
IF VF THEN VC = EMPTY ELSE
VC = FIELD(LOCN<ONE,ONE,3>,"-",ONE)
IF VC[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; VC = FIELD(VC,'"',TWO)
END ELSE IF NUM(VC) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = VC[ONE,TWO]; VF = VC[3,9]; VC = ONE
END
END; * of VF or VC
* SVM
IF VF THEN SC = EMPTY ELSE
SC = FIELD(LOCN<ONE,ONE,4>,"-",ONE)
IF SC[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; SC = FIELD(SC,'"',TWO)
END ELSE IF NUM(SC) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = SC[ONE,TWO]; VF = SC[3,9]; SC = ONE
END
END; * of VF or SC
SB = LOCN<ONE,ONE,5>
GOSUB SET.UP.STRINGS
RETURN
!
SET.UP.STRINGS: *
* IF TF THEN PRINT "s":
IF NOT(NUM(FL)) THEN FLNM = FL ELSE
IF NOT(FL) THEN FLNM = 'EMPTY' ELSE
FLNM = FLNMS<ONE,FL>
END
IF NUM(AC) THEN
IF NOT(AC) AND SQ EQ EMPTY THEN FLNM = FLNM:'.ID' ELSE
IF EQT(FL) NE EMPTY THEN
EQ.F = EMPTY; FLNM = FLNM:'(':AC:')'; AC = ONE
TMP = INDEX(EQT(FL),"EQU",ONE)
*EQ.AC = TWO
EQ.AC = DCOUNT(EQT(FL)[ONE,TMP+ONE],AM)
LOOP EQ.LN = EQT(FL)<EQ.AC> UNTIL EQ.LN EQ EMPTY OR EQ.F DO
IF FIELD(EQ.LN," ",4) EQ FLNM:";" THEN EQ.F = ONE; FLNM = FIELD(EQ.LN," ",TWO)
EQ.AC = EQ.AC + ONE
REPEAT
END; * of equate item present
END; * of not an ID
END ELSE
* AC is a string
FLNM = AC
END; * of field name string
END; * of file name not a string
*
TMP.AC = AC
IF NOT(NUM(TMP.AC)) THEN TMP.AC = "ONE"
BEGIN CASE
*
CASE SC NE EMPTY
VTYPE = "SC"
IF VF THEN
EXTR = '<':TMP.AC:',':VC:',SC>' ; LOCN = TMP.AC:':",":':VC:':",":SC'
END ELSE EXTR = '<':TMP.AC:',':VC:',':SC:'>'; LOCN = TMP.AC:':",":':VC:':",":':SC; IF SB NE EMPTY THEN LOCN = LOCN:':",":"':SB:'"'
*
CASE VC NE EMPTY
VTYPE = "VC"
IF VF THEN
EXTR = '<':TMP.AC:',VC>' ; LOCN = TMP.AC:':",":VC'
END ELSE EXTR = '<':TMP.AC:',':VC:'>'; LOCN = TMP.AC:':",":':VC; IF SB NE EMPTY THEN LOCN = LOCN:':",,":"':SB:'"'
*
CASE AC NE EMPTY
VTYPE = "AC"
IF VF THEN
EXTR = '<AC>'; LOCN = 'AC'
END ELSE EXTR = '<':TMP.AC:'>'; LOCN = TMP.AC; IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
*
CASE FL NE EMPTY
VTYPE = "FL"
IF VF THEN
EXTR = EMPTY; LOCN = EMPTY
END ELSE EXTR = EMPTY; LOCN = ONE; IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
*
CASE TRUE; VTYPE = EMPTY; EXTR = EMPTY; LOCN = EMPTY
*
END CASE
*
RETURN
!
~SOURCEGEN.SETUP.STR~
SUBROUTINE SOURCEGEN.SETUP.STR(EQ.F,MAT EQF,MAT EQT,EQF.IND,NO.DIM,REC.FL,KEY.FL,FLNMS,FLNM,FLNM.SUFF,SIR,SIR.AC,READ.ITEMS,TRUE.AC,REF.AC,FL,AC,VC,SC,SB,PMPT.TYPE,PMPT.TEXT,PMPT.RSP,INPUT.REQD,EXTR,INST,POSN,LOCT,LOCN,OLD.LOCN,CONV,EDIT,EDIT.FILE,CL,LN,LH,LHM,FXD,LM,MS,VF,CNTRL.AC,SQ,VTYPE,VTYPE.SEP,VTYPE.VC,VTYPE.FL,DT,SPOS,SPOS.MAX)
*CODE.SEGMENT: SOURCEGEN.PMPT.DT
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
$INCLUDE BP.SG SOURCEGEN.DOC.HDR
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
!
SET.UP.STRINGS: *
*
* PRINT CLB:"READY...":; INPUT TMP:
*
EQ.F = FALSE; TRUE.AC = ZERO
*
IF PMPT.TYPE EQ "'" THEN 
FLNM = PMPT.RSP
RETURN
END
*
IF NOT(NUM(FL)) THEN FLNM = FL; FLNM.SUFF = FIELD(FL,".",TWO) ELSE
IF NOT(FL) THEN FLNM = 'EMPTY' ELSE
FLNM = FLNMS<ONE,FL>
END
FLNM.SUFF = FIELD(FLNM,".",TWO)
*
IF AC = 'AC' THEN
NULL
*
END ELSE IF NUM(AC) AND FL LE 8 THEN
TRUE.AC = AC
IF NOT(TRUE.AC) AND SQ EQ EMPTY THEN FLNM = FLNM:'.ID' ELSE
IF EQT(FL) NE EMPTY AND NOT(NO.DIM<ONE,FL>) THEN
IF EQF(FL,TRUE.AC)<DCT.DBNAME> NE EMPTY THEN
**FLNM = FLNM:'$':EQF(FL,TRUE.AC)<DCT.DBNAME>
* AC = EQF(FL,TRUE.AC)<DCT.DBNAME>
* FLNM = FLNMS<ONE,FL>:'$':AC
FLNM = FLNMS<ONE,FL>:'$':EQF(FL,TRUE.AC)<DCT.DBNAME>
AC = FLNM
IF SIR<SIR.AC,3,TWO> EQ AC THEN SIR<SIR.AC,3,TWO> = "'":FIELD(AC,'$',TWO):"'"
EQ.F = TRUE
END ELSE
FLNM = FLNM:'(':AC:')'
END
END; * of equate item present
END; * of not an ID
*
END ELSE
* AC is a string
FLNM = AC
LOCATE FLNM IN EQF.IND SETTING TRUE.AC ELSE
TMP = FLNMS<ONE,FL>:"$":AC
LOCATE TMP IN EQF.IND SETTING TRUE.AC THEN
FLNM = TMP
END ELSE TRUE.AC = ZERO
END
*
IF TRUE.AC THEN EQ.F = TRUE
*
END; * of field name string
END; * of file name not a string
*
TMP.AC = AC
IF NOT(NUM(TMP.AC)) AND AC NE 'AC' THEN TMP.AC = 'ONE'
IF TMP.AC EQ EMPTY OR TMP.AC EQ '0' THEN TMP.AC = 'ONE'
*
BEGIN CASE
*
CASE SC NE EMPTY
EXTR = '<':TMP.AC:',':VC:',':SC:'>'; LOCN = TMP.AC:':",":':VC:':",":':SC
SPOS = TMP.AC:',':VC:',':SC
IF SB NE EMPTY THEN LOCN = LOCN:':",":"':SB:'"'
SPOS.MAX = 3
*
CASE VC NE EMPTY
EXTR = '<':TMP.AC:',':VC:'>'; LOCN = TMP.AC:':",":':VC
SPOS = TMP.AC:',':VC
IF SB NE EMPTY THEN LOCN = LOCN:':",,":"':SB:'"'
SPOS.MAX = TWO
*
CASE AC NE EMPTY
IF EQ.F THEN
EXTR = EMPTY; LOCN = ONE; SPOS = EMPTY
END ELSE
* IF TRUE.AC THEN
EXTR = '<':TMP.AC:'>'; LOCN = TMP.AC; SPOS = TMP.AC
* END ELSE
* * EXTR = '<':SIR.AC - REF.AC + ONE:">"; LOCN = SIR.AC - REF.AC + ONE; SPOS = SIR.AC - REF.AC + ONE
* EXTR = '<1>'; LOCN = '1'; SPOS = '1'
* END
END
IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
SPOS.MAX = ONE
*
CASE FL NE EMPTY
EXTR = EMPTY; LOCN = ONE; SPOS = EMPTY
IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
SPOS.MAX = ZERO
*
CASE TRUE
VTYPE = EMPTY; EXTR = EMPTY; LOCN = EMPTY; SPOS = EMPTY; SPOS.MAX = ZERO
*
END CASE
*
INST = EXTR; LOCT = EXTR
IF VTYPE.VC THEN
IF VTYPE.VC GT ONE THEN
TMP = INDEX(EXTR,',',VTYPE.VC - ONE)
IF NOT(TMP) THEN TMP = INDEX(EXTR,'>',ONE)
INST = EXTR[ONE,TMP - ONE]:'>'
END ELSE
INST = EMPTY
END
IF VTYPE.VC GT TWO THEN
TMP = INDEX(EXTR,',',VTYPE.VC - TWO)
IF NOT(TMP) THEN TMP = INDEX(EXTR,'>',ONE)
LOCT = EXTR[ONE,TMP - ONE]:'>'
END ELSE
LOCT = EMPTY
END
END
*
RETURN
!
END
~SOURCEGEN.START~
SUBROUTINE SOURCEGEN.START(TOP.LNS,SCR.APPL,SCR.SUB.APPL,SCR.ID,RELEASE.ID,INP.C,SBR,TF,STAT)
*CODE.SEGMENT: SOURCEGEN.START
*
* DAVID HORSMAN
* APR 91
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
TOP.LNS = EMPTY
TOP.LNS<-ONE> = '*PROGRAM:           SH.':SCR.ID
TOP.LNS<-ONE> = '* AUTHOR:            XXX'
TOP.LNS<-ONE> = '* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"'
TOP.LNS<-ONE> = '*                              (Axion)        (Macroscope)'
TOP.LNS<-ONE> = '*VS ':OCONV(DATE(),'D2'):' (':RELEASE.ID:')'
TOP.LNS<-ONE> = '*  UTILITY PRODUCT BY Axion Computer Systems'
TOP.LNS<-ONE> = '*                              &'
TOP.LNS<-ONE> = '*                 Macroscope Design Matrix'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '!'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '* DATE WRITTEN:      ':OCONV(DATE(),"D2"):' ':OCONV(TIME(),'MTS')
TOP.LNS<-ONE> = '* DATE RELEASED:     DD MMM YY'
TOP.LNS<-ONE> = '* MODIFICATIONS:     DATE       NAME        DESCRIPTION'
TOP.LNS<-ONE> = '*                    DD MMM YY'
TOP.LNS<-ONE> = '!'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*FUNC.LNS*'
TOP.LNS<-ONE> = '$INCL':'UDE IBP STANDARD.FUNCTIONS'
TOP.LNS<-ONE> = '*FUNC.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '!'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*SEC.DIM*'
TOP.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.DIM'
TOP.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.EQUATES'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.ON'
TOP.LNS<-ONE> = '*SEC.DIM.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*MNU.DIM*'
TOP.LNS<-ONE> = '$INCL':'UDE IBP PAR.MENU.DIM'
TOP.LNS<-ONE> = '$INCL':'UDE IBP PAR.MENU.EQUATES'
TOP.LNS<-ONE> = '*MNU.DIM.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*TST.DIM*'
TOP.LNS<-ONE> = '$INCL':'UDE IBP CNT.TST.DIM'
TOP.LNS<-ONE> = '$INCL':'UDE IBP CNT.TST.EQUATES'
TOP.LNS<-ONE> = '*TST.DIM.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '!'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*INPUT.LNS*'
TOP.LNS<-ONE> = 'INPUT DISP.ONLY:'
TOP.LNS<-ONE> = 'AUTO.RUN = 0'; * 11NOV93 ** TOP.LNS<-ONE> = 'INPUT AUTO.RUN:'
TOP.LNS<-ONE> = 'INPUT AUTO.RUN:'
* TOP.LNS<-ONE> = 'INPUT GENERIC:'
TOP.LNS<-ONE> = '*INPUT.END*'
*
IF INP.C NE EMPTY THEN
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = 'GOSUB INP.C; * : *'
END
*
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*SYS.LNS*'
TOP.LNS<-ONE> = '*ID.LNS*'
TMP = SCR.APPL; IF TMP EQ EMPTY THEN TMP = "SYS"
TOP.LNS<-ONE> = 'SYS = EMPTY; SYS.APPL = "':TMP:'"'
TOP.LNS<-ONE> = 'SYS.APPL.SUB = "':SCR.SUB.APPL:'"'
TOP.LNS<-ONE> = 'SYS.PROG = "':SCR.ID:'"'
TOP.LNS<-ONE> = 'SYS.LOCT = "INIT"'
TOP.LNS<-ONE> = 'LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY'
TOP.LNS<-ONE> = 'LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY'
TOP.LNS<-ONE> = 'LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = 'SCR.ID = "':SCR.ID:'"'
TOP.LNS<-ONE> = '*ID.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = 'SYS.PROG.TYPE = "PROG"'
TOP.LNS<-ONE> = 'RELEASE.ID = "':RELEASE.ID:'"'
TOP.LNS<-ONE> = 'DT = DATE(); TM = TIME(); ELP = ZERO'
TOP.LNS<-ONE> = '*SYS.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*CNTR.LNS*'
TOP.LNS<-ONE> = '*'
**IF INPUT.TYPE EQ "C" THEN
**TOP.LNS<-ONE> = '*'
**TOP.LNS<-ONE> = '$INCL':'UDE IBP CURSOR.EQUATES'
**END
**
**IF INP.C NE EMPTY THEN
**TOP.LNS<-ONE> = '*'
**TOP.LNS<-ONE> = 'GOSUB INP.C; * : *'
**END
***
TOP.LNS<-ONE> = '*CNTR.VAR.LNS*'
TOP.LNS<-ONE> = 'REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE'
TOP.LNS<-ONE> = 'DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY'
TOP.LNS<-ONE> = 'REFLN = EMPTY; SAVE.REFLN = EMPTY'
TOP.LNS<-ONE> = 'LPT.STAT = FALSE; LPT.FL = FALSE'
TOP.LNS<-ONE> = 'LN.LOC = ZERO; SUB.REF.LOC = ZERO'
TOP.LNS<-ONE> = 'FIXED = FALSE; NUMC = FALSE'
TOP.LNS<-ONE> = 'FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO'
TOP.LNS<-ONE> = '*CNTR.VAR.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*COM.LNS*'
TOP.LNS<-ONE> = 'OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)'
* TOP.LNS<-ONE> = 'OPEN "COM" TO COM.FILE ELSE'
* TOP.LNS<-ONE> = 'PRINT CLB:"COM File missing! ":'
* TOP.LNS<-ONE> = 'IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:'
* TOP.LNS<-ONE> = 'STOP'
* TOP.LNS<-ONE> = 'END'
TOP.LNS<-ONE> = '*COM.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*CNT.LNS*'
TOP.LNS<-ONE> = 'OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)'
* TOP.LNS<-ONE> = 'OPEN "CNT" TO CNT.FILE ELSE'
* TOP.LNS<-ONE> = 'PRINT CLB:"CNT File missing! ":'
* TOP.LNS<-ONE> = 'IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:'
* TOP.LNS<-ONE> = 'STOP'
* TOP.LNS<-ONE> = 'END'
TOP.LNS<-ONE> = '*CNT.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*PAR.LNS*'
TOP.LNS<-ONE> = 'OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)'
* TOP.LNS<-ONE> = 'OPEN "PAR" TO PAR.FILE ELSE'
* TOP.LNS<-ONE> = 'PRINT CLB:"PAR File missing! ":'
* TOP.LNS<-ONE> = 'IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:'
* TOP.LNS<-ONE> = 'STOP'
* TOP.LNS<-ONE> = 'END'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*SEC.LNS*'
TOP.LNS<-ONE> = 'CALL.ID = EMPTY; PORT.KEY = EMPTY'
TOP.LNS<-ONE> = 'PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY'
TOP.LNS<-ONE> = 'MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY'
TOP.LNS<-ONE> = 'SEC.USER.ID = PAR.MENU$USER'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = 'CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)'
TOP.LNS<-ONE> = '*SEC.END*'
TOP.LNS<-ONE> = '*PAR.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*ACC.LNS*'
TOP.LNS<-ONE> = '$INCL':'UDE IBP SYS.INCL.ACC.OPSYS'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = 'OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)'
* TOP.LNS<-ONE> = 'OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE'
* TOP.LNS<-ONE> = 'PRINT CLB:"ACC File missing! ":'
* TOP.LNS<-ONE> = 'IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:'
* TOP.LNS<-ONE> = 'STOP'
* TOP.LNS<-ONE> = 'END'
TOP.LNS<-ONE> = '*ACC.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*TST.LNS*'
TOP.LNS<-ONE> = 'CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY'
TOP.LNS<-ONE> = 'GOSUB LOAD.TST; * : *'
TOP.LNS<-ONE> = '*TST.END*'
TOP.LNS<-ONE> = '*'
TOP.LNS<-ONE> = '*CNTR.END*'
TOP.LNS<-ONE> = '*'
*
RETURN
*
END
~SOURCEGEN.SUBR.DISPLN~
SUBROUTINE SOURCEGEN.SUBR.DISPLN(DISP.LN,CLEAR.LN,FLNM,EXTR,CONV,LN,CL,SORTED,SUB.NUM,VTYPE,VTYPE.SEP,MS,TEMP.RSP,TRANSL,TRN.NUM)
*CODE.SEGMENT: SOURCEGEN.SUBR.DISPLN
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* JUN 93
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP DCT.EQUATES
*
*
*
*
IF NOT(SORTED) AND SUB.NUM EQ ONE THEN
* SPOS.DISP<LN + ONE,SCL.LOC> = 'SPACE(TWO - LEN(':VTYPE:')):':VTYPE:':" ":':DISP.LN:' "':MS:'"'
DISP.LN = 'PRINT @(':CL - 3:',LN):SPACE(TWO - LEN(':VTYPE:')):RVB:':VTYPE:':RVE:" ":':DISP.LN:' "':MS:'":'
CLEAR.LN = 'PRINT @(':CL-3:',LN.TMP):SPACE(':MS[3,TWO]+3:'):'
* ? *TEMP.RSP = '" "'
* ? *IF SUB.NUM EQ ONE THEN TEMP.RSP = 'RSP' ELSE TEMP.RSP = '" "'
IF SUB.NUM EQ ONE THEN TEMP.RSP = 'FLD' ELSE TEMP.RSP = 'EMPTY'
*960520*DGH*TEMP.RSP = 'EMPTY'
END ELSE
* SPOS.DISP<LN + ONE,SCL.LOC> = DISP.LN:' "':MS:'"'
DISP.LN = 'PRINT @(':CL:',LN):':DISP.LN:' "':MS:'":'
CLEAR.LN = 'PRINT @(':CL:',LN.TMP):SPACE(':MS[3,TWO]:'):'
* ? *IF SUB.NUM EQ ONE THEN TEMP.RSP = 'RSP' ELSE TEMP.RSP = '" "'
IF SUB.NUM EQ ONE THEN TEMP.RSP = 'FLD' ELSE TEMP.RSP = 'EMPTY'
END
*
IF TRANSL THEN
DISP.LN = DISP.LN:'; GOSUB T':(TRN.NUM + 100)[TWO,TWO]
CLEAR.LN = CLEAR.LN:'; GOSUB TC':(TRN.NUM + 100)[TWO,TWO]
END
*
!
*
RETURN; * To calling program
*
END
~SOURCEGEN.SUBR.ERRLNS~
SUBROUTINE SOURCEGEN.SUBR.ERRLNS(ERR.LNS)
*CODE.SEGMENT: SOURCEGEN.SUBR.ERRLNS
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* JUN 93
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
!
*
ERROR.ROUTINE: * LOAD ERROR ROUTINE
*
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
ERR.LNS<-ONE> = '*ERR.LNS*'
ERR.LNS<-ONE> = 'ERROR: *'
ERR.LNS<-ONE> = 'IF TEXT EQ EMPTY THEN RETURN'
ERR.LNS<-ONE> = 'PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":'
ERR.LNS<-ONE> = 'INPUT RSP:; PRINT CLB:'
ERR.LNS<-ONE> = 'RETURN'
ERR.LNS<-ONE> = '*ERR.END*'
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
ERR.LNS<-ONE> = 'SYS.DEBUG: *'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'DEBUG'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'RETURN'
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
ERR.LNS<-ONE> = '$INCL':'UDE IBP CLS.ROUTINE'
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
ERR.LNS<-ONE> = 'LOAD.STD.DATA: *'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'RETURN'
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
ERR.LNS<-ONE> = 'ENTER.STD.SUBR: *'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'RETURN'
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
ERR.LNS<-ONE> = 'ENTER.STD.EXEC: *'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = '! Load test data'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'LOAD.TST: *'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)'
ERR.LNS<-ONE> = '*'
ERR.LNS<-ONE> = 'RETURN'
ERR.LNS<-ONE> = '*':AM:'!':AM:'*'
*
RETURN; * To calling program
*
END
~SOURCEGEN.SUBR.SPOS~
SUBROUTINE SOURCEGEN.SUBR.SPOS(CL,LN,SCL.LOC,SPOS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.DISP,INP.NUM,SAVE.PMPT.TYPE,START.LN,REF.AC,FIRST.AC,TF,STAT)
*CODE.SEGMENT: SOURCEGEN.SUBR.SPOS
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* JUN 93
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
!
*
INP.LBL = (INP.NUM + 100)[TWO,TWO]
LOCATE CL IN SPOS.LOC<LN + ONE> BY "AR" SETTING SCL.LOC ELSE
IF LN GT SPOS.LOC.MAX THEN SPOS.LOC.MAX = LN; SPOS.LOC<LN + ONE> = EMPTY; SPOS.REF<LN + ONE> = EMPTY
INS CL BEFORE SPOS.LOC<LN + ONE,SCL.LOC>
INS EMPTY BEFORE SPOS.REF<LN + ONE,SCL.LOC>
INS EMPTY BEFORE SPOS.DISP<LN + ONE,SCL.LOC>
END
SPOS.REF<LN + ONE,SCL.LOC> = SAVE.PMPT.TYPE:"|":LN - START.LN + ONE:"|":REF.AC - FIRST.AC + ONE
*
!
*
RETURN; * To calling program
*
END
~SOURCEGEN.SUBR.SUBREF~
SUBROUTINE SOURCEGEN.SUBR.SUBREF(RTN.LNS,INP.LBL,INP.NUM,INPUT.REQD,CURR.AC,FIRST.AC,RTN.LN,SUB.NUM,MAX.NUM,LINE,TF,STAT)
*CODE.SEGMENT: SOURCEGEN.SUBR.SUBREF
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* MAY 93
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP DCT.EQUATES
*
*
INP.LBL = (INP.NUM + 100)[TWO,TWO]
IF INPUT.REQD THEN
RTN.LN = 'I':INP.LBL:': *'
* MAX.NUM = (LM - LN + ONE) * MAX.NUM
*
IF CURR.AC EQ FIRST.AC THEN IF MAX.NUM GT ONE THEN
RTN.LNS<-ONE> = '*':AM:'!':AM:'*'
RTN.LNS<-ONE> = RTN.LN
RTN.LNS<-ONE> = '*'
RTN.LNS<-ONE> = 'FOR SUB.REF = ONE TO ':MAX.NUM
LINE = ''
*@@@
*
FOR SUB.NUM = ONE TO MAX.NUM
LINE = LINE:'I':INP.LBL:CHAR(SUB.NUM+64):','
NEXT SUB.NUM
*
RTN.LNS<-ONE> = 'IF SUB.REF GE SUB.REF.LOC THEN'
RTN.LNS<-ONE> = 'ON SUB.REF GOSUB ':LINE[ONE,LEN(LINE) - ONE]
RTN.LNS<-ONE> = 'TC.FUNC = EMPTY; TC.OUT = EMPTY'
* RTN.LNS<-ONE> = 'IF STAT THEN IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO; IF SUB.REF LT ZERO THEN SUB.REF = ':MAX.NUM
RTN.LNS<-ONE> = 'IF STAT THEN'
RTN.LNS<-ONE> = 'IF STAT EQ 999 THEN RETURN'
RTN.LNS<-ONE> = 'IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO'
RTN.LNS<-ONE> = 'IF SUB.REF LT ZERO THEN SUB.REF = ':MAX.NUM
RTN.LNS<-ONE> = 'END ELSE'
RTN.LNS<-ONE> = 'IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN RETURN'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'SUB.REF.LOC = ZERO'
RTN.LNS<-ONE> = 'END'
RTN.LNS<-ONE> = 'NEXT SUB.REF'
RTN.LNS<-ONE> = 'RETURN'
SUB.NUM = ONE
*
END; * of curr.ac = 1st.ac and max.num > 1
*
END; * of input.reqd
*
*
RETURN; * To calling program
*
END
~SOURCEGEN.TRANSL~
*CODE.SEGMENT: SOURCEGEN.TRANSL
*
*
SAVE = AC:AM:VC:AM:SC:AM:REDISP:AM:TRUE.AC:AM:VTYPE:AM:VTYPE.VC:AM:VTYPE.FL:AM:SQ:AM:VF:AM:EXTR:AM:INST:AM:POSN:AM:LOCT:AM:LOCN:AM:OLD.LOCN:AM:FLNM
CURR.AC = CURR.AC + ONE
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
* IF AC EQ ZERO THEN
* EXTR = '<':REF.AC - ID.AC + ONE:'>'
* END
TRN.LNS<-ONE> = 'T':(TRN.NUM + 100)[TWO,TWO]:': *':AM:'*'
IF TRUE.AC EQ ZERO THEN
TRN.LNS<-ONE> = 'TRN.FLD = RSP'
END ELSE
TRN.LNS<-ONE> = 'TRN.FLD = ':FLNM:EXTR
END
*
* Read item is an READV attribute reference
*           with TRN.FLD as the key
*   format: \XX99\AC\VC\SVC
*
IF DT<ONE,ONE,3> MATCHES "0N" THEN
TMP = INDEX(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".FILE",ONE)
IF REC.FL<ONE,ED2> THEN TMP = INDEX(FLNMS<ONE,ED2>,".",ONE)
IF NOT(TMP) THEN TMP = LEN(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>) + ONE
TMP2 = FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>[ONE,TMP - ONE]
TRN.LNS<-ONE> = 'READV TRN.FLD FROM ':TMP2:'.FILE,TR.FLD,':DT<ONE,ONE,3>:' ELSE TRN.FLD = EMPTY'
*
IF DT<ONE,ONE,5> NE EMPTY THEN
TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:',':DT<ONE,ONE,5>:'>'
END ELSE IF DT<ONE,ONE,4> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:'>'
*
IF DT<ONE,ONE,6> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = FIELD(TRN.FLD,"':DT<ONE,ONE,6>[ONE,ONE]:'",':DT<ONE,ONE,6>[TWO,TWO]:')'
*
* Read item is and Item ID
*   format \XX99\Item.ID\locate.AC\display.AC
*       OR \XX99\Item.ID\locate.AC\2
*       OR \XX99\Item.ID\1\2
*
END ELSE
TMP = INDEX(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".FILE",ONE)
IF REC.FL<ONE,ED2[TWO,TWO]> THEN TMP = INDEX(FLNMS<ONE,ED2[TWO,TWO]>,".",ONE)
IF NOT(TMP) THEN TMP = LEN(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>) + ONE
TMP2 = FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>[ONE,TMP - ONE]
READ.ITEM = TMP2:'*':DT<ONE,ONE,3>
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
* TRN.LNS<-ONE> = 'LOCATE TRN.FLD IN ':DT<ONE,ONE,3>:'<ONE> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
TMP4 = DT<ONE,ONE,4>
TMP5 = DT<ONE,ONE,5>
TMP6 = 'LOCATE TRN.FLD IN ':DT<ONE,ONE,3>
IF LEN(TMP4) THEN
IF LEN(TMP5) THEN
TMP6 = TMP6:'<':TMP4:'> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<':TMP5:',LOC> ELSE TRN.FLD = EMPTY'
END ELSE
TMP6 = TMP6:'<':TMP4:'> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
END; * Of 5
END ELSE
TMP6 = TMP6:'<ONE> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
END; * Of 4
TRN.LNS<-ONE> = TMP6
END
*
TRN.LNS<-ONE> = 'PRINT @(':CL:',LN):TRN.FLD "':MS:'":'
TRN.LNS<-ONE> = 'RETURN'
TRN.LNS<-ONE> = '*'
TRN.LNS<-ONE> = 'TC':(TRN.NUM + 100)[TWO,TWO]:': *'
TRN.LNS<-ONE> = 'PRINT @(':CL:',LN):SPACE(':LH:'):'
TRN.LNS<-ONE> = 'RETURN'
*
IF TF AND (LN OR CL) AND LH THEN
FOR TMP = LN TO LM
PRINT @(CL,TMP):RVB:STR("#",LH):RVE:
NEXT TMP
* RQM
END
*
TRN.NUM = TRN.NUM + ONE; TRANSL = EMPTY
AC = SAVE<ONE>; VC = SAVE<TWO>; SC = SAVE<3>; REDISP = SAVE<4>
TRUE.AC = SAVE<5>; VTYPE = SAVE<6>; VTYPE.VC = SAVE<7>; VTYPE.FL = SAVE<8>
SQ = SAVE<9>; VF = SAVE<10>; EXTR = SAVE<11>; INST = SAVE<12>
POSN = SAVE<13>; LOCT = SAVE<14>; LOCN = SAVE<15>; OLD.LOCN = SAVE<16>
FLNM = SAVE<17>
*
~SOURCEGEN.VALID.REFS~
SUBROUTINE SOURCEGEN.VALID.REFS(REF.LNS,MAX.REF,PMPT.AC,SIR,TF,POS.LOC,POS.REF,POS.LOC.MAX,SPOS.LOC,SPOS.REF,SPOS.LOC.MAX,SPOS.DISP,STAT)
*CODE.SEGMENT: SOURCEGEN.VALID.REFS
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
!
*
VALID.REFERENCES: * VALID PROMPT REFERENCES
MAX.REF = EMPTY
LINE = EMPTY
POS.LOC = EMPTY; POS.REF = EMPTY; POS.LOC.MAX = ZERO
SPOS.LOC = EMPTY; SPOS.REF = EMPTY; SPOS.LOC.MAX = ZERO; SPOS.DISP = EMPTY
IF PMPT.AC THEN
CURR.AC = PMPT.AC
** IF TF THEN PRINT @(47,9):
LOOP DT = SIR<CURR.AC> UNTIL DT = EMPTY DO
IF TF THEN PRINT @(40,CURR.AC - PMPT.AC + 11):RVB:" r":RVE:CURR.AC - PMPT.AC + ONE:
REF = DT<ONE,ONE,ONE>
IF REF NE EMPTY AND REF[ONE,ONE] NE "," AND REF[ONE,ONE] NE '"' AND REF[ONE,ONE] NE "." AND REF[ONE,ONE] NE "'" THEN
LINE = LINE:REF:'":AM:"'
MAX.REF = MAX.REF + ONE
IF TF THEN PRINT RVB:"-":RVE:REF:">":
END
CURR.AC = CURR.AC + ONE
REPEAT
IF MAX.REF THEN
IF TF THEN PRINT @(40,CURR.AC - PMPT.AC + 12):RVB:" rm":RVE:MAX.REF:
REF.LNS = EMPTY
REF.LNS<-ONE> = '*'
REF.LNS<-ONE> = '*REF.LNS*'
* TOP OF PAGE VTYPE
REF.LNS<-ONE> = 'DIM TDL(':MAX.REF:'); MAT TDL = EMPTY'
* HI LINE PRINTED
REF.LNS<-ONE> = 'DIM TDH(':MAX.REF:'); MAT TDH = EMPTY'
* ITEM COUNT
REF.LNS<-ONE> = 'DIM TDI(':MAX.REF:'); MAT TDI = EMPTY'
* CURR ITEM LOC
REF.LNS<-ONE> = 'DIM TDX(':MAX.REF:'); MAT TDX = ONE'
REF.LNS<-ONE> = 'DIM SAVE.TDX(':MAX.REF:'); MAT SAVE.TDX = EMPTY'
*
REF.LNS<-ONE> = 'DIM TDM(':MAX.REF:'); MAT TDM = EMPTY'
*
REF.LNS<-ONE> = 'DIM TDS(':MAX.REF:'); MAT TDS = EMPTY'
*
REF.LNS<-ONE> = 'DIM TDR(':MAX.REF:'); MAT TDR = EMPTY'
*
* LN.CN.MAX
REF.LNS<-ONE> = 'DIM TDC(':MAX.REF:'); MAT TDC = EMPTY'
* LN.START
REF.LNS<-ONE> = 'DIM TDT(':MAX.REF:'); MAT TDT = EMPTY'
REF.LNS<-ONE> = 'VALID.REFS = "':LINE[ONE,LEN(LINE)-5]
REF.LNS<-ONE> = '*REF.END*'
REF.LNS<-ONE> = '*':AM:'!':AM:'*'
END
END
RETURN
!
END
~SOURCEGEN.WRITE~
SUBROUTINE SOURCEGEN.WRITE(LNS,SBR,SCR.APPL,SCR.SUB.APPL,SCR.ID,SBR.LN,BPF.FILE,SYS.FILE,SCR.FILE,EQF.FILE,SPOS.LOC,SPOS.REF,SPOS.DISP,MAT SCR.LNS,SIR,SIR.HDR,SIR.TEXTS,SIR.KEY,SIR.PMPT,MAT EQF,TF,EQF.MAX,DIM.LNS,EQU.LNS,REF.LNS,FLNMS,NO.DIM,REC.FL,KEY.FL,DEL.TBL)
*CODE.SEGMENT: SOURCEGEN.WRITE
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* NOV 91
*
$INCLUDE BP.SG SOURCEGEN.DOC.HDR
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*
EQU SO TO CHAR(14),SI TO CHAR(15)
*
$INCLUDE IBP EQT.DIM
$INCLUDE IBP EQF.DIM
*
$INCLUDE IBP SCR.LNS.DIM
*
$INCLUDE IBP DCT.EQUATES
$INCLUDE IBP SCREENS.HDR.VAR.EQUATES
*
!
*
WRITE.DATA: *
*
* WRITE RTN.LNS    ON SCR.FILE,SCR.ID:'*RTN'
*
* WRITE TRN.LNS    ON SCR.FILE,SCR.ID:'*TRN'
*
!
*
SPOS.BUILD: * BUILD CALL TO LOAD POSITION
*
SLP.LNS = EMPTY; OUT.LNS = EMPTY
*
OUT.LNS<-ONE> = 'SUBROUTINE SH.SUBR.SCR.':SCR.ID:'(':SBR.LN:',POS.LOC,POS.REF':')'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP STANDARD.FUNCTIONS.SUBR'
OUT.LNS<-ONE> = '*OVERRIDE'
*
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.DIM'
OUT.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.EQUATES'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP PAR.MENU.DIM'
OUT.LNS<-ONE> = '$INCL':'UDE IBP PAR.MENU.EQUATES'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP SEC.USER.ON'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '$INCL':'UDE IBP CNT.TST.DIM'
OUT.LNS<-ONE> = '$INCL':'UDE IBP CNT.TST.EQUATES'
OUT.LNS<-ONE> = '*'
*
INIT.LNS = EMPTY
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*DIM.LNS*'
IF DIM.LNS NE EMPTY THEN
INIT.LNS<-ONE> = DIM.LNS
END
INIT.LNS<-ONE> = 'DIM STD(50); MAT STD = EMPTY'
INIT.LNS<-ONE> = '*DIM.END*'
*
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*EQU.LNS*'
IF EQU.LNS NE EMPTY THEN
INIT.LNS<-ONE> = EQU.LNS
END
INIT.LNS<-ONE> = '$INCL':'UDE IBP STANDARD.FUNCTIONS.CLB'
INIT.LNS<-ONE> = '*EQU.END*'
*
INIT.LNS<-ONE> = '*'
INIT.LNS<-ONE> = '*REF.LNS*'
IF REF.LNS NE EMPTY THEN
INIT.LNS<-ONE> = REF.LNS
END
INIT.LNS<-ONE> = '*REF.END*'
INIT.LNS<-ONE> = '*'
*
OUT.LNS<-ONE> = INIT.LNS
*
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '!'
OUT.LNS<-ONE> = '*'
*
!
*
OUT.LNS<-ONE> = '*CURSOR.LNS*'
*
*28MAR94*OUT.LNS<-ONE> = '*REF.LNS*'
*
!
*
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = 'RETURN; * To calling program'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = '!'
OUT.LNS<-ONE> = '*'
OUT.LNS<-ONE> = 'END'
*
!
*
CURSOR.INS: *
*
* TMP1 = DCOUNT(SPOS.LOC,AM)
* FOR TMP = ONE TO TMP1
* IF SPOS.LOC<TMP> EQ EMPTY THEN SPOS.LOC<TMP> = "0"
* NEXT TMP
*
LOCATE '*CURSOR.LNS*' IN OUT.LNS SETTING LN THEN
TMP1 = SPOS.LOC; TMP2 = TRUE; TMP3 = EMPTY
LOOP
LINE = TMP1[1,50]; TMP1 = TMP1[51,9999]
GOSUB REMOVE.AM
IF TMP2 THEN
TMP3 = 'POS.LOC = "':LINE:'"'
TMP2 = FALSE
END ELSE
TMP3 = TMP3:AM:'POS.LOC = POS.LOC:"':LINE:'"'
END
WHILE LEN(TMP1) DO REPEAT
OUT.LNS<LN> = TMP3
END
*
LOCATE '*REF.LNS*' IN OUT.LNS SETTING LN THEN
TMP1 = SPOS.REF; TMP2 = TRUE; TMP3 = EMPTY
LOOP
LINE = TMP1[1,50]; TMP1 = TMP1[51,9999]
GOSUB REMOVE.AM
IF TMP2 THEN
TMP3 = 'POS.REF = "':LINE:'"'
TMP2 = FALSE
END ELSE
TMP3 = TMP3:AM:'POS.REF = POS.REF:"':LINE:'"'
END
WHILE LEN(TMP1) DO REPEAT
OUT.LNS<LN> = TMP3
END
*
!
*
* SLP.LNS<-ONE> = '*':AM:'!':AM:'*'
SLP.LNS<-ONE> = 'CALL SH.SUBR.SCR.':SCR.ID:'(':SBR.LN:',POS.LOC,POS.REF':')'
* SLP.LNS<-ONE> = '*':AM:'!':AM:'*'
*
WRITE OUT.LNS ON BPF.FILE,'SH.SUBR.SCR.':SCR.ID
*
LOCATE '*CURSOR.LNS*' IN LNS SETTING LN THEN
LNS<LN> = SLP.LNS
END
*
! Specal Deletions
*
DEL.ERROR = FALSE
DEL.CN.MAX = DCOUNT(DEL.TBL,AM)
FOR DEL.CN = ONE TO DEL.CN.MAX
DEL.FUNC = DEL.TBL<DEL.CN>
*
LOCATE '*':DEL.FUNC:'.LNS*' IN LNS SETTING DEL.CN.LO THEN
DEL.CN.LO = DEL.CN.LO + ONE
*
LOCATE '*':DEL.FUNC:'.END*' IN LNS SETTING DEL.CN.HI THEN
DEL.CN.HI = DEL.CN.HI - ONE
*
IF DEL.CN.HI GE DEL.CN.LO THEN
*
FOR LN = DEL.CN.LO TO DEL.CN.HI
LNS<LN> = '*d*':LNS<LN>
NEXT LN
*
END ELSE DEL.ERROR = TRUE; * of HI ge LO
*
END ELSE DEL.ERROR = TRUE; * of HI found
*
END ELSE DEL.ERROR = TRUE; * of LO found
*
NEXT DEL.CN
*
IF DEL.ERROR THEN PRINT CLB:"Deletion structure error!":BELL:
*
!
*
SUBST.CHARS: *
*
IF TF THEN PRINT @(ZERO,ZERO):RVB:'<SpecialChars : ':RVE:; * RQM 
*
GOSUB REMOVE.VM
*
GOSUB REMOVE.SVM
*
GOSUB REMOVE.ESC
*
LNS<-ONE> = 'END'
*
IF TF THEN 
PRINT CLB2:'< WritePGM >':
PRINT @(20,22):'< * Bytes : ':LEN(LNS) 'R#5':' >':
PRINT @(40,22):'< * Lines : ':DCOUNT(LNS,AM) 'R#5':' >':
* RQM
END
*
!
*
WRITE LNS ON BPF.FILE,'SH.':SCR.ID
*
IF SBR THEN
*
LINE = 'SUBROUTINE SH.SUBR.':SCR.ID:'(':SBR.LN:')'
LNS = LINE:AM:LNS
*
LOCATE '*FUNC.LNS*' IN LNS SETTING LN THEN
FOR TMP = 1 TO 10 UNTIL LNS<LN>[ONE,ONE] EQ "$"
LN = LN + ONE
NEXT TMP
IF LNS<LN>[ONE,ONE] EQ "$" THEN
LNS<LN> = LNS<LN>:'.SUBR'
LN = LN + ONE
LINE = '*OVERRIDE'
INS LINE BEFORE LNS<LN>
END
END
*
LOCATE '*ID.LNS*' IN LNS SETTING LN THEN
FOR TMP = 1 TO 10 UNTIL LNS<LN>[ONE,9] EQ "SYS.PROG "
LN = LN + ONE
NEXT TMP
IF LNS<LN>[ONE,9] EQ "SYS.PROG " THEN
LNS<LN> = 'SYS.PROG = "SH.SUBR.':SCR.ID:'"'
END
FOR TMP = 1 TO 10 UNTIL LNS<LN>[ONE,13] EQ "SYS.PROG.TYPE"
LN = LN + ONE
NEXT TMP
IF LNS<LN>[ONE,13] EQ "SYS.PROG.TYPE" THEN
LNS<LN> = 'SYS.PROG.TYPE = "SUBR"'
END
END
*
LOCATE '*INPUT.LNS*' IN LNS SETTING LN THEN
LOOP LN = LN + ONE UNTIL LNS<LN> EQ '*INPUT.END*' DO
LNS<LN> = '* ':LNS<LN>
REPEAT
END
*
LOCATE '*OPEN.LNS*' IN LNS SETTING LN THEN
LOOP LN = LN + ONE UNTIL LNS<LN> EQ '*OPEN.END*' DO
LNS<LN> = '* ':LNS<LN>
REPEAT
END
*
LOCATE '*SUB.LNS*' IN LNS SETTING LN THEN
LOOP LN = LN + ONE UNTIL LNS<LN> EQ '*SUB.END*' DO
LNS<LN> = '* ':LNS<LN>
REPEAT
END
*
*960501*DGH*LOCATE '*FIN.LNS*' IN LNS SETTING LN THEN
*960501*DGH*LOOP LN = LN + ONE UNTIL LNS<LN> EQ '*FIN.END*' DO
*960501*DGH*LNS<LN> = '* ':LNS<LN>
*960501*DGH*REPEAT
*960501*DGH*INS 'RETURN' BEFORE LNS<LN>
*960501*DGH*END
*
LOOP
LOCATE '*SUB.RTN*' IN LNS SETTING LN ELSE LN = ZERO
WHILE LN DO
LNS<LN> = 'RETURN'
REPEAT
*
WRITE LNS ON BPF.FILE,'SH.SUBR.':SCR.ID
*
END
*
LINE = 'CALL SH.SUBR.':SCR.ID:'(':SBR.LN:')'
WRITE LINE ON SCR.FILE,'*CALL.':SCR.ID
* WRITE POS.LOC ON SCR.FILE,'*CURSOR.':SCR.ID
* WRITE POS.REF ON SCR.FILE,'*REF.':SCR.ID
WRITE SPOS.LOC  ON SCR.FILE,'*CURSOR.':SCR.ID
WRITE SPOS.REF  ON SCR.FILE,'*REF.':SCR.ID
WRITE SPOS.DISP ON SCR.FILE,'*SDISP.':SCR.ID
*
MATWRITE SCR.LNS ON SCR.FILE,SCR.ID:'*BGM'
* WRITE DIM.LNS    ON SCR.FILE,SCR.ID:'*DIM'
* WRITE EQU.LNS    ON SCR.FILE,SCR.ID:'*EQU'
WRITE REF.LNS    ON SCR.FILE,SCR.ID:'*REF'
*
* WRITE TOP.LNS    ON SCR.FILE,SCR.ID:'*TOP'
* WRITE INIT.LNS   ON SCR.FILE,SCR.ID:'*INIT'
* WRITE OPEN.LNS   ON SCR.FILE,SCR.ID:'*OPEN'
* WRITE READ.LNS   ON SCR.FILE,SCR.ID:'*READ'
* WRITE MAIN.LNS   ON SCR.FILE,SCR.ID:'*MAIN'
* WRITE KEY.LNS    ON SCR.FILE,SCR.ID:'*KEY'
* WRITE CALL.LNS   ON SCR.FILE,SCR.ID:'*CALL'
*BGR
*FGR
* WRITE ERR.LNS    ON SCR.FILE,SCR.ID:'*ERR'
*BOT
*
WRITE SIR        ON SCR.FILE,SCR.ID
WRITE SIR.HDR    ON SCR.FILE,SCR.ID:'*HDR'
WRITE SIR.TEXTS  ON SCR.FILE,SCR.ID:'*TEXTS'
WRITE SIR.KEY    ON SCR.FILE,SCR.ID:'*KEYS'
WRITE SIR.PMPT   ON SCR.FILE,SCR.ID:'*PROMPTS'
*
* Loop thru dictionary
IF TF THEN PRINT @(60,ONE):'Dict':; * RQM
FOR FL.CN = ONE TO 5
IF NOT(NO.DIM<ONE,FL.CN>) THEN
FOR CN = ONE TO EQF.MAX
IF EQF(FL.CN,CN) NE EMPTY THEN
IF EQF(FL.CN,CN)<DCT.WRFL> THEN
EQF(FL.CN,CN)<DCT.WRFL> = EMPTY
TMP = FLNMS<ONE,FL.CN>
TMP1 = INDEX(TMP,".",ONE)
IF TMP1 THEN
TMP2 = TMP[TMP1 + ONE,999]
TMP = TMP[ONE,TMP1 - ONE]
END ELSE TMP2 = EMPTY
IF TMP NE "DICT" THEN
IF REC.FL<ONE,FL.CN> AND LEN(TMP2) THEN TMP2 = TMP2:"." ELSE TMP2 = EMPTY
WRITE EQF(FL.CN,CN) ON EQF.FILE,TMP2:CN
END
PRINT @(65,ONE):FL.CN "R#3":" ":CN "R#3":
END
END
NEXT CN
END; * OF NOT(NO.DIM)
NEXT FL.CN
*
RETURN
*
!
*
REMOVE.SVM: *
*
$INCLUDE IBP SYS.INCL.REMOVE.SVM
*
RETURN
*
!
*
REMOVE.VM: *
*
$INCLUDE IBP SYS.INCL.REMOVE.VM
*
RETURN
*
!
*
REMOVE.AM: *
*
$INCLUDE IBP SYS.INCL.REMOVE.AM
*
!
*
REMOVE.ESC: *
*
$INCLUDE IBP SYS.INCL.REMOVE.ESC
*
RETURN
*
*
END
