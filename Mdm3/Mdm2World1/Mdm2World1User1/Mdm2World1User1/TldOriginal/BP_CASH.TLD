~CASH.CLEAR.XTR~
*PROGRAM: CASH.CLEAR.XTR
*
*      Clear Payments Tape XTR file
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CNT.XTRIND.DIM
*
$INCLUDE IBP CNT.XTRIND.EQUATES
*
! Open files
*
OPEN "XTR" TO XTR.FILE ELSE PRINT "Can't open XTR"; INPUT RSP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR"; INPUT RSP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT"; INPUT RSP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS"; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO
STAT = FALSE
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<ONE,ONE> ELSE CO.NAME = ""
*
! Display screen
*
PRINT @(ZERO,ZERO):CLS:
PRINT @(ZERO,ZERO):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28 - (((LEN(CO.NAME) + ONE) / TWO))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(ZERO,ONE):RVB:"                   Payments Tape Clear File                                     ":RVE:
*
! Get input
*
IF NOT(AUTO.RUN) THEN
*
LOOP
PRINT @(ZERO,3):CLL:RVB:"Enter the date you want cleared (YYMMDD): ":; INPUT CLEAR.DATE:
IF CLEAR.DATE EQ "KILL" THEN STOP
IF CLEAR.DATE NE "ALL" THEN
VALID.DATE = CLEAR.DATE[3,TWO]:"/":CLEAR.DATE[5,TWO]:"/":CLEAR.DATE[ONE,TWO]
IF VALID.DATE EQ "//" THEN VALID.RSLT = ZERO ELSE
VALID.RSLT = ICONV(VALID.DATE,"D")
END
END ELSE VALID.RSLT = ZERO
UNTIL VALID.RSLT OR CLEAR.DATE EQ "ALL" DO REPEAT
*
LOOP
PRINT @(ZERO,5):CLL:RVB:"Clear TRANSmission or RESET transmission: ":; INPUT CLEAR.TYPE
IF CLEAR.TYPE EQ "KILL" THEN STOP
UNTIL CLEAR.TYPE EQ "TRANS" OR CLEAR.TYPE = "RESET" DO REPEAT
*
LOOP
PRINT @(0,10):CLL:"Are you sure you want to clear that date? ":; INPUT RSP:
IF RSP EQ "N" OR RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "N" OR RSP EQ "KILL" DO REPEAT
*
END ELSE
CLEAR.DATE = CURRENT.RUN<ONE,TWO>
CLEAR.TYPE = CURRENT.RUN<ONE,3>
END
*
! Write auto
*
EXEC.VERB = "RUN BP CASH.CLEAR.XTR"
EXEC.IN = CLEAR.DATE:VM:CLEAR.TYPE
EXEC.DESC = "Clear XTR Dates"
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
! Process information
*
$INCLUDE IBP.CASH CASH.INCL.LCK.XTR
*
*
MATREAD CNT.XTRIND FROM CNT.FILE,"XTR.CTL" ELSE MAT CNT.XTRIND = EMPTY
*
PRINT @(ZERO,10):CLL:@(10):"Clearing transmission items for date ":CLEAR.DATE:" . . . ":
*
PGS = ZERO; LNS = 99
*
! Clear files
*
XTR.DT.CURR = EMPTY; XTR.TRANS.ID = EMPTY
*
IF CLEAR.TYPE EQ "TRANS" THEN
IF CLEAR.DATE NE "ALL" THEN
EXEC.VERB = 'EQ "':CLEAR.DATE:'*]"'
END ELSE
EXEC.VERB = EMPTY
END
END ELSE
EXEC.VERB = 'EQ "[*TRANS" OR "[*ERR" OR "[*HDR"'
END; * of reset
EXEC.RESULT = EMPTY
*
* ULT ONLY
EXECUTE "SSELECT XTR ":EXEC.VERB, //SELECT. > XTR.ID.LIST, //OUT. > EXEC.RESULT
*
* EXECUTE "SSELECT XTR ":EXEC.VERB; * REV ONLY
*
! Main loop
*
LOOP
*
* ULT ONLY
READNEXT XTR.ID FROM XTR.ID.LIST ELSE XTR.ID = "@@@"
*
* READNEXT XTR.ID ELSE XTR.ID = "@@@"; * REV ONLY
*
PRINT @(0,12):XTR.ID "R#15":
*
IF XTR.ID NE "XTR.CTL" THEN
*
XTR.DT = FIELD(XTR.ID,"*",ONE)
XTR.SEQ = FIELD(XTR.ID,"*",TWO)
XTR.TYPE = FIELD(XTR.ID,"*",3)
IF XTR.SEQ EQ "TRANS" THEN XTR.TYPE = XTR.SEQ
*
IF XTR.DT NE XTR.DT.CURR THEN
*
TMP = FIELD(CNT.XTRIND$INDEX<ONE,ONE>,"*",ONE)
IF CLEAR.TYPE EQ "RESET" AND TMP NE EMPTY AND (TMP EQ XTR.DT.CURR OR TMP EQ CLEAR.DATE) THEN
LOOP
DEL CNT.XTRIND$INDEX<ONE,ONE>
DEL CNT.XTRIND$REC.CN<ONE,ONE>
DEL CNT.XTRIND$REMT.CN<ONE,ONE>
DEL CNT.XTRIND$TOT.REMT<ONE,ONE>
DEL CNT.XTRIND$ERR<ONE,ONE>
DEL CNT.XTRIND$ERR.CN<ONE,ONE>
DEL CNT.XTRIND$FAILED<ONE,ONE>
DEL CNT.XTRIND$SPLIT<ONE,ONE>
TMP = FIELD(CNT.XTRIND$INDEX<ONE,ONE>,"*",ONE)
WHILE TMP NE EMPTY AND (TMP EQ XTR.DT.CURR OR TMP EQ CLEAR.DATE) DO REPEAT
IF ALL.FLAG THEN MATWRITE CNT.XTRIND ON CNT.FILE,"XTR.CTL"
END
*
IF CLEAR.DATE EQ "ALL" OR XTR.DT EQ CLEAR.DATE THEN
*
IF XTR.DT.CURR NE EMPTY THEN
CALL UNLOCK.ITEM(LCK.FILE,"XTR",XTR.TRANS.ID,LCK.FILE)
END
*
IF XTR.ID NE "@@@" THEN
XTR.TRANS.ID = XTR.DT:"*000001*TRANS"
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(XTR.FILE,"XTR",XTR.TRANS.ID,LCK.FILE,LCK.STAT)
WHILE LCK.STAT DO REPEAT
*
XTR.DT.CURR = XTR.DT
END; * of not @@@
*
END; * of new DT
*
END; * of ALL or same date
*
END; * of not XTR.CTL
*
UNTIL XTR.ID = "@@@" DO
*
IF (XTR.DT EQ CLEAR.DATE OR CLEAR.DATE EQ "ALL") AND XTR.ID NE "XTR.CTL" THEN
*
IF (XTR.TYPE EQ "TRANS" OR XTR.TYPE EQ "HDR" OR XTR.TYPE EQ "ERR") OR CLEAR.TYPE NE "RESET" THEN
*
DELETE XTR.FILE,XTR.ID
*
END
*
END
*
REPEAT
*
! End of main loop
*
IF ALL.FLAG THEN MATWRITE CNT.XTRIND ON CNT.FILE,"XTR.CTL"
*
IF XTR.DT.CURR NE EMPTY THEN
CALL UNLOCK.ITEM(LCK.FILE,"XTR",XTR.TRANS.ID,LCK.FILE)
END
*
$INCLUDE IBP.CASH CASH.INCL.RELS.XTR
*
*
STOP
*
END
~CASH.DAILY.REP~
*PROGRAM: CASH.DAILY.REP
* AUTHOR: DAVID HORSMAN
*         MACROSCOPE DESIGN MATRIX
*
EQU VS TO " (R:1.0)"
* COMPANY: AXION COMPUTER SYSTEMS
*
* DESCRIPTION:    PRINTS SUMMARY REPORT OF BATCHES FOR DAILY CASH
*                 RECONCILIATION
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
MAT CNT.CSH = EMPTY; CNT.CSH.ID = EMPTY
*
*
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
STAT = FALSE
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't find Company Data"; INPUT RSP; STOP
*
*
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; INPUT RSP; STOP
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; INPUT RSP; STOP
READ TRANS.TYPES.ADJ FROM PAR.FILE,"TRANS.TYPES.ADJ" ELSE PRINT "Can't read PAR TRANS.TYPES.ADJ"; INPUT RSP; STOP
READ TRANS.TYPES.PMT FROM PAR.FILE,"TRANS.TYPES.PMT" ELSE PRINT "Can't read PAR TRANS.TYPES.PMT"; INPUT RSP; STOP
READ TRANS.TYPES.DEP FROM PAR.FILE,"TRANS.TYPES.DEP" ELSE TRANS.TYPES.DEP = EMPTY
READ DAILY.REPORT FROM PAR.FILE,"DAILY.REPORT" ELSE DAILY.REPORT = 0
READ DAYS.TO.RETAIN FROM PAR.FILE,"DAYS.TO.RETAIN" ELSE
DAYS.TO.RETAIN = 7
* PRINT "Can't read PAR DAYS.TO.RETAIN"
* INPUT RSP; STOP
END
*
LPT.STAT = FALSE; LN.CN = 999; LN.CN.MAX = 60; PG = ZERO
*
! Load auto * : *
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
! Load Responses or auto.run info * : *
*
IF NOT(AUTO.RUN) THEN
*
*
! Update auto * : *
*
*
EXEC.VERB = "RUN BP CASH.DAILY.UPD"
EXEC.IN = EMPTY
EXEC.DESC = "Daily Cash Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
! Initialize program * : *
*
END; * of not auto.run
*
! Start * : *
*
START: *
*
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
* 
! Put up screen header * : *
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
PRINT @(ZERO,ZERO):CLS:
$INCLUDE IBP SYS.INCL.SCR.CO
*
TITLE = SCR.CO
TITLE<TWO> = "Daily Cash Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
TITLEA     = "Summary List Daily Batched Transactions"; *: *
*
HEADER = TITLE
PRINT @(ZERO,ONE):SPACE(40 - LEN(TITLE<TWO>) / TWO):RVB:TITLE<TWO> "L#40":RVE:
*
! Process Delivered Batches * : *
*
MAIN: *
*
FOR MAIN.CN = ONE TO CNT.CSH$EOD.COPIES.DRFT
HEADER = TITLEA<ONE>
PRINT @(ZERO,MAIN.CN + ONE):CLL:@(20,MAIN.CN + ONE):RVB:HEADER "L#40":RVE:@(ZERO,9):
GOSUB DAILY.POST; * : *
NEXT MAIN.CN
*
! End of program * : *
*
FINISH: *
*
STOP
*
! Daily reconcile / post * : *
*
DAILY.POST: *
*
BATCH.CLASS.TMP = CNT.CSH$EOD.CLASSES.FNL
CALL CASH.SUBR.CLASS.PARSE(BATCH.CLASS.TMP)
BATCH.SOURCE.TMP = CNT.CSH$EOD.SOURCES.FNL
CALL CASH.SUBR.SOURCE.PARSE(BATCH.SOURCE.TMP)
BATCH.SOURCE.CN = ZERO
*
LOOP WHILE LEN(BATCH.SOURCE.TMP) DO
BATCH.SOURCE.CN = BATCH.SOURCE.CN + ONE
*
BATCH.SOURCE.CURR = BATCH.SOURCE.TMP[ONE,ONE]
BATCH.SOURCE.TMP = BATCH.SOURCE.TMP[TWO,9999]
*
PRINT @(5,MAIN.CN + BATCH.SOURCE.CN):"(":BATCH.SOURCE.CN:") ":RVB:BATCH.SOURCE.CURR:RVE:@(ZERO,9):
BATCH.CLASS.TMP = CNT.CSH$EOD.CLASSES.FNL
CALL CASH.SUBR.CLASS.PARSE(BATCH.CLASS.TMP)
BATCH.CLASS.CN = ZERO
*
**  LOOP WHILE LEN(BATCH.CLASS.TMP) DO
BATCH.CLASS.CN = BATCH.CLASS.CN + ONE
*
**  BATCH.CLASS.CURR = BATCH.CLASS.TMP[ONE,ONE]
**  BATCH.CLASS.TMP = BATCH.CLASS.TMP[TWO,9999]
BATCH.CLASS.CURR = BATCH.CLASS.TMP
*
PRINT @(15,MAIN.CN + BATCH.SOURCE.CN):RVB:BATCH.CLASS.CURR:RVE:@(ZERO,9):
*
************
*
AUTO.RUN.SUBR    = "0"
CSH.TYPE.CURR    = "0P"
DT.OPEN.CURR     = "CLOSED"
PORT.CURR        = "ALL"
USER.VALID.CURR  = "ALL"
* LPT.DETAIL.CURR  = "SYP"
LPT.DETAIL.CURR  = "SYTE"
POST.FL          = FALSE
*
************
*
* EXEC.VERB = "RUN BP CASH.LIST.POST (D)"
EXEC.VERB = "RUN BP CASH.LIST.POST"
EXEC.IN = EMPTY
EXEC.IN<-ONE> = AUTO.RUN.SUBR
EXEC.IN<-ONE> = CSH.TYPE.CURR
EXEC.IN<-ONE> = BATCH.CLASS.CURR
EXEC.IN<-ONE> = BATCH.SOURCE.CURR
EXEC.IN<-ONE> = DT.OPEN.CURR
EXEC.IN<-ONE> = PORT.CURR
EXEC.IN<-ONE> = USER.VALID.CURR
EXEC.IN<-ONE> = LPT.DETAIL.CURR
EXEC.IN<-ONE> = POST.FL
*
EXEC.DESC = "Daily Transaction Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
************
*
**  REPEAT
*
REPEAT
*
RETURN
*
END
~CASH.DAILY.UPD~
*PROGRAM: CASH.DAILY.UPD
* AUTHOR: DAVID HORSMAN
*         MACROSCOPE DESIGN MATRIX
*
EQU VS TO " (R:1.2)"
* COMPANY: AXION COMPUTER SYSTEMS
*
* DESCRIPTION:    DELETES OLD BATCHES AND EXECUTES DAILY CASH POSTING
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
MAT CNT.CSH = EMPTY; CNT.CSH.ID = EMPTY
*
*
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
STAT = FALSE
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't find Company Data"; INPUT RSP; STOP
*
*
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; INPUT RSP; STOP
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; INPUT RSP; STOP
READ TRANS.TYPES.ADJ FROM PAR.FILE,"TRANS.TYPES.ADJ" ELSE PRINT "Can't read PAR TRANS.TYPES.ADJ"; INPUT RSP; STOP
READ TRANS.TYPES.PMT FROM PAR.FILE,"TRANS.TYPES.PMT" ELSE PRINT "Can't read PAR TRANS.TYPES.PMT"; INPUT RSP; STOP
READ TRANS.TYPES.DEP FROM PAR.FILE,"TRANS.TYPES.DEP" ELSE TRANS.TYPES.DEP = EMPTY
READ DAILY.REPORT FROM PAR.FILE,"DAILY.REPORT" ELSE DAILY.REPORT = 0
READ DAYS.TO.RETAIN FROM PAR.FILE,"DAYS.TO.RETAIN" ELSE
DAYS.TO.RETAIN = 7
* PRINT "Can't read PAR DAYS.TO.RETAIN"
* INPUT RSP; STOP
END
*
LPT.STAT = FALSE; LN.CN = 999; LN.CN.MAX = 60; PG = ZERO
*
! Load auto * : *
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
! Load Responses or auto.run info * : *
*
IF NOT(AUTO.RUN) THEN
*
*
! Update auto * : *
*
*
EXEC.VERB = "RUN BP CASH.DAILY.UPD"
EXEC.IN = EMPTY
EXEC.DESC = "Daily Cash Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
! Initialize program * : *
*
END; * of not auto.run
*
! Start * : *
*
START: *
*
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
* 
! Put up screen header * : *
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
PRINT @(ZERO,ZERO):CLS:
$INCLUDE IBP SYS.INCL.SCR.CO
*
TITLE = SCR.CO
TITLE<TWO> = "Daily Cash Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
TITLEA     = "Audit List Daily Batched Transactions"; *: *
TITLEA<2>  = "Delete Historical Batches"; *: *
TITLEA<3>  = "Clear Till / Operator Controls"; *: *
TITLEA<4>  = "Examine Saved Transactions"; *: *
*
HEADER = TITLE
PRINT @(ZERO,ONE):SPACE(40 - LEN(TITLE<TWO>) / TWO):RVB:TITLE<TWO> "L#40":RVE:
*
! Process Delivered Batches * : *
*
MAIN: *
*
FOR MAIN.CN = ONE TO 4
HEADER = TITLEA<MAIN.CN>
PRINT @(0,MAIN.CN + 3):CLL:@(20,MAIN.CN + 3):RVB:MAIN.CN "R#3":". ":HEADER "L#40":RVE:
ON MAIN.CN GOSUB DAILY.POST,CLEAR.HIST,CLEAR.CNT,UNPOSTED.BATCHES ; * : *
NEXT MAIN.CN
*
! End of program * : *
*
FINISH: *
*
STOP
*
! Daily reconcile / post * : *
*
DAILY.POST: *
*
BATCH.CLASS.TMP = CNT.CSH$EOD.CLASSES.FNL
CALL CASH.SUBR.CLASS.PARSE(BATCH.CLASS.TMP)
BATCH.SOURCE.TMP = CNT.CSH$EOD.SOURCES.FNL
CALL CASH.SUBR.SOURCE.PARSE(BATCH.SOURCE.TMP)
*
LOOP WHILE LEN(BATCH.SOURCE.TMP) DO
*
BATCH.SOURCE.CURR = BATCH.SOURCE.TMP[ONE,ONE]
BATCH.SOURCE.TMP = BATCH.SOURCE.TMP[TWO,9999]
*
PRINT @(10,MAIN.CN + 3):RVB:BATCH.SOURCE.CURR "R#3":RVE:
*
LOOP WHILE LEN(BATCH.CLASS.TMP) DO
*
BATCH.CLASS.CURR = BATCH.CLASS.TMP[ONE,ONE]
BATCH.CLASS.TMP = BATCH.CLASS.TMP[TWO,9999]
*
PRINT @(15,MAIN.CN + 3):RVB:BATCH.CLASS.CURR "R#3":RVE:
*
************
*
AUTO.RUN.SUBR    = "0"
CSH.TYPE.CURR    = "0P"
DT.OPEN.CURR     = "RECONCILED"
PORT.CURR        = "ALL"
USER.VALID.CURR  = "ALL"
LPT.DETAIL.CURR  = "DYPE"
POST.FL          = TRUE
*
************
*
EXEC.VERB = "RUN BP CASH.LIST.POST"
EXEC.IN = EMPTY
EXEC.IN<-ONE> = AUTO.RUN.SUBR
EXEC.IN<-ONE> = CSH.TYPE.CURR
EXEC.IN<-ONE> = BATCH.CLASS.CURR
EXEC.IN<-ONE> = BATCH.SOURCE.CURR
EXEC.IN<-ONE> = DT.OPEN.CURR
EXEC.IN<-ONE> = PORT.CURR
EXEC.IN<-ONE> = USER.VALID.CURR
EXEC.IN<-ONE> = LPT.DETAIL.CURR
EXEC.IN<-ONE> = POST.FL
*
EXEC.DESC = "Daily Transaction Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
************
*
REPEAT
*
REPEAT
*
RETURN
*
! Delete Historical * : *
*
CLEAR.HIST: *
*
*(CAJ): *
*
CAJ.UNPOSTED.IDS = EMPTY; PRINT @(ZERO,MAIN.CN + 7):
CAJ.POSTED.IDS = EMPTY
*
EXEC.VERB = 'WITH BUSINESS.DATE LE "':OCONV(CURR.ACCTG.DATE,"D2"):'" BY BUSINESS.DATE'
PRINT @(ZERO,MAIN.CN + 8):'SSELECT CAJ ':EXEC.VERB
PRINT
PRINT "Selecting Transaction File . . . "
*
EXECUTE 'SSELECT CAJ ':EXEC.TEXT
*
PRINT
PRINT "Processing Transaction Batches . . . "
PRINT
*
! Loop Through Batches * : *
*
LOOP
READNEXT CAJ.ID ELSE CAJ.ID = "@"
UNTIL CAJ.ID EQ "@" DO
*
PRINT CLB:CAJ.ID:
*
IF CAJ.ID NE EMPTY THEN
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
READV BATCH.HEADER FROM CAJ.FILE,CAJ.ID,ONE THEN
*
*@@@@ CHECK DELETE FLAG?????? 6 NOV 95
IF FIELD(BATCH.HEADER,"*",TWO) EQ "P" THEN
IF FIELD(BATCH.HEADER,"*",7) LE CURR.ACCTG.DATE - DAYS.TO.RETAIN THEN
DELETE CAJ.FILE,CAJ.ID
END ELSE
CAJ.POSTED.IDS<-ONE> = CAJ.ID
END
END ELSE
CAJ.UNPOSTED.IDS<-ONE> = CAJ.ID
END
*
END; * of batch on file
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
END; * Of ID not empty
*
REPEAT
*
RETURN
*
! Clear CNT transaction control items (batch lists) * : *
*
CLEAR.CNT: *
*
*(CNT): *
*
EXEC.VERB = 'EQ "CSHU]"'
PRINT @(ZERO,6):'SSELECT CNT ':EXEC.VERB
PRINT
PRINT "Selecting Transaction Control File . . . "
*
EXECUTE 'SSELECT CNT ':EXEC.TEXT
*
PRINT
PRINT "Processing Transaction Batch Lists . . . "
PRINT
*
! Loop Through Batch Lists * : *
*
LOOP
READNEXT CNT.ID ELSE CNT.ID = "@"
UNTIL CNT.ID EQ "@" DO
PRINT CLB:CNT.ID:
IF CNT.ID[ONE,5] EQ "CSHU*" OR CNT.ID[ONE,6] EQ "CSHUD*" THEN
BUS.DT = FIELD(CNT.ID,"*",TWO)
IF BUS.DT LE CURR.ACCTG.DATE - DAYS.TO.RETAIN THEN
DELETE CNT.FILE,CNT.ID
END
END
REPEAT
*
RETURN
*
! CNT closed dates * : *
*
CLEAR.CLOSED.DT: *
*
*(CNT): *
*
DT.CN = ZERO; DT.CN.MAX = DCOUNT(CNT$DT.OPEN<ONE>,VM)
LOOP
DT.CN = DT.CN + ONE
WHILE DT.CN LE DT.CN.MAX DO
IF CNT$DT.CLOSED<ONE,DT.CN> EQ "P" THEN
DEL CNT$DT.OPEN<ONE,DT.CN>
DEL CNT$DT.CLOSED<ONE,DT.CN>
DT.CN = DT.CN - ONE
DT.CN.MAX = DT.CN.MAX - ONE
END
REPEAT
*
RETURN
*
! Unposted Batches Report * : *
*
UNPOSTED.BATCHES: *
*
CALL PRINTER.SUBR.ONE(LPT.STAT)
*
PRINT; LN.CN = LN.CN + ONE
CAJ.ID.AC = ONE
*
LOOP CAJ.ID = CAJ.UNPOSTED.IDS<CAJ.ID.AC> UNTIL CAJ.ID EQ EMPTY DO
*
READV BATCH.HEADER FROM CAJ.FILE,CAJ.ID,ONE THEN
*
LINE = "Unposted "
*
BEGIN CASE
CASE FIELD(BATCH.HEADER,"*",ONE) EQ "C" 
LINE = LINE:"Cash"
CASE FIELD(BATCH.HEADER,"*",ONE) EQ "D" 
LINE = LINE:"Dep."
CASE FIELD(BATCH.HEADER,"*",ONE) EQ "A"
LINE = LINE:"Adj."
CASE FIELD(BATCH.HEADER,"*",ONE) EQ "B"
LINE = LINE:"Bil."
CASE TRUE
LINE = LINE:"????"
END CASE
*
LINE = LINE:" Batch No. ":CAJ.ID
LINE = LINE:" Status ":FIELD(BATCH.HEADER,"*",TWO)
LINE = LINE:" dated ":OCONV(FIELD(BATCH.HEADER,"*",7),"D2")
LINE = LINE "L#100":FIELD(BATCH.HEADER,"*",12) "R#5":OCONV(FIELD(BATCH.HEADER,"*",10),"MR2M") "R#14"
*
LN.CN = LN.CN + ONE
IF LN.CN GT LN.CN.MAX THEN GOSUB LPT.PG
*
PRINT LINE
*
END; * Of batch on file
*
CAJ.ID.AC = CAJ.ID.AC + ONE
*
REPEAT
*
!
*
TMP = DCOUNT(CAJ.POSTED.IDS,AM)
IF TMP THEN
IF TMP EQ ONE THEN
LINE = "There is one posted batch retained on file."
END ELSE
LINE = "There are ":TMP:" posted batches retained on file."
END
PRINT
PRINT LINE
LN.CN = LN.CN + TWO
END
*
CALL PRINTER.SUBR.OFF(LPT.STAT)
*
RETURN
*
!
*
LPT.PG: *
*
IF LN.CN.CN LT LN.CN.MAX THEN LN.CN = LN.CN + ONE; RETURN
*
PG = PG + ONE
LN.CN = 4
*
PRINT FF:TIMEDATE() "L#25":(SPACE(40 - LEN(TITLE<ONE>) / TWO):TITLE<ONE>) "L#80":("Page ":PG) "R#25"
PRINT SPACE(65 - LEN(TITLE<TWO>) / TWO):TITLE<TWO>
IF LEN(TITLE<3>) THEN PRINT SPACE(65 - LEN(TITLE<3>) / TWO):TITLE<3>; LN.CN = LN.CN + ONE
PRINT
PRINT HEADER<ONE>
IF LEN(HEADER<TWO>) THEN PRINT HEADER<TWO>; LN.CN = LN.CN + ONE
PRINT
*
RETURN
*
!
*
END
~CASH.ENTRY~
*PROGRAM: CASH.ENTRY 
* VERSION: 930305 2.X  CALLS CASH.SUBR.ENTRY
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Counter payments
*                  4 = Imported
*                  5 = Pay-Per-View Charges
*                  6 = Late Charges
*                  7 = Write Offs
*
*                  See list post program
*
*  
* DATE WRITTEN:    DD MMM 83
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
*                  26-JAN-88   HH   Cr. Status not updated for a 'Late
*                                   Notice' trans. unless Cr. Status is
*                                   less than Min. Delinq. criteria.
*                  01-AUG-88   HH   TRANS VAL 5 = Old Account Number
*                  24-NOV-88   HH   TRANS VAL 6 = 'Collection Account'
*                                   If active & updated balance # 0
*                                   then:
*                                   TRANS VAL 6 = BALANCE BILL.FREQS
!  
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
*  INCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
*  INCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
*  INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*  INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
*  INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
*  INCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*
STAT = ZERO
TITLE = "Transaction Entry"
TRANS.CLASS = EMPTY
TRANS.SUB.CLASS = EMPTY
SOURCE = EMPTY
LC.SOURCE = EMPTY
*
ENTRY.MODE = EMPTY; BACTH.CLASS.SEL = EMPTY
LN.TOP = EMPTY; LN.BOT = EMPTY; LN.HDR.TOP = EMPTY
RECPT.IMPRT.MODE = EMPTY; CSH.TYPE.CURR = EMPTY; BATCH.CLASS.CURR = EMPTY
BATCH.SOURCE.CURR = EMPTY; ALLOWED.MODE = EMPTY; DOLLAR.EDIT = EMPTY
CSH.TYPE = EMPTY; CSH.TYPE.CURR = EMPTY
FROM.LIST = FALSE
*
OPEN "ACT" TO ACT.FILE ELSE FILE.NAME = "ACT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
IF OPSYS NE "R" THEN OPEN "AAX" TO AAX.FILE ELSE FILE.NAME = "AAX"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ACG" TO ACG.FILE ELSE FILE.NAME = "ACG"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ADD" TO ADD.FILE ELSE FILE.NAME = "ADD"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ATR" TO ATR.FILE ELSE FILE.NAME = "ATR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "EFT" TO EFT.FILE ELSE FILE.NAME = "EFT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* LCK.FILE = 0; * REV ONLY
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
IF STAT THEN STOP
*
! COMMON AREA
*
*
RSP = EMPTY; STAT = EMPTY; UPDATED = EMPTY; CHANGED = EMPTY
*
*LCK.FILE = EMPTY; LCK.ITM = EMPTY; LCK.TYPE = EMPTY; LCK.STAT = EMPTY
*
ACG.ID = EMPTY; ACT.ID = EMPTY; ADD.ID = EMPTY; STT.ID = EMPTY; TPL.ID = EMPTY; WKO.ID = EMPTY; AIX.ID = EMPTY; SAVE.ACG.ID = EMPTY; SAVE.ACT.ID = EMPTY; SAVE.ADD.ID = EMPTY; SAVE.WKO.ID = EMPTY; CO.DATA = EMPTY
*
* ACG.FILE,ACT.FILE,ACX.FILE,ADD.FILE,ASH.FILE,ATH.FILE,ATR.FILE,CNT.FILE,DLQ.FILE,DVC.FILE,EFT.FILE,PAR.FILE,RTE.FILE,STT.FILE,STX.FILE,SVC.FILE,SVS.FILE,TAX.FILE,TPL.FILE,WKH.FILE,WKO.FILE,WKP.FILE
*
REF = EMPTY; NEXT.CALL = EMPTY; ALLOWED = EMPTY; ALLOW.MSG = EMPTY; PREV.ID = EMPTY; PRIOR.TNT.ID = EMPTY; PRIOR.ADD.ID = EMPTY; PEND.WO.NUMS = EMPTY; NEW.ADD = EMPTY; SERVICE.TOP = EMPTY; AI.TYPE = EMPTY; AI.TALK = EMPTY
*
SEC.USER.ID = EMPTY; HOLD.A = EMPTY; HOLD.B = EMPTY; HOLD.C = EMPTY
DISP.ONLY = EMPTY; SYS.TST = EMPTY
RSPBUF = EMPTY; PROCBUF = EMPTY
*
MAT ACT = EMPTY;  MAT ADD = EMPTY;  MAT ATR = EMPTY
MAT ASH = EMPTY;  MAT DLQ = EMPTY;  MAT DVC = EMPTY
MAT ACG = EMPTY; MAT EFT = EMPTY; MAT RTE = EMPTY
MAT STT = EMPTY; MAT SVC = EMPTY; MAT SVS = EMPTY
MAT TAX = EMPTY; MAT TPL = EMPTY; MAT WKO = EMPTY
MAT WKP = EMPTY; MAT SAVE.ACG = EMPTY; MAT SAVE.ACT = EMPTY
MAT SAVE.ADD = EMPTY; MAT SAVE.ATR = EMPTY
MAT SAVE.WKO = EMPTY; MAT AIX = EMPTY
*
* BELL,LF,FF,CR,AM,VM,SVM,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE,TT
*
! END OF COMMON
*
*
! READ CONTROL ITEMS
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
*
STAT = ZERO
*MAX.DESC = ONE; DESC.LEN = 5; INPUT.DESC = "N"
BELL.CN = ZERO; LIST.ALL = FALSE
CSH.TYPE = ONE
CSH.TYPE.CURR = ONE
BATCH.SOURCE.SEL = EMPTY
*
*
INPUT BATCH.CLASS.SEL
*
BEGIN CASE
CASE INDEX("0123",BATCH.CLASS.SEL,ONE)
NULL
CASE BATCH.CLASS.SEL EQ "4"
BATCH.SOURCE.SEL = BATCH.CLASS.SEL
BATCH.CLASS.SEL = "0"
CASE BATCH.CLASS.SEL EQ "5"
BATCH.SOURCE.SEL = BATCH.CLASS.SEL
BATCH.CLASS.SEL = "3"
CASE BATCH.CLASS.SEL EQ "6"
BATCH.SOURCE.SEL = BATCH.CLASS.SEL
BATCH.CLASS.SEL = "1"
CASE BATCH.CLASS.SEL EQ "7"
BATCH.SOURCE.SEL = BATCH.CLASS.SEL
BATCH.CLASS.SEL = "1"
END CASE
*
!
*
INPUT ENTRY.MODE
BATCH.CLASS.CURR = BATCH.CLASS.SEL
* BATCH.SOURCE.CURR = ZERO
*
!
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
!
*
START: *
*
LN.TOP = 4; LN.BOT = 20; LN.HDR.TOP = ZERO
*
CALL CASH.SUBR.ENTRY(LN.TOP,LN.BOT,LN.HDR.TOP,ENTRY.MODE,RECPT.IMPRT.MODE,CSH.TYPE,CSH.TYPE.CURR,BATCH.CLASS.CURR,BATCH.SOURCE.CURR,ALLOWED.MODE,DOLLAR.EDIT,FROM.LIST,PHAN.RUN)
*
*
STOP
*
END
~CASH.LBOX.IMP.SPLIT~
*PROGRAM: CASH.LBOX.IMP.SPLIT 
* VERSION: 910611 1.0  SPLIT LOCK BOX PAYMENTS IMPORT FILE & VERIFY
EQU VS TO " V:1.1"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1991              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
* DESCRIPTION:     THIS PROGRAM PROCESSES THE XTR FILE.
* If valid the data is output to the CAJ files for each company.
* This file is transfered to the host not more than once per day. It con-
* tains payments to be applied to customer acccounts. There can be more
* than one day to process at a time. Payments for all three companies can
* be present and are handler appropriately through file pointers.
*  
* DATE WRITTEN:    11 JUN 91
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
*
!  
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*
$INCLUDE IBP CNT.XTRIND.DIM
$INCLUDE IBP XTR.TRANS.DIM
*
$INCLUDE IBP CNT.XTRIND.EQUATES
$INCLUDE IBP XTR.TRANS.EQUATES
*
! Open files
*
OPEN "XTR" TO XTR.FILE ELSE PRINT "Can't open file XTR"; INPUT RSP; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = -3
STAT = FALSE
*
MAX.DESC = ONE; DESC.LEN = 5; INPUT.DESC = "N"
*
TITLE = "Cash"
TITLE1 = "Validate Transmission":VS
TRANS.CLASS = 'p'; TRANS.ITEM = "TRANS.TYPES.PMT"
TITLE2 = "Process Imported Payments - ":TITLE1
*
XTR = EMPTY; XTR.HDR = EMPTY; MAT XTR.TRANS = EMPTY; MAT CNT.XTRIND = EMPTY
XTR.ERRORS = EMPTY
*
SOURCE = "C"; LC.SOURCE = CHAR(SEQ(SOURCE)+32)
OPERATOR = "XTR"; DEFAULT.TYPE = "LB"; ITEM.COUNT = 0
BATCH.STATUS = "E"; ENTRY.TIME = EMPTY; ENTRY.DATE = EMPTY
POST.DATE = EMPTY; POST.TIME = EMPTY; BUS.DATE = EMPTY; EFF.DATE = EMPTY
DEFAULT.TYPE = "LB"; TRANS.TYPES = EMPTY; BATCH.DEL.STATUS = FALSE
BATCH.TYPE = EMPTY; BATCH.LPT.DT = EMPTY; BATCH.LPT.TM = EMPTY
BATCH.SOURCE = SOURCE; BATCH.CLASS = ONE; BATCH.INP.SOURCE = 4
BATCH.LST = EMPTY; BATCH.TILL = EMPTY
*
RUN.TRANS.CLASS = TRANS.CLASS
RUN.SOURCE = SOURCE
RUN.LC.SOURCE = LC.SOURCE
*
CO.PRE = EMPTY; CO.FIRST = TRUE; BATCH.CLASS.CURR = ONE; BATCH.SOURCE.CURR = 4
GOSUB OPEN.COMPANY
*
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
! Write auto
*
EXEC.VERB = "RUN BP CASH.LBOX.IMP.SPLIT"
EXEC.IN = EMPTY
EXEC.DESC = "Split LBox Pmts"
*
IF NOT(AUTO.RUN) THEN
* 26JAN94 NOT NEEDED * INPUT BATCH.CLASS.CURR:
END ELSE
* 26JAN94 NOT NEEDED * BATCH.CLASS.CURR = CURRENT.RUN<ONE,TWO>
END
*
EXEC.IN = BATCH.CLASS.CURR
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
! Load control
*
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT RSP:; STOP
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
READ ALL.FLAG FROM CNT.FILE,"ALL.FLAG" ELSE ALL.FLAG = TRUE
IF NOT(ALL.FLAG) THEN ATR.FLAG = FALSE; ACG.FLAG = FALSE; ACT.FLAG = FALSE
*
XTR.ID.FUNC = "POST"
XTR.ID.PREF = "XTR"
XTR.ID.SUFF = "REG"
XTR.POST.REG = EMPTY; XTR.POST.ERR = EMPTY; XTR.POST.OTH = EMPTY
*
*
$INCLUDE IBP.CASH CASH.INCL.LCK.XTR
*
IF STAT THEN STOP
*
$INCLUDE IBP.CASH CASH.INCL.RELS.XTR
*
*
$INCLUDE IBP.CASH CASH.INCL.LCK.APPL
*
IF STAT THEN STOP
*
MATREAD CNT.XTRIND FROM BASE.CNT.FILE,"XTR.CTL" ELSE MAT CNT.XTRIND = EMPTY
*
DOLLAR.EDIT = EMPTY; STAT = EMPTY; POSTED.BATCHES = EMPTY
*
! Process items
*
START: *
*
XTR.DT.CURR = EMPTY; XTR.DT.CURR.ID = EMPTY; XTR.DT = EMPTY; XTR.REC.TYPE.NEXT = EMPTY
XTR.FOUND = EMPTY; MAT XTR.TRANS = EMPTY; XTR.HDR = EMPTY; XTR.ERRORS = EMPTY
XTR.ERR = ZERO; XTR.ERR.CN = ZERO
XTR.SEQ = ZERO; XTR.SEQ.LAST = ZERO
XTR.TYPE = EMPTY
XTR.BAT = ZERO; XTR.BAT.LAST = ZERO
XTR.REC.CN = ZERO; XTR.TOT.REMT = ZERO; XTR.REMT.CN = ZERO
XTR.BAT.TOT.REMT = ZERO; XTR.BAT.REMT.CN = ZERO; XTR.BAT.ERR = FALSE
XTR.BAF.TOT.REMT = ZERO; XTR.BAF.REMT.CN = ZERO
XTR.ITEM.CN = ZERO; XTR.ITEM = ZERO; XTR.ITEM.LAST = ZERO
*
!!
*
! Validate XTR file
*
VALIDATE.FILE: *
*
*Select the XTR file by date*sequence number
PRINT @(0,18):
* ULT ONLY
EXECUTE "SSELECT XTR ", //SELECT. > XTR.VALID.ID.LIST
* EXECUTE "SSELECT XTR "; * REV ONLY
*
LOOP
*
LOOP
*
! Read next record
*
* ULT ONLY
READNEXT XTR.ID FROM XTR.VALID.ID.LIST ELSE
XTR.ID = "@@@"; * ULT ONLY
PRINT BELL:; * ULT ONLY
END; * ULT ONLY
* READNEXT XTR.ID ELSE XTR.ID = "@@@"; * REV ONLY
XTR.SEQ  = FIELD(XTR.ID,"*",TWO)
XTR.TYPE = FIELD(XTR.ID,"*",3)
IF XTR.ID NE "@@@" AND XTR.ID NE "XTR.CTL" AND XTR.TYPE NE "HDR" AND XTR.TYPE NE "TRANS" AND XTR.TYPE NE "ERR" THEN
READ XTR FROM XTR.FILE,XTR.ID ELSE XTR = EMPTY
PRINT @(25,10):XTR.ID "L#15":
XTR.REC.TYPE.NEXT = XTR[ONE,ONE]
END
*
IF XTR.ID NE "XTR.CTL" THEN
*
XTR.DT = FIELD(XTR.ID,"*",ONE)
XTR.ERR  = FALSE
*
*Detect break in date
*
IF XTR.TYPE NE "HDR" AND XTR.TYPE NE "TRANS" AND XTR.TYPE NE "ERR" THEN
*
IF XTR NE CR OR XTR.ID EQ "@@@" THEN
*
IF XTR.DT NE XTR.DT.CURR OR XTR.REC.TYPE.NEXT EQ ONE THEN
*
IF XTR.DT.CURR NE EMPTY THEN
*
* Validate end of last transmission
*
* Do not process previously split transmissions
*
IF NOT(XTR.TRANS$SPLIT) THEN
*
*Record Counts
IF XTR.REC.CN NE XTR.TRANS$REC.CN THEN
XTR.ERR = 15; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.TOT.REMT NE XTR.TRANS$TOT.REMT THEN
XTR.ERR = 7; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.REMT.CN NE XTR.TRANS$REMT.CN THEN
XTR.ERR = 8; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.FOUND<ONE,5> NE XTR.FOUND<ONE,7> THEN
XTR.ERR = 3; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
* File old transmission
*
*Index
INS XTR.DT.CURR.ID   BEFORE CNT.XTRIND$INDEX<ONE,ONE>
INS XTR.REC.CN       BEFORE CNT.XTRIND$REC.CN<ONE,ONE>
INS XTR.REMT.CN      BEFORE CNT.XTRIND$REMT.CN<ONE,ONE>
INS XTR.TOT.REMT     BEFORE CNT.XTRIND$TOT.REMT<ONE,ONE>
INS XTR.TRANS$ERR    BEFORE CNT.XTRIND$ERR<ONE,ONE>
INS XTR.ERR.CN       BEFORE CNT.XTRIND$ERR.CN<ONE,ONE>
INS XTR.TRANS$FAILED BEFORE CNT.XTRIND$FAILED<ONE,ONE>
INS XTR.TRANS$SPLIT  BEFORE CNT.XTRIND$SPLIT<ONE,ONE>
LOOP
TMP = DCOUNT(CNT.XTRIND$INDEX,VM)
WHILE TMP GT 15 AND NOT(STAT) DO
DEL CNT.XTRIND$INDEX<ONE,16>
DEL CNT.XTRIND$REC.CN<ONE,16>
DEL CNT.XTRIND$REMT.CN<ONE,16>
DEL CNT.XTRIND$TOT.REMT<ONE,16>
DEL CNT.XTRIND$ERR<ONE,16>
DEL CNT.XTRIND$ERR.CN<ONE,16>
DEL CNT.XTRIND$FAILED<ONE,16>
REPEAT
IF ALL.FLAG THEN MATWRITE CNT.XTRIND ON BASE.CNT.FILE,"XTR.CTL"
*Transmission Header
IF ALL.FLAG THEN WRITE XTR.HDR ON XTR.FILE,XTR.DT.CURR.ID:"*HDR"
*Transmission Statistics
XTR.TRANS$FOUND = XTR.FOUND
IF ALL.FLAG THEN MATWRITE XTR.TRANS ON XTR.FILE,XTR.DT.CURR.ID:"*TRANS"
*Transmission Errors
IF ALL.FLAG THEN WRITE XTR.ERRORS ON XTR.FILE,XTR.DT.CURR:"*000001*ERR"
*
END; * of previously split transmission
*
END; * of current date not empty
*
XTR.HDR = EMPTY; MAT XTR.TRANS = EMPTY
IF XTR.DT NE XTR.DT.CURR THEN XTR.ERRORS = EMPTY
XTR.DT.CURR = XTR.DT; XTR.DT.CURR.ID = XTR.ID
XTR.FOUND = EMPTY; XTR.HDR = EMPTY
MATREAD XTR.TRANS FROM XTR.FILE,XTR.DT.CURR.ID:"*TRANS" ELSE MAT XTR.TRANS = EMPTY
IF NOT(XTR.TRANS$SPLIT) THEN MAT XTR.TRANS = EMPTY
XTR.ERR = ZERO; XTR.BAT.ERR = TRUE; XTR.ERR.CN = ZERO
* XTR.SEQ.LAST = ZERO; * XTR.SEQ = ZERO
IF XTR.SEQ GT ONE THEN XTR.SEQ.LAST = XTR.SEQ - ONE ELSE XTR.SEQ.LAST = ZERO
XTR.BAT = ZERO; XTR.BAT.LAST = ZERO
XTR.REC.CN = ZERO; XTR.TOT.REMT = ZERO; XTR.REMT.CN = ZERO
XTR.BAT.TOT.REMT = ZERO; XTR.BAT.REMT.CN = ZERO; XTR.BAT.ERR = FALSE
XTR.BAF.TOT.REMT = ZERO; XTR.BAF.REMT.CN = ZERO
XTR.ITEM.CN = ZERO; XTR.ITEM = ZERO; XTR.ITEM.LAST = ZERO
*
END; * of date change
*
END; * of XTR not CR
*
END; * of not HDR or TRANS
*
END; * of not XTR.CTL
*
* Skip rest of transmission if gt 100 errors
WHILE ((XTR.TRANS$FAILED OR XTR.TRANS$SPLIT) OR XTR.TYPE EQ "HDR" OR XTR.TYPE EQ "TRANS" OR XTR.TYPE EQ "ERR" OR XTR.ID EQ "XTR.CTL" OR XTR EQ CR) AND NOT(STAT) AND XTR.ID NE "@@@" DO 
IF XTR EQ CR THEN XTR.SEQ.LAST = XTR.SEQ
REPEAT
*
*Detect end of file
*
UNTIL XTR.ID EQ "@@@" OR STAT DO
*
XTR.REC.CN = XTR.REC.CN + ONE
*
*Validate record type
XTR.REC.TYPE = XTR[ONE,ONE]; XTR.VALID = TRUE
IF NOT(NUM(XTR.REC.TYPE)) THEN XTR.VALID = FALSE ELSE
IF XTR.REC.TYPE LT ONE OR XTR.REC.TYPE GT 9 THEN XTR.VALID = FALSE
END
IF NOT(XTR.VALID) THEN
XTR.ERR = ONE; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
*Validate rec len
IF LEN(XTR) NE 80 THEN
XTR.ERR = 4; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
* XTR.VALID = FALSE
END
*
IF XTR.VALID THEN
*
*Extract headers
*     and
*Data records
*
*Validate ID sequence
IF NOT(NUM(XTR.SEQ)) THEN XTR.SEQ = ZERO
IF XTR.SEQ NE XTR.SEQ.LAST + ONE THEN
XTR.ERR = 13; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
XTR.SEQ.LAST = XTR.SEQ
*
BEGIN CASE
*
CASE XTR.REC.TYPE EQ 6
* Detail record
*
*Validate Batch Number
XTR.BAT = XTR[TWO,3]
IF NOT(NUM(XTR.BAT)) THEN XTR.BAT = ZERO
IF XTR.BAT NE XTR.TRANS$BAT.LAST THEN
XTR.ERR = 5; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
* Count remitances
XTR.REMT.CN = XTR.REMT.CN + ONE
XTR.BAT.REMT.CN = XTR.BAT.REMT.CN + ONE
*
*Validate Item Sequence
XTR.ITEM.CN = XTR.ITEM.CN + ONE
XTR.ITEM = XTR[5,3]
IF NOT(NUM(XTR.ITEM)) THEN XTR.ITEM = ZERO
* IF XTR.ITEM NE XTR.ITEM.LAST + ONE THEN
* XTR.ERR = 16; XTR.BAT.ERR = TRUE
* XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
* XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
* XTR.ERR.CN = XTR.ERR.CN + ONE
* END
XTR.ITEM.LAST = XTR.ITEM
XTR.REMT = XTR[8,10]
IF NOT(NUM(XTR.REMT)) THEN AMT.VALID = FALSE ELSE AMT.VALID = TRUE
IF NOT(AMT.VALID) THEN
XTR.ERR = 12; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END ELSE
XTR.TOT.REMT = XTR.TOT.REMT + XTR.REMT
XTR.BAT.TOT.REMT = XTR.BAT.TOT.REMT + XTR.REMT
END
*
XTR.ACCT = XTR[18,16]
LOOP WHILE XTR.ACCT[ONE,ONE] EQ "0" AND LEN(XTR.ACCT) GT 7 DO XTR.ACCT = XTR.ACCT[TWO,9999] REPEAT
XTR.TRANS.CD = XTR.ACCT[7,ONE]
XTR.ACCT = XTR.ACCT[ONE,6]
CALL MOD11.DIGIT(XTR.ACCT,CD)
IF CD NE XTR.TRANS.CD THEN
XTR.ERR = 11; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
CASE TRUE
* Header records
*
* Load header into XTR.HDR
XTR.HDR<XTR.REC.TYPE,-ONE> = XTR
* Check for duplicate headers
IF XTR.FOUND<ONE,XTR.REC.TYPE> THEN
IF XTR.REC.TYPE NE 5 AND XTR.REC.TYPE NE 7 THEN
XTR.ERR = 3; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
END
XTR.FOUND<ONE,XTR.REC.TYPE> = XTR.FOUND<ONE,XTR.REC.TYPE> + ONE
*
BEGIN CASE
*
CASE XTR.REC.TYPE EQ ONE
* Immediate Address Header
XTR.TRANS$TRANS.DT = XTR[24,6]; * YYMMDD
XTR.TRANS$TRANS.TM = XTR[30,4]; * HHMM
*
CASE XTR.REC.TYPE EQ TWO
* Service Record
NULL
*
CASE XTR.REC.TYPE EQ 5
* Lock Box Detail Header
* Batch Header Record
XTR.TRANS$BAT.LAST = XTR[TWO,3]; * NNN
XTR.TRANS$DEP.DT = XTR[15,6]; * YYMMDD
*
*Validate batch against last batch number
IF XTR.TRANS$BAT.LAST NE XTR.BAT.LAST + ONE THEN
XTR.ERR = 14; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
*Clear Batch fields for this batch
XTR.BAT.LAST = XTR.TRANS$BAT.LAST
IF NOT(NUM(XTR.BAT.LAST)) THEN XTR.BAT.LAST = ZERO
XTR.BAT.TOT.REMT = ZERO; XTR.BAT.REMT.CN = ZERO; XTR.BAT.ERR = FALSE
*
CASE XTR.REC.TYPE EQ 7
* Batch Total Record
XTR.BAT = XTR[TWO,3]
IF NOT(NUM(XTR.BAT)) THEN XTR.BAT = ZERO
IF XTR.BAT NE XTR.TRANS$BAT.LAST THEN
XTR.ERR = 5; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
XTR.DEP.DT = XTR[15,6]
IF XTR.DEP.DT NE XTR.TRANS$DEP.DT THEN
XTR.ERR = 9; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
XTR.SEQ = XTR[5,3]
XTR.LBOX = XTR[8,7]
XTR.BAF.REMT.CN = XTR[21,3]
XTR.BAF.TOT.REMT   = XTR[24,10]
XTR.TRANS$CALC.REMT.CN = XTR.REMT.CN
XTR.TRANS$CALC.TOT.REMT = XTR.TOT.REMT
*
*Validate Batch Totals
IF XTR.BAT.TOT.REMT NE XTR.BAF.TOT.REMT THEN
XTR.ERR = 7; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.BAT.REMT.CN NE XTR.BAF.REMT.CN THEN
XTR.ERR = 8; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
*Store Batch Infor on failed batch
IF XTR.BAT.LAST NE "0" THEN
IF XTR.BAT.ERR THEN
INS XTR.TRANS$BAT.LAST BEFORE XTR.TRANS$BAT<ONE>
INS XTR.BAT.REMT.CN    BEFORE XTR.TRANS$BAT.REMT.CN<ONE>
INS XTR.BAT.TOT.REMT   BEFORE XTR.TRANS$BAT.TOT.REMT<ONE>
INS XTR.TRANS$ERR      BEFORE XTR.TRANS$BAT.ERR<ONE>
END
END
*
XTR.ITEM.LAST = ZERO
*
CASE XTR.REC.TYPE EQ 8
* Service Total Record
* Transmission Total Record
*
XTR.DEP.DT = XTR[15,6]
IF XTR.DEP.DT NE XTR.TRANS$DEP.DT THEN
XTR.ERR = 10; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
XTR.SEQ = XTR[5,3]
XTR.LBOX = XTR[8,7]
XTR.TRANS$REMT.CN = XTR[21,5]
XTR.TRANS$TOT.REMT = XTR[26,10]
XTR.TRANS$CALC.REMT.CN = XTR.REMT.CN
XTR.TRANS$CALC.TOT.REMT = XTR.TOT.REMT
*
IF XTR.TRANS$REMT.CN NE XTR.TRANS$CALC.REMT.CN THEN
XTR.ERR = 17; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.TRANS$TOT.REMT NE XTR.TRANS$CALC.TOT.REMT THEN
XTR.ERR = 18; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
CASE XTR.REC.TYPE EQ 9
* End Of Transmission Record
XTR.TRANS$REC.CN = XTR[TWO,6]
*
CASE TRUE
XTR.ERR = TWO; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
*
END CASE
*
END CASE
*
END; * of valid record type
*
IF XTR.ERR.CN GT 100 THEN XTR.TRANS$FAILED = 3
*
REPEAT ; * get next date / seq
*
!!
*
! Create cash batches
*
SPLIT.XTR: *
*
TITLE1 = "Split into Batches"
TITLE2 = "Process Imported Payments - ":TITLE1
IF NOT(STAT) THEN
*
PRINT @(ZERO,6):SPACE(40 - LEN(TITLE1) / TWO + .5):RVB:TITLE1:RVE:
*
*Select the XTR file by date account number
*
EXECUTE "SSELECT XTR BY DATE BY ACCOUNT"
*
* Init fields
*
XTR.DT.CURR = EMPTY; XTR.DT.CURR.ID = EMPTY;  XTR.DT = EMPTY
MAT XTR.TRANS = EMPTY; XTR.HDR = EMPTY; XTR.ERRORS = EMPTY
IND.LOC = ONE; CO.NO = EMPTY; CO.NO.LAST = EMPTY
BAT.CN = ZERO; BAT.CN.BAD = ZERO
CAJ = EMPTY; CAJ.BAD = EMPTY
ITEM.COUNT = ZERO; ANY.FAILED = FALSE; ANY.SPLIT = FALSE
BATCH.TOTAL = ZERO; BATCH.TOTAL.BAD = ZERO
ENTERED.TOTAL = ZERO; ENTERED.TOTAL.BAD = ZERO
ADJUST.TOTAL = ZERO; ADJUST.TOTAL.BAD = ZERO
XTR.REC.TYPE = EMPTY
*
* Main Loop
*
LOOP
*
LOOP
*
*Read next id
*
READNEXT XTR.ID ELSE
XTR.ID = "@@@"
PRINT BELL:
END
IF XTR.ID NE "@@@" AND XTR.ID NE "XTR.CTL" THEN
READ XTR FROM XTR.FILE,XTR.ID ELSE XTR = EMPTY
PRINT @(25,10):XTR.ID "L#15":
END
*
IF XTR.ID NE "XTR.CTL" AND XTR NE CR THEN
*
XTR.DT = FIELD(XTR.ID,"*",ONE)
XTR.SEQ  = FIELD(XTR.ID,"*",TWO)
XTR.TYPE = FIELD(XTR.ID,"*",3)
XTR.REC.TYPE = XTR[ONE,ONE]
*
IF XTR.TYPE NE "HDR" AND XTR.TYPE NE "TRANS" AND XTR.TYPE NE "ERR" THEN
*
IF XTR.REC.TYPE EQ "6" THEN
*
*Extract Trans information
*
TRANS = EMPTY
TRANS.BAD = FALSE
*
*
* Check for change in date
IF XTR.DT NE XTR.DT.CURR THEN
*
IF XTR.DT.CURR NE EMPTY THEN
*
IF CO.NO NE EMPTY AND BAT.CN THEN
BATCH.STATUS = "B"
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO; BATCH.TOTAL = ZERO; ENTERED.TOTAL = ZERO
END
*
IF CO.NO NE EMPTY AND BAT.CN.BAD THEN
SAVE.CAJ = CAJ; SAVE.BAT.CN = BAT.CN
SAVE.BATCH.TOTAL = BATCH.TOTAL; SAVE.ENTERED.TOTAL = ENTERED.TOTAL
BATCH.STATUS = "E"
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = SAVE.CAJ; BAT.CN = SAVE.BAT.CN
BATCH.TOTAL = SAVE.BATCH.TOTAL; ENTERED.TOTAL = SAVE.ENTERED.TOTAL
END
*
UPD.FUNC = "WRITE"; GOSUB UPDATE.CONTROL
*
END; * of curr date not empty
*
XTR.DT.CURR = XTR.DT; XTR.DT.CURR.ID = XTR.ID
*
* Open transmission
*
UPD.FUNC = "READ"; GOSUB UPDATE.CONTROL
READ XTR.HDR FROM XTR.FILE,XTR.DT.CURR.ID:"*HDR" ELSE XTR.HDR = EMPTY
READ XTR.ERRORS FROM XTR.FILE,XTR.DT.CURR:"*000001*ERR" ELSE XTR.ERRORS = EMPTY
*
GOSUB OPEN.BATCH
*
END; * of date change
*
* IF NOT(ANY.FAILED OR ANY.SPLIT) THEN
* *
* *
* END; * of not(failed or split)
*
END; * of REC.TYPE 6
*
END; * of not HDR or TRANS
*
END; * of id XTR.CTL OR rec is CR 
*
UNTIL XTR.ID EQ "@@@" OR (XTR.REC.TYPE EQ "6" AND NOT(ANY.FAILED OR ANY.SPLIT) AND XTR.ID NE "XTR.CTL" AND XTR NE CR) OR STAT DO REPEAT
*
UNTIL XTR.ID EQ "@@@" OR STAT DO
*
*Extract Trans information
*
*Load batch and item #
XTR.BAT = XTR[TWO,3]
XTR.ITEM = XTR[5,3]
TRANS<ONE,7> = " Batch ":XTR.BAT:" item ":XTR.ITEM
*
* Look for validation error
*
LOCATE XTR.ID IN XTR.ERRORS<ONE> SETTING ERR.LOC ELSE ERR.LOC = ZERO
IF ERR.LOC THEN
VALIDATION.ERROR = XTR.ERRORS<TWO,ERR.LOC>
END ELSE
VALIDATION.ERROR = ZERO
END
*
* Load transactions type
*
TRANS<ONE,TWO> = "LB"
*
XTR.REMT = XTR[8,10]
AMT.VALID = TRUE
IF NOT(NUM(XTR.REMT)) THEN AMT.VALID = FALSE ELSE
TRANS.AMT = ICONV(XTR.REMT,"MR0")
IF XTR.REMT NE TRANS.AMT THEN AMT.VALID = FALSE
END
IF NOT(AMT.VALID) THEN
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = "(":XTR.REMT:") Amount is bad"
XTR.REMT = ZERO
TRANS.BAD = TRUE
END
XTR.REMT = XTR.REMT
*
IF AMT.VALID THEN
TRANS<ONE,3> = TRANS.AMT
END ELSE
TRANS<ONE,3> = XTR.REMT
END
*
* Load description (blank because LB is predefined and looked up)
*
TRANS<ONE,4> = EMPTY
*
* Load the cheque number
*
TRANS.CHEQUE = XTR[37,6]
IF NOT(NUM(TRANS.CHEQUE)) THEN TRANS.CHEQUE = EMPTY
IF TRANS.CHEQUE THEN
TRANS<ONE,4,ONE> = TRANS.CHEQUE
END
*
* Check max batch size
*
IF CO.NO NE EMPTY AND BAT.CN GE 100 THEN
BATCH.STATUS = "B"
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO; BATCH.TOTAL = ZERO; ENTERED.TOTAL = ZERO
END
*
IF CO.NO NE EMPTY AND BAT.CN.BAD GE 50 THEN
SAVE.CAJ = CAJ; SAVE.BAT.CN = BAT.CN
SAVE.BATCH.TOTAL = BATCH.TOTAL; SAVE.ENTERED.TOTAL = ENTERED.TOTAL
BATCH.STATUS = "E"
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = SAVE.CAJ; BAT.CN = SAVE.BAT.CN
BATCH.TOTAL = SAVE.BATCH.TOTAL; ENTERED.TOTAL = SAVE.ENTERED.TOTAL
END
*
* Load field 1 - ACCT
*
XTR.ACCT = XTR[18,16]
LOOP WHILE XTR.ACCT[ONE,ONE] EQ "0" AND LEN(XTR.ACCT) GT 7 DO XTR.ACCT = XTR.ACCT[TWO,9999] REPEAT
IF NUM(XTR.ACCT) THEN
XTR.TRANS.CD = XTR.ACCT[7,ONE]
XTR.ACCT = XTR.ACCT[ONE,6]
CALL MOD11.DIGIT(XTR.ACCT,CD)
IF CD NE XTR.TRANS.CD THEN
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = "Check digit is wrong!"
TRANS.BAD = TRUE
END
XTR.ACCT = XTR.ACCT:XTR.TRANS.CD
END ELSE
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = "Account not numeric"
TRANS.BAD = TRUE
END
*
TRANS<ONE,ONE> = XTR.ACCT
*
* Company No
*
CO.NO = XTR.ACCT[ONE,ONE]
*
*Close batches if Company changed
IF CO.NO NE CO.NO.LAST THEN
*
GOSUB CHANGE.COMPANY
*
END
*
* Read account
*
IF NOT(TRANS.BAD) THEN
TMP = XTR.ACCT[ONE,6]
* TMP = "0":TMP[TWO,9999]
MATREAD ACT FROM ACT.FILE,TMP THEN
IF ACT$STAT EQ "C" THEN TRANS<ONE,6> = "** Collection Account **" ELSE
IF ACT$BALANCE GE MIN.DELINQ.AMT AND ACT$CREDIT.STATUS GE MIN.DELINQ.STAT THEN TRANS<ONE,6> = STR("*",(ACT$CREDIT.STATUS - MIN.DELINQ.STAT) * 3):" Delinquent Account ":STR("*",(ACT$CREDIT.STATUS - MIN.DELINQ.STAT) * 3)
END
END ELSE
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = "Account not on file"
TRANS.BAD = TRUE
END
END
IF TRANS.BAD THEN TRANS<ONE,5> = XTR.ACCT
*
* Check for validation errors
*
IF VALIDATION.ERROR THEN
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = TRANS<ONE,7>:"validation error ":VALIDATION.ERROR
TRANS.BAD = TRUE
END
*
*
*Write into batch
*
IF NOT(TRANS.BAD) THEN
*
*Increment batch detail count
BAT.CN = BAT.CN + ONE
ITEM.COUNT = ITEM.COUNT + ONE
*
*Write into batch
CAJ<-ONE> = TRANS
*
*Accumulate batch totals
BATCH.TOTAL = BATCH.TOTAL + XTR.REMT
ENTERED.TOTAL = ENTERED.TOTAL + XTR.REMT
*
END ELSE
*
*Increment batch detail count
BAT.CN.BAD = BAT.CN.BAD + ONE
*
*Write into batch
CAJ.BAD<-ONE> = TRANS
*
*Accumulate batch totals
BATCH.TOTAL.BAD = BATCH.TOTAL.BAD + XTR.REMT
ENTERED.TOTAL.BAD = ENTERED.TOTAL.BAD + XTR.REMT
*
END
*
REPEAT
*
! Next record
*
CO.NO = "@@@"
*
GOSUB CHANGE.COMPANY
*
END; * of STAT
*
!!
*
! End of program
*
FINISH: *
*
IF XTR.DT.CURR NE EMPTY THEN
UPD.FUNC = "WRITE"; GOSUB UPDATE.CONTROL
END
*
IF STAT AND NOT(AUTO.RUN) THEN PRINT BELL:; INPUT RSP:
*
! Unlock control info
*
$INCLUDE IBP.CASH CASH.INCL.RELS.APPL
*
STOP
*
! Subroutines
*
OPEN.BATCH: *
*
BATCH.TOTAL = ZERO; BATCH.TOTAL.BAD = ZERO
ENTERED.TOTAL = ZERO; ENTERED.TOTAL.BAD = ZERO
ADJUST.TOTAL = ZERO; ADJUST.TOTAL.BAD = ZERO
ITEM.COUNT = ZERO
*
RETURN
*
CLOSE.BATCH: *
*
ADJUST.TOTAL = ZERO
ENTRY.DATE = DATE()
ENTRY.TIME = OCONV(TIME(),"MT")
ITEM.COUNT = BAT.CN
BUS.DATE = CONTROL.DT
EFF.DATE = XTR.TRANS$DEP.DT
IF NOT(EFF.DATE) THEN
EFF.DATE = DATE()
END ELSE
*YYMMDD
EFF.DATE = EFF.DATE[3,TWO]:"/":EFF.DATE[5,TWO]:"/":EFF.DATE[ONE,TWO]
EFF.DATE = ICONV(EFF.DATE,"D2/")
END
POST.DATE = EMPTY
POST.TIME = EMPTY
*
$INCLUDE IBP.CASH CASH.INCL.NEXT.BATCH
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
IF BATCH.STATUS EQ "B" THEN
XTR.POST.REG<-ONE> = BATCH.NUM
BATCH.LST = XTR.ID.PREF:".":XTR.ID.FUNC:".REG"
END ELSE
XTR.POST.ERR<-ONE> = BATCH.NUM
BATCH.LST = XTR.ID.PREF:".":XTR.ID.FUNC:".ERR"
END
*
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
RETURN
*
! Company info
*
OPEN.COMPANY: *
*
OPEN CO.PRE:"ACT" TO ACT.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"ACT":; INPUT RSP:; STAT = 999; RETURN
OPEN CO.PRE:"CAJ" TO CAJ.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"CAJ":; INPUT RSP:; STAT = 999; RETURN
OPEN CO.PRE:"PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"PAR":; INPUT RSP:; STAT = 999; RETURN
OPEN CO.PRE:"CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"CNT":; INPUT RSP:; STAT = 999; RETURN
OPEN "CNT" TO BASE.CNT.FILE ELSE PRINT CLB:"Can't open ":"CNT":; INPUT RSP:; STAT = 999; RETURN
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
XTR.ID.FUNC = "POST"
XTR.ID.PREF = "XTR"
XTR.ID.SUFF = "REG"
XTR.POST.REG = EMPTY; XTR.POST.ERR = EMPTY; XTR.POST.OTH = EMPTY
*
IF NOT(CO.FIRST) THEN
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.LISTS
*
END
*
CO.FIRST = FALSE
*
PRINT @(ZERO,ZERO):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15":
PRINT @(ZERO,ONE):RVB:OCONV(TIME(),"MT") "L#10":(SPACE(30 - LEN(TITLE2) / TWO + .5):TITLE2) "L#60":("Acct ":ACCT) "R#10":RVE:
PRINT @(ZERO,6):SPACE(40 - LEN(TITLE1) / TWO + .5):RVB:TITLE1:
PRINT @(ZERO,8):"Company: ":FIELD(CO.PRE,".",ONE):" ":CO.NAME:
PRINT @(ZERO,10):"Item being processed: ":RVE:
*
RETURN
*
! Company change
*
CHANGE.COMPANY: *
*
*Close Company batches
*
IF CO.NO.LAST NE EMPTY AND BAT.CN THEN 
BATCH.STATUS = "B"
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO
BATCH.TOTAL = ZERO; ENTERED.TOTAL = EMPTY
END
*
IF CO.NO.LAST NE EMPTY AND BAT.CN.BAD THEN 
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
BATCH.STATUS = "E"
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = EMPTY; BAT.CN = ZERO
BATCH.TOTAL = ZERO; ENTERED.TOTAL = EMPTY
END
*
! Update posting list
*
IF CO.NO.LAST NE EMPTY THEN
*
$INCLUDE IBP.CASH CASH.INCL.UPD.LISTS
*
END
*
! Update control info
*
IF CO.NO NE "@@@" AND CO.NO NE CO.NO.LAST THEN
CO.NO.LAST = CO.NO
* LOCATE CO.NO IN CNT.XTRIND$CO.NO.IND<ONE> SETTING LOC ELSE LOC = ONE; STAT = 999
LOCATE CO.NO IN CNT.XTRIND$CO.NO.IND<ONE> SETTING LOC ELSE
LOC = ONE; TRANS.BAD = TRUE
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = TRANS<ONE,7>:"company bad: ":CO.NO
END
CO.PRE = CNT.XTRIND$CO.NO.PRE<ONE,LOC>
IF LEN(CO.PRE) THEN CO.PRE = CO.PRE:"."
GOSUB OPEN.COMPANY
END; * of company change
*
RETURN
*
! Update control info
*
UPDATE.CONTROL: *
*
TMP = XTR.DT.CURR:"*000001"
LOCATE TMP IN CNT.XTRIND$INDEX<ONE> SETTING UPD.ST.LOC ELSE UPD.ST.LOC = ONE
*
LOOP
IF UPD.ST.LOC GE ONE THEN TMP.DT = FIELD(CNT.XTRIND$INDEX<ONE,UPD.ST.LOC>,"*",ONE)
WHILE TMP.DT EQ XTR.DT.CURR AND UPD.ST.LOC GE ONE DO UPD.ST.LOC = UPD.ST.LOC - ONE REPEAT
UPD.ST.LOC = UPD.ST.LOC + ONE
*
IF UPD.FUNC = "READ" THEN
*
UPD.CONT = TRUE; UPD.LOC = UPD.ST.LOC
ANY.FAILED = FALSE; ANY.SPLIT = FALSE
*
LOOP
TMP.DT = FIELD(CNT.XTRIND$INDEX<ONE,UPD.LOC>,"*",ONE)
IF TMP.DT NE XTR.DT.CURR OR TMP.DT EQ EMPTY THEN UPD.CONT = FALSE
WHILE UPD.CONT AND NOT(ANY.FAILED OR ANY.SPLIT) DO
IF CNT.XTRIND$FAILED<ONE,UPD.LOC> THEN ANY.FAILED = TRUE
IF CNT.XTRIND$SPLIT<ONE,UPD.LOC> THEN ANY.SPLIT = TRUE
UPD.LOC = UPD.LOC + ONE
REPEAT
*
END ELSE
*
IF NOT(ANY.FAILED OR ANY.SPLIT) THEN
*
UPD.CONT = TRUE; UPD.LOC = UPD.ST.LOC
*
LOOP
TMP.DT = FIELD(CNT.XTRIND$INDEX<ONE,UPD.LOC>,"*",ONE)
IF TMP.DT NE XTR.DT.CURR OR TMP.DT EQ EMPTY THEN UPD.CONT = FALSE
WHILE UPD.CONT DO
*
XTR.DT.CURR.ID = CNT.XTRIND$INDEX<ONE,UPD.LOC>
MATREAD XTR.TRANS FROM XTR.FILE,XTR.DT.CURR.ID:"*TRANS" ELSE MAT XTR.TRANS = EMPTY
*
XTR.TRANS$SPLIT = DATE()
IF ALL.FLAG THEN MATWRITE XTR.TRANS ON XTR.FILE,XTR.DT.CURR.ID:"*TRANS"
CNT.XTRIND$SPLIT<ONE,UPD.LOC> = XTR.TRANS$SPLIT
UPD.LOC = UPD.LOC + ONE
REPEAT
*
IF ALL.FLAG THEN MATWRITE CNT.XTRIND ON BASE.CNT.FILE,"XTR.CTL"
*
END; * of not failed or split
*
END; * of upd.func
*
RETURN
*
*
END
~CASH.LIST.POST~
*PROGRAM: TRANS.LIST.POST 
* VERSION: 921009 1.2   REVISED-FOR-PPV.BILLING
* PRIOR: 920531  1.1  REVISED-FOR-PAY-PER-VIEW
* PRIOR: 910611 1.0  NEW
EQU VS TO " (R:1.2)"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1991              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
* DESCRIPTION:     THIS PROGRAM PROCESSES THE BATCHES
*                  FROM THE XXX.POST.REG CONTROL ITEMS
*  
* DATE WRITTEN:    29 JUN 91
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  * TITLE = "Process Transactions" * : *
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
*INCLUDE IBP AAX.DIM
*INCLUDE IBP AAX.EQUATES
*NCLUDE IBP ACG.DIM
* $INCLUDE IBP ACG.EQUATES
*NCLUDE IBP SAVE.ACG.DIM
*INCLUDE IBP SAVE.ACG.EQUATES
*NCLUDE IBP ACT.DIM
*INCLUDE IBP ACT.EQUATES
*NCLUDE IBP ADD.DIM
*INCLUDE IBP ADD.EQUATES
*NCLUDE IBP ATR.DIM
*INCLUDE IBP ATR.EQUATES
*NCLUDE IBP EFT.DIM
*INCLUDE IBP EFT.EQUATES
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
*
MAT CNT.CSH = EMPTY
*
! OPEN files * : *
*
SYS.PROG = "CASH.LIST.POST"; VERSION = "2.0"
STAT = FALSE; PHAN.RUN = TRUE
*
CALL CASH.SUBR.OPEN.LIST.POST(CAJ.FILE)
IF STAT THEN STOP
*
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
STAT = FALSE; INPUTS = EMPTY
*
*
! Special parameters for fixing posting run aborts * : *
*
XTR.POST = EMPTY; XTR.POST.ERR = EMPTY; XTR.POST.OTH = EMPTY
XTR.ID.PREF = EMPTY; XTR.ID.FUNC = EMPTY; XTR.ID.SUFF = EMPTY
ENTRY.MODE = ZERO
*
CALL CASH.SUBR.LOAD.CNTRL(CNT.CSH.ID,MAT CNT.CSH)
IF STAT THEN STOP
IF STAT THEN STOP
*
! Put up screen header * : *
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
$INCLUDE IBP SYS.INCL.SCR.CO
*
EXEC.REPORT = SCR.CO
TITLEA = "Batched Transactions Processing"
TMP = (SPACE(40-LEN(TITLEA)/2):TITLEA) "L#80"
EXEC.REPORT<-ONE> = TMP
*
! Load auto * : *
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
! Load Responses or auto.run info * : *
*
IF NOT(AUTO.RUN) THEN
*
CSH.TYPE = ZERO; CSH.TYPE.CURR = ZERO
INPUT CSH.TYPE.SEL:
FROM.LIST = INDEX(CSH.TYPE.SEL,"L",ONE)
PHAN.RUN = INDEX(CSH.TYPE.SEL,"P",ONE)
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ONE):CLS:RVB:TMP:RVE:
* 0 Regular Posting Run
* L From a get-list
* P Phantom Mode
*
BATCH.CLASS = EMPTY; BATCH.CLASS.CURR = EMPTY; BATCH.CLASS.TMP = EMPTY
INPUT BATCH.CLASS.SEL:
* 0 Regular Adjustments (ADJ)
* 1 Regular Payments    (PMT)
* 2 Regular Deposits    (DEP)
* 3 Special Billing     (BIL)
* 6 All Batch Types
*
BATCH.SOURCE = EMPTY; BATCH.SOURCE.CURR = EMPTY; BATCH.SOURCE.TMP = EMPTY
INPUT BATCH.SOURCE.SEL:
* 0 Cash.or.Adj Entry    (REG)
* 3 Counter Cash         (CTR)
* 4 Lockbox Transactions (XTR)
* 5 Pay-Per-View Charges (BIL)
* 6 All batch sources
*
INPUT DT.OPEN.SEL:
EXEC.VERB.SEL = EMPTY
IF DT.OPEN.SEL[ONE,3] EQ "SEL" THEN EXEC.VERB.SEL = DT.OPEN.SEL[4,9999]
INPUT PORT.SEL:
INPUT USER.VALID.SEL:
INPUT LPT.DETAIL.SEL:
INPUT POST.FL:
* 
! Perform Screen Selection Criteria * : *
*
CALL CASH.SUBR.LIST.SELECT(TITLE,MAT CNT.CSH,CNT.CSH.ID,CHSU,CSHU.ID,CSHUD,CSHUD.ID,CONTROL.DT,CSH.TYPE.SEL,EXEC.VERB.SEL,BATCH.CLASS.SEL,BATCH.SOURCE.SEL,DT.OPEN.SEL,PORT.SEL,USER.VALID.SEL,LPT.DETAIL.SEL,POST.FL,INPUTS,AUTO.RUN,PHAN.RUN)
IF STAT THEN STOP
*
! Update Inputs for auto.run * : *
*
INPUTS          = CSH.TYPE.SEL
INPUTS<ONE,TWO> = BATCH.CLASS.SEL
INPUTS<ONE,3>   = BATCH.SOURCE.SEL
INPUTS<ONE,4>   = DT.OPEN.SEL
INPUTS<ONE,5>   = PORT.SEL
INPUTS<ONE,6>   = USER.VALID.SEL
INPUTS<ONE,7>   = LPT.DETAIL.SEL
INPUTS<ONE,8>   = POST.FL
INPUTS<ONE,9>   = EXEC.VERB.SEL
*
END ELSE
*
! This is an auto run * : *
*
CSH.TYPE.SEL     = CURRENT.RUN<ONE,TWO>
BATCH.CLASS.SEL   = CURRENT.RUN<ONE,3>
BATCH.SOURCE.SEL = CURRENT.RUN<ONE,4>
DT.OPEN.SEL      = CURRENT.RUN<ONE,5>
PORT.SEL         = CURRENT.RUN<ONE,6>
USER.VALID.SEL   = CURRENT.RUN<ONE,7>
LPT.DETAIL.SEL   = CURRENT.RUN<ONE,8>
POST.FL          = CURRENT.RUN<ONE,9>
EXEC.VERB.SEL    = CURRENT.RUN<ONE,10>
*
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ONE):RVB:TMP:RVE:
*
END
*
*
! Update auto * : *
*
*
EXEC.VERB = "RUN BP CASH.LIST.POST"
EXEC.IN = INPUTS
EXEC.DESC = "Post Batches from Lists  ":CSH.TYPE.SEL:",":BATCH.SOURCE.SEL:",":BATCH.CLASS.SEL
*
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
$INCLUDE IBP SYS.INCL.UPD.AUTO
END
*
! Initialize program * : *
*
BATCH.SOURCE.CURR = EMPTY; BATCH.TYPE.CURR = BATCH.CLASS.SEL[ONE,ONE]
DT.OPEN.CURR = EMPTY; PORT.CURR = EMPTY; USER.VALID.CURR = EMPTY
LIST.TO.POST = EMPTY; FROM.LIST = FALSE; END.OF.LIST = FALSE
*
FROM.LIST = INDEX(CSH.TYPE.SEL,"L",ONE)
*
PHAN.RUN = INDEX(CSH.TYPE.SEL,"P",ONE)
*
IF LEN(EXEC.VERB.SEL) THEN FROM.LIST = TRUE
*
CALL CASH.SUBR.CLASS.PARSE(BATCH.CLASS.SEL)
IF STAT THEN STOP
IF BATCH.CLASS.SEL EQ "6" THEN BATCH.CLASS.SEL   = "0123"
*
CALL CASH.SUBR.SOURCE.PARSE(BATCH.SOURCE.SEL)
IF STAT THEN STOP
IF BATCH.SOURCE.SEL EQ "6" THEN BATCH.SOURCE.SEL = "0345"
*
! Call program initialization and lock control info * : *
*
BATCH.CLASS.CURR = BATCH.CLASS.SEL[ONE,ONE]
BATCH.SOURCE.CURR = BATCH.SOURCE.SEL[ONE,ONE]
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
CALL CASH.SUBR.ENTRY.INIT(ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
*
! Lock out transmissions and other updates to transactions * : *
*
$INCLUDE IBP.CASH CASH.INCL.LCK.XTR
*
IF STAT THEN STOP
*
!!
*
! Start of program * : *
*
START: *
*
BUS.DATE = EMPTY
EFF.DATE = EMPTY
POST.DATE = EMPTY
POST.TIME = EMPTY
OPERATOR = EMPTY
DEFAULT.TYPE = EMPTY
BATCH.DEL.STATUS = EMPTY
BATCH.TYPE = EMPTY
BATCH.LPT.DT = EMPTY
BATCH.LPT.TM = EMPTY
BATCH.INP.SOURCE = EMPTY
BATCH.LST = EMPTY
*
!
*
LPT.DETAIL.FL = INDEX(LPT.DETAIL.SEL,"D",ONE)
LPT.SUMMARY.FL = INDEX(LPT.DETAIL.SEL,"S",ONE)
LPT.PMT.TYP.FL = INDEX(LPT.DETAIL.SEL,"Y",ONE)
LPT.FL = NOT(INDEX(LPT.DETAIL.SEL,"T",ONE))
IF NOT(LPT.FL) THEN LPT.FL = INDEX(LPT.DETAIL.SEL,"P",ONE)
*
LN.TOP = 6; LN.BOT = 20; LN.HDR.TOP = TWO
LPT.STAT = FALSE; LPT.CN = ZERO
LPT.PG = ONE; LPT.LN = 99; LPT.LN.MAX = 55
IF NOT(LPT.FL) THEN LPT.LN.MAX = 19
LPT.HEADER = "Status Description" "L#24":" S ":"Batch" "L#9":" ":"Oper." "L#5"
LPT.HEADER = LPT.HEADER:" ":"Bus.Date" "L#10":"Per." "L#5":" "
LPT.HEADER = LPT.HEADER:"Post.Date" "L#10"
LPT.HEADER = LPT.HEADER:"Print.Dt" "L#10"
*
IF NOT(LPT.FL) THEN LPT.HEADER = LPT.HEADER:CR:LF:SPACE(10)
LPT.HEADER = LPT.HEADER:"Total.Amt" "R#9":" ":"Entry.Amt" "R#9":" ":"Adj.Amt" "R#9"
*
IF LPT.PMT.TYP.FL THEN
LPT.HEADER = LPT.HEADER:CR:LF
IF LPT.FL THEN LPT.HEADER = LPT.HEADER:SPACE(68) ELSE LPT.HEADER = LPT.HEADER:SPACE(10)
LPT.HEADER = LPT.HEADER:"Total.Chq" "R#9":" ":"Total.Crd" "R#9":" ":"Total.Dbt" "R#9":" ":"Total.Csh" "R#9"
END
*
LPT.TEXT = EMPTY
*
LPT.BATCH.TOTAL = EMPTY; LPT.ENTERED.TOTAL = EMPTY; LPT.ADJUST.TOTAL = EMPTY
LPT.TOTAL.CHQ = EMPTY; LPT.TOTAL.CRD = EMPTY; LPT.TOTAL.CSH = EMPTY; LPT.TOTAL.CDC = EMPTY
*
CNTR.PREV = EMPTY
CNTR.CURR = EMPTY
CNTR.FIRST = TRUE
CNTR.TOTAL = EMPTY
* 1 *    * 2 *    * 3 *    * 4 *    * 5 *    * 6 *    * 7 *            
* CO     TRAN     TRAN   LIST.TYPE  ENTRY    ENTRY    ENTRY
* TOTS  SOURCE   CLASS  REG/ERR/OTH  DATE     PORT   OPERATOR
*
* ENTERED  ADJUSTMENTS  CONTROL
*
* CASH     CHEQUES      CREDIT CARDS    DEBIT CARDS
*
!
*
BATCH.CLASS.TMP = BATCH.CLASS.SEL
BATCH.SOURCE.TMP = BATCH.SOURCE.SEL
CSH.TYPE.CURR = CSH.TYPE.SEL[ONE,ONE]
*
! Main loop * : *
*
MAIN.LOOP: *
*
! Loop for all types processing * : *
*
LOOP WHILE (NOT(FROM.LIST) AND LEN(BATCH.SOURCE.TMP)) OR (FROM.LIST AND NOT(END.OF.LIST)) DO
*
! Process next source * : *
*
BATCH.SOURCE.CURR = BATCH.SOURCE.TMP[ONE,ONE]
BATCH.SOURCE.TMP = BATCH.SOURCE.TMP[TWO,9999]
BATCH.CLASS.TMP = BATCH.CLASS.SEL
*
LOOP WHILE (NOT(FROM.LIST) AND LEN(BATCH.CLASS.TMP)) OR (FROM.LIST AND NOT(END.OF.LIST)) DO
*
BATCH.CLASS.CURR = BATCH.CLASS.TMP[ONE,ONE]
BATCH.CLASS.TMP = BATCH.CLASS.TMP[TWO,9999]
*
! Examine type of run * : *
*
CALL CASH.SUBR.BATCH.ANAL(CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
IF STAT THEN
*
TMP = "Error in ":ACCT:" on type ":BATCH.CLASS.CURR:BATCH.SOURCE.CURR:" ":XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF:". Error #: ":STAT
EXEC.REPORT<-ONE> = TMP
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 10 UNTIL SYSTEM(11)
* FOR TMP = ONE TO 10; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
EXEC.REPORT<-ONE> = "CASH IN ":ACCT:" ERR ":STAT+0:" ON ":XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
*
STAT = FALSE
*
END; * of STAT
*
IF POST.FL THEN TITLE = "Post " ELSE TITLE = "Report on "
IF NOT(LPT.DETAIL.FL) THEN TITLE = "Summary ":TITLE
TITLE = TITLE:BATCH.CLASS.CURR.DESC:" Batches "
IF FROM.LIST THEN TITLE = TITLE:"from a List "
TITLEA = TITLE:"    ":VS
CLS.COL = ZERO; CLS.ROW = 7; GOSUB CLS.ROUTINE
PRINT @(ZERO,7):RVB:(SPACE(40-LEN(TITLEA)/2):TITLEA) "L#80":RVE:
*
! Read List info * : *
*
IF NOT(PHAN.RUN) THEN
CLS.COL = ZERO; CLS.ROW = 9; GOSUB CLS.ROUTINE
END
IF NOT(FROM.LIST) THEN
PRINT "Load List . . .   ":
$INCLUDE IBP.CASH CASH.INCL.LOAD.LISTS
END
*
! Loop for class of list (regular or errors) * : *
*
! 2 Cycles for balanced and error batches * : *
*
FOR XTR.TYPE.CN = ONE TO CLASS.CN.MAX
*
! Read XTR Post record * : *
*
IF NOT(FROM.LIST) THEN
*
IF XTR.TYPE.CN EQ ONE THEN
XTR.ID.SUFF = "REG"
LIST.TO.POST.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.TO.POST = XTR.POST.REG
RUN.CLASS = "REGULAR"
END ELSE IF XTR.TYPE.CN EQ TWO THEN
XTR.ID.SUFF = "ERR"
LIST.TO.POST.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.TO.POST = XTR.POST.ERR
RUN.CLASS = "ERRORS"
END ELSE
XTR.ID.SUFF = "OTH"
LIST.TO.POST.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.TO.POST = XTR.POST.OTH
RUN.CLASS = "OTHER"
END
*
! Process list * : *
*
IF NOT(FROM.LIST) AND LIST.TO.POST EQ EMPTY THEN
*
TMP = "There are no ":BATCH.CLASS.CURR.DESC:", type ":RUN.CLASS:" to post."
EXEC.REPORT<-ONE> = TMP
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 3 UNTIL SYSTEM(11)
* FOR TMP = ONE TO 3; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
EXEC.REPORT<-ONE> = "CASH IN ":ACCT:" NO ":RUN.CLASS:" POSTED"
*
STAT = 200
*
END
*
END ELSE
*
! From a list * : *
*
IF EXEC.VERB.SEL NE EMPTY THEN
PRINT EXEC.VERB
* ULT ONLY
EXECUTE EXEC.VERB.SEL, //SELECT. > CAJ.ID.LIST
* EXECUTE EXEC.VERB.SEL; * REV ONLY
END
*
END; * of not(FROM.LIST)
*
! Display batches * : *
*
IF LPT.DETAIL.FL THEN
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
END ELSE IF NOT(PHAN.RUN) THEN
CLS.COL = ZERO; CLS.ROW = 13; GOSUB CLS.ROUTINE
END
*
! Loop thru batches * : *
*
XTR.CN = ZERO
IF NOT(FROM.LIST) THEN
XTR.CN.MAX = DCOUNT(LIST.TO.POST,AM)
END ELSE
XTR.CN.MAX = 99999
END
*
LOOP
*
! Read next batch * : *
*
XTR.CN = XTR.CN + ONE; CONT = TRUE
IF NOT(FROM.LIST) THEN
CAJ.ID = LIST.TO.POST<XTR.CN>
BATCH.NUM = ("00000":CAJ.ID) "R#5"
IF (CAJ.ID EQ EMPTY AND (NOT(LEN(LIST.TO.POST)) OR XTR.CN GT XTR.CN.MAX)) THEN CONT = FALSE
END ELSE IF END.OF.LIST THEN
CONT = FALSE; CAJ.ID = EMPTY; BATCH.NUM = EMPTY
END ELSE
* ULT ONLY
READNEXT CAJ.ID FROM CAJ.ID.LIST ELSE
* READNEXT CAJ.ID ELSE; * REV ONLY
CAJ.ID = EMPTY; CONT = FALSE; END.OF.LIST = TRUE
END
BATCH.NUM = ("00000":CAJ.ID) "R#5"
END
*
WHILE CONT AND NOT(STAT) DO
*
IF NOT(PHAN.RUN) THEN PRINT @(ZERO):BATCH.NUM:"  ":
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
READ CAJ FROM CAJ.FILE,BATCH.NUM THEN
*
! Extract Header * : *
*
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
! Validate Batch * : *
*
VALID = TRUE
*
CALL CASH.SUBR.VALIDATE.BATCH(VALID,BATCH.HEADER,DT.OPEN.SEL,DT.OPEN.LOC,PORT.SEL,PORT.LOC,USER.VALID.SEL,USER.VALID.LOC,BATCH.CLASS.CURR,BATCH.SOURCE.CURR)
*
IF VALID THEN
*
*
! Display Background * : *
*
IF LPT.DETAIL.FL THEN
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.HDR.FG
END
*
! Set Control Current
*
CNTR.CURR<ONE> = "*"
CNTR.CURR<TWO> = BATCH.SOURCE
CNTR.CURR<3>   = BATCH.CLASS
CNTR.CURR<4>   = XTR.ID.SUFF
CNTR.CURR<5>   = ENTRY.DATE
CNTR.CURR<6>   = BATCH.TILL
CNTR.CURR<7>   = OPERATOR
IF CNTR.FIRST THEN
CNTR.FIRST = FALSE; CNTR.PREV = CNTR.CURR
END
*
! Call Impulse Pay Per View Billing * : *
*
IF LPT.DETAIL.FL THEN
IF POST.FL THEN
IF BATCH.STATUS EQ "C" THEN
*
SINGLE = 0; ACT.ID = ""; PVM.ID = ""
CALL PPV.BILLING(LCK.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,STAT,LCK.TYPE,CAJ,BATCH.HEADER,CONTROL.DT,A.PERIOD,BATCH.NUM,BATCH.TYPE,SINGLE,ACT.ID,PVM.ID)
*
BATCH.STATUS = FIELD(BATCH.HEADER,"*",2)
BATCH.TOTAL = FIELD(BATCH.HEADER,"*",9)
ENTERED.TOTAL = FIELD(BATCH.HEADER,"*",10)
*
IF NOT(STAT) THEN BATCH.STATUS = "D"
*
END
END; * Of post.fl
END; * Of not S
*
! Call Printing routine * : *
*
IF NOT(LPT.DETAIL.FL) THEN
*
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.DESC
*
LPT.CN = LPT.CN + ONE
*
! Detect Control Breaks * : *
*
CNTR.MIN = ZERO
LOOP
CNTR.MIN = CNTR.MIN + ONE
WHILE CNTR.CURR<CNTR.MIN> EQ CNTR.PREV<CNTR.MIN> AND CNTR.MIN LT 7 DO REPEAT
*
! Print Totals
*
IF CNTR.MIN LT 7 THEN
*
IF LPT.FL THEN CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
PRINT
PRINT "Totals" "R#9":" ":
*
FOR CNTR.CN = 7 TO CNTR.MIN STEP -ONE
*
* PRINT CLB:"TOT ":CNTR.CN
IF CNTR.CN GT ONE THEN
CNTR.TOTAL<CNTR.CN - ONE> = CNTR.TOTAL<CNTR.CN - ONE> + CNTR.TOTAL<CNTR.CN>
END
*
PRINT (CNTR.CN:" - ":CNTR.TOTAL<CNTR.CN>) "R#9":" ":
*
* Clear  Control Totals * : *
*
CNTR.TOTAL<CNTR.CN> = ZERO
*
NEXT CNTR.CN
*
PRINT
IF LPT.FL THEN CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
END
*
! Build Report Line * : *
*
*43
LPT.TEXT = BATCH.STATUS.DESC "L#24":" ":SOURCE "L#1":" ":BATCH.NUM "L#9":" ":OPERATOR "L#5"
*17
LPT.TEXT = LPT.TEXT:" ":OCONV(BUS.DATE,"D2") "L#9":" ":ACCTG.PERIOD "L#5":" "
*10
LPT.TEXT = LPT.TEXT:OCONV(POST.DATE,"D2") "L#10"
*9
LPT.TEXT = LPT.TEXT:OCONV(BATCH.LPT.DT,"D2") "L#9"
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF:"  Totals:" "L#10"
LPT.LN = LPT.LN + ONE
END
*
*30
LPT.TEXT = LPT.TEXT:OCONV(BATCH.TOTAL,"MR2") "R#9":" ":OCONV(ENTERED.TOTAL,"MR2") "R#9":" ":OCONV(ADJUST.TOTAL,"MR2") "R#9"
*
END; * of summary report
*
! Batch Detail Printing Routine * : *
*
IF (LPT.DETAIL.FL OR LPT.PMT.TYP.FL OR BATCH.LPT.DT EQ EMPTY OR ALL.FLAG) AND NOT(STAT) THEN
*
BATCH.TOTAL.CHQ = ZERO; BATCH.TOTAL.CRD = ZERO; BATCH.TOTAL.CSH = ZERO; BATCH.TOTAL.CDC = ZERO
*
CALL CASH.SUBR.PRINT(CAJ,CO.NAME,ACCTG.PERIOD,BATCH.HEADER,BATCH.STATUS.DESC,BATCH.NUM,BATCH.TOTAL.CHQ,BATCH.TOTAL.CRD,BATCH.TOTAL.CDC,BATCH.TOTAL.CSH,CSH.TYPE,CSH.TYPE.CURR,TITLE,TRANS.TYPES,BATCH.CLASS.CURR,LPT.DETAIL.FL,LPT.PMT.TYP.FL,LPT.FL,LPT.STAT,MIN.DELINQ.AMT,MIN.MIN.DELINQ.STAT)
*
! Printer output * : *
*
IF LPT.PMT.TYP.FL THEN
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF:"Currency:" "L#10"
LPT.LN = LPT.LN + ONE
END ELSE
LPT.TEXT = LPT.TEXT:CR:LF:SPACE(68)
LPT.LN = LPT.LN + ONE
END
*
*30
LPT.TEXT = LPT.TEXT:OCONV(BATCH.TOTAL.CHQ,"MR2") "R#9":" ":OCONV(BATCH.TOTAL.CRD,"MR2") "R#9":" ":OCONV(BATCH.TOTAL.CDC,"MR2") "R#9":" ":OCONV(BATCH.TOTAL.CSH,"MR2") "R#9"
*
END
*
! Update print date and error batch status * : *
*
IF LPT.DETAIL.FL THEN
IF BATCH.STATUS EQ "D" THEN BATCH.STATUS = "P"
IF BATCH.STATUS EQ "E" THEN BATCH.STATUS = "R"
BATCH.LPT.DT = DATE()
BATCH.LPT.TM = TIME()
END
*
END; * Of E B U and not STAT
*
!  Print Report Line * : *
*
IF NOT(LPT.DETAIL.FL) THEN
*
!  Detect Page Break * : *
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF
LPT.LN = LPT.LN + ONE
END
LPT.LN = LPT.LN + ONE
*
IF LPT.LN GT LPT.LN.MAX THEN GOSUB LPT.PAGE
*
IF LPT.FL THEN CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
PRINT LPT.TEXT
*
IF LPT.FL THEN CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
! Accumulate Totals * : *
*
LPT.BATCH.TOTAL   = LPT.BATCH.TOTAL   + BATCH.TOTAL
LPT.ENTERED.TOTAL = LPT.ENTERED.TOTAL + ENTERED.TOTAL
LPT.ADJUST.TOTAL  = LPT.ADJUST.TOTAL  + ADJUST.TOTAL
*
LPT.TOTAL.CHQ = LPT.TOTAL.CHQ + BATCH.TOTAL.CHQ
LPT.TOTAL.CRD = LPT.TOTAL.CRD + BATCH.TOTAL.CRD
LPT.TOTAL.CSH = LPT.TOTAL.CSH + BATCH.TOTAL.CSH
LPT.TOTAL.CDC = LPT.TOTAL.CDC + BATCH.TOTAL.CDC
*
CNTR.TOTAL<7> = CNTR.TOTAL<7> + LPT.BATCH.TOTAL
END; * of summary report * : *
*
! Call Posting routine * : *
*
IF (BATCH.STATUS EQ "B" OR ALL.FLAG) AND LPT.DETAIL.FL AND NOT(STAT) THEN
*
* DON'T POST PPV. POST WON'T HANDLE ACG BILLING, TAXES, ETC.
IF NOT(BATCH.SOURCE.SEL = 5) THEN
*
CALL CASH.SUBR.POST(CAJ,CSH.TYPE,CSH.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,RUN.TRANS.SUB.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,MIN.DELINQ.STAT,MIN.DELINQ.AMT,BUS.DATE,BATCH.CLASS.SEL,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,BATCH.DEL.STATUS,ENTRY.MODE,TRANS.COUNT,BATCH.INP.SOURCE)
*
END
*
IF NOT(STAT) THEN
BATCH.STATUS = "P"
DEL LIST.TO.POST<XTR.CN>
XTR.CN = XTR.CN - ONE
XTR.CN.MAX = XTR.CN.MAX - ONE
END ELSE
BATCH.STATUS = "R"
* XTR.CN = XTR.CN + ONE
STAT = FALSE
END
*
POST.DATE = CONTROL.DT
POST.TIME = OCONV(TIME(),"MT")
*
END ELSE
* XTR.CN = XTR.CN + ONE
END; * of status B
*
* END ELSE
* XTR.CN = XTR.CN + ONE
* END; * of not an E or R and not STAT so post
*
! Update header * : *
*
* IF NOT(STAT) THEN
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
* END
*
END; * Of valid * : *
*
*
END ELSE
CAJ = EMPTY
IF XTR.TYPE.CN = 2 THEN
XTR.CN = XTR.CN + ONE
END ELSE
XTR.POST.ERR<-ONE> = LIST.TO.POST<XTR.CN>
DEL LIST.TO.POST<XTR.CN>
STAT = 299
BATCH.STATUS = "?"
END
END
*
! Release batch * : *
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
! Check status * : *
*
*  will clear STAT set by a bad batch or lock here
*
IF STAT THEN
*
TMP = "Error in ":ACCT:" on batch ":BATCH.NUM:" status ":BATCH.STATUS:". Error #: ":STAT
EXEC.REPORT<-ONE> = TMP
*
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 10 UNTIL SYSTEM(11)
* FOR TMP = ONE TO 10; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
EXEC.REPORT<-ONE> = "CASH IN ":ACCT:" ERR ":STAT+0:" ON ":BATCH.NUM
*
STAT = FALSE
*
END; * of STAT
*
! Next batch * : *
*
REPEAT
*
! Next XTR Posting Class Record * : *
*
IF NOT(FROM.LIST) THEN
IF XTR.TYPE.CN EQ ONE THEN
XTR.POST.REG = LIST.TO.POST
END ELSE IF XTR.TYPE.CN EQ TWO THEN
XTR.POST.ERR = LIST.TO.POST
END ELSE
XTR.POST.OTH = LIST.TO.POST
END
END
*
*
NEXT XTR.TYPE.CN
*
! Write lists out * : *
*
IF NOT(FROM.LIST) THEN
$INCLUDE IBP.CASH CASH.INCL.UPD.LISTS
END
*
! Next Class of Transaction * : *
*
REPEAT
*
! Next Source of Transaction * : *
*
REPEAT
*
! End of Report * : *
*
IF NOT(LPT.DETAIL.FL) AND LPT.CN THEN
*
* * : * Detect Page Break
*
IF LPT.LN GT LPT.LN.MAX THEN GOSUB LPT.PAGE
*
* * : *  Print report totals
*
**********
*
END
*
*
! End of program * : *
*
FINISH: *
*
$INCLUDE IBP.CASH CASH.INCL.RELS.XTR
*
*
STOP
*
!
*
$INCLUDE IBP.CASH CASH.INCL.IMPRINT
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
CHECK.BALANCE: *
*
$INCLUDE IBP.CASH CASH.INCL.CHECK.BAL
*
RETURN
*
!
*
LPT.PAGE: *
*
*
*    Detect Page Break
*
IF LPT.LN GT LPT.LN.MAX THEN
*
IF LPT.FL THEN
CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
PRINT FF:
$INCLUDE IBP SYS.INCL.LPT.CO
END ELSE
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT CLB:"Enter <cr> for next page . . . ":; INPUT TMP:
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ "END" THEN STAT = 999; RETURN
END
PRINT @(ZERO,ZERO):CLS:
$INCLUDE IBP SYS.INCL.SCR.CO
END
*
IF LPT.FL THEN
PRINT (SPACE(65 - LEN(TITLEA) / TWO):TITLEA) "L#130"
END ELSE
PRINT
PRINT (SPACE(40 - LEN(TITLEA) / TWO):TITLEA) "L#79"
END
*
PRINT
PRINT LPT.HEADER
PRINT
LPT.PG = LPT.PG + ONE; LPT.LN = 6
*
IF LPT.FL THEN
CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
END
*
END
*
RETURN
*
*
END
~CASH.LOCK.XTR~
*PROGRAM: CASH.LCK.XTR
*
*      Clear Payments Tape XTR file
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CNT.XTRIND.DIM
*
$INCLUDE IBP CNT.XTRIND.EQUATES
*
ECHO OFF
INPUT AUTO.RUN,ONE:
IF NOT(NUM(AUTO.RUN)) THEN AUTO.RUN = TRUE
ECHO ON
*
*
!
*
OPEN "FC.XTR" TO XTR.FILE ELSE PRINT "Can't open XTR"; INPUT RSP:; STOP
OPEN "FC.PAR" TO PAR.FILE ELSE PRINT "Can't open PAR"; INPUT RSP:; STOP
OPEN "FC.CNT" TO CNT.FILE ELSE PRINT "Can't open CNT"; INPUT RSP:; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS"; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
*
*
LOOP
IF AUTO.RUN THEN
LCK.STAT = -5
END ELSE
LCK.STAT = ZERO
END
CALL LOCK.ITEM(XTR.FILE,"CNT","XTR.CTL",LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
IF LCK.STAT AND AUTO.RUN THEN
EXECUTE "SLEEP 10"
END
WHILE LCK.STAT DO REPEAT
*
IF NOT(AUTO.RUN) THEN
PRINT CLB:"Lock box now locked, remember to unlock it. Enter <cr> . . . ":; INPUT TMP:
END
*
END
~CASH.OR.ADJ.ENTRY~
*PROGRAM: CASH.OR.ADJ.ENTRY 
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Counter payments
*                  4 = Pay-Per-View Charges
*                  5 = All
*
*                  See list post program
*
*  
* DATE WRITTEN:    DD MMM 83
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
*                  26-JAN-88   HH   Cr. Status not updated for a 'Late
*                                   Notice' trans. unless Cr. Status is
*                                   less than Min. Delinq. criteria.
*                  01-AUG-88   HH   TRANS VAL 5 = Old Account Number
*                  24-NOV-88   HH   TRANS VAL 6 = 'Collection Account'
*                                   If active & updated balance # 0
*                                   then:
*                                   TRANS VAL 6 = BALANCE BILL.FREQS
!  
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
$INCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
$INCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*
OPEN "ACT" TO ACT.FILE ELSE PRINT "Can't open file ACT"; INPUT RSP; STOP
IF OPSYS NE "R" THEN OPEN "AAX" TO AAX.FILE ELSE PRINT "Can't open file AAX"; INPUT RSP; STOP
OPEN "ACG" TO ACG.FILE ELSE PRINT "Can't open file ACG"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT "Can't open file ADD"; INPUT RSP; STOP
OPEN "ATR" TO ATR.FILE ELSE PRINT "Can't open file ATR"; INPUT RSP; STOP
OPEN "EFT" TO EFT.FILE ELSE PRINT "Can't open file EFT"; INPUT RSP; STOP
OPEN "CAJ" TO CAJ.FILE ELSE PRINT "Can't open file CAJ"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
* LCK.FILE = 0; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
*
STAT = FALSE
MAX.DESC = ONE; DESC.LEN = 5; INPUT.DESC = "N"
BELL.CN = ZERO; LIST.ALL = FALSE
RUN.TYPE = ZERO
RUN.TYPE.CURR = ONE
INPUT BATCH.CLASS.CURR
*
!
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
!
*
START: *
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
*
BUS.DATE = EMPTY
EFF.DATE = EMPTY
POST.DATE = EMPTY
POST.TIME = EMPTY
OPERATOR = EMPTY
DEFAULT.TYPE = EMPTY
BATCH.DEL.STATUS = EMPTY
BATCH.TYPE = EMPTY
BATCH.LPT.DT = EMPTY
BATCH.LPT.TM = EMPTY
*
BATCH.TOTAL.CRD = ZERO; BATCH.TOTAL.CHQ = ZERO; BATCH.TOTAL.CSH = ZERO
*
!
WHICH.BATCH: *
SOURCE = RUN.SOURCE
LC.SOURCE = RUN.LC.SOURCE
TRANS.CLASS = RUN.TRANS.CLASS
PRINT @(0,22):CLL:"Enter N(ew batch), existing batch no. or <cr> to end: ":
INPUT RSP:; IF RSP EQ "KILL" THEN STOP
IF RSP EQ EMPTY THEN
LOOP BATCH.NUM = POSTED.BATCHES<ONE> UNTIL BATCH.NUM EQ EMPTY DO
READ CAJ FROM CAJ.FILE,BATCH.NUM THEN
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
GOSUB EXTRACT.HEADER.DATA
GOSUB PRINT.BATCH
END
DEL POSTED.BATCHES<ONE>
REPEAT
STOP
END
IF RSP EQ "N" THEN NEW = ONE ELSE NEW = EMPTY
IF DOLLAR.EDIT EQ EMPTY THEN
LOOP
PRINT @(ZERO,22):CLL:"Do you prefer to key the decimal point (Y/N)? ":
INPUT DOLLAR.EDIT:; IF DOLLAR.EDIT EQ "KILL" THEN STOP
UNTIL DOLLAR.EDIT EQ "Y" OR DOLLAR.EDIT EQ "N" DO PRINT BELL: REPEAT
IF DOLLAR.EDIT EQ "N" THEN DOLLAR.EDIT = "NC" ELSE DOLLAR.EDIT = "ND"
END
IF NOT(NEW) THEN GOTO EXISTING.BATCH
!
NEW.BATCH: *
CAJ = EMPTY
BATCH.STATUS = "B"
ENTRY.DATE = CONTROL.DT
ENTRY.TIME = OCONV(TIME(),"MT")
BATCH.TOTAL = EMPTY
ENTERED.TOTAL = EMPTY
ADJUST.TOTAL = EMPTY
DEFAULT.TYPE = EMPTY
ITEM.COUNT = ZERO
BATCH.DEL.STATUS = FALSE
BATCH.TYPE = EMPTY
BATCH.LPT.DT = EMPTY
BATCH.LPT.TM = EMPTY
*
GOSUB GET.HEADER.DATA; IF STAT EQ 999 THEN GOTO START
IF DEFAULT.TYPE EQ EMPTY THEN GOTO WHICH.BATCH
*
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CNT.FILE,"CNT","CASH.BATCH.NUM",LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO START
WHILE LCK.STAT DO REPEAT
*
READ BATCH.NUM FROM CNT.FILE,"CASH.BATCH.NUM" ELSE BATCH.NUM = ONE
IF ALL.FLAG THEN WRITE BATCH.NUM + ONE ON CNT.FILE,"CASH.BATCH.NUM"
CALL UNLOCK.ITEM(CNT.FILE,"CNT","CASH.BATCH.NUM",LCK.FILE)
*
BATCH.NUM = (BATCH.NUM + 100000)[TWO,5]
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO NEW.BATCH
WHILE LCK.STAT DO REPEAT
*
*
GOSUB DISPLAY.HEADER.DATA
CURR.PG = ONE
IF OPSYS EQ "U" THEN GOSUB IMPRINT.HEADER; *CHEQUE IMPRINTER HEADER LINE..
GOSUB ADD.TRANS
GOTO WHAT.NEXT
!
EXISTING.BATCH: *
BATCH.NUM = STR(ZERO,5 - LEN(RSP)):RSP
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO START
WHILE LCK.STAT DO REPEAT
READ CAJ FROM CAJ.FILE,BATCH.NUM ELSE PRINT BELL:; GOTO FINISH
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
GOSUB EXTRACT.HEADER.DATA
IF BATCH.SOURCE NE SOURCE THEN PRINT BELL:; GOTO FINISH
IF STAT EQ 999 THEN GOTO FINISH
DEFAULT.TYPE = "!":DEFAULT.TYPE; GOSUB GET.DEFAULT.TYPE
GOSUB DISPLAY.HEADER.DATA
GOSUB LIST.BATCH
IF STAT THEN GOTO FINISH
*
IF BATCH.STATUS NE "P" AND BATCH.STATUS NE "Z" THEN
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN BATCH.STATUS = EMPTY
GOSUB CHECK.BALANCE
END ELSE
MSG = " ":ITEM.COUNT:" item"; IF ITEM.COUNT - ONE THEN MSG = MSG:"s"
MSG = MSG:" - Batch posted on ":OCONV(POST.DATE<ONE,ONE,ONE>,"D2"):" "
MSG = STR("*",40-LEN(MSG) / TWO):MSG:STR("*",40)
PRINT @(ZERO,23):RVB:MSG "L#79":RVE:
LOOP
PRINT @(ZERO,22):CLL:"Enter L(ist again), P(rint again), or <cr> to end: ":
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
IF RSP EQ "L" THEN GOSUB LIST.BATCH
IF RSP EQ "P" THEN GOSUB PRINT.BATCH; IF OPSYS NE "R" THEN PRINTER CLOSE
WHILE RSP EQ "L" OR RSP EQ "P" DO REPEAT
GOTO FINISH
END
IF OPSYS EQ "U" THEN GOSUB IMPRINT.HEADER; *CHEQUE IMPRINTER HEADER LINE..
!
WHAT.NEXT: *
PRINT @(ZERO,21):CLL:"Enter # to alter, A(dd), L(ist), P(rint), R(emove error status),"
PRINT @(ZERO,22):CLL:"    C(hange header) or <cr> if okay: ":
INPUT RSP:
PRINT @(0,21):CLL:; IF RSP EQ "KILL" THEN GOTO FINISH
*
BEGIN CASE
CASE RSP EQ EMPTY; GOTO ENTRY.COMPLETED
CASE RSP EQ "A"; GOSUB ADD.TRANS
CASE RSP EQ "C"; GOSUB GET.HEADER.DATA; IF STAT EQ 999 THEN GOTO FINISH ELSE GOSUB UPDATE.FILE; GOSUB CHECK.BALANCE
CASE RSP EQ "L"; GOSUB LIST.BATCH
CASE RSP EQ "P"; GOSUB PRINT.BATCH; IF OPSYS NE "R" THEN PRINTER CLOSE
CASE RSP EQ "R"
IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN
BATCH.STATUS = EMPTY; GOSUB CHECK.BALANCE
LIST.ALL = TRUE; GOSUB LIST.BATCH; LIST.ALL = FALSE
IF STAT THEN GOTO FINISH
END ELSE PRINT BELL:
CASE RSP EQ ZERO OR NOT(RSP MATCHES "0N"); PRINT BELL:
CASE ONE; IF CAJ<RSP> EQ EMPTY THEN PRINT BELL: ELSE GOSUB CHANGE.TRANS
END CASE
GOTO WHAT.NEXT
!
UPDATE.FILE: *
*
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
*
RETURN
!
ENTRY.COMPLETED: *
IF BATCH.TOTAL EQ ENTERED.TOTAL THEN
MSG = "Batch is in balance - S(ave but don't post), D(elete it) or <cr> to post: "
END ELSE MSG = "Batch is not in balance - S(ave it), D(elete it) or <cr> to continue: "
*
LOOP
PRINT @(ZERO,22):CLL:MSG:
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
IF RSP EQ "S" THEN
IF OPSYS NE "U" THEN GOTO FINISH
GOSUB IMPRINT.TOTAL
GOSUB UPDATE.FILE
GOTO FINISH
END
IF RSP EQ "D" THEN GOTO DELETE.BATCH
UNTIL RSP EQ EMPTY DO PRINT BELL: REPEAT
IF BATCH.TOTAL NE ENTERED.TOTAL THEN GOTO WHAT.NEXT
*
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
PRINT RVB:STR("*",80):RVE:
POST.DATE = CONTROL.DT
POST.TIME = OCONV(TIME(),"MT")
IF OPSYS EQ "U" THEN GOSUB IMPRINT.TOTAL; *CHEQUE IMPRINTER TOTAL LINE..
CALL CASH.OR.ADJ.POST(LCK.FILE,PAR.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,LCK.ITM,LCK.TYPE,LCK.STAT,STAT,CAJ,RUN.TYPE,RUN.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,RUN.TRANS.SUB.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,DELINQ.STAT,MIN.BALANCE,BUS.DATE,BATCH.CLASS.CURR,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,BATCH.DEL.STATUS)
IF NOT(STAT) THEN BATCH.STATUS = "P" ELSE BATCH.STATUS = "E"
POSTED.BATCHES<-ONE> = BATCH.NUM
END
GOSUB UPDATE.FILE
*
!
*
FINISH: *
*
CALL UNLOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE)
*
GOTO START
*
!
*
EXTRACT.HEADER.DATA: *
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
RETURN
*
!
*
DELETE.BATCH: *
*
LOOP
PRINT @(ZERO,22):CLL:"Are you sure you want to delete the batch (Y/N)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
IF RSP EQ "N" THEN GOTO ENTRY.COMPLETED
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
DELETE CAJ.FILE,BATCH.NUM
GOTO FINISH
*
!
*
CHECK.BALANCE: *
*
PRINT @(69,TWO):OCONV(ENTERED.TOTAL,"MR2ZM") "R#10":
IF ADJUST.TOTAL THEN PRINT @(69,3):OCONV(ADJUST.TOTAL,"MR2ZM") "R#10":
MSG = " ":ITEM.COUNT:" item"; IF ITEM.COUNT - ONE THEN MSG = MSG:"s"
DIFF = BATCH.TOTAL - ENTERED.TOTAL
IF DIFF THEN
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN BATCH.STATUS = "U" ELSE MSG = MSG:" Errors"
MSG = MSG:" - Difference of ":OCONV(DIFF,"MR2M"):" "
END ELSE
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN BATCH.STATUS = "B" ELSE MSG = MSG:" Errors"
MSG = MSG:" - Batch is in balance":" "
END
MSG = STR("*",40 - LEN(MSG) / TWO):MSG:STR("*",40)
PRINT @(ZERO,23):RVB:MSG "L#79":RVE:
RETURN
*
!
*
ADD.TRANS: *
*
LOCATE EMPTY IN CAJ SETTING TRANS.COUNT THEN NULL
PG = INT((TRANS.COUNT + 15) / 16); IF PG NE CURR.PG THEN GOSUB DISPLAY.PAGE
LN = MOD(TRANS.COUNT - ONE,16) + 4
ACT.ID = EMPTY; MORE.TRANS = EMPTY
*
LOOP
ITEM.COUNT = ITEM.COUNT + ONE
GOSUB GET.ENTRIES
IF TRANS NE EMPTY AND MORE.TRANS EQ EMPTY THEN
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN MORE.TRANS = TRANS.TYPES<3,LOC> 
ADJ.DESC = MORE.TRANS<ONE,ONE,ONE>
IF ADJ.DESC NE EMPTY THEN
IF BATCH.CLASS.CURR EQ TWO THEN
LOCATE ADJ.DESC IN TRANS.TYPES<ONE> SETTING LOC THEN ADJ.DESC = TRANS.TYPES<TWO,LOC>; TMP = ADJ.DESC
END ELSE
LOCATE ADJ.DESC IN TRANS.TYPES.ADJ<ONE> SETTING LOC THEN ADJ.DESC = TRANS.TYPES.ADJ<TWO,LOC>; TMP = "a-":ADJ.DESC
END
IF MORE.TRANS NE EMPTY THEN CAJ<TRANS.COUNT + ONE> = "!":TRANS<ONE,ONE>:VM:"!":MORE.TRANS<ONE,ONE,ONE>:VM:VM:TMP
END
END ELSE
IF ACT.ID EQ EMPTY THEN MORE.TRANS = EMPTY; CAJ<TRANS.COUNT> = EMPTY ELSE
DEL MORE.TRANS<ONE,ONE,ONE>
IF MORE.TRANS<ONE,ONE,ONE> = EMPTY OR MORE.TRANS<ONE,ONE,ONE> = TRANS<ONE,TWO> THEN MORE.TRANS = EMPTY ELSE
CAJ<TRANS.COUNT + ONE> = "!":TRANS<ONE,ONE>:VM:"!":MORE.TRANS<ONE,ONE,ONE>
END
END
END
WHILE (ACT.ID NE EMPTY OR MORE.TRANS NE EMPTY) AND STAT NE 999 DO
TRANS.COUNT = TRANS.COUNT + ONE
LN = LN + ONE
IF LN GT 20 THEN
FOR LN = 4 TO 20; PRINT @(ZERO,LN):CLL:; NEXT LN
LN = 4; PG = PG + ONE; CURR.PG = PG
END
REPEAT
ITEM.COUNT = ITEM.COUNT - ONE
RETURN
*
!
*
CHANGE.TRANS: *
*
TRANS.COUNT = RSP
PG = INT((TRANS.COUNT + 15) / 16); IF PG NE CURR.PG THEN GOSUB DISPLAY.PAGE
LN = MOD(TRANS.COUNT - ONE,16) + 4
LOOP
PRINT @(ZERO,22):CLL:"Enter D(elete line) or <cr> to change it: ":
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
IF RSP EQ "D" THEN
ITEM.COUNT = ITEM.COUNT - ONE
TRANS = CAJ<TRANS.COUNT>; DEL CAJ<TRANS.COUNT>
IF TRANS<ONE,4>[ONE,TWO] = "a-" AND BATCH.CLASS.CURR GT ZERO THEN
ADJUST.TOTAL = ADJUST.TOTAL - TRANS<ONE,3>
END ELSE
ENTERED.TOTAL = ENTERED.TOTAL - TRANS<ONE,3>
END
GOSUB CHECK.BALANCE
GOSUB UPDATE.FILE
GOSUB DISPLAY.PAGE
RETURN
END
UNTIL RSP EQ EMPTY DO PRINT BELL: REPEAT
GOSUB GET.ENTRIES
RETURN
*
!
*
PRINT.BATCH: *
*
GOSUB UPDATE.FILE
*
CALL CASH.OR.ADJ.PRINT(LCK.FILE,PAR.FILE,ACT.FILE,CAJ,CO.NAME,BATCH.HEADER,BATCH.STATUS.DESC,BATCH.NUM,BATCH.TOTAL.CHQ,BATCH.TOTAL.CRD,BATCH.TOTAL.CSH,RUN.TYPE,RUN.TYPE.CURR,TITLE,TRANS.TYPES,BATCH.CLASS.CURR,MIN.DELINQ.AMT,MIN.DELINQ.STAT,LCK.ITM,LCK.TYPE,LCK.STAT,STAT)
IF BATCH.STATUS EQ "E" THEN BATCH.STATUS = "R"
RETURN
*
!
*
LIST.BATCH: *
*
PG = ONE
LOOP GOSUB DISPLAY.PAGE UNTIL TRANS EQ EMPTY OR STAT DO
IF NOT(LIST.ALL) THEN
LOOP
PRINT @(ZERO,22):CLL:"Enter N(ext page) or <cr> to end listing: ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP EQ EMPTY THEN RETURN
UNTIL RSP EQ "N" DO PRINT BELL: REPEAT
END
PG = PG + ONE
REPEAT
RETURN
*
!
*
DISPLAY.PAGE: *
*
FOR LN = 4 TO 20; PRINT @(ZERO,LN):CLL:; NEXT LN
LN = 4; DISP.COUNT = (PG - ONE) * 16 + ONE; BELL.CN = ZERO
LOOP TRANS = CAJ<DISP.COUNT> UNTIL TRANS EQ EMPTY OR LN GT 20 DO
PRINT @(ZERO,LN):DISP.COUNT "R#3":" ":
IF TRANS<ONE,5> NE EMPTY THEN TRANS<ONE,ONE> = "!":TRANS<ONE,5> ELSE TRANS<ONE,ONE> = "!":TRANS<ONE,ONE> 
GOSUB GET.ACT.ID
IF STAT LT ZERO THEN STAT = 999
IF STAT THEN RETURN
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
PRINT @(35,LN):TRANS.TYPE "L#2":@(39,LN):OCONV(TRANS<1,3>,"MR2ZM") "R#9":@(49,LN):
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC ELSE NULL
IF TRANS<ONE,4> NE EMPTY OR TRANS<ONE,7> NE EMPTY THEN 
IF TRANS<ONE,4> EQ EMPTY THEN
PRINT TRIM(TRANS<ONE,7>)[ONE,30]
END ELSE IF LEN(TRANS<ONE,4,ONE>) LT 6 THEN
PRINT TRIM("CH#:":TRANS<ONE,4,ONE>:" ":TRANS.TYPES<TWO,LOC>:" ":TRANS<ONE,7>)[ONE,30]:
END ELSE
PRINT TRIM(TRANS<ONE,4,ONE>:" ":TRANS<ONE,4,TWO>:" ":TRANS<ONE,7>)[ONE,30]:
END
END ELSE PRINT TRANS.TYPES<TWO,LOC> "L#30":
DISP.COUNT = DISP.COUNT + ONE
LN = LN + ONE
REPEAT
CURR.PG = PG
RETURN
*
!
*
DISPLAY.HEADER.DATA: *
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.HDR.FG
*
RETURN
*
!
*
GET.HEADER.DATA: *
*
FOR NUM = ONE TO 5
ON NUM GOSUB GET.DEFAULT.TYPE,GET.BATCH.TOTAL,GET.BUS.DATE,GET.EFF.DATE,GET.OPERATOR
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN NUM = NUM - ONE ELSE
NUM = NUM - TWO; IF NUM LT ZERO THEN RETURN
END
STAT = FALSE
END
NEXT NUM
RETURN
*
!
*
GET.DEFAULT.TYPE: *
*
* IF BATCH.CLASS.CURR EQ TWO THEN DEFAULT.TYPE = "!":TRANS.TYPES<ONE,ONE>
CALL INPUT.DATA(DEFAULT.TYPE,41,ONE,TWO,ONE,"","LF":SVM:"0":SVM:"2":VM:"EQ":SVM:"@":TRANS.TYPES<ONE>:"@","",RSP,STAT)
IF STAT THEN RETURN
LOCATE DEFAULT.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN PRINT @(41,ONE):TRANS.TYPES<TWO,LOC> "L#20":
RETURN
*
!
*
GET.BATCH.TOTAL: *
*
CALL INPUT.DATA(BATCH.TOTAL,69,ONE,"R10",ONE,"MR2ZM",DOLLAR.EDIT,EMPTY,RSP,STAT)
IF STAT THEN RETURN
RETURN
*
!
*
GET.BUS.DATE: *
*
IF BUS.DATE EQ EMPTY THEN BUS.DATE = CONTROL.DT
LOOP
CALL INPUT.DATA(BUS.DATE,10,TWO,9,ONE,"D2","DT",EMPTY,RSP,STAT)
IF STAT THEN RETURN
WHILE BUS.DATE GT CURR.ACCTG.DATE DO BUS.DATE = CURR.ACCTG.DATE REPEAT
RETURN
*
!
*
GET.EFF.DATE: *
*
EFF.DATE = BUS.DATE
RETURN
*
!
*
GET.OPERATOR: *
*
CALL INPUT.DATA(OPERATOR,52,TWO,3,ONE,EMPTY,"EQ":SVM:"@":OPERATORS<ONE>:"@",EMPTY,RSP,STAT)
IF STAT THEN RETURN
RETURN
*
!
*
GET.ENTRIES: *
*
TRANS = CAJ<TRANS.COUNT>
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" AND BATCH.CLASS.CURR GT ZERO THEN ADJ = ONE ELSE ADJ = ZERO
PRINT @(ZERO,LN):TRANS.COUNT "R#3":" ":
BELL.CN = ZERO
FOR NUM = ONE TO 4
ON NUM GOSUB GET.ACT.ID,GET.TRANS.TYPE,GET.AMOUNT,GET.DESCRIP
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN NUM = NUM - ONE ELSE
NUM = NUM - TWO; IF NUM LT ZERO THEN NUM = ZERO
END
STAT = FALSE
END
IF NUM EQ ONE THEN IF ACT.ID EQ EMPTY THEN RETURN
NEXT NUM
CAJ<TRANS.COUNT> = TRANS
IF OPSYS EQ "U" THEN GOSUB IMPRINT.DETAIL; *CHEQUE IMPRINTER DETAIL LINE..
GOSUB UPDATE.FILE
RETURN
*
!
*
GET.ACT.ID: *
*
PREFIX = EMPTY; IF TRANS<ONE,5> NE EMPTY THEN ORIG.ACT.ID = TRANS<ONE,5> ELSE ORIG.ACT.ID = TRANS<ONE,ONE>
LOOP
LOOP
CALL INPUT.DATA(TRANS,5,LN,9,"1,1","","OP":VM:"LF":SVM:"0":SVM:"7":VM:"MA":SVM:"7N":SVM:"6N'#'":SVM:"6N'+'":SVM:"6N'.'":SVM:"1A8N","",RSP,STAT)
IF STAT THEN RETURN
ACT.ID = TRANS<ONE,ONE>; IF ACT.ID EQ EMPTY THEN IF ORIG.ACT.ID EQ EMPTY THEN RETURN
PREFIX = ACT.ID[ONE,ONE]
IF PREFIX GT "9" THEN
MATREAD AAX FROM AAX.FILE,ACT.ID ELSE MAT AAX = EMPTY
TRANS<ONE,5> = TRANS<ONE,ONE>; TRANS<ONE,ONE> = AAX$ACT.ID; ENTERED.CD = EMPTY; CD = EMPTY
ACT.ID = TRANS<ONE,ONE>
END ELSE
ENTERED.CD = ACT.ID[7,ONE]; ACT.ID = ACT.ID[ONE,6]
CALL MOD11.DIGIT (ACT.ID,CD)
IF ENTERED.CD EQ "#" OR ENTERED.CD EQ "." OR ENTERED.CD EQ "+" THEN ENTERED.CD = CD
END
CONT = TRUE
IF CD EQ ENTERED.CD OR PREFIX GT 9 THEN CONT = FALSE
IF CONT AND BELL.CN LT 3 THEN PRINT BELL:; BELL.CN = BELL.CN + ONE
UNTIL NOT(CONT) OR BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" DO TRANS<ONE,ONE> = ORIG.ACT.ID REPEAT
CONT = TRUE
MATREAD ACT FROM ACT.FILE,ACT.ID THEN
LAST.NAME = FIELD(ACT$CUS.NAME,"*",ONE)
FIRST.NAME = FIELD(ACT$CUS.NAME,"*",TWO)
FULL.NAME = TRIM(FIRST.NAME:" ":LAST.NAME)
IF LEN(FULL.NAME) GT 19 THEN FULL.NAME = TRIM(FIRST.NAME[ONE,ONE]:" ":LAST.NAME)
CONT = FALSE
END ELSE
MAT ACT = EMPTY
FULL.NAME = "Account is missing!"
IF BELL.CN LT 3 THEN PRINT BELL:; BELL.CN = BELL.CN + ONE
IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" OR ORIG.ACT.ID[ONE,ONE] EQ "!" THEN CONT = FALSE
END
IF ORIG.ACT.ID[ONE,ONE] EQ "!" AND ACT.ID EQ EMPTY THEN ACT.ID = "!"
WHILE ACT.ID EQ EMPTY OR CONT DO PRINT BELL:; TRANS<ONE,ONE> = ORIG.ACT.ID REPEAT
IF ACT$STAT EQ "C" THEN TRANS<ONE,6> = "** Collection Account **" ELSE
IF ACT$BALANCE GE MIN.DELINQ.AMT AND ACT$CREDIT.STATUS GE MIN.DELINQ.STAT THEN TRANS<ONE,6> = STR("*",(ACT$CREDIT.STATUS - MIN.DELINQ.STAT) * 3):" Delinquent Account ":STR("*",(ACT$CREDIT.STATUS - MIN.DELINQ.STAT) * 3)
END
PRINT @(15,LN):FULL.NAME "L#19":
RETURN
*
!
*
GET.TRANS.TYPE: *
*
IF BATCH.CLASS.CURR EQ ONE AND NOT(ADJ) THEN TRANS<ONE,TWO> = "!":DEFAULT.TYPE ELSE IF TRANS<ONE,TWO> = EMPTY THEN TRANS<ONE,TWO> = DEFAULT.TYPE
IF TRANS<ONE,4>[ONE,TWO] = "a-" THEN TMP = TRANS.TYPES.ADJ<ONE> ELSE TMP = TRANS.TYPES<ONE>
CALL INPUT.DATA(TRANS,35,LN,TWO,"1,2",EMPTY,"OP":VM:"LF":SVM:"0":SVM:"2":VM:"EQ":SVM:"@":TMP:"@",EMPTY,RSP,STAT)
IF STAT THEN RETURN
IF TRANS<ONE,TWO> = DEFAULT.TYPE THEN TRANS<ONE,TWO> = ""
RETURN
*
!
*
GET.AMOUNT: *
*
ORIG.AMT = TRANS<ONE,3>
CALL INPUT.DATA(TRANS,39,LN,"R9","1,3","MR2ZM",DOLLAR.EDIT,EMPTY,RSP,STAT)
IF STAT THEN RETURN
IF ADJ THEN ADJUST.TOTAL = ADJUST.TOTAL+TRANS<ONE,3> - ORIG.AMT ELSE
ENTERED.TOTAL = ENTERED.TOTAL+TRANS<ONE,3> - ORIG.AMT
END
GOSUB CHECK.BALANCE
RETURN
*
!
*
GET.DESCRIP: *
*
DESC = TRANS<ONE,4>
IF DESC EQ EMPTY THEN
DEF.DESC = TRANS<ONE,TWO>; IF DEF.DESC EQ EMPTY THEN DEF.DESC = DEFAULT.TYPE
LOCATE DEF.DESC IN TRANS.TYPES<ONE> SETTING LOC THEN DEF.DESC = TRANS.TYPES<TWO,LOC>; STD.DESC = DEF.DESC; INPUT.DESC = TRANS.TYPES<5,LOC>
END ELSE PRINT @(ZERO,22):CLL:"Description: ":TRIM(DESC<ONE,ONE,ONE>:" ":DESC<ONE,ONE,TWO>)[ONE,30]:; STD.DESC = EMPTY
IF BATCH.CLASS.CURR NE ONE THEN INPUT.DESC = "Y"
IF DESC[ONE,TWO] EQ "a-"  OR INPUT.DESC NE "Y" THEN PRINT @(49,LN):DESC "L#30":; RETURN
SC = ONE
LOOP
IF SC GT MAX.DESC THEN
IF MAX.DESC GT ONE THEN
PRINT @(49,LN):CLL:"Enter <cr> to end ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP EQ "^" THEN STAT = -ONE
END
END ELSE DESC = EMPTY; CALL INPUT.DATA(DESC,49,LN,DESC.LEN,"1,1,":SC,EMPTY,EMPTY,EMPTY,RSP,STAT); IF STAT EQ 999 THEN RETURN
IF STAT = -ONE THEN SC = SC - TWO; IF SC LT ZERO THEN SC = ZERO
UNTIL DESC EQ STD.DESC OR RSP EQ EMPTY OR SC GT MAX.DESC DO
PRINT @(ZERO,22):CLL:"Description: ":TRIM(DESC<ONE,ONE,ONE>:" ":DESC<ONE,ONE,TWO>)[ONE,60]:
SC = SC + ONE
REPEAT
IF DESC NE STD.DESC THEN TRANS<ONE,4> = DESC; PRINT @(49,LN):DESC<ONE,ONE,ONE> "L#30":@(ZERO,22):CLL:
RETURN
*
!
*
$INCLUDE IBP.CASH CASH.INCL.IMPRINT
*
!
*
$INCLUDE IBP CLS.ROUTINE
!
END
~CASH.OR.ADJ.INIT~
*
*
*
*
*
*
*
*
*
*
*
!  
*
BEGIN CASE
CASE ENTRY.TYPE = 0
TITLE = "Adjustments"
TRANS.CLASS = 'a'
TRANS.ITEM = "TRANS.TYPES.ADJ"
MAX.DESC = TWO; DESC.LEN = 30; INPUT.DESC = "Y"
CASE ENTRY.TYPE = ONE
TITLE = "Cash"
TRANS.CLASS = 'p'
TRANS.ITEM = "TRANS.TYPES.PMT"
CASE ENTRY.TYPE = TWO
TITLE = "Deposit"
TRANS.CLASS = 'd'
TRANS.ITEM = "TRANS.TYPES.DEP"
CASE ENTRY.TYPE = 3
TITLE = "IPV"
TRANS.CLASS = 'b'
TRANS.ITEM = "TRANS.TYPES.BIL"
CASE TRUE; STOP
END CASE
*
SOURCE = TITLE[ONE,ONE]; LC.SOURCE = CHAR(SEQ(SOURCE)+32)
RUN.TRANS.CLASS = TRANS.CLASS
RUN.SOURCE = SOURCE
RUN.LC.SOURCE = LC.SOURCE
*
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = EMPTY
IF OPERATORS = EMPTY THEN OPERATORS = ACCT[ONE,3]
READ TRANS.TYPES FROM PAR.FILE,TRANS.ITEM ELSE PRINT "Can't read PAR ":TRANS.ITEM; CALL GET.INPUT(RSP); STOP
READ TRANS.TYPES.ADJ FROM PAR.FILE,"TRANS.TYPES.ADJ" ELSE PRINT "Can't read PAR TRANS.TYPES.ADJ"; CALL GET.INPUT(RSP); STOP
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; CALL GET.INPUT(RSP); STOP
ACCTG.PERIOD = CURR.ACCTG.PERIOD[ONE,TWO]:"-":CURR.ACCTG.PERIOD[3,TWO]
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; CALL GET.INPUT(RSP); STOP
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; CALL GET.INPUT(RSP); STOP
CO.NAME = CO.DATA<ONE,ONE,ONE>; CONTROL.DT = CO.DATA<TWO,ONE,ONE>
READ CREDIT.CRITERIA FROM PAR.FILE,"CREDIT.CRITERIA" ELSE CREDIT.CRITERIA = EMPTY
MIN.BALANCE = CREDIT.CRITERIA<ONE>; IF NOT(MIN.BALANCE) THEN MIN.BALANCE = 100
DELINQ.STAT = CREDIT.CRITERIA<TWO>
DOLLAR.EDIT = EMPTY; STAT = ""; POSTED.BATCHES = ""
*
~CASH.PRINT.TEST.RECEIPT~
*PROGRAM:           CASH.PRINT.TEST.RECEIPT
* VERSION: 930610 2.9  NEW
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
$INCLUDE IBP ACT.EQUATES
*
!
SYS.TST = 1
!
VERSION = " (R:2.9)"
OPEN "ACT" TO ACT.FILE ELSE PRINT CLB:"Can't open ACT":; INPUT RSP:; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT CLB:"Can't open ADD":; INPUT RSP:; STOP
OPEN "STT" TO STT.FILE ELSE PRINT CLB:"Can't open STT":; INPUT RSP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT RSP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT RSP:; STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = ""
CO.NAME = CO.DATA<1>
READ TRANS.TYPES FROM PAR.FILE,"TRANS.TYPES.PMT" ELSE TRANS.TYPES = ""
!
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME) / 2 + .5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Print a TEST Receipt":VERSION
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
!
START: *
READ RECEIPT.FORMAT FROM CNT.FILE,"CASH.RECEIPT.TOP" ELSE
PRINT @(10,8):CLL:"The DEFAULT Receipt format will be used":
END
*
* INPUT ACT NUMBER, CURRENCY, PAYMENT TYPE, PAYMENT AMOUNT
*
* ACCOUNT NUMBER
LOOP
STAT = 0
PRINT @(0,10):CLL:"Enter an account number without the check digit: ":
INPUT ACT.ID
IF ACT.ID = "KILL" OR ACT.ID = "" THEN GOTO FINISH
ACT.ID = STR(0,6-LEN(ACT.ID)):ACT.ID
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE STAT = 1
PRINT @(10,11):ACT$CUS.NAME:
WHILE STAT DO PRINT BELL: REPEAT
ADD.ID = ACT$ADD.ID
MATREAD ADD FROM ADD.FILE,ADD.ID ELSE STOP
STT.ID = FIELD(ACT$ADD.ID,"*",3)
*
* CURRENCY TYPE
LOOP
STAT = 0
PRINT @(0,12):CLL:"Enter a Currency Type (CA,CC,CH,CD): ":; INPUT CURRENCY:
IF CURRENCY = "KILL" THEN GOTO FINISH
BEGIN CASE
CASE CURRENCY = "CA"
CASE CURRENCY = "CC"
CASE CURRENCY = "CH"
CASE CURRENCY = "CD"
CASE 1; STAT = 1
END CASE
WHILE STAT DO PRINT BELL: REPEAT
IF CURRENCY = "CH" THEN
PRINT @(0,13):CLL:"Enter a Check/Cheque Number: ":; INPUT CHECK:
IF CHECK NE "" THEN CURRENCY = CURRENCY:CHECK
END
PAYMENT.TYPE = CURRENCY
PRINT @(10,14):PAYMENT.TYPE
*
* PAYMENT TYPE
LOOP
STAT = 0
PRINT @(0,15):CLL:"Enter a Payment Type: ":; INPUT TYPE:
IF TYPE = "KILL" THEN GOTO FINISH
LOCATE TYPE IN TRANS.TYPES<ONE> SETTING LOC ELSE STAT = 1
WHILE STAT DO PRINT BELL: REPEAT
STD.DESC = TRANS.TYPES<2,LOC>
PRINT @(10,16):CLL:TYPE:"  ":STD.DESC
*
* PAYMENT AMOUNT
LOOP
PRINT @(0,17):CLL:"Enter a payment amount (no decimal): ":; INPUT AMOUNT
IF AMOUNT = "KILL" THEN GOTO FINISH
WHILE NOT(NUM(AMOUNT)) DO PRINT BELL: REPEAT
PRINT @(10,18):CLL:"Amount ":OCONV(AMOUNT,"MR2ZM") "L#9":
*
* PRINTER OPTIONS
LOOP
PRINT @(0,19):"Enter Printer choice: 1 = Q0, 2 = Q6, 3 = Auxillary: ":; INPUT PTR.TYPE:
IF PTR.TYPE = 3 THEN
READV AUX.PTR FROM CNT.FILE,"PRINTER":PORT,1 THEN
IF NOT(AUX.PTR) THEN
PTR.TYPE = ""
END
END ELSE
PRINT CLB:"There is no Auxillary Printer defined for this port. Enter <cr>: ":; INPUT RSP:
PTR.TYPE = ""
END
END
IF NOT(PTR.TYPE = 1 OR PTR.TYPE = 2 OR PTR.TYPE = 3) THEN PTR.TYPE = ""
UNTIL PTR.TYPE NE "" DO PRINT CLB:BELL: REPEAT
SYS.TST<1> = PTR.TYPE
!
PRINT CLB:" Enter <cr> to proceed or 'KILL' to stop: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
*
CALL CASH.SUBR.PRINT.RECEIPT(MAT CNT.CSH,CNT.CSH.ID,PAYMENT.TYPE,AMOUNT,STD.DESC)
*
!
FINISH: *
STOP
!
END
~CASH.SUBR.BATCH.ANAL~
SUBROUTINE CASH.SUBR.BATCH.ANAL(CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*VERSION 1.0
*
*CHANGED,MAX.DESC,DESC.LEN,INPUT.DESC,BELL.CN,LIST.ALL,
*LN.MAX,LN.BOT,LN.TOP,CURR.PG
*PORT.CC,USER.VALID,MAT CNT.CSH
*
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Billings entry
*
*     Sources
*                  0 = CASH.ENTRY
*                  3 = Counter Cash
*                  4 = Lock Box Trans
*                  5 = Pay-Per-View Charges
*
*                  See list post program
*
*   Entry modes
*                  0 = From Cash.Entry
*                  1 = From Genie
*
*
* DATE WRITTEN:    DD MMM 83
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
*
MAT CNT.CSH = EMPTY
*
!
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.CNTRL
*FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,STAT,AUTO.RUN,PHAN.RUN,
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
* MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR,STAT
*
!
*
FINISH: *
*
RETURN; * To calling program
*
END
~CASH.SUBR.CLASS.PARSE~
SUBROUTINE CASH.SUBR.CLASS.PARSE(BATCH.CLASS.SEL)
*
*
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
!
*
* 0 Regular Adjustments (ADJ)
* 1 Regular Payments    (PMT)
* 2 Regular Deposits    (DEP)
* 3 Special Billing     (BIL)
* 6 All Batch Types
IF NOT(NUM(BATCH.CLASS.SEL)) THEN
TMP1 = BATCH.CLASS.SEL; TMP = EMPTY
LOOP WHILE LEN(TMP1) DO
BEGIN CASE
CASE TMP1[ONE,3] EQ "ALL"
TMP = "6"; TMP1 = "6"
CASE TMP1[ONE,3] EQ "ADJ"
TMP = TMP:"0"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "PMT"
TMP = TMP:"1"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "DEP"
TMP = TMP:"2"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "BIL"
TMP = TMP:"3"; TMP1 = TMP1[4,9999]
CASE INDEX("01236",TMP1[ONE,ONE],ONE) AND NOT(INDEX(TMP,TMP1[ONE,ONE],ONE))
TMP = TMP:TMP1[ONE,ONE]; TMP1 = TMP1[TWO,9999]
CASE TRUE
TMP1 = TMP1[TWO,9999]
END CASE
REPEAT
BATCH.CLASS.SEL = TMP
END
*
RETURN
*
END
~CASH.SUBR.ENTRY~
SUBROUTINE CASH.SUBR.ENTRY(LN.TOP,LN.BOT,LN.HDR.TOP,ENTRY.MODE,RECP.IMPRT.MODE,CSH.TYPE,CSH.TYPE.CURR,BATCH.CLASS.CURR,BATCH.SOURCE.CURR,ALLOWED.MODE,DOLLAR.EDIT,FROM.LIST,PHAN.RUN)
*ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG
*
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*SETTERM
*
!
*
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Billings entry
*
*     Sources
*                  0 = CASH.ENTRY
*                  3 = Counter Cash
*                  4 = Lock Box Trans
*                  5 = Pay-Per-View Charges
*                  6 = Late Charges
*                  7 = Write Off
*
*                  See list post program
*
*   Entry modes
*                  0 = From Cash.Entry - page mode
*                  1 = From Genie      - line mode
*                  2 = From Cash.Entry - line mode for post/unpost on chg
*
*
* DATE WRITTEN:    DD MMM 83
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
*                  26-JAN-88   HH   Cr. Status not updated for a 'Late
*                                   Notice' trans. unless Cr. Status is
*                                   less than Min. Delinq. criteria.
*                  01-AUG-88   HH   TRANS VAL 5 = Old Account Number
*                  24-NOV-88   HH   TRANS VAL 6 = 'Collection Account'
*                                   If active & updated balance # 0
*                                   then:
*                                   TRANS VAL 6 = BALANCE BILL.FREQS
!  
*
$INCLUDE IBP ACT.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
*INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
*INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
*
CALL CASH.SUBR.ENTRY.INIT(ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
IF STAT THEN RETURN
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
$INCLUDE IBP SYS.INCL.SCR.CO
IF STAT THEN RETURN
*
ORIG.INPUT.DESC = INPUT.DESC; LN.MAX = LN.BOT - LN.TOP + ONE
LPT.DETAIL.FL = TRUE; LPT.PMT.TYP.FL = TRUE; LPT.FL = TRUE; LPT.STAT = FALSE
CURR.PG = -ONE
BELL.CN = ZERO
CONT = FALSE; CONT1 = FALSE
REDISP = FALSE
ITEM.CURR = ZERO
*
IF ENTRY.MODE EQ ZERO THEN
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
END
*
*
!
*
START: *
*
* IF ENTRY.MODE EQ ZERO THEN
* $INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
* END
*
SOURCE = EMPTY
BATCH.SOURCE = EMPTY
BATCH.STATUS = EMPTY
ENTRY.DATE = EMPTY
ENTRY.TIME = EMPTY
BUS.DATE = EMPTY
EFF.DATE = EMPTY
POST.DATE = EMPTY
POST.TIME = EMPTY
OPERATOR = EMPTY
DEFAULT.TYPE = EMPTY
BATCH.DEL.STATUS = EMPTY
BATCH.TYPE = EMPTY
BATCH.LPT.DT = EMPTY
BATCH.LPT.TM = EMPTY
BATCH.CLASS = EMPTY
BATCH.INP.SOURCE = EMPTY
BATCH.LST = EMPTY
BATCH.TILL = EMPTY
ITEM.COUNT = ZERO
ITEM.CURR = ONE
*
BATCH.TOTAL.CRD = ZERO; BATCH.TOTAL.CHQ = ZERO; BATCH.TOTAL.CSH = ZERO; BATCH.TOTAL.CDC = ZERO
BALANCED.TOTAL = FALSE
DIFF = ZERO
*
!
*
WHICH.BATCH: *
*
SOURCE = RUN.SOURCE
LC.SOURCE = RUN.LC.SOURCE
TRANS.CLASS = RUN.TRANS.CLASS
TRANS.SUB.CLASS = RUN.TRANS.SUB.CLASS
STAT = FALSE
*
* MODE 0
*
IF ENTRY.MODE EQ ZERO THEN
*
PRINT @(0,22):CLL:"Enter N(ew batch), existing batch no. or <cr> to end: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STAT = 999; RETURN; * ?????????????
*
IF RSP[ONE,ONE] EQ "?" THEN
EXECUTE "LIST.CAJ":RSP[TWO,9999]
PRINT CLB:"Enter <cr> . . . ":; INPUT TMP:
GOTO START
END
*
IF RSP EQ EMPTY THEN
* LOOP BATCH.NUM = POSTED.BATCHES<ONE> UNTIL BATCH.NUM EQ EMPTY DO
* READ CAJ FROM CAJ.FILE,BATCH.NUM THEN
* BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
* GOSUB EXTRACT.HEADER.DATA
* GOSUB PRINT.BATCH
* END
* DEL POSTED.BATCHES<ONE>
* REPEAT
RETURN; * To calling program
END
*
IF RSP EQ "N" THEN NEW = TRUE ELSE NEW = EMPTY
PORT.CC = ZERO; USER.VALID = TRUE
*
* not MODE 0
END ELSE
CALL CASH.SUBR.LOAD.LIST.CC(BATCH.NUM,MAT PAR.MENU,MAT SEC.USER,PORT.CC,USER.VALID,CAJ.FILE)
IF STAT OR (PORT.CC AND NOT(USER.VALID)) THEN RETURN
DOLLAR.EDIT = CNT.CSH$USER.DECIMAL
RSP = BATCH.NUM
GOTO EXISTING.BATCH
END; * of MODE not 0
*
!
*
IF DOLLAR.EDIT EQ EMPTY THEN
LOOP
PRINT @(ZERO,22):CLL:"Do you prefer to key the decimal point (Y/N)? ":
INPUT DOLLAR.EDIT:
IF DOLLAR.EDIT EQ "KILL" THEN STAT = 999; RETURN; * TO CALLING PROGRAM
UNTIL DOLLAR.EDIT EQ "Y" OR DOLLAR.EDIT EQ "N" DO PRINT BELL: REPEAT
IF DOLLAR.EDIT EQ "N" THEN DOLLAR.EDIT = "NC" ELSE DOLLAR.EDIT = "ND"
BELL.CN = ZERO
END
*
IF NOT(NEW) THEN GOTO EXISTING.BATCH
*
!
*
NEW.BATCH: *
*
IF ENTRY.MODE EQ ZERO THEN
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
END
*
CAJ = EMPTY
SOURCE = RUN.SOURCE
BATCH.SOURCE = RUN.SOURCE
BATCH.STATUS = "B"
POST.DATE = EMPTY
POST.TIME = EMPTY
ENTRY.DATE = DATE()
ENTRY.TIME = OCONV(TIME(),"MT")
BUS.DATE   = CONTROL.DT
EFF.DATE   = CONTROL.DT
$INCLUDE IBP.CASH CASH.INCL.CLEAR.BATCH
BATCH.DEL.STATUS = FALSE
BATCH.TYPE = EMPTY
BATCH.LPT.DT = EMPTY
BATCH.LPT.TM = EMPTY
BATCH.CLASS = BATCH.CLASS.CURR
BATCH.INP.SOURCE = BATCH.SOURCE.CURR
*
* MODE 0
IF ENTRY.MODE EQ ZERO THEN
*
GOSUB GET.HEADER.DATA; IF STAT EQ 999 THEN GOTO START
IF DEFAULT.TYPE EQ EMPTY THEN GOTO WHICH.BATCH
*
$INCLUDE IBP.CASH CASH.INCL.NEXT.BATCH
IF LCK.STAT THEN GOTO NEW.BATCH
*
* not MODE 0
END ELSE
*****
SOURCE = RUN.SOURCE
BATCH.SOURCE = RUN.SOURCE
BATCH.STATUS = "U"
DEFAULT.TYPE = "CC"
OPERATOR = SEC.USER.ID
PRINT CLB:"New Batch ":BATCH.NUM:BELL:
*****
END; * Of entry.MODE 0
*
BATCH.NUM = (BATCH.NUM + 100000)[TWO,5]
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
IF LCK.STAT THEN GOTO NEW.BATCH
*
*
IF ENTRY.MODE EQ ZERO THEN GOSUB DISPLAY.HEADER.DATA
* CURR.PG = ONE
*
IF CNT.CSH$TILL.RECP.IMPRT EQ "I" THEN
FUNC = "H"; GOSUB IMPRINT.LINE; *CHEQUE IMPRINTER HEADER LINE..
END
*
GOSUB ADD.TRANS
*
GOTO WHAT.NEXT
*
!
*
EXISTING.BATCH: *
*
BATCH.NUM = STR(ZERO,5 - LEN(RSP)):RSP
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
IF LCK.STAT THEN GOTO START
*
READ CAJ FROM CAJ.FILE,BATCH.NUM ELSE
IF ENTRY.MODE EQ 0 THEN
PRINT CLB:"Batch ":BATCH.NUM:" is missing!":BELL:
GOTO FINISH
END ELSE
GOTO NEW.BATCH
END
END
*
* Header
*
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
GOSUB EXTRACT.HEADER.DATA
*
! ON FILE
*
IF BATCH.SOURCE NE RUN.SOURCE THEN
LOOP
PRINT CLB:"Invalid Batch Source ":BATCH.SOURCE:
IF BATCH.DEL.STATUS THEN
PRINT " (DELETED!)":
END
PRINT " does not match source ":RUN.SOURCE:" being entered!":BELL:; INPUT TMP:
PRINT CLB:"Do you wish to view the batch (Y/N=<CR>)? ":BELL:; INPUT TMP:
IF TMP EQ EMPTY THEN TMP = "N"
WHILE TMP NE "Y" AND TMP NE "N" DO PRINT BELL: REPEAT
IF TMP EQ "N" THEN GOTO FINISH
END
*
IF STAT THEN GOTO FINISH
*
! Background
*
IF ENTRY.MODE EQ ZERO THEN
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
END
*
! Display Header & Detail
*
***IF BATCH.STATUS NE "P" AND BATCH.STATUS NE "Z" THEN
*
IF BATCH.STATUS NE "P" AND BATCH.STATUS NE "Z" AND NOT(BATCH.DEL.STATUS) AND BATCH.SOURCE EQ RUN.SOURCE THEN
*
IF ENTRY.MODE EQ ZERO THEN
DEFAULT.TYPE = "!":DEFAULT.TYPE; GOSUB GET.DEFAULT.TYPE
GOSUB DISPLAY.HEADER.DATA
GOSUB LIST.BATCH
* not MODE 0
END ELSE
GOSUB ADD.TRANS
GOSUB CHECK.BALANCE
GOSUB UPDATE.FILE
GOTO WHAT.NEXT
END; * Of entry MODE 0
*
END ELSE
* not STATUS  P or Z
PRINT CLB:"Invalid Batch Status: ":BATCH.STATUS:
IF BATCH.DEL.STATUS THEN
PRINT " (DELETED!)":
END
*
PRINT "  Enter <cr> . . . ":BELL:; INPUT TMP:
GOSUB DISPLAY.HEADER.DATA
GOSUB LIST.BATCH
END; * Of not STATUS  P or Z
*
IF STAT THEN GOTO FINISH
*
* Check Balance
*
*960225*DGH*IF BATCH.STATUS NE "P" AND BATCH.STATUS NE "Z" AND NOT(BATCH.DEL.STATUS) THEN
*960225*DGH*IF BATCH.STATUS NE "P" AND BATCH.STATUS NE "Z" AND NOT(BATCH.DEL.STATUS) AND BATCH.SOURCE EQ RUN.SOURCE THEN
*960225*DGH*IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN BATCH.STATUS = EMPTY
*
IF BATCH.STATUS NE "Z" THEN
*960225*DGH*IF BATCH.STATUS EQ "B" OR BATCH.STATUS EQ "U" THEN BATCH.STATUS = EMPTY
*960225*DGH*IF ENTRY.MODE NE ZERO THEN
GOSUB CHECK.BALANCE
*960225*DGH*END
END; * of not STATUS  Z
*
*960225*DGH*END ELSE
*960225*DGH** STATUS  P or Z
*
IF ENTRY.MODE EQ ZERO THEN
*
*
*960225*DGH***MSG = " ":ITEM.COUNT - ONE:" item"; IF ITEM.COUNT - TWO THEN MSG = MSG:"s"
*960225*DGH*MSG = " ":ITEM.COUNT
*960225*DGH**
*960225*DGH*IF BATCH.DEL.STATUS THEN
*960225*DGH*MSG = MSG:" DELETED!!!"
*960225*DGH*PRINT BELL:
*960225*DGH*END
*960225*DGH**
*960225*DGH*IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN
*960225*DGH*MSG = MSG:" ERROR!"
*960225*DGH*END
*960225*DGH**
*960225*DGH*MSG = MSG:" item"; IF ITEM.COUNT - ONE THEN MSG = MSG:"s"
*960225*DGH*IF POST.DATE<ONE,ONE,ONE> THEN
*960225*DGH*MSG = MSG:" - Batch posted on ":OCONV(POST.DATE<ONE,ONE,ONE>,"D2"):" "
*960225*DGH*END
*960225*DGH**
*960225*DGH*MSG = STR("*",40-LEN(MSG) / TWO):MSG:STR("*",40)
*960225*DGH*PRINT @(ZERO,23):RVB:MSG "L#79":RVE:
*
!
*
IF BATCH.STATUS EQ "P" OR BATCH.STATUS EQ "Z" OR BATCH.DEL.STATUS OR BATCH.SOURCE NE RUN.SOURCE THEN
*
LOOP
PRINT @(ZERO,22):CLL:"Enter L(ist again), P(rint again), or <cr> to end: ":
*  IF ENTRY.MODE NE ZERO THEN RSP = "P" ELSE
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
* END
WHILE (RSP EQ "L" OR RSP EQ "P") AND ENTRY.MODE EQ ZERO DO
IF RSP EQ "L" THEN GOSUB LIST.BATCH
IF RSP EQ "P" THEN GOSUB PRINT.BATCH; IF OPSYS NE "R" THEN CALL LPT.SUBR.CLOSE(STAT)
REPEAT
*
END; * of STATUS  P Z, DEL.STATUS or SOURCE#RUN.SOURCE
*
END; * Of entry MODE 0
*
IF BATCH.STATUS EQ "P" OR BATCH.STATUS EQ "Z" OR BATCH.DEL.STATUS OR BATCH.SOURCE NE RUN.SOURCE THEN
GOTO FINISH
END; * of EXIT based on STATUS or SOURCE
*
*960225*DGH*END; * Of not STATUS  P or Z
*
! Imprinting
*
IF CNT.CSH$TILL.RECP.IMPRT EQ "I" THEN
FUNC = "H"; GOSUB IMPRINT.LINE; *CHEQUE IMPRINTER HEADER LINE..
END
*
!
*
WHAT.NEXT: *
*
IF ENTRY.MODE EQ ZERO THEN
*
**PRINT @(ZERO,21):CLL:"Enter # to alter, A(dd), L(ist), P(rint), R(emove error status),"
MSG = "Enter # to alter, A(dd), L(ist), P(rint),"
*
IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN
MSG = MSG:" R(emove error status),"
END
*
PRINT @(ZERO,21):CLL:MSG
PRINT @(ZERO,22):CLL:"    C(hange header) or <cr> if okay: ":
*
INPUT RSP:
PRINT @(0,21):CLL:
PRINT @(0,22):CLL:
*
IF RSP EQ "KILL" THEN
IF BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5 THEN GOSUB UPDATE.FILE
GOTO FINISH
END
*
* not MODE 0
END ELSE
RSP = EMPTY
END; * of not MODE 0
*
*
BEGIN CASE
*
CASE RSP EQ EMPTY
GOTO ENTRY.COMPLETED
*
* Add an item (Line) to Batch
CASE RSP EQ "A"
GOSUB ADD.TRANS
*
* Change Batch Header
CASE RSP EQ "C"
GOSUB GET.HEADER.DATA
IF STAT EQ 999 THEN
GOTO FINISH
END ELSE
GOSUB UPDATE.FILE
GOSUB CHECK.BALANCE
END
*
* Set to Unprinted Error Batch
CASE RSP EQ "E"
BATCH.STATUS = "R"
PRINT CLB:"Batch is an unprinted ERROR batch! Enter <cr>. . . ":BELL:
INPUT TMP:
GOSUB UPDATE.FILE
*
* List Batch Lines
CASE RSP EQ "L"
GOSUB LIST.BATCH
*
* Print Batch
CASE RSP EQ "P"
GOSUB PRINT.BATCH
IF OPSYS NE "R" THEN
CALL LTR.SUBR.CLOSE(STAT)
END
PRINT CLB:"Batch printed.":BELL:
*
* Remove Error status from Batch
CASE RSP EQ "R"
***CASE RSP EQ "R" AND (BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R")
*
IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN
*
BATCH.STATUS = EMPTY; GOSUB CHECK.BALANCE
LIST.ALL = TRUE; GOSUB LIST.BATCH; LIST.ALL = FALSE
*
IF STAT OR (BATCH.STATUS NE "U" AND BATCH.STATUS NE "B") THEN
IF BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5 THEN GOSUB UPDATE.FILE
***GOTO FINISH
BATCH.STATUS = "R"
PRINT CLB:"Batch is an unprinted ERROR batch!":BELL:
END; * of stat
*
* not STATUS  E or R
END ELSE
BATCH.STATUS = "R"
PRINT CLB:"Batch is an unprinted ERROR batch!":BELL:
***END ELSE PRINT CLB:"Batch already is an ERROR batch!":BELL:
END; * of 'E' or 'R'
*
* Redisplay
CASE RSP EQ "RE"
IF ENTRY.MODE EQ ZERO THEN
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
GOSUB DISPLAY.HEADER.DATA
END
GOSUB LIST.BATCH
*
* Invalid Numeric Line Selection
CASE RSP EQ ZERO OR NOT(RSP MATCHES "0N"); PRINT BELL:
*
* Valid Numeric (Change Line)
CASE ONE; IF CAJ<RSP> EQ EMPTY THEN PRINT BELL: ELSE GOSUB CHANGE.TRANS
*
END CASE
*
* Reloop
*
GOSUB CHECK.BALANCE
*
GOTO WHAT.NEXT
*
! Update File
*
UPDATE.FILE: *
*
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
*
RETURN
*
! Entry completed
*
ENTRY.COMPLETED: *
*
BALANCED.TOTAL = TRUE
*960226*DGH*IF BATCH.CLASS EQ ONE THEN
IF BATCH.TOTAL NE ENTERED.TOTAL THEN BALANCED.TOTAL = FALSE
*960226*DGH*END ELSE
*960226*DGH*IF BATCH.TOTAL NE (ENTERED.TOTAL + ADJUST.TOTAL) THEN BALANCED.TOTAL = FALSE
*960226*DGH*END
*
IF BALANCED.TOTAL THEN
MSG = "Batch balanced"
END ELSE
MSG = "Batch not balanced"
END
*
* Options
*
IF BATCH.DEL.STATUS THEN
MSG = "DELETED ":MSG
MSGA = " - <cr> to continue: "
PRINT BELL:
*
END ELSE IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN
MSG = "ERROR ":MSG
MSGA = " - S(ave), D(elete), or <cr> to continue: "
PRINT BELL:
*
END ELSE IF BALANCED.TOTAL THEN
*960225*DGH*END ELSE IF BATCH.TOTAL EQ ENTERED.TOTAL THEN
MSGA = " - S(ave), D(elete), P(ost it later) or <cr> to post: "
*
END ELSE
MSGA = " - S(ave), D(elete) or <cr> to continue: "
END
*
* Diplay line 22
*
MSG = MSG:MSGA
*
LOOP
*
IF ENTRY.MODE EQ ZERO THEN
PRINT @(ZERO,22):CLL:MSG:
INPUT RSP:
END ELSE RSP = "S"
*
IF RSP EQ "KILL" THEN
IF ENTRY.MODE NE ZERO OR BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5 THEN GOSUB UPDATE.FILE
GOTO FINISH
END
*
* Process Response
*
BEGIN CASE
*
CASE RSP EQ "S" OR (RSP EQ "P" AND NOT(BATCH.DEL.STATUS) AND NOT(BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R"))
**CASE RSP EQ "S" OR RSP EQ "P"
IF CNT.CSH$TILL.RECP.IMPRT EQ "I" THEN
FUNC = "T"; GOSUB IMPRINT.LINE; *
END
*
LST.SUFFIX.OLD = BATCH.LST; FUNC = "A"
IF LST.SUFFIX.OLD NE EMPTY THEN FUNC = "C"
*
BEGIN CASE
CASE NOT(BALANCED.TOTAL)
*@@@ OR (BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R")
*960225*DGH*CASE BATCH.TOTAL NE ENTERED.TOTAL
*960111*DGH*CASE BATCH.TOTAL NE (ENTERED.TOTAL + ADJUST.TOTAL)
LST.SUFFIX = "ERR"
CASE RSP EQ "S"
LST.SUFFIX = "OTH"
CASE TRUE
LST.SUFFIX = "REG"
END CASE
*
BATCH.LST = LST.SUFFIX
*
GOSUB UPDATE.FILE
*
IF LST.SUFFIX NE LST.SUFFIX.OLD THEN
GOSUB APPEND.TO.LIST
END
*
GOTO FINISH
*
CASE RSP EQ "D" AND NOT(BATCH.DEL.STATUS)
GOSUB DELETE.BATCH
*
END CASE
*
UNTIL RSP EQ EMPTY DO PRINT BELL: REPEAT
*
*
IF BATCH.DEL.STATUS OR BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN GOTO WHAT.NEXT
*
IF NOT(BALANCED.TOTAL) THEN GOTO WHAT.NEXT
*960225*DGH*IF BATCH.CLASS GE ONE THEN
*960225*DGH**@*IF BATCH.TOTAL NE ENTERED.TOTAL THEN GOTO WHAT.NEXT
*960225*DGH*END ELSE
*960111*DGH*IF BATCH.TOTAL NE (ENTERED.TOTAL + ADJUST.TOTAL) THEN GOTO WHAT.NEXT
*960225*DGH*END
*
*
GOSUB PRINT.BATCH
*
TMP.ENTRY.MODE = ENTRY.MODE
TMP.DEL.STATUS = BATCH.DEL.STATUS
GOSUB POST.BATCH
*
GOSUB UPDATE.FILE
*
!
*
FINISH: *
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
IF ENTRY.MODE EQ ZERO THEN GOTO START
*
RETURN; * To calling program
*
!!
*
!
*
EXTRACT.HEADER.DATA: *
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
RETURN
*
!
*
DELETE.BATCH: *
*
LOOP
PRINT @(ZERO,22):CLL:BELL:"Are you sure you want to delete the batch (Y/N)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
IF RSP EQ "N" THEN GOTO ENTRY.COMPLETED
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
*
* DELETE CAJ.FILE,BATCH.NUM
BATCH.DEL.STATUS = TRUE
*
GOSUB UPDATE.FILE
*
GOTO FINISH
*
!
*
APPEND.TO.LIST: *
*
CALL CASH.SUBR.LI.UPD(BATCH.NUM,XTR.ID.PREF,XTR.ID.FUNC,XTR.ID.SUFF,LST.SUFFIX,LST.SUFFIX.OLD,FUNC,ALL.FLAG)
*
RETURN
*
!
*
CHECK.BALANCE: *
*
IF BATCH.INP.SOURCE EQ "3" OR BATCH.INP.SOURCE EQ "5" THEN BATCH.TOTAL = ENTERED.TOTAL
*960111*DGH*IF BATCH.INP.SOURCE EQ "3" OR BATCH.INP.SOURCE EQ "5" THEN BATCH.TOTAL = (ENTERED.TOTAL + ADJUST.TOTAL)
*
IF ENTRY.MODE EQ ZERO THEN
PRINT @(69,LN.HDR.TOP + TWO):OCONV(ENTERED.TOTAL,"MR2ZM") "R#10":
PRINT @(69,LN.HDR.TOP + 3):OCONV(ADJUST.TOTAL,"MR2ZM") "R#10":
END
*
**MSG = " ":ITEM.COUNT - ONE:" item"; IF ITEM.COUNT - TWO THEN MSG = MSG:"s"
MSG = " "
*
IF BATCH.DEL.STATUS THEN
MSG = MSG:"DELETED!!! "
END
*
IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN
MSG = MSG:"ERROR! "
END
*
MSG = MSG:ITEM.COUNT:" item"; IF ITEM.COUNT - ONE THEN MSG = MSG:"s"
*
IF POST.DATE<ONE,ONE,ONE> THEN
MSG = MSG:" - Batch posted on ":OCONV(POST.DATE<ONE,ONE,ONE>,"D2"):" "
END
*
!
*
*960226*DGH*IF BATCH.CLASS EQ ONE THEN
DIFF = BATCH.TOTAL - ENTERED.TOTAL
*960226*DGH*END ELSE
*960111*DGH*DIFF = BATCH.TOTAL - (ENTERED.TOTAL + ADJUST.TOTAL)
*960226*DGH*DIFF = BATCH.TOTAL - (ENTERED.TOTAL + ADJUST.TOTAL)
*960226*DGH*END
*
IF BATCH.STATUS NE "P" AND BATCH.STATUS NE "Z" THEN
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN
*960225*DGH*IF BATCH.STATUS EQ "B" OR  BATCH.STATUS EQ "U" THEN
BATCH.STATUS = EMPTY
*960225*DGH*END
END
END
*
* Set Diff flag
IF DIFF THEN
*
BALANCED.TOTAL = FALSE
IF BATCH.STATUS EQ "B" OR BATCH.STATUS EQ EMPTY THEN BATCH.STATUS = "U"
*960225*DGH*MSG = MSG:" - Difference of ":OCONV(DIFF,"MR2M"):" "
MSG = MSG:" - Diff of ":OCONV(DIFF,"MR2M"):" "
END ELSE
*
BALANCED.TOTAL = TRUE
IF BATCH.STATUS EQ "U" OR BATCH.STATUS EQ EMPTY THEN BATCH.STATUS = "B"
*960225*DGH*MSG = MSG:" - Batch is in balance":" "
MSG = MSG:" - Batch is balanced":" "
*
END; * of DIFF / not DIFF
*
* Display Message
*
MSG = STR("*",40 - LEN(MSG) / TWO):MSG:STR("*",40)
IF ENTRY.MODE EQ ZERO THEN
PRINT @(ZERO,23):RVB:MSG "L#79":RVE:
END
*
*
RETURN
*
!
*
ADD.TRANS: *
*
*960225*DGH*LOCATE EMPTY IN CAJ SETTING ITEM.CURR THEN NULL ELSE ITEM.CURR = ONE
ITEM.COUNT = DCOUNT(CAJ,AM)
ITEM.CURR = ITEM.COUNT + ONE
*
PG = INT((ITEM.CURR + LN.MAX - ONE) / LN.MAX); IF PG NE CURR.PG THEN GOSUB DISPLAY.PAGE
LN = MOD(ITEM.CURR - ONE,LN.MAX) + LN.TOP
*960226*DGH*LN = MOD(ITEM.CURR,LN.MAX) + LN.TOP
IF ENTRY.MODE EQ ZERO THEN ACT.ID = EMPTY; FULL.ACT.ID = EMPTY
MORE.TRANS = EMPTY
*
LOOP
*
*960226*DGH*ITEM.COUNT = DCOUNT(CAJ,AM)
*960226*DGH*ITEM.CURR = ITEM.COUNT + ONE
*
GOSUB GET.ENTRIES
*
STAT = STAT + ZERO; IF STAT LT ZERO THEN RETURN
*
IF TRANS NE EMPTY THEN
*960312*DGH*IF TRANS NE EMPTY AND MORE.TRANS EQ EMPTY THEN
*
TRANS.TYPE = TRANS<ONE,TWO>
IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
MORE.TRANS<ONE,ONE,-ONE> = TRANS.TYPES<3,LOC>
*960312*DGH*MORE.TRANS = TRANS.TYPES<3,LOC> 
END
*
*960317*DGH*END; * of TRANS empty
*
LOOP
*
ADJ.TYPE = MORE.TRANS<ONE,ONE,ONE>; TMP = EMPTY
*
IF ADJ.TYPE NE EMPTY THEN
*
IF BATCH.CLASS NE ONE THEN
*960225*DGH*IF BATCH.CLASS EQ TWO THEN
LOCATE ADJ.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
ADJ.DESC = TRANS.TYPES<TWO,LOC>; TMP = ADJ.DESC
END ELSE ADJ.TYPE = EMPTY
END ELSE
LOCATE ADJ.TYPE IN TRANS.TYPES.ADJ<ONE> SETTING LOC THEN
ADJ.DESC = TRANS.TYPES.ADJ<TWO,LOC>; TMP = "a-":ADJ.DESC
END ELSE ADJ.TYPE = EMPTY
END; * of CLASS ~one/one
*
IF ADJ.TYPE NE EMPTY THEN
INS EMPTY BEFORE CAJ<ITEM.CURR + ONE>
CAJ<ITEM.CURR + ONE> = "!":TRANS<ONE,ONE>:VM:"!":MORE.TRANS<ONE,ONE,ONE>:VM:VM:TMP
*960226*DGH*ITEM.COUNT = ITEM.COUNT + ONE
END
*
END; * of ADJ.TYPE not empty
*
DEL MORE.TRANS<ONE,ONE,ONE>
*
WHILE ADJ.TYPE EQ EMPTY AND MORE.TRANS NE EMPTY DO REPEAT
*
* not(TRANS not empty or MORE.TRANS empty)
END ELSE
*
IF ACT.ID EQ EMPTY THEN MORE.TRANS = EMPTY
*
*960312*DGH*IF ACT.ID EQ EMPTY THEN MORE.TRANS = EMPTY ELSE
*960312*DGH**
*960312*DGH*DEL MORE.TRANS<ONE,ONE,ONE>
*960312*DGH**
*960312*DGH*IF MORE.TRANS<ONE,ONE,ONE> EQ EMPTY OR MORE.TRANS<ONE,ONE,ONE> EQ TRANS<ONE,TWO> THEN
*960312*DGH** clear more trans
*960312*DGH*MORE.TRANS = EMPTY
*960312*DGH*END ELSE
*960312*DGH** preload next trans line
*960312*DGH*INS EMPTY BEFORE CAJ<ITEM.CURR + ONE>
*960312*DGH*CAJ<ITEM.CURR + ONE> = "!":TRANS<ONE,ONE>:VM:"!":MORE.TRANS<ONE,ONE,ONE>
*960312*DGH**960226*DGH*ITEM.COUNT = ITEM.COUNT + ONE
*960312*DGH*END
*960317*DGH**
*960317*DGH*END; * of ACT.ID not empty
*
END; * of TRANS not.empty/empty or MORE.TRANS empty/not.empty
*
IF ACT.ID EQ EMPTY OR NOT(TRANS<ONE,3>) OR CAJ<ITEM.CURR> EQ EMPTY THEN
CAJ<ITEM.CURR> = EMPTY
DEL CAJ<ITEM.CURR>
ITEM.CURR = ITEM.CURR - ONE
*960226*DGH*ITEM.COUNT = ITEM.COUNT - ONE
IF ACT.ID EQ EMPTY THEN MORE.TRANS = EMPTY
PRINT @(ZERO,LN):CLL:
LN = LN - ONE
END
*
*860318*DGH*IF CAJ<ITEM.CURR> EQ EMPTY THEN
*860318*DGH*DEL CAJ<ITEM.CURR>
*860318*DGH*ITEM.CURR = ITEM.CURR - ONE
*860318*DGH**960226*DGH*ITEM.COUNT = ITEM.COUNT - ONE
*860318*DGH*END
*
WHILE (ACT.ID NE EMPTY OR MORE.TRANS NE EMPTY) AND STAT NE 999 AND ENTRY.MODE EQ ZERO DO
*
ITEM.CURR = ITEM.CURR + ONE
ITEM.COUNT = ITEM.COUNT + ONE
*960226*DGH*ADJ = TRUE
IF MORE.TRANS NE EMPTY THEN ADJ = TRUE
*
LN = LN + ONE
IF LN GT LN.BOT THEN
FOR LN = LN.TOP TO LN.BOT; PRINT @(ZERO,LN):CLL:; NEXT LN
LN = LN.TOP; PG = PG + ONE; CURR.PG = PG
END
*
GOSUB CHECK.BALANCE
*
REPEAT
*
* End of ADD.TRANS loop
*
ITEM.CURR = ITEM.CURR - ONE
ITEM.COUNT = DCOUNT(CAJ,AM)
*
PRINT @(ZERO,22):CLL:
*
GOSUB CHECK.BALANCE
*
***** POST
IF STAT NE 999 THEN
IF ENTRY.MODE NE ZERO THEN
TMP.ENTRY.MODE = ENTRY.MODE
TMP.DEL.STATUS = FALSE
GOSUB POST.BATCH
END
END
*****
*
RETURN
*
!
*
CHANGE.TRANS: *
*
ITEM.CURR = RSP
PG = INT((ITEM.CURR + LN.MAX - ONE) / LN.MAX); IF PG NE CURR.PG THEN GOSUB DISPLAY.PAGE
LN = MOD(ITEM.CURR - ONE,LN.MAX) + LN.TOP
*
LOOP
*
PRINT @(ZERO,22):CLL:"Enter D(elete line) or <cr> to change it: ":
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
*
***** UNPOST
TMP.ENTRY.MODE = TWO
TMP.DEL.STATUS = TRUE
GOSUB POST.BATCH
PRINT @(48,LN):" ":
***
*
IF RSP EQ "D" THEN
*
IF ENTRY.MODE EQ ZERO THEN
*
* ITEM.COUNT = ITEM.COUNT - ONE
TRANS = CAJ<ITEM.CURR>; DEL CAJ<ITEM.CURR>
*
ADJ = FALSE
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" THEN
*960225*DGH*IF TRANS<ONE,4>[ONE,TWO] = "a-" AND BATCH.CLASS EQ ONE THEN
ADJUST.TOTAL = ADJUST.TOTAL - TRANS<ONE,3>
ADJ = TRUE
IF BATCH.CLASS NE ONE THEN
ENTERED.TOTAL = ENTERED.TOTAL - TRANS<ONE,3>
END
END ELSE
ENTERED.TOTAL = ENTERED.TOTAL - TRANS<ONE,3>
ADJ = FALSE
END
*
* END ELSE
* ***** UNPOST
* TMP.ENTRY.MODE = ENTRY.MODE
* TMP.DEL.STATUS = TRUE
* GOSUB POST.BATCH
* ***
END; * of MODE 0 / not 0
*
GOSUB CHECK.BALANCE
*
*960225*DGH*LOCATE EMPTY IN CAJ SETTING ITEM.COUNT THEN ITEM.COUNT = ITEM.COUNT - ONE ELSE ITEM.COUNT = ZERO
*960225*DGH***LOCATE EMPTY IN CAJ SETTING ITEM.COUNT THEN NULL
ITEM.COUNT = DCOUNT(CAJ,AM)
*
GOSUB UPDATE.FILE
IF ENTRY.MODE EQ ZERO THEN GOSUB DISPLAY.PAGE
*
RETURN
*
END; * of RSP 'D'elete
*
UNTIL RSP EQ EMPTY DO PRINT BELL: REPEAT
*
GOSUB GET.ENTRIES
*
***** POST
IF ENTRY.MODE NE ZERO THEN
TMP.TWO = ENTRY.MODE
TMP.DEL.STATUS = FALSE
GOSUB POST.BATCH
END
*****
*
*960225*DGH*LOCATE EMPTY IN CAJ SETTING ITEM.COUNT THEN ITEM.COUNT = ITEM.COUNT - ONE
ITEM.COUNT = DCOUNT(CAJ,AM)
*
RETURN
*
!
*
PRINT.BATCH: *
*
GOSUB UPDATE.FILE
*
LPT.PG = 1; LPT.LN = 1; LPT.LN.MAX = 55
CALL TRANS.SUBR.PRINT(CAJ,CO.NAME,ACCTG.PERIOD,BATCH.HEADER,BATCH.STATUS.DESC,BATCH.NUM,POST.FL,BATCH.TOTAL.CHQ,BATCH.TOTAL.CRD,BATCH.TOTAL.CDC,BATCH.TOTAL.CSH,CSH.TYPE,CSH.TYPE.CURR,TITLE,TRANS.TYPES,BATCH.CLASS.CURR,LPT.DETAIL.FL,LPT.PMT.TYP.FL,LPT.FL,LPT.STAT,LPT.PG,LPT.LN,LPT.LN.MAX,MIN.DELINQ.AMT,MIN.DELINQ.STAT)
*
IF BATCH.STATUS EQ "E" THEN BATCH.STATUS = "R"
BATCH.LPT.DT = DATE()
BATCH.LPT.TM = TIME()
GOSUB UPDATE.FILE
*
RETURN
*
!
*
POST.BATCH: *
*
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN
IF TMP.ENTRY.MODE EQ ZERO THEN
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
PRINT RVB:STR("*",80):RVE:
END
*
POST.DATE = CONTROL.DT
POST.TIME = OCONV(TIME(),"MT")
*
IF CNT.CSH$TILL.RECP.IMPRT EQ "I" THEN
FUNC = "T"; GOSUB IMPRINT.LINE; *CHEQUE IMPRINTER TOTAL LINE..
END
*
*960226*DGH*TMP.ITEM.CURR = ITEM.COUNT
TMP.ITEM.CURR = ITEM.CURR
*
CALL TRANS.SUBR.POST(CAJ,CSH.TYPE,CSH.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,RUN.TRANS.SUB.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,MIN.DELINQ.STAT,MIN.DELINQ.STAT,BUS.DATE,BATCH.CLASS.CURR,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,TMP.DEL.STATUS,TMP.ENTRY.MODE,TMP.ITEM.CURR,BATCH.INP.SOURCE)
*
IF TMP.ENTRY.MODE EQ ZERO THEN
IF NOT(STAT) THEN BATCH.STATUS = "P" ELSE BATCH.STATUS = "E"
POSTED.BATCHES<-ONE> = BATCH.NUM
END
*
*
END
*
RETURN
*
!
*
LIST.BATCH: *
*
PG = ONE
LOOP GOSUB DISPLAY.PAGE UNTIL TRANS EQ EMPTY OR STAT DO
IF NOT(LIST.ALL) THEN
LOOP
PRINT @(ZERO,22):CLL:"Enter N(ext page) or <cr> to end listing: ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP EQ EMPTY THEN RETURN
UNTIL RSP EQ "N" DO PRINT BELL: REPEAT
END
PG = PG + ONE
REPEAT
RETURN
*
!
*
DISPLAY.PAGE: *
*
REDISP = 99
*
IF NOT(SYSTEM(11)) THEN
FOR LN = LN.TOP TO LN.BOT; PRINT @(ZERO,LN):CLL:; NEXT LN
END
LN = LN.TOP; DISP.COUNT = (PG - ONE) * LN.MAX + ONE; BELL.CN = ZERO
*
LOOP TRANS = CAJ<DISP.COUNT> UNTIL TRANS EQ EMPTY OR LN GT LN.BOT DO
*
PRINT @(ZERO,LN):DISP.COUNT "R#3":" ":
IF TRANS<ONE,5> NE EMPTY THEN TRANS<ONE,ONE> = "!":TRANS<ONE,5> ELSE TRANS<ONE,ONE> = "!":TRANS<ONE,ONE> 
*
GOSUB GET.ACT.ID
IF NOT(REDISP) THEN
STAT = STAT + ZERO; IF STAT LT ZERO THEN STAT = 999
IF STAT THEN RETURN
END
*
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
PRINT @(35,LN):TRANS.TYPE "L#2":@(39,LN):OCONV(TRANS<1,3>,"MR2ZM") "R#9":
IF TRANS<1,10> THEN PRINT RVB:"*":RVE:
PRINT @(49,LN):
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC ELSE NULL
*
TMP = TRIM(TRANS<ONE,11>:" ":TRANS<ONE,4,ONE>:" ":TRANS<ONE,4,TWO>:" ":TRANS<ONE,7>)
IF LEN(TMP) THEN PRINT TMP "L#30": ELSE PRINT TRANS.TYPES<TWO,LOC> "L#30":
*
DISP.COUNT = DISP.COUNT + ONE
LN = LN + ONE
*
REPEAT
*
CURR.PG = PG
REDISP = FALSE
*
RETURN
*
!
*
DISPLAY.HEADER.DATA: *
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.HDR.FG
*
RETURN
*
!
*
GET.DEFAULT.TYPE: *
*
* IF BATCH.CLASS EQ TWO THEN DEFAULT.TYPE = "!":TRANS.TYPES<ONE,ONE>
*
CALL INPUT.DATA(DEFAULT.TYPE,41,LN.HDR.TOP + ONE,TWO,ONE,"","LF":SVM:"0":SVM:"2":VM:"EQ":SVM:"@":TRANS.TYPES<ONE>:"@","",RSP,STAT)
*
IF STAT THEN RETURN
*
LOCATE DEFAULT.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
PRINT @(41,LN.HDR.TOP + ONE):TRANS.TYPES<TWO,LOC> "L#20":
END
*
RETURN
*
!
*
GET.HEADER.DATA: *
*
CALL CASH.SUBR.ENTRY.HDR(LN.TOP,LN.BOT,LN.HDR.TOP,ENTRY.MODE,RECP.IMPRT.MODE,CSH.TYPE,CSH.TYPE.CURR,BATCH.CLASS.CURR,BATCH.SOURCE.CURR,ALLOWED.MODE,BATCH.TOTAL,DOLLAR.EDIT,BUS.DATE,EFF.DATE,OPERATOR,CONTROL.DT,CURR.ACCTG.DATE,FROM.LIST,DEFAULT.TYPE,TRANS.TYPES,OPERATORS)
*
RETURN
*
!
*
GET.ENTRIES: *
*
TRANS = CAJ<ITEM.CURR>
*
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" THEN
*960225*DGH*IF TRANS<ONE,4>[ONE,TWO] EQ "a-" THEN ADJ = TRUE ELSE ADJ = FALSE
*960225*DGH*IF TRANS<ONE,4>[ONE,TWO] EQ "a-" AND BATCH.CLASS EQ ONE THEN
ADJ = TRUE
END ELSE
ADJ = FALSE
END
*
PRINT @(ZERO,LN):ITEM.CURR "R#3":" ":
BELL.CN = ZERO
*
FOR NUM = ONE TO 4
*
ON NUM GOSUB GET.ACT.ID,GET.TRANS.TYPE,GET.AMOUNT,GET.DESCRIP
*
*960317*DGH*v
IF NUM EQ ONE AND ACT.ID EQ EMPTY THEN RETURN
**IF NUM EQ 3 AND TRANS<ONE,3> EQ ZERO THEN RETURN
*
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN NUM = NUM - ONE; STAT = FALSE ELSE
NUM = NUM - TWO; IF NUM LT ZERO THEN NUM = ZERO
END
END
*
* IF NOT(BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5) AND NUM LE ONE AND (ACT.ID EQ EMPTY OR STAT) THEN RETURN ELSE STAT = FALSE
*
*960317*DGH*IF ENTRY.MODE EQ ZERO AND NUM LE ONE AND (ACT.ID EQ EMPTY OR STAT) THEN
*960317*DGH*RETURN
*960317*DGH*END ELSE
*960317*DGH*STAT = FALSE
*960317*DGH*END
*
NEXT NUM
*
!
*
STAT = STAT + ZERO; IF STAT LT ZERO THEN STAT = FALSE
*
CAJ<ITEM.CURR> = TRANS
*
IF CNT.CSH$TILL.RECP.IMPRT EQ "I" THEN
FUNC = "D"; GOSUB IMPRINT.LINE; *CHEQUE IMPRINTER DETAIL LINE..
END
*
IF (CNT.CSH$TILL.RECP.IMPRT EQ "R" OR RECP.IMPRT.MODE EQ "R") AND PORT.CC THEN
GOSUB PRINT.RECEIPT
IF STAT THEN RETURN
END
*
GOSUB UPDATE.FILE
*
RETURN
*
!
*
GET.ACT.ID: *
*
PREFIX = EMPTY
IF TRANS<ONE,5> NE EMPTY THEN ORIG.ACT.ID = TRANS<ONE,5> ELSE ORIG.ACT.ID = TRANS<ONE,ONE>
*
IF ENTRY.MODE EQ ZERO THEN
*
LOOP
*
LOOP
*
*960318*DGH*IF ORIG.ACT.ID[ONE,ONE] EQ "!" THEN ORIG.ACT.ID = ORIG.ACT.ID[TWO,99999]
*
STAT = STAT + ZERO; IF STAT LT ZERO THEN STAT = FALSE
CALL INPUT.DATA(TRANS,5,LN,9,"1,1","","OP":VM:"LF":SVM:"0":SVM:"7":VM:"MA":SVM:"7N":SVM:"6N'#'":SVM:"6N'+'":SVM:"6N'.'":SVM:"1A8N","",RSP,STAT)
IF STAT THEN RETURN
*
IF ENTRY.MODE EQ ZERO OR ACT.ID EQ EMPTY THEN
FULL.ACT.ID = TRANS<ONE,ONE>; ACT.ID = FULL.ACT.ID[ONE,6]
IF ACT.ID EQ EMPTY AND ORIG.ACT.ID EQ EMPTY THEN RETURN
END ELSE ORIG.ACT.ID = ACT.ID
*
PREFIX = ACT.ID[ONE,ONE]
IF PREFIX GT "9" THEN
MATREAD AAX FROM AAX.FILE,ACT.ID ELSE MAT AAX = EMPTY
TRANS<ONE,5> = TRANS<ONE,ONE>; TRANS<ONE,ONE> = AAX$ACT.ID; ENTERED.CD = EMPTY; CD = EMPTY
FULL.ACT.ID = TRANS<ONE,ONE>; ACT.ID = FULL.ACT.ID[ONE,6]
ENTERED.CD = FULL.ACT.ID[7,ONE]
END ELSE
ENTERED.CD = FULL.ACT.ID[7,ONE]; ACT.ID = FULL.ACT.ID[ONE,6]
END
CALL MOD11.DIGIT(ACT.ID,CD)
IF ENTERED.CD EQ "#" OR ENTERED.CD EQ "." OR ENTERED.CD EQ "+" THEN ENTERED.CD = CD
*
CONT = TRUE
IF CD EQ ENTERED.CD OR PREFIX GT 9 THEN CONT = FALSE
IF CONT AND BELL.CN LT 3 THEN PRINT BELL:; BELL.CN = BELL.CN + ONE
*
UNTIL NOT(CONT) OR REDISP OR BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" DO TRANS<ONE,ONE> = ORIG.ACT.ID REPEAT
*
CONT = TRUE
MATREAD ACT FROM ACT.FILE,ACT.ID THEN
LAST.NAME = FIELD(ACT$CUS.NAME,"*",ONE)
FIRST.NAME = FIELD(ACT$CUS.NAME,"*",TWO)
FULL.NAME = TRIM(FIRST.NAME:" ":LAST.NAME)
IF LEN(FULL.NAME) GT 19 THEN FULL.NAME = TRIM(FIRST.NAME[ONE,ONE]:" ":LAST.NAME)
CONT = FALSE
END ELSE
MAT ACT = EMPTY
FULL.NAME = "Account is missing!"
IF BELL.CN LT 3 THEN PRINT BELL:; BELL.CN = BELL.CN + ONE
IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" OR ORIG.ACT.ID[ONE,ONE] EQ "!" THEN CONT = FALSE
END
*
IF ORIG.ACT.ID[ONE,ONE] EQ "!" AND ACT.ID EQ EMPTY THEN ACT.ID = "!"
*
WHILE NOT(REDISP) AND (ACT.ID EQ EMPTY OR CONT) DO PRINT BELL:; TRANS<ONE,ONE> = ORIG.ACT.ID REPEAT
*
END ELSE
STAT = STAT + ZERO; IF STAT LT ZERO THEN RETURN
CALL MOD11.DIGIT(ACT.ID,CD)
FULL.ACT.ID = ACT.ID:CD
LAST.NAME = FIELD(ACT$CUS.NAME,"*",ONE)
FIRST.NAME = FIELD(ACT$CUS.NAME,"*",TWO)
FULL.NAME = TRIM(FIRST.NAME:" ":LAST.NAME)
IF LEN(FULL.NAME) GT 19 THEN FULL.NAME = TRIM(FIRST.NAME[ONE,ONE]:" ":LAST.NAME)
CONT = FALSE
PRINT @(5,LN):FULL.ACT.ID "L#9":
IF TRANS<ONE,ONE> EQ EMPTY THEN TRANS<ONE,ONE> = FULL.ACT.ID
* IF TRANS<ONE,5> EQ EMPTY THEN TRANS<ONE,5> = FULL.ACT.ID
END; * Of entry MODE 0
*
IF ACT$STAT EQ "C" THEN TRANS<ONE,6> = "** Collection Account **" ELSE
IF ACT$BALANCE GE MIN.DELINQ.AMT AND ACT$CREDIT.STATUS GE MIN.DELINQ.STAT THEN
TRANS<ONE,6> = STR("*",(ACT$CREDIT.STATUS - MIN.DELINQ.STAT) * 3):" Delinquent Account ":STR("*",(ACT$CREDIT.STATUS - MIN.DELINQ.STAT) * 3)
END
END
PRINT @(15,LN):FULL.NAME "L#19":
*
RETURN
*
!
*
GET.TRANS.TYPE: *
*
IF BATCH.CLASS EQ ONE AND NOT(ADJ OR BATCH.INP.SOURCE EQ 3) THEN
STAT = STAT + ZERO; IF STAT LT ZERO THEN RETURN
TRANS<ONE,TWO> = "!":DEFAULT.TYPE
END ELSE
STAT = STAT + ZERO; IF STAT LT ZERO THEN STAT = FALSE
IF TRANS<ONE,TWO> = EMPTY THEN TRANS<ONE,TWO> = DEFAULT.TYPE
END
*
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" THEN
*960225*DGH*IF TRANS<ONE,4>[ONE,TWO] EQ "a-" AND BATCH.CLASS EQ ONE THEN
TMP = TRANS.TYPES.ADJ<ONE>; ADJ = TRUE
END ELSE
TMP = TRANS.TYPES<ONE>; ADJ = FALSE
END
*
CALL INPUT.DATA(TRANS,35,LN,TWO,"1,2",EMPTY,"OP":VM:"LF":SVM:"0":SVM:"2":VM:"EQ":SVM:"@":TMP:"@",EMPTY,RSP,STAT)
*
IF STAT THEN RETURN
*
IF TRANS<ONE,TWO> = DEFAULT.TYPE THEN TRANS<ONE,TWO> = ""
*
RETURN
*
!
*
GET.AMOUNT: *
*
STAT = STAT + ZERO; IF STAT LT ZERO THEN STAT = FALSE
ORIG.AMT = TRANS<ONE,3>
*
CALL INPUT.DATA(TRANS,39,LN,"R9","1,3","MR2ZM",DOLLAR.EDIT,EMPTY,RSP,STAT)
*
IF STAT THEN RETURN
*
*960226*DGH*IF ADJ THEN ADJUST.TOTAL = ADJUST.TOTAL + TRANS<ONE,3> - ORIG.AMT ELSE
*960226*DGH*ENTERED.TOTAL = ENTERED.TOTAL + TRANS<ONE,3> - ORIG.AMT
*960226*DGH*END
IF ADJ THEN
ADJUST.TOTAL = ADJUST.TOTAL + TRANS<ONE,3> - ORIG.AMT
IF BATCH.CLASS NE ONE THEN
ENTERED.TOTAL = ENTERED.TOTAL + TRANS<ONE,3> - ORIG.AMT
END
END ELSE
ENTERED.TOTAL = ENTERED.TOTAL + TRANS<ONE,3> - ORIG.AMT
END
*
GOSUB CHECK.BALANCE
*
RETURN
*
!
*
GET.DESCRIP: *
*
DESC = TRANS<ONE,4>; INPUT.DESC = ORIG.INPUT.DESC
*
IF DESC EQ EMPTY THEN
DEF.DESC = TRANS<ONE,TWO>; IF DEF.DESC EQ EMPTY THEN DEF.DESC = DEFAULT.TYPE
*
LOCATE DEF.DESC IN TRANS.TYPES<ONE> SETTING LOC THEN
DEF.DESC = TRANS.TYPES<TWO,LOC>; STD.DESC = DEF.DESC; INPUT.DESC = TRANS.TYPES<5,LOC>
END ELSE STD.DESC = EMPTY
*
END ELSE
STD.DESC = EMPTY; DEF.DESC = EMPTY
TMP = TRIM(TRANS<ONE,11>:" ":TRANS<ONE,4,ONE>:" ":TRANS<ONE,4,TWO>:" ":TRANS<ONE,7>:" ":TRANS<ONE,6>)
PRINT @(ZERO,21):CLL:"Description: ":
IF LEN(TMP) THEN PRINT TMP "L#60": ELSE PRINT TRANS.TYPES<TWO,LOC> "L#60":
END
*
* IF BATCH.CLASS NE ONE THEN INPUT.DESC = "Y"
*
ADJ = FALSE
IF DESC[ONE,TWO] EQ "a-"  OR INPUT.DESC NE "Y" THEN
ADJ = TRUE
PRINT @(49,LN):DESC "L#30":
RETURN
END
*
SC = ONE
*
LOOP
*
IF SC GT MAX.DESC THEN
IF MAX.DESC GT TWO THEN
PRINT @(49,LN):CLL:"Enter <cr> to end ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999
IF RSP EQ "^" THEN STAT = -ONE
END
END ELSE
*
STAT = STAT + ZERO; IF STAT LT ZERO THEN STAT = FALSE
CALL INPUT.DATA(DESC,49,LN,DESC.LEN,"1,1,":SC,EMPTY,"DF":SVM:DEF.DESC,EMPTY,RSP,STAT)
END
*
STAT = STAT + ZERO; IF STAT LT ZERO THEN
* SC = SC - TWO; IF SC LT ZERO THEN SC = ZERO
SC = SC - TWO; IF SC LT ZERO THEN RETURN
END ELSE IF LEN(RSP) AND RSP NE DEF.DESC THEN
IF INDEX("*CH*CC*CD*CA*","*":RSP[ONE,TWO]:"*",ONE) OR NUM(RSP) THEN
IF NUM(RSP) THEN RSP = "CH":RSP
TRANS<ONE,11> = RSP
DESC<ONE,ONE,SC> = TRANS<ONE,4,SC>
*DESC<ONE,ONE,SC> = EMPTY
SC = SC - ONE
END
END
*
UNTIL DESC EQ STD.DESC OR RSP EQ EMPTY OR SC GE MAX.DESC OR STAT EQ 999 DO
*
PRINT @(ZERO,21):CLL:"Description: ":TRIM(TRANS<ONE,11>:" ":DESC<ONE,ONE,ONE>:" ":DESC<ONE,ONE,TWO>)[ONE,60]:
*
SC = SC + ONE
*
REPEAT
*
IF NOT(STAT) THEN
IF DESC NE STD.DESC THEN TRANS<ONE,4> = DESC
PRINT @(49,LN):
TMP = TRIM(TRANS<ONE,11>:" ":TRANS<ONE,4,ONE>:" ":TRANS<ONE,4,TWO>:" ":TRANS<ONE,7>:" ":TRANS<ONE,6>)
IF LEN(TMP) THEN PRINT TMP "L#30": ELSE PRINT TRANS.TYPES<TWO,LOC> "L#30":
END
*
RETURN
*
!
*
PRINT.RECEIPT: *
*
TMP = TRANS<ONE,3>
IF ADJ THEN TMP = -TMP
PAYMENT.TYPE = TRANS<ONE,2>
CALL CASH.SUBR.PRINT.RECEIPT(MAT CNT.CSH,CNT.CSH.ID,PAYMENT.TYPE,TMP,STD.DESC,PORT.CC)
*
RETURN
*
!
*
IMPRINT.LINE: *
*
CALL CASH.SUBR.IMPRINT(BATCH.NUM,DEFAULT.TYPE,ACT.ID,CD,TRANS,ENTERED.TOTAL,FUNC,STAT)
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
!
END
~CASH.SUBR.ENTRY.HDR~
SUBROUTINE CASH.SUBR.ENTRY.HDR(LN.TOP,LN.BOT,LN.HDR.TOP,ENTRY.MODE,RECP.IMPRT.MODE,CSH.TYPE,CSH.TYPE.CURR,BATCH.CLASS.CURR,BATCH.SOURCE.CURR,ALLOWED.MODE,BATCH.TOTAL,DOLLAR.EDIT,BUS.DATE,EFF.DATE,OPERATOR,CONTROL.DT,CURR.ACCTG.DATE,FROM.LIST,DEFAULT.TYPE,TRANS.TYPES,OPERATORS)
*ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG
*
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
* AUTHOR:          DAVID STERN - AXION
*
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
*  
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Billings entry
*
*     Sources
*                  0 = CASH.ENTRY
*                  3 = Counter Cash
*                  4 = Lock Box Trans
*                  5 = Pay-Per-View Charges
*
*                  See list post program
*
*   Entry modes
*                  0 = From Cash.Entry
*                  1 = From Genie
*
*
* DATE WRITTEN:    DD MMM 83
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
*                  1993       DGH          Pay-Per-View, Cou. Ca.& Lst Pro
*                   1992      DGH         Counter Cash & list processing
*                   1991      DGH         Lock Box & List Processing
*                  26-JAN-88   HH   Cr. Status not updated for a 'Late
*                                   Notice' trans. unless Cr. Status is
*                                   less than Min. Delinq. criteria.
*                  01-AUG-88   HH   TRANS VAL 5 = Old Account Number
*                  24-NOV-88   HH   TRANS VAL 6 = 'Collection Account'
*                                   If active & updated balance # 0
*                                   then:
*                                   TRANS VAL 6 = BALANCE BILL.FREQS
*
!  
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
$INCLUDE IBP ACG.EQUATES
$INCLUDE IBP SAVE.ACG.EQUATES
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP EFT.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
!
*
GOSUB GET.HEADER.DATA; * : *
*
!
*
FINISH: *
*
*
RETURN; * To calling program
*
!
*
EXTRACT.HEADER.DATA: *
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
RETURN
*
!
*
DISPLAY.HEADER.DATA: *
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.HDR.FG
*
RETURN
*
!
*
GET.HEADER.DATA: *
*
FOR NUM = ONE TO 5
ON NUM GOSUB GET.DEFAULT.TYPE,GET.BATCH.TOTAL,GET.BUS.DATE,GET.EFF.DATE,GET.OPERATOR; * : *
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN NUM = NUM - ONE ELSE
NUM = NUM - TWO; IF NUM LT ZERO THEN RETURN
END
STAT = FALSE
END
NEXT NUM
RETURN
*
!
*
GET.DEFAULT.TYPE: *
*
* IF BATCH.CLASS.CURR EQ TWO THEN DEFAULT.TYPE = "!":TRANS.TYPES<ONE,ONE>
CALL INPUT.DATA(DEFAULT.TYPE,41,LN.HDR.TOP + ONE,TWO,ONE,"","LF":SVM:"0":SVM:"2":VM:"EQ":SVM:"@":TRANS.TYPES<ONE>:"@","",RSP,STAT)
IF STAT THEN RETURN
LOCATE DEFAULT.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN PRINT @(41,LN.HDR.TOP + ONE):TRANS.TYPES<TWO,LOC> "L#20":
RETURN
*
!
*
GET.BATCH.TOTAL: *
*
CALL INPUT.DATA(BATCH.TOTAL,69,LN.HDR.TOP + ONE,"R10",ONE,"MR2ZM",DOLLAR.EDIT,EMPTY,RSP,STAT)
IF STAT THEN RETURN
RETURN
*
!
*
GET.BUS.DATE: *
*
IF BUS.DATE EQ EMPTY THEN BUS.DATE = CONTROL.DT
LOOP
CALL INPUT.DATA(BUS.DATE,10,LN.HDR.TOP + TWO,9,ONE,"D2","DT",EMPTY,RSP,STAT)
IF STAT THEN RETURN
WHILE BUS.DATE GT CURR.ACCTG.DATE DO BUS.DATE = CURR.ACCTG.DATE REPEAT
RETURN
*
!
*
GET.EFF.DATE: *
*
EFF.DATE = BUS.DATE
RETURN
*
!
*
GET.OPERATOR: *
*
CALL INPUT.DATA(OPERATOR,41,LN.HDR.TOP + TWO,5,ONE,EMPTY,"EQ":SVM:"@":OPERATORS<ONE>:"@",EMPTY,RSP,STAT)
IF STAT THEN RETURN
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
END
~CASH.SUBR.ENTRY.INIT~
SUBROUTINE CASH.SUBR.ENTRY.INIT(ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*VERSION 1.0
*
*CHANGED,MAX.DESC,DESC.LEN,INPUT.DESC,BELL.CN,LIST.ALL,
*LN.MAX,LN.BOT,LN.TOP,CURR.PG
*PORT.CC,USER.VALID,MAT CNT.CSH
*
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Billings entry
*
*     Sources
*                  0 = CASH.ENTRY
*                  3 = Counter Cash
*                  4 = Lock Box Trans
*                  5 = Pay-Per-View Charges
*
*                  See list post program
*
*   Entry modes
*                  0 = From Cash.Entry
*                  1 = From Genie
*
*
* DATE WRITTEN:    DD MMM 83
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
READ ALL.FLAG FROM CNT.FILE,"ALL.FLAG" ELSE ALL.FLAG = TRUE
*
MAT CNT.CSH = EMPTY
*
!
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*CNT.CSH.ID,MAT CNT.CSH,STAT
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.CNTRL
*FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,STAT,AUTO.RUN,PHAN.RUN,
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
* MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR,STAT
*
!
*
FINISH: *
*
RETURN; * To calling program
*
END
~CASH.SUBR.IMPRINT~
SUBROUTINE CASH.SUBR.IMPRINT(BATCH.NUM,DEFAULT.TYPE,ACT.ID,CD,TRANS,ENTERED.TOTAL,FUNC,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
*
IF FUNC EQ "H" THEN GOSUB IMPRINT.HEADER ELSE
IF FUNC EQ "D" THEN GOSUB IMPRINT.DETAIL ELSE
IF FUNC EQ "T" THEN GOSUB IMPRINT.TOTAL ELSE
PRINT CLB:BELL:"Imprinting function error! Enter <cr> . . . ":; INPUT TMP:
STAT = 690
END
END
END
GOTO FINISH
*
!
*
$INCLUDE IBP.CASH CASH.INCL.IMPRINT
*
!
*
FINISH: *
*
RETURN
END
~CASH.SUBR.INIT~
SUBROUTINE CASH.SUBR.ENTRY(LN.TOP,LN.BOT,LN.HDR.TOP,ENTRY.MODE,RECP.IMPRT.MODE,CSH.TYPE,CSH.TYPE.CURR,BATCH.CLASS.CURR,BATCH.SOURCE.CURR,ALLOWED.MODE,DOLLAR.EDIT,FROM.LIST,PHAN.RUN)
CAJ.FILE,COM.FILE,ATR.FLAG,ACG.FLAG,ACT.FLAG,
MAX.DESC,DESC.LEN,INPUT.DESC,BELL.CN,LIST.ALL,
LN.BOT,LN.TOP,LN.MAX,CURR.PG,
PORT.CC,USER.VALID,MAT CNT.CSH,
*CNT.CSH.ID,MAT CNT.CSH,STAT
*FROM.LIST,BATCH.CLASS.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,STAT,AUTO.RUN,PHANTOM.RUN,
* MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR,STAT
*ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG
**********************
*
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Billings entry
*
*     Sources
*                  0 = CASH.ENTRY
*                  3 = Counter Cash
*                  4 = Lock Box Trans
*                  5 = Pay-Per-View Charges
*
*                  See list post program
*
*   Entry modes
*                  0 = From Cash.Entry
*                  1 = From Genie
*
*
* DATE WRITTEN:    DD MMM 83
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
*                  26-JAN-88   HH   Cr. Status not updated for a 'Late
*                                   Notice' trans. unless Cr. Status is
*                                   less than Min. Delinq. criteria.
*                  01-AUG-88   HH   TRANS VAL 5 = Old Account Number
*                  24-NOV-88   HH   TRANS VAL 6 = 'Collection Account'
*                                   If active & updated balance # 0
*                                   then:
*                                   TRANS VAL 6 = BALANCE BILL.FREQS
!  
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP ACT.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
*
CHANGED = TRUE
* MAX.DESC = ONE; DESC.LEN = 5; INPUT.DESC = "N"
MAX.DESC = 2; DESC.LEN = 30; INPUT.DESC = "Y"
BELL.CN = ZERO; LIST.ALL = FALSE
LN.MAX = LN.BOT - LN.TOP + ONE; CURR.PG = ONE
PORT.CC = FALSE; USER.VALID = FALSE
MAT CNT.CSH = EMPTY
*
!
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
$INCLUDE IBP SYS.INCL.SCR.CO
*
RETURN; * To calling program
*
END
~CASH.SUBR.LI.UPD~
SUBROUTINE CASH.SUBR.LI.UPD(BATCH.NUM,XTR.ID.PREF,XTR.ID.FUNC,XTR.ID.SUFF,LST.SUFFIX,LST.SUFFIX.OLD,FUNC,ALL.FLAG)
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.LISTS
*
!
*
IF (FUNC EQ "D" OR FUNC EQ "C") AND LST.SUFFIX.OLD NE EMPTY THEN
*
BEGIN CASE
*
CASE LST.SUFFIX.OLD EQ "REG"
LOCATE BATCH.NUM IN XTR.POST.REG SETTING XTR.LOC THEN
DEL XTR.POST.REG<XTR.LOC>
END ELSE NULL
*
CASE LST.SUFFIX.OLD EQ "ERR"
LOCATE BATCH.NUM IN XTR.POST.ERR SETTING XTR.LOC THEN
DEL XTR.POST.ERR<XTR.LOC>
END ELSE NULL
*
CASE LST.SUFFIX.OLD EQ "OTH"
LOCATE BATCH.NUM IN XTR.POST.OTH SETTING XTR.LOC THEN
DEL XTR.POST.OTH<XTR.LOC>
END ELSE NULL
*
CASE TRUE
* ERROR
NULL
*
END CASE
*
END
*
!
*
IF (FUNC EQ "A" OR FUNC EQ "C") AND LST.SUFFIX NE EMPTY THEN
*
BEGIN CASE
*
CASE LST.SUFFIX EQ "REG"
LOCATE BATCH.NUM IN XTR.POST.REG SETTING XTR.LOC ELSE
XTR.POST.REG<-ONE> = BATCH.NUM
END
*
CASE LST.SUFFIX EQ "ERR"
LOCATE BATCH.NUM IN XTR.POST.ERR SETTING XTR.LOC ELSE
XTR.POST.ERR<-ONE> = BATCH.NUM
END
*
CASE LST.SUFFIX EQ "OTH"
LOCATE BATCH.NUM IN XTR.POST.OTH SETTING XTR.LOC ELSE
XTR.POST.OTH<-ONE> = BATCH.NUM
END
*
CASE TRUE
* ERROR
NULL
*
END CASE
*
END
*
!
*
$INCLUDE IBP.CASH CASH.INCL.UPD.LISTS
*
RETURN
~CASH.SUBR.LIST.LOAD~
SUBROUTINE CASH.SUBR.LIST.LOAD(BATCH.CLASS.SEL,BATCH.SOURCE.SEL,LIST.TO.PROC)
* VERSION: 9304 1.0
EQU VS TO " (R:1.0)"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1993              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
* DESCRIPTION:     THIS PROGRAM PROCESSES THE XTR BATCHES
*                  FROM THE ???.POST CONTROL ITEM.
*  
* DATE WRITTEN:    22 APR 93
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
* BATCH.CLASS.SEL:
* 0 Regular Adjustments (ADJ)
* 1 Regular Payments    (PMT)
* 2 Regular Deposits    (DEP)
* 3 Special Billing     (BIL)
* 6 All Batch Types
*
* BATCH.SOURCE.SEL:
* 0 Cash.or.Adj Entry    (REG)
* 3 Counter Cash         (CTR)
* 4 Lockbox Transactions (XTR)
* 5 Pay-Per-View Charges (BIL)
* 6 All batch sources
*
BATCH.CLASS.TMP = BATCH.CLASS.SEL
BATCH.SOURCE.TMP = BATCH.SOURCE.SEL
*
! Main loop
*
MAIN.LOOP: *
*
! Loop for all types processing
*
LOOP WHILE LEN(BATCH.SOURCE.TMP) DO
*
BATCH.SOURCE.CURR = BATCH.SOURCE.TMP[ONE,ONE]
BATCH.SOURCE.TMP = BATCH.SOURCE.TMP[TWO,9999]
BATCH.CLASS.TMP = BATCH.CLASS.SEL
*
LOOP WHILE LEN(BATCH.CLASS.TMP) DO
*
BATCH.CLASS.CURR = BATCH.CLASS.TMP[ONE,ONE]
BATCH.CLASS.TMP = BATCH.CLASS.TMP[TWO,9999]
*
! Process type of run
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
*
IF STAT THEN
*
IF NOT(PHAN.RUN) THEN
PRINT CLB:"Error in ":ACCT:" on type ":BATCH.CLASS.CURR:BATCH.SOURCE.CURR:" ":XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF:". Error #: ":STAT:
END
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO TWO UNTIL SYSTEM(11)
* FOR TMP = ONE TO TWO; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
STAT = FALSE
*
END; * of STAT
*
*
! Read List info
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.LISTS
*
! Loop for class of list (regular or errors)
*
* 2 Cycles for balanced and error batches
*
FOR XTR.TYPE.CN = ONE TO CLASS.CN.MAX
*
* Read XTR Post record
*
IF XTR.TYPE.CN EQ ONE THEN
XTR.ID.SUFF = "REG"
LIST.CURR.PROC.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.CURR.PROC = XTR.PROC.REG
RUN.CLASS = "REGULAR"
END ELSE IF XTR.TYPE.CN EQ TWO THEN
XTR.ID.SUFF = "ERR"
LIST.CURR.PROC.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.CURR.PROC = XTR.PROC.ERR
RUN.CLASS = "ERRORS"
END ELSE
XTR.ID.SUFF = "OTH"
LIST.CURR.PROC.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.CURR.PROC = XTR.PROC.OTH
RUN.CLASS = "OTHER"
END
*
! Process list
IF LIST.CURR.PROC EQ EMPTY THEN
*
IF NOT(PHAN.RUN) THEN
PRINT CLB:"There are no ":BATCH.CLASS.CURR.DESC:", type ":RUN.CLASS:" to post.":
END
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
FOR TMP = ONE TO 3
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
STAT = 200
*
END; * of LIST empty
*
! Loop thru batches
*
XTR.CN = ONE
XTR.CN.MAX = DCOUNT(LIST.CURR.PROC,AM)
*
LOOP
*
* Read next batch
*
CONT = TRUE
BATCH.NUM = LIST.CURR.PROC<XTR.CN>
IF (BATCH.NUM EQ EMPTY AND NOT(LEN(LIST.CURR.PROC) AND XTR.CN LE XTR.CN.MAX)) THEN CONT = FALSE
*
WHILE CONT AND NOT(STAT) DO
*
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 AND NOT(STAT) THEN STAT = LCK.STAT
WHILE NOT(STAT) AND LCK.STAT DO REPEAT
*
READ CAJ FROM CAJ.FILE,BATCH.NUM THEN
*
!
*
* Extract Header
*
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
! Validate Batch
*
VALID = TRUE
*
IF DT.OPEN.SEL NE "ALL" AND BUS.DATE NE EMPTY THEN
LOCATE BUS.DATE IN DT.OPEN.SEL<ONE> BY "AR" SETTING DT.OPEN.LOC ELSE VALID = FALSE
END
*
IF PORT.SEL NE "ALL" AND BATCH.TILL NE EMPTY THEN
LOCATE BATCH.TILL IN PORT.SEL<ONE> BY "AR" SETTING PORT.LOC ELSE VALID = FALSE
END
*
IF USER.VALID.SEL NE "ALL" AND OPERATOR NE EMPTY THEN
LOCATE OPERATOR IN USER.VALID.SEL<ONE> BY "AL" SETTING USER.VALID.LOC ELSE VALID = FALSE
END
*
IF VALID THEN
*
LIST.TO.PROC<-ONE> = BATCH.NUM
*
END; * Of valid
*
!
*
END ELSE
CAJ = EMPTY
XTR.CN = XTR.CN + ONE
END
*
CALL UNLOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE)
*
!
*
* Check status
*
*  will clear STAT set by a bad batch or lock here
*
IF STAT EQ 200 THEN
*
IF NOT(PHAN.RUN) THEN
PRINT CLB:"Error in ":ACCT:" on batch ":BATCH.NUM:" status ":BATCH.STATUS:". Error #: ":STAT:
END
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO TWO UNTIL SYSTEM(11)
* FOR TMP = ONE TO TWO; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
STAT = FALSE
*
END; * of STAT
*
! Next batch
*
REPEAT
*
! Next type of list REG/ERR/OTH
*
NEXT XTR.TYPE.CN
*
! Unlock lists
*
$INCLUDE IBP.CASH CASH.INCL.RELS.LISTS
*
! Next Class of Transaction
*
REPEAT
*
! Next Source of Transaction
*
REPEAT
*
! End of program
*
FINISH: *
*
$INCLUDE IBP.CASH CASH.INCL.RELS.XTR
*
*
RETURN
*
END
~CASH.SUBR.LIST.SELECT~
SUBROUTINE CASH.SUBR.LIST.SELECT(TITLE,MAT CNT.CSH,CNT.CSH.ID,CHSU,CSHU.ID,CSHUD,CSHUD.ID,CONTROL.DT,CSH.TYPE.SEL,EXEC.VERB.SEL,BATCH.CLASS.SEL,BATCH.SOURCE.SEL,DT.OPEN.SEL,PORT.SEL,USER.VALID.SEL,LPT.DETAIL.SEL,POST.FL,INPUTS,AUTO.RUN,PHAN.RUN)
*
* SUBROUTINE CASH.LIST.SELECT
* (
* LCK.FILE,PAR.FILE,CNT.FILE,
* CSH.TYPE,CSH.TYPE.CURR,TITLE,
* MAT CSH,CHS.ID,CHSU,CSHU.ID,CSHUD,CSHUD.ID,
* SEC.USER.ID,CONTROL.DT,
* DT.OPEN.SEL,PORT.SEL,USER.VALID.SEL,INPUTS,
* LCK.ITM,LCK.TYPE,LCK.STAT,STAT)
* (LCK.FILE,PAR.FILE,ACT.FILE,CAJ,CO.NAME,BATCH.STATUS,HEADER,BATCH.NUM,BUS.DATE,ACCTG.PERIOD,BATCH.TOTAL,ENTERED.TOTAL,ADJUST.TOTAL,CSH.TYPE,CSH.TYPE.CURR,TITLE,OPERATOR,TRANS.TYPES,DEFAULT.TYPE,ENTRY.TYPE,MIN.DELINQ.AMT,MIN.DELINQ.STAT,LCK.ITM,LCK.TYPE,LCK.STAT,STAT)
*
* VERSION: 921218 1.0  NEW
* DESCRIPTION:      SELECT COUNTER CASH BATCHES FOR PRINTING / POSTING
*
* COPYRIGHT         AXION COMPUTER SYSTEMS LTD.
*   1992             ALL RIGHTS RESERVED
*
* AUTHOR:           DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
!
*
* DT.OPEN.SEL = EMPTY
* EXEC.VERB.SEL = EMPTY
* PORT.SEL = EMPTY
* USER.VALID.SEL = EMPTY
* LPT.DETAIL.SEL = EMPTY
*
LN = 5; LN.ORIG = 5; LN.INP = 22
RELOOP = FALSE; INPUTS = VM
DT.LOC = ZERO; PORT.LOC = ZERO; USER.LOC = ZERO
*
CSH.OPT.TEXT = RVB:'D':RVE:'etailed transactions'
CSH.OPT.TEXT<ONE,ONE,-ONE> = RVB:'S':RVE:'ummary of batches'
CSH.OPT.TEXT<ONE,ONE,-ONE> = 't':RVB:'Y':RVE:'ypes of payment'
CSH.OPT.TEXT<ONE,ONE,-ONE> = RVB:'P':RVE:'rinter'
CSH.OPT.TEXT<ONE,ONE,-ONE> = RVB:'T':RVE:'erminal'
CSH.OPT.TEXT<ONE,ONE,-ONE> = 'se':RVB:'L':RVE:'ect statement'
CSH.OPT.TEXT<ONE,ONE,-ONE> = 'no ':RVB:'E':RVE:'ntry of options'
CSH.OPT = 'D':SVM:'S':SVM:'Y':SVM:'P':SVM:'T':SVM:'L':SVM:'E'
*
BE.DESC = 'Business':AM:'Entry'
BE.DICT = 'BUS.DATE':AM:'ENTRY.DATE'
BE.COND = 'GT':AM:'LT'
BE.SEL = EMPTY; BE.LOC = ZERO
BE.LO.HI = 'lowest':AM:'highest'
*
FOR NUM = ONE TO 4
ON NUM GOSUB GET.DT.OPEN,GET.PORT,GET.USER.VALID,GET.LPT.DETAIL
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN NUM = NUM - ONE ELSE
NUM = NUM - TWO; IF NUM LT ZERO THEN NUM = ZERO
END
RELOOP = TRUE
STAT = FALSE
END
NEXT NUM
*
RETURN; * to calling program
*
!
*
GET.DT.OPEN: *
*
LN = LN.ORIG; SC = ONE
*
* IF DCOUNT(CNT.CSH$DT.OPEN<ONE,ONE>,SVM) THEN
IF DT.OPEN.SEL EQ '&' THEN DT.OPEN.SEL = EMPTY
IF DT.OPEN.SEL EQ '*' THEN DT.OPEN.SEL = CNT.CSH$DT.OPEN
IF DT.OPEN.SEL EQ 'CLOSED' THEN CLOSED.FL = "C"; DT.OPEN.SEL = EMPTY ELSE
IF DT.OPEN.SEL EQ 'RECONCILED' THEN CLOSED.FL = "R"; DT.OPEN.SEL = EMPTY ELSE
CLOSED.FL = ""
END
END
IF DT.OPEN.SEL EQ EMPTY OR RELOOP THEN
IF NOT(AUTO.RUN) THEN
IF DT.OPEN.SEL EQ 'ALL' AND RELOOP THEN DT.OPEN.SEL = EMPTY
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN):RVB:' Dates.Open':RVE:'  ':RVB:'Closed':RVE:
LN = LN + ONE
LOOP UNTIL CNT.CSH$DT.OPEN<ONE,ONE,SC> EQ EMPTY DO
IF CNT.CSH$DT.CLOSED<ONE,ONE,SC> EQ CLOSED.FL THEN
DT.OPEN.SEL<ONE,ONE,-ONE> = CNT.CSH$DT.OPEN<ONE,ONE,SC>
END
IF NOT(PHAN.RUN) THEN
PRINT @(TWO,LN):OCONV(CNT.CSH$DT.OPEN<ONE,ONE,SC>,'D2') 'R#9':
IF CNT.CSH$DT.CLOSED<ONE,ONE,SC> EQ "C" THEN
PRINT '   Closed':
END ELSE IF CNT.CSH$DT.CLOSED<ONE,ONE,SC> EQ "R" THEN
PRINT ' Reconciled':
END
LOCATE CNT.CSH$DT.OPEN<ONE,ONE,SC> IN DT.OPEN.SEL<ONE,ONE> BY 'AR' SETTING TMP.LOC THEN
PRINT @(ZERO,LN):RVB:'*':RVE:
END ELSE
PRINT @(ZERO,LN):' ':
END
END; * OF PHAN.RUN
SC = SC + ONE; LN = LN + ONE
REPEAT
*
LN = LN + ONE
*
LOOP
*
IF NOT(PHAN.RUN) THEN
PRINT @(ZERO,LN.INP - ONE):CLL:RVB:'Enter Business Dates, SELection criteria, "*", ALL or <cr> when done: ':RVE:
PRINT @(ZERO,LN.INP):CLL:
END
IF CLOSED.FL EQ EMPTY THEN
INPUT RSP:
END ELSE RSP = EMPTY
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
DT.OPEN.INP = RSP
*
!
*
IF DT.OPEN.INP[ONE,3] EQ 'SEL' THEN
EXEC.VERB.SEL = DT.OPEN.INP[4,9999]
*
IF EXEC.VERB.SEL EQ EMPTY THEN
*
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:'Select by ':RVB:'B':RVE:'usiness or ':RVB:'E':RVE:'ntry date: ':
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
WHILE RSP NE 'B' AND RSP NE 'E' DO
PRINT CLB:BELL:'Enter a "B" or "E"
WHILE RSP NE 'B' AND RSP NE 'E' DO
PRINT CLB:BELL:'Enter a "B" or "E" here.':
REPEAT
IF NOT(PHAN.RUN) THEN PRINT CLB:
BE.LOC = INDEX('BE',RSP,ONE)
*
EXEC.VERB.SEL  = EMPAN.RUN) THEN PRINT CLB:
BE.LOC = INDEX('BE',RSP,ONE)
*
EXEC.VERB.SEL  = EMPTY
*
FOR BE.CN = ONE TO TWO
*
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP - 4 + BE.CN):CLL:'Enter the ':BE.LO.HI<BE.CN>:' ':BE.DESC<BE.LOC>:' date: ':
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
RSP = ICONV(RSP,'D')
WHILE NOT(RSP) DO
PRINT CLB:BELL:'Enter a valid date here.':
REPEAT
IF NOT(PHAN.RUN) THEN PRINT CLB:
BE.SEL<BE.CN> = RSP
*
NEXT BE.CN
*
EXEC.VERB.SEL = 'SSELECT CAJ BY ':BE.DICT<BE.LOC>:' WITH '
EXEC.VERB.SEL = EXEC.VERB.SEL:BE.DICT<BE.LOC>:' '
FOR BE.CN = ONE TO TWO
* EXEC.VERB.SEL = EXEC.VERB.SEL:BE.DICT<BE.LOC>:' ':BE.COND<BE.CN>:' "':OCONV(BE.SEL<BE.CN>,'D2'):'"'
EXEC.VERB.SEL = EXEC.VERB.SEL:BE.COND<BE.CN>:' "':OCONV(BE.SEL<BE.CN>,'D2'):'"'
IF BE.CN EQ ONE THEN EXEC.VERB.SEL = EXEC.VERB.SEL:' AND '
NEXT BE.CN
*
END; * of empty select
*
DT.OPEN.INP = 'ALL'
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP - 4):CLL:EXEC.VERB.SEL:
IF NOT(INDEX(LPT.DETAIL.SEL,'L',ONE)) THEN LPT.DETAIL.SEL<ONE,ONE,-ONE> = 'L'
*
END ELSE IF DT.OPEN.INP EQ 'ALL' THEN
EXEC.VERB.SEL = 'SSELECT CAJ'
END; * of SEL
*
!
*
IF DT.OPEN.INP NE 'ALL' AND DT.OPEN.INP NE '*' THEN
IF DT.OPEN.INP NE EMPTY THEN
DT.OPEN.INP = ICONV(DT.OPEN.INP,'D')
IF DT.OPEN.INP NE EMPTY THEN
LOCATE DT.OPEN.INP IN CNT.CSH$DT.OPEN<ONE,ONE> BY 'AR' SETTING DT.LOC THEN
LOCATE DT.OPEN.INP IN DT.OPEN.SEL<ONE,ONE> BY 'AR' SETTING TMP.LOC THEN
DEL DT.OPEN.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.ORIG + DT.LOC):' ':@(5,LN):
END ELSE
INS DT.OPEN.INP BEFORE DT.OPEN.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.ORIG + DT.LOC):RVB:'*':RVE:@(5,LN):
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END
END ELSE DT.LOC = 999
END ELSE IF DT.OPEN.INP EQ '*' THEN
EXEC.VERB.SEL = EMPTY
IF DT.OPEN.SEL EQ CNT.CSH$DT.OPEN THEN
DT.OPEN.SEL = EMPTY
END ELSE
DT.OPEN.SEL = CNT.CSH$DT.OPEN
END
RELOOP = TRUE
GOTO GET.DT.OPEN
END ELSE IF DT.OPEN.INP EQ 'ALL' THEN
DT.OPEN.SEL = 'ALL'; DT.LOC = 999
END
IF (DT.OPEN.SEL EQ EMPTY AND EXEC.VERB.SEL EQ EMPTY) AND DT.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one Date or KILL the run!':BELL:
DT.LOC = ZERO
END
UNTIL DT.LOC EQ 999 DO REPEAT
*
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP - ONE):CLL:
END
END
* END ELSE DT.OPEN.SEL = EMPTY
* INPUTS<ONE> = INPUTS<ONE>:'*':DT.OPEN.SEL
*
RETURN
*
!
*
GET.PORT: *
*
LN = LN.ORIG; SC = ONE
*
* IF DCOUNT(CNT.CSH$PORT<ONE,ONE>,SVM) THEN
IF PORT.SEL EQ '&' THEN PORT.SEL = EMPTY
IF PORT.SEL EQ '*' THEN PORT.SEL = CNT.CSH$PORT
IF PORT.SEL EQ EMPTY OR RELOOP THEN
IF NOT(AUTO.RUN) THEN
IF PORT.SEL EQ 'ALL' AND RELOOP THEN PORT.SEL = EMPTY
IF NOT(PHAN.RUN) THEN
PRINT @(23,LN):RVB:'Ports':RVE:
LN = LN + ONE
LOOP UNTIL CNT.CSH$PORT<ONE,ONE,SC> EQ EMPTY DO
PRINT @(25,LN):CNT.CSH$PORT<ONE,ONE,SC> 'L#5':
LOCATE CNT.CSH$PORT<ONE,ONE,SC> IN PORT.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
PRINT @(23,LN):RVB:'*':RVE:
END ELSE
PRINT @(23,LN):' ':
END
SC = SC + ONE; LN = LN + ONE
REPEAT
END; * OF PHAN.RUN
*
LN = LN + ONE
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter Till, "*", ALL or <cr> when done: ':RVE:
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
PORT.INP = RSP
IF PORT.INP NE 'ALL' AND PORT.INP NE '*' THEN
IF PORT.INP NE EMPTY THEN
PORT.INP = ('000':PORT.INP) 'R#3'
LOCATE PORT.INP IN CNT.CSH$PORT<ONE,ONE> BY 'AL' SETTING PORT.LOC THEN
LOCATE PORT.INP IN PORT.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
DEL PORT.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(23,LN.ORIG + PORT.LOC):' ':@(75,LN.INP):
END ELSE
INS PORT.INP BEFORE PORT.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(23,LN.ORIG + PORT.LOC):RVB:'*':RVE:@(75,LN.INP):
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END ELSE PORT.LOC = 999
END ELSE IF PORT.INP EQ '*' THEN
IF PORT.SEL EQ CNT.CSH$PORT THEN
PORT.SEL = EMPTY
END ELSE
PORT.SEL = CNT.CSH$PORT
END
RELOOP = TRUE
GOTO GET.PORT
END ELSE IF PORT.INP EQ 'ALL' THEN
PORT.SEL = 'ALL'; PORT.LOC = 999
END
IF PORT.SEL EQ EMPTY AND PORT.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one Till or KILL the run!':BELL:
PORT.LOC = ZERO
END
UNTIL PORT.LOC EQ 999 DO REPEAT
*
END
END
* END ELSE PORT.INP = EMPTY
* INPUTS<ONE> = INPUTS<ONE>:'*':PORT.SEL
*
RETURN
*
!
*
GET.USER.VALID: *
*
LN = LN.ORIG; SC = ONE
*
* IF DCOUNT(CNT.CSH$USER.VALID<ONE,ONE>,SVM) THEN
IF USER.VALID.SEL EQ '&' THEN USER.VALID.SEL = EMPTY
IF USER.VALID.SEL EQ '*' THEN USER.VALID.SEL = CNT.CSH$USER.VALID
IF USER.VALID.SEL EQ EMPTY OR RELOOP THEN
IF NOT(AUTO.RUN) THEN
IF USER.VALID.SEL EQ 'ALL' AND RELOOP THEN USER.VALID.SEL = EMPTY
IF NOT(PHAN.RUN) THEN
PRINT @(31,LN):RVB:'Users':RVE:; LN = LN + ONE
LOOP UNTIL CNT.CSH$USER.VALID<ONE,ONE,SC> EQ EMPTY DO
PRINT @(33,LN):CNT.CSH$USER.VALID<ONE,ONE,SC> 'L#5':
LOCATE CNT.CSH$USER.VALID<ONE,ONE,SC> IN USER.VALID.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
PRINT @(31,LN):RVB:'*':RVE:
END ELSE
PRINT @(31,LN):' ':
END
SC = SC + ONE; LN = LN + ONE
REPEAT
END; * OF PHAN.RUN
*
LN = LN + ONE
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter User, "*", ALL or <cr> when done: ':RVE:
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
USER.VALID.INP = RSP
IF USER.VALID.INP NE 'ALL' AND USER.VALID.INP NE '*' THEN
IF USER.VALID.INP NE EMPTY THEN
LOCATE USER.VALID.INP IN CNT.CSH$USER.VALID<ONE,ONE> BY 'AL' SETTING USER.LOC THEN
LOCATE USER.VALID.INP IN USER.VALID.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
DEL USER.VALID.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(31,LN.ORIG + USER.LOC):' ':@(75,LN.INP):
END ELSE
INS USER.VALID.INP BEFORE USER.VALID.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(31,LN.ORIG + USER.LOC):RVB:'*':RVE:@(75,LN.INP):
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END ELSE USER.LOC = 999
END ELSE IF USER.VALID.INP EQ '*' THEN
IF USER.VALID.SEL EQ CNT.CSH$USER.VALID THEN
USER.VALID.SEL = EMPTY
END ELSE
USER.VALID.SEL = CNT.CSH$USER.VALID
END
RELOOP = TRUE
GOTO GET.USER.VALID
END ELSE IF USER.VALID.INP EQ 'ALL' THEN
USER.VALID.SEL = 'ALL'; USER.LOC = 999
END
IF USER.VALID.SEL EQ EMPTY AND USER.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one User or KILL the run!':BELL:
USER.LOC = ZERO
END
UNTIL USER.LOC EQ 999 DO REPEAT
*
END
END
* END ELSE USER.VALID.INP = EMPTY
* INPUTS<ONE> = INPUTS<ONE>:'*':USER.VALID.SEL
*
RETURN
*
!
*
GET.LPT.DETAIL: *
*
LN = LN.ORIG; SC = ONE; NO.ENTRY = FALSE
*
IF LPT.DETAIL.SEL EQ '&' THEN LPT.DETAIL.SEL = EMPTY
*
* IF LPT.DETAIL.SEL EQ EMPTY THEN
*
IF NOT(AUTO.RUN) THEN
*
IF NOT(PHAN.RUN) THEN
PRINT @(40,LN):RVB:'Reporting Options' 'L#25':RVE:; LN = LN + ONE
LOOP UNTIL CSH.OPT<ONE,ONE,SC> EQ EMPTY DO
PRINT @(42,LN):CSH.OPT.TEXT<ONE,ONE,SC> 'L#25':
SC = SC + ONE; LN = LN + ONE
REPEAT
END; * OF PHAN.RUN
*
*
LN = LN + ONE
LPT.DETAIL.TMP = LPT.DETAIL.SEL; LPT.DETAIL.SEL = EMPTY
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter Reporting Options or <cr> when done: ':RVE:
LOOP
* IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter Reporting Options or <cr> when done: ':RVE:
IF LEN(LPT.DETAIL.TMP) THEN
IF LPT.DETAIL.TMP[ONE,ONE] EQ SVM THEN LPT.DETAIL.TMP = LPT.DETAIL.TMP[TWO,99999]
LPT.DETAIL.INP = LPT.DETAIL.TMP[ONE,ONE]
LPT.DETAIL.TMP = LPT.DETAIL.TMP[TWO,99999]
END ELSE
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
LPT.DETAIL.INP = RSP
IF LEN(LPT.DETAIL.INP) GT ONE THEN
LPT.DETAIL.TMP = LPT.DETAIL.INP[TWO,9999]
LPT.DETAIL.INP = LPT.DETAIL.INP[ONE,ONE]
END
END
IF LPT.DETAIL.INP NE EMPTY THEN
LOCATE LPT.DETAIL.INP IN CSH.OPT<ONE,ONE> SETTING OPT.LOC THEN
LOCATE LPT.DETAIL.INP IN LPT.DETAIL.SEL<ONE,ONE> SETTING TMP.LOC THEN
DEL LPT.DETAIL.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(40,LN.ORIG + OPT.LOC):' ':@(75,LN.INP):
END ELSE
INS LPT.DETAIL.INP BEFORE LPT.DETAIL.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(40,LN.ORIG + OPT.LOC):RVB:'*':RVE:@(75,LN.INP):
IF LPT.DETAIL.INP EQ 'E' THEN NO.ENTRY = TRUE
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END ELSE OPT.LOC = 999
IF LPT.DETAIL.SEL EQ EMPTY AND OPT.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one Option or KILL the run!':BELL:
OPT.LOC = ZERO
END
UNTIL OPT.LOC EQ 999 OR NO.ENTRY DO REPEAT
*
* END
END
* INPUTS<ONE> = INPUTS<ONE>:'*':LPT.DETAIL.SEL
*
RETURN
*
!
*
END
~CASH.SUBR.LOAD.CNTRL~
SUBROUTINE CASH.SUBR.LOAD.CNTRL(CNT.CSH.ID,MAT CNT.CSH)
*VERSION 1.0
*
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1993              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
* DESCRIPTION:      LOAD CASH CONTROL PARAMETER
*  
*
*
* DATE WRITTEN:    DD MMM 93
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
*
MAT CNT.CSH = EMPTY
*
!
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
*CNT.CSH.ID,MAT CNT.CSH,STAT
*
!
*
FINISH: *
*
RETURN; * To calling program
*
END
~CASH.SUBR.LOAD.LIST.CC~
SUBROUTINE CASH.SUBR.LOAD.LIST.CC(BATCH.NUM,MAT PAR.MENU,MAT SEC.USER,PORT.CC,USER.VALID,CAJ.FILE)
*PROGRAM: CASH.SUBR.LOAD.LIST.CC
EQU VS TO "930305"
* AUTHORS: DAVID HORMAN for AXION COMPUTER SYSTEMS
* DESCRIPTION:  Enter payments for an account
*
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
!
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
!
*
VERSION = " (R:1.0)"
*
* PRINT CLB:"EP 1 - Enter <cr> . . . ":; INPUT TMP.RSP:
*
* LCK.ITM = TRUE; LCK.TYPE = ONE; * LCK.FILE = ZERO; * REV ONLY
CNT.CSH.ID = EMPTY
MAT CNT.CSH = EMPTY
CSH.PORT.VC = ZERO; CSH.USER.SC = ZERO; CSH.DT.VC = ZERO
*
CSHUD.ID = EMPTY; CSHUD = EMPTY
CSHU.ID = EMPTY; CSHU = EMPTY
*
OPERATOR = SEC.USER.ID
CONTROL.DT = CO.DATA<TWO>
IF CONTROL.DT EQ DATE() AND CO.DATA<3> LE TIME() THEN
PRINT CLB:RVB:"Transactions are being processed under tomorrow's date!":RVE:
CONTROL.DT = CONTROL.DT + ONE
END
USER.VALID = FALSE
PORT.CC = FALSE
UPD.FL = FALSE
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
! Validate Port
LOCATE PORT IN CNT.CSH$PORT<ONE,ONE> BY "AR" SETTING CSH.PORT.VC THEN
PORT.CC = CSH.PORT.VC
END ELSE
PORT.CC = FALSE
*CSH.PORT.VC = ONE
*LOCATE "" IN CNT.CSH$PORT<ONE,ONE> BY "AR" SETTING CSH.PORT.VC ELSE NULL
*INS???
PRINT CLB:BELL:"The till you are using is not approved for counter payment!  Enter <cr>: ":; INPUT TMP:
STAT = 604
GOTO FINISH
END
*
! Validate Date
*
CONT = TRUE; CSH.CONTROL.DT = CONTROL.DT
LOOP
LOCATE CSH.CONTROL.DT IN CNT.CSH$DT.OPEN<ONE,ONE> BY "AR" SETTING CSH.DT.VC THEN
IF CNT.CSH$DT.CLOSED<ONE,ONE,CSH.DT.VC> EQ "Y" THEN
PRINT CLB:BELL:OCONV(CSH.CONTROL.DT,"D2"):" is closed for payments! Enter <cr> . . . ":; INPUT TMP:
END ELSE CONT = FALSE
END ELSE
PRINT CLB:RVB:OCONV(CSH.CONTROL.DT,"D2"):" now open for payments!":" Enter <cr> . . . ":RVE:BELL:; INPUT TMP:
CONT = FALSE
INS CONTROL.DT BEFORE CNT.CSH$DT.OPEN<ONE,ONE,CSH.DT.VC>
INS EMPTY      BEFORE CNT.CSH$DT.CLOSED<ONE,ONE,CSH.DT.VC>
UPD.FL = TRUE
END
WHILE CONT DO CSH.CONTROL.DT = CSH.CONTROL.DT + ONE REPEAT
*
! Prompt for New User
*
* PRINT CLB:"EP 2 - Enter <cr> . . . ":; INPUT CSH.CONTROL.DT.RSP:
*
*
IF CNT.CSH$USER.PROMPT<ONE,ONE,CSH.PORT.VC> EQ "Y" OR CNT.CSH$USER.CURR<ONE,ONE,CSH.PORT.VC> NE SEC.USER.ID OR CNT.CSH$USER.CURR<ONE,ONE,CSH.PORT.VC> EQ EMPTY THEN
! Prompt for user
****
! Call to security system (validation only?)
$INCLUDE IBP SYS.INCL.LOAD.PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
PAR.MENU$USER = EMPTY
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
IF STAT THEN
USER.VALID = FALSE
STAT = 602
GOTO FINISH
END
END; * Of prompt for user
*
****
! Validate Security
LOCATE SEC.USER.ID IN CNT.CSH$USER.VALID<ONE,ONE> BY "AL" SETTING CSH.USER.SC THEN
! Set new User
CNT.CSH$USER.CURR<ONE,ONE,CSH.PORT.VC> = SEC.USER.ID
USER.VALID = TRUE
UPD.FL = TRUE
END ELSE
PRINT CLB:BELL:"You are not approved for counter payments! Enter <cr> . . . ":; INPUT TMP:
PRINT CLB:BELL:"Have an operator approved for payments help you! Enter <cr> . . . ":; INPUT TMP:
STAT = 605
USER.VALID = FALSE
GOTO FINISH
END
*
IF UPD.FL THEN
$INCLUDE IBP.CASH CASH.INCL.UPD.CNTRL
END
*
! Load User Info
*
* 1 - Tills Open for todays's date
*
* PRINT CLB:"EP 3 - Enter <cr> . . . ":; INPUT TMP.RSP:
*
*
BATCH.OPEN = FALSE
CSHUD.ID = "CSHUD*":SEC.USER.ID:"*":CSH.CONTROL.DT
READ CSHUD FROM CNT.FILE,CSHUD.ID ELSE
CSHUD = EMPTY
GOSUB OPEN.BATCH
BATCH.OPEN = TRUE
END
*
! Load User Info for this Till
*
* 1 - Batches Open for today's date by Till
*
* PRINT CLB:"EP 4 - Enter <cr> . . . ":; INPUT TMP.RSP:
*
*
CSHU.ID = "CSHU*":SEC.USER.ID:"*":CSH.CONTROL.DT:"*":PORT
READ CSHU FROM CNT.FILE,CSHU.ID ELSE
CSHU = EMPTY
IF NOT(BATCH.OPEN) THEN
GOSUB OPEN.BATCH
BATCH.OPEN = TRUE
END
END
*
! Load Curr Batch?
*
IF NOT(BATCH.OPEN) THEN
BATCH.NUM = CSHU<ONE>
READV BATCH.HEADER FROM CAJ.FILE,BATCH.NUM,ONE THEN
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
IF BATCH.STATUS EQ "P" OR BATCH.STATUS EQ "Z" OR ITEM.COUNT GT CNT.CSH$ITEM.CN.MAX THEN
GOSUB OPEN.BATCH
BATCH.OPEN = TRUE
END
END ELSE GOSUB OPEN.BATCH; BATCH.OPEN = TRUE
END
*
! Load Curr Batch?
*
IF BATCH.OPEN THEN
INS BATCH.NUM BEFORE CSHU<ONE>
IF ALL.FLAG THEN WRITE CSHU ON CNT.FILE,CSHU.ID
INS BATCH.NUM BEFORE CSHUD<ONE>
IF ALL.FLAG THEN WRITE CSHUD ON CNT.FILE,CSHUD.ID
END ELSE
BATCH.NUM = CSHU<ONE>
END
*
FINISH: *
*
$INCLUDE IBP.CASH CASH.INCL.UNLCK.CNTRL
*
RETURN; * To Calling program
*
!
*
OPEN.BATCH: *
*
$INCLUDE IBP.CASH CASH.INCL.NEXT.BATCH
*
RETURN
*
END
~CASH.SUBR.LOAD.PORT.USER~
SUBROUTINE CASH.SUBR.LOAD.PORT.USER(MAT CNT.CSH,CNT.CSH.ID,PORT.CC,USER.VALID)
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
!
*
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
UPD.FL = FALSE
PORT.CC = FALSE
USER.VALID = FALSE
*
* Validate Port
LOCATE PORT IN CSH$PORT<ONE> BY "AR" SETTING CSH.PORT.VC THEN
PORT.CC = TRUE
END ELSE
PORT.CC = FALSE
*CSH.PORT.VC = ONE
*LOCATE "" IN CSH$PORT<ONE> BY "AR" SETTING CSH.PORT.VC ELSE NULL
*INS???
END
*
* Validate Date
*
LOCATE CONTROL.DT IN CSH$DT.OPEN<ONE> BY "AR" SETTING CSH.DT.VC THEN
IF CNT$DT.CLOSED<ONE,CSH.DT.VC> THEN
PRINT CLB:"That business date is close for payment! Enter <cr> . . . ":; INPUT TMP:
STAT = 603
END ELSE
INS CONTROL.DT BEFORE CSH$DT.OPEN<ONE,CSH.DT.VC>
UPD.FL = TRUE
END
*
* Prompt for New User
*
PRINT CLB:"EP 2 - Enter <cr> . . . ":; INPUT TMP.RSP:
*
*
IF CSH$USER.PROMPT<ONE,CSH.PORT.VC> OR (CSH$PORT.USER.CURR<CSH.PORT.VC> NE SEC.USER.ID) THEN
* Prompt for user
****
* Call to security system (validation only?)
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
****
* Validate Security
LOCATE SEC.USER.ID IN CSH$PORT.USER.VALID<ONE,CSH.PORT.VC> BY "AL" SETTING CSH.USER.SC THEN
* Set new User
CSH$PORT.USER.CURR<ONE,CSH.PORT.VC> = SEC.USER.ID
USER.VALID = TRUE
UPD.FL = TRUE
END ELSE
PRINT CLB:"You are not approved for counter payments! Enter <cr> . . . ":; INPUT TMP:
STAT = 602
GOTO FINISH
END
*
END
*
IF UPD.FL THEN
$INCLUDE IBP.CASH CASH.INCL.UPD.CNTRL
END
*
$INCLUDE IBP.CASH CASH.INCL.UNLCK.CNTRL
*
!
*
FINISH: *
*
RETURN
*
END
~CASH.SUBR.OPEN.LIST.POST~
SUBROUTINE CASH.SUBR.OPEN.LIST.POST(CAJ.FILE)
* VERSION: 930504 1.0
EQU VS TO " (R:1.0)"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1991              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
*                  MACROSCOPE DESIGN MATRIX
* DESCRIPTION:     This program opens the files for Cash List Post
*  
* DATE WRITTEN:    5 MAY 93
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
SYS.PROG = "CASH.SUBR.OPEN.LIST.POST"; VERSION = "1.0"
STAT = FALSE; PHAN.RUN = TRUE
OPEN "ACT" TO ACT.FILE ELSE FILE.NAME = "ACT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
IF OPSYS NE "R" THEN OPEN "AAX" TO AAX.FILE ELSE FILE.NAME = "AAX"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ACG" TO ACG.FILE ELSE FILE.NAME = "ACG"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ADD" TO ADD.FILE ELSE FILE.NAME = "ADD"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ATR" TO ATR.FILE ELSE FILE.NAME = "ATR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "EFT" TO EFT.FILE ELSE FILE.NAME = "EFT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
STAT = FALSE; INPUTS = EMPTY
*
*
RETURN; * To Calling program
*
END
~CASH.SUBR.POST~
SUBROUTINE CASH.SUBR.POST(CAJ,CSH.TYPE,CSH.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,RUN.TRANS.SUB.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,MIN.DELINQ.STAT,MIN.DELINQ.AMT,BUS.DATE,BATCH.CLASS.SEL,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,BATCH.DEL.STATUS,ENTRY.MODE,TRANS.COUNT,BATCH.INP.SOURCE)
* VERSION: 950915 4.0  PHASE (ZONE) CHANGED TO LENGTH 3.
* PRIOR: 910625 1.0  Posting routines for cash
* PRIOR: ?
* COPYRIGHT         AXION COMPUTER SYSTEMS LTD.
*   1991             ALL RIGHTS RESERVED
*
* AUTHOR:           DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:      POSTS A BATCH OF CASH OR ADJUSTMENTS
*
*     Addapted from cash.or.adj.entry (COPYRIGHT 1983 - AXION)
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
*NCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
*NCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
*NCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*NCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
*NCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
*NCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*NCLUDE IBP DLQ.DIM
*
IF ENTRY.MODE EQ ONE THEN
*
* Process a Transaction
*
TRANS = CAJ<TRANS.COUNT>
*
POST.FL = TRANS<ONE,10>
IF NOT(STAT) THEN
* Check for a $ amt
IF TRANS<ONE,3> THEN
* If not Posted or (posted and batch being deleted)
IF NOT(POST.FL OR BATCH.DEL.STATUS) OR (POST.FL AND BATCH.DEL.STATUS) THEN
GOSUB POST.TRANS
* If Posted OK flag as posted
IF NOT(STAT) THEN CAJ<TRANS.COUNT,10> = DATE() * 100000 + TIME()
END
END
END
*
END ELSE
*
! Load Standard System Program Delay
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DELAY
*
! Process Transactions in Batch
*
TRANS.COUNT = ONE
*
LOOP TRANS = CAJ<TRANS.COUNT> UNTIL TRANS EQ EMPTY OR STAT DO
*
* Standard System Programs Delay (Multi-User Systems)
*
IF CSH.TYPE THEN
*
$INCLUDE IBP SYS.INCL.CHK.STD.DELAY
*
$INCLUDE IBP SYS.INCL.STD.DELAY
*
END
*
*
* Process a Transaction
*
POST.FL = TRANS<ONE,10>
IF NOT(STAT) THEN
* Check for a $ amt
IF TRANS<ONE,3> THEN
* If not Posted or (posted and batch being deleted)
IF NOT(POST.FL OR BATCH.DEL.STATUS) OR (POST.FL AND BATCH.DEL.STATUS) THEN
GOSUB POST.TRANS
* If Posted OK flag as posted
IF NOT(STAT) THEN CAJ<TRANS.COUNT,10> = DATE() * 100000 + TIME()
END
END
END
*
* Next Trans
TRANS.COUNT = TRANS.COUNT + ONE
*
REPEAT
*
END; * Of entry.mode
*
!
*
FINISH: *
*
RETURN
*
!!
*
! Post a Transaction
*
POST.TRANS: *
*
* Load ACT ID
ACT.ID = TRANS<ONE,ONE>; CD = ACT.ID[7,ONE]; ACT.ID = ACT.ID[ONE,6]
* Display Trans
IF ENTRY.MODE EQ ZERO THEN
PRINT @(10,11):CLL:"Now Posting Transaction on account no. ":ACT.ID:"-":CD
END
*
IF ENTRY.MODE EQ ZERO THEN
* Lock ACT
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE,LCK.STAT) 
WHILE STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ACT file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
* Read ACT
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = EMPTY; STAT = TRUE
*      ATR
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = EMPTY
*      ADD
MATREAD ADD FROM ADD.FILE,ACT$ADD.ID ELSE MAT ADD = EMPTY; STAT = TRUE
*
* Release item if abort on batch
IF STAT THEN 
CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
RETURN
END
*
END; * Of entry.mode
! Post Trans
*
*INCLUDE IBP CASH.INCL.POST.TRANS
*CODE.SEGMENT: CASH.INCL.POST.TRANS
*
* DAVID HORSMAN
*
* 930305
*
* Load Trans Info
PHASE = FIELD(ADD$GEOGRAPHIC.DATA,"*",ONE); PHASE = ("00":PHASE) "R#3"
MAT ACG = EMPTY
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
AMOUNT = TRANS<ONE,3>; IF BATCH.CLASS.SEL THEN AMOUNT = -AMOUNT
* Reverse amount on a batch delete
IF BATCH.DEL.STATUS THEN AMOUNT = -AMOUNT
DESC = TRANS<ONE,4>
* Adjustment
IF DESC[ONE,TWO] EQ "a-" THEN
SOURCE = "A"
LC.SOURCE = "a"
TRANS.CLASS = "a"
TRANS.SUB.CLASS = EMPTY
END ELSE
* Deposit, Cash or Billing
SOURCE = RUN.SOURCE
LC.SOURCE = RUN.LC.SOURCE
TRANS.CLASS = RUN.TRANS.CLASS
TRANS.SUB.CLASS = RUN.TRANS.SUB.CLASS
END
DESC<ONE,ONE,-ONE> = TRANS<ONE,11>
*
W.TYP = TRANS.CLASS:TRANS.SUB.CLASS:'*':TRANS.TYPE
TMP.SUB.CLASS = EMPTY
*
! Add Trans to ATR
*
* Add a ATR Trans; Don't Reverse an ATR Trans
ATR.UPD.FL = TRUE; ATR.DEL.FL = FALSE
*
* CTR = 3
* PPV = 5
*   * If it is a Pre-Posted Trans don't Add another ATR trans (CTR or PPV)
*   IF BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5 THEN ATR.UPD.FL = FALSE
* If it has been Posted don't Add another ATR Trans
IF POST.FL THEN ATR.UPD.FL = FALSE
* If the batch is waiting to be deleted
IF BATCH.DEL.STATUS THEN
* Dont Add an ATR Trans; Reverse the ATR Trans.
ATR.UPD.FL = FALSE; ATR.DEL.FL = TRUE
* If it is not Posted
*    * and it is not a pre-Posted Transaction (CTR or PPV)
* then don't reverse the Posting
*     IF NOT(POST.FL) AND (BATCH.INP.SOURCE NE 3 AND BATCH.INP.SOURCE NE 5) THEN
IF NOT(POST.FL) THEN
ATR.DEL.FL = FALSE
END
END
*
! Add an ATR Trans if OK
*
IF ATR.UPD.FL THEN
*
CALL PACK.NUMBER(EFF.DATE,TEMP); INS TEMP BEFORE ATR$EFF.DATES<ONE,ONE>
CALL PACK.NUMBER(CONTROL.DT,TEMP); INS TEMP BEFORE ATR$ENTRY.DATES<ONE,ONE>
CALL PACK.NUMBER(CURR.ACCTG.PERIOD,TEMP); INS TEMP BEFORE ATR$ENTRY.PERIODS<ONE,ONE>
INS SOURCE BEFORE ATR$TYPES<ONE,ONE>
INS BATCH.NUM BEFORE ATR$REFS<ONE,ONE>
CALL PACK.NUMBER(AMOUNT,TEMP); INS TEMP BEFORE ATR$TOTAL.AMTS<ONE,ONE>
IF DESC[ONE,TWO] EQ "a-" THEN INS EMPTY BEFORE ATR$DESCS<ONE,ONE> ELSE INS DESC BEFORE ATR$DESCS<ONE,ONE>
INS W.TYP BEFORE ATR$SVC.TYPES<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.QNTYS<ONE,ONE>
CALL PACK.NUMBER(AMOUNT,TEMP); INS TEMP BEFORE ATR$SVC.AMTS<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.FROM.DATES<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.TO.DATES<ONE,ONE>
*
END; * of Add an ATR Trans
*
! Reverse an ATR Trans
*
* END ELSE IF (BATCH.DEL.STATUS AND (POST.FL OR (NOT(POST.FL) AND (BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5)))) THEN
*
*
IF ATR.DEL.FL THEN
*
LOCATE BATCH.NUM IN ATR$REFS<ONE> SETTING ATR.LOC THEN
*
DEL ATR$EFF.DATES<ONE,ATR.LOC>
DEL ATR$ENTRY.DATES<ONE,ATR.LOC>
DEL ATR$ENTRY.PERIODS<ONE,ATR.LOC>
DEL ATR$TYPES<ONE,ATR.LOC>
DEL ATR$REFS<ONE,ATR.LOC>
DEL ATR$TOTAL.AMTS<ONE,ATR.LOC>
DEL ATR$DESCS<ONE,ATR.LOC>
DEL ATR$SVC.TYPES<ONE,ATR.LOC>
DEL ATR$SVC.QNTYS<ONE,ATR.LOC>
DEL ATR$SVC.AMTS<ONE,ATR.LOC>
DEL ATR$SVC.FROM.DATES<ONE,ATR.LOC>
DEL ATR$SVC.TO.DATES<ONE,ATR.LOC>
END
*
END; * Of Reverse an ATR Trans
*
!!
*
! Update Account balance and aging
*
* Don't update ACT/ACG
ACT.UPD.FL = FALSE
*
* If not Posted and not Reverse update the ACT/ACG
IF NOT(POST.FL) AND NOT(BATCH.DEL.STATUS) THEN ACT.UPD.FL = TRUE
*
* If not Posted and Reverse and Pre-posted Amount (CTR or PPV) update the ACT
IF NOT(POST.FL) AND BATCH.DEL.STATUS AND (BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5) THEN ACT.UPD.FL = TRUE
*
* IF Posted and Reverse Update then ACT/ACG (amounts will be reversed)
IF POST.FL AND BATCH.DEL.STATUS THEN ACT.UPD.FL = TRUE
*
* If not Posted and (not a Pre-Posted Trans (CTR or PPV)) Update the ACT/ACG
IF NOT(POST.FL) AND (BATCH.INP.SOURCE NE 3 AND BATCH.INP.SOURCE NE 5) THEN ACT.UPD.FL = TRUE
*
! Update the account for Adj's, Payments, Billings   vs   Deposits
*
IF ACT.UPD.FL THEN
*
* Process Adjustments, Cash, and Billings (vs. Deposits)
IF BATCH.CLASS.SEL NE TWO THEN
*
ACT$BALANCE = ACT$BALANCE + AMOUNT
AMT.TO.APPLY = -AMOUNT
IF AMT.TO.APPLY GT ZERO THEN AGE.NUM = 4 ELSE
AGE.NUM = TWO
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
IF TRANS.TYPES<5,LOC> EQ "N" THEN AGE.NUM = ONE ELSE
* NOW SET CR. STATUS TO MIN. DLQ FOR A 'LATE NOTICE' TRANSACTION
IF TRANS.TYPES<4,LOC> EQ "Y" THEN IF ACT$CREDIT.STATUS LT MIN.DELINQ.STAT THEN AGE.NUM = MIN.DELINQ.STAT
END
END
END
LOOP WHILE AMT.TO.APPLY DO
AGED = FIELD(ACT$AGED.AMTS,"*",ONE)
AGED<TWO> = FIELD(ACT$AGED.AMTS,"*",TWO)
AGED<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGED<4> = FIELD(ACT$AGED.AMTS,"*",4)
IF AGED<ONE> LT ZERO THEN AGED<4> = AGED<4> + AGED<ONE>; AGED<ONE> = ZERO
AGED<AGE.NUM> = AGED<AGE.NUM> - AMT.TO.APPLY
AGE.NUM = 4
LOOP
WHILE AGE.NUM GT ONE DO
IF AGED<AGE.NUM> LT ZERO THEN AGED<AGE.NUM - ONE> = AGED<AGE.NUM - ONE> + AGED<AGE.NUM>; AGED<AGE.NUM> = ZERO
AGE.NUM = AGE.NUM - ONE
REPEAT
AMT.TO.APPLY = AGED<ONE> + AGED<TWO> + AGED<3> + AGED<4> - ACT$BALANCE
IF AMT.TO.APPLY GT ZERO THEN AGE.NUM = 4 ELSE AGE.NUM = TWO
BEGIN CASE
CASE AGED<4>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>:"*":AGED<3>:"*":AGED<4>
CASE AGED<3>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>:"*":AGED<3>
CASE AGED<TWO>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>
CASE ONE;       ACT$AGED.AMTS = AGED<ONE>
END CASE
BEGIN CASE
CASE AGED<4> GE MIN.DELINQ.AMT;               * 60 DAYS  + 
IF ACT$CREDIT.STATUS LT 3 THEN ACT$CREDIT.STATUS = 3 
CASE AGED<3> + AGED<4> GE MIN.DELINQ.AMT;       * 30 DAYS  + 
ACT$CREDIT.STATUS = TWO
CASE AGED<TWO> + AGED<3> + AGED<4> GE MIN.DELINQ.AMT; * CURRENT
ACT$CREDIT.STATUS = ONE
CASE ONE;                                    * UNDER 30 DAYS
ACT$CREDIT.STATUS = ZERO
IF ACT$STAT EQ "A" THEN ACT$DISC.DATE = EMPTY ELSE IF ACT$BALANCE LT ZERO AND ABS(ACT$BALANCE) GE MIN.DELINQ.AMT THEN ACT$CREDIT.STATUS = -ONE
END CASE
REPEAT
END ELSE
DEPOSIT.TYPE = "D"
BEGIN CASE
CASE TRANS.TYPE EQ "01" OR TRANS.TYPE EQ "03" OR TRANS.TYPE EQ "05" OR TRANS.TYPE EQ "07"
DEPOSIT.TYPE = "D"
CASE TRANS.TYPE EQ "02" OR TRANS.TYPE EQ "04" OR TRANS.TYPE EQ "04" OR TRANS.TYPE EQ "08"
DEPOSIT.TYPE = "X"
END CASE
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
IF TRANS.TYPES<4,LOC> NE EMPTY THEN DEPOSIT.TYPE = TRANS.TYPES<4,LOC>
END
BEGIN CASE
CASE DEPOSIT.TYPE EQ "D"
ACT$DEPOSIT.AMT = ACT$DEPOSIT.AMT + AMOUNT
CASE DEPOSIT.TYPE EQ "X"
ACT$DEPOSIT.TAX = ACT$DEPOSIT.TAX + AMOUNT
END CASE
END
*
! Update Accounting
*
LOCATE LC.SOURCE IN ACG$SOURCES<ONE> BY "AL" SETTING SOURCE.LOC ELSE
INS LC.SOURCE BEFORE ACG$SOURCES<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$TRANS.TYPES<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$AMOUNTS<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$COUNTS<ONE,SOURCE.LOC>
END
LOCATE TRANS.TYPE IN ACG$TRANS.TYPES<ONE,SOURCE.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRANS.TYPE BEFORE ACG$TRANS.TYPES<ONE,SOURCE.LOC,TRANS.LOC>
INS EMPTY BEFORE ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC>
INS EMPTY BEFORE ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC>
END
ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC> = ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC> + AMOUNT
ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC> = ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC> + ONE
*
ACG.ID = PHASE:"*":BUS.DATE
LOOP
LOOP LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LCK.FILE,LCK.STAT) WHILE LCK.STAT DO
PRINT BELL:CLB:"You must unlock ACG file - item ":ACG.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
MATREAD SAVE.ACG FROM ACG.FILE,ACG.ID ELSE MAT SAVE.ACG = EMPTY
VC = ONE
LOOP SRC = ACG$SOURCES<ONE,VC> UNTIL SRC EQ EMPTY DO
LOCATE SRC IN SAVE.ACG$SOURCES<ONE> BY "AL" SETTING SRC.LOC ELSE
INS SRC BEFORE SAVE.ACG$SOURCES<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$AMOUNTS<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$COUNTS<ONE,SRC.LOC>
END
SC = ONE
LOOP TRTYP = ACG$TRANS.TYPES<ONE,VC,SC> UNTIL TRTYP EQ EMPTY DO
LOCATE TRTYP IN SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRTYP BEFORE SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC,TRANS.LOC>
INS EMPTY BEFORE SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC>
INS EMPTY BEFORE SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC>
END
SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC> = SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC> + ACG$AMOUNTS<ONE,VC,SC>
SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC> = SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC> + ACG$COUNTS<ONE,VC,SC>
SC = SC + ONE
REPEAT
VC = VC + ONE
REPEAT
*
* IF ENTRY.MODE EQ ZERO THEN
IF ACG.FLAG THEN MATWRITE SAVE.ACG ON ACG.FILE,ACG.ID
* END
CALL UNLOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LCK.FILE)
UNTIL ACG.ID[ONE,ONE] EQ "$" DO ACG.ID = "$":PHASE:"*":CONTROL.DT REPEAT
*
! Update ATR and ACT
*
* IF ENTRY.MODE EQ ZERO THEN
IF ATR.FLAG THEN MATWRITE ATR ON ATR.FILE,ACT.ID
* END
*
IF ACT.FLAG THEN
*
* IF ENTRY.MODE EQ ZERO THEN
MATWRITE ACT ON ACT.FILE,ACT.ID
* END
*
IF TRANS.TYPE MATCHES "'E'1A" THEN
IF TRANS.TYPE NE "EP" THEN
MATREAD EFT FROM EFT.FILE,ACT.ID THEN
BEGIN CASE
CASE TRANS.TYPE EQ "EE"; * EFT - Error in coding
EFT$STAT = "S"
IF EFT$ERROR.FLAG EQ EMPTY THEN EFT$ERROR.FLAG = "E"
CASE TRANS.TYPE EQ "EN"; * EFT - NSF cheque
IF EFT$ERROR.FLAG MATCHES "0N" THEN EFT$ERROR.FLAG = EFT$ERROR.FLAG + ONE ELSE EFT$ERROR.FLAG = ONE
CASE ONE; * CLOSED ACCOUNT OR STOP PAYMENT
EFT$STAT = "C"
END CASE
* IF ENTRY.MODE EQ ZERO THEN
MATWRITE EFT ON EFT.FILE,ACT.ID
* END
END; * of EFT found
END; * of not EP
END; * of "'E'1A"
*
END; * of ACT.FLAG
*
END; * of ACT.UPD.FL
*
*@@@@@@@@@@
*
! Unlock ACT
*
IF ENTRY.MODE EQ ZERO THEN
CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
END
*
RETURN
*
!
*
END
~CASH.SUBR.PRINT~
SUBROUTINE CASH.SUBR.PRINT(CAJ,CO.NAME,ACCTG.PERIOD,BATCH.HEADER,BATCH.STATUS.DESC,BATCH.NUM,BATCH.TOTAL.CHQ,BATCH.TOTAL.CRD,BATCH.TOTAL.CDC,BATCH.TOTAL.CSH,CSH.TYPE,CSH.TYPE.CURR,TITLE,TRANS.TYPES,BATCH.CLASS.SEL,LPT.DETAIL.FL,LPT.PMT.TYP.FL,LPT.FL,LPT.STAT,MIN.DELINQ.AMT,MIN.DELINQ.STAT)
* VERSION: 910625 1.0  NEW
* DESCRIPTION:      PRINTS A BATCH OF TRANSACTIONS
* COPYRIGHT         AXION COMPUTER SYSTEMS LTD.
*   1991             ALL RIGHTS RESERVED
*
* AUTHOR:           DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*
*     Addapted from cash.or.adj.entry (COPYRIGHT 1983 - AXION)
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
*NCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*
*NCLUDE IBP DLQ.DIM
$INCLUDE IBP DLQ.EQUATES
*
!
*
DLQ.FL = TRUE
OPEN "DLQ" TO DLQ.FILE ELSE
PRINT CLB:"Can't open DLQ File, delinquency won't be used.":
DLQ.FL = FALSE
END
READ MEMO.DAYS FROM PAR.FILE,"MEMO.DAYS" ELSE MEMO.DAYS = 5
WKO.IDS = EMPTY
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DELAY
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
!
*
PRINT.BATCH: *
*
IF LPT.FL AND LPT.DETAIL.FL THEN
PRINT @(ZERO,22):CLL:"Printing batch list ... one moment please ...":
END
PG = ONE; LN = 99; MAX.LN = 55
DISP.COUNT = ONE
IF LPT.FL THEN CALL LPT.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
*
LOOP TRANS = CAJ<DISP.COUNT> UNTIL TRANS EQ EMPTY DO
*
IF NOT(LPT.DETAIL.FL) AND LPT.PMT.TYP.FL THEN
*
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" AND BATCH.CLASS.SEL GT ZERO THEN AMOUNT = ZERO ELSE AMOUNT = TRANS<ONE,3>
ADJ.AMOUNT = TRANS<ONE,3> - AMOUNT
*
CURRENCY.TYPE = TRANS<ONE,11>
BEGIN CASE
CASE CURRENCY.TYPE EQ "CH"
BATCH.TOTAL.CHQ = BATCH.TOTAL.CHQ + AMOUNT
CASE CURRENCY.TYPE EQ "CC"
BATCH.TOTAL.CRD = BATCH.TOTAL.CRD + AMOUNT
CASE CURRENCY.TYPE EQ "CD"
BATCH.TOTAL.CDC = BATCH.TOTAL.CDC + AMOUNT
CASE TRUE
BATCH.TOTAL.CSH = BATCH.TOTAL.CSH + AMOUNT
END CASE
*
END ELSE
GOSUB LPT.LINE
END
*
DISP.COUNT = DISP.COUNT + ONE
*
REPEAT
*
IF LPT.DETAIL.FL THEN GOSUB LPT.WO.REPORT
*
RETURN
*
*
!
*
LPT.LINE: *
*
*
IF CSH.TYPE THEN
*
$INCLUDE IBP SYS.INCL.CHK.STD.DELAY
*
$INCLUDE IBP SYS.INCL.STD.DELAY
*
END
*
*
IF LN GT MAX.LN THEN
*
$INCLUDE IBP SYS.INCL.LPT.CO
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.DESC
*
HEADER = TITLE:" Entry  -  ":BATCH.STATUS.DESC:" batch No. ":BATCH.NUM:"  Entered by ":OPERATOR
PRINT SPACE(65 - LEN(HEADER) / TWO):HEADER
HEADER = "Bus.date ":OCONV(BUS.DATE,"D2"):"  Accounting period ":ACCTG.PERIOD:"  "
HEADER = HEADER:"Batch total $":OCONV(BATCH.TOTAL,"MR2"):"  Entered total $":OCONV(ENTERED.TOTAL,"MR2")
IF ADJUST.TOTAL NE EMPTY THEN HEADER = HEADER:"  Adjust total $":OCONV(ADJUST.TOTAL,"MR2")
*
PRINT SPACE(65 - LEN(HEADER) / TWO):HEADER
PRINT
PRINT " T#  Account  Customer name" "L#35":"Type  Amount   Adjust     Description" "L#45":" Old Cust No" "R#46":
PRINT
LN = 6
PG = PG + ONE
*
END; * OF PAGE CHANGE
*
*
ACT.ID = TRANS<ONE,ONE>[ONE,6]
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = EMPTY
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.MEMO
*
IF MEMO.ID NE EMPTY THEN
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = TRANS<ONE,7>:"** Memo WO: ":MEMO.ID:" on ":MEMO.ODT
IF ACT$BALANCE LT MIN.DELINQ.AMT OR ACT$CREDIT.STATUS LT MIN.DELINQ.STAT THEN
WKO.IDS<-ONE> = ACT.ID:VM:MEMO.ID
END
END; * OF MEMO.ID
*
*
IF ACT$PEND.WO.NUMS NE EMPTY THEN
TMP = DCOUNT(ACT$PEND.WO.NUMS,VM)
WKO.DISP = EMPTY
FOR TMP1 = ONE TO TMP
WKO.DISP = WKO.DISP:"** WO: ":ACT$PEND.WO.NUMS<ONE,TMP1>:" "
* IF ACT$BALANCE LT MIN.DELINQ.AMT OR ACT$CREDIT.STATUS LT MIN.DELINQ.STAT THEN
* WKO.IDS<-ONE> = ACT.ID:VM:ACT$PEND.WO.NUMS<ONE,TMP1>
* END
NEXT TMP1
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = TRANS<ONE,7>:WKO.DISP
END ELSE WKO.DISP = EMPTY
*
*
LAST.NAME = FIELD(ACT$CUS.NAME,"*",ONE)
FIRST.NAME = FIELD(ACT$CUS.NAME,"*",TWO)
FULL.NAME = TRIM(FIRST.NAME:" ":LAST.NAME)
IF LEN(FULL.NAME) GT 20 THEN FULL.NAME = TRIM(FIRST.NAME[ONE,ONE]:" ":LAST.NAME)
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" AND BATCH.CLASS.SEL GT ZERO THEN AMOUNT = ZERO ELSE AMOUNT = TRANS<ONE,3>
ADJ.AMOUNT = TRANS<ONE,3> - AMOUNT
*
TRANS.NUM = TRANS<ONE,11>
IF TRANS.NUM[ONE,ONE] EQ "C" THEN
CURRENCY.TYPE = TRANS.NUM[ONE,TWO]
TRANS.NUM = TRANS.NUM[3,9999]
END ELSE CURRENCY.TYPE = "CA"
*
BEGIN CASE
CASE CURRENCY.TYPE EQ "CH"
BATCH.TOTAL.CHQ = BATCH.TOTAL.CHQ + AMOUNT
CASE CURRENCY.TYPE EQ "CC"
BATCH.TOTAL.CRD = BATCH.TOTAL.CRD + AMOUNT
CASE CURRENCY.TYPE EQ "CD"
BATCH.TOTAL.CDC = BATCH.TOTAL.CDC + AMOUNT
CASE TRUE
BATCH.TOTAL.CSH = BATCH.TOTAL.CSH + AMOUNT
END CASE
*
*
PRINT DISP.COUNT "R#3":"  ":TRANS<ONE,ONE> "L#9":FULL.NAME "L#20":" ":TRANS.TYPE "L#4":OCONV(AMOUNT,"MR2ZM") "R#9":OCONV(ADJ.AMOUNT,"MR2ZM") "R#9":"  ":
IF TRANS<ONE,4>[ONE,TWO] NE "a-" THEN PRINT "  ":
*
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC ELSE NULL
*
LN.DISP = EMPTY
IF TRANS<ONE,4> NE EMPTY THEN 
IF LEN(TRANS<ONE,4,ONE>) LT 6 THEN
LN.DISP = TRIM("CH#:":TRANS<ONE,4,ONE>:" ":TRANS.TYPES<TWO,LOC>)
END ELSE
LN.DISP = TRIM(TRANS<ONE,4,ONE>:" ":TRANS<ONE,4, TWO>)
END
END ELSE
LN.DISP = TRIM(TRANS.TYPES<TWO,LOC>)
END
IF LEN(TRANS<ONE,7>) THEN LN.DISP = LN.DISP:", ":TRANS<ONE,7>
IF LEN(TRANS<ONE,6>) THEN LN.DISP = TRIM(LN.DISP:", ":TRANS<ONE,6>)
*
IF LEN(LN.DISP) LE 54 THEN
PRINT LN.DISP "L#54":
PRINT "  ":TRANS<ONE,5>
*
END ELSE
LN.DISP.CONT = TRUE; LEN.LN.DISP = LEN(LN.DISP)
LOOP
IF LEN(LN.DISP) GT 54 THEN
TC.CN = 54
LOOP
TC = LN.DISP[TC.CN,ONE]
UNTIL NOT(TC.CN) OR TC EQ "," OR (TC.CN LT 25 AND TC EQ " ") DO TC.CN = TC.CN - ONE REPEAT
IF TC.CN LE 10 THEN TC.CN = 54
END ELSE TC.CN = LEN(LN.DISP)
IF NOT(LN.DISP.CONT) THEN PRINT SPACE(61):
PRINT LN.DISP[ONE,TC.CN] "L#54":
IF LN.DISP.CONT THEN
PRINT "  ":TRANS<ONE,5>
LN.DISP.CONT = FALSE
END ELSE
PRINT
END
LN.DISP = TRIM(LN.DISP[TC.CN+ONE,99999])
LEN.LN.DISP = LEN(LN.DISP)
WHILE LEN.LN.DISP DO LN = LN + ONE REPEAT
END
*
*
LN = LN + ONE
*
RETURN
*
! Update Status
*
UPDATE.STATUS: *
*
*IF BATCH.STATUS EQ "P" THEN 
*BATCH.STATUS = "Z"
*GOSUB UPDATE.FILE
*END
*
! Print Work Order Report
*
LPT.WO.REPORT: *
*
LINE = EMPTY; LN = MAX.LN + ONE
*
LOOP WHILE LEN(WKO.IDS) DO
*
LINE = EMPTY
FOR TMP = ONE TO 6 UNTIL NOT(LEN(WKO.IDS))
LINE = LINE:WKO.IDS<ONE,ONE> "L#8":WKO.IDS<ONE,TWO> "L#12"
DEL WKO.IDS<ONE>
NEXT TMP
*
IF LN GT MAX.LN THEN
PRINT FF:TIMEDATE() "L#25":(SPACE(40 - LEN(CO.NAME) / TWO):CO.NAME) "L#80":("Page ":PG) "R#25"
HEADER = "Work Orders to be Checked by Dispatcher"
PRINT SPACE(65 - LEN(HEADER) / TWO):HEADER
PRINT
HEADER = EMPTY
FOR TMP = ONE TO 6
HEADER = HEADER:"Account" "L#8":"Work Order" "L#12"
NEXT TMP
PRINT HEADER "L#130"
PRINT
PG = PG + ONE; LN = 6
END
*
PRINT LINE
PRINT
LN = LN + TWO
*
REPEAT
*
*
IF LPT.FL THEN CALL LPT.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
PRINT @(ZERO,22):CLL:
*
RETURN
*
!
*
END
~CASH.SUBR.PRINT.RECEIPT~
SUBROUTINE CASH.SUBR.PRINT.RECEIPT(MAT CNT.CSH,CNT.CSH.ID,PAYMENT.TYPE,AMOUNT,STD.DESC,PORT.CC)
* VERSION: 930929 2.1  TO BYPASS CUSTOM RECEIPT IF LEN IS ***.
* PRIOR: 930907 2.0  ADDED: PRINTER CONTROLS, @PAYMENT@. REVISED SOME @s.
* PRIOR: 930601 1.0  NEW
*
* COPYRIGHT:         AXION COMPUTER SYSTEMS LTD.
*   1993                 ALL RIGHTS RESERVED
*
* DESCRIPTION:  PRINTS A CUSTOM OR DEFAULT PAYMENT RECEIPT
*               RECEIPT IS PRINTED TO AUX.SUBR PRINTER
*                              - OR -
*                         TO PRINTER QUEUE 6
*
* TESTING: SYS.TST IS SET BY CASH.PRINT.TEST.RECEIPT
*          IF SYS.TST IS SET DON'T OPEN THE TILL 
*          IF SYS.TST IS VALUE 1 THEN SEND RECEIPT TO Q0
*          IF SYS.TST IS VALUE 2 THEN SEND RECEIPT TO Q6.
*          IF SYS.TST IS VALUE 3 THEN SEND RECEIPT TO AUX PRINTER
!
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
$INCLUDE IBP ACT.EQUATES
*
!
*
PTR.ON = ""; PTR.OFF = ""; REG.FONT = ""; COMP.FONT = ""
*
MAIN: *
*
! Open cash drawer
*
IF NOT(SYS.TST<1>) THEN
TST.HDR = ""
CALL AUX.SUBR.ON(STAT)
CALL CASH.SUBR.OPEN.TILL(PAR.FILE,MAT CNT.CSH,CNT.CSH.ID,PORT.CC,STAT)
CALL AUX.SUBR.OFF(STAT)
IF STAT THEN RETURN
END ELSE
TST.HDR = " ** TEST ** "
END
*
! Prepare Printer
*
PTR.TYPE = PORT
* PRT.TYPE = CNT.CSH$TILL.LPT.TYPE<ONE,PORT.CC>
READ PCN FROM PAR.FILE,"PRINTER.":PTR.TYPE ELSE
* PRINT CLB:"Auxillary Printer Type is undefined. Enter <cr>: ":; INPUT TMP:
* ; STAT = 904; RETURN
PCN = ""; AUX.PTR = ""
END
AUX.PTR = PCN<1>
*
IF SYS.TST<1> EQ 3 THEN AUX.PTR = TRUE ELSE
IF SYS.TST<1> THEN AUX.PTR = FALSE
END
*
* THE FOLLOWING WILL BE CHANGED WHEN PC PRINTING IS DEFINED
IF NOT(AUX.PTR) THEN
IF OPSYS EQ "R" THEN PTR.TYPE = "REG" ELSE
IF SYS.TST<1> EQ 1 THEN PTR.TYPE = "Q0" ELSE PTR.TYPE = "Q6"
END
READ PCN FROM PAR.FILE,"PRINTER.":PTR.TYPE ELSE 
PRINT CLB:"Printer Type is undefined. Enter <cr>: ":; INPUT TMP:; STAT = 999; RETURN
END
END
*
LOOP UNTIL PCN<2> = "" DO PTR.ON = PTR.ON:CHAR(PCN<2,1>); DEL PCN<2,1> REPEAT
LOOP UNTIL PCN<3> = "" DO PTR.OFF = PTR.OFF:CHAR(PCN<3,1>); DEL PCN<3,1> REPEAT
LOOP UNTIL PCN<4> = "" DO REG.FONT = REG.FONT:CHAR(PCN<4,1>); DEL PCN<4,1> REPEAT
LOOP UNTIL PCN<5> = "" DO COMP.FONT = COMP.FONT:CHAR(PCN<5,1>); DEL PCN<5,1> REPEAT
BF.SIZE = PCN<6>
BF.WAIT = PCN<7>
*
! Prepare Customer Info
*
CALL MOD11.DIGIT(ACT.ID,CD)
FULL.ACT.ID = ACT.ID:"-":CD
*
LAST.NAME = FIELD(ACT$CUS.NAME,"*",ONE)
FIRST.NAME = FIELD(ACT$CUS.NAME,"*",TWO)
FULL.NAME = TRIM(FIRST.NAME:" ":LAST.NAME)
*
CO.HEADER = "** ** ":CO.DATA<ONE>:" ** **"
* REC.HEADER = "Receipt for payment received from"
REC.HEADER = TST.HDR:"RECEIPT"
APT = FIELD(ADD.ID,"*",ONE); HOUSE = FIELD(ADD.ID,"*",TWO); STT.ID = FIELD(ADD.ID,"*",3)
IF STT.ID THEN
MATREAD STT FROM STT.FILE,STT.ID ELSE MAT STT = EMPTY
STREET = STT(ONE); CITY = STT(TWO)
ADDRESS = HOUSE:" ":STREET; IF APT NE EMPTY THEN ADDRESS = APT:"-":ADDRESS
END ELSE ADDRESS = "Billing only"; CITY = EMPTY
SVC.ADDR = EMPTY
*
NEW.BALANCE = ACT$BALANCE - AMOUNT
*
! Load currency info
*
CURRENCY.TYPE = PAYMENT.TYPE[ONE,TWO]
TRANS.NUM = PAYMENT.TYPE[3,9999]
BEGIN CASE
*
CASE CURRENCY.TYPE EQ "CH"
CURRENCY.DESC = "Cheque"
*
CASE CURRENCY.TYPE EQ "CC"
CURRENCY.DESC = "Credit Card"
*
CASE CURRENCY.TYPE EQ "CD"
CURRENCY.DESC = "Debit Card"
*
CASE CURRENCY.TYPE EQ "CA"
CURRENCY.DESC = "Cash"
*
CASE TRUE
CURRENCY.DESC = "Cash"
TRANS.NUM = PAYMENT.TYPE
CURRENCY.TYPE = "CA"
END CASE
*
! Load receipt text from file if present
*
RECP.LEN = 50; RECP.MSK = "R#9"
HDR.ON.FILE = FALSE
*
READ RECP.TXT FROM CNT.FILE,"CASH.RECEIPT.TOP" THEN
*
HDR.ON.FILE = TRUE
*
IF RECP.TXT<ONE>[ONE,3] EQ "***" THEN HDR.ON.FILE = FALSE ELSE
*
IF RECP.TXT<ONE>[ONE,4] EQ "LEN=" THEN
RECP.LEN = TRIM(RECP.TXT<ONE>[5,9999])
DEL RECP.TXT<ONE>
IF NOT(NUM(RECP.LEN)) THEN RECP.LEN = 50
IF RECP.LEN LE 20 THEN RECP.LEN = 20
END
IF NOT(LEN(RECP.TXT)) THEN HDR.ON.FILE = FALSE
*
IF RECP.TXT<ONE>[ONE,4] EQ "MSK=" THEN
RECP.MSK = RECP.TXT<ONE>[5,9999]
DEL RECP.TXT<ONE>
END
*
END
*
LOOP
TMP = INDEX(RECP.TXT,"@FF@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:FF:RECP.TXT[TMP + 4,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@DDMMMYY@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:OCONV(DATE(),"D2"):RECP.TXT[TMP + 9,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@H:M@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:OCONV(TIME(),"MT"):RECP.TXT[TMP + 6,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@PAYMENT@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:OCONV(AMOUNT,"MR2ZM") RECP.MSK:RECP.TXT[TMP + 9,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@OLD.BAL@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:OCONV(ACT$BALANCE,"MR2ZM") RECP.MSK:RECP.TXT[TMP + 9,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@NEW.BAL@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:OCONV(NEW.BALANCE,"MR2ZM") RECP.MSK:RECP.TXT[TMP + 9,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@CURRENCY@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:CURRENCY.DESC:RECP.TXT[TMP + 10,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@CHEQUE.NUM@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:TRANS.NUM:RECP.TXT[TMP + 12,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@ACCOUNT@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:FULL.ACT.ID:RECP.TXT[TMP + 9,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@ADDRESS@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:ADDRESS:RECP.TXT[TMP + 9,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@NAME@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:FULL.NAME:RECP.TXT[TMP + 6,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@SVC.ADDR@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:SVC.ADDR:RECP.TXT[TMP + 10,9999]
REPEAT
*
LOOP
TMP = INDEX(RECP.TXT,"@CO.NAME@",ONE)
WHILE TMP DO
RECP.TXT = RECP.TXT[ONE,TMP-ONE]:CO.DATA<ONE>:TST.HDR:RECP.TXT[TMP + 9,9999]
REPEAT
*
*
END ELSE RECP.TXT = EMPTY
*
RECP.MSK = "L#":RECP.LEN
*
! Printing Area
*
LPT.AREA: *
*
IF CNT.CSH$LPT.PROMPT EQ "Y" THEN
PRT.PROMPT = TRUE
END ELSE
PRT.PROMPT = FALSE
END
*
IF PRT.PROMPT THEN
PRINT CLB:"Print a receipt (N/<cr>)? ":; INPUT PRT.RSP:
END ELSE PRT.RSP = "Y"
*
IF PRT.RSP NE "N" THEN
*
LOOP
*
! Check for printing prompt
*
PRINT @(ZERO,ZERO):
*
! Assign Queue and Turn on Printer
IF NOT(AUX.PTR) THEN EXECUTE "SP-ASSIGN ":PTR.TYPE; * ULT ONLY
IF AUX.PTR THEN CALL AUX.SUBR.ON(STAT) ELSE CALL LPT.SUBR.ON(STAT)
IF STAT THEN RETURN
*
! Set up the default receipt if required.
IF NOT(HDR.ON.FILE) THEN
*
PRINT "  ":STR("*",RECP.LEN)
PRINT
PRINT (SPACE((RECP.LEN - LEN(CO.HEADER)) / TWO):CO.HEADER) RECP.MSK
PRINT (SPACE((RECP.LEN - LEN(REC.HEADER)) / TWO):REC.HEADER) RECP.MSK
PRINT (OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTH")) RECP.MSK
PRINT
PRINT ("Account: " "R#20":FULL.ACT.ID) RECP.MSK
PRINT
PRINT ("Subscriber: " "R#20":FULL.NAME "L#30") RECP.MSK
PRINT
*
PRINT ("Address: " "R#20":ADDRESS "L#30") RECP.MSK
*PRINT ("       : " "R#20":SVC.ADDR1 "L#30") RECP.MSK
*
PRINT
PRINT
PRINT ("Previous Balance: " "R#20":OCONV(ACT$BALANCE,"MR2ZM") RECP.MSK) RECP.MSK
PRINT
*
PRINT ("Payment Received: " "R#20":OCONV(AMOUNT,"MR2ZM") RECP.MSK) RECP.MSK
IF CURRENCY.TYPE NE "CA" THEN
PRINT ((CURRENCY.DESC "R#12":": ") "R#10":TRANS.NUM "L#15") RECP.MSK
END ELSE
PRINT
END
*
PRINT
PRINT ("New Balance: " "R#20":OCONV(NEW.BALANCE,"MR2ZM") RECP.MSK) RECP.MSK
PRINT
*
PRINT "  ":STR("*",RECP.LEN)
PRINT
PRINT
PRINT
*
END ELSE
*
! Print using text from file
*
IF PTR.TYPE = "REG" OR PTR.TYPE = "Q0" THEN FORMFEED = 1 ELSE FORMFEED = 0
IF FORMFEED THEN PRINT FF
RECP.CN = ZERO; RECP.CN.MAX = DCOUNT(RECP.TXT,AM)
LOOP
RECP.CN = RECP.CN + ONE
WHILE RECP.CN LE RECP.CN.MAX DO
TMP.TXT = RECP.TXT<RECP.CN>
PRINT TMP.TXT RECP.MSK
REPEAT
IF FORMFEED THEN PRINT FF
*
END; * Of standard or maintained receipt.text
*
! Turn off auxillary port
*
IF AUX.PTR THEN CALL AUX.SUBR.OFF(STAT) ELSE CALL LPT.SUBR.OFF(STAT)
IF STAT THEN RETURN
*
IF NOT(AUX.PTR) THEN CALL LPT.SUBR.CLOSE(STAT)
*
! Prompt operator for reprint
*
PRINT CLB:"Is Receipt OK (N/<cr>)? ":; INPUT OK.RSP:
IF OK.RSP EQ EMPTY THEN OK.RSP = "Y"
IF OK.RSP EQ "KILL" THEN STAT = 999; RETURN
*
WHILE OK.RSP NE "Y" DO PRINT BELL: REPEAT
*
END; *  Of print prompt
*
!
*
* PRINT CLB:"EP 6 - Enter <cr> . . . ":; INPUT TMP.RSP:
*
*
RETURN
END
~CASH.SUBR.SOURCE.PARSE~
SUBROUTINE CASH.SUBR.SOURCE.PARSE(BATCH.SOURCE.SEL)
*
*
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
!
*
* 0 Cash.or.Adj Entry     (REG)
* 3 Counter Cash          (CTR)
* 4 Lockbox Transactions  (XTR)
* 5 Pay-Per-View Charges  (XPV)
* 6 Late Charges          (LCH)
* 7 Write_Off Adjustments (WRO)
* 9 All batch sources     (ALL)
IF NOT(NUM(BATCH.SOURCE.SEL)) THEN
TMP1 = BATCH.SOURCE.SEL; TMP = EMPTY
LOOP WHILE LEN(TMP1) DO
BEGIN CASE
CASE TMP1[ONE,3] EQ "ALL"
TMP = "9"; TMP1 = "9"
CASE TMP1[ONE,3] EQ "REG"
TMP = TMP:"0"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "ONE"
TMP = TMP:"1"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "TWO"
TMP = TMP:"2"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "CTR"
TMP = TMP:"3"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "XTR"
TMP = TMP:"4"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "XPV"
TMP = TMP:"5"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "LCH"
TMP = TMP:"6"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "WRO"
TMP = TMP:"7"; TMP1 = TMP1[4,9999]
CASE INDEX("012345679",TMP1[ONE,ONE],ONE) AND NOT(INDEX(TMP,TMP1[ONE,ONE],ONE))
TMP = TMP:TMP1[ONE,ONE]; TMP1 = TMP1[TWO,9999]
CASE TRUE
TMP1 = TMP1[TWO,9999]
END CASE
REPEAT
BATCH.SOURCE.SEL = TMP
END
*
RETURN
*
END
~CASH.SUBR.VALIDATE.BATCH~
SUBROUTINE CASH.SUBR.VALIDATE.BATCH(VALID,BATCH.HEADER,DT.OPEN.SEL,DT.OPEN.LOC,PORT.SEL,PORT.LOC,USER.VALID.SEL,USER.VALID.LOC,BATCH.CLASS.CURR,BATCH.SOURCE.CURR)
*PROGRAM: CASH.SUBR.VALIDATE.BATCH
EQU VS TO "930305"
* AUTHORS: DAVID HORMAN for AXION COMPUTER SYSTEMS
* DESCRIPTION:  Enter payments for an account
*
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
!
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
*
!
*
VERSION = " (R:1.0)"
*
* PRINT CLB:"EP 1 - Enter <cr> . . . ":; INPUT TMP.RSP:
*
* LCK.ITM = TRUE; LCK.TYPE = ONE; * LCK.FILE = ZERO; * REV ONLY
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
! Validate Batch
*
VALID = TRUE
*
* Date
IF DT.OPEN.SEL NE "ALL" AND BUS.DATE NE EMPTY THEN
LOCATE BUS.DATE IN DT.OPEN.SEL<ONE,ONE> BY "AR" SETTING DT.OPEN.LOC ELSE VALID = FALSE
END
*
* Port
IF PORT.SEL NE "ALL" AND BATCH.TILL NE EMPTY THEN
LOCATE BATCH.TILL IN PORT.SEL<ONE,ONE> BY "AR" SETTING PORT.LOC ELSE VALID = FALSE
END
*
* Operator
IF USER.VALID.SEL NE "ALL" AND OPERATOR NE EMPTY THEN
LOCATE OPERATOR IN USER.VALID.SEL<ONE,ONE> BY "AR" SETTING USER.VALID.LOC ELSE VALID = FALSE
END
*
IF BATCH.CLASS.CURR NE "6" AND BATCH.CLASS NE EMPTY THEN
IF BATCH.CLASS.CURR NE BATCH.CLASS THEN VALID = FALSE
END
*
IF BATCH.SOURCE.CURR NE "6" AND BATCH.INP.SOURCE NE EMPTY THEN
IF BATCH.SOURCE.CURR NE BATCH.INP.SOURCE THEN VALID = FALSE
END
*
RETURN
~CASH.UNLOCK.XTR~
*PROGRAM: CASH.UNLCK.XTR
*
*      Clear Payments Tape XTR file
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CNT.XTRIND.DIM
*
$INCLUDE IBP CNT.XTRIND.EQUATES
*
!
*
OPEN "FC.XTR" TO XTR.FILE ELSE PRINT "Can't open XTR"; INPUT RSP:; STOP
OPEN "FC.PAR" TO PAR.FILE ELSE PRINT "Can't open PAR"; INPUT RSP:; STOP
OPEN "FC.CNT" TO CNT.FILE ELSE PRINT "Can't open CNT"; INPUT RSP:; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS"; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
*
*
CALL UNLOCK.ITEM(XTR.FILE,"CNT","XTR.CTL",LCK.FILE)
*
*
PRINT CLB:"Lock box is now unlocked. Enter <cr> . . . ":; INPUT TMP:
*
*
END
~DUMMY~
*PROGRAM: DUMMY
*
PRINT "DUMMY"
*
*
END
~GENERATE.LATE.CHARGES~
*PROGRAM:   GENERATE.LATE.CHARGES
* VERSION: 941006 3.0  CHANGED FROM PICK TO REV TESTING. WAS CHARGING ON 1 AGING CATEG. TOO MANY.
* PRIOR: 930111 2.8  ADDED-SCREEN HEADER.
* PRIOR: 920303 2.7  TO DRIVE OFF MIN DELINQ. STATUS
* PRIOR: 911122 1.0  NEW
*
* COPYRIGHT       AXION COMPUTER SYSTEMS LTD.
*   1992             ALL RIGHTS RESERVED
*
* SPECIAL TEST FLAGS:
*   PROG.TEST$9 SUPPRESSES WRITE OF LAST.LATE.RUN ON CNT, LAST.CHARGES.RUN
*   PROG.TEST$10 SUPPRESSES WRITE OF LATE.CHARGES.DATE ON CNT
*   PROG.TEST$11 SUPPRESSES WRITE OF BATCHES AND ACT
!
EQU VS TO " (R:3.0)"
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*
$INCLUDE IBP SVC.DIM
$INCLUDE IBP SVC.EQUATES
*
$INCLUDE IBP RTE.DIM
$INCLUDE IBP RTE.EQUATES
*
$INCLUDE IBP CNT.LATE.DIM
$INCLUDE IBP CNT.LATE.EQUATES
*
$INCLUDE IBP CNT.RSTAT.DIM
$INCLUDE IBP CNT.RSTAT.EQUATES
*
* : * Test Controls
* $INCLUDE IBP CNT.TST.DIM
* $INCLUDE IBP CNT.TST.EQUATES
*
VERSION = VS
*
INPUT A.RUN:
*
!
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "BI.LATE"
PHANTOM.RUN = FALSE; STAT = FALSE
DISP.ONLY = FALSE; SYS.TST = FALSE; REDISP = FALSE
*
CALL CHARGES.SUBR.OPEN(STAT,ACT.FILE,CAJ.FILE,SVC.FILE,RTE.FILE,TAX.FILE,PAR.FILE,CNT.FILE,LCK.FILE)
IF STAT THEN STOP
*
!
*
* LCK.F = 0; * REV ONLY
LCK.TYPE = -3
*
ENTRY.TYPE = 0
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
TITLE = "AI"
TITLE1 = "Validate Uploaded Terminal IDs":VS
TRANS.CLASS = 'b'; TRANS.ITEM = "TRANS.TYPES.BIL"
*
** MAT XPV = EMPTY; MAT CNT.XPVCTL = EMPTY
SOURCE = "B"; LC.SOURCE = CHAR(SEQ(SOURCE)+32)
OPERATOR = "SYS"; OPER = OPERATOR; DEFAULT.TYPE = "IP"; ITEM.COUNT = 0
BATCH.STATUS = "B"; ENTRY.TIME = EMPTY; ENTRY.DATE = EMPTY
POST.DATE = EMPTY; POST.TIME = EMPTY; BUS.DATE = EMPTY; EFF.DATE = EMPTY
TRANS.TYPES = EMPTY; BATCH.DEL.STATUS = FALSE
BATCH.TYPE = EMPTY; BATCH.LPT.DT = EMPTY; BATCH.LPT.TM = EMPTY
***BATCH.CLASS = EMPTY; BATCH.INP.SOURCE = EMPTY; BATCH.LST = EMPTY
BATCH.CLASS = "3"; BATCH.INP.SOURCE = "6"; BATCH.LST = EMPTY
BATCH.TILL = EMPTY; XTR.POST.REG = ""; XTR.POST.ERR = ""; XTR.POST.OTH = ""
RUN.TRANS.CLASS = TRANS.CLASS
RUN.SOURCE = SOURCE; CNT.TST$LBL = ""
RUN.LC.SOURCE = LC.SOURCE
*
XPV.DT.CURR = DATE(); XPV.DT.CURR.ID = EMPTY; XPV.DT = EMPTY; XPV.REC.TYPE.NEXT = EMPTY
VAL.ERRORS = ""; XPV.SEQ = ZERO; XPV.SEQ.LAST = ZERO; XPV.REC.TOT.CN = ZERO; XPV.REC.ERR.CN = ZERO
ATM = 1; XPV.REC.VAL.CN = ZERO; XPV.EVENT.VAL.CN = ZERO; XPV.EVENT.ERR.CN = ZERO; XPV.EVENT.TOT.CN = ZERO
XPV.VAL.VAL.CN = ZERO; XPV.VAL.ERR.CN = ZERO; XPV.VAL.TOT.CN = ZERO
XPV.EVENT.MAN.CN = ZERO; XPV.TYPE = EMPTY; XPV.BAT = ZERO; XPV.BAT.LAST = ZERO
*
START: *
** PRINT @(0,3):CLS:
** IF CNT.TST$LBL THEN PRINT CLB:"Start ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
** *
** $INCLUDE IBP SYS.INCL.LOAD.AUTO
** *
** READ AI.COS FROM COM.FILE,"AI.COS" ELSE AI.COS = ""
** MATREAD CNT.XPVCTL FROM CNT.FILE,"XPV.CTL" ELSE MAT CNT.XPVCTL = EMPTY
** LOCATE DATE() IN CNT.XPVCTL$SPLIT.DT<1> BY "DL" SETTING LOC THEN
** LOOP
** PRINT @(5,3):CLL:"Uploaded PPV Buys have already been processed today.":
** PRINT @(5,4):CLL:"Do you still want to proceed? (Y/<cr>): ":; INPUT TMP:
** IF TMP = "" THEN STOP
** UNTIL TMP = "Y" DO PRINT BELL REPEAT
** END
*
*
!
*
TITLE = "Generate Late Charge ":VERSION; LN = TWO
$INCLUDE IBP DISPLAY.SCREEN.HEADER
CALL CHARGES.SUBR.INPUT(PAR.FILE,CNT.FILE,LCK.FILE,VERSION,SYS,SYS.APPL,SYS.APPL.SUB,TDY,SLCT,SNGL,SL.PMETH,SL.SVC.CAT,SL.FQS,CURR.ACCTG.PERIOD,LAST.LATE.RUN,CO.DATA,CCR,REQ.CD,MIN.CS,MIN.BAL,DCR,PAP.CLIENT.NUM,SVC.SEQ,CYCS,FQC,TITLE,HIGH.DAY,LATEST.CHARGE.DATE,CYCLIT,CYCSEL,CO.NAME,CONTROL.DT,LN,STAT,A.RUN)
*
IF STAT THEN STOP
*
MATREAD CNT.LATE FROM CNT.FILE,"LATE.CHRG" ELSE MAT CNT.LATE = EMPTY
*
READ SYS.TST FROM CNT.FILE,"LC.TEST" ELSE SYS.TST = ""; * CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ JAN 96 CONVERT TST
$INCLUDE IBP SYSTEM.TEST
PRINT @(0,16):CLS:
*
*
!
*
EXEC.OUTPUT = EMPTY; T.CN = ZERO
IF NOT(STAT) THEN
IF NOT(SNGL) THEN
IF LIST.NAME NE EMPTY THEN
EXECUTE 'GET-LIST ':LIST.NAME, //OUT. > EXEC.OUTPUT
END ELSE
LN = LN + TWO
PRINT @(ZERO,LN):CLL:"Now selecting accounts for late charges":@(ZERO,LN + TWO):
EXLN = 'WITH STAT = "A" AND WITH BAL GE "':OCONV(MIN.BAL,"MR2"):'" AND WITH CREDIT.STATUS GE "':MIN.CS:'"'
EXECUTE 'SSELECT ACT ':EXLN
END
* CALL EXEC.SUBR.OUT.PARSE(EXEC.OUTPUT,PAR.FILE,T.CN,ONE,STAT)
EXEC.OUTPUT = EMPTY
END
END
IF STAT THEN STOP
*
RSTAT.ID = "LATE.CHARGES.DATE"
$INCLUDE IBP SYS.INCL.RUN.INIT
RSTAT.RUN = LAST.LATE.RUN
IF NOT(PROG.TEST9) THEN WRITE LAST.LATE.RUN ON CNT.FILE,"LAST.CHARGES.RUN"
CURR.TM = START.TM; RUN.TOTAL = ZERO; LATE.POST = EMPTY; BAT.CN = ZERO
U.CN = 0; U.TM.AVG = 0; C.TM.AVG = 0; C.CN = 0;  S.CN = 0;
*LATEST.CHARGE.DATE
CHARGE.ODT = OCONV(LATEST.CHARGE.DATE,"D2-")
CHARGE.MM = CHARGE.ODT[ONE,TWO]
CHARGE.DD = CHARGE.ODT[4,TWO]
CHARGE.YY = CHARGE.ODT[7,TWO]
DONE = FALSE
*
GOSUB OPEN.BATCH
POST.DATE = EMPTY; POST.TIME =EMPTY; BUS.DATE = CONTROL.DT
EFF.DATE = CONTROL.DT; BATCH.STATUS = "B"
ENTRY.DATE = START.DT; ENTRY.TIME = START.TM; DEFAULT.TYPE = "LC"
BATCH.TOTAL = ZERO; ENTERED.TOTAL = ZERO; ADJUST.TOTAL = ZERO
ITEM.COUNT = ZERO; OPERATOR = "LChrg"; OVERDUE.AMT = 0
BATCH.STATUS = "B"
*
!
*
MAIN.LOOP: *
*
LOOP
*
SKIP.ACCT = TRUE
IF SNGL THEN
LOOP
STAT = FALSE
PRINT @(ZERO,18):CLL:"Enter account number: ":
INPUT ACT.ID:
IF ACT.ID EQ "KILL" OR ACT.ID EQ EMPTY THEN DONE = TRUE ELSE
IF REQ.CD OR COUNT(ACT.ID,"-") THEN ENT.CD = ACT.ID[LEN(ACT.ID),ONE]; ACT.ID = FIELD(ACT.ID[ONE,LEN(ACT.ID) - ONE],"-",ONE) ELSE ENT.CD = EMPTY
IF ENT.CD EQ "+" THEN ENT.CD = "#"
ACT.ID = STR(ZERO,6 - LEN(ACT.ID)):ACT.ID
IF ENT.CD NE "#" THEN IF REQ.CD OR ENT.CD THEN CALL MOD11.DIGIT(ACT.ID,CD); IF CD NE ENT.CD THEN
PRINT CLB:"Invalid check digit":BELL:
STAT = TRUE
END
END
WHILE STAT AND NOT(DONE) DO REPEAT
PRINT CLB:; PRINT @(ZERO,19):
END ELSE
*
READNEXT ACT.ID ELSE DONE = TRUE
IF NOT(DONE) THEN CALL MOD11.DIGIT(ACT.ID,CD)
END
*
*
WHILE NOT(DONE) DO
*
*
C.CN = C.CN + ONE
*
LOOP LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE,LCK.STAT) WHILE LCK.STAT DO REPEAT
*
MATREAD ACT FROM ACT.FILE,ACT.ID THEN
*
IF DIS.ITEM THEN PRINT @(ZERO,10):CLS:"Acct: ":ACT.ID ELSE PRINT @(ZERO,10):"Acct: ":ACT.ID "L#10":
*
GOSUB SL.CYCLE; * : *
IF CYCLE.SELECT THEN
*
LOCATE ACT$PAY.METHOD[ONE,3] IN CNT.LATE$EXEMPT.PAY.METHODS<ONE> SETTING TMP THEN
IF DIS.ITEM THEN PRINT @(ZERO,10):CLL:"Pay method: ":ACT$PAY.METHOD
END ELSE
*
LOCATE ACT$RATE.TYPE[ONE,3] IN CNT.LATE$EXEMPT.RATE.TYPES<ONE> SETTING TMP THEN
IF DIS.ITEM THEN PRINT @(ZERO,10):CLL:"Rate type: ":ACT$RATE.TYPE
END ELSE
*
IF DIS.ITEM THEN PRINT @(ZERO,11):CLL:"Balance: ":ACT$BALANCE
IF ACT$BALANCE GT ZERO THEN
*
****** MIN BAL
IF ACT$BALANCE GE MIN.BAL OR CNT.LATE$EXCLD.MIN.BAL NE "Y" THEN 
*
****** MIN DELINQ
IF DIS.ITEM THEN PRINT @(ZERO,12):CLL:"Credit Status: ":ACT$CREDIT.STATUS
IF ACT$CREDIT.STATUS GE MIN.CS THEN 
*
****** CREDIT STATUS
IF ACT$CREDIT.STATUS GE CNT.LATE$CREDIT.STATUS THEN 
*
TRNT = EMPTY
*
SKIP.ACCT = FALSE
GOSUB APPLY.LATE.CHARGE; * : *
*
IF NOT(SKIP.ACCT) THEN
*
ACT$LAST.LATE.DATE = CHARGE.DT
*
IF NOT(PROG.TEST11) THEN MATWRITE ACT ON ACT.FILE,ACT.ID
*
IF NOT(SNGL) THEN
TMP = TIME()
TMP1 = TMP - CURR.TM
IF TMP1 LT ZERO THEN TMP1 = TMP1 + 86400
U.TM = U.TM + TMP1
U.CN = U.CN + ONE
CURR.TM = TMP
END
*
END; * of not skip.acct or PROG.TEST11
END; * of cr stat ge min delinq stat
END; * of cr stat ge late chrg stat
* END; * of exclude min bal
END; * of act bal gt 0
END; * of act bat gt min bal
END; * of exempt.rate.types
END; * of exempt.pay.methods
END; * of cycle.select
*
END; * of read item
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
*
!
*
IF SKIP.ACCT THEN
TMP = TIME()
TMP1 = TMP - CURR.TM
IF TMP1 LT ZERO THEN TMP1 = TMP1 + 86400
S.TM = S.TM + TMP1
S.CN = S.CN + ONE
CURR.TM = TMP
END
*
ID = ACT.ID
* $INCLUDE IBP SYS.INCL.RUN.DISP.ID
*
B.CN = B.CN + ONE
IF DIS.ITEM OR B.CN GE D.CN THEN
B.CN = ZERO
IF U.CN NE ZERO THEN
U.TM.AVG = INT((U.TM / U.CN) * 100) / 100
END ELSE U.TM.AVG = EMPTY
C.ELP = ((DATE() - START.DT) * 86400) + (TIME() - START.TM)
C.TM.AVG = INT((C.ELP / C.CN) * 100) / 100
PRINT CLL:"Times - Avg.: ":C.TM.AVG "L#5":"  Avg.Update: ":U.TM.AVG "L#5":"  Total: ":OCONV(C.ELP,"MTS"):  "  Last ID: ":ID "L#10":
PRINT CLL:"Counts - Examined: ":C.CN "L#5":"  Skipped: ":S.CN "L#5":"  Updated: ":U.CN "L#5":
IF P.CN THEN PRINT "  Semi-updated: ":P.CN "L#5":
IF DIS.ITEM GT 1 THEN PRINT CLB:BELL:" <cr>":; CALL GET.INPUT(TMP)
END; * of CNT.TST$LBL
*
*
REPEAT
* for not(done)
*
!
*
FINISH: *
*
IF U.CN THEN GOSUB WRITE.BATCH; * : *
*
IF LEN(LATE.POST) THEN
*
XTR.POST.ID = "ADJ.POST"
$INCLUDE IBP XTR.INCL.POST.READ
*
XTR.POST<-ONE> = LATE.POST
*
$INCLUDE IBP XTR.INCL.POST.WRITE
*
END
*
$INCLUDE IBP SYS.INCL.RUN.ELP
*
* $INCLUDE IBP SYS.INCL.RUN.DISP.END
*
IF NOT(SNGL) THEN
*
IF NOT(T.CN) THEN T.CN = C.CN
RSTAT.MISC1 = OCONV(LATEST.CHARGE.DATE,"D2"); RSTAT.MISC2 = OCONV(RUN.TOTAL,"MR2")
IF NOT(PROG.TEST10) THEN
* CALL SYS.SUBR.RUN.INS(CNT.FILE,LCK.FILE,RSTAT.ID,RSTAT.RUN,RSTAT.MAX,START.DT,START.TM,END.DT,END.TM,C.CN,C.TM,U.CN,U.TM,P.CN,P.TM,S.CN,S.TM,RSTAT.MISC1,RSTAT.MISC2,RSTAT.MISC3,RSTAT.MISC4,0,LCK.TYPE,STAT)
END
*
IF NOT(PROG.TEST9) THEN WRITE LAST.LATE.RUN ON CNT.FILE,"LAST.CHARGES.RUN"
* WRITE LATEST.CHARGE.DATE ON CNT.FILE,"LATE.CHARGES.DATE"
*
END; * of sngl
*
STOP
*
!
*
APPLY.LATE.CHARGE: *
*
IF ACT$LAST.LATE.DATE THEN LAST.LATE.DT = ACT$LAST.LATE.DATE ELSE LAST.LATE.DT = 0
*
IF LAST.LATE.DT THEN
OLAST.LATE.DT = OCONV(LAST.LATE.DT,"D")
END ELSE LAST.LATE.DT = ""
IF DIS.ITEM THEN PRINT @(ZERO,13):CLL:"Last charge date: ":OLAST.LATE.DT; PRINT @(ZERO,15):CLL:; PRINT @(ZERO,16):CLL:
*
IF LAST.LATE.DT+20 LT DATE() THEN
CHARGE.AMOUNT = ZERO
*
AGD = FIELD(ACT$AGED.AMTS,"*",ONE)
AGD<2> = FIELD(ACT$AGED.AMTS,"*",TWO)
AGD<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGD<4> = FIELD(ACT$AGED.AMTS,"*",4)
*
OVERDUE.AMT = 0
XCTR = MIN.CS+1
LOOP TMP.AGED = FIELD(ACT$AGED.AMTS,"*",XCTR) UNTIL TMP.AGED = "" DO
OVERDUE.AMT = OVERDUE.AMT+TMP.AGED
XCTR = XCTR+1
REPEAT
*
*
*
IF OVERDUE.AMT THEN
*
***** REVERSE AGING
*
* IF FALSE THEN
AGING.DATE = OCONV(ACT$LAST.AGING.DATE,"D2-")
*???? Does aging date have to be gt charge.date?
AGING.MM = AGING.DATE[ONE,TWO]
AGING.DD = AGING.DATE[4,TWO]
AGING.YY = AGING.DATE[7,TWO]
*
* AGING.DIFF = ((AGING.YY - LAST.LATE.YY) * 12) + (AGING.MM - LAST.LATE.MM) - (AGING.DD LT LAST.LATE.DD)
* AGING.DIFF1 = ((AGING.YY - CHARGE.YY) * 12) + (AGING.MM - CHARGE.MM) - (AGING.DD LT LAST.LATE.DD)
*
*
*
***** CALCULATE CHARGES
*
IF DIS.ITEM = 2 THEN PRINT CLB:"Apply late charge <cr> ":; INPUT TMP:
*
*
* LAST.LATE.MM = LAST.LATE.MM + ONE
* IF LAST.LATE.MM GT 12 THEN LAST.LATE.MM = ONE; LAST.LATE.YY = LAST.LATE.YY + ONE
*
******* CALCULATE MONTH'S CHARGE
*
IF CNT.LATE$APPL.METHOD EQ "M" THEN
* one months charge
CHARGE.MNTHS = ONE
END ELSE
* chrg amt * mths overdue
CHARGE.MNTHS = ZERO
FOR TMP = ONE TO ACT$CREDIT.STATUS
CHARGE.MNTHS = CHARGE.MNTHS + TMP
NEXT TMP
IF CHARGE.MNTHS LT ONE THEN
IF DIS.ITEM = 2 THEN PRINT CLB:"Non-positive late charge <cr> ":; INPUT TMP:
CHARGE.MNTHS = ONE
END
END
*
IF CNT.LATE$CHARGE.TYPE EQ "F" THEN
* fixed
CHARGE.AMOUNT = CHARGE.AMOUNT + CNT.LATE$AMT.OR.PER * CHARGE.MNTHS
END ELSE
* percent
CHARGE.AMOUNT = CHARGE.AMOUNT + INT(CNT.LATE$AMT.OR.PER * OVERDUE.AMT / 10000 * CHARGE.MNTHS)
END
*
IF DIS.ITEM THEN PRINT @(ZERO,14):CLL:"No. of months to apply: ":CHARGE.MNTHS:"   Overdue ":OVERDUE.AMT
* for charges loop
*
*
IF CHARGE.AMOUNT THEN
*
****** WRITE BATCH IF NEEDED
*
IF BAT.CN GE CNT.LATE$CHRG.PER.BTCH THEN
GOSUB WRITE.BATCH
GOSUB OPEN.BATCH
BAT.CN = ZERO
END
*
****** ADD TO BATCH
*
BAT.CN = BAT.CN + ONE
ITEM.COUNT = ITEM.COUNT + ONE
*
TRANS = ACT.ID:CD:VM:"LC":VM:CHARGE.AMOUNT:VM:EMPTY
CAJ<-ONE> = TRANS
*
BATCH.TOTAL = BATCH.TOTAL + CHARGE.AMOUNT
ENTERED.TOTAL = ENTERED.TOTAL + CHARGE.AMOUNT
*
*
****** ADD TO CNT $ TOTAL
*
RUN.TOTAL = RUN.TOTAL + CHARGE.AMOUNT
*
IF DIS.ITEM THEN PRINT @(ZERO,15):"Charge amount: ":CHARGE.AMOUNT
END; * of charge.amount
*
CHARGE.DT = ICONV(CHARGE.MM:"-":CHARGE.DD:"-":CHARGE.YY,"D2-")
IF DIS.ITEM THEN PRINT @(ZERO,16):"New charge date: ":OCONV(CHARGE.DT,"D")
*
END ELSE
*
SKIP.ACCT = TRUE
END; * of charge.cn.max ge one
*
END; * of last charge date test
*
*
RETURN
*
!
*
OPEN.BATCH: *
*
$INCLUDE IBP.CASH CASH.INCL.CLEAR.BATCH
*
CAJ = EMPTY
*
RETURN
*
!
*
WRITE.BATCH: *
*
$INCLUDE IBP.CASH CASH.INCL.NEXT.BATCH
*
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
*
IF NOT(PROG.TEST11) THEN WRITE BATCH.HEADER:AM:CAJ ON CAJ.FILE,BATCH.NUM
CALL UNLOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE)
*
LATE.POST<-ONE> = BATCH.NUM
*
RETURN
*
!
*
ADVANCE.DATE: *
*
TMP = ADT
ADT = OCONV(ADT,"D2-")
DAY = HIGHEST.DAY; MTH = ADT[ONE,TWO] + ADD.MTHS; YEAR = ADT[7,2]
IF Y.PER NE EMPTY THEN
ADT = Y.PER:"-":(YEAR-1)
CALL GET.ICONV(ADT,"D")
LOOP ADT = ADT - ONE UNTIL ADT GT TMP DO
ADT = ADT + ONE 
ADT = OCONV(ADT,"D2-")
DAY = ADT[4,TWO]
MTH = ADT[ONE,TWO] + ADD.MTHS
YEAR = ADT[7,TWO]
IF MTH GT 12 THEN MTH = MTH - 12; YEAR = YEAR + ONE 
LOOP
ADT = MTH:" ":DAY:" ":YEAR; CALL GET.ICONV(ADT,"D")
WHILE ADT = EMPTY DO DAY = DAY - ONE REPEAT
REPEAT
END ELSE
IF MTH GT 12 THEN MTH = MTH - 12; YEAR = YEAR + ONE 
LOOP
ADT = MTH:" ":DAY:" ":YEAR; CALL GET.ICONV(ADT,"D")
WHILE ADT EQ EMPTY DO DAY = DAY - ONE REPEAT
END
*
RETURN
*
!
*
AGE.ACT: *
*
AGE.ON = 0
AGD = FIELD(ACT$AGED.AMTS,"*",ONE) + TRNT
AGD<2> = FIELD(ACT$AGED.AMTS,"*",TWO)
AGD<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGD<4> = FIELD(ACT$AGED.AMTS,"*",4)
IF BILLING.DATE GT ACT$LAST.BILL.DATE THEN
ACT$LAST.BILL.DATE = BILLING.DATE
IF ACT$BILL.DAY = 31 THEN ADJ.BILLING.DATE = BILLING.DATE + 3 ELSE ADJ.BILLING.DATE = BILLING.DATE
IF ADJ.BILLING.DATE GE ACT$LAST.AGING.DATE THEN
AGE.ON = ONE 
ACT$LAST.AGING.DATE = BILLING.DATE
GOSUB ADVANCE.AGING; * : *
IF ACT$BALANCE LT MIN.BAL THEN AGD = ACT$BALANCE ELSE
IF ACT$STAT NE "A" THEN UAMT = ZERO ELSE GOSUB GET.UAMT; * : *
AGD<4> = AGD<4> + AGD<3>
AGD<3> = AGD<2>
AGD<2> = AGD<1> - UAMT
IF AGD<2> LT 0 THEN AGD<3> = AGD<3> + AGD<2>; AGD<2> = 0
IF AGD<3> LT 0 THEN AGD<4> = AGD<4> + AGD<3>; AGD<3> = 0
AGD<1> = UAMT
END
END
END
DIFF = ACT$BALANCE - AGD<1> - AGD<2> - AGD<3> - AGD<4>
IF DIFF GT 0 THEN AGD<2> = AGD<2> + DIFF ELSE AGD<4> = AGD<4> + DIFF
IF AGD<4> LT 0 THEN AGD<3> = AGD<3> + AGD<4>; AGD<4> = EMPTY
IF AGD<3> LT 0 THEN AGD<2> = AGD<2> + AGD<3>; AGD<3> = EMPTY
IF AGD<2> LT 0 THEN AGD<1> = AGD<1> + AGD<2>; AGD<2> = EMPTY
*
BEGIN CASE
CASE AGD<4>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>:"*":AGD<3>:"*":AGD<4>
CASE AGD<3>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>:"*":AGD<3>
CASE AGD<2>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>
CASE 1;       ACT$AGED.AMTS = AGD<1>
END CASE
*
BEGIN CASE
CASE AGD<4> GE MIN.BAL
IF ACT$CREDIT.STATUS LT 3 THEN ACT$CREDIT.STATUS = 3 ELSE IF ACT$CREDIT.STATUS LT 8 THEN ACT$CREDIT.STATUS = ACT$CREDIT.STATUS + AGE.ON
CASE AGD<3> + AGD<4> GE MIN.BAL
ACT$CREDIT.STATUS = TWO 
CASE AGD<2> + AGD<3> + AGD<4> GE MIN.BAL
ACT$CREDIT.STATUS = ONE 
CASE ONE 
ACT$CREDIT.STATUS = 0
IF ACT$STAT = "A" THEN ACT$DISC.DATE = EMPTY ELSE IF ACT$BALANCE LT 0 AND ABS(ACT$BALANCE) GE MIN.BAL THEN ACT$CREDIT.STATUS = -1
END CASE
*
RETURN
*
!
*
GET.UAMT: *
*
UAMT = 0
* IF ACT$STAT NE "A" THEN RETURN
*
VC = ONE 
LOOP SERVICE = ACT$SERVICES<ONE,VC> UNTIL SERVICE = EMPTY DO
BILL.TO.DATE = ACT$BILL.TO.DATES<ONE,VC>
IF BILL.TO.DATE GE ACT$LAST.AGING.DATE THEN
SDT = ACT$LAST.AGING.DATE; EDT = BILL.TO.DATE
GOSUB GET.TIME; REM.DAYS = DAYS; * : *
LOCATE ACT$LAST.AGING.DATE IN ACT$SVC.CHG.DATES<ONE,VC> BY "DR" SETTING SC ELSE NULL
SDT = ACT$LAST.AGING.DATE; EDT = EMPTY
FOR SC = SC TO ONE STEP -1 UNTIL EDT = BILL.TO.DATE
IF SC = ONE THEN EDT = BILL.TO.DATE; DAYS = REM.DAYS ELSE
EDT = ACT$SVC.CHG.DATES<ONE,VC,SC - 1> - 1; IF EDT GT BILL.TO.DATE THEN EDT = BILL.TO.DATE
GOSUB GET.TIME; REM.DAYS = REM.DAYS - DAYS; * : *
END
GOSUB CALC.UNEARNED; * : *
SDT = EDT + ONE 
NEXT SC
END
VC = VC + ONE 
REPEAT
IF UAMT LT 0 THEN UAMT = 0 ELSE UAMT = OCONV(UAMT,"MR0")
*
RETURN
*
!
*
GET.TIME: *
*
SXDT = OCONV(SDT,"D2-"); EXDT = OCONV(EDT + ONE,"D2-")
YRS = EXDT[7,TWO] - SXDT[7,2]; MTHS = EXDT[ONE,2]-SXDT[1,2]
IF SXDT[4,TWO] GE 28 AND EXDT[4,2] GE 28 THEN DAYS = 0 ELSE DAYS = EXDT[4,2] - SXDT[4,2]
IF DAYS LT 0 THEN DAYS = DAYS + 30; MTHS = MTHS - ONE 
IF MTHS LT 0 THEN MTHS = MTHS + 12; YRS = YRS - ONE 
DAYS = DAYS + (MTHS * 30) + (YRS * 360)
IF DAYS LT 30 THEN DAYS = EDT - SDT + ONE 
*
RETURN
*
!
*
CALC.UNEARNED: *
*
QNTY = ACT$QNTYS<ONE,VC>
RQS = ACT$RATE.QNTYS<ONE,VC,SC>
MTHLY.RATES = ACT$MTHLY.RATES<ONE,VC,SC>
MT.NAMES = ACT$TAX.NAMES<ONE,VC,SC>
MT.AMTS = ACT$TAX.AMTS<ONE,VC,SC>
LOC = ONE 
LOOP RQ = FIELD(RQS,"*",LOC) WHILE RQ DO
QNTY = QNTY-RQ
IF QNTY LT 0 THEN RQ = RQ + QNTY; QNTY = 0
MTHLY.RATE = FIELD(MTHLY.RATES,"*",LOC)
MT.NAME = FIELD(MT.NAMES,"*",LOC)
MT.AMT = FIELD(MT.AMTS,"*",LOC)
MTHS = DAYS / 30
AMT = MTHLY.RATE * MTHS * RQ; UAMT = UAMT + AMT
POS = ONE 
LOOP TAX.NAME = FIELD(MT.NAME,",",POS) UNTIL TAX.NAME = EMPTY DO
TAX.AMT = FIELD(MT.AMT,",",POS) * MTHS * RQ; UAMT = UAMT + TAX.AMT
POS = POS + ONE 
REPEAT
LOC = LOC + ONE 
REPEAT
*
RETURN
*
!
*
ADVANCE.AGING: *
*
ACT$LAST.AGING.DATE = OCONV(ACT$LAST.AGING.DATE,"D2-")
MTH = ACT$LAST.AGING.DATE[ONE,TWO] + 1; YEAR = ACT$LAST.AGING.DATE[7,2]
IF ACT$BILL.DAY THEN DAY = ACT$BILL.DAY ELSE DAY = ACT$LAST.AGING.DATE[4,TWO]
IF DAY GE 28 THEN DAY = 31
IF MTH GT 12 THEN MTH = MTH - 12; YEAR = YEAR + ONE 
LOOP
ACT$LAST.AGING.DATE = MTH:" ":DAY:" ":YEAR; CALL GET.ICONV(ACT$LAST.AGING.DATE,"D")
WHILE ACT$LAST.AGING.DATE = EMPTY DO DAY = DAY - ONE REPEAT
*
RETURN
*
!
*
CALC.BILLING.DATE: *
*
TMP = OCONV(LATEST.CHARGE.DT,"D2-")
MTH = TMP[ONE,TWO]
DAY = TMP[4,TWO]
YEAR = TMP[7,TWO]
IF DAY LT ACT$BILL.DAY THEN MTH = MTH - 1; IF MTH LT ONE THEN MTH = 12; YEAR = YEAR-1
DAY = ACT$BILL.DAY
LOOP
BILLING.DATE = ICONV(MTH:"-":DAY:"-":YEAR,"D")
UNTIL BILLING.DATE DO
DAY = DAY - ONE 
REPEAT
*
RETURN
*
!
*
SL.CYCLE: *
*
CYCLE.SELECT = -1
IF ACT$BILL.TO.DATES<ONE,ONE> THEN ACT$BILL.DAY = OCONV(ACT$BILL.TO.DATES<ONE,ONE> + ONE,"D")[ONE,TWO] ELSE
IF NOT(ACT$BILL.DAY) THEN ACT$BILL.DAY = "01"
END
IF ACT$BILL.DAY GT 27 THEN ACT$BILL.DAY = 31
IF CYCS NE EMPTY THEN
TMP = ACT$BILL.DAY + 0
LOCATE TMP IN CYCS<1> BY "AR" SETTING CYC.NUM ELSE NULL
IF CYCS<ONE,CYC.NUM> = EMPTY THEN CYC.NUM = ONE 
IF FIELD(CYCSEL,"*",CYC.NUM) NE "Y" THEN CYCLE.SELECT = EMPTY
IF DIS.ITEM THEN PRINT @(ZERO,9):"Cycle: ":CYC.NUM:" ":FIELD(CYCSEL,"*",CYC.NUM)
END
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.TST: *
* $INCLUDE IBP TST.INCL.LOAD
!
END
~PPV.BILLING~
SUBROUTINE PPV.BILLING(LCK.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,STAT,LCK.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ,BATCH.HEADER,CONTROL.DATE,A.PERIOD,BATCH.NUM,ENTRY.TYPE,SINGLE,ACT.ID,PVM.ID)
*PROGRAM:   PPV.BILLING
* VERSION: 940808 3.6  CLEAR TAX.AMTS ON EACH EVENT. TOO MUCH TAX CALC'D.
* PRIOR: 940807 3.5  MOVE TAX ACCUM TO WITHIN EVENT LOOP
* PRIOR: 940801 3.4  UPDATE TAX TABLE FOR EACH EVENT0801 3.4
* PRIOR: 940728 3.3  SET CURR.PER.END.DATE (WAS MISSING).
* EXPORTED TO AXION 31-JUL-94
* PRIOR: 930728 3.2  ADDED REPORT.PERIOD TO RPT.ID.
* PRIOR: 920916 3.1  NEW
* DESCRIPTION: PER PER VIEW BILLING
*              1) PROCESSES A BATCH OF PAY PER VIEW TRANSACTIONS
*              2) GENERATES A PPV BILLING TRANSACTION FOR EACH TRANSACTION 
*                 PLACING THE TOTAL AMOUNT IN THE CAJ TRANSACTION.
*              3) UPDATES ACCOUNT'S ATR FOR EACH TRANSACTION
*              4) UPDATES ACG FOR THE BATCH
*              NOTES:
*              UPDATING OF ACG IS BYPASSED IN CASH.LIST.POST
*              BATCH IS LISTED BY CASH.LIST.POST
* TESTING:     USES LOAD.TST
*              CNT.TST$X WILL NOT WRITE ATR,ACT,ACG
*              IN TRANS.LIST.POST.
*
VS = "3.6"; RELEASE = " (3.6)"
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
$INCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP RTE.DIM
$INCLUDE IBP RTE.EQUATES
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP TAX.DIM
$INCLUDE IBP TAX.EQUATES
$INCLUDE IBP RPT.PPV.DIM
$INCLUDE IBP RPT.PPV.EQUATES
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
!
DIM TAX.TABLE(5); MAT TAX.TABLE = ""; STUDIO = ""; * RESERVED
*
CALL BILLING.SUBR.OPEN(STAT,ACT.FILE,ACG.FILE,ATR.FILE,ATH.FILE,ADD.FILE,EFT.FILE,SVC.FILE,RTE.FILE,TAX.FILE,PAR.FILE,CNT.FILE,LCK.FILE)
OPEN "PVM" TO PVM.FILE ELSE PRINT CLB:"Can't open PVM":; INPUT TMP:
OPEN "CAJ" TO CAJ.FILE ELSE PRINT CLB:"Can't open CAJ":; INPUT TMP:
OPEN "PPV.RPT" TO RPT.FILE ELSE PRINT CLB:"Can't open RPT":; INPUT TMP:
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:
* LCK.F = 0; * REV ONLY
*
READ A.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE A.PERIOD = ""
*
READV CURR.PER FROM COM.FILE,"CURR.PPV.REPORT.PERIOD",2 ELSE CURR.PER = A.PERIOD
DAY = 31; MTH = CURR.PER[3,2]; YEAR = CURR.PER[1,2]
LOOP
CURR.PER.END.DATE = ICONV(MTH:" ":DAY:" ":YEAR,"D")
WHILE CURR.PER.END.DATE = "" DO DAY = DAY-1 REPEAT
*
PRINT @(10,8):RVB:"Current Reporting Period is ":CURR.PER:RVE:
*
NEXT.PER = CURR.PER+1
IF NEXT.PER[3,2] > 12 THEN NEXT.PER = NEXT.PER+88
*
SYS.APPL.SUB = "BI"; CNT.TST.ID = SYS.APPL.SUB
GOSUB LOAD.TST
*
LCK.TYPE = -3
CDT = CONTROL.DATE; T.RUN.START = TIME(); CTD = DATE(); B.F.DATE = ""; B.CTR = 0
T.EVENT.RENT = 0; E.CTR = 0; TRAN.ERR = ""; EQU CAJ.ERROR TO 1; SNGL = 0; * TEMPORARY
ST.ZONE = ""; ZONE = ""; MAT ACG = ""; B.NET = 0; AMOUNT = 0
TAX.READ = 0; MTH = ""; DAY = ""; YEAR = ""; LAST.RATE.AREA = ""; CAJ.ERRORS = 0
!
BATCH.SOURCE = FIELD(BATCH.HEADER,"*",1)
BATCH.STATUS = FIELD(BATCH.HEADER,"*",2)
ENTRY.DATE = FIELD(BATCH.HEADER,"*",3); * IS GENERATE DATE
ENTRY.TIME = FIELD(BATCH.HEADER,"*",4); * IS GENERATE TIME
POST.DATE = FIELD(BATCH.HEADER,"*",5)
POST.TIME = FIELD(BATCH.HEADER,"*",6)
BUS.DATE = FIELD(BATCH.HEADER,"*",7)
EFF.DATE = FIELD(BATCH.HEADER,"*",8)
BATCH.TOTAL = 0
ENTERED.TOTAL = 0
ADJUST.TOTAL = FIELD(BATCH.HEADER,"*",11)
DEFAULT.TYPE = FIELD(BATCH.HEADER,"*",12)
ITEM.COUNT = FIELD(BATCH.HEADER,"*",13)
OPER = FIELD(BATCH.HEADER,"*",14)
DEL.STATUS = FIELD(BATCH.HEADER,"*",15)
LPT.DATE = FIELD(BATCH.HEADER,"*",16)
LPT.TM = FIELD(BATCH.HEADER,"*",17)
CLASS = FIELD(BATCH.HEADER,"*",18)
INP.SOURCE = FIELD(BATCH.HEADER,"*",19)
BATCH.LST = FIELD(BATCH.HEADER,"*",20)
*
TDY = DATE()
TMP = OCONV(TDY,"D2-")
MTH = TMP[1,2]
DAY = TMP[4,2]
YEAR = TMP[7,2]
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:
LOOP
ACCTG.DATE = ICONV(MTH:"-":DAY:"-":YEAR,"D")
UNTIL ACCTG.DATE DO
DAY = DAY-1
REPEAT
!
START: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering PPV.BILLING. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
AC = 1
PRINT @(10,16):"Validating PPV Event Numbers":
*
LOOP TRAN = CAJ<AC> UNTIL TRAN = "" DO
*
TRAN.EVENTS = TRAN<1,8>
SVC = 1
LOOP TRAN.EVENT = TRAN.EVENTS<1,1,SVC> UNTIL TRAN.EVENT = "" DO
PVE.ID = TRAN.EVENT
MATREAD PVE FROM PVE.FILE,PVE.ID ELSE 
MAT PVE = ""
INS "Invalid PPV Event Number ":TRAN.EVENT BEFORE CAJ<AC,7,SVC>
CAJ<AC,20,SVC> = CAJ.ERROR
CAJ.ERRORS = CAJ.ERRORS+1
IF CNT.TST$ID THEN
PRINT @(0,17):CAJ<AC,7,SVC>:
IF CNT.TST$CR THEN PRINT CLB:"Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
END; * of PVE not on file
*
IF NOT(CAJ<AC,20,SVC>) THEN
PVM.ID = PVE$PVM.ID
MATREAD PVM FROM PVM.FILE,PVM.ID ELSE
INS "Invalid PPV Master Event" BEFORE CAJ<AC,7,SVC>
CAJ.ERRORS = CAJ.ERRORS+1
CAJ<AC,20,SVC> = CAJ.ERROR
IF CNT.TST$LBL THEN
PRINT @(0,18):CAJ<AC,7,SVC>:
IF CNT.TST$CR THEN PRINT CLB:"Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
END
END
IF CAJ.ERRORS THEN PRINT @(10,19):"Errors detected: ":CAJ.ERRORS "R#6":
*
SVC = SVC+1
REPEAT
*
AC = AC+1
REPEAT
*
IF NOT(SINGLE) THEN
AC = 1
LOOP TRAN = CAJ<AC> UNTIL TRAN = "" DO
*
ACT.ID = TRAN<1,1>; CD = ACT.ID[7,1]; ACT.ID = ACT.ID[1,6]
TRAN.TYPE = TRAN<1,2>
IF TRAN.TYPE = "" THEN TRAN.TYPE = DEFAULT.TYPE
TRAN.AMOUNT = TRAN<1,3>
TRAN.DESC = TRAN<1,4>
TRAN.OLD.ACT = TRAN<1,5>
TRAN.MESSAGES = TRAN<1,6>
TRAN.ERRORS = TRAN<1,7>
TRAN.EVENTS = TRAN<1,8>
TRAN.RSVD = TRAN<1,9>
TRAN.POST = TRAN<1,10>
TRAN.ERR  = TRAN<1,20>
*
IF NOT(TRAN.POST) THEN
GOSUB BILL.ACT
PRINT @(5,15):CLL:"Uploads processed: ":B.CTR "R#5":" Events: ":E.CTR "R#5":
END
*
AC = AC+1
REPEAT
END ELSE
GOSUB BILL.ACT
END
GOTO FINISH
!
BILL.ACT: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering BILL.ACT. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE,LCK.STAT) 
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ACT file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ATR.FILE,"ATR",ACT.ID,LCK.FILE,LCK.STAT) 
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ATR file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
MATREAD ACT FROM ACT.FILE,ACT.ID THEN
*
RATE.TYPE = ACT$RATE.TYPE
PRINT @(10,11):CLL:"Now posting transaction on account no. ":ACT.ID:"-":CD
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = ""
READV GEO FROM ADD.FILE,ACT$ADD.ID,12 ELSE GEO = ""
ZONE = FIELD(GEO,"*",1); IF LEN(ZONE) = 1 THEN ZONE = "0":ZONE
*
*
T.EVENT.RENT = 0; TTX.AMTS = ""; TAX.NAMES = ""; TAX.AMTS = ""; CALC.TAX.AMT = ""; COMPOUND.AMT = ""
TRNT = ""; TTX.NAMES = ""; MTHLY.TAX.AMT = ""; COMPOUND.MTHLY = ""; MTHLY.TAX.NAME = ""
*
AMOUNT = 0; SC = 1; RVC = 1; DMT = 0; DFAMT = 0; TDAMT = 0; RENT = 0
*
*
CALL PACK.NUMBER(TDY,TM); INS TM BEFORE ATR$EFF.DATES<1,1>
CALL PACK.NUMBER(ENTRY.DATE,TM); INS TM BEFORE ATR$ENTRY.DATES<1,1>
CALL PACK.NUMBER(A.PERIOD,TM); INS TM BEFORE ATR$ENTRY.PERIODS<1,1>
INS "V" BEFORE ATR$TYPES<1,1>
INS BATCH.NUM BEFORE ATR$REFS<1,1>
INS "" BEFORE ATR$TOTAL.AMTS<1,1>
INS "" BEFORE ATR$DESCS<1,1>
INS "" BEFORE ATR$SVC.TYPES<1,1>
INS "" BEFORE ATR$SVC.QNTYS<1,1>
INS "" BEFORE ATR$SVC.AMTS<1,1>
INS "" BEFORE ATR$SVC.FROM.DATES<1,1>
INS "" BEFORE ATR$SVC.TO.DATES<1,1>
*
LOOP EVENT = TRAN.EVENTS<1,1,RVC> UNTIL EVENT = "" DO
*
IF NOT(CAJ<AC,20,RVC>) THEN
*
MATREAD PVE FROM PVE.FILE,EVENT ELSE MAT PVE = ""
PVM.ID = PVE$PVM.ID
SHOW.DATE = PVE$DT
SHOW.TIME = PVE$TM
PVE.RATE.CL = PVE$RATE.CL
PVE.RATE.CL.SUB = PVE$RATE.CL.SUB
*
MATREAD PVM FROM PVM.FILE,PVM.ID ELSE MAT PVM = ""
EVENT.CL = PVM$CL
PROG.CL = PVM$PROG.CL
MRKT.CL = PVM$MRKT.CL
EVENT.DESC = PVM$DESC
RATE.CL = PVM$RATE.CL
RATE.CL.SUB = PVM$RATE.CL.SUB
DISTR = PVM$DISTR
STUDIO = PVM$STUDIO
CH.CODE = PVM$CH.CODE
RATE.AREA = FIELD(GEO,"*",5)
*
RTE.ID.TYPE = "PPV*":RATE.CL:"*":RATE.CL.SUB:"*":RATE.TYPE
RTE.ID.STD = "PPV*":RATE.CL:"*":RATE.CL.SUB:"*STD"
RTE.ID = "PPV*":RATE.CL:"*":RATE.CL.SUB
RTE.ON.FILE = TRUE
MATREAD RTE FROM RTE.FILE,RTE.ID.TYPE ELSE
MATREAD RTE FROM RTE.FILE,RTE.ID.STD  ELSE
MATREAD RTE FROM RTE.FILE,RTE.ID ELSE
RTE.ON.FILE = FALSE
END
END
END
*
*
IF RTE.ON.FILE THEN
*
EVENT.RENT = RTE$AMTS<1>
*
* **** RPT FILE UPDATE ****
IF SHOW.DATE GT CURR.PER.END.DATE THEN RPT.PERIOD = NEXT.PER ELSE RPT.PERIOD = CURR.PER
RPT.ID = "PPV*":RPT.PERIOD:"*":DISTR:"*":STUDIO
GOSUB RPT.UPDATE
RPT.ID = RPT.ID:"*":EVENT.CL
GOSUB RPT.UPDATE
RPT.ID = RPT.ID:"*":ACCT:"*":ZONE
GOSUB RPT.UPDATE
*
TAX.NAMES = RTE$TAX.NAMES
LOCATE RATE.AREA IN RTE$AREAS<1> BY "AR" SETTING LOC THEN
AREA.TAX.NAMES = RTE$AREA.TAX.NAMES<1,LOC>
END ELSE AREA.TAX.NAMES = ""
IF TAX.NAMES NE "" AND AREA.TAX.NAMES NE "" THEN TAX.NAMES = TAX.NAMES:","
IF AREA.TAX.NAMES NE "" THEN TAX.NAMES = TAX.NAMES:AREA.TAX.NAMES
GOSUB GET.TAX.DATA
TAX.AMTS = ""; TAX.NAMES = ""; TXN = 1
*
LOOP UNTIL TAX.TABLE(TXN) = "" DO
*
TAX.ON.RENTS = TAX.TABLE(TXN)<5>
*
IF TAX.ON.RENTS THEN
*
TAX.NAME = TAX.TABLE(TXN)<1>
FULL.TAX.NAME = TAX.NAME
IF TAX.NAME[1,1] EQ "+" THEN TAX.NAME = TAX.NAME[2,99]; COMPOUND.FLAG = 1 ELSE COMPOUND.FLAG = 0
LOCATE SHOW.DATE IN TAX.TABLE(TXN)<3> BY "DR" SETTING TAX.VC ELSE TAX.VC = 1
TAX.RATE = TAX.TABLE(TXN)<4,TAX.VC>
*
IF TAX.RATE THEN
LOCATE TAX.NAME IN TAX.NAMES SETTING LOC ELSE TAX.NAMES<LOC> = TAX.NAME
IF COMPOUND.FLAG THEN TEMP = COMPOUND.AMT ELSE TEMP = 0
CALC.TAX.AMT = (OCONV((EVENT.RENT+TEMP)*(TAX.RATE/10),"MR0"))/1000
TAX.AMTS<LOC> = TAX.AMTS<LOC>+CALC.TAX.AMT
COMPOUND.AMT = COMPOUND.AMT+CALC.TAX.AMT
MTHLY.TAX.NAME = MTHLY.TAX.NAME:",":FULL.TAX.NAME
IF COMPOUND.FLAG THEN TEMP = COMPOUND.MTHLY ELSE TEMP = 0
CALC.TAX.AMT = (EVENT.RENT+TEMP)*(OCONV((TAX.RATE/10),"MR0"))/1000
MTHLY.TAX.AMT = MTHLY.TAX.AMT:",":CALC.TAX.AMT
COMPOUND.MTHLY = COMPOUND.MTHLY+CALC.TAX.AMT
END; * of TAX.RATE
*
END; * of TAX.ON.RENTS
*
TXN = TXN+1
*
REPEAT
*
*
CAJ<AC,6> = CAJ<AC,6>:", ":EVENT
AMOUNT = AMOUNT+EVENT.RENT
*
IF CNT.TST$ID THEN
PRINT CLB:"Event ":EVENT:" has been billed for ":EVENT.RENT:
IF CNT.TST$CR THEN PRINT " Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
ATR$SVC.TYPES<1,1,SC> = "i":PVM.ID:"*":EVENT.CL
ATR$SVC.QNTYS<1,1,SC> = "1"
CALL PACK.NUMBER(EVENT.RENT,TM); ATR$SVC.AMTS<1,1,SC> = TM
CALL PACK.NUMBER(SHOW.DATE,TM); ATR$SVC.FROM.DATES<1,1,SC> = TM
CALL PACK.NUMBER(SHOW.TIME,TM); ATR$SVC.TO.DATES<1,1,SC> = TM
*
T.EVENT.RENT = T.EVENT.RENT+EVENT.RENT
*
TAC = 1
LOOP TAX.NAME = TAX.NAMES<TAC> UNTIL TAX.NAME = "" DO
OTHER.TAX.NAME = ""
IF TAX.NAME[1,2] = "O*" THEN OTHER.TAX.NAME = 1; TAX.NAME = TAX.NAME[3,99]
LOCATE TAX.NAME IN TTX.NAMES SETTING LOC ELSE TTX.NAMES<LOC> = TAX.NAME
TTX.AMTS<LOC> = TTX.AMTS<LOC>+TAX.AMTS<TAC>
TAC = TAC+1
REPEAT
*
E.CTR = E.CTR+1; SC = SC+1
*
END ELSE
INS "*** ERROR *** Missing Rate for Event ":EVENT BEFORE CAJ<AC,7,SVC>
MAT RTE = EMPTY
TAX.AMTS = EMPTY; EVENT.RENT = EMPTY; TAX.NAMES = EMPTY; AREA.TAX.NAMES = EMPTY
END; * of RTE.ON.FILE
*
END; * of NOT(CAJ<AC,20,RVC>)
*
RVC = RVC+1
*
REPEAT
*
IF ZONE # ST.ZONE THEN
GOSUB WRITE.ACG
ST.ZONE = ZONE
MAT ACG = ""
END
*
TRANS.TYPE = "rIPV"
GOSUB ACG.UPDATE
*
TAC = 1
LOOP TAX.NAME = TTX.NAMES<TAC> UNTIL TAX.NAME = "" DO
TAX.AMT = OCONV(TTX.AMTS<TAC>,"MR0")
IF TAX.AMT THEN
TRANS.TYPE = "t":TAX.NAME
AMOUNT = TAX.AMT
GOSUB ACG.UPDATE
ATR$SVC.TYPES<1,1,SC> = "t*":TAX.NAME
CALL PACK.NUMBER(TAX.AMT,TM); ATR$SVC.AMTS<1,1,SC> = TM
TRNT = TRNT+TAX.AMT
SC = SC+1
END
TAC = TAC+1
REPEAT
*
TRNT = TRNT+T.EVENT.RENT
CALL PACK.NUMBER(TRNT,TM); ATR$TOTAL.AMTS<1,1> = TM
BATCH.TOTAL = BATCH.TOTAL+TRNT
ACT$BALANCE = ACT$BALANCE+TRNT
*
CAJ<AC,3> = TRNT
*
AGD = FIELD(ACT$AGED.AMTS,"*",1)+TRNT
AGD<2> = FIELD(ACT$AGED.AMTS,"*",2)
AGD<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGD<4> = FIELD(ACT$AGED.AMTS,"*",4)
BEGIN CASE
CASE AGD<4>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>:"*":AGD<3>:"*":AGD<4>
CASE AGD<3>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>:"*":AGD<3>
CASE AGD<2>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>
CASE 1;       ACT$AGED.AMTS = AGD<1>
END CASE
*
** * **** RPT FILE UPDATE ****
** IF SHOW.DATE GT CURR.PER.END.DATE THEN RPT.PERIOD = NEXT.PER ELSE RPT.PERIOD = CURR.PER
** RPT.ID = "PPV*":RPT.PERIOD:"*":DISTR:"*":STUDIO
** GOSUB RPT.UPDATE
** RPT.ID = RPT.ID:"*":EVENT.CL
** GOSUB RPT.UPDATE
** RPT.ID = RPT.ID:"*ACCT*":ZONE
** GOSUB RPT.UPDATE
*
CAJ<AC,10> = DATE() * 100000 + TIME()
IF ATR.FLAG THEN MATWRITE ATR ON ATR.FILE,ACT.ID
IF ACT.FLAG THEN MATWRITE ACT ON ACT.FILE,ACT.ID
*
B.CTR = B.CTR+1
*
*
END ELSE
*
**** ACCOUNT NOT ON FILE
*
END; * of read ACT
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
CALL UNLOCK.ITEM(ATR.FILE,"ATR",ACT.ID,LCK.FILE)
*
IF CNT.TST$ID THEN
PRINT CLB:"Account has been billed for ":TRNT:
IF CNT.TST$CR THEN PRINT " Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
RETURN
!
RPT.UPDATE: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering RPT.UPDATE. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(RPT.FILE,"RPT",RPT.ID,LCK.FILE,LCK.STAT) 
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock RPT file - item ":RPT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
MATREAD RPT FROM RPT.FILE,RPT.ID ELSE MAT RPT = ""
*
LOCATE PVM.ID IN RPT$CURR.EVENTS<1> BY "AL" SETTING RPT.VC ELSE
INS PVM.ID BEFORE RPT$CURR.EVENTS<1,RPT.VC>
INS ""      BEFORE RPT$CURR.PRICES<1,RPT.VC>
INS ""      BEFORE RPT$CURR.BUYS<1,RPT.VC>
INS ""      BEFORE RPT$CURR.REVERSALS<1,RPT.VC>
END
*
LOCATE EVENT.RENT IN RPT$CURR.PRICES<1,RPT.VC> BY "AR" SETTING RPT.SC ELSE
INS EVENT.RENT BEFORE RPT$CURR.PRICES<1,RPT.VC,RPT.SC>
INS ""         BEFORE RPT$CURR.BUYS<1,RPT.VC,RPT.SC>
INS ""         BEFORE RPT$CURR.REVERSALS<1,RPT.VC,RPT.SC>
END
*
RPT$CURR.BUYS<1,RPT.VC,RPT.SC> = RPT$CURR.BUYS<1,RPT.VC,RPT.SC>+1
*
IF ALL.FLAG THEN MATWRITE RPT ON RPT.FILE,RPT.ID
CALL UNLOCK.ITEM(RPT.FILE,"RPT",RPT.ID,LCK.FILE)
RETURN
!
ACG.UPDATE: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering ACG.UPDATE. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
LOCATE "b" IN ACG$SOURCES<1> BY "AL" SETTING SOURCE.LOC ELSE
INS "b" BEFORE ACG$SOURCES<1,SOURCE.LOC>
INS "" BEFORE ACG$TRANS.TYPES<1,SOURCE.LOC>
INS "" BEFORE ACG$AMOUNTS<1,SOURCE.LOC>
INS "" BEFORE ACG$COUNTS<1,SOURCE.LOC>
END
LOCATE TRANS.TYPE IN ACG$TRANS.TYPES<1,SOURCE.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRANS.TYPE BEFORE ACG$TRANS.TYPES<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>
END
ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC> = ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>+AMOUNT
ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC> = ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>+1
RETURN
!
WRITE.ACG: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering WRITE.ACG. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
IF ST.ZONE # "" THEN
ACG.ID = ST.ZONE:"*":ACCTG.DATE
LOOP
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LCK.FILE,LCK.STAT) 
WHILE LCK.STAT DO
PRINT @(0,22):CLL:"You must unlock ACG file - item ":ACG.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
MATREAD SAVE.ACG FROM ACG.FILE,ACG.ID ELSE MAT SAVE.ACG = ""
ACG.VC = 1
LOOP SOURCE = ACG$SOURCES<1,ACG.VC> UNTIL SOURCE = "" DO
LOCATE SOURCE IN SAVE.ACG$SOURCES<1> BY "AL" SETTING SOURCE.LOC ELSE
INS SOURCE BEFORE SAVE.ACG$SOURCES<1,SOURCE.LOC>
INS "" BEFORE SAVE.ACG$TRANS.TYPES<1,SOURCE.LOC>
INS "" BEFORE SAVE.ACG$AMOUNTS<1,SOURCE.LOC>
INS "" BEFORE SAVE.ACG$COUNTS<1,SOURCE.LOC>
END
ACG.SC = 1
LOOP TRANS.TYPE = ACG$TRANS.TYPES<1,ACG.VC,ACG.SC> UNTIL TRANS.TYPE = "" DO
LOCATE TRANS.TYPE IN SAVE.ACG$TRANS.TYPES<1,SOURCE.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRANS.TYPE BEFORE SAVE.ACG$TRANS.TYPES<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE SAVE.ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE SAVE.ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>
END
SAVE.ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC> = SAVE.ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>+ACG$AMOUNTS<1,ACG.VC,ACG.SC>
SAVE.ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC> = SAVE.ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>+ACG$COUNTS<1,ACG.VC,ACG.SC>
ACG.SC = ACG.SC+1
REPEAT
ACG.VC = ACG.VC+1
REPEAT
IF ACG.FLAG THEN MATWRITE SAVE.ACG ON ACG.FILE,ACG.ID
CALL UNLOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LCK.FILE)
UNTIL ACG.ID[1,1] = "$" DO ACG.ID = "$":ST.ZONE:"*":CDT REPEAT
END
RETURN
!
GET.TAX.DATA: *
IF CNT.TST$LBL THEN PRINT CLB:"GET.TAX.DATA":
IF CNT.TST$CR THEN PRINT " Enter <cr>: ":; INPUT TMP:; PRINT CLB:
* TAX.TABLE(TXN)<1> - TAX NAME
* TAX.TABLE(TXN)<2> - RELEVENT TAX.TABLE VC
* TAX.TABLE(TXN)<3> - EFF. DATES
* TAX.TABLE(TXN)<4> - TAX RATES (%)
* TAX.TABLE(TXN)<5> - TAX APPLIC. TO RENTAL
* TAX.TABLE(TXN)<6> - TAX APPLIC. TO SALES
* TAX.TABLE(TXN)<7> - TAX APPLIC. TO OTHER CHARGES
*
* IF RATE.AREA = LAST.RATE.AREA THEN RETURN
TXN = 1; TXN1 = 1; MAT TAX.TABLE = EMPTY
LOOP TAX.ID = FIELD(TAX.NAMES<1>,",",TXN1) UNTIL TAX.ID = "" OR TXN = 5 DO
TAX.TABLE(TXN) = TAX.ID
IF TAX.ID[1,1] = "+" THEN TAX.ID = TAX.ID[2,99]
MATREAD TAX FROM TAX.FILE,TAX.ID THEN
TMP = ",":TAX$EXEMPT.RATE.TYPES:","; TMP1 = ",":FIELD(ACT$RATE.TYPE,"*",1):","
IF INDEX(TMP,TMP1,1) THEN TAX.TABLE(TXN) = ""; TXN = TXN-1 ELSE
TAX.TABLE(TXN)<3> = TAX$EFF.DATES
TAX.TABLE(TXN)<4> = TAX$TAX.RATES
IF TAX$RENTAL.AMT.FLAG = "Y" THEN TAX.TABLE(TXN)<5> = 1
IF TAX$SALES.AMT.FLAG = "Y" THEN TAX.TABLE(TXN)<6> = 1
END
END
TXN = TXN+1; TXN1 = TXN1+1
REPEAT
* LAST.RATE.AREA = RATE.AREA
RETURN
!
FINISH: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering FINISH. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
*** POST.DATE = TDY; POST.TIME = TIME()
ENTERED.TOTAL = BATCH.TOTAL
BATCH.HEADER = BATCH.SOURCE:"*":BATCH.STATUS:"*":ENTRY.DATE:"*":ENTRY.TIME:"*":POST.DATE:"*":POST.TIME:"*"
BATCH.HEADER = BATCH.HEADER:BUS.DATE:"*":EFF.DATE:"*":BATCH.TOTAL:"*":ENTERED.TOTAL:"*"
BATCH.HEADER = BATCH.HEADER:ADJUST.TOTAL:"*":DEFAULT.TYPE:"*":ITEM.COUNT:"*":OPER:"*"
BATCH.HEADER = BATCH.HEADER:DEL.STATUS:"*":LPT.DATE:"*":LPT.TM:"*":CLASS:"*":INP.SOURCE:"*":BATCH.LST
*** IF ALL.FLAG THEN WRITE BATCH.HEADER:AM:CAJ ON CAJ.FILE,BATCH.NUM
GOSUB WRITE.ACG
*
IF CNT.TST$LBL THEN
PRINT CLB:"Exiting FINISH. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
$INCLUDE IBP CLS.ROUTINE
!
END
~TRANS.BILLING.LOADER~
*PROGRAM:           TRANS.BILLING.LOADER
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       AUTOMATIC OVERNIGHT LOAD BILLING AND STATEMENTS
* DATE WRITTEN:      DD MMM 82
* DATE RELEASED:     DD MMM 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
*
READ PAP.CLIENT.NUM FROM PAR.FILE,"PAP.CLIENT.NUM" ELSE PAP.CLIENT.NUM = ""
READ BILLING.CYCLES FROM PAR.FILE,"BILLING.CYCLES" ELSE BILLING.CYCLES = ""
IF BILLING.CYCLES<1,2> = "" THEN BILLING.CYCLES = ""
READ LAST.BILLING.DATES FROM CNT.FILE,"LAST.BILLING.DATE" ELSE LAST.BILLING.DATES = ""
LAST.BILLING.DATE = LAST.BILLING.DATES<1,1>
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE CURR.ACCTG.PERIOD = ""
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE CURR.ACCTG.DATE = ""
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
*
!
BCYC.SEL: *
HIGH.DAY = ""; CYCSEL = ""; CYCLIT = ""
IF BILLING.CYCLES # "" THEN
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Billing and statements - Cycle selection"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
CALL BILLING.CYCLE.SELECT(BILLING.CYCLES,CYCSEL,CYCLIT,RSP)
IF RSP = "KILL" THEN STOP
CYC.NUM = 1
LOOP UNTIL BILLING.CYCLES<1,CYC.NUM> = "" DO
IF FIELD(CYCSEL,"*",CYC.NUM) = "Y" THEN
IF BILLING.CYCLES<1,CYC.NUM> > HIGH.DAY THEN HIGH.DAY = BILLING.CYCLES<1,CYC.NUM>
END
CYC.NUM = CYC.NUM+1
REPEAT
END
!
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Regular billing and statements"
IF CYCLIT # "" THEN TITLE = TITLE:"    ":CYCLIT
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
!
RSP.RELOOP1: *
IF LAST.BILLING.DATE THEN PRINT @(0,4):"Last billing run was to ":OCONV(LAST.BILLING.DATE,"D2"):
MSG = "Enter latest billing date for this run: "
LOOP
PRINT @(0,6):CLL:MSG:
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "^" THEN GOTO BCYC.SEL
IF RSP = "" THEN STOP
LATEST.BILLING.DATE = RSP
CALL GET.ICONV(LATEST.BILLING.DATE,"D")
IF HIGH.DAY THEN
IF HIGH.DAY > 27 THEN
IF OCONV(LATEST.BILLING.DATE,"D2")[3,7] = OCONV(LATEST.BILLING.DATE+1,"D2")[3,7] THEN
LATEST.BILLING.DATE = ""; PRINT CLB:"must be last day of month":
END
END ELSE
TMP = OCONV(LATEST.BILLING.DATE,"D2")[1,2] - HIGH.DAY
IF TMP THEN LATEST.BILLING.DATE = ""; PRINT CLB:"day must be ":HIGH.DAY:
END
END
UNTIL LATEST.BILLING.DATE DO
PRINT BELL:
REPEAT
*
PRINT @(0,6):CLL:MSG:OCONV(LATEST.BILLING.DATE,"D2"):"   ":CYCLIT
EFT.PAYMENT.DATE = LATEST.BILLING.DATE+4
IF PAP.CLIENT.NUM<1> # "" THEN
MSG = "Enter EFT payment date for this run:    "
LOOP
PRINT @(0,7):CLL:MSG:OCONV(EFT.PAYMENT.DATE,"D2")
PRINT @(LEN(MSG),7):
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "^" THEN GOTO RSP.RELOOP1
IF RSP # "" THEN EFT.PAYMENT.DATE = RSP; CALL GET.ICONV(EFT.PAYMENT.DATE,"D")
IF EFT.PAYMENT.DATE THEN
PRINT @(LEN(MSG),7):CLL:OCONV(EFT.PAYMENT.DATE,"D2")
IF EFT.PAYMENT.DATE < LATEST.BILLING.DATE THEN
PRINT CLB:"That's prior to latest billing date - are you sure? ":
INPUT RSP:
PRINT CLB:
IF RSP # "Y" THEN EFT.PAYMENT.DATE = ""
END
END
UNTIL EFT.PAYMENT.DATE DO
EFT.PAYMENT.DATE = LATEST.BILLING.DATE+4
REPEAT
END
*
READV HOLD.FILES FROM PAR.FILE, "STATEMENT.HOLD.FILES",1 ELSE HOLD.FILES = 0
IF HOLD.FILES THEN
STMT.PRINT.DATE = DATE()
PRINT @(0,10):" statements dated ":OCONV(STMT.PRINT.DATE,"D2")
*
DISCON.DATE = STMT.PRINT.DATE+14
LOOP
PRINT @(0,12):CLL:"Enter disconnect date to use on this statement run: ":OCONV(DISCON.DATE,"D2"):@(52,12):
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "" THEN RSP = DISCON.DATE ELSE CALL GET.ICONV(RSP,"D")
UNTIL RSP AND RSP > STMT.PRINT.DATE DO
PRINT BELL:
REPEAT
DISCON.DATE = RSP
PRINT @(0,12):CLL:"Disconnect date used for this statement run: ":OCONV(DISCON.DATE,"D2"):
END
*
PROCS = ""; INPUTS = ""; DESCS = ""
PROCS<1> = "BILLING"; INPUTS<1> = OCONV(LATEST.BILLING.DATE,"D2"):VM:OCONV(EFT.PAYMENT.DATE,"D2"); DESCS<1> = "Bill to ":INPUTS<1>[1,6]
INPUTS<1,9> = CYCSEL
INPUTS<1,10> = CYCLIT
AC = 1
IF PAP.CLIENT.NUM<1> # "" THEN
AC = AC+1
PROCS<AC> = "GENERATE.?"
INPUTS<AC> = ""
DESCS<AC> = "EFT Generation"
END
IF HOLD.FILES THEN
AC = AC+1
PROCS<AC> = "STATEMENTS.?"
INPUTS<AC> = "REGULAR":VM:VM:OCONV(DISCON.DATE,"D2"):VM:VM:CYCSEL:VM:CYCLIT
DESCS<AC> = "Statements"
END
**** W/O COUNTS & TRANS.DAILY.UPD?????? @@@@@
PROCS<AC+1> = "DAILY.UPDATE";       INPUTS<AC+1> = ""; DESCS<AC+1> = "Daily update"
* ULT ONLY
PROCS<AC+2> = "DAILY.REPORT";    INPUTS<AC+2> = ""; DESCS<AC+2> = "Daily report"
CALL AUTO.LOADER(PROCS,INPUTS,DESCS)
*
END
~TRANS.DAILY.LOADER~
*PROGRAM:           TRANS.DAILY.LOADER
* VERSION: 900331 1.9
* PRIOR: ??????
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       LOADS DAILY UPDATE AND REPORT INTO OVERNIGHT PROCESSING..
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    14 MAY 89   HH    TO LOAD REPORT OPTION THRU SPECIAL.ROUTINES.
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
*
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; INPUT RSP; STOP
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; INPUT RSP; STOP
READ ADMIN.AREAS FROM PAR.FILE,"ADMIN.AREAS" ELSE PRINT "Can't read PAR ADMIN.AREAS"; INPUT RSP; STOP
!
VC = 1; CO.NAME = ""
LOOP TRUE.ACCT = ADMIN.AREAS<1,VC> UNTIL TRUE.ACCT = "" OR CO.NAME # "" DO
IF TRUE.ACCT = ACCT THEN CO.NAME = ADMIN.AREAS<2,VC> ELSE LOCATE ACCT IN ADMIN.AREAS<4,VC> SETTING SC THEN CO.NAME = ADMIN.AREAS<2,VC>
VC = VC+1
REPEAT
IF CO.NAME = "" THEN PRINT "Can't locate ADMIN.AREA for ":ACCT:" account"; INPUT RSP; STOP
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Daily Accounting Update/Report - ":OCONV(CURR.ACCTG.DATE,"D2")
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
YEAR = CURR.ACCTG.PERIOD[1,2]; MTH = CURR.ACCTG.PERIOD[3,2]; CURR.PERIOD = YEAR:"-":MTH
MTH = MTH+1; IF MTH > 12 THEN MTH = MTH-12; YEAR = YEAR+1
IF CURR.ACCTG.DATE >= ICONV(MTH:" 1 ":YEAR,"D") THEN
LOOP
PRINT BELL:CLB:"***WARNING*** ":CURR.PERIOD:" month-end has not been run - proceed? (Y/N)":
INPUT RSP:
IF RSP = "N" THEN STOP
UNTIL RSP = "Y" DO REPEAT
END
PRINT CLB:"Press <return> to continue...":; INPUT RSP:; IF RSP = "KILL" THEN STOP
PROCS = "UPDATE.WKO.COUNTS"; INPUTS = "1"; DESCS = "W/O Counts"
PROCS<2> = "TRANS.DAILY.UPD"; INPUTS<2> = "1"; DESCS<2> = "Transaction Updates"
PROCS<3> = "DAILY.UPDATE"; INPUTS<3> = ""; DESCS<3> = "Daily update"
PROCS<4> = "DAILY.REPORT"; INPUTS<4> = "1"; DESCS<4> = "Daily report"; * ULT ONLY
CALL AUTO.LOADER(PROCS,INPUTS,DESCS)
END
~TRANS.DAILY.UPD~
*PROGRAM: TRANS.DAILY.UPD
* AUTHOR: DAVID HORSMAN
*         MACROSCOPE DESIGN MATRIX
*
EQU VS TO " (R:1.2)"
* COMPANY: AXION COMPUTER SYSTEMS
*
* DESCRIPTION:    DELETES OLD BATCHES AND EXECUTES DAILY CASH POSTING
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
MAT CNT.CSH = EMPTY; CNT.CSH.ID = EMPTY
*
*
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
STAT = FALSE
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't find Company Data"; INPUT RSP; STOP
*
*
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; INPUT RSP; STOP
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; INPUT RSP; STOP
READ TRANS.TYPES.ADJ FROM PAR.FILE,"TRANS.TYPES.ADJ" ELSE PRINT "Can't read PAR TRANS.TYPES.ADJ"; INPUT RSP; STOP
READ TRANS.TYPES.PMT FROM PAR.FILE,"TRANS.TYPES.PMT" ELSE PRINT "Can't read PAR TRANS.TYPES.PMT"; INPUT RSP; STOP
READ TRANS.TYPES.DEP FROM PAR.FILE,"TRANS.TYPES.DEP" ELSE TRANS.TYPES.DEP = EMPTY
READ DAILY.REPORT FROM PAR.FILE,"DAILY.REPORT" ELSE DAILY.REPORT = 0
READ DAYS.TO.RETAIN FROM PAR.FILE,"DAYS.TO.RETAIN" ELSE
DAYS.TO.RETAIN = 7
* PRINT "Can't read PAR DAYS.TO.RETAIN"
* INPUT RSP; STOP
END
*
LPT.STAT = FALSE; LN.CN = 999; LN.CN.MAX = 60; PG = ZERO
*
! Load auto * : *
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
! Load Responses or auto.run info * : *
*
IF NOT(AUTO.RUN) THEN
*
*
! Update auto * : *
*
*
EXEC.VERB = "RUN BP.CASH TRANS.DAILY.UPD"
EXEC.IN = EMPTY
EXEC.DESC = "Daily Cash Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
! Initialize program * : *
*
END; * of not auto.run
*
! Start * : *
*
START: *
*
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
* 
! Put up screen header * : *
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
PRINT @(ZERO,ZERO):CLS:
$INCLUDE IBP SYS.INCL.SCR.CO
*
TITLE = SCR.CO
TITLE<TWO> = "Daily Cash Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
TITLEA     = "Audit List Daily Batched Transactions"; *: *
TITLEA<2>  = "Delete Historical Batches"; *: *
TITLEA<3>  = "Clear Till / Operator Controls"; *: *
TITLEA<4>  = "Examine Saved Transactions"; *: *
*
HEADER = TITLE
PRINT @(ZERO,ONE):SPACE(40 - LEN(TITLE<TWO>) / TWO):RVB:TITLE<TWO> "L#40":RVE:
*
! Process Delivered Batches * : *
*
MAIN: *
*
FOR MAIN.CN = ONE TO 4
HEADER = TITLEA<MAIN.CN>
PRINT @(0,MAIN.CN + 3):CLL:@(20,MAIN.CN + 3):RVB:MAIN.CN "R#3":". ":HEADER "L#40":RVE:
ON MAIN.CN GOSUB DAILY.POST,CLEAR.HIST,CLEAR.CNT,UNPOSTED.BATCHES ; * : *
NEXT MAIN.CN
*
! End of program * : *
*
FINISH: *
*
STOP
*
! Daily reconcile / post * : *
*
DAILY.POST: *
*
BATCH.CLASS.TMP = CNT.CSH$EOD.CLASSES.FNL
CALL TRANS.SUBR.CLASS.PARSE(BATCH.CLASS.TMP)
BATCH.SOURCE.TMP = CNT.CSH$EOD.SOURCES.FNL
CALL TRANS.SUBR.SOURCE.PARSE(BATCH.SOURCE.TMP)
*
LOOP WHILE LEN(BATCH.SOURCE.TMP) DO
*
BATCH.SOURCE.CURR = BATCH.SOURCE.TMP[ONE,ONE]
BATCH.SOURCE.TMP = BATCH.SOURCE.TMP[TWO,9999]
*
PRINT @(10,MAIN.CN + 3):RVB:BATCH.SOURCE.CURR "R#3":RVE:
*
LOOP WHILE LEN(BATCH.CLASS.TMP) DO
*
BATCH.CLASS.CURR = BATCH.CLASS.TMP[ONE,ONE]
BATCH.CLASS.TMP = BATCH.CLASS.TMP[TWO,9999]
*
PRINT @(15,MAIN.CN + 3):RVB:BATCH.CLASS.CURR "R#3":RVE:
*
************
*
AUTO.RUN.SUBR    = "0"
CSH.TYPE.CURR    = "0P"
DT.OPEN.CURR     = "RECONCILED"
PORT.CURR        = "ALL"
USER.VALID.CURR  = "ALL"
LPT.DETAIL.CURR  = "DYPE"
POST.FL          = TRUE
*
************
*
EXEC.VERB = "RUN BP.CASH TRANS.LIST.POST"
EXEC.IN = EMPTY
EXEC.IN<-ONE> = AUTO.RUN.SUBR
EXEC.IN<-ONE> = CSH.TYPE.CURR
EXEC.IN<-ONE> = BATCH.CLASS.CURR
EXEC.IN<-ONE> = BATCH.SOURCE.CURR
EXEC.IN<-ONE> = DT.OPEN.CURR
EXEC.IN<-ONE> = PORT.CURR
EXEC.IN<-ONE> = USER.VALID.CURR
EXEC.IN<-ONE> = LPT.DETAIL.CURR
EXEC.IN<-ONE> = POST.FL
*
EXEC.DESC = "Daily Transaction Processing - ":OCONV(CURR.ACCTG.DATE,"D2")
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
************
*
REPEAT
*
REPEAT
*
RETURN
*
! Delete Historical * : *
*
CLEAR.HIST: *
*
*(CAJ): *
*
CAJ.UNPOSTED.IDS = EMPTY; PRINT @(ZERO,MAIN.CN + 7):
CAJ.POSTED.IDS = EMPTY
*
EXEC.TEXT = 'WITH BUSINESS.DATE LE "':OCONV(CURR.ACCTG.DATE,"D2"):'" BY BUSINESS.DATE BY BATCH.STATUS'
PRINT @(ZERO,MAIN.CN + 8):'SSELECT CAJ ':EXEC.TEXT
PRINT
PRINT "Selecting Transaction File . . . "
*
EXECUTE 'SSELECT CAJ ':EXEC.TEXT
*
PRINT
PRINT "Processing Transaction Batches . . . "
PRINT
*
! Totals
*
BAL.CN = ZERO; UNB.CN = ZERO; PST.CN = ZERO
DEL.CN = ZERO; PRT.CN = ZERO; ERR.CN = ZERO; ERP.CN = ZERO
*
! Loop Through Batches * : *
*
LOOP
READNEXT CAJ.ID ELSE CAJ.ID = "@"
UNTIL CAJ.ID EQ "@" DO
*
PRINT CLB:CAJ.ID:
BATCH.NUM = CAJ.ID
*
IF CAJ.ID NE EMPTY THEN
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
READV BATCH.HEADER FROM CAJ.FILE,CAJ.ID,ONE THEN
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
*@@@@ CHECK DELETE FLAG?????? 6 NOV 95
*
BATCH.STATUS = FIELD(BATCH.HEADER,"*",TWO)
*
BEGIN CASE
*
CASE BATCH.STATUS EQ "P"
PST.CN = PST.CN + ONE
*CAJ.POSTED.IDS<-ONE> = CAJ.ID
IF FIELD(BATCH.HEADER,"*",7) LE CURR.ACCTG.DATE - DAYS.TO.RETAIN THEN
DELETE CAJ.FILE,CAJ.ID
END
*
CASE BATCH.STATUS EQ "D"
DEL.CN = DEL.CN + ONE
*CAJ.DELETED.IDS<-ONE> = CAJ.ID
IF FIELD(BATCH.HEADER,"*",7) LE CURR.ACCTG.DATE - DAYS.TO.RETAIN THEN
DELETE CAJ.FILE,CAJ.ID
END
*
CASE TRUE
*CAJ.UNPOSTED.IDS<-ONE> = CAJ.ID
*
END CASE
*
END; * of batch on file
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
END; * Of ID not empty
*
REPEAT
*
RETURN
*
! Clear CNT transaction control items (batch lists) * : *
*
CLEAR.CNT: *
*
*(CNT): *
*
EXEC.TEXT = 'EQ "CSHU]"'
PRINT @(ZERO,6):'SSELECT CNT ':EXEC.TEXT
PRINT
PRINT "Selecting Transaction Control File . . . "
*
EXECUTE 'SSELECT CNT ':EXEC.TEXT
*
PRINT
PRINT "Processing Transaction Batch Lists . . . "
PRINT
*
! Loop Through Batch Lists * : *
*
LOOP
READNEXT CNT.ID ELSE CNT.ID = "@"
UNTIL CNT.ID EQ "@" DO
PRINT CLB:CNT.ID:
IF CNT.ID[ONE,5] EQ "CSHU*" OR CNT.ID[ONE,6] EQ "CSHUD*" THEN
BUS.DT = FIELD(CNT.ID,"*",TWO)
IF BUS.DT LE CURR.ACCTG.DATE - DAYS.TO.RETAIN THEN
DELETE CNT.FILE,CNT.ID
END
END
REPEAT
*
EXEC.VERB = 'CALL-DH.PL COPY.LOCKS.ARC'
PRINT @(ZERO,3):CLS:EXEC.VERB
EXECUTE EXEC.VERB
*
EXEC.VERB = 'CALL-DH.PL COPY.MSGS.ARC'
PRINT @(ZERO,3):CLS:EXEC.VERB
EXECUTE EXEC.VERB
*
EXEC.VERB = 'CALL-DH.PL COPY.AI.ARC'
PRINT @(ZERO,3):CLS:EXEC.VERB
EXECUTE EXEC.VERB
*
RETURN
*
! CNT closed dates * : *
*
CLEAR.CLOSED.DT: *
*
*(CNT): *
*
DT.CN = ZERO; DT.CN.MAX = DCOUNT(CNT$DT.OPEN<ONE>,VM)
LOOP
DT.CN = DT.CN + ONE
WHILE DT.CN LE DT.CN.MAX DO
IF CNT$DT.CLOSED<ONE,DT.CN> EQ "P" THEN
DEL CNT$DT.OPEN<ONE,DT.CN>
DEL CNT$DT.CLOSED<ONE,DT.CN>
DT.CN = DT.CN - ONE
DT.CN.MAX = DT.CN.MAX - ONE
END
REPEAT
*
RETURN
*
! Unposted Batches Report * : *
*
UNPOSTED.BATCHES: *
*
*
EXECUTE "BLOCK-PRINT ":ACCT:" (P"
*
CALL PRINTER.SUBR.ON(LPT.STAT)
*
GOSUB LPT.PAGE
*
PRINT "**** Total Number Of Deleted Batches ****"
PRINT
*
EXEC.VERB = "COUNT CAJ WITH F1.15"
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
*
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE>
DEL EXEC.OUT<ONE>
REPEAT
*
CALL PRINTER.SUBR.OFF(LPT.STAT)
*
EXECUTE "LIST.CAJ.ERR CAJ * * * (P"
*
EXECUTE "LIST.CAJ.OPEN CAJ * * * (P"
*
*@*CALL PRINTER.SUBR.ON(LPT.STAT)
*@**
*@*PRINT; LN.CN = LN.CN + ONE
*@*CAJ.ID.AC = ONE
*@**
*@*LOOP CAJ.ID = CAJ.UNPOSTED.IDS<CAJ.ID.AC> UNTIL CAJ.ID EQ EMPTY DO
*@**
*@*READV BATCH.HEADER FROM CAJ.FILE,CAJ.ID,ONE THEN
*@**
*@*LINE = "Unposted "
*@**
*@*BEGIN CASE
*@*CASE FIELD(BATCH.HEADER,"*",ONE) EQ "C" 
*@*LINE = LINE:"Cash"
*@*CASE FIELD(BATCH.HEADER,"*",ONE) EQ "D" 
*@*LINE = LINE:"Dep."
*@*CASE FIELD(BATCH.HEADER,"*",ONE) EQ "A"
*@*LINE = LINE:"Adj."
*@*CASE FIELD(BATCH.HEADER,"*",ONE) EQ "B"
*@*LINE = LINE:"Bil."
*@*CASE TRUE
*@*LINE = LINE:"????"
*@*END CASE
*@**
*@*LINE = LINE:" Batch No. ":CAJ.ID
*@*LINE = LINE:" Status ":FIELD(BATCH.HEADER,"*",TWO)
*@*LINE = LINE:" dated ":OCONV(FIELD(BATCH.HEADER,"*",7),"D2")
*@*LINE = LINE "L#100":FIELD(BATCH.HEADER,"*",12) "R#5":OCONV(FIELD(BATCH.HEADER,"*",10),"MR2M") "R#14"
*@**
*@*LN.CN = LN.CN + ONE
*@*IF LN.CN GT LN.CN.MAX THEN GOSUB LPT.PG
*@**
*@*PRINT LINE
*@**
*@*END; * Of batch on file
*@**
*@*CAJ.ID.AC = CAJ.ID.AC + ONE
*@**
*@*REPEAT
*@**
*@*!
*@**
*@*TMP = DCOUNT(CAJ.POSTED.IDS,AM)
*@*IF TMP THEN
*@*IF TMP EQ ONE THEN
*@*LINE = "There is one posted batch retained on file."
*@*END ELSE
*@*LINE = "There are ":TMP:" posted batches retained on file."
*@*END
*@*PRINT
*@*PRINT LINE
*@*LN.CN = LN.CN + TWO
*@*END
*@**
*@*CALL PRINTER.SUBR.OFF(LPT.STAT)
*
RETURN
*
!
*
CLEAR.LOCKS: *
*
EXEC.VERB = 'CALL-DH.PL ARC.LOCKS.COPY'
PRINT @(ZERO,3):CLS:EXEC.VERB
EXECUTE EXEC.VERB
*
EXEC.VERB = 'CALL-DH.PL ARC.LOCKS.PORT.COPY'
PRINT @(ZERO,3):CLS:EXEC.VERB
EXECUTE EXEC.VERB
*
RETURN
*
!
*
LPT.PG: *
*
IF LN.CN LT LN.CN.MAX THEN LN.CN = LN.CN + ONE; RETURN
*
PG = PG + ONE
LN.CN = 4
*
PRINT FF:TIMEDATE() "L#25":(SPACE(40 - LEN(TITLE<ONE>) / TWO):TITLE<ONE>) "L#80":("Page ":PG) "R#25"
PRINT SPACE(65 - LEN(TITLE<TWO>) / TWO):TITLE<TWO>
IF LEN(TITLE<3>) THEN PRINT SPACE(65 - LEN(TITLE<3>) / TWO):TITLE<3>; LN.CN = LN.CN + ONE
PRINT
PRINT HEADER<ONE>
IF LEN(HEADER<TWO>) THEN PRINT HEADER<TWO>; LN.CN = LN.CN + ONE
PRINT
*
RETURN
*
!
*
END
~TRANS.LIST.POST~
*PROGRAM: TRANS.LIST.POST 
* VERSION: 921009 1.2   REVISED-FOR-PPV.BILLING
* PRIOR: 920531  1.1  REVISED-FOR-PAY-PER-VIEW
* PRIOR: 910611 1.0  NEW
EQU VS TO ' (R:1.2)'
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1991              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
* DESCRIPTION:     THIS PROGRAM PROCESSES THE XTR BATCHES
*                  FROM THE XTR.POST CONTROL ITEM.
*  
* DATE WRITTEN:    29 JUN 91
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  * TITLE = 'Process Transactions' * : *
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
*INCLUDE IBP AAX.DIM
*INCLUDE IBP AAX.EQUATES
*NCLUDE IBP ACG.DIM
* $INCLUDE IBP ACG.EQUATES
*NCLUDE IBP SAVE.ACG.DIM
*INCLUDE IBP SAVE.ACG.EQUATES
*NCLUDE IBP ACT.DIM
*INCLUDE IBP ACT.EQUATES
*NCLUDE IBP ADD.DIM
*INCLUDE IBP ADD.EQUATES
*NCLUDE IBP ATR.DIM
*INCLUDE IBP ATR.EQUATES
*NCLUDE IBP EFT.DIM
*INCLUDE IBP EFT.EQUATES
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
*
MAT CNT.CSH = EMPTY
*
! OPEN files * : *
*
SYS.PROG = 'TRANS.LIST.POST'; VERSION = '2.0'
STAT = FALSE; PHAN.RUN = TRUE
*
CALL TRANS.SUBR.OPEN.LIST.POST(CAJ.FILE)
IF STAT THEN STOP
*
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
SOURCE = '?'; DAVE = FALSE
STAT = FALSE; INPUTS = EMPTY
*
*
! Special parameters for fixing posting run aborts * : *
*
XTR.POST = EMPTY; XTR.POST.ERR = EMPTY; XTR.POST.OTH = EMPTY
XTR.ID.PREF = EMPTY; XTR.ID.FUNC = EMPTY; XTR.ID.SUFF = EMPTY
ENTRY.MODE = ZERO
*
CALL TRANS.SUBR.LOAD.CNTRL(CNT.CSH.ID,MAT CNT.CSH)
IF STAT THEN STOP
*IF STAT THEN STOP
*
! Put up screen header * : *
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
$INCLUDE IBP SYS.INCL.SCR.CO
*
EXEC.REPORT = SCR.CO
TITLE = EMPTY
TITLEA = 'Batched Transactions Processing'
TITLE = TITLEA
TMP = (SPACE(40-LEN(TITLEA)/2):TITLEA) 'L#80'
EXEC.REPORT<-ONE> = TMP
*
! Load auto * : *
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
! Load Responses or auto.run info * : *
*
IF NOT(AUTO.RUN) THEN
*
CSH.TYPE = ZERO; CSH.TYPE.CURR = ZERO
INPUT CSH.TYPE.SEL:
FROM.LIST = INDEX(CSH.TYPE.SEL,'L',ONE)
PHAN.RUN = INDEX(CSH.TYPE.SEL,'P',ONE)
LPTR.ALL = INDEX(CSH.TYPE.SEL,'A',ONE)
POST.ALL = INDEX(CSH.TYPE.SEL,'U',ONE)
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ONE):CLS:RVB:TMP:RVE:
* 0 Regular Posting Run
* L From a get-list
* P Phantom Mode
* A Print all batches
*
BATCH.CLASS = EMPTY; BATCH.CLASS.CURR = EMPTY; BATCH.CLASS.TMP = EMPTY
INPUT BATCH.CLASS.SEL:
CALL TRANS.SUBR.CLASS.PARSE(BATCH.CLASS.SEL)
IF STAT THEN STOP
* IF BATCH.CLASS.SEL EQ '9' AND NOT(FROM.LIST) THEN BATCH.CLASS.SEL   = '0123'
* 0 Regular Adjustments (ADJ)
* 1 Regular Payments    (PMT)
* 2 Regular Deposits    (DEP)
* 3 Special Billing     (BIL)
* 9 All Batch Types     (ALL)
*
BATCH.SOURCE = EMPTY; BATCH.SOURCE.CURR = EMPTY; BATCH.SOURCE.TMP = EMPTY
INPUT BATCH.SOURCE.SEL:
CALL TRANS.SUBR.SOURCE.PARSE(BATCH.SOURCE.SEL)
IF STAT THEN STOP
* IF BATCH.SOURCE.SEL EQ '9' AND NOT(FROM.LIST) THEN BATCH.SOURCE.SEL = '034567'
INP.SOURCE.DESCS = 'REG':AM:'ONE':AM:'TWO':AM:'CTR':AM:'XTR':AM:'XPV':AM:'LCH':AM:'WRO':AM:'888':AM:'ALL'
* 0 Delivered Entry      (REG)
* 3 Counter Cash         (CTR)
* 4 Lockbox Transactions (XTR)
* 5 Pay-Per-View Charges (XPV)
* 6 Late Charge Trans.   (LCH)
* 7 Write Offs Trans.    (WRO)
* 9 All batch sources    (ALL)
*
INPUT DT.OPEN.SEL:
EXEC.VERB.SEL = EMPTY
IF DT.OPEN.SEL[ONE,3] EQ 'SEL' THEN EXEC.VERB.SEL = DT.OPEN.SEL[4,9999]
INPUT PORT.SEL:
INPUT USER.VALID.SEL:
INPUT LPT.DETAIL.SEL:
IF NOT(INDEX(LPT.DETAIL.SEL,'T',ONE) OR INDEX(LPT.DETAIL.SEL,'P',ONE)) THEN
LPT.DETAIL.SEL = LPT.DETAIL.SEL:'P'
INPUT POST.FL:
* 
! Perform Screen Selection Criteria * : *
*
CALL TRANS.SUBR.LIST.SELECT(TITLE,MAT CNT.CSH,CNT.CSH.ID,CHSU,CSHU.ID,CSHUD,CSHUD.ID,CONTROL.DT,CSH.TYPE.SEL,EXEC.VERB.SEL,BATCH.CLASS.SEL,BATCH.SOURCE.SEL,DT.OPEN.SEL,PORT.SEL,USER.VALID.SEL,LPT.DETAIL.SEL,POST.FL,INPUTS,AUTO.RUN,PHAN.RUN)
IF STAT THEN STOP
*
! Update Inputs for auto.run * : *
*
INPUTS          = CSH.TYPE.SEL
INPUTS<ONE,TWO> = BATCH.CLASS.SEL
INPUTS<ONE,3>   = BATCH.SOURCE.SEL
INPUTS<ONE,4>   = DT.OPEN.SEL
INPUTS<ONE,5>   = PORT.SEL
INPUTS<ONE,6>   = USER.VALID.SEL
INPUTS<ONE,7>   = LPT.DETAIL.SEL
INPUTS<ONE,8>   = POST.FL
INPUTS<ONE,9>   = EXEC.VERB.SEL
*
END ELSE
*
! This is an auto run * : *
*
CSH.TYPE.SEL     = CURRENT.RUN<ONE,TWO>
BATCH.CLASS.SEL  = CURRENT.RUN<ONE,3>
BATCH.SOURCE.SEL = CURRENT.RUN<ONE,4>
DT.OPEN.SEL      = CURRENT.RUN<ONE,5>
PORT.SEL         = CURRENT.RUN<ONE,6>
USER.VALID.SEL   = CURRENT.RUN<ONE,7>
LPT.DETAIL.SEL   = CURRENT.RUN<ONE,8>
POST.FL          = CURRENT.RUN<ONE,9>
EXEC.VERB.SEL    = CURRENT.RUN<ONE,10>
*
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ONE):RVB:TMP:RVE:
*
END
*
*
! Update auto * : *
*
*
EXEC.VERB = 'RUN BP TRANS.LIST.POST'
EXEC.IN = INPUTS
EXEC.DESC = 'Post Batches from Lists  ':CSH.TYPE.SEL:',':BATCH.SOURCE.SEL:',':BATCH.CLASS.SEL
*
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
$INCLUDE IBP SYS.INCL.UPD.AUTO
END
*
! Initialize program * : *
*
BATCH.SOURCE.CURR = EMPTY; BATCH.TYPE.CURR = BATCH.CLASS.SEL[ONE,ONE]
DT.OPEN.CURR = EMPTY; PORT.CURR = EMPTY; USER.VALID.CURR = EMPTY
LIST.TO.POST = EMPTY; FROM.LIST = FALSE; END.OF.LIST = FALSE
LIST.TO.POST.DONE = EMPTY
XTR.ID.DT = '@':DATE()
*
FROM.LIST = INDEX(CSH.TYPE.SEL,'L',ONE)
*
PHAN.RUN = INDEX(CSH.TYPE.SEL,'P',ONE)
LPTR.ALL = INDEX(CSH.TYPE.SEL,'A',ONE)
POST.ALL = INDEX(CSH.TYPE.SEL,'U',ONE)
*
IF LEN(EXEC.VERB.SEL) THEN FROM.LIST = TRUE
*
** CALL TRANS.SUBR.CLASS.PARSE(BATCH.CLASS.SEL)
** IF STAT THEN STOP
** IF BATCH.CLASS.SEL EQ '9' THEN BATCH.CLASS.SEL   = '0123'
IF BATCH.CLASS.SEL EQ '9' AND NOT(FROM.LIST) THEN BATCH.CLASS.SEL   = '0123'
** *
** CALL TRANS.SUBR.SOURCE.PARSE(BATCH.SOURCE.SEL)
** IF STAT THEN STOP
** IF BATCH.SOURCE.SEL EQ '9' THEN BATCH.SOURCE.SEL = '034567'
IF BATCH.SOURCE.SEL EQ '9' AND NOT(FROM.LIST) THEN BATCH.SOURCE.SEL = '034567'
*
! Call program initialization and lock control info * : *
*
BATCH.CLASS.CURR = BATCH.CLASS.SEL[ONE,ONE]
BATCH.SOURCE.CURR = BATCH.SOURCE.SEL[ONE,ONE]
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
CALL TRANS.SUBR.ENTRY.INIT(ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
*
! Lock out transmissions and other updates to transactions * : *
*
IF POST.FL THEN
$INCLUDE IBP.CASH CASH.INCL.LCK.XTR
*
$INCLUDE IBP.CASH CASH.INCL.RELS.XTR
END
*
IF STAT THEN STOP
*
!!
*
! Start of program * : *
*
START: *
*
BUS.DATE = EMPTY
EFF.DATE = EMPTY
POST.DATE = EMPTY
POST.TIME = EMPTY
OPERATOR = EMPTY
DEFAULT.TYPE = EMPTY
BATCH.DEL.STATUS = EMPTY
BATCH.TYPE = EMPTY
BATCH.LPT.DT = EMPTY
BATCH.LPT.TM = EMPTY
BATCH.INP.SOURCE = EMPTY
BATCH.LST = EMPTY
*
!
*
LPT.DETAIL.FL = INDEX(LPT.DETAIL.SEL,'D',ONE)
LPT.SUMMARY.FL = INDEX(LPT.DETAIL.SEL,'S',ONE)
LPT.PMT.TYP.FL = INDEX(LPT.DETAIL.SEL,'Y',ONE)
LPT.FL = NOT(INDEX(LPT.DETAIL.SEL,'T',ONE))
IF NOT(LPT.FL) THEN LPT.FL = INDEX(LPT.DETAIL.SEL,'P',ONE)
*
LN.TOP = 6; LN.BOT = 20; LN.HDR.TOP = TWO
LPT.STAT = FALSE; LPT.CN = ZERO
LPT.PG = ONE; LPT.LN = 99; LPT.LN.MAX = 55
IF NOT(LPT.FL) THEN LPT.LN.MAX = 19
LPT.HEADER = 'Status Description' 'R#19':' Src C Lns ':'Batch#' 'L#6':' ':'Oper.' 'L#5'
LPT.HEADER = LPT.HEADER:' ':'Bus.Date' 'L#10':'Per.' 'L#5':' '
LPT.HEADER = LPT.HEADER:'Post.Date' 'L#10'
LPT.HEADER = LPT.HEADER:'Print.Dt' 'L#10'
*
IF NOT(LPT.FL) THEN LPT.HEADER = LPT.HEADER:CR:LF:SPACE(10)
LPT.HEADER = LPT.HEADER:'Total.Amt' 'R#9':' ':'Entry.Amt' 'R#9':' ':'Adj.Amt' 'R#9'
*
IF LPT.PMT.TYP.FL THEN
LPT.HEADER = LPT.HEADER:CR:LF
IF LPT.FL THEN LPT.HEADER = LPT.HEADER:SPACE(68) ELSE LPT.HEADER = LPT.HEADER:SPACE(10)
LPT.HEADER = LPT.HEADER:'Total.Chq' 'R#9':' ':'Total.Crd' 'R#9':' ':'Total.Dbt' 'R#9':' ':'Total.Csh' 'R#9'
END
*
LPT.TEXT = EMPTY
*
LPT.BATCH.TOTAL = EMPTY; LPT.ENTERED.TOTAL = EMPTY; LPT.ADJUST.TOTAL = EMPTY
LPT.TOTAL.CHQ = EMPTY; LPT.TOTAL.CRD = EMPTY; LPT.TOTAL.CSH = EMPTY; LPT.TOTAL.CDC = EMPTY
*
CNTR.PREV = EMPTY
CNTR.CURR = EMPTY
CNTR.DESC = EMPTY
CNTR.FIRST = TRUE
CNTR.TOTAL = EMPTY
CNTR.DESC = 'COMP':AM:'SRCE':AM:'CLSS':AM:'TYPE':AM:'DATE':AM:'PORT':AM:'OPER'
* 1 *    * 2 *    * 3 *    * 4 *    * 5 *    * 6 *    * 7 *            
* CO     TRAN     TRAN   LIST.TYPE  ENTRY    ENTRY    ENTRY
* TOTS  SOURCE   CLASS  REG/ERR/OTH  DATE     PORT   OPERATOR
*
* ENTERED  ADJUSTMENTS  CONTROL
*
* CASH     CHEQUES      CREDIT CARDS    DEBIT CARDS
*
!
*
BATCH.CLASS.TMP = BATCH.CLASS.SEL
BATCH.SOURCE.TMP = BATCH.SOURCE.SEL
CSH.TYPE.CURR = CSH.TYPE.SEL[ONE,ONE]
*
! Main loop * : *
*
MAIN.LOOP: *
*
! Loop for all types processing * : *
*
LOOP WHILE STAT NE 999 AND ((NOT(FROM.LIST) AND LEN(BATCH.SOURCE.TMP)) OR (FROM.LIST AND NOT(END.OF.LIST))) DO
*
! Process next source * : *
*
BATCH.SOURCE.CURR = BATCH.SOURCE.TMP[ONE,ONE]
BATCH.SOURCE.TMP = BATCH.SOURCE.TMP[TWO,9999]
BATCH.CLASS.TMP = BATCH.CLASS.SEL
*
LOOP WHILE STAT NE 999 AND ((NOT(FROM.LIST) AND LEN(BATCH.CLASS.TMP)) OR (FROM.LIST AND NOT(END.OF.LIST))) DO
*
BATCH.CLASS.CURR = BATCH.CLASS.TMP[ONE,ONE]
BATCH.CLASS.TMP = BATCH.CLASS.TMP[TWO,9999]
*
! Examine type of run * : *
*
CALL TRANS.SUBR.BATCH.ANAL(CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR,DFLT.SOURCE)
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
IF STAT THEN
*
TMP = 'Error in ':ACCT:' on Type:':BATCH.CLASS.CURR:BATCH.SOURCE.CURR:' ':XTR.ID.PREF:'.':XTR.ID.FUNC:'.':XTR.ID.SUFF:'. Error#:':STAT
EXEC.REPORT<-ONE> = TMP
* IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(PHAN.RUN) THEN PRINT ' Enter <cr> . . . ':
* IF NOT(AUTO.RUN OR PHAN.RUN) THEN
* PRINT ' Enter <cr> . . . ':; INPUT TMP:
* END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 10 UNTIL SYSTEM(11) OR PHAN.RUN
* FOR TMP = ONE TO 10; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE 'SLEEP 5'
NEXT TMP
IF NOT(PHAN.RUN) THEN
IF SYSTEM(11) THEN
INPUT TMP:
END
END
* END
*
* EXEC.REPORT<-ONE> = 'TRANSACTIONS in ':ACCT:', Error#:':STAT+0:' on Source:':XTR.ID.PREF:'.':XTR.ID.FUNC:'.':XTR.ID.SUFF
*
STAT = FALSE
*
END; * of STAT
*
IF POST.FL THEN TITLE = 'Post ' ELSE TITLE = 'Report on '
IF NOT(LPT.DETAIL.FL) THEN TITLE = 'Summary ':TITLE
TITLE = TITLE:BATCH.CLASS.CURR.DESC:' Batches '
IF FROM.LIST THEN TITLE = TITLE:'from a List '; CLASS.CN.MAX = ONE
TITLEA = TITLE:'    ':VS
CLS.COL = ZERO; CLS.ROW = 7; GOSUB CLS.ROUTINE
PRINT @(ZERO,7):RVB:(SPACE(40-LEN(TITLEA)/2):TITLEA) 'L#80':RVE:
*
! Lock Application for posting * : *
*
IF POST.FL THEN
PRINT 'Lock Source of transactions . . . ':
$INCLUDE IBP.CASH CASH.INCL.LCK.APPL
END
*
! Read List info * : *
*
IF NOT(PHAN.RUN) THEN
CLS.COL = ZERO; CLS.ROW = 9; GOSUB CLS.ROUTINE
END
IF NOT(FROM.LIST) THEN
PRINT 'Load List . . .   ':
$INCLUDE IBP.CASH CASH.INCL.LOAD.LISTS
END
*
! Loop for class of list (regular or errors) * : *
*
! 2 Cycles for balanced and error batches * : *
*
FOR XTR.TYPE.CN = ONE TO CLASS.CN.MAX UNTIL STAT EQ 999
* PRINT CLB:BELL:'CLASS.CN.MAX IS ':CLASS.CN.MAX:; INPUT TMP:
*
! Read XTR Post record * : *
*
IF NOT(FROM.LIST) THEN
*
IF XTR.TYPE.CN EQ ONE THEN
XTR.ID.SUFF = 'REG'
LIST.TO.POST.ID = XTR.ID.PREF:'.':XTR.ID.FUNC:'.':XTR.ID.SUFF
LIST.TO.POST = XTR.POST.REG
RUN.CLASS = 'REGULAR'
END ELSE IF XTR.TYPE.CN EQ TWO THEN
XTR.ID.SUFF = 'ERR'
LIST.TO.POST.ID = XTR.ID.PREF:'.':XTR.ID.FUNC:'.':XTR.ID.SUFF
LIST.TO.POST = XTR.POST.ERR
RUN.CLASS = 'ERRORS'
END ELSE
XTR.ID.SUFF = 'OTH'
LIST.TO.POST.ID = XTR.ID.PREF:'.':XTR.ID.FUNC:'.':XTR.ID.SUFF
LIST.TO.POST = XTR.POST.OTH
RUN.CLASS = 'OTHER'
END
LIST.TO.POST.DONE = EMPTY
*
! Process list * : *
*
IF NOT(FROM.LIST) AND LIST.TO.POST EQ EMPTY AND POST.FL THEN
*
TMP = 'There are no ':BATCH.CLASS.CURR.DESC:', of Type ':RUN.CLASS:' to post.'
EXEC.REPORT<-ONE> = TMP
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
* IF NOT(AUTO.RUN OR PHAN.RUN) THEN
* PRINT ' Enter <cr> . . . ':; INPUT TMP:
IF NOT(PHAN.RUN) THEN PRINT ' Enter <cr> . . . ':
* END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 10 UNTIL SYSTEM(11) OR PHAN.RUN
* FOR TMP = ONE TO 10; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE 'SLEEP 5'
NEXT TMP
IF NOT(PHAN.RUN) THEN
IF SYSTEM(11) THEN
INPUT TMP:
END
END
* END
*
* EXEC.REPORT<-ONE> = 'TRANSACTIONS IN ':ACCT:' NO ':RUN.CLASS:' POSTED'
*
* STAT = 200
*
END
*
END ELSE
*
! From a list * : *
*
IF EXEC.VERB.SEL NE EMPTY THEN
PRINT EXEC.VERB.SEL
* ULT ONLY
EXECUTE EXEC.VERB.SEL, //SELECT. > CAJ.ID.LIST
* EXECUTE EXEC.VERB.SEL; * REV ONLY
END
*
END; * of not(FROM.LIST)
*
! Display batches * : *
*
IF LPT.DETAIL.FL THEN
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
END ELSE IF NOT(PHAN.RUN) THEN
CLS.COL = ZERO; CLS.ROW = 13; GOSUB CLS.ROUTINE
END
*
! Loop thru batches * : *
*
XTR.CN = ZERO
IF NOT(FROM.LIST) THEN
XTR.CN.MAX = DCOUNT(LIST.TO.POST,AM)
END ELSE
XTR.CN.MAX = 99999
END
*
LOOP
*
! Read next batch * : *
*
XTR.CN = XTR.CN + ONE; CONT = TRUE
IF NOT(FROM.LIST) THEN
CAJ.ID = LIST.TO.POST<XTR.CN>
BATCH.NUM = ('00000':CAJ.ID) 'R#5'
IF (CAJ.ID EQ EMPTY AND (NOT(LEN(LIST.TO.POST)) OR XTR.CN GT XTR.CN.MAX)) THEN CONT = FALSE
END ELSE IF END.OF.LIST THEN
CONT = FALSE; CAJ.ID = EMPTY; BATCH.NUM = EMPTY
END ELSE
* ULT ONLY
READNEXT CAJ.ID FROM CAJ.ID.LIST ELSE
* READNEXT CAJ.ID ELSE; * REV ONLY
CAJ.ID = EMPTY; CONT = FALSE; END.OF.LIST = TRUE
END
BATCH.NUM = ('00000':CAJ.ID) 'R#5'
END
*
* PRINT CLB:BELL:BATCH.NUM:',':CONT:',':STAT:',':XTR.CN:',':XTR.CN.MAX:',':CAJ.ID:',':LIST.TO.POST:; INPUT TMP:
WHILE CONT AND NOT(STAT) DO
*
IF NOT(PHAN.RUN) AND LPT.FL THEN PRINT @(ZERO):BATCH.NUM:'  ':
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
READ CAJ FROM CAJ.FILE,BATCH.NUM THEN
*
! Extract Header * : *
*
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
* IF NOT(DAVE) THEN
* PRINT CLB:'SOURCE ':SOURCE:',':BATCH.SOURCE:
* INPUT DAVE:
* END
*
SOURCE = BATCH.SOURCE; LC.SOURCE = CHAR(SEQ(SOURCE)+32)
RUN.TRANS.CLASS = BATCH.CLASS.CURR
RUN.SOURCE = SOURCE
RUN.LC.SOURCE = LC.SOURCE
*
! Validate Batch * : *
*
VALID = TRUE
*
CALL TRANS.SUBR.VALIDATE.BATCH(VALID,BATCH.HEADER,DT.OPEN.SEL,DT.OPEN.LOC,PORT.SEL,PORT.LOC,USER.VALID.SEL,USER.VALID.LOC,BATCH.CLASS.CURR,BATCH.SOURCE.CURR)
*
IF VALID THEN
*
*
! Display Background * : *
*
IF LPT.DETAIL.FL THEN
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.HDR.FG
END
*
! Set Control Current
*
CNTR.CURR<ONE> = '*'
** CNTR.CURR<TWO> = BATCH.SOURCE
** CNTR.CURR<3>   = BATCH.CLASS
CNTR.CURR<TWO> = BATCH.INP.SOURCE
CNTR.CURR<3>   = BATCH.SOURCE
CNTR.CURR<4>   = XTR.ID.SUFF
CNTR.CURR<5>   = ENTRY.DATE
CNTR.CURR<6>   = BATCH.TILL
CNTR.CURR<7>   = OPERATOR
IF CNTR.FIRST THEN
CNTR.FIRST = FALSE; CNTR.PREV = CNTR.CURR
END
*
! Call Impulse Pay Per View Billing * : *
*
*IF LPT.DETAIL.FL THEN
*IF POST.FL THEN
*IF BATCH.STATUS EQ 'C' THEN
IF ((LPT.DETAIL.FL AND POST.FL) AND (BATCH.STATUS EQ 'C' OR (POST.ALL AND BATCH.STATUS EQ 'D'))) AND NOT(STAT) THEN
*
SINGLE = 0; ACT.ID = ''; PVM.ID = ''
CALL PPV.BILLING(LCK.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,STAT,LCK.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ,BATCH.HEADER,CONTROL.DT,A.PERIOD,BATCH.NUM,BATCH.TYPE,SINGLE,ACT.ID,PVM.ID)
*
BATCH.STATUS = FIELD(BATCH.HEADER,'*',2)
BATCH.TOTAL = FIELD(BATCH.HEADER,'*',9)
ENTERED.TOTAL = FIELD(BATCH.HEADER,'*',10)
*
IF NOT(STAT) THEN BATCH.STATUS = 'D'
*
END; * of DETAIL.FL and POST.FL and 'C'   or  POST.ALL
*END
*END; * Of post.fl
*END; * Of not S
*
! Call Printing routine * : *
*
IF NOT(LPT.DETAIL.FL) THEN
*
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.DESC
*
LPT.CN = LPT.CN + ONE
*
! Detect Control Breaks * : *
*
CNTR.MIN = ZERO
LOOP
CNTR.MIN = CNTR.MIN + ONE
WHILE CNTR.CURR<CNTR.MIN> EQ CNTR.PREV<CNTR.MIN> AND CNTR.MIN LT 8 DO REPEAT
*
! Print Totals
*
IF CNTR.MIN LT 8 THEN
*
GOSUB CHECK.CONTROL; * : *
*
END; * of cntr.min lt 8
*
! Build Report Line * : *
*
INP.SOURCE.DESC = INP.SOURCE.DESCS<BATCH.INP.SOURCE + ONE>
*
IF LPT.LN GE LPT.LN.MAX THEN GOSUB LPT.PAGE
*
*43
LPT.TEXT = BATCH.STATUS.DESC 'R#19':' ':INP.SOURCE.DESC 'L#3':' ':SOURCE 'L#1':' ':ITEM.COUNT 'R#3':' ':BATCH.NUM 'R#6':' ':OPERATOR 'L#5'
*17
LPT.TEXT = LPT.TEXT:' ':OCONV(BUS.DATE,'D2') 'L#9':' ':ACCTG.PERIOD 'L#5':' '
*10
LPT.TEXT = LPT.TEXT:OCONV(POST.DATE,'D2') 'L#10'
*9
LPT.TEXT = LPT.TEXT:OCONV(BATCH.LPT.DT,'D2') 'L#9'
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF:RVB:'  Totals:':RVE:' '
LPT.LN = LPT.LN + ONE
END
*
*30
LPT.TEXT = LPT.TEXT:OCONV(BATCH.TOTAL,'MR2') 'R#9':' ':OCONV(ENTERED.TOTAL,'MR2') 'R#9':' ':OCONV(ADJUST.TOTAL,'MR2') 'R#9'
*
END; * of summary report
*
! Batch Detail Printing Routine * : *
*
* PRINT CLB:BELL:LPT.DETAIL.FL:',':LPT.PMT.TYP.FL:',':BATCH.LPT.DT:',':LPTR.ALL:',':STAT:; INPUT TMP:
*
IF (((NOT(POST.FL) AND (LPT.DETAIL.FL OR LPT.PMT.TYP.FL)) OR (POST.FL AND (BATCH.LPT.DT EQ EMPTY))) OR LPTR.ALL) AND NOT(STAT) THEN
*
BATCH.TOTAL.CHQ = ZERO; BATCH.TOTAL.CRD = ZERO; BATCH.TOTAL.CSH = ZERO; BATCH.TOTAL.CDC = ZERO
*
CALL TRANS.SUBR.PRINT(CAJ,CO.NAME,ACCTG.PERIOD,BATCH.HEADER,BATCH.STATUS.DESC,BATCH.NUM,POST.FL,BATCH.TOTAL.CHQ,BATCH.TOTAL.CRD,BATCH.TOTAL.CDC,BATCH.TOTAL.CSH,CSH.TYPE,CSH.TYPE.CURR,TITLE,TRANS.TYPES,BATCH.CLASS.CURR,LPT.DETAIL.FL,LPT.PMT.TYP.FL,LPT.FL,LPT.STAT,LPT.PG,LPT.LN,LPT.LN.MAX,MIN.DELINQ.AMT,MIN.MIN.DELINQ.STAT)
*
! Printer output * : *
*
IF LPT.PMT.TYP.FL THEN
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF:'Currency:' 'L#10'
LPT.LN = LPT.LN + ONE
END ELSE
LPT.TEXT = LPT.TEXT:CR:LF:SPACE(68)
LPT.LN = LPT.LN + ONE
END
*
*30
LPT.TEXT = LPT.TEXT:OCONV(BATCH.TOTAL.CHQ,'MR2') 'R#9':' ':OCONV(BATCH.TOTAL.CRD,'MR2') 'R#9':' ':OCONV(BATCH.TOTAL.CDC,'MR2') 'R#9':' ':OCONV(BATCH.TOTAL.CSH,'MR2') 'R#9'
*
END
*
! Update print date and error batch status * : *
*
IF LPT.DETAIL.FL THEN
***IF BATCH.STATUS EQ 'D' THEN BATCH.STATUS = 'P'
IF BATCH.STATUS EQ 'E' THEN BATCH.STATUS = 'R'
BATCH.LPT.DT = DATE()
BATCH.LPT.TM = TIME()
END
*
END; * Of E B U and not STAT
*
!  Print Report Line * : *
*
IF NOT(LPT.DETAIL.FL) THEN
*
!  Detect Page Break * : *
*
** IF NOT(LPT.FL) THEN
** LPT.TEXT = LPT.TEXT:CR:LF
** LPT.LN = LPT.LN + ONE
** END
*
LPT.LN = LPT.LN + ONE
*
IF LPT.LN GE LPT.LN.MAX THEN GOSUB LPT.PAGE
*
IF LPT.FL THEN CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
PRINT LPT.TEXT
*
IF LPT.FL THEN CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
! Accumulate Totals * : *
*
LPT.BATCH.TOTAL   = LPT.BATCH.TOTAL   + BATCH.TOTAL
LPT.ENTERED.TOTAL = LPT.ENTERED.TOTAL + ENTERED.TOTAL
LPT.ADJUST.TOTAL  = LPT.ADJUST.TOTAL  + ADJUST.TOTAL
*
IF (((NOT(POST.FL) AND (LPT.DETAIL.FL OR LPT.PMT.TYP.FL)) OR (POST.FL AND (BATCH.LPT.DT EQ EMPTY))) OR LPTR.ALL) AND NOT(STAT) THEN
LPT.TOTAL.CHQ = LPT.TOTAL.CHQ + BATCH.TOTAL.CHQ
LPT.TOTAL.CRD = LPT.TOTAL.CRD + BATCH.TOTAL.CRD
LPT.TOTAL.CSH = LPT.TOTAL.CSH + BATCH.TOTAL.CSH
LPT.TOTAL.CDC = LPT.TOTAL.CDC + BATCH.TOTAL.CDC
END
*
CNTR.TOTAL<7> = CNTR.TOTAL<7> + BATCH.TOTAL
END; * of summary report * : *
*
! Call Posting routine * : *
*
IF ((LPT.DETAIL.FL AND POST.FL) AND (BATCH.STATUS EQ 'B' OR BATCH.STATUS EQ 'D' OR BATCH.STATUS EQ 'P' OR (POST.ALL AND BATCH.STATUS EQ 'R'))) AND NOT(STAT) THEN
*
*** * DON'T POST PPV. POST WON'T HANDLE ACG BILLING, TAXES, ETC.
*** * DON'T' POST POSTED BATCHES EITHER
*** * IF NOT(BATCH.CLASS.SEL = 3) THEN
*** IF NOT(BATCH.SOURCE.SEL = 5) THEN
IF (BATCH.STATUS EQ 'B' OR (POST.ALL AND BATCH.STATUS EQ 'R')) THEN
*
CALL TRANS.SUBR.POST(CAJ,CSH.TYPE,CSH.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,RUN.TRANS.SUB.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,MIN.DELINQ.STAT,MIN.DELINQ.AMT,BUS.DATE,BATCH.CLASS.SEL,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,BATCH.DEL.STATUS,ENTRY.MODE,TRANS.COUNT,BATCH.INP.SOURCE)
*
END
*** END
*
IF NOT(STAT) THEN
*
LIST.TO.POST.DONE<-ONE> = LIST.TO.POST<XTR.CN>
BATCH.LST = XTR.ID.PREF:'.':XTR.ID.SUFF:XTR.ID.DT
DEL LIST.TO.POST<XTR.CN>
XTR.CN = XTR.CN - ONE
XTR.CN.MAX = XTR.CN.MAX - ONE
*
IF BATCH.STATUS NE 'P' THEN
BATCH.STATUS = 'P'
POST.DATE = CONTROL.DT
POST.TIME = OCONV(TIME(),'MT')
END
*
END ELSE
*
BATCH.STATUS = 'R'
* XTR.CN = XTR.CN + ONE
STAT = FALSE
*
END; * of not STAT
*** *
*** POST.DATE = CONTROL.DT
*** POST.TIME = OCONV(TIME(),'MT')
*
END ELSE
* XTR.CN = XTR.CN + ONE
END; * of status B
*
* END ELSE
* XTR.CN = XTR.CN + ONE
* END; * of not an E or R and not STAT so post
*
! Update header * : *
*
* IF NOT(STAT) THEN
* IF NOT(DAVE) THEN
* PRINT CLB:'SOURCE ':SOURCE:',':BATCH.SOURCE:
* INPUT DAVE:
* END
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
* END
*
END; * Of valid * : *
*
*
END ELSE
CAJ = EMPTY
* XTR.CN = XTR.CN + ONE
*95-02-05*DGH*Move items for REG and OTH to ERR list when missing, skip ERR
IF XTR.TYPE.CN EQ 2 THEN
XTR.CN = XTR.CN + ONE
END ELSE
XTR.POST.ERR<-ONE> = LIST.TO.POST<XTR.CN>
BATCH.LST = XTR.ID.PREF:'.':XTR.ID.SUFF:'.ERR'
DEL LIST.TO.POST<XTR.CN>
STAT = 299
BATCH.STATUS = '?'
END
END
*
! Release batch * : *
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
! Check status * : *
*
*  will clear STAT set by a bad batch or lock here
*
IF STAT THEN
*
TMP = 'Error in ':ACCT:' on Batch:':BATCH.NUM:', Status:':BATCH.STATUS:'.  Error#:':STAT
EXEC.REPORT<-ONE> = TMP
*
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
* IF NOT(AUTO.RUN OR PHAN.RUN) THEN
* PRINT ' Enter <cr> . . . ':; INPUT TMP:
IF NOT(PHAN.RUN) THEN PRINT ' Enter <cr> . . . ':
* END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 10 UNTIL SYSTEM(11) OR PHAN.RUN
* FOR TMP = ONE TO 10; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE 'SLEEP 5'
NEXT TMP
IF NOT(PHAN.RUN) THEN
IF SYSTEM(11) THEN
INPUT TMP:
END
END
* END
*
* EXEC.REPORT<-ONE> = 'TRANSACTIONS in ':ACCT:', Error#:':STAT+0:' on Batch: ':BATCH.NUM
*
IF PHAN.RUN OR AUTO.RUN OR POST.FL THEN 
IF STAT NE 999 THEN
STAT = FALSE
END
END
*
END; * of STAT
*
! Next batch * : *
*
REPEAT
*
! Next XTR Posting Class Record * : *
*
IF NOT(FROM.LIST) THEN
IF POST.FL THEN
IF XTR.TYPE.CN EQ ONE THEN
XTR.POST.REG = LIST.TO.POST
END ELSE IF XTR.TYPE.CN EQ TWO THEN
XTR.POST.ERR = LIST.TO.POST
END ELSE
XTR.POST.OTH = LIST.TO.POST
END
END
END
*
IF LIST.TO.POST.DONE NE EMPTY THEN
DT = DATE()
READ TMP FROM CNT.FILE,LIST.TO.POST.ID:XTR.ID.DT ELSE TMP = EMPTY
TMP<-ONE> = LIST.TO.POST.DONE
WRITE TMP ON CNT.FILE,LIST.TO.POST.ID:'@':DT
TMP = EMPTY; LIST.TO.POST.DONE = EMPTY
END
*
*
NEXT XTR.TYPE.CN
*
! Write lists out * : *
*
IF NOT(FROM.LIST) THEN
$INCLUDE IBP.CASH CASH.INCL.UPD.LISTS
END
*
! Release Application Lock (INP.SOURCE LOCK) * : *
*
IF POST.FL THEN
$INCLUDE IBP.CASH CASH.INCL.RELS.APPL
END
*
! Next Class of Transaction * : *
*
REPEAT
*
! Next Source of Transaction * : *
*
REPEAT
*
! End of Report * : *
*
IF NOT(LPT.DETAIL.FL) AND LPT.CN THEN
*
* * : * Detect Page Break
*
IF LPT.LN GE LPT.LN.MAX THEN GOSUB LPT.PAGE
*
* * : *  Print report totals
*
CNTR.MIN = ONE
GOSUB CHECK.CONTROL; * : *
**********
*
END
*
*
! End of program * : *
*
FINISH: *
*
IF POST.FL THEN
* $INCLUDE IBP.CASH CASH.INCL.RELS.XTR
END
*
*
STOP
*
!
*
$INCLUDE IBP.CASH CASH.INCL.IMPRINT
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
CHECK.CONTROL: *
*
! Print Totals
*
IF CNTR.MIN LT 8 THEN
*
IF LPT.FL THEN CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
IF LPT.LN GE LPT.LN.MAX THEN GOSUB LPT.PAGE
*
* IF NOT(LPT.FL) THEN
* PRINT
* LPT.LN = LPT.LN + ONE
* END
*
IF LPT.FL THEN
PRINT 'Totals:' 'R#8':' ':
END ELSE
PRINT RVB:'Totals:' 'R#8':RVE:' ':
END
*
FOR CNTR.CN = 7 TO CNTR.MIN STEP -ONE
IF LPT.FL THEN
PRINT (CNTR.DESC<CNTR.CN>:CNTR.PREV<CNTR.CN>:'........') 'L#9':' ':
END ELSE
PRINT RVB:(CNTR.DESC<CNTR.CN>:CNTR.PREV<CNTR.CN>:'........') 'L#9':RVE:' ':
END
NEXT CNTR.CN
PRINT
LPT.LN = LPT.LN + ONE
*
PRINT 'Totals:' 'R#8':' ':
*
FOR CNTR.CN = 7 TO CNTR.MIN STEP -ONE
*
* PRINT CLB:'TOT ':CNTR.CN
IF CNTR.CN GT ONE THEN
CNTR.TOTAL<CNTR.CN - ONE> = CNTR.TOTAL<CNTR.CN - ONE> + CNTR.TOTAL<CNTR.CN>
END
*
* PRINT (CNTR.DESC<CNTR.CN>:' ':CNTR.CN:' - ':CNTR.TOTAL<CNTR.CN>) 'R#9':' ':
PRINT CNTR.TOTAL<CNTR.CN> 'R#9':' ':
*
* Clear  Control Totals * : *
*
CNTR.TOTAL<CNTR.CN> = ZERO
CNTR.PREV<CNTR.CN> = CNTR.CURR<CNTR.CN>
*
NEXT CNTR.CN
*
PRINT
LPT.LN = LPT.LN + ONE
*
IF LPT.FL THEN CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
END; * of cntr.min lt 8
*
RETURN
*
!
*
CHECK.BALANCE: *
*
$INCLUDE IBP.CASH CASH.INCL.CHECK.BAL
*
RETURN
*
!
*
LPT.PAGE: *
*
*
*    Detect Page Break
*
* IF LPT.LN GE LPT.LN.MAX THEN
*
IF LPT.FL THEN
CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
PRINT FF:
$INCLUDE IBP SYS.INCL.LPT.CO
END ELSE
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT CLB:'Enter <cr> for next page . . . ':; INPUT TMP:
IF TMP EQ 'KILL' THEN STAT = 999; RETURN
IF TMP EQ 'END' THEN STAT = 999; RETURN
END
PRINT @(ZERO,ZERO):CLS:
$INCLUDE IBP SYS.INCL.SCR.CO
END
*
IF LPT.FL THEN
PRINT (OCONV(TIME(),'MTH') 'L#10':SPACE(60 - LEN(TITLEA) / TWO):TITLEA) 'L#130'
END ELSE
* PRINT
PRINT RVB:(OCONV(TIME(),'MTS') 'L#10':SPACE(35 - LEN(TITLEA) / TWO):TITLEA) 'L#79':RVE
END
*
LPT.LN = TWO
IF LPT.FL THEN PRINT; LPT.LN = LPT.LN + ONE
PRINT LPT.HEADER; LPT.LN = LPT.LN + ONE
IF LPT.FL THEN PRINT; LPT.LN = LPT.LN + ONE
LPT.PG = LPT.PG + ONE
*
IF LPT.FL THEN
CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
END
*
* END
*
RETURN
*
*
END
~TRANS.MAKE.LIST~
*PROGRAM: TRANS.MAKE.LIST
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:    6 JUN 96
*
*
*COPYRIGHT    : (C) 1996 MACROSCOPE DESIGN MATRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PROMPT EMPTY; CRLF = CR:LF; DOSNUM = 47; DOSLTH = ZERO; DOSITEM = EMPTY
PROC1 = EMPTY
PROG.LIST = EMPTY; SUBR.LIST = EMPTY; CSEG.LIST = EMPTY; OTHER.LIST = EMPTY
PROC.LIST = EMPTY; CODE.LIST = EMPTY; DICT.LIST = EMPTY
LIST.TYPE = "ABORT"; RTN.TYPE = "ABORT"
*
OPEN EMPTY,"MD" TO MDI.FILE ELSE STOP
OPEN EMPTY,"SYS" TO SYS.FILE ELSE STOP
OPEN EMPTY,"LISTS" TO LST.FILE ELSE STOP
OPEN EMPTY,"OUT.BP.INST" TO BP.INST.FILE ELSE STOP
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
TMP = ("000":PORT) "R#3"
READ RUN.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":TMP ELSE RUN.TYPE = "NONE"
READ RUN.FILE FROM SYS.FILE,"KBIL.":RUN.TYPE:".FILE" ELSE RUN.FILE = EMPTY
*
*
PRINT
PRINT "Enter list name in LISTS: ":
INPUT LIST.NAME:
IF LIST.NAME EQ "KILL" THEN STOP
IF LIST.NAME EQ EMPTY THEN STOP
PRINT
*
PRINT "Enter file name: ":
INPUT FILE.NAME:
IF FILE.NAME EQ "KILL" THEN STOP
IF FILE.NAME EQ EMPTY THEN STOP
PRINT
FILE.AVAIL = TRUE
READ TMP1 FROM SYS.FILE,FILE.NAME THEN
FILE.NAME = TMP1<ONE>
END
*
OPEN EMPTY,FILE.NAME TO ITEM.FILE ELSE STOP
*
PRINT "Enter prestore: ":
INPUT PRESTORE:
IF PRESTORE EQ "KILL" THEN STOP
IF PRESTORE EQ EMPTY THEN PRESTORE.FL = FALSE ELSE PRESTORE.FL = TRUE
PRINT
*
PRINT
*
READ ITEM.ID.LIST FROM LST.FILE,LIST.NAME ELSE STOP
READ ITEM.ID.LIST.OUT FROM LST.FILE,LIST.NAME:".OUT" ELSE ITEM.ID.LIST.OUT = EMPTY
*
PROC1 = "PQN":AM
PROC1 = PROC1:"O       COMPILE & CATALOG items in OUT.":FILE.NAME:" for the list ":LIST.NAME:" ":AM:"C":AM:"C":AM
PROC1 = PROC1:"C":AM:"[MD KBIL.SYSTEM]":AM:"C":AM
PROC1 = PROC1:"HDATE":AM:"P":AM:"C":AM:"HWHO":AM:"P":AM:"C":AM:"C":AM
PROC1 = PROC1:"C":AM:"C":AM:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" COM-CAT ":LIST.NAME:"<":AM:"P":AM
PROC1 = PROC1:"O       ACTIVATE MDD ":AM:"C":AM:"C":AM
*
**IF CODE.ACTIVATE EQ "Y" THEN
PROC1 = PROC1:"HGET-LIST ":LIST.NAME:".OUT":AM:"STON":AM:"HED ":FILE.NAME:"<":AM
*
IF PRESTORE.FL THEN
*
BEGIN CASE
*
CASE OPSYS EQ "M"
**PROC1 = PROC1:"HP9 R9999/^%%MDD"
**PROC1 = PROC1:"%%^//":CHAR(27):"F":CHAR(27)
**PROC1 = PROC1:"R9999/^%%ALL"
**PROC1 = PROC1:"%%^//":CHAR(27):"FI":CHAR(27):"P9<":AM
PROC1 = PROC1:"H":PRESTORE:"<":AM
*
CASE TRUE
PROC1 = PROC1:"HP9 R9999/^%%MDD"
PROC1 = PROC1:"%%^//":SVM:"F":SVM
PROC1 = PROC1:"R9999/^%%ALL"
PROC1 = PROC1:"%%^//":SVM:"FI":SVM:"P9<":AM
*
END CASE
*
**PROC1 = PROC1:"HPD<":AM:"HP9<":AM:"P":AM:"C":AM:"C":AM:"C":AM
PROC1 = PROC1:"HPD<":AM:"P":AM:"C":AM:"C":AM:"C":AM
*
END; * of prestore
*
**END
*
!
*
PRINT
*
LOOP
*
LOOP
*
PROG.OK = TRUE; ATTR1 = EMPTY; RTN.TYPE = "OTHER"
*
IF ITEM.ID.LIST NE EMPTY THEN
*
ITEM.ID = ITEM.ID.LIST<ONE>
**PRINT ITEM.ID "L#30":" ":
*
IF FILE.AVAIL AND ITEM.ID.LIST[ONE,ONE] NE "*" THEN
*
READV ATTR1 FROM ITEM.FILE,ITEM.ID,ONE ELSE PROG.OK = FALSE
*
**IF ITEM.ID[ONE,8] EQ "SH.SUBR." THEN
**ATTR1 = "SUBROUTINE ":ITEM.ID:"(?)"
*** PROG.OK = TRUE
**PROG.OK = FALSE
**END ELSE IF ITEM.ID[ONE,3] EQ "SH." THEN
**ATTR1 = "*PROGRAM: ":ITEM.ID
**PROG.OK = TRUE
**END
***
**$INCLUDE IBP SYS.INCL.ITEM.TYPE
***
**IF RTN.TYPE NE "PROG" AND RTN.TYPE = "CSEG" AND RTN.TYPE NE "PROC" THEN PROG.OK = FALSE
*
END
*
END
*
WHILE (ITEM.ID.LIST[ONE,ONE] EQ "*" OR NOT(PROG.OK)) AND ITEM.ID.LIST NE EMPTY DO
*
PRINT "~":ITEM.ID.LIST<ONE>
*
DEL ITEM.ID.LIST<ONE>
*
REPEAT
*
*
WHILE ITEM.ID.LIST NE EMPTY DO
*
**ITEM.ID = ITEM.ID.LIST<ONE>
***
DEL ITEM.ID.LIST<ONE>
*
READ CAJ FROM ITEM.FILE,ITEM.ID THEN
*
CAJ.CN.MAX = DCOUNT(CAJ,AM)
PRINT ITEM.ID:"(":CAJ.CN.MAX:")>":
*
FOR CAJ.CN = TWO TO CAJ.CN.MAX
*
****
ITEM.ID.EXTR = CAJ<CAJ.CN,ONE>
IF LEN(ITEM.ID.EXTR) EQ 7 THEN ITEM.ID.EXTR = ITEM.ID.EXTR[ONE,6]
*
ITEM.ID.LIST.OUT<-ONE> = ITEM.ID.EXTR
PRINT ".":
****
*
NEXT CAJ.CN
*
END ELSE
* NOT ON FILE
END
*
*
PRINT
*
REPEAT
*
!
*
PROC1 = PROC1:"C":AM:"C":AM:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" COM-CAT ":LIST.NAME:" done.":"<":AM:"P":AM
*
BEGIN CASE
*
CASE OPSYS EQ "M"
PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"RTN":AM
*
CASE TRUE
PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"X":AM
*
END CASE
*
*
PRINT "Proc in MD is ":LIST.NAME:".EDIT . . . "
WRITE PROC1 ON MDI.FILE,LIST.NAME:".EDIT"
WRITE PROC1 ON SYS.FILE,LIST.NAME:".EDIT"
WRITE PROC1 ON BP.INST.FILE,LIST.NAME:".EDIT"
PRINT "Output list name in LISTS is ":LIST.NAME:".OUT . . . "
WRITE ITEM.ID.LIST.OUT ON LST.FILE,LIST.NAME:".OUT"
*
STOP
*
END
~TRANS.MONTHLY.LOADER~
*PROGRAM:         TRANS.MONTHLY.LOADER
* VERSION: 960121 5.0  RUN.TYPE FOR GEN.SVC.COUNTS WAS PUT IN GEN.ADD.COUNTS.
* PRIOR: 900724 2.2  TO.LOAD.GEN.SVC.COUNTS RE SVS REPORTING
* PRIOR: 900615 2.1
* PROIR: 900331 1.9  
* AUTHOR:          BOB CONARROE - AXION
* DESCRIPTION:     LOAD MONTH-END PROGS FOR OVERNIGHT PROCESSING...
* DATE WRITTEN:    29 JUN 84
* DATE RELEASED:   29 JUN 84
* MODIFICATIONS:   DATE      NAME        DESCRIPTION
*                  31-MAR-90  HH  MONTHEND.UPDATE REPLACES TRANS.MONTHLY.UPDATE
*                                 LOADS UPDATE.WKO.COUNTS
!
VERSION = " (R:5.0)"
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
*
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE CURR.ACCTG.PERIOD = ""
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE CURR.ACCTG.DATE = ""
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = ""
GAC = "GEN.ADD.COUNTS"; DESCS = ""; INPUTS = ""; PROCS = ""; DATE.FORMAT = 0
LOCATE GAC IN SPECIAL.ROUTINES<1> BY "AR" SETTING LOC ELSE LOC = ""
IF SPECIAL.ROUTINES<2,LOC> NE "GEO" THEN DESCS<3> = "" ELSE DESCS<3> = "GEO "
IF LOC = "" THEN GAC = GAC:".":"STANDARD"; DESCS<3> = "" ELSE
GAC = GAC:".":SPECIAL.ROUTINES<2,LOC>; INPUTS<3> = "M":VM
END
GSC = "GEN.SVC.COUNTS"
* LOCATE GSC IN SPECIAL.ROUTINES<1> BY "AR" SETTING LOC ELSE LOC = ""
* IF SPECIAL.ROUTINES<2,LOC> NE "GEO" THEN DESCS<4> = "" ELSE DESCS<4> = "GEO "
* IF LOC = "" THEN GSC = GSC:".":"STANDARD"; DESCS<4> = "" ELSE
* GSC = GSC:".":SPECIAL.ROUTINES<2,LOC>; INPUTS<4> = "M":VM
INPUTS<5> = "M":VM
DATE.FORMAT = 1
* END
*
MTH = CURR.ACCTG.PERIOD[3,2]; YEAR = CURR.ACCTG.PERIOD[1,2]
CURR.PERIOD.START.DATE = ICONV(MTH:" 1 ":YEAR,"D")
TWO.MOS.AGO = ICONV(MTH-2:" 1 ":YEAR,"D")
TWO.MOS.AGO = OCONV(TWO.MOS.AGO,"D2")
MTH = MTH+1; IF MTH > 12 THEN MTH = MTH-12; YEAR = YEAR+1
CURR.PERIOD.END.DATE = ICONV(MTH:" 1 ":YEAR,"D")-1
IF DATE.FORMAT THEN DATE.USED = CURR.ACCTG.PERIOD ELSE DATE.USED = OCONV(CURR.PERIOD.END.DATE,"D2")
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Load Month-end overnight processing for Period ":CURR.ACCTG.PERIOD[1,2]:"-":CURR.ACCTG.PERIOD[3,2]:VERSION
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
IF CURR.ACCTG.DATE < CURR.PERIOD.END.DATE-3 THEN
PRINT @(5,10):CLL:"The Acctg. date ":OCONV(CURR.ACCTG.DATE,"D2"):" is more than 3 days to monthend.":
PRINT @(5,11):CLL:"Do you wish to proceed (Y/N)?: ":
INPUT RSP:
IF RSP NE "Y" THEN STOP
END
IF CURR.ACCTG.DATE < CURR.PERIOD.END.DATE-8 THEN
PRINT BELL:@(5,13):"Acctg. date is ":OCONV(CURR.ACCTG.DATE,"D2"):" - not yet ":CURR.ACCTG.PERIOD[1,2]:"-":CURR.ACCTG.PERIOD[3,2]:" month end":
PRINT @(5,14):CLL:"It is more than 8 days to monthend and you cannot proceed.":
INPUT RSP:
STOP
END
*
PROCS<1> = "TRANS.DAILY.UPD";            INPUTS<1> = 1; DESCS<1> = "Transaction Updates"
PROCS<2> = "DAILY.UPDATE";              INPUTS<2> = ""; DESCS<2> = "Daily update"
PROCS<3> = "MONTHEND.UPDATE";         INPUTS<3> = 1; DESCS<3> = "Monthly update"
PROCS<4> = GAC;           INPUTS<4> = "M";          DESCS<4> = DESCS<4>:"Addr counts"
PROCS<5> = GSC;       INPUTS<5> = INPUTS<5>:OCONV(CURR.PERIOD.END.DATE,"D2"); DESCS<5> = "Svc counts"
PROCS<6> = "LIST.MOVE.WKO"; INPUTS<6> = "C,X*&*&*2":VM:VM:"Y":VM:TWO.MOS.AGO; DESCS<6> = "Move WO to Hist"
PROCS<7> = "UPDATE.WKO.COUNTS"; INPUTS<7> = "1"; DESCS<7> = "W/O Counts"
PRINT CLB:"Press <return> to continue...":; INPUT RSP:; IF RSP = "KILL" THEN STOP
CALL AUTO.LOADER(PROCS,INPUTS,DESCS)
*
END
~TRANS.SUBR.BATCH.ANAL~
SUBROUTINE TRANS.SUBR.BATCH.ANAL(CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR,DFLT.SOURCE)
*VERSION 1.0
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
!  
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
* $INCLUDE IBP STANDARD.FUNCTIONS.SUBR
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
*
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Billings entry
*
*     Sources
*                  0 = CASH.ENTRY
*                  3 = Counter Cash
*                  4 = Lock Box Trans
*                  5 = Pay-Per-View Charges
*                  6 = Late Charges
*                  7 = Write Offs
*                  9 = ALL
*
*                  See list post program
*
*   Entry modes
*                  0 = From Cash.Entry
*                  1 = From Genie
*
!  
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
*
MAT CNT.CSH = EMPTY
*
!
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.CNTRL
*FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,STAT,AUTO.RUN,PHAN.RUN,
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
* MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR,STAT
*
!
*
FINISH: *
*
RETURN; * To calling program
*
END
~TRANS.SUBR.CLASS.PARSE~
SUBROUTINE TRANS.SUBR.CLASS.PARSE(BATCH.CLASS.SEL)
*
*
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
!
*
* 0 Regular Adjustments (ADJ)
* 1 Regular Payments    (PMT)
* 2 Regular Deposits    (DEP)
* 3 Special Billing     (BIL)
* 9 All Batch Types     (ALL)
IF NOT(NUM(BATCH.CLASS.SEL)) THEN
TMP1 = BATCH.CLASS.SEL; TMP = EMPTY
LOOP WHILE LEN(TMP1) DO
BEGIN CASE
CASE TMP1[ONE,3] EQ "ALL"
TMP = "9"; TMP1 = "9"
CASE TMP1[ONE,3] EQ "ADJ"
TMP = TMP:"0"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "PMT"
TMP = TMP:"1"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "DEP"
TMP = TMP:"2"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "BIL"
TMP = TMP:"3"; TMP1 = TMP1[4,9999]
CASE INDEX("01239",TMP1[ONE,ONE],ONE) AND NOT(INDEX(TMP,TMP1[ONE,ONE],ONE))
TMP = TMP:TMP1[ONE,ONE]; TMP1 = TMP1[TWO,9999]
CASE TRUE
TMP1 = TMP1[TWO,9999]
END CASE
REPEAT
BATCH.CLASS.SEL = TMP
END
*
RETURN
*
END
~TRANS.SUBR.ENTRY.INIT~
SUBROUTINE TRANS.SUBR.ENTRY.INIT(ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*VERSION 1.0
* VERSION: 911122 2.7  LIST-AND-POST-NOW-CALLS(RE XTR PROCESSING)
* PRIOR: 910106 2.6  ADD.PICK.LOCKING.TO.CASH.BATCH.NUM
* PRIOR: 900416 1.9
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1983              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID STERN - AXION
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
* DESCRIPTION:     ALLOWS ENTRY OF CASH OR ADJUSTMENTS
*  
!  
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
* $INCLUDE IBP STANDARD.FUNCTIONS.SUBR
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
*
*                  0 = Adjustments entry
*                  1 = Cash entry
*                  2 = Deposit entry
*                  3 = Billings entry
*
*     Sources
*                  0 = CASH.ENTRY
*                  3 = Counter Cash
*                  4 = Lock Box Trans
*                  5 = Pay-Per-View Charges
*
*                  See list post program
*
*   Entry modes
*                  0 = From Cash.Entry
*                  1 = From Genie
*
!  
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
READ ALL.FLAG FROM CNT.FILE,"ALL.FLAG" ELSE ALL.FLAG = TRUE
IF NOT(ALL.FLAG) THEN ATR.FLAG = FALSE; ACG.FLAG = FALSE; ACT.FLAG = FALSE
*
MAT CNT.CSH = EMPTY
*
!
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*CNT.CSH.ID,MAT CNT.CSH,STAT
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.CNTRL
*FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,STAT,AUTO.RUN,PHAN.RUN,
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
* MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR,STAT
*
!
*
FINISH: *
*
RETURN; * To calling program
*
END
~TRANS.SUBR.LIST.SELECT~
SUBROUTINE TRANS.SUBR.LIST.SELECT(TITLE,MAT CNT.CSH,CNT.CSH.ID,CHSU,CSHU.ID,CSHUD,CSHUD.ID,CONTROL.DT,CSH.TYPE.SEL,EXEC.VERB.SEL,BATCH.CLASS.SEL,BATCH.SOURCE.SEL,DT.OPEN.SEL,PORT.SEL,USER.VALID.SEL,LPT.DETAIL.SEL,POST.FL,INPUTS,AUTO.RUN,PHAN.RUN)
*
* SUBROUTINE CASH.LIST.SELECT
* (
* LCK.FILE,PAR.FILE,CNT.FILE,
* CSH.TYPE,CSH.TYPE.CURR,TITLE,
* MAT CSH,CHS.ID,CHSU,CSHU.ID,CSHUD,CSHUD.ID,
* SEC.USER.ID,CONTROL.DT,
* DT.OPEN.SEL,PORT.SEL,USER.VALID.SEL,INPUTS,
* LCK.ITM,LCK.TYPE,LCK.STAT,STAT)
* (LCK.FILE,PAR.FILE,ACT.FILE,CAJ,CO.NAME,BATCH.STATUS,HEADER,BATCH.NUM,BUS.DATE,ACCTG.PERIOD,BATCH.TOTAL,ENTERED.TOTAL,ADJUST.TOTAL,CSH.TYPE,CSH.TYPE.CURR,TITLE,OPERATOR,TRANS.TYPES,DEFAULT.TYPE,ENTRY.TYPE,MIN.DELINQ.AMT,MIN.DELINQ.STAT,LCK.ITM,LCK.TYPE,LCK.STAT,STAT)
*
* VERSION: 921218 1.0  NEW
* DESCRIPTION:      SELECT COUNTER CASH BATCHES FOR PRINTING / POSTING
*
* COPYRIGHT         AXION COMPUTER SYSTEMS LTD.
*   1992             ALL RIGHTS RESERVED
*
* AUTHOR:           DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
!
*
* DT.OPEN.SEL = EMPTY
* EXEC.VERB.SEL = EMPTY
* PORT.SEL = EMPTY
* USER.VALID.SEL = EMPTY
* LPT.DETAIL.SEL = EMPTY
*
LN = 5; LN.ORIG = 5; LN.INP = 22
RELOOP = FALSE; INPUTS = VM
DT.LOC = ZERO; PORT.LOC = ZERO; USER.LOC = ZERO
*
CSH.OPT.TEXT = RVB:'D':RVE:'etailed transactions'
CSH.OPT.TEXT<ONE,ONE,-ONE> = RVB:'S':RVE:'ummary of batches'
CSH.OPT.TEXT<ONE,ONE,-ONE> = 't':RVB:'Y':RVE:'ypes of payment'
CSH.OPT.TEXT<ONE,ONE,-ONE> = RVB:'P':RVE:'rinter'
CSH.OPT.TEXT<ONE,ONE,-ONE> = RVB:'T':RVE:'erminal'
CSH.OPT.TEXT<ONE,ONE,-ONE> = 'se':RVB:'L':RVE:'ect statement'
CSH.OPT.TEXT<ONE,ONE,-ONE> = 'no ':RVB:'E':RVE:'ntry of options'
CSH.OPT = 'D':SVM:'S':SVM:'Y':SVM:'P':SVM:'T':SVM:'L':SVM:'E'
*
BE.DESC = 'Business':AM:'Entry'
BE.DICT = 'BUS.DATE':AM:'ENTRY.DATE'
BE.COND = 'GE':AM:'LE'
BE.SEL = EMPTY; BE.LOC = ZERO
BE.LO.HI = 'lowest':AM:'highest'
*
EXEC.SORT = EMPTY
EXEC.SORT.CONT = EMPTY
*
IF BATCH.SOURCE.SEL NE '9' THEN
EXEC.SORT = EXEC.SORT:'BY TMP.SOURCE '
TMP = ONE
LOOP WHILE BATCH.SOURCE.SEL[TMP,ONE] NE EMPTY DO
IF TMP EQ ONE THEN
IF EXEC.SORT.CONT NE EMPTY THEN EXEC.SORT.CONT = EXEC.SORT.CONT:'AND '
EXEC.SORT.CONT = EXEC.SORT.CONT:'WITH TMP.SOURCE '
END ELSE
EXEC.SORT.CONT = EXEC.SORT.CONT:'OR '
END
EXEC.SORT.CONT = EXEC.SORT.CONT:'EQ "':BATCH.SOURCE.SEL[TMP,ONE]:'" '
TMP = TMP + ONE
REPEAT
END
*
* IF BATCH.CLASS.SEL NE '9' THEN
EXEC.SORT = EXEC.SORT:'BY CLASS '
* EXEC.SORT.CONT = EXEC.SORT.CONT:'BY TYPE BY 0 '
*
IF BATCH.CLASS.SEL NE '9' THEN
TMP = ONE
LOOP
TMP1 = BATCH.CLASS.SEL[TMP,ONE]
WHILE TMP1 NE EMPTY DO
TMP2 = INDEX('0123',TMP1,ONE)
IF TMP2 THEN
IF TMP EQ ONE THEN
IF EXEC.SORT.CONT NE EMPTY THEN EXEC.SORT.CONT = EXEC.SORT.CONT:'AND '
EXEC.SORT.CONT = EXEC.SORT.CONT:'WITH CLASS '
END ELSE
EXEC.SORT.CONT = EXEC.SORT.CONT:'OR '
END
EXEC.SORT.CONT = EXEC.SORT.CONT:'EQ "':"ACDB"[TMP2,ONE]:'" '
END
TMP = TMP + ONE
REPEAT
END
*
IF BATCH.SOURCE.SEL EQ '9' THEN
EXEC.SORT = EXEC.SORT:'BY TMP.SOURCE '
END
*
EXEC.SORT.CONT = EXEC.SORT.CONT:'BY OPER '
*
EXEC.SORT.CONT = EXEC.SORT.CONT:'BY 0 '
*
FOR NUM = ONE TO 4
ON NUM GOSUB GET.DT.OPEN,GET.PORT,GET.USER.VALID,GET.LPT.DETAIL
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN NUM = NUM - ONE ELSE
NUM = NUM - TWO; IF NUM LT ZERO THEN NUM = ZERO
END
RELOOP = TRUE
STAT = FALSE
END
NEXT NUM
*
RETURN; * to calling program
*
!
*
GET.DT.OPEN: *
*
LN = LN.ORIG; SC = ONE
*
* IF DCOUNT(CNT.CSH$DT.OPEN<ONE,ONE>,SVM) THEN
IF DT.OPEN.SEL EQ '&' THEN DT.OPEN.SEL = EMPTY
IF DT.OPEN.SEL EQ '*' THEN DT.OPEN.SEL = CNT.CSH$DT.OPEN
IF DT.OPEN.SEL EQ 'CLOSED' THEN CLOSED.FL = 'C'; DT.OPEN.SEL = EMPTY ELSE
IF DT.OPEN.SEL EQ 'RECONCILED' THEN CLOSED.FL = 'R'; DT.OPEN.SEL = EMPTY ELSE
CLOSED.FL = EMPTY
END
END
IF DT.OPEN.SEL EQ EMPTY OR RELOOP THEN
IF NOT(AUTO.RUN) THEN
IF DT.OPEN.SEL EQ 'ALL' AND RELOOP THEN DT.OPEN.SEL = EMPTY
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN):RVB:' Dates.Open':RVE:'  ':RVB:'Closed':RVE:
LN = LN + ONE
LOOP UNTIL CNT.CSH$DT.OPEN<ONE,ONE,SC> EQ EMPTY DO
IF CNT.CSH$DT.CLOSED<ONE,ONE,SC> EQ CLOSED.FL THEN
DT.OPEN.SEL<ONE,ONE,-ONE> = CNT.CSH$DT.OPEN<ONE,ONE,SC>
END
IF NOT(PHAN.RUN) THEN
PRINT @(TWO,LN):OCONV(CNT.CSH$DT.OPEN<ONE,ONE,SC>,'D2') 'R#9':
IF CNT.CSH$DT.CLOSED<ONE,ONE,SC> EQ 'C' THEN
PRINT '   Closed':
END ELSE IF CNT.CSH$DT.CLOSED<ONE,ONE,SC> EQ 'R' THEN
PRINT ' Reconciled':
END
LOCATE CNT.CSH$DT.OPEN<ONE,ONE,SC> IN DT.OPEN.SEL<ONE,ONE> BY 'AR' SETTING TMP.LOC THEN
PRINT @(ZERO,LN):RVB:'*':RVE:
END ELSE
PRINT @(ZERO,LN):' ':
END
END; * OF PHAN.RUN
SC = SC + ONE; LN = LN + ONE
REPEAT
*
LN = LN + ONE
*
LOOP
*
IF NOT(PHAN.RUN) THEN
PRINT @(ZERO,LN.INP - ONE):CLL:RVB:'Enter Business Dates, SELection criteria, "*", ALL or <cr> when done: ':RVE:
PRINT @(ZERO,LN.INP):CLL:
END
IF CLOSED.FL EQ EMPTY THEN
INPUT RSP:
END ELSE RSP = EMPTY
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
DT.OPEN.INP = RSP
*
!
*
IF DT.OPEN.INP[ONE,3] EQ 'SEL' THEN
EXEC.VERB.SEL = DT.OPEN.INP[4,9999]
*
IF EXEC.VERB.SEL EQ EMPTY THEN
*
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:'Select by ':RVB:'B':RVE:'usiness or ':RVB:'E':RVE:'ntry date: ':
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
WHILE RSP NE 'B' AND RSP NE 'E' DO
PRINT CLB:BELL:'Enter a "B" or "E" here.':
REPEAT
IF NOT(PHAN.RUN) THEN PRINT CLB:
BE.LOC = INDEX('BE',RSP,ONE)
*
EXEC.VERB.SEL  = EMPTY
*
FOR BE.CN = ONE TO TWO
*
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP - 4 + BE.CN):CLL:'Enter the ':BE.LO.HI<BE.CN>:' ':BE.DESC<BE.LOC>:' date: ':
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
RSP = ICONV(RSP,'D')
WHILE NOT(RSP) DO
PRINT CLB:BELL:'Enter a valid date here.':
REPEAT
IF NOT(PHAN.RUN) THEN PRINT CLB:
BE.SEL<BE.CN> = RSP
*
NEXT BE.CN
*
EXEC.VERB.SEL = 'SSELECT CAJ ':EXEC.SORT:'BY ':BE.DICT<BE.LOC>:' WITH '
* EXEC.VERB.SEL = 'SSELECT CAJ ':EXEC.SORT:'BY ':BE.DICT<BE.LOC>:' WITH '
EXEC.VERB.SEL = EXEC.VERB.SEL:BE.DICT<BE.LOC>:' '
FOR BE.CN = ONE TO TWO
* EXEC.VERB.SEL = EXEC.VERB.SEL:BE.DICT<BE.LOC>:' ':BE.COND<BE.CN>:' "':OCONV(BE.SEL<BE.CN>,'D2'):'"'
EXEC.VERB.SEL = EXEC.VERB.SEL:BE.COND<BE.CN>:' "':OCONV(BE.SEL<BE.CN>,'D2'):'" '
IF BE.CN EQ ONE THEN EXEC.VERB.SEL = EXEC.VERB.SEL:'AND '
NEXT BE.CN
*
IF EXEC.SORT.CONT NE EMPTY THEN EXEC.SORT.CONT = 'AND ':EXEC.SORT.CONT
EXEC.VERB.SEL = EXEC.VERB.SEL:EXEC.SORT.CONT
*
END; * of empty select
*
DT.OPEN.INP = 'ALL'
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP - 6):CLL:EXEC.VERB.SEL:
IF NOT(INDEX(LPT.DETAIL.SEL,'L',ONE)) THEN LPT.DETAIL.SEL<ONE,ONE,-ONE> = 'L'
*
END ELSE IF DT.OPEN.INP EQ 'ALL' THEN
IF EXEC.SORT.CONT NE EMPTY THEN EXEC.SORT.CONT = 'AND ':EXEC.SORT.CONT
** IF EXEC.SORT.CONT NE EMPTY THEN EXEC.SORT.CONT = EXEC.SORT.CONT:'AND '
EXEC.VERB.SEL = 'SSELECT CAJ ':EXEC.SORT:EXEC.SORT.CONT
END; * of SEL
*
!
*
IF DT.OPEN.INP NE 'ALL' AND DT.OPEN.INP NE '*' THEN
IF DT.OPEN.INP NE EMPTY THEN
DT.OPEN.INP = ICONV(DT.OPEN.INP,'D')
IF DT.OPEN.INP NE EMPTY THEN
LOCATE DT.OPEN.INP IN CNT.CSH$DT.OPEN<ONE,ONE> BY 'AR' SETTING DT.LOC THEN
LOCATE DT.OPEN.INP IN DT.OPEN.SEL<ONE,ONE> BY 'AR' SETTING TMP.LOC THEN
DEL DT.OPEN.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.ORIG + DT.LOC):' ':@(5,LN):
END ELSE
INS DT.OPEN.INP BEFORE DT.OPEN.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.ORIG + DT.LOC):RVB:'*':RVE:@(5,LN):
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END
END ELSE DT.LOC = 999
END ELSE IF DT.OPEN.INP EQ '*' THEN
EXEC.VERB.SEL = EMPTY
IF DT.OPEN.SEL EQ CNT.CSH$DT.OPEN THEN
DT.OPEN.SEL = EMPTY
END ELSE
DT.OPEN.SEL = CNT.CSH$DT.OPEN
END
RELOOP = TRUE
GOTO GET.DT.OPEN
END ELSE IF DT.OPEN.INP EQ 'ALL' THEN
DT.OPEN.SEL = 'ALL'; DT.LOC = 999
END
IF (DT.OPEN.SEL EQ EMPTY AND EXEC.VERB.SEL EQ EMPTY) AND DT.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one Date or KILL the run!':BELL:
DT.LOC = ZERO
END
UNTIL DT.LOC EQ 999 DO REPEAT
*
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP - ONE):CLL:
END
END
* END ELSE DT.OPEN.SEL = EMPTY
* INPUTS<ONE> = INPUTS<ONE>:'*':DT.OPEN.SEL
*
RETURN
*
!
*
GET.PORT: *
*
LN = LN.ORIG; SC = ONE
*
* IF DCOUNT(CNT.CSH$PORT<ONE,ONE>,SVM) THEN
IF PORT.SEL EQ '&' THEN PORT.SEL = EMPTY
IF PORT.SEL EQ '*' THEN PORT.SEL = CNT.CSH$PORT
IF PORT.SEL EQ EMPTY OR RELOOP THEN
IF NOT(AUTO.RUN) THEN
IF PORT.SEL EQ 'ALL' AND RELOOP THEN PORT.SEL = EMPTY
IF NOT(PHAN.RUN) THEN
PRINT @(23,LN):RVB:'Ports':RVE:
LN = LN + ONE
LOOP UNTIL CNT.CSH$PORT<ONE,ONE,SC> EQ EMPTY DO
PRINT @(25,LN):CNT.CSH$PORT<ONE,ONE,SC> 'L#5':
LOCATE CNT.CSH$PORT<ONE,ONE,SC> IN PORT.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
PRINT @(23,LN):RVB:'*':RVE:
END ELSE
PRINT @(23,LN):' ':
END
SC = SC + ONE; LN = LN + ONE
REPEAT
END; * OF PHAN.RUN
*
LN = LN + ONE
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter Till, "*", ALL or <cr> when done: ':RVE:
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
PORT.INP = RSP
IF PORT.INP NE 'ALL' AND PORT.INP NE '*' THEN
IF PORT.INP NE EMPTY THEN
PORT.INP = ('000':PORT.INP) 'R#3'
LOCATE PORT.INP IN CNT.CSH$PORT<ONE,ONE> BY 'AL' SETTING PORT.LOC THEN
LOCATE PORT.INP IN PORT.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
DEL PORT.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(23,LN.ORIG + PORT.LOC):' ':@(75,LN.INP):
END ELSE
INS PORT.INP BEFORE PORT.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(23,LN.ORIG + PORT.LOC):RVB:'*':RVE:@(75,LN.INP):
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END ELSE PORT.LOC = 999
END ELSE IF PORT.INP EQ '*' THEN
IF PORT.SEL EQ CNT.CSH$PORT THEN
PORT.SEL = EMPTY
END ELSE
PORT.SEL = CNT.CSH$PORT
END
RELOOP = TRUE
GOTO GET.PORT
END ELSE IF PORT.INP EQ 'ALL' THEN
PORT.SEL = 'ALL'; PORT.LOC = 999
END
IF PORT.SEL EQ EMPTY AND PORT.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one Till or KILL the run!':BELL:
PORT.LOC = ZERO
END
UNTIL PORT.LOC EQ 999 DO REPEAT
*
END
END
* END ELSE PORT.INP = EMPTY
* INPUTS<ONE> = INPUTS<ONE>:'*':PORT.SEL
*
RETURN
*
!
*
GET.USER.VALID: *
*
LN = LN.ORIG; SC = ONE
*
* IF DCOUNT(CNT.CSH$USER.VALID<ONE,ONE>,SVM) THEN
IF USER.VALID.SEL EQ '&' THEN USER.VALID.SEL = EMPTY
IF USER.VALID.SEL EQ '*' THEN USER.VALID.SEL = CNT.CSH$USER.VALID
IF USER.VALID.SEL EQ EMPTY OR RELOOP THEN
IF NOT(AUTO.RUN) THEN
IF USER.VALID.SEL EQ 'ALL' AND RELOOP THEN USER.VALID.SEL = EMPTY
IF NOT(PHAN.RUN) THEN
PRINT @(31,LN):RVB:'Users':RVE:; LN = LN + ONE
LOOP UNTIL CNT.CSH$USER.VALID<ONE,ONE,SC> EQ EMPTY DO
PRINT @(33,LN):CNT.CSH$USER.VALID<ONE,ONE,SC> 'L#5':
LOCATE CNT.CSH$USER.VALID<ONE,ONE,SC> IN USER.VALID.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
PRINT @(31,LN):RVB:'*':RVE:
END ELSE
PRINT @(31,LN):' ':
END
SC = SC + ONE; LN = LN + ONE
REPEAT
END; * OF PHAN.RUN
*
LN = LN + ONE
LOOP
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter User, "*", ALL or <cr> when done: ':RVE:
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
USER.VALID.INP = RSP
IF USER.VALID.INP NE 'ALL' AND USER.VALID.INP NE '*' THEN
IF USER.VALID.INP NE EMPTY THEN
LOCATE USER.VALID.INP IN CNT.CSH$USER.VALID<ONE,ONE> BY 'AL' SETTING USER.LOC THEN
LOCATE USER.VALID.INP IN USER.VALID.SEL<ONE,ONE> BY 'AL' SETTING TMP.LOC THEN
DEL USER.VALID.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(31,LN.ORIG + USER.LOC):' ':@(75,LN.INP):
END ELSE
INS USER.VALID.INP BEFORE USER.VALID.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(31,LN.ORIG + USER.LOC):RVB:'*':RVE:@(75,LN.INP):
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END ELSE USER.LOC = 999
END ELSE IF USER.VALID.INP EQ '*' THEN
IF USER.VALID.SEL EQ CNT.CSH$USER.VALID THEN
USER.VALID.SEL = EMPTY
END ELSE
USER.VALID.SEL = CNT.CSH$USER.VALID
END
RELOOP = TRUE
GOTO GET.USER.VALID
END ELSE IF USER.VALID.INP EQ 'ALL' THEN
USER.VALID.SEL = 'ALL'; USER.LOC = 999
END
IF USER.VALID.SEL EQ EMPTY AND USER.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one User or KILL the run!':BELL:
USER.LOC = ZERO
END
UNTIL USER.LOC EQ 999 DO REPEAT
*
END
END
* END ELSE USER.VALID.INP = EMPTY
* INPUTS<ONE> = INPUTS<ONE>:'*':USER.VALID.SEL
*
RETURN
*
!
*
GET.LPT.DETAIL: *
*
LN = LN.ORIG; SC = ONE; NO.ENTRY = FALSE
*
IF LPT.DETAIL.SEL EQ '&' THEN LPT.DETAIL.SEL = EMPTY
*
* IF LPT.DETAIL.SEL EQ EMPTY THEN
*
IF NOT(AUTO.RUN) THEN
*
IF NOT(PHAN.RUN) THEN
PRINT @(40,LN):RVB:'Reporting Options' 'L#25':RVE:; LN = LN + ONE
LOOP UNTIL CSH.OPT<ONE,ONE,SC> EQ EMPTY DO
PRINT @(42,LN):CSH.OPT.TEXT<ONE,ONE,SC> 'L#25':
SC = SC + ONE; LN = LN + ONE
REPEAT
END; * OF PHAN.RUN
*
*
LN = LN + ONE
LPT.DETAIL.TMP = LPT.DETAIL.SEL; LPT.DETAIL.SEL = EMPTY
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter Reporting Options or <cr> when done: ':RVE:
*
LOOP
* IF NOT(PHAN.RUN) THEN PRINT @(ZERO,LN.INP):CLL:RVB:'Enter Reporting Options or <cr> when done: ':RVE:
IF LEN(LPT.DETAIL.TMP) THEN
*
IF LPT.DETAIL.TMP[ONE,ONE] EQ SVM THEN LPT.DETAIL.TMP = LPT.DETAIL.TMP[TWO,99999]
LPT.DETAIL.INP = LPT.DETAIL.TMP[ONE,ONE]
LPT.DETAIL.TMP = LPT.DETAIL.TMP[TWO,99999]
*
END ELSE
*
INPUT RSP:
IF RSP EQ 'KILL' THEN STAT = 999; RETURN
IF RSP EQ '^' THEN STAT = -ONE; RETURN
LPT.DETAIL.INP = RSP
*
IF LEN(LPT.DETAIL.INP) GT ONE THEN
LPT.DETAIL.TMP = LPT.DETAIL.INP[TWO,9999]
LPT.DETAIL.INP = LPT.DETAIL.INP[ONE,ONE]
END
*
END
*
IF LPT.DETAIL.INP EQ 'T' THEN
IF INDEX(LPT.DETAIL.SEL,'P',ONE) THEN LPT.DETAIL.INP = 'P'; LPT.DETAIL.TMP = LPT.DETAIL.TMP:'T'
END ELSE IF LPT.DETAIL.INP EQ 'P' THEN
IF INDEX(LPT.DETAIL.SEL,'T',ONE) THEN LPT.DETAIL.INP = 'T'; LPT.DETAIL.TMP = LPT.DETAIL.TMP:'P'
END
*
IF LPT.DETAIL.INP NE EMPTY THEN
LOCATE LPT.DETAIL.INP IN CSH.OPT<ONE,ONE> SETTING OPT.LOC THEN
LOCATE LPT.DETAIL.INP IN LPT.DETAIL.SEL<ONE,ONE> SETTING TMP.LOC THEN
DEL LPT.DETAIL.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(40,LN.ORIG + OPT.LOC):' ':@(75,LN.INP):
END ELSE
INS LPT.DETAIL.INP BEFORE LPT.DETAIL.SEL<ONE,ONE,TMP.LOC>
IF NOT(PHAN.RUN) THEN PRINT @(40,LN.ORIG + OPT.LOC):RVB:'*':RVE:@(75,LN.INP):
IF LPT.DETAIL.INP EQ 'E' THEN NO.ENTRY = TRUE
END
END ELSE IF NOT(PHAN.RUN) THEN PRINT BELL:
END ELSE OPT.LOC = 999
*
IF LPT.DETAIL.SEL EQ EMPTY AND OPT.LOC EQ 999 THEN
PRINT CLB:'You must select atleast one Option or KILL the run!':BELL:
OPT.LOC = ZERO
* END ELSE IF NOT(INDEX(LPT.DETAIL.SEL,'T',ONE) OR INDEX(LPT.DETAIL.SEL,'P',ONE)) THEN
* PRINT CLB:'You must select either the (T)erminal or (P)rinter!':BELL:
* OPT.LOC = ZERO
* PRINT CLB:'You did not select either the (T)erminal or (P)rinter!':BELL:
END
UNTIL OPT.LOC EQ 999 OR NO.ENTRY DO REPEAT
*
* END
END
* INPUTS<ONE> = INPUTS<ONE>:'*':LPT.DETAIL.SEL
*
RETURN
*
!
*
END
~TRANS.SUBR.LOAD.CNTRL~
SUBROUTINE TRANS.SUBR.LOAD.CNTRL(CNT.CSH.ID,MAT CNT.CSH)
*VERSION 1.0
*
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1993              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                              FOR AXION COMPUTER SYSTEMS
*
* DESCRIPTION:      LOAD CASH CONTROL PARAMETER
*  
*
*
* DATE WRITTEN:    DD MMM 93
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
*
MAT CNT.CSH = EMPTY
*
!
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.CNTRL
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
*CNT.CSH.ID,MAT CNT.CSH,STAT
*
!
*
FINISH: *
*
RETURN; * To calling program
*
END
~TRANS.SUBR.OPEN.LIST.POST~
SUBROUTINE TRANS.SUBR.OPEN.LIST.POST(CAJ.FILE)
* VERSION: 930504 1.0
EQU VS TO " (R:1.0)"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1991              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
*                  MACROSCOPE DESIGN MATRIX
* DESCRIPTION:     This program opens the files for Cash List Post
*  
* DATE WRITTEN:    5 MAY 93
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
SYS.PROG = "CASH.SUBR.OPEN.LIST.POST"; VERSION = "1.0"
STAT = FALSE; PHAN.RUN = TRUE
OPEN "ACT" TO ACT.FILE ELSE FILE.NAME = "ACT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
IF OPSYS NE "R" THEN OPEN "AAX" TO AAX.FILE ELSE FILE.NAME = "AAX"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ACG" TO ACG.FILE ELSE FILE.NAME = "ACG"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ADD" TO ADD.FILE ELSE FILE.NAME = "ADD"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "ATR" TO ATR.FILE ELSE FILE.NAME = "ATR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "EFT" TO EFT.FILE ELSE FILE.NAME = "EFT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CAJ" TO CAJ.FILE ELSE FILE.NAME = "CAJ"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
STAT = FALSE; INPUTS = EMPTY
*
*
RETURN; * To Calling program
*
END
~TRANS.SUBR.POST~
SUBROUTINE TRANS.SUBR.POST(CAJ,CSH.TYPE,CSH.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,RUN.TRANS.SUB.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,MIN.DELINQ.STAT,MIN.DELINQ.AMT,BUS.DATE,BATCH.CLASS.SEL,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,BATCH.DEL.STATUS,ENTRY.MODE,TRANS.COUNT,BATCH.INP.SOURCE)
* VERSION: 950915 4.0  PHASE (ZONE) CHANGED TO LENGTH 3.
* VERSION: 910625 1.0 Posting routines for cash
* PRIOR: ?
* COPYRIGHT         AXION COMPUTER SYSTEMS LTD.
*   1991             ALL RIGHTS RESERVED
*
* AUTHOR:           DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:      POSTS A BATCH OF CASH OR ADJUSTMENTS
*
*     Addapted from cash.or.adj.entry (COPYRIGHT 1983 - AXION)
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
*NCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
*NCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
*NCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*NCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
*NCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
*NCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*NCLUDE IBP DLQ.DIM
*
IF ENTRY.MODE NE ZERO THEN
*
* Process a Transaction
*
TRANS = CAJ<TRANS.COUNT>
*
POST.FL = TRANS<ONE,10>
IF NOT(STAT) THEN
* Check for a $ amt
IF TRANS<ONE,3> THEN
* If not Posted or (posted and batch being deleted)
IF NOT(POST.FL OR BATCH.DEL.STATUS) OR (POST.FL AND BATCH.DEL.STATUS) THEN
GOSUB POST.TRANS
* If Posted OK flag as posted
IF NOT(STAT) THEN
IF POST.FL AND BATCH.DEL.STATUS THEN
CAJ<TRANS.COUNT,10> = "0"
END ELSE
CAJ<TRANS.COUNT,10> = DATE() * 100000 + TIME()
END
END
END
END
END
*
END ELSE
*
! Load Standard System Program Delay
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DELAY
*
! Process Transactions in Batch
*
TRANS.COUNT = ONE
*
LOOP TRANS = CAJ<TRANS.COUNT> UNTIL TRANS EQ EMPTY OR STAT DO
*
* Standard System Programs Delay (Multi-User Systems)
*
IF CSH.TYPE THEN
*
$INCLUDE IBP SYS.INCL.CHK.STD.DELAY
*
$INCLUDE IBP SYS.INCL.STD.DELAY
*
END
*
*
* Process a Transaction
*
POST.FL = TRANS<ONE,10>
IF NOT(STAT) THEN
* Check for a $ amt
IF TRANS<ONE,3> THEN
* If not Posted or (posted and batch being deleted)
IF NOT(POST.FL OR BATCH.DEL.STATUS) OR (POST.FL AND BATCH.DEL.STATUS) THEN
GOSUB POST.TRANS
* If Posted OK flag as posted
IF NOT(STAT) THEN
IF POST.FL AND BATCH.DEL.STATUS THEN
CAJ<TRANS.COUNT,10> = "0"
END ELSE
CAJ<TRANS.COUNT,10> = DATE() * 100000 + TIME()
END
END
END
END
END
*
* Next Trans
TRANS.COUNT = TRANS.COUNT + ONE
*
REPEAT
*
END; * Of entry.mode
*
!
*
FINISH: *
*
RETURN
*
!!
*
! Post a Transaction
*
POST.TRANS: *
*
* Load ACT ID
ACT.ID = TRANS<ONE,ONE>; CD = ACT.ID[7,ONE]; ACT.ID = ACT.ID[ONE,6]
* Display Trans
IF ENTRY.MODE EQ ZERO THEN
PRINT @(10,11):CLL:"Now Posting Transaction on account no. ":ACT.ID:"-":CD
END
*
IF ENTRY.MODE NE ONE THEN
* Lock ACT
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE,LCK.STAT) 
WHILE STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ACT file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
* Read ACT
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = EMPTY; STAT = TRUE
*      ATR
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = EMPTY
*      ADD
MATREAD ADD FROM ADD.FILE,ACT$ADD.ID ELSE MAT ADD = EMPTY; STAT = TRUE
*
* Release item if abort on batch
IF STAT THEN 
CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
RETURN
END
*
END; * Of entry.mode
! Post Trans
*
*INCLUDE IBP.CASH CASH.INCL.POST.TRANS
*CODE.SEGMENT: CASH.INCL.POST.TRANS
*
* DAVID HORSMAN
*
* 930305
*
* Load Trans Info
PHASE = FIELD(ADD$GEOGRAPHIC.DATA,"*",ONE); IF LEN(PHASE) LT 3 THEN PHASE = ("000":PHASE) "R#3"
MAT ACG = EMPTY
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
AMOUNT = TRANS<ONE,3>; IF BATCH.CLASS.SEL THEN AMOUNT = -AMOUNT
* Reverse amount on a batch delete
IF BATCH.DEL.STATUS THEN AMOUNT = -AMOUNT
DESC = TRANS<ONE,4>
* Adjustment
IF DESC[ONE,TWO] EQ "a-" THEN
SOURCE = "A"
LC.SOURCE = "a"
TRANS.CLASS = "a"
TRANS.SUB.CLASS = EMPTY
END ELSE
* Deposit, Cash or Billing
SOURCE = RUN.SOURCE
LC.SOURCE = RUN.LC.SOURCE
TRANS.CLASS = RUN.TRANS.CLASS
TRANS.SUB.CLASS = RUN.TRANS.SUB.CLASS
END
DESC<ONE,ONE,-ONE> = TRANS<ONE,11>
*
W.TYP = TRANS.CLASS:TRANS.SUB.CLASS:'*':TRANS.TYPE
TMP.SUB.CLASS = EMPTY
*
! Add Trans to ATR
*
* Add a ATR Trans; Don't Reverse an ATR Trans
ATR.UPD.FL = TRUE; ATR.DEL.FL = FALSE
*
* CTR = 3
* BIL = 5
*   * If it is a Pre-Posted Trans don't Add another ATR trans (CTR or BIL)
*   IF BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5 THEN ATR.UPD.FL = FALSE
* If it has been Posted don't Add another ATR Trans
IF POST.FL THEN ATR.UPD.FL = FALSE
* If the batch is waiting to be deleted
IF BATCH.DEL.STATUS THEN
* Dont Add an ATR Trans; Reverse the ATR Trans.
ATR.UPD.FL = FALSE; ATR.DEL.FL = TRUE
* If it is not Posted
*    * and it is not a pre-Posted Transaction (CTR or BIL)
* then don't reverse the Posting
*     IF NOT(POST.FL) AND (BATCH.INP.SOURCE NE 3 AND BATCH.INP.SOURCE NE 5) THEN
IF NOT(POST.FL) THEN
ATR.DEL.FL = FALSE
END
END
*
! Add an ATR Trans if OK
*
IF ATR.UPD.FL THEN
*
CALL PACK.NUMBER(EFF.DATE,TEMP); INS TEMP BEFORE ATR$EFF.DATES<ONE,ONE>
CALL PACK.NUMBER(CONTROL.DT,TEMP); INS TEMP BEFORE ATR$ENTRY.DATES<ONE,ONE>
CALL PACK.NUMBER(CURR.ACCTG.PERIOD,TEMP); INS TEMP BEFORE ATR$ENTRY.PERIODS<ONE,ONE>
INS SOURCE BEFORE ATR$TYPES<ONE,ONE>
INS BATCH.NUM BEFORE ATR$REFS<ONE,ONE>
CALL PACK.NUMBER(AMOUNT,TEMP); INS TEMP BEFORE ATR$TOTAL.AMTS<ONE,ONE>
IF DESC[ONE,TWO] EQ "a-" THEN INS EMPTY BEFORE ATR$DESCS<ONE,ONE> ELSE INS DESC BEFORE ATR$DESCS<ONE,ONE>
INS W.TYP BEFORE ATR$SVC.TYPES<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.QNTYS<ONE,ONE>
CALL PACK.NUMBER(AMOUNT,TEMP); INS TEMP BEFORE ATR$SVC.AMTS<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.FROM.DATES<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.TO.DATES<ONE,ONE>
*
END; * of Add an ATR Trans
*
! Reverse an ATR Trans
*
* END ELSE IF (BATCH.DEL.STATUS AND (POST.FL OR (NOT(POST.FL) AND (BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5)))) THEN
*
*
IF ATR.DEL.FL THEN
LOCATE BATCH.NUM IN ATR$REFS<ONE> SETTING ATR.LOC THEN
CONT = TRUE
LOOP
IF ATR$EFF.DATES<ONE,ATR.LOC> EQ EMPTY THEN CONT = FALSE ELSE
* TMP = ATR$EFF.DATES<ONE,ATR.LOC>; CALL UNPACK.NUMBER(TMP,TEMP)
* IF TEMP EQ EFF.DATE THEN
IF ATR$TYPES<ONE,ATR.LOC> EQ SOURCE THEN
TMP = ATR$TOTAL.AMTS<ONE,ATR.LOC>; CALL UNPACK.NUMBER(TMP,TEMP)
IF TEMP EQ -AMOUNT THEN
DEL ATR$EFF.DATES<ONE,ATR.LOC>
DEL ATR$ENTRY.DATES<ONE,ATR.LOC>
DEL ATR$ENTRY.PERIODS<ONE,ATR.LOC>
DEL ATR$TYPES<ONE,ATR.LOC>
DEL ATR$REFS<ONE,ATR.LOC>
DEL ATR$TOTAL.AMTS<ONE,ATR.LOC>
DEL ATR$DESCS<ONE,ATR.LOC>
DEL ATR$SVC.TYPES<ONE,ATR.LOC>
DEL ATR$SVC.QNTYS<ONE,ATR.LOC>
DEL ATR$SVC.AMTS<ONE,ATR.LOC>
DEL ATR$SVC.FROM.DATES<ONE,ATR.LOC>
DEL ATR$SVC.TO.DATES<ONE,ATR.LOC>
CONT = FALSE
END
END
* END
END
WHILE CONT DO ATR.LOC = ATR.LOC + ONE REPEAT
END; * Of ATR.DEL.FL
*
END; * Of Reverse an ATR Trans
*
!!
*
! Update Account balance and aging
*
* Don't update ACT/ACG
ACT.UPD.FL = FALSE
*
* If not Posted and not Reverse update the ACT/ACG
IF NOT(POST.FL) AND NOT(BATCH.DEL.STATUS) THEN ACT.UPD.FL = TRUE
*
* If not Posted and Reverse and Pre-posted Amount (CTR or BIL) update the ACT
IF NOT(POST.FL) AND BATCH.DEL.STATUS AND (BATCH.INP.SOURCE EQ 3 OR BATCH.INP.SOURCE EQ 5) THEN ACT.UPD.FL = TRUE
*
* IF Posted and Reverse Update then ACT/ACG (amounts will be reversed)
IF POST.FL AND BATCH.DEL.STATUS THEN ACT.UPD.FL = TRUE
*
* If not Posted and (not a Pre-Posted Trans (CTR or BIL)) Update the ACT/ACG
IF NOT(POST.FL) AND (BATCH.INP.SOURCE NE 3 AND BATCH.INP.SOURCE NE 5) THEN ACT.UPD.FL = TRUE
*
! Update the account for Adj's, Payments, Billings   vs   Deposits
*
IF ACT.UPD.FL THEN
*
* Process Adjustments, Cash, and Billings (vs. Deposits)
IF BATCH.CLASS.SEL NE TWO THEN
*
ACT$BALANCE = ACT$BALANCE + AMOUNT
AMT.TO.APPLY = -AMOUNT
IF AMT.TO.APPLY GT ZERO THEN AGE.NUM = 4 ELSE
AGE.NUM = TWO
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
IF TRANS.TYPES<5,LOC> EQ "N" THEN AGE.NUM = ONE ELSE
* NOW SET CR. STATUS TO MIN. DLQ FOR A 'LATE NOTICE' TRANSACTION
IF TRANS.TYPES<4,LOC> EQ "Y" THEN IF ACT$CREDIT.STATUS LT MIN.DELINQ.STAT THEN AGE.NUM = MIN.DELINQ.STAT
END
END
END
LOOP WHILE AMT.TO.APPLY DO
AGED = FIELD(ACT$AGED.AMTS,"*",ONE)
AGED<TWO> = FIELD(ACT$AGED.AMTS,"*",TWO)
AGED<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGED<4> = FIELD(ACT$AGED.AMTS,"*",4)
IF AGED<ONE> LT ZERO THEN AGED<4> = AGED<4> + AGED<ONE>; AGED<ONE> = ZERO
AGED<AGE.NUM> = AGED<AGE.NUM> - AMT.TO.APPLY
AGE.NUM = 4
LOOP
WHILE AGE.NUM GT ONE DO
IF AGED<AGE.NUM> LT ZERO THEN AGED<AGE.NUM - ONE> = AGED<AGE.NUM - ONE> + AGED<AGE.NUM>; AGED<AGE.NUM> = ZERO
AGE.NUM = AGE.NUM - ONE
REPEAT
AMT.TO.APPLY = AGED<ONE> + AGED<TWO> + AGED<3> + AGED<4> - ACT$BALANCE
IF AMT.TO.APPLY GT ZERO THEN AGE.NUM = 4 ELSE AGE.NUM = TWO
BEGIN CASE
CASE AGED<4>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>:"*":AGED<3>:"*":AGED<4>
CASE AGED<3>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>:"*":AGED<3>
CASE AGED<TWO>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>
CASE ONE;       ACT$AGED.AMTS = AGED<ONE>
END CASE
BEGIN CASE
CASE AGED<4> GE MIN.DELINQ.AMT;               * 60 DAYS  + 
IF ACT$CREDIT.STATUS LT 3 THEN ACT$CREDIT.STATUS = 3 
CASE AGED<3> + AGED<4> GE MIN.DELINQ.AMT;       * 30 DAYS  + 
ACT$CREDIT.STATUS = TWO
CASE AGED<TWO> + AGED<3> + AGED<4> GE MIN.DELINQ.AMT; * CURRENT
ACT$CREDIT.STATUS = ONE
CASE ONE;                                    * UNDER 30 DAYS
ACT$CREDIT.STATUS = ZERO
IF ACT$STAT EQ "A" THEN ACT$DISC.DATE = EMPTY ELSE IF ACT$BALANCE LT ZERO AND ABS(ACT$BALANCE) GE MIN.DELINQ.AMT THEN ACT$CREDIT.STATUS = -ONE
END CASE
REPEAT
END ELSE
DEPOSIT.TYPE = "D"
BEGIN CASE
CASE TRANS.TYPE EQ "01" OR TRANS.TYPE EQ "03" OR TRANS.TYPE EQ "05" OR TRANS.TYPE EQ "07"
DEPOSIT.TYPE = "D"
CASE TRANS.TYPE EQ "02" OR TRANS.TYPE EQ "04" OR TRANS.TYPE EQ "04" OR TRANS.TYPE EQ "08"
DEPOSIT.TYPE = "X"
END CASE
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
IF TRANS.TYPES<4,LOC> NE EMPTY THEN DEPOSIT.TYPE = TRANS.TYPES<4,LOC>
END
BEGIN CASE
CASE DEPOSIT.TYPE EQ "D"
ACT$DEPOSIT.AMT = ACT$DEPOSIT.AMT + AMOUNT
CASE DEPOSIT.TYPE EQ "X"
ACT$DEPOSIT.TAX = ACT$DEPOSIT.TAX + AMOUNT
END CASE
END
*
! Update Accounting
*
LOCATE LC.SOURCE IN ACG$SOURCES<ONE> BY "AL" SETTING SOURCE.LOC ELSE
INS LC.SOURCE BEFORE ACG$SOURCES<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$TRANS.TYPES<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$AMOUNTS<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$COUNTS<ONE,SOURCE.LOC>
END
LOCATE TRANS.TYPE IN ACG$TRANS.TYPES<ONE,SOURCE.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRANS.TYPE BEFORE ACG$TRANS.TYPES<ONE,SOURCE.LOC,TRANS.LOC>
INS EMPTY BEFORE ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC>
INS EMPTY BEFORE ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC>
END
ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC> = ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC> + AMOUNT
ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC> = ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC> + ONE
*
ACG.ID = PHASE:"*":BUS.DATE
LOOP
LOOP LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LCK.FILE,LCK.STAT) WHILE LCK.STAT DO
PRINT BELL:CLB:"You must unlock ACG file - item ":ACG.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
MATREAD SAVE.ACG FROM ACG.FILE,ACG.ID ELSE MAT SAVE.ACG = EMPTY
VC = ONE
LOOP SRC = ACG$SOURCES<ONE,VC> UNTIL SRC EQ EMPTY DO
LOCATE SRC IN SAVE.ACG$SOURCES<ONE> BY "AL" SETTING SRC.LOC ELSE
INS SRC BEFORE SAVE.ACG$SOURCES<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$AMOUNTS<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$COUNTS<ONE,SRC.LOC>
END
SC = ONE
LOOP TRTYP = ACG$TRANS.TYPES<ONE,VC,SC> UNTIL TRTYP EQ EMPTY DO
LOCATE TRTYP IN SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRTYP BEFORE SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC,TRANS.LOC>
INS EMPTY BEFORE SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC>
INS EMPTY BEFORE SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC>
END
SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC> = SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC> + ACG$AMOUNTS<ONE,VC,SC>
SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC> = SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC> + ACG$COUNTS<ONE,VC,SC>
SC = SC + ONE
REPEAT
VC = VC + ONE
REPEAT
*
* IF ENTRY.MODE EQ ZERO THEN
IF ACG.FLAG THEN MATWRITE SAVE.ACG ON ACG.FILE,ACG.ID
* END
CALL UNLOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LCK.FILE)
UNTIL ACG.ID[ONE,ONE] EQ "$" DO ACG.ID = "$":PHASE:"*":CONTROL.DT REPEAT
*
! Update ATR and ACT
*
* IF ENTRY.MODE EQ ZERO THEN
IF ATR.FLAG THEN MATWRITE ATR ON ATR.FILE,ACT.ID
* END
*
IF ACT.FLAG THEN
*
* IF ENTRY.MODE EQ ZERO THEN
MATWRITE ACT ON ACT.FILE,ACT.ID
* END
*
IF TRANS.TYPE MATCHES "'E'1A" THEN
IF TRANS.TYPE NE "EP" THEN
MATREAD EFT FROM EFT.FILE,ACT.ID THEN
BEGIN CASE
CASE TRANS.TYPE EQ "EE"; * EFT - Error in coding
EFT$STAT = "S"
IF EFT$ERROR.FLAG EQ EMPTY THEN EFT$ERROR.FLAG = "E"
CASE TRANS.TYPE EQ "EN"; * EFT - NSF cheque
IF EFT$ERROR.FLAG MATCHES "0N" THEN EFT$ERROR.FLAG = EFT$ERROR.FLAG + ONE ELSE EFT$ERROR.FLAG = ONE
CASE ONE; * CLOSED ACCOUNT OR STOP PAYMENT
EFT$STAT = "C"
END CASE
* IF ENTRY.MODE EQ ZERO THEN
IF ALL.FLAG THEN MATWRITE EFT ON EFT.FILE,ACT.ID
* END
END; * of EFT found
END; * of not EP
END; * of "'E'1A"
*
END; * of ACT.FLAG
*
END; * of ACT.UPD.FL
*
*@@@@@@@@@@
*
! Unlock ACT
*
IF ENTRY.MODE NE ONE THEN
CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
END
*
RETURN
*
!
*
END
~TRANS.SUBR.PRINT~
SUBROUTINE TRANS.SUBR.PRINT(CAJ,CO.NAME,ACCTG.PERIOD,BATCH.HEADER,BATCH.STATUS.DESC,BATCH.NUM,POST.FL,BATCH.TOTAL.CHQ,BATCH.TOTAL.CRD,BATCH.TOTAL.CDC,BATCH.TOTAL.CSH,CSH.TYPE,CSH.TYPE.CURR,TITLE,TRANS.TYPES,BATCH.CLASS.SEL,LPT.DETAIL.FL,LPT.PMT.TYP.FL,LPT.FL,LPT.STAT,LPT.PG,LPT.LN,LPT.LN.MAX,MIN.DELINQ.AMT,MIN.DELINQ.STAT)
* VERSION: 910625 1.0  NEW
* DESCRIPTION:      PRINTS A BATCH OF TRANSACTIONS
* COPYRIGHT         AXION COMPUTER SYSTEMS LTD.
*   1991             ALL RIGHTS RESERVED
*
* AUTHOR:           DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*
*     Addapted from cash.or.adj.entry (COPYRIGHT 1983 - AXION)
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*
*NCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*
*NCLUDE IBP DLQ.DIM
$INCLUDE IBP DLQ.EQUATES
*
!
*
DLQ.FL = TRUE
OPEN "DLQ" TO DLQ.FILE ELSE
PRINT CLB:"Can't open DLQ File, delinquency won't be used.":
DLQ.FL = FALSE
END
READ MEMO.DAYS FROM PAR.FILE,"MEMO.DAYS" ELSE MEMO.DAYS = 5
WKO.IDS = EMPTY
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DELAY
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
!
*
PRINT.BATCH: *
*
IF LPT.FL AND LPT.DETAIL.FL THEN
PRINT @(ZERO,22):CLL:"Printing batch list ... one moment please ...":
END
LPT.PG = ONE; LN = 99; MAX.LN = 55
DISP.COUNT = ONE
IF LPT.FL THEN CALL LPT.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
*
LOOP TRANS = CAJ<DISP.COUNT> UNTIL TRANS EQ EMPTY DO
*
IF NOT(LPT.DETAIL.FL) AND LPT.PMT.TYP.FL THEN
*
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" AND BATCH.CLASS.SEL GT ZERO THEN AMOUNT = ZERO ELSE AMOUNT = TRANS<ONE,3>
ADJ.AMOUNT = TRANS<ONE,3> - AMOUNT
*
CURRENCY.TYPE = TRANS<ONE,11>
BEGIN CASE
CASE CURRENCY.TYPE EQ "CH"
BATCH.TOTAL.CHQ = BATCH.TOTAL.CHQ + AMOUNT
CASE CURRENCY.TYPE EQ "CC"
BATCH.TOTAL.CRD = BATCH.TOTAL.CRD + AMOUNT
CASE CURRENCY.TYPE EQ "CD"
BATCH.TOTAL.CDC = BATCH.TOTAL.CDC + AMOUNT
CASE TRUE
BATCH.TOTAL.CSH = BATCH.TOTAL.CSH + AMOUNT
END CASE
*
END ELSE
GOSUB LPT.LINE
END
*
DISP.COUNT = DISP.COUNT + ONE
*
REPEAT
*
IF LPT.DETAIL.FL THEN GOSUB LPT.WO.REPORT
*
RETURN
*
*
!
*
LPT.LINE: *
*
*
IF CSH.TYPE THEN
*
$INCLUDE IBP SYS.INCL.CHK.STD.DELAY
*
$INCLUDE IBP SYS.INCL.STD.DELAY
*
END
*
*
IF LN GT MAX.LN THEN
*
$INCLUDE IBP SYS.INCL.LPT.CO
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.DESC
*
HEADER = TITLE:" Entry  -  ":BATCH.STATUS.DESC:" batch No. ":BATCH.NUM:"  Entered by ":OPERATOR
PRINT SPACE(65 - LEN(HEADER) / TWO):HEADER
HEADER = "Bus.date ":OCONV(BUS.DATE,"D2"):"  Accounting period ":ACCTG.PERIOD:"  "
HEADER = HEADER:"Batch total $":OCONV(BATCH.TOTAL,"MR2"):"  Entered total $":OCONV(ENTERED.TOTAL,"MR2")
IF ADJUST.TOTAL NE EMPTY THEN HEADER = HEADER:"  Adjust total $":OCONV(ADJUST.TOTAL,"MR2")
*
PRINT SPACE(65 - LEN(HEADER) / TWO):HEADER
PRINT
PRINT " T#  Account  Customer name" "L#35":"Type  Amount   Adjust     Description" "L#45":" Old Cust No" "R#46":
PRINT
LN = 6
LPT.PG = LPT.PG + ONE
*
END; * OF PAGE CHANGE
*
*
ACT.ID = TRANS<ONE,ONE>[ONE,6]
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = EMPTY
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.MEMO
*
IF MEMO.ID NE EMPTY THEN
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = TRANS<ONE,7>:"** Memo WO: ":MEMO.ID:" on ":MEMO.ODT
IF ACT$BALANCE LT MIN.DELINQ.AMT OR ACT$CREDIT.STATUS LT MIN.DELINQ.STAT THEN
WKO.IDS<-ONE> = ACT.ID:VM:MEMO.ID
END
END; * OF MEMO.ID
*
*
IF ACT$PEND.WO.NUMS NE EMPTY THEN
TMP = DCOUNT(ACT$PEND.WO.NUMS,VM)
WKO.DISP = EMPTY
FOR TMP1 = ONE TO TMP
WKO.DISP = WKO.DISP:"** WO: ":ACT$PEND.WO.NUMS<ONE,TMP1>:" "
* IF ACT$BALANCE LT MIN.DELINQ.AMT OR ACT$CREDIT.STATUS LT MIN.DELINQ.STAT THEN
* WKO.IDS<-ONE> = ACT.ID:VM:ACT$PEND.WO.NUMS<ONE,TMP1>
* END
NEXT TMP1
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = TRANS<ONE,7>:WKO.DISP
END ELSE WKO.DISP = EMPTY
*
*
LAST.NAME = FIELD(ACT$CUS.NAME,"*",ONE)
FIRST.NAME = FIELD(ACT$CUS.NAME,"*",TWO)
FULL.NAME = TRIM(FIRST.NAME:" ":LAST.NAME)
IF LEN(FULL.NAME) GT 20 THEN FULL.NAME = TRIM(FIRST.NAME[ONE,ONE]:" ":LAST.NAME)
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
IF TRANS<ONE,4>[ONE,TWO] EQ "a-" AND BATCH.CLASS.SEL GT ZERO THEN AMOUNT = ZERO ELSE AMOUNT = TRANS<ONE,3>
ADJ.AMOUNT = TRANS<ONE,3> - AMOUNT
*
TRANS.NUM = TRANS<ONE,11>
IF TRANS.NUM[ONE,ONE] EQ "C" THEN
CURRENCY.TYPE = TRANS.NUM[ONE,TWO]
TRANS.NUM = TRANS.NUM[3,9999]
END ELSE CURRENCY.TYPE = "CA"
*
BEGIN CASE
CASE CURRENCY.TYPE EQ "CH"
BATCH.TOTAL.CHQ = BATCH.TOTAL.CHQ + AMOUNT
CASE CURRENCY.TYPE EQ "CC"
BATCH.TOTAL.CRD = BATCH.TOTAL.CRD + AMOUNT
CASE CURRENCY.TYPE EQ "CD"
BATCH.TOTAL.CDC = BATCH.TOTAL.CDC + AMOUNT
CASE TRUE
BATCH.TOTAL.CSH = BATCH.TOTAL.CSH + AMOUNT
END CASE
*
*
PRINT DISP.COUNT "R#3":"  ":TRANS<ONE,ONE> "L#9":FULL.NAME "L#20":" ":TRANS.TYPE "L#4":OCONV(AMOUNT,"MR2ZM") "R#9":OCONV(ADJ.AMOUNT,"MR2ZM") "R#9":"  ":
IF TRANS<ONE,4>[ONE,TWO] NE "a-" THEN PRINT "  ":
*
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC ELSE NULL
*
LN.DISP = EMPTY
*
IF TRANS.NUM NE "" THEN
LN.DISP = CURRENCY.TYPE:"# ":TRANS.NUM:", "
END
*
IF TRANS<ONE,4> NE EMPTY THEN 
IF LEN(TRANS<ONE,4,ONE>) LT 6 THEN
LN.DISP = LN.DISP:TRIM("CH#:":TRANS<ONE,4,ONE>:" ":TRANS.TYPES<TWO,LOC>)
END ELSE
LN.DISP = LN.DISP:TRIM(TRANS<ONE,4,ONE>:" ":TRANS<ONE,4, TWO>)
END
END ELSE
LN.DISP = LN.DISP:TRIM(TRANS.TYPES<TWO,LOC>)
END
*
IF LEN(TRANS<ONE,7>) THEN LN.DISP = LN.DISP:", ":TRANS<ONE,7>
IF LEN(TRANS<ONE,6>) THEN LN.DISP = TRIM(LN.DISP:", ":TRANS<ONE,6>)
*
IF LEN(LN.DISP) LE 54 THEN
PRINT LN.DISP "L#54":
PRINT "  ":TRANS<ONE,5>
*
END ELSE
LN.DISP.CONT = TRUE; LEN.LN.DISP = LEN(LN.DISP)
LOOP
IF LEN(LN.DISP) GT 54 THEN
TC.CN = 54
LOOP
TC = LN.DISP[TC.CN,ONE]
UNTIL NOT(TC.CN) OR TC EQ "," OR (TC.CN LT 25 AND TC EQ " ") DO TC.CN = TC.CN - ONE REPEAT
IF TC.CN LE 10 THEN TC.CN = 54
END ELSE TC.CN = LEN(LN.DISP)
IF NOT(LN.DISP.CONT) THEN PRINT SPACE(61):
PRINT LN.DISP[ONE,TC.CN] "L#54":
IF LN.DISP.CONT THEN
PRINT "  ":TRANS<ONE,5>
LN.DISP.CONT = FALSE
END ELSE
PRINT
END
LN.DISP = TRIM(LN.DISP[TC.CN+ONE,99999])
LEN.LN.DISP = LEN(LN.DISP)
WHILE LEN.LN.DISP DO LN = LN + ONE REPEAT
END
*
*
LN = LN + ONE
*
RETURN
*
! Update Status
*
UPDATE.STATUS: *
*
*IF BATCH.STATUS EQ "P" THEN 
*BATCH.STATUS = "Z"
*GOSUB UPDATE.FILE
*END
*
! Print Work Order Report
*
LPT.WO.REPORT: *
*
LINE = EMPTY; LN = MAX.LN + ONE
*
LOOP WHILE LEN(WKO.IDS) DO
*
LINE = EMPTY
FOR TMP = ONE TO 6 UNTIL NOT(LEN(WKO.IDS))
LINE = LINE:WKO.IDS<ONE,ONE> "L#8":WKO.IDS<ONE,TWO> "L#12"
DEL WKO.IDS<ONE>
NEXT TMP
*
IF LN GT MAX.LN THEN
PRINT FF:TIMEDATE() "L#25":(SPACE(40 - LEN(CO.NAME) / TWO):CO.NAME) "L#80":("Page ":LPT.PG) "R#25"
HEADER = "Work Orders to be Checked by Dispatcher"
PRINT SPACE(65 - LEN(HEADER) / TWO):HEADER
PRINT
HEADER = EMPTY
FOR TMP = ONE TO 6
HEADER = HEADER:"Account" "L#8":"Work Order" "L#12"
NEXT TMP
PRINT HEADER "L#130"
PRINT
LPT.PG = LPT.PG + ONE; LN = 6
END
*
PRINT LINE
PRINT
LN = LN + TWO
*
REPEAT
*
*
IF LPT.FL THEN CALL LPT.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
PRINT @(ZERO,22):CLL:
*
RETURN
*
!
*
END
~TRANS.SUBR.SOURCE.PARSE~
SUBROUTINE TRANS.SUBR.SOURCE.PARSE(BATCH.SOURCE.SEL)
*
*
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
!
*
* 0 Cash.or.Adj Entry     (REG)
* 3 Counter Cash          (CTR)
* 4 Lockbox Transactions  (XTR)
* 5 Pay-Per-View Charges  (XPV)
* 6 Late Charges          (LCH)
* 7 Write_Off Adjustments (WRO)
* 9 All batch sources     (ALL)
IF NOT(NUM(BATCH.SOURCE.SEL)) THEN
TMP1 = BATCH.SOURCE.SEL; TMP = EMPTY
LOOP WHILE LEN(TMP1) DO
BEGIN CASE
CASE TMP1[ONE,3] EQ "ALL"
TMP = "9"; TMP1 = "9"
CASE TMP1[ONE,3] EQ "REG"
TMP = TMP:"0"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "ONE"
TMP = TMP:"1"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "TWO"
TMP = TMP:"2"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "CTR"
TMP = TMP:"3"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "XTR"
TMP = TMP:"4"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "XPV"
TMP = TMP:"5"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "LCH"
TMP = TMP:"6"; TMP1 = TMP1[4,9999]
CASE TMP1[ONE,3] EQ "WRO"
TMP = TMP:"7"; TMP1 = TMP1[4,9999]
CASE INDEX("012345679",TMP1[ONE,ONE],ONE) AND NOT(INDEX(TMP,TMP1[ONE,ONE],ONE))
TMP = TMP:TMP1[ONE,ONE]; TMP1 = TMP1[TWO,9999]
CASE TRUE
TMP1 = TMP1[TWO,9999]
END CASE
REPEAT
BATCH.SOURCE.SEL = TMP
END
*
RETURN
*
END
~TRANS.SUBR.VALIDATE.BATCH~
SUBROUTINE TRANS.SUBR.VALIDATE.BATCH(VALID,BATCH.HEADER,DT.OPEN.SEL,DT.OPEN.LOC,PORT.SEL,PORT.LOC,USER.VALID.SEL,USER.VALID.LOC,BATCH.CLASS.CURR,BATCH.SOURCE.CURR)
*PROGRAM: CASH.SUBR.VALIDATE.BATCH
EQU VS TO "930305"
* AUTHORS: DAVID HORMAN for AXION COMPUTER SYSTEMS
* DESCRIPTION:  Enter payments for an account
*
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
!
$INCLUDE IBP GENERAL.COMMON.AREA
 * $INCLUDE IBP STANDARD.FUNCTIONS.SUBR
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
*
!
*
VERSION = " (R:1.0)"
*
* PRINT CLB:"EP 1 - Enter <cr> . . . ":; INPUT TMP.RSP:
*
* LCK.ITM = TRUE; LCK.TYPE = ONE; * LCK.FILE = ZERO; * REV ONLY
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
! Validate Batch
*
VALID = TRUE
*
* Date
IF DT.OPEN.SEL NE "ALL" AND BUS.DATE NE EMPTY THEN
LOCATE BUS.DATE IN DT.OPEN.SEL<ONE,ONE> BY "AR" SETTING DT.OPEN.LOC ELSE VALID = FALSE
END
*
* Port
IF PORT.SEL NE "ALL" AND BATCH.TILL NE EMPTY THEN
LOCATE BATCH.TILL IN PORT.SEL<ONE,ONE> BY "AR" SETTING PORT.LOC ELSE VALID = FALSE
END
*
* Operator
IF USER.VALID.SEL NE "ALL" AND OPERATOR NE EMPTY THEN
LOCATE OPERATOR IN USER.VALID.SEL<ONE,ONE> BY "AR" SETTING USER.VALID.LOC ELSE VALID = FALSE
END
*
IF BATCH.CLASS.CURR NE "9" AND BATCH.CLASS NE EMPTY THEN
IF BATCH.CLASS.CURR NE BATCH.CLASS THEN VALID = FALSE
END
*
IF BATCH.SOURCE.CURR NE "9" AND BATCH.INP.SOURCE NE EMPTY THEN
IF BATCH.SOURCE.CURR NE BATCH.INP.SOURCE THEN VALID = FALSE
END
*
RETURN
!
END
