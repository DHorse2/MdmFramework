~ACC.UPDATE~
*PROGRAM: ACC.UPDATE 
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       Update attr four of ACC file for location
* DATE WRITTEN:      13 JUL 91
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*                       DEC 95  DGH         Add + and , feature
* '+' - Insert before sub-value 3
* ',' - Add to end of sub-values
* '+999+xxxxx' - Replace sub-value 999 with xxxxxxx
*                and clear out sub-values after it
* ',999,xxxxx' - Insert before sub-value 999
* '+' and ',' can only replace other '+' and ',' lines
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT ACC.FILE.NAME:' file is missing!':; STOP
END
*
!
*
OPEN 'SYS' TO SYS.FILE ELSE STOP
*
PORT = ('000':PORT) 'R#3'
*
READ TERM.DISP FROM SYS.FILE,'USER.DISPLAY.':PORT ELSE
READ TERM.DISP FROM SYS.FILE,'USER.DISPLAY' ELSE TERM.DISP = FALSE
END
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE
*
!
*
READ ACC.REC FROM ACC.FILE,ACC.ID ELSE ACC.REC = EMPTY
ACC.CURR = ACC.REC<ACC.AM.DESC>
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO OFF
END ELSE
IF TERM.DISP THEN
PRINT
PRINT 'Enter the task being done: ':
END
END
*
INPUT RSP:
ACC.VERB = RSP<ONE,TWO>
RSP = RSP<ONE,ONE>
FMT.LEN = (INT(LEN(RSP)/30) + ONE) * 30 - ONE
FMT.STR = 'L#':FMT.LEN
* RSP = RSP FMT.STR
*
LOOP
TMP.VM.MAX = DCOUNT(ACC.CURR<ONE>,VM)
**WHILE TMP.VM.MAX GT 15 AND ACC.CURR<ONE,15>[ONE,ONE] EQ ',' DO
WHILE TMP.VM.MAX GT 15 DO
DEL ACC.CURR<ONE,15>
REPEAT
*
SAVE.RSP = EMPTY
*
!
*
LOOP
*
NEW.VM = -ONE
TC = RSP[ONE,ONE]
IF TC EQ '+' THEN NEW.VM = 3
REF.FL = FALSE
*
IF TC EQ '+' OR TC EQ ',' THEN
* + means insert
* , means replace
*
TMP.VM = FIELD(RSP,TC,TWO)
IF NOT(NUM(TMP.VM)) THEN TMP.VM = 0
*
* numeric + or , reference
IF TMP.VM GT ZERO AND TMP.VM LE 15 THEN
*
REF.FL = TRUE
RSP = RSP[COL2(),9999]
NEW.VM = TMP.VM
*
* numeric +    delete all lines after it
IF TC EQ '+' THEN
LOOP
TMP.VM.MAX = DCOUNT(ACC.CURR<ONE>,VM)
WHILE TMP.VM.MAX GE TMP.VM DO
DEL ACC.CURR<ONE,TMP.VM>
REPEAT
END
*
END ELSE
IF TC EQ '+' THEN
TMP.VM = 3
END ELSE
TMP.VM = -ONE
END
END; * of numeric
*
TC1 = TC
IF TC1 EQ '+' OR TC1 EQ ',' THEN
IF COUNT(RSP,TC1) GT ONE THEN
TMP = INDEX(RSP,TC1,TWO)
SAVE.RSP = RSP[TMP,9999]
RSP = RSP[ONE,TMP - ONE]
END
END ELSE
IF COUNT(RSP,TC1) THEN
TMP = INDEX(RSP,TC1,ONE)
SAVE.RSP = RSP[TMP,9999]
RSP = RSP[ONE,TMP - ONE]
END
END
*
NEW.VM = TMP.VM
FMT.LEN = (INT(LEN(RSP)/30) + ONE) * 30 - ONE
FMT.STR = 'L#':FMT.LEN
RSP = RSP FMT.STR
*
IF TC EQ ',' THEN
IF TRIM(RSP) NE EMPTY AND TRIM(RSP) NE TC THEN ACC.CURR<ONE,NEW.VM> = RSP
END ELSE
IF TRIM(RSP) NE EMPTY AND TRIM(RSP) NE TC THEN
INS RSP BEFORE ACC.CURR<ONE,NEW.VM>
END
END
*
END ELSE
*
* NO line # specified
*
IF COUNT(RSP,'+') THEN
TMP = INDEX(RSP,'+',ONE)
SAVE.RSP = RSP[TMP,9999]
RSP = RSP[ONE,TMP - ONE]
END ELSE IF COUNT(RSP,',') THEN
TMP = INDEX(RSP,',',ONE)
SAVE.RSP = RSP[TMP,9999]
RSP = RSP[ONE,TMP - ONE]
END
*
FMT.LEN = (INT(LEN(RSP)/30) + ONE) * 30 - ONE
FMT.STR = 'L#':FMT.LEN
RSP = RSP FMT.STR
TMP.VM.MAX = DCOUNT(ACC.CURR<ONE>,VM)
TC = RSP[ONE,ONE]
*
IF TRIM(RSP) NE EMPTY AND TRIM(RSP) NE TC THEN
IF TC EQ '+' THEN
INS RSP BEFORE ACC.CURR<ONE,NEW.VM>
END ELSE IF TC EQ ',' THEN
ACC.CURR<ONE,NEW.VM> = RSP
END ELSE
* ACC.CURR<ONE> = RSP
ACC.CURR = RSP
END
END
*
END; * of REF.FL   (+,  or regular)
*
WHILE SAVE.RSP NE EMPTY DO RSP = SAVE.RSP; SAVE.RSP = EMPTY REPEAT
*
!
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO ON
END ELSE IF PROC.FL THEN
IF TERM.DISP THEN
PRINT RSP:
END
END
*
IF TERM.DISP THEN PRINT
*
!
*
ACC.REC<ACC.AM.DESC> = ACC.CURR<ONE>
ACC.REC<ACC.AM.DT>   = DATE()
ACC.REC<ACC.AM.TM>   = TIME()
IF ACC.VERB NE EMPTY THEN
ACC.REC<ACC.AM.VERB> = ACC.VERB
END
WRITE ACC.REC ON ACC.FILE,ACC.ID
*
!
*
STOP
*
*
END
~ASSEMBLE.DICTS~
*PROGRAM: ASSEMBLE.DICTS 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       PRINTS FILE LAYOUTS AS DEFINED IN DICTIONARY
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
MAX.LINES = 55
!
OPEN "CNT" TO CNT.FILE ELSE STOP
OPEN "TEMP" TO TEMP.FILE ELSE STOP
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = ""
CO.NAME = CO.NAME<1,1,1>
TITLE = "Assemble.dicts - Sets up dict. data on TEMP file"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
*
FILE.NAMES = ""
LOOP READNEXT FILE.NAME ELSE FILE.NAME = "@" UNTIL FILE.NAME = "@" DO
IF FILE.NAME # "" THEN FILE.NAMES<-1> = FILE.NAME
REPEAT
!
100 * START
FILE.NAME = FILE.NAMES<1>; IF FILE.NAME = "" THEN STOP
DEL FILE.NAMES<1>
TITLE = "FILE LAYOUT - '":FILE.NAME:"'"
PRINT @(24,11):CLL:TITLE
OPEN "DICT",FILE.NAME ELSE GOTO 100
*
EXECUTE "SSELECT DICT ":FILE.NAME:" BY NUM.ORDER", //SELECT. > FILE.ID.LIST
!
200 *
READNEXT ID FROM FILE.ID.LIST ELSE GOTO 100
IF NOT(NUM(FIELD(ID,",",1))) THEN GOTO 200
READ ITEM FROM ID ELSE GOTO 200
WRITE ITEM ON TEMP.FILE,FILE.NAME:"+":ID
GOTO 200
END
~ATTR.DEC.FIX~
*PROGRAM: ATTR.DEC.FIX 
*
*$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT
PRINT "Enter the file to search: ":
INPUT FILE.NAME
IF FILE.NAME EQ "" OR FILE.NAME EQ "KILL" THEN STOP
OPEN FILE.NAME TO INP.FILE ELSE STOP
*
PRINT
PRINT "Enter the attribute number: ":
INPUT ATTR
IF ATTR EQ "" OR ATTR EQ "KILL" THEN STOP
IF NOT(NUM(ATTR)) THEN STOP
IF ATTR LT 1 THEN STOP
*
CONT = 0
GO.FLAG = 0
*
SELECT INP.FILE TO INP.ID.LIST
*
LOOP
READNEXT INP.ID FROM INP.ID.LIST ELSE STOP
CONT = CONT + 1
WHILE CONT DO
READ ITEM FROM INP.FILE,INP.ID THEN
PRINT @(0,9):CONT "R#5":
IF COUNT(ITEM<ATTR>,".") THEN
DATAVAL = ITEM<ATTR>
IF NOT(GO.FLAG) THEN
PRINT @(10):INP.ID "L#10":ITEM<ATTR> "L#40":
END
MV.MAX = COUNT(DATAVAL,VM)+1
IF NOT(LEN(DATAVAL)) THEN MV.MAX = 0
FOR MV.CN = 1 TO MV.MAX
SV.MAX = COUNT(ITEM<1,MV.CN>,SVM)+1
IF NOT(LEN(ITEM<1,MV.CN>)) THEN SV.MAX = 0
FOR SV.CN = 1 TO SV.MAX
TMP = DATAVAL<1,MV.CN,SV.CN>
OUT.TMP = ""
AST.MAX = COUNT(TMP,"*")+1
IF NOT(LEN(TMP)) THEN AST.MAX = 0
FOR AST.CN = 1 TO AST.MAX
TMP1 = FIELD(TMP,"*",AST.CN)
TMP1 = OCONV(TMP1,"MR0")
IF AST.CN GT 1 THEN OUT.TMP = OUT.TMP:"*"
OUT.TMP = OUT.TMP:TMP1
NEXT AST.CN
DATAVAL<1,MV.CN,SV.CN> = OUT.TMP
NEXT SV.CN
NEXT MV.CN
ITEM<ATTR> = DATAVAL
IF NOT(GO.FLAG) THEN
PRINT @(15,10):ITEM<ATTR> "L#40":
INPUT GO.FLAG:
END
WRITE ITEM ON INP.FILE,INP.ID
END; * OF COUNT(".")
END ELSE NULL
REPEAT
END
~AUTO.LOADER~
SUBROUTINE AUTO.LOADER (PROG.NAME,INPUTS,PROG.DESC)
* PROGRAM:           AUTO.LOADER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       DELAYED AUTO. PROGRAM LOAD
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
OPEN "PAR" TO PAR.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
ONE.ONLYS = "DAILY.UPDATE":VM:"DAILY.REPORT":VM:"MONTHLY.UPDATE":VM:"MONTHLY.REPORT"
NUM.PROGS = 1
LOOP UNTIL PROG.NAME<NUM.PROGS+1> = "" DO NUM.PROGS = NUM.PROGS+1 REPEAT
!
IF NUM.PROGS = 1 THEN
LOOP
PRINT CLB:"Enter I(mmediate start), O(vernight) or <cr> to cancel: ":
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "" THEN STOP
IF RSP = "I" THEN RETURN
UNTIL RSP = "O" DO PRINT BELL: REPEAT
END
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = ""
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Automatic Loading for Overnight Run - ":PROG.DESC<1>
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":
TITLE = " #  Entry date  Time   Program"
TITLE = TITLE "L#40":TITLE "L#40"
PRINT @(0,2):TITLE:RVE
AC = 0
READ.RUNS: *
READ PENDING.RUNS FROM CNT.FILE,"PENDING.RUNS" ELSE PENDING.RUNS = ""
THIS.RUN = ""
LOCATE "" IN PENDING.RUNS SETTING NEXT.AC ELSE NULL
IF AC = 0 THEN AC = NEXT.AC
IF AC+NUM.PROGS > 36 THEN
LOOP
PRINT BELL:CLB:"No more than 36 jobs allowed - enter <cr> to go back: ":
INPUT RSP:; IF RSP = "KILL" THEN STOP
UNTIL RSP = "" DO PRINT BELL: REPEAT
STOP
END
PROG.NUM = NUM.PROGS
LOOP
PENDING.RUN = DATE():"*":TIME():"*":PROG.NAME<PROG.NUM>:"*":PROG.DESC<PROG.NUM>:VM:INPUTS<PROG.NUM>
INS PENDING.RUN BEFORE PENDING.RUNS<AC>
INS "*" BEFORE THIS.RUN<AC>
PROG.NUM = PROG.NUM-1
UNTIL PROG.NUM < 1 DO
REPEAT
GOSUB DISPLAY.RUNS
IF ONE.ONLY.ERR > 0 THEN
PRINT CLB:ONE.ONLY.ERR:" invalid duplicate run(s) found - <cr> to cancel: ":
INPUT RSP:
STOP
END
*
LOOP
PRINT CLB:"* is the run you're loading - C(ancel), # to insert before, or <cr> if okay: ":
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "C" THEN STOP
IF RSP MATCHES "0N" THEN
IF RSP > 0 AND RSP < NEXT.AC THEN AC = RSP; GOTO READ.RUNS
END
UNTIL RSP = "" DO PRINT BELL: REPEAT
WRITE PENDING.RUNS ON CNT.FILE,"PENDING.RUNS"
STOP
!
DISPLAY.RUNS: *
CL = 0; LN = 4
CLS.COL = CL; CLS.ROW = LN; GOSUB CLS.ROUTINE
LOC = 1
ONE.ONLY.CTR = ""
LOOP PENDING.RUN = PENDING.RUNS<LOC,1> UNTIL PENDING.RUN = "" DO
PRG.NM = FIELD(PENDING.RUN,"*",3)
LOCATE PRG.NM IN ONE.ONLYS<1> SETTING ONE.ONLY THEN ONE.ONLY.CTR<1,ONE.ONLY> = ONE.ONLY.CTR<1,ONE.ONLY>+1
PRINT @(CL,LN):LOC "R#2":THIS.RUN<LOC> "L#2":OCONV(FIELD(PENDING.RUN,"*",1),"D2") "L#12":
PRINT OCONV(FIELD(PENDING.RUN,"*",2),"MT") "L#7":FIELD(PENDING.RUN,"*",4)[1,15]
LN = LN+1
IF LN > 21 THEN CL = 40; LN = 4
LOC = LOC+1
REPEAT
ONE.ONLY.ERR = 0
ONE.ONLY = 1
LOOP UNTIL ONE.ONLYS<1,ONE.ONLY> = "" DO
IF ONE.ONLY.CTR<1,ONE.ONLY> > 1 THEN ONE.ONLY.ERR = ONE.ONLY.ERR+1
ONE.ONLY = ONE.ONLY+1
REPEAT
RETURN
$INCLUDE IBP CLS.ROUTINE
END
~AUTO.MAINTENANCE~
*PROGRAM:           AUTO.MAINTENANCE
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       AUTO. BATCH PROGRAM MAINTENANCE
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
OPEN "LOCKS" TO LCK.FILE ELSE STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.TYPE = ZERO
*
!
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = EMPTY
PRINT @(ZERO,ZERO):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Maintain Overnight Processing Schedule"
PRINT @(ZERO,ONE):(SPACE(40 - LEN(TITLE) / TWO):TITLE) "L#80":
TITLE = " #  Entry date  Time   Program"
TITLE = TITLE "L#40":TITLE "L#40"
PRINT @(ZERO,TWO):TITLE:RVE
CNT.ID = "PENDING.RUNS"; PENDING.RUN = ""
*
!
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
WHILE LCK.STAT DO REPEAT
*
READ PENDING.RUNS FROM CNT.FILE,CNT.ID ELSE PENDING.RUNS = EMPTY
*
READ PENDING.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE THIS.RUN = EMPTY
*
GOSUB DISPLAY.RUNS
*
!
*
ENTRIES: *
*
READ PENDING.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE THIS.RUN = EMPTY
*
PRINT CLB:"Enter # to adjust, C(ancel), L(ist), LC (list completed), <cr> to exit:":
INPUT RSP:
*
IF RSP EQ "KILL" OR RSP EQ "C" THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
END
*
IF RSP EQ "L" THEN GOSUB PRINT.RUNS; GOTO ENTRIES
*
IF RSP EQ "LC" THEN GOSUB PRINT.COMPL.RUNS; GOTO ENTRIES
*
IF RSP MATCHES "0N" THEN IF RSP GT ZERO THEN GOSUB ADJUST.RUN; GOTO ENTRIES
*
IF RSP NE EMPTY THEN PRINT BELL:; GOTO ENTRIES
*
WRITE PENDING.RUNS ON CNT.FILE,CNT.ID
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
*
CLS.COL = ZERO; CLS.ROW = 8; GOSUB CLS.ROUTINE
*
STOP
*
!
*
ADJUST.RUN: *
*
AC = RSP
IF PENDING.RUNS<AC,ONE> EQ EMPTY THEN PRINT BELL:; RETURN
LOOP
PRINT CLB:"#":AC:" - M(ove), D(elete) or <cr> if okay: ":
INPUT RSP:
*
IF RSP EQ "KILL" THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
END
*
IF RSP EQ EMPTY THEN RETURN
*
IF RSP EQ "D" THEN
DEL PENDING.RUNS<AC>
GOSUB DISPLAY.RUNS
RETURN
END
*
UNTIL RSP EQ "M" DO PRINT BELL: REPEAT
*
PREV.AC = AC
LOOP
PRINT CLB:"Enter # to insert before or <cr> to move to end: ":
INPUT RSP:
*
IF RSP EQ "KILL" THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
END
*
IF NOT(RSP MATCHES "0N") THEN AC = EMPTY ELSE
AC = RSP
IF AC NE EMPTY THEN
IF AC LT ONE THEN AC = EMPTY ELSE IF PENDING.RUNS<AC> EQ EMPTY THEN AC = EMPTY
END ELSE LOCATE AC IN PENDING.RUNS SETTING AC ELSE NULL
END
*
UNTIL AC DO PRINT BELL: REPEAT
*
IF AC EQ PREV.AC THEN RETURN
*
THIS.RUN = PENDING.RUNS<PREV.AC>
INS THIS.RUN BEFORE PENDING.RUNS<AC>
IF AC LT PREV.AC THEN PREV.AC = PREV.AC + ONE
DEL PENDING.RUNS<PREV.AC>
*
GOSUB DISPLAY.RUNS
*
RETURN
*
!
*
DISPLAY.RUNS: *
*
CL = ZERO; LN = 4
CLS.COL = CL; CLS.ROW = LN; GOSUB CLS.ROUTINE
LOC = ONE
IF PENDING.RUN EQ "" THEN CURR.DISP = TRUE ELSE CURR.DISP = FALSE
*
LOOP
THIS.RUN = PENDING.RUNS<LOC,ONE>
IF THIS.RUN EQ EMPTY AND NOT(CURR.DISP) THEN
PRINT @(ZERO,20):RVB:(LOC "R#2":"  ":OCONV(FIELD(PENDING.RUN,"*",ONE),"D2") "L#12":OCONV(FIELD(PENDING.RUN,"*",TWO),"MT") "L#7":OCONV(FIELD(PENDING.RUN,"*",4),"D2") "L#15") "L#38":
PRINT @(ZERO,21):RVB:FIELD(PENDING.RUN<ONE,ONE>,"*",3) "L#38":RVE:
PRINT @(ZERO,22):RVB:"  **   Currently Running   **   " "L#38":RVE:
CURR.DISP = TRUE
END
UNTIL THIS.RUN EQ EMPTY AND CURR.DISP DO
PRINT @(CL,LN):LOC "R#2":"  ":OCONV(FIELD(THIS.RUN,"*",ONE),"D2") "L#12":
PRINT OCONV(FIELD(THIS.RUN,"*",TWO),"MT") "L#7":OCONV(FIELD(THIS.RUN,"*",4),"D2")[ONE,15]
LN = LN + ONE
IF LN GT 21 THEN CL = 40; LN = 4
LOC = LOC + ONE
REPEAT
*
IF LOC EQ ONE THEN PRINT @(24,11):"No overnight processing is to be done..."
*
RETURN
*
!
*
PRINT.RUNS: *
*
CALL PRINTER.ON(STAT); IF STAT THEN STAT = EMPTY
PRINT FF:
PRINT OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15"
TITLE = "Overnight Processing Schedule"
PRINT SPACE(40 - LEN(TITLE) / TWO):TITLE
TITLE = " #  Entry date  Time   Procedure to be run      Internal name"
PRINT; PRINT; PRINT TITLE; PRINT
LOC = ONE
*
LOOP THIS.RUN = PENDING.RUNS<LOC,ONE> UNTIL THIS.RUN EQ EMPTY DO
PRINT LOC "R#2":"  ":OCONV(FIELD(THIS.RUN,"*",ONE),"D2") "L#12":
PRINT OCONV(FIELD(THIS.RUN,"*",TWO),"MT") "L#7":OCONV(FIELD(THIS.RUN,"*",4),"D2") "L#25":FIELD(THIS.RUN,"*",3)
LOC = LOC + ONE
REPEAT
*
IF LOC EQ ONE THEN PRINT; PRINT; PRINT "No overnight processing is to be done..."
PRINTER OFF
IF OPSYS NE "R" THEN PRINTER CLOSE
*
RETURN
*
!
*
PRINT.COMPL.RUNS: *
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(CNT.FILE,"CNT","COMPLETED.RUNS",LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
WHILE LCK.STAT DO REPEAT
*
READ COMPL.RUNS FROM CNT.FILE,"COMPLETED.RUNS" ELSE COMPL.RUNS = EMPTY
*
CALL PRINTER.ON(STAT); IF STAT THEN STAT = EMPTY
PRINT FF:
PRINT OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15"
TITLE = "Completed Overnight Runs"
PRINT SPACE(40 - LEN(TITLE) / TWO):TITLE
TITLE = " #  Date run    Start  End    Procedure                Internal name"
PRINT; PRINT; PRINT TITLE; PRINT
LOC = ONE
*
LOOP COMPL.RUN = COMPL.RUNS<LOC> UNTIL COMPL.RUN EQ EMPTY DO
PRINT LOC "R#2":"  ":OCONV(FIELD(COMPL.RUN<ONE,TWO>,"*",ONE),"D2") "L#12":
PRINT OCONV(FIELD(COMPL.RUN<ONE,TWO>,"*",TWO),"MT") "L#7":OCONV(FIELD(COMPL.RUN<ONE,3>,"*",TWO),"MT") "L#7":COMPL.RUN<ONE,4> "L#25":COMPL.RUN<ONE,ONE>
LOC = LOC + ONE
REPEAT
*
IF LOC EQ ONE THEN PRINT; PRINT; PRINT "No overnight runs completed since last printing..."
PRINTER OFF
IF OPSYS NE "R" THEN PRINTER CLOSE
*
LOOP
PRINT CLB:"Do wish to delete the completed run log (Y/N): ":
INPUT TMP:
WHILE TMP NE "Y" AND TMP NE "N" DO PRINT BELL: REPEAT
IF TMP EQ "Y" THEN
DELETE CNT.FILE,"COMPLETED.RUNS"
END
CALL UNLOCK.ITEM(CNT.FILE,"CNT","COMPLETED.RUNS",LCK.FILE)
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
*
END
~AUTO.REC.PROCESS~
*PROGRAM: AUTO.REC.PROCESS
* PROGRAM = 'AUTO.REC.PROCESS'
*
* 15 JUN 92 DAVID HORSMAN - AXION COMPUTER SYSTEMS INC.
* ADDED CALLS TO LOCK.ITEM AND UNLOCK.ITEM TO PREVENTS INTERFERANCE
* BETWEEN KBil Subscriber Billing System and Novadyne Computer's MCC
* Software. Item is backed up in BU.AUTO.REC.PROCESS in BP of account
* FC.....
*
* 9/23/91. RY. NOVADYNE COMPUTER SYSTEMS COMPANY, INC.
* THIS PROGRAM CHECKS THE SPOOLER JOBS FILE FOR ANY JOBS FROM
* THE FORM QUEUE "MCC".  THESE WILL BE JOBS RECEIVED FROM THE BANK.
* IF JOBS EXIST, THEY ARE PICKED OUT ONE AT A TIME AND CONVERTED INTO
* DATA ITEMS IN THE "AUTO.REC.TEMP" FILE USING THE SP-EDIT (I) COMMAND.
* THE IDS ARE THE INTERNAL DATE:INTERNAL TIME. THIS IS DONE SO THAT WE
* CAN SSELECT THE ITEMS TO MAKE SURE THEY ARE PROCESSED IN THE CORRECT
* ORDER.  THE SPOOLER PUTS JOBS INTO ANY JOB NUMBER IT CAN, SO YOU
* CAN'T USE THE JOB NUMBERS FOR SORTING. NOTE, THOUGH, THAT IF THE
* JOB IS GREATER THAN 32 K, A NEW ITEM IS CREATED WITH A '1', ETC
* APPENDED TO THE ID DESCRIBED ABOVE.
* THEN, EACH ITEM IS BROKEN INTO INDIVIDUAL RECORDS, AND WRITTEN TO THE
* 'XTR' FILE ON THE 'FC' ACCOUNT.  THE ITEM IDS ARE yymmdd*nnnnnn WHERE
* nnnnnn IS A RIGHT JUSTIFIED, 0 PADDED NUMBER.
* THE NUMBER IS STORED IN THE DICTIONARY OF THE 'XTR' FILE. THE ITEM
* ID IS THE DATE OF THE JOB.  COUNTERS FOR EACH DAY ARE STORED SEPARATELY
* IN CASE THIS PROGRAM GETS SHUT DOWN FOR A FEW DAYS WHILE THE
* COMMS-DESPOOLER CONTINUES RUNNING.  WHEN THE COUNTER IS 30 DAYS OLD,
* IT WILL BE DELETED BY THE 'HOUSEKEEPING' SUBROUTINE.
* AT EACH STEP OF THE PROGRAM THE ITEM 'STATUS' WILL BE UPDATED IN THE
* DICTIONARY OF THE 'XTR' FILE FOR TROUBLESHOOTING PURPOSES.
* 2/7/92. RESET MCC EVERY NIGHT AT 12:12 AM. RY.
*********************
OPEN 'MD' TO MD.FILE ELSE STOP 201,'MD'
OPEN 'AUTO.REC.TEMP' TO TEMP.FILE ELSE ERR = 'AUTO.REC.TEMP' ; GO 5000
OPEN 'DICT', 'XTR' TO D.XTR.FILE ELSE ERR = 'XTR' ; GO 5000
OPEN 'XTR' TO XTR.FILE ELSE ERR = 'XTR' ; GO 5000
*
*
* AXION FIRST CHANGE
*
OPEN 'LOCKS' TO LCK.FILE ELSE ERR = "LOCKS"; GO 5000
*
LCK.ITM = 1; LCK.TYPE = -5; LCK.STAT = ""
*
* AXION END FIRST CHANGE
*
* DEFINE MONTH-NUMERIC ARRAY
CAL = ''
CAL<1> = 'JAN' ; CAL<2> = 'FEB' ; CAL<3> = 'MAR' ; CAL<4> = 'APR'
CAL<5> = 'MAY' ; CAL<6> = 'JUN' ; CAL<7> = 'JUL' ; CAL<8> = 'AUG'
CAL<9> = 'SEP' ; CAL<10> = 'OCT' ; CAL<11> = 'NOV' ; CAL<12> = 'DEC'
*
* ATTRIBUTE DEFINITION ITEM FOR SELECTING OLD RECORD COUNTERS
ATTR.ITEM = '' ; ATTR.ITEM<1> = 'A' ; ATTR.ITEM<2> = '0'
ATTR.ITEM<8> = "D2" ; ATTR.ITEM<9> = "L" ; ATTR.ITEM<10> = "5"
*
* VARIABLES
AM = CHAR(254)   ;* ATTRIBUTE MARK
*
* USE 'SP-JOBS' (IN D/B FORMAT) TO GET ANY SPOOLER JOBS FOR THE
* ACCOUNT 'COMMS-DSP'. THIS IS THE ACCOUNT USED BY THE COMMS-DESPOOLER.
* THE "SPOOLER" FUNCTION WON'T LET YOU GET THE JOBS FOR A PARTICULAR
* FORMQUEUE DIRECTLY.
*
* AXION SECOND CHANGE
*
1 * LOCK XTR.CTL RECORD
*
IF LCK.ITM THEN
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(XTR.FILE,"CNT","XTR.CTL",LCK.FILE,LCK.STAT)
WHILE LCK.STAT DO 
PERFORM "SLEEP 5"
REPEAT
END
*
** AXION ** 1 STATUS = TIME() "MTHS":" - ":DATE() "D2":" -> PERFORM SP-JOBS"
STATUS = TIME() "MTHS":" - ":DATE() "D2":" -> PERFORM SP-JOBS"
*
* AXION END SECOND CHANGE
*
*
WRITE STATUS ON D.XTR.FILE,'STATUS'
SP.LIST = SPOOLER(2,"COMMS-DSP")
IF SP.LIST = '' THEN GO 999  ;* NO JOBS, SO SLEEP FOR AWHILE.
*
* SCAN THE LIST OF SPOOLER JOBS FOR THOSE THAT ARE COMPLETED AND ARE
* IN THE FORM QUEUE 'MCC'. REMEMBER THAT THE COMMS-DESPOOLER WILL ALSO
* OUTPUT JOBS TO THE 'STANDARD' FORM QUEUE - IGNORE THESE.
*
* AXION CHANGE *
ACC.SET = 0
* AXION  END CHANGE *
I = 0   ;* JOB COUNTER
5 I = I + 1
IF SP.LIST<I> = '' THEN GO 500  ;* NOW PROCESS THE DATA ITEMS
IF SP.LIST<I,7> # "QUEUED " THEN GO 5   ;* JOB STILL ACTIVE
IF SP.LIST<I,1> # "MCC" THEN GO 5    ;* WRONG FORM QUEUE. IGNORE IT.
IF NOT(ACC.SET) THEN
DATA "MCC Processing Info."
PERFORM "ACC.UPDATE"
ACC.SET = 1
END
JNUM = SP.LIST<I,2>   ;* JOB NUMBER
STATUS = TIME() "MTHS":" - ":DATE() "D2":" -> PROCESSING SPOOLER JOB #":JNUM
WRITE STATUS ON D.XTR.FILE,'STATUS'
SP.DATE = SP.LIST<I,5>    ;* DAY JOB WAS CREATED (INTERNAL FORMAT)
SP.TIME = SP.LIST<I,6> "R%5"  ;* TIME JOB WAS CREATED (INTERNAL FORMAT)
T.ID = SP.DATE:SP.TIME  ;* ID OF TEMPORARY DATA ITEM
DATA "MCC", "AUTO.REC.TEMP ":T.ID   ;* FILENAME AND ID TO  STORE JOB
PERFORM "SP-EDIT ":JNUM:" (IA" CAPTURING Z   ;* MOVE JOB TO DATA FILE
DATA "MCC"
PERFORM "SP-DELETE ":JNUM CAPTURING Z          ;* DELETE SPOOLER JOB
GO 5
****
* GET JOB ITEMS IN SORTED ORDER AND PROCESS
*
500 PERFORM 'SSELECT AUTO.REC.TEMP' RTNLIST CAPTURING Z SETTING ERR
*
IF ERR<1,1> # '404' THEN GO 999  ;* 404 = N ITEMS SELECTED
510 READNEXT ID ELSE GO 900  ;* FINISHED - GO HOUSEKEEPING
STATUS = TIME() "MTHS":" - ":DATE() "D2":" -> PROCESSING ITEM ":ID:" IN AUTO.REC.TEMP FILE"
WRITE STATUS ON D.XTR.FILE,'STATUS'
EXT = 0   ;* ID EXTENSION FOR JOBS > 32K
*
520 READ SP.ITEM FROM TEMP.FILE,ID ELSE GO 510
*
SP.LIN = COUNT(SP.ITEM,AM) + 1  ;* NUMBER OF ATTRIBUTES IN THIS ITEM.
*
* GET DATE AND TIME OF THIS ITEM
DAT = ID[1,4]
*
* CREATE ID HEADER (YYMMDD) FROM JOB DATE
DAT = OCONV(DAT,'D2')   ;* CHANGE TO DD MMM YY FORMAT
MTH = DAT[4,3]    ;* EXTRACT ALPHABETIC MONTH
LOCATE MTH IN CAL SETTING MNUM ELSE GO 9001  ;* CONVERT TO 2 DIGIT NUMBER
MNUM = MNUM "R%2"    ;* PAD WITH '0' IF NECESSARY
HEAD.ID = DAT[8,2]:MNUM:DAT[1,2]    ;* BUILD ID HEADER
*
* GET NUMERIC RECORD ID
*
READ REC.NUM FROM D.XTR.FILE,HEAD.ID ELSE REC.NUM = 0
*
FOR Z = 1 TO SP.LIN
REC.NUM = REC.NUM + 1
REC.NUM = REC.NUM "R%6"
NEW.ID = HEAD.ID:"*":REC.NUM
NEW.REC = SP.ITEM<Z>
WRITE NEW.REC ON XTR.FILE,NEW.ID
NEXT Z
*
* STORE RECORD COUNTER, AND DELETE DATA ITEM
*
WRITE REC.NUM ON D.XTR.FILE,HEAD.ID
DELETE TEMP.FILE,ID
*
* CHECK IF AN ADDTIONAL ITEM HAD BEEN CREATED BECAUSE THE SPOOLER JOB
* WAS GREATER THAN 32K.  IF SO, THE ITEM ID IS THE ORIGINAL ID WITH
* A 1, 2, 3, ETC, APPENDED TO THE RIGHT OF IT.
*
EXT = EXT + 1
ID = ID:EXT
GO 520   ;* CHECK IF THE ITEM EXISTS.
***
* CLEAR RECORD COUNTERS WHICH ARE OVER 30 DAYS OLD. THE DATE IS THE
* FIRST 4 CHARACTERS OF THE ID. MAKE SURE AN ATTRIBUTE DEFINITION ITEM
* EXISTS IN THIS ACCOUNT'S M/DICT SO THE ENGLISH STATEMENT WORKS.
*
900 * SEND MSG TO PRINTER. THEN CLEAN UP DICTIONARY OF XTR
LIN = OCONV(DATE(),"D"):" ":OCONV(TIME(),"MTH"):" DATA IN XTR FILE"
LIN = "BLOCK-PRINT ":LIN
PERFORM LIN CAPTURING Z
WRITE ATTR.ITEM ON MD.FILE,"MCC.REC.DATE"
DAT = DATE()
LIN = "EDELETE DICT XTR WITH MCC.REC.DATE < ":DAT
PERFORM LIN CAPTURING Z
PERFORM "TEST.TRANSMISSION"
*
999 * REST FOR 10 MINUTES.
*
STATUS = TIME() "MTHS":" - ":DATE() "D2":" -> SLEEPING FOR 10 MINUTES"
WRITE STATUS ON D.XTR.FILE,'STATUS'
*
*
* AXION THIRD CHANGE
*
CALL UNLOCK.ITEM(XTR.FILE,"CNT","XTR.CTL",LCK.FILE)
*
DATA "MCC Control Sleeping"
PERFORM "ACC.UPDATE"
*
*
* AXION END THIRD CHANGE
*
*
 SLEEP 600
*+SLEEP 10
READ ITEM FROM MD.FILE,'STOP' ELSE GO 1000
DELETE MD.FILE,'STOP'
STOP
1000 READ ITEM FROM MD.FILE,'RESET' ELSE GO 1001
DELETE MD.FILE,'RESET'
PERFORM "RESET.MCC" CAPTURING Z
GO 1
*
1001 * RESET MCC IF TIME IS LESS THAN 12:12 AM
IF TIME() > 720 THEN GO 1   ;* DON'T RESET AFTER 12:12 AM
STATUS = TIME() "MTHS":" - ":DATE() "D2":" -> NIGHTLY MCC RESET"
WRITE STATUS ON D.XTR.FILE,'STATUS'
PERFORM "NIGHT.RESET.MCC" CAPTURING Z
GO 1
**
* SYSTEM DATE FORMAT NOT CORRECT. NOTIFY PORT 0, AND LOGOFF
*
9001 PERFORM "MSG !0 SYSTEM DATE FORMAT WRONG" CAPTURING Z
     STOP
*
5000 * CAN'T OPEN A FILE, PUT IN 'STATUS' ITEM
STATUS = TIME() "MTHS":" - ":DATE() "D2":" -> CAN'T OPEN FILE ":ERR
WRITE STATUS ON MD.FILE,'STATUS'
PERFORM "MSG !0 CANT OPEN FILE ":ERR CAPTURING Z
STOP
********************
END
~AUTO.RUNNER~
*PROGRAM:           AUTO.RUNNER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       AUTO. BATCH PROGRAM RUN
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
OPEN "LOCKS" TO LCK.FILE ELSE STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.TYPE = -3
CNT.ID = "PENDING.RUNS"
*
! Read parameters
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",ONE THEN CO.NAME = CO.NAME<ONE,ONE,ONE> ELSE CO.NAME = EMPTY
PRINT @(ZERO,ZERO):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Auto.Runner - Runs previously requested batch programs"
PRINT @(ZERO,ONE):(SPACE(40 - LEN(TITLE) / TWO):TITLE) "L#80":
TITLEA = " #  Entry date  Time   Program"
TITLE = TITLEA "L#40":TITLEA "L#40"
PRINT @(ZERO,TWO):TITLE:RVE
*
! Lock and load pending runs
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
WHILE LCK.STAT DO REPEAT
*
READ PENDING.RUNS FROM CNT.FILE,CNT.ID ELSE PENDING.RUNS = EMPTY
*
GOSUB DISPLAY.RUNS
*
* Check if last ov run completed OK
*
READ PENDING.RUN FROM PAR.FILE,"CURRENT.RUN" THEN
*
LOOP
*
PRINT @(ZERO,17):CLS:BELL:@(ZERO,19):TITLEA:
PRINT @(ZERO,20):LOC "R#2":"  ":OCONV(FIELD(PENDING.RUN,"*",ONE),"D2") "L#12":
PRINT OCONV(FIELD(PENDING.RUN,"*",TWO),"MT") "L#7":OCONV(FIELD(PENDING.RUN,"*",4),"D2"):
PRINT @(ZERO,21):FIELD(PENDING.RUN<ONE,ONE>,"*",3):
*
PRINT CLB:"This last run did not complete!! Enter <cr> . . . ":RVE:BELL:
INPUT TMP:
*
IF TMP EQ "KILL" THEN CHAIN "ZZOFF"
*
WHILE TMP EQ "0" DO REPEAT
*
DELETE PAR.FILE,"CURRENT.RUN"
*
END ELSE NULL
*
*
! Allow maintenance before starting
*
ENTRIES: *
*
PRINT CLB:"Enter # to adjust, C(ancel) or <cr> to start running programs: ":
INPUT RSP:
*
IF RSP EQ "C" OR RSP EQ "KILL" THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
END
*
IF RSP MATCHES "0N" THEN IF RSP GT ZERO THEN GOSUB ADJUST.RUN; GOTO ENTRIES
*
IF RSP EQ "0" THEN RSP = EMPTY
*
IF RSP NE EMPTY THEN PRINT BELL:; GOTO ENTRIES
*
! Process pending runs
*
RUN.PROGRAMS: *
*
SYSTEM.CHANGED = EMPTY
*
LOOP
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
WHILE LCK.STAT DO REPEAT
*
READ PENDING.RUNS FROM CNT.FILE,CNT.ID ELSE PENDING.RUNS = EMPTY
*
UNTIL PENDING.RUNS EQ EMPTY DO
*
PENDING.RUN = PENDING.RUNS<ONE>
DEL PENDING.RUNS<ONE>
WRITE PENDING.RUNS ON CNT.FILE,CNT.ID
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
*
PROC.NAME = FIELD(PENDING.RUN<ONE,ONE>,"*",3)
*
PROC.DESC = FIELD(PENDING.RUN<ONE,ONE>,"*",4)
*
IF PROC.NAME NE EMPTY THEN
*
IF PROC.NAME[LEN(PROC.NAME) - ONE,TWO] = ".?" THEN
PROC.NAME = PROC.NAME[ONE,LEN(PROC.NAME) - TWO]
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = EMPTY
LOCATE PROC.NAME IN SPECIAL.ROUTINES<ONE> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<TWO,LOC>
PROC.NAME = PROC.NAME:".":ROUTINE.SUFFIX
END
*
CLS.COL = ZERO; CLS.ROW = TWO; GOSUB CLS.ROUTINE
PRINT @(20,11):"Next run: ":PROC.NAME:" (":PROC.DESC:")"
WRITE PENDING.RUN ON PAR.FILE,"CURRENT.RUN"
START.TIME = DATE():"*":TIME()
*
! Update user activity
*
EXEC.VERB = "ACC.UPDATE"
TMP = OCONV(DATE(),"D2")
TMP = FIELD(TMP," ",ONE):FIELD(TMP," ",TWO):FIELD(TMP," ",3)
TMP1 = OCONV(TIME(),"MTS")
TMP1 = FIELD(TMP1,":",ONE):":":FIELD(TMP1,":",TWO)
EXEC.IN = ("Overnight - ":TMP:" ":TMP1:", ") "L#25":PROC.DESC "L#25"
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
! Execute current run
*
BEGIN CASE
*
CASE OPSYS = "R"
* DATA ONE       ; * REV ONLY
* IF FIELD(PROC.NAME," ",TWO) EQ EMPTY THEN EXECUTE "RUN BP.OBJ ":PROC.NAME; * REV ONLY
* IF FIELD(PROC.NAME," ",TWO) NE EMPTY THEN EXECUTE PROC.NAME; * REV ONLY
*
CASE OPSYS = "U"
IF FIELD(PROC.NAME," ",TWO) EQ EMPTY THEN
EXECUTE "RUN BP ":PROC.NAME, //IN. < "1"
END ELSE
EXECUTE PROC.NAME, //IN. < "1"
END
*
CASE OPSYS = "M"
IF FIELD(PROC.NAME," ",ONE) EQ "RUN" THEN
TEMP = FIELD(PROC.NAME," ",3)
IF TEMP NE EMPTY THEN
PROC.NAME = PROC.NAME[COL1(),9999]
END
END
EXECUTE PROC.NAME, //IN. < "1"
*
CASE TRUE
*** ERROR
*
END CASE
*
! Check current system & ramdisk
*
END.TIME = DATE():"*":TIME()
* GOSUB CHECK.USER0; * REV ONLY
READ RAMDISK.CNT FROM CNT.FILE,"RAMDISK.FILES" THEN
LOCATE "1" IN RAMDISK.CNT<TWO> SETTING LOC THEN
OPEN "LISTS" TO LISTS.FILE THEN
READ RAMDISK.REC FROM LISTS.FILE,"RAMDISK.FILES" THEN
CALL DOWNLOAD.RAMDISK(CNT.FILE,RAMDISK.CNT,LISTS.FILE,RAMDISK.REC)
OPEN "PAR" TO PAR.FILE ELSE STOP
END
END
END
END
*
! Update completed runs
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(CNT.FILE,"CNT","COMPLETED.RUNS",LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
WHILE LCK.STAT DO REPEAT
*
READ COMPLETED.RUNS FROM CNT.FILE,"COMPLETED.RUNS" ELSE COMPLETED.RUNS = EMPTY
*
READ DAYS.TO.KEEP FROM CNT.FILE,"COMPLETED.RUNS.DAYS" ELSE DAYS.TO.KEEP = 7
*
AC = DCOUNT(COMPLETED.RUNS,AM)
LOOP WHILE LEN(COMPLETED.RUNS) GT 10000 AND AC GT 32 DO
DEL COMPLETED.RUNS<AC>
AC = AC - ONE
REPEAT
*
AC = ONE
LOOP UNTIL COMPLETED.RUNS<AC> EQ EMPTY DO
IF FIELD(COMPLETED.RUNS<AC,3>,"*",ONE) LT DATE() - DAYS.TO.KEEP THEN DEL COMPLETED.RUNS<AC> ELSE
AC = AC + ONE
END
REPEAT
*
COMPLETED.RUNS<AC> = PROC.NAME:VM:START.TIME:VM:END.TIME:VM:PROC.DESC
*
WRITE COMPLETED.RUNS ON CNT.FILE,"COMPLETED.RUNS"
*
CALL UNLOCK.ITEM(CNT.FILE,"CNT","COMPLETED.RUNS",LCK.FILE)
*
DELETE PAR.FILE,"CURRENT.RUN"
*
*
END; * Of PROC.NAME not empty
*
REPEAT
*
!
*
PRINT CLB:@(ZERO,13):
* IF SYSTEM.CHANGED THEN @USER0 = EMPTY; * REV ONLY
*
*
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
*
*
STOP
*
!
*
CHECK.USER0: *
*
* IF @USER0 NE EMPTY THEN RETURN; * REV ONLY
*
* EXECUTE "RUN BP.OBJ INITIALIZATION"; * REV ONLY
*
OPEN "PAR" TO PAR.FILE ELSE STOP
*
OPEN "CNT" TO CNT.FILE ELSE STOP
*
SYSTEM.CHANGED = -ONE
*
RETURN
*
!
*
ADJUST.RUN: *
*
AC = RSP
IF PENDING.RUNS<AC,ONE> EQ EMPTY THEN PRINT BELL:; RETURN
*
! Get action
*
LOOP
PRINT CLB:"#":AC:" - M(ove), D(elete) or <cr> if okay: ":
INPUT RSP:
*
IF RSP EQ "KILL" THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
END
*
IF RSP EQ EMPTY THEN RETURN
*
IF RSP EQ "D" THEN
DEL PENDING.RUNS<AC>
GOSUB DISPLAY.RUNS
RETURN
END
*
UNTIL RSP EQ "M" DO PRINT BELL: REPEAT
*
! Get # to insert before
*
PREV.AC = AC
*
LOOP
PRINT CLB:"Enter # to insert before or <cr> to move to end: ":
INPUT RSP:
*
IF RSP EQ "KILL" THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
END
*
IF NOT(RSP MATCHES "0N") THEN AC = EMPTY ELSE
AC = RSP
IF AC NE EMPTY THEN
IF AC LT ONE THEN AC = EMPTY ELSE IF PENDING.RUNS<AC> EQ EMPTY THEN AC = EMPTY
END ELSE LOCATE AC IN PENDING.RUNS SETTING AC ELSE NULL
END
*
UNTIL AC DO PRINT BELL: REPEAT
*
IF AC EQ PREV.AC THEN RETURN
*
PENDING.RUN = PENDING.RUNS<PREV.AC>
INS PENDING.RUN BEFORE PENDING.RUNS<AC>
IF AC LT PREV.AC THEN PREV.AC = PREV.AC + ONE
DEL PENDING.RUNS<PREV.AC>
*
GOSUB DISPLAY.RUNS
*
RETURN
*
!
*
DISPLAY.RUNS: *
*
CL = ZERO; LN = 4
CLS.COL = CL; CLS.ROW = LN; GOSUB CLS.ROUTINE
LOC = ONE
*
LOOP PENDING.RUN = PENDING.RUNS<LOC,ONE> UNTIL PENDING.RUN EQ EMPTY DO
PRINT @(CL,LN):LOC "R#2":"  ":OCONV(FIELD(PENDING.RUN,"*",ONE),"D2") "L#12":
PRINT OCONV(FIELD(PENDING.RUN,"*",TWO),"MT") "L#7":OCONV(FIELD(PENDING.RUN,"*",4),"D2")[ONE,15]
LN = LN + ONE
IF LN GT 21 THEN CL = 40; LN = 4
LOC = LOC + ONE
REPEAT
*
IF LOC EQ ONE THEN PRINT @(24,11):"No overnight processing is to be done..."
*
RETURN
*
*
$INCLUDE IBP CLS.ROUTINE
*
*
END
~AUTO.RUNNER.ALL~
*PROGRAM: AUTO.RUNNER.ALL
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       AUTO BATCH PROGRAM RUN FOR MULTIPLE REVELATION ACCTS
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
CO.NAME = "Combined Systems"
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Overnight Processing"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
!
BEGIN CASE
CASE OPSYS EQ "R"
OPEN "QFILES" TO Q.FILE ELSE PRINT @(0,10):CLL:"missing QFILES file...":; INPUT RSP:; STOP
CASE OPSYS EQ "U" OR OPSYS EQ "M"
OPEN "MD" TO Q.FILE ELSE PRINT @(0,10):CLL:"missing MD file...":; INPUT RSP:; STOP
CASE TRUE
STOP
END CASE
*
OPEN "LISTS" TO L.FILE ELSE PRINT @(0,10):CLL:"missing LISTS file...":; INPUT RSP:; STOP
*
READ SYSTEMS FROM L.FILE,"SYSTEMS" ELSE PRINT @(0,10):CLL:"list SYSTEMS is missing...":; INPUT RSP:; STOP
*
READ FILES FROM L.FILE,"FILES" ELSE PRINT @(0,10):CLL:"list FILES is missing...":; INPUT RSP:; STOP
*
ACCT.THIS = ACCT
IF ACCT.THIS[ONE,3] EQ "TR." OR ACCT.THIS[ONE,3] EQ "OV." OR ACCT.THIS[ONE,3] EQ "CA." THEN ACCT.THIS = ACCT.THIS[4,9999]
*
!
*
LOOP
*
PRINT @(0,10):CLL:"Enter C(ancel) or <cr> to start overnight processing: ":
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "C" THEN STOP
*
UNTIL RSP = "" DO PRINT BELL: REPEAT
*
!
*
BEGIN CASE
CASE OPSYS EQ "R"
SYSTEM.THIS = ""
CASE OPSYS EQ "U"
SYSTEM.THIS = ACCT.THIS
CASE OPSYS EQ "M"
SYSTEM.THIS = ACCT.THIS
CASE TRUE
**** ERROR
SYSTEM.THIS = "?"
END CASE
*
FOUND.THIS = FALSE
SYSTEM.NEXT = ""
SYSTEM.FIRST = ""
*
!
*
LOOP UNTIL SYSTEMS = "" OR (OPSYS NE "R" AND (FOUND.THIS AND SYSTEM.NEXT NE "")) DO
*
SYSTEM.ID = SYSTEMS<1>
DEL SYSTEMS<1>
SYSTEM.ID = TRIM(SYSTEM.ID)
SYSTEM.PASSWORD = FIELD(SYSTEM.ID," ",3)
DRIVE.ID = FIELD(SYSTEM.ID," ",2)
SYSTEM.ID = FIELD(SYSTEM.ID," ",1)
*
PRINT @(0,12):SYSTEM.ID "L#20":
PRINT @(0,13):DRIVE.ID "L#20":
*
IF SYSTEM.FIRST = "" THEN SYSTEM.FIRST = SYSTEM.ID
IF FOUND.THIS THEN SYSTEM.NEXT = SYSTEM.ID
IF SYSTEM.ID = SYSTEM.THIS THEN FOUND.THIS = TRUE
IF SYSTEMS = "" THEN SYSTEM.NEXT = SYSTEM.FIRST
*
!
*
BEGIN CASE
CASE OPSYS EQ "R"
Q.REC = "QFILE"; Q.REC<2> = SYSTEM.ID
CASE TRUE
Q.REC = "Q"; Q.REC<2> = SYSTEM.ID
END CASE
*
!
*
AC = 1
LOOP FILE.ID = FILES<AC> UNTIL FILE.ID = "" DO
*
BEGIN CASE
*
CASE OPSYS EQ "R"
Q.REC<3> = FILE.ID
WRITE Q.REC ON Q.FILE,FILE.ID
*
CASE (OPSYS EQ "U" OR OPSYS EQ "M") AND FILE.ID EQ "CNT"
IF SYSTEM.NEXT NE ACCT.THIS THEN
READV FILE.TYPE FROM Q.FILE,SYSTEM.NEXT:".":FILE.ID,ONE ELSE FILE.TYPE = "Q"
IF FILE.TYPE EQ "Q" THEN
Q.REC<3> = FILE.ID
WRITE Q.REC ON Q.FILE,SYSTEM.NEXT:".":FILE.ID
END
END
*
END CASE
*
AC = AC+1
REPEAT
*
!
*
BEGIN CASE
*
CASE OPSYS = "R"
EXECUTE "ATTACH ":DRIVE.ID
* DATA 0; * REV ONLY
* PERFORM "RUN BP.OBJ AUTO.RUNNER"; * REV ONLY
*
CASE OPSYS = "U" OR OPSYS EQ "M"
*
SYSTEM.TMP = SYSTEM.NEXT:"."
IF SYSTEM.NEXT EQ ACCT.THIS THEN SYSTEM.TMP = EMPTY
OPEN SYSTEM.TMP:"CNT" TO CNT.FILE THEN
*
READ RUNS.NEXT FROM CNT.FILE,"PENDING.RUNS" THEN
*
IF RUNS.NEXT NE EMPTY THEN
*
* ULT ONLY
* EXECUTE "RUN BP AUTO.RUNNER", //IN. < "0"
* ULT ONLY
CHAIN "LOGTO OV.":SYSTEM.ID:",":SYSTEM.PASSWORD
*
END ELSE SYSTEM.NEXT = EMPTY
*
END ELSE SYSTEM.NEXT = EMPTY
*
END ELSE SYSTEM.NEXT = EMPTY
*
CASE 1
**** ERROR
*
END CASE
*
REPEAT
*
!
*
STOP
!
END
~AUTO.RUNNER.ALL2~
*PROGRAM:           AUTO.RUNNER.ALL2
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       AUTO BATCH PROGRAM RUN FOR MULTIPLE REVELATION ACCTS
*                    *VERSION 2 - USE WHERE ACCOUNTS ARE IN SEPARATE DOS
*                                 SUBDIRECTORIES...
*
* DATE WRITTEN:      20 DEC 85
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
IF OPSYS # "R" THEN STOP
CO.NAME = "Combined Systems"
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Overnight Processing"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
!
OPEN "LISTS" TO L.FILE ELSE PRINT @(0,10):CLL:"missing LISTS file...":; INPUT RSP:; STOP
READ SYSTEMS FROM L.FILE,"SYSTEM.LOCATIONS" ELSE PRINT @(0,10):CLL:"LISTS SYSTEM.LOCATIONS is missing...":; INPUT RSP:; STOP
*
LOOP
PRINT @(0,10):CLL:"Enter C(ancel) or <cr> to start overnight processing: ":
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "C" THEN STOP
UNTIL RSP = "" DO PRINT BELL: REPEAT
!
VC = 1
LOOP UNTIL SYSTEMS<5,VC> = "" DO
IF SYSTEMS<7,VC> = SYSTEMS<1> THEN
PRINT @(0,0):CLS:
ACCT = SYSTEMS<5,VC>
SYSTEMS<4> = ACCT:"/OV"
* @USER0 = ""; * REV ONLY
WRITE SYSTEMS ON L.FILE,"SYSTEM.LOCATIONS"
* PERFORM "RUN BP.OBJ INITIALIZATION"; * REV ONLY
* DATA 0; * REV ONLY
* PERFORM "RUN BP.OBJ AUTO.RUNNER"; * REV ONLY
END
VC = VC+1
REPEAT
* @USER0 = ""; * REV ONLY
STOP
!
END
~AUX.OFF~
*PROGRAM: AUX.OFF 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT AUX.OFF:
*
STOP
*
END
~AUX.ON~
*PROGRAM: AUX.ON 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT AUX.ON:
*
STOP
*
END
~AUX.SUBR.OFF~
SUBROUTINE AUX.SUBR.OFF(AUX.STAT)
* PROGRAM:           AUX.SUBR.OFF
* AUTHOR:    David Horsman/Macroscope Design Matrix
*            Axion Computer Systems Ltd.
*
* DESCRIPTION:       TURNS Terminal Auxillary Port or PC Com Port ON
*
* DATE WRITTEN:      30 DEC 92
* DATE RELEASED:     30 DEC 92
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
RQM
$INCLUDE IBP AUX.INCL.OFF
RQM
RETURN
END
~AUX.SUBR.ON~
SUBROUTINE AUX.SUBR.ON(AUX.STAT)
* PROGRAM:           AUX.SUBR.ON
* AUTHOR:    David Horsman/Macroscope Design Matrix
*            Axion Computer Systems Ltd.
*
* DESCRIPTION:       TURNS Terminal Auxillary Port or PC Com Port ON
*
* DATE WRITTEN:      30 DEC 92
* DATE RELEASED:     30 DEC 92
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP AUX.INCL.ON
RQM
RETURN
END
~BEEP~
*PROGRAM: BELL 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
START: *
FOR A = 1 TO 4
PRINT BELL:
FOR B = 1 TO 1000
NULL
NEXT B
NEXT A
STOP
END
~BELL~
*PROGRAM: BELL 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
START: *
PRINT BELL:RVB:"*******":RVE:"        ":
RQM
RQM
IF SYSTEM(11) LT 4 THEN GOTO START
END
~BILL.EFT.STMT.LOADER~
*PROGRAM:           BILL.EFT.STMT.LOADER
* VERSION: 910207 2.6  REMOVED.NO.DUE.DATE.FOR.6X8.5.FORMAT
* PRIOR: 910128 2.6  ADD.CLL.TO.DISPLAY.OF.LATEST.BILLING.DATE
* PRIOR: 901009 2.4  SET.EFT.PAYMENT.DATE.TO.NULL
* PRIOR 900808 2.3  GEN.ADDED.TO.CALL.TO.STAT.SUB.INPUT
* PRIOR 900731 2.1  AC FOR EFT MOVED TO AFTER RSP 'Y'
* PRIOR: 900401 1.9
* PRIOR: 890825
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       AUTOMATIC OVERNIGHT LOAD BILLING AND STATEMENTS
*                    RUN.TYPE 1 = BILLING ONLY
*                             2 = BILLING AND STATEMENTS
*                             3 = BILLING, EFT GENERATION AND STATEMENTS
*                             IF NO DISK SPOOLER THEN STATEMENTS NOT GENERATED
*                             IF NO PAP CLIENT NUM THEN EFT NO EFT GENERATION
* DATE WRITTEN:      DD MMM 82
* DATE RELEASED:     DD MMM 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
*
INPUT RUN.TYPE
IF NOT(RUN.TYPE) THEN RUN.TYPE = 1
VERSION = " (2.6)"
EFT.PAYMENT.DATE = ""; READ PAP.CLIENT.NUM FROM PAR.FILE,"PAP.CLIENT.NUM" ELSE PAP.CLIENT.NUM = ""
READ BILLING.CYCLES FROM PAR.FILE,"BILLING.CYCLES" ELSE BILLING.CYCLES = ""
IF BILLING.CYCLES<1,2> = "" THEN BILLING.CYCLES = ""
READ LAST.BILLING.DATES FROM CNT.FILE,"LAST.BILLING.DATE" ELSE LAST.BILLING.DATES = ""
LAST.BILLING.DATE = LAST.BILLING.DATES<1,1>
*
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = ""
IF SPECIAL.ROUTINES NE "" THEN LOCATE "STATEMENTS" IN SPECIAL.ROUTINES<1> SETTING LOC ELSE NULL
IF LOC THEN STMT.TYPE = SPECIAL.ROUTINES<2,LOC>
*
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE CURR.ACCTG.PERIOD = ""
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE CURR.ACCTG.DATE = ""
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
!
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE1 = "Regular billing "; TITLE2 = ""
IF RUN.TYPE GT 2 THEN TITLE1 = TITLE1:", EFT generation, "
IF RUN.TYPE GT 1 THEN TITLE1 = TITLE1:"and statements"
TITLE1 = TITLE1:VERSION
PRINT @(0,1):(SPACE(40-LEN(TITLE1)/2):TITLE1) "L#80":RVE:
!
BCYC.SEL: *
HIGH.DAY = ""; CYCSEL = ""; CYCLIT = ""
IF BILLING.CYCLES # "" THEN
TITLE2 = "Billing Loader"
PRINT @(0,2):RVB:(SPACE(40-LEN(TITLE2)/2):TITLE2) "L#80":RVE:
CALL BILLING.CYCLE.SELECT(BILLING.CYCLES,CYCSEL,CYCLIT,RSP)
IF RSP = "KILL" THEN STOP
CYC.NUM = 1
LOOP UNTIL BILLING.CYCLES<1,CYC.NUM> = "" DO
IF FIELD(CYCSEL,"*",CYC.NUM) = "Y" THEN
IF BILLING.CYCLES<1,CYC.NUM> > HIGH.DAY THEN HIGH.DAY = BILLING.CYCLES<1,CYC.NUM>
END
CYC.NUM = CYC.NUM+1
REPEAT
IF CYCLIT # "" THEN TITLE2 = TITLE2:"   ":CYCLIT
IF TITLE2 NE "" THEN PRINT @(0,2):RVB:(SPACE(40-LEN(TITLE2)/2):TITLE2) "L#80":RVE:
END
!
RSP.RELOOP1: *
IF LAST.BILLING.DATE THEN PRINT @(0,5):CLL:"Last billing run was to ":OCONV(LAST.BILLING.DATE,"D2"):
MSG = "Enter latest billing date for this run: "
LOOP
PRINT @(0,7):CLL:MSG:
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "^" THEN GOTO BCYC.SEL
IF RSP = "" THEN STOP
LATEST.BILLING.DATE = RSP
CALL GET.ICONV(LATEST.BILLING.DATE,"D")
IF HIGH.DAY THEN
IF HIGH.DAY > 27 THEN
IF OCONV(LATEST.BILLING.DATE,"D2")[3,7] = OCONV(LATEST.BILLING.DATE+1,"D2")[3,7] THEN
LATEST.BILLING.DATE = ""; PRINT CLB:"must be last day of month":
END
END ELSE
TMP = OCONV(LATEST.BILLING.DATE,"D2")[1,2] - HIGH.DAY
IF TMP THEN LATEST.BILLING.DATE = ""; PRINT CLB:"day must be ":HIGH.DAY:
END
END
UNTIL LATEST.BILLING.DATE DO
PRINT BELL:
REPEAT
PRINT @(0,7):CLL:MSG:OCONV(LATEST.BILLING.DATE,"D2"):"   ":CYCLIT
PROCS = ""; DESCS = ""; AC = 1; INPUTS = ""
INPUTS<AC,7> = CYCSEL
INPUTS<AC,8> = CYCLIT
*
IF PAP.CLIENT.NUM<10> # "" THEN
EFT.PAYMENT.DATE = LATEST.BILLING.DATE+4
MSG = "Enter EFT payment date for this run:    "
LOOP
PRINT @(0,9):CLL:MSG:OCONV(EFT.PAYMENT.DATE,"D2")
PRINT @(LEN(MSG),9):
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "^" THEN GOTO RSP.RELOOP1
IF RSP # "" THEN EFT.PAYMENT.DATE = RSP; CALL GET.ICONV(EFT.PAYMENT.DATE,"D")
IF EFT.PAYMENT.DATE THEN
PRINT @(LEN(MSG),9):CLL:OCONV(EFT.PAYMENT.DATE,"D2")
IF EFT.PAYMENT.DATE < LATEST.BILLING.DATE THEN
PRINT CLB:"That's prior to latest billing date - are you sure? ":
INPUT RSP:
PRINT CLB:
IF RSP # "Y" THEN EFT.PAYMENT.DATE = ""
END
END
UNTIL EFT.PAYMENT.DATE DO
EFT.PAYMENT.DATE = LATEST.BILLING.DATE+4
REPEAT
END
PROCS<AC> = "BILLING"; INPUTS<AC> = OCONV(LATEST.BILLING.DATE,"D2"):VM:OCONV(EFT.PAYMENT.DATE,"D2"):VM:INPUTS<AC>; DESCS<AC> = "Bill to ":INPUTS<AC>[1,6]
* AC = AC+1
!
IF (RUN.TYPE GT 2 AND PAP.CLIENT.NUM<10> NE "") THEN
TITLE2 = "EFT Generation Loader"
PRINT @(0,2):RVB:(SPACE(40-LEN(TITLE2)/2):TITLE2) "L#80":RVE:
LOOP
PRINT @(0,12):CLL:"Do you wish to do EFT Generation now? (Y/N) ":
INPUT RSP:
UNTIL RSP = "Y" OR RSP = "N" DO PRINT BELL: REPEAT
IF RSP = "Y" THEN
AC = AC+1
PROCS<AC> = "GENERATE.?"
INPUTS<AC> = ""
DESCS<AC> = "EFT Generation"
END
END
!
READ STATEMENT.CONTROL FROM PAR.FILE,"STATEMENT.CONTROL" ELSE STATEMENT.CONTROL = 15:AM:2:AM:"N":AM:50:AM:1:AM:"N":AM:"N":AM:0:AM:"N"
READV HOLD.FILES FROM PAR.FILE, "STATEMENT.HOLD.FILES",1 ELSE HOLD.FILES = STATEMENT.CONTROL<3>
IF HOLD.FILES = "Y" THEN HOLD.FILES = 1 
IF HOLD.FILES NE 1 THEN HOLD.FILES = 0
IF RUN.TYPE GT 1 THEN IF HOLD.FILES THEN
AC = AC+1
TITLE2 = "Statement Loader"
PRINT @(0,2):RVB:(SPACE(40-LEN(TITLE2)/2):TITLE2) "L#80":RVE:
PYDD = ""
IF NOT(STMT.TYPE = "STANDARD" OR STMT.TYPE = "6X10") THEN
AUTO.RUN = 0; SYS.PROG = "STATEMENTS":STMT.TYPE
TEST.FL = 0;  REJECTED.DESC = ""; RNTP = "REGULAR"; RPR = 0
DIM MG(20); DIM MG.LGTH(20)
MAT MG = ""; MAT MG.LGTH = ""
*
CTR = 0; STMT.COUNT = 0; ACR = 1; FR.FLAG = 0; TO.FLAG = 0
STMT.COUNT.MPG = 0; ACT.ID = ""
FR.ACT = STR("0",6); TO.ACT = STR("9",6); SINGLE = 0
LPI6 = ''; LPI8 = ''
DIM BMG(3)
MAT BMG = ""
DIM TDSC(4)
MAT TDSC = ""
RNTP.RSP = "REGULAR"
LN = 4
CALL STAT.SUB.INPUT(PAR.FILE,MXACR,PMT.N.S,RECALC.DISC,PCODE.SORT,SYS.PROG,CNT.FILE,RQC,DBTW,TT.PMT,TT.ADJ,TT.DEP,CCR,MDQA,MDQS,MDD,DCR,PYM,TEST.FL,MTP,MAT MG,MAT MG.LGTH,CO.NAME,RNTP.RSP,ST.IDATE,PYDD,FR.ACT,TO.ACT,LFL,HF,HC,AUTO.RUN,MAT BMG,REJECTED.DESC,FCV,FCN,CLC,LN,BFS,BFS.ANN,MAT TDSC,ST.PRDT,DISC.DATE,TM,RPR,RNTP,BILLING.CYCLES,CYCSEL,MXPRT,INRNG,SINGLE,RSP,CURRENT.RUN,GEN)
INPUTS<AC> = RSP
END ELSE
ST.PRDT = DATE()
PRINT @(0,14):" statements dated ":OCONV(ST.PRDT,"D2")
*
DISCON.DATE = ST.PRDT+14
LOOP
PRINT @(0,16):CLL:"Enter disconnect date to use on this statement run: ":OCONV(DISCON.DATE,"D2"):@(52,16):
INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "" THEN RSP = DISCON.DATE ELSE CALL GET.ICONV(RSP,"D")
UNTIL RSP AND RSP > ST.PRDT DO
PRINT BELL:
REPEAT
DISCON.DATE = RSP
PRINT @(0,16):CLL:"Disconnect date used for this statement run: ":OCONV(DISCON.DATE,"D2"):
INPUTS<AC> = "REGULAR":VM:VM:OCONV(DISCON.DATE,"D2"):VM:VM:CYCSEL:VM:CYCLIT
END
PROCS<AC> = "STATEMENTS.?"
DESCS<AC> = "Statements"
END
!
AC = AC+1
PROCS<AC> = "DAILY.UPDATE"; INPUTS<AC> = ""; DESCS<AC> = "Daily update"
AC = AC+1
PROCS<AC> = "UPDATE.WKO.COUNTS";   INPUTS<AC> = "1"; DESCS<AC> = "W/O Counts"
AC = AC+1
PROCS<AC> = "DAILY.REPORT"; INPUTS<AC> = ""; DESCS<AC> = "Daily report"; * ULT ONLY
CALL AUTO.LOADER(PROCS,INPUTS,DESCS)
!
END
~CASH.SUBR.OPEN.TILL~
SUBROUTINE CASH.SUBR.OPEN.TILL(PAR.FILE,MAT CNT.CSH,CNT.CSH.ID,PORT.CC,STAT)
* PROGRAM:           CASH.SUBR.OPEN.TILL
* AUTHOR:    David Horsman/Macroscope Design Matrix
*            Axion Computer Systems Ltd.
*
* DESCRIPTION:       TURNS Terminal Auxillary Port or PC Com Port ON
*
* DATE WRITTEN:      30 DEC 92
* DATE RELEASED:     30 DEC 92
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
!
*
TILL.OPEN.ID = CNT.CSH$TILL.TYPE<ONE,PORT.CC>
*
IF TILL.OPEN.ID NE EMPTY THEN
*
READ TILL.OPEN FROM PAR.FILE,"CASH.TILL.":TILL.OPEN.ID ELSE
TILL.OPEN.ID = PORT
READ TILL.OPEN FROM PAR.FILE,"CASH.TILL.":TILL.OPEN.ID ELSE
TILL.OPEN = EMPTY
PRINT CLB:"Cash Till Type ":CNT.CSH$TILL.TYPE<ONE,PORT.CC>:" is undefined. Enter <cr>: ":; INPUT TMP:; STAT = 999; RETURN
END
END
*
END ELSE TILL.OPEN = EMPTY
*
TILL.OPEN.STR = EMPTY
LOOP UNTIL TILL.OPEN<ONE> EQ EMPTY DO TILL.OPEN.STR = TILL.OPEN.STR:CHAR(TILL.OPEN<ONE,ONE>); DEL TILL.OPEN<ONE,1> REPEAT
*
PRINT TILL.OPEN.STR:
RQM
*
RETURN
*
END
~CHANGE.SYSTEMS~
*PROGRAM:           CHANGE.SYSTEMS
* AUTHOR:            BOB CONARROE
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      18 DEC 85
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "LISTS" TO LISTS.FILE ELSE TEXT = "Can't open LISTS"; GOSUB ERROR; STOP
CO.DATA = "System not on disk":AM:DATE()
OPEN "CNT" TO CNT.FILE THEN
READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN NULL
END
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP
* LCK.FILE = 0; * REV ONLY
*
CO.NAME = CO.DATA<1,1,1>
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(5)
VALID.REFS = "MN":AM:"EF":AM:"PR":AM:"CU":AM:"SY"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
LISTS.ID = ""; GOSUB GET.KEY; IF LISTS.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(LISTS.FILE,"LISTS",LISTS.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ LISTS FROM LISTS.FILE,LISTS.ID THEN NEW = "" ELSE NEW = 1; LISTS = ""
PREV.SYSTEM = LISTS<4>; *CUSTOM*
PREV.LISTS = LISTS; *CUSTOM*
IF NOT(NEW) THEN
FIRST.TIME = 1; *CUSTOM*
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = LISTS.ID; LISTS.ID = "!":LISTS.ID; GOSUB GET.KEY; LISTS.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
FIRST.TIME = ""; *CUSTOM*
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 5
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *CUSTOM*
IF FIRST.TIME = 1 THEN FIRST.TIME = ""; RSP = "CU" ELSE
PRINT CLB:"Enter screen ref., REdisplay, KILL or <cr> to update: ":
INPUT RSP:
END
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""
IF PREV.SYSTEM # LISTS<4> THEN GOTO DETACH.DISK; *CUSTOM*
GOTO UPDATE
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = LISTS.ID; LISTS.ID = "!":LISTS.ID; GOSUB GET.KEY; LISTS.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
DETACH.DISK: *
TMP = PREV.LISTS<4>
LOCATE TMP IN PREV.LISTS<5> SETTING VCP THEN
FOR DRIVE.AC = 8 TO 9
DRIVE = PREV.LISTS<DRIVE.AC,VCP>
IF DRIVE # "" THEN
DRIVE = DRIVE:":\CABLE\":PREV.LISTS<4>
PRINT CLB:"Detaching ":DRIVE:
EXLN = "DETACH ":DRIVE
* EXECUTE EXLN; * REV ONLY
END
NEXT DRIVE.AC
END
* @USER0 = ""; * REV ONLY
!
UPDATE: *
WRITE LISTS ON LISTS.FILE,LISTS.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(LISTS.FILE,"LISTS",LISTS.ID,LCK.FILE)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                          System Location Maintenance                           ":RVE:
PRINT @(0,3):RVB:"MN> The name of this machine is:                    ":RVE:
PRINT @(0,5):RVB:"EF> The EFT subdirectory is located on drive:       ":RVE:
PRINT @(0,6):RVB:"PR> The programs subdirectory is located on drive:  ":RVE:
PRINT @(0,8):RVB:"CU> The current system is:                          ":RVE:
PRINT @(0,10):RVB:"SY> System":RVE:"  ":RVB:"System name              ":RVE:"  ":RVB:"Machine ":RVE:"  ":RVB:"Drive1":RVE:" ":RVB:"Drive2":RVE:"  ":RVB:"Moved on ":RVE:"  ":RVB:"By   ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(53,3):LISTS<1> "L#8":
PRINT @(53,5):LISTS<2> "L#1":
PRINT @(53,6):LISTS<3> "L#1":
PRINT @(53,8):LISTS<4> "L#10":
DYNAMIC = ""; GOSUB D05; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
LISTS.ID = "SYSTEM.LOCATIONS"
RETURN
!
GET.DATA: *
ON REF GOSUB I01,I02,I03,I04,I05
RETURN
!
I01: CALL INPUT.DATA(LISTS,53,3,"L8",1,"","","",RSP,STAT); RETURN
I02: CALL INPUT.DATA(LISTS,53,5,"L1",2,"","OPEQCDEFGHIJ","",RSP,STAT); RETURN
I03: CALL INPUT.DATA(LISTS,53,6,"L1",3,"","EQCDEFGHIJ","",RSP,STAT); RETURN
I04: CALL INPUT.DATA(LISTS,53,8,"L6",4,"","","",RSP,STAT); *CUSTOM*
IF STAT = 999 THEN RETURN
IF PREV.SYSTEM = LISTS<4> THEN RETURN
CURR.SYSTEM = LISTS<4>
LOCATE CURR.SYSTEM IN LISTS<5> SETTING VC5 ELSE
TEXT = "not a valid system code"
GOSUB ERROR
LISTS<4> = PREV.SYSTEM
PRINT @(53,8):PREV.SYSTEM "L#6":
GOTO I04
END
IF LISTS<7,VC5> # LISTS<1> THEN
TEXT = "system is not on this machine"
GOSUB ERROR
LISTS<4> = PREV.SYSTEM
PRINT @(53,8):PREV.SYSTEM "L#6":
GOTO I04
END
RETURN
I05: IF NEW THEN
LOCATE "" IN LISTS<5> SETTING VC ELSE NULL
DYNAMIC = "N"
END ELSE
PRINT CLB:"Ref. SY> - Enter line no., N(ext line) or <cr> if okay: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
IF DYNAMIC = "" OR DYNAMIC = "^" THEN RETURN
IF DYNAMIC = "N" THEN
LOCATE "" IN LISTS<5> SETTING VC ELSE NULL
END ELSE
IF NOT(DYNAMIC MATCHES "0N") THEN PRINT BELL:; GOTO I05
IF NOT(DYNAMIC) THEN PRINT BELL:; GOTO I05
VC = DYNAMIC
IF LISTS<5,VC> = "" THEN PRINT BELL:; GOTO I05
LOOP
PRINT CLB:"Enter I(nsert), D(elete) or <cr> to change line: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
UNTIL DYNAMIC = "I" OR DYNAMIC = "D" OR DYNAMIC = "" DO PRINT BELL: REPEAT
END
END
IF NOT(DYNAMIC = "I" OR DYNAMIC = "N") THEN
IF DYNAMIC = "D" THEN
DEL LISTS<5,VC>
DEL LISTS<6,VC>
DEL LISTS<7,VC>
DEL LISTS<8,VC>
DEL LISTS<9,VC>
DEL LISTS<10,VC>
DEL LISTS<11,VC>
TOP.DISP.LOC(5) = -ABS(TOP.DISP.LOC(5))
DYNAMIC = "D"; GOSUB D05; IF STAT = 999 THEN RETURN
GOTO I05
END
END ELSE
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I05
END
INS " " BEFORE LISTS<5,VC>
INS "" BEFORE LISTS<6,VC>
INS "" BEFORE LISTS<7,VC>
INS "" BEFORE LISTS<8,VC>
INS "" BEFORE LISTS<9,VC>
INS "" BEFORE LISTS<10,VC>
INS "" BEFORE LISTS<11,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(5) = -ABS(TOP.DISP.LOC(5)) ELSE IF NOT(TOP.DISP.LOC(5)) THEN TOP.DISP.LOC(5) = 1
END
GOSUB D05; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,11)+12
FOR SUB.REF = 1 TO 7
ON SUB.REF GOSUB I05A,I05B,I05C,I05D,I05E,I05F,I05G
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 7
IF SUB.REF = 1 THEN IF RSP = "" THEN RETURN
NEXT SUB.REF
GOTO I05
I05A: IF LISTS<5,VC> = " " THEN LISTS<5,VC> = ""
PRINT @(1,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":; CALL INPUT.DATA(LISTS,4,LN,"L6",5:",":VC,"","OP","",RSP,STAT)
IF RSP = "" THEN IF DYNAMIC # "N" THEN PRINT BELL:; GOTO I05A
RETURN
I05B: CALL INPUT.DATA(LISTS,12,LN,"L25",6:",":VC,"","","",RSP,STAT)
RETURN
I05C: CALL INPUT.DATA(LISTS,39,LN,"L8",7:",":VC,"","","",RSP,STAT)
RETURN
I05D: *CUSTOM*
TMP = LISTS<8,VC>; *CUSTOM*
CALL INPUT.DATA(LISTS,49,LN,"L1",8:",":VC,"","EQCDEFGHIJ","",RSP,STAT)
IF TMP # LISTS<8,VC> AND LISTS<5,VC> = LISTS<4> THEN PREV.SYSTEM = ""; *CUSTOM*
RETURN
I05E: *CUSTOM*
TMP = LISTS<9,VC>; *CUSTOM*
CALL INPUT.DATA(LISTS,56,LN,"L1",9:",":VC,"","OPEQCDEFGHIJ","",RSP,STAT)
IF TMP # LISTS<9,VC> AND LISTS<5,VC> = LISTS<4> THEN PREV.SYSTEM = ""; *CUSTOM*
RETURN
I05F: CALL INPUT.DATA(LISTS,64,LN,"L9",10:",":VC,"D2","OPDT","",RSP,STAT)
RETURN
I05G: CALL INPUT.DATA(LISTS,75,LN,"L5",11:",":VC,"","","",RSP,STAT)
RETURN
D05: SAVE.VC = VC
IF TOP.DISP.LOC(5) < 0 THEN TOP.DISP.LOC(5) = ABS(TOP.DISP.LOC(5)) ELSE
IF VC >= TOP.DISP.LOC(5) THEN IF VC <= TOP.DISP.LOC(5)+10 THEN RETURN
END
IF TOP.DISP.LOC(5) THEN VC = VC-MOD(VC-1,11); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 12 TO 22 UNTIL LISTS<5,VC> = ""
IF LN = 12 THEN TOP.LOC = VC
PRINT @(1,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":LISTS<5,VC> "L#6":
PRINT @(12,LN):LISTS<6,VC> "L#25":
PRINT @(39,LN):LISTS<7,VC> "L#8":
PRINT @(49,LN):LISTS<8,VC> "L#1":
PRINT @(56,LN):LISTS<9,VC> "L#1":
PRINT @(64,LN):OCONV(LISTS<10,VC>,"D2") "L#9":
PRINT @(75,LN):LISTS<11,VC> "L#5":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(5) OR LISTS<5,VC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 12; GOSUB C05 REPEAT
IF CLEAR THEN GOSUB C05 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(5) = TOP.LOC
VC = SAVE.VC
RETURN
C05: FOR LN = LN TO 22
PRINT @(1,LN):SPACE(9):
PRINT @(12,LN):SPACE(25):
PRINT @(39,LN):SPACE(8):
PRINT @(49,LN):SPACE(1):
PRINT @(56,LN):SPACE(1):
PRINT @(64,LN):SPACE(9):
PRINT @(75,LN):SPACE(5):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~CHAR.CONV~
*PROGRAM: CHAR.CONV 
*
LOOP
LOOP
PRINT "ENTER THE LETTER TO CONVERT: ":; INPUT LETTER
IF LETTER EQ "KILL" OR LETTER EQ "EX" OR LETTER EQ "END" THEN STOP
IF LEN(LETTER) GT 1 THEN LETTER = LETTER[1,1]
WHILE LETTER NE "" DO
***
PRINT
PRINT "THE LETTER ":LETTER:" CONVERTS TO ":SEQ(LETTER):"..."
PRINT
REPEAT
*
LOOP
PRINT "ENTER THE SEQUENCE TO CONVERT: ":; INPUT SEQ
*
IF SEQ EQ "KILL" OR SEQ EQ "EX" OR SEQ EQ "END" THEN STOP
IF NOT(NUM(SEQ)) THEN SEQ = ""
IF SEQ LT 0 THEN SEQ = ""
IF SEQ GT 254 THEN SEQ = ""
*
WHILE SEQ NE "" DO
****
PRINT
PRINT "THE SEQUENCE ":SEQ:" CONVERTS TO ":CHAR(SEQ):"..."
PRINT
REPEAT
*
*
WHILE 1 EQ 1 DO REPEAT
*
STOP
END
~CHAR.INPUT~
*PROGRAM: CHAR.CONV 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
LOOP
LOOP
*
PRINT @(0,3):"ENTER THE LETTER TO CONVERT: ":
LOOP UNTIL SYSTEM(11) DO RQM REPEAT
*
RSP = EMPTY; CONT = TRUE
*
LOOP
*
CONT = SYSTEM(11)
*
PRINT @(10,23):CONT:@(30,5):
*
INPUT TC,1: FOR 10 THEN PRINT @(20,23):TC: CONT = TRUE ELSE TC = EMPTY; CONT = FALSE; PRINT @(20,23):"?":
*
WHILE CONT DO
EXECUTE "SLEEP 5"
RSP = RSP:TC
REPEAT
*
PRINT @(0,5):RSP "L#30":
*
IF TC EQ "KILL" OR TC EQ "EX" OR TC EQ "END" THEN STOP
IF LEN(TC) GT ONE THEN TC = TC[ONE,ONE]
*
WHILE TC NE EMPTY DO
***
PRINT
PRINT "THE TC ":TC:" CONVERTS TO ":SEQ(TC):"..."
PRINT
REPEAT
*
LOOP
PRINT "ENTER THE SEQUENCE TO CONVERT: ":; INPUT SEQ
*
IF SEQ EQ "KILL" OR SEQ EQ "EX" OR SEQ EQ "END" THEN STOP
IF NOT(NUM(SEQ)) THEN SEQ = EMPTY
IF SEQ LT ZERO THEN SEQ = EMPTY
IF SEQ GT 254 THEN SEQ = EMPTY
*
WHILE SEQ NE EMPTY DO
****
PRINT
PRINT "THE SEQUENCE ":SEQ:" CONVERTS TO ":CHAR(SEQ):"..."
PRINT
REPEAT
*
*
WHILE TRUE DO REPEAT
*
STOP
*
*
END
~CHECKSUMS~
*PROGRAM: CHECKSUMS 
* DESCRIPTION:     CALCULATE CHECKSUMS FOR ALL ITEMS AND WRITE ON ITEM "CHECKSUMS.LIST"
$INCLUDE IBP STANDARD.FUNCTIONS
NXT.FILE: *
PRINT
PRINT
PRINT
PRINT "FILE? ":
INPUT FL.NAME
DICT.NAME = ""
IF FL.NAME[1,4] = "ULT" THEN FL.NAME = FL.NAME[5,99]
IF FL.NAME[1,5] = "DICT " OR FL.NAME[1,5] = "DICT." THEN
DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
END
IF FL.NAME = "" THEN STOP
PRINT " ALL? ":; INPUT ALL.FILES
IF ALL.FILES = "Y" THEN ALL.FILES = 1 ELSE ALL.FILES = ""
IF ALL.FILES THEN EXECUTE 'SSELECT ':TRIM(DICT.NAME:" ":FL.NAME):' # "CHECKSUMS.LIST]"', //SELECT. > FILE.ID.LIST
OPEN DICT.NAME,FL.NAME TO BP.FILE ELSE GOTO NXT.FILE
IF ALL.FILES THEN SUMS = "" ELSE
READ SUMS FROM BP.FILE,"CHECKSUMS.LIST" ELSE SUMS = ""
END
*
LOOP
READNEXT INAME FROM FILE.ID.LIST ELSE INAME = "@"
UNTIL INAME = "@" DO
IF INAME[1,14] # "CHECKSUMS.LIST" THEN
PRINT
PRINT INAME
EXECUTE 'CHECK-SUM ':TRIM(DICT.NAME:" ":FL.NAME):' "':INAME:'"', //OUT. > TCL.LINE
TCL.LINE = TCL.LINE<2>
PRINT TCL.LINE
POS = INDEX(TCL.LINE,"Cksum = ",1)
CSUM = FIELD(TCL.LINE[POS+8,99]," ",1)
IF ALL.FILES THEN SUMS<-1> = INAME:VM:CSUM ELSE
AC = 1
LOOP UNTIL SUMS<AC,1> >= INAME OR SUMS<AC,1> = "" DO AC = AC+1 REPEAT
IF SUMS<AC,1> # INAME THEN
INS "" BEFORE SUMS<AC>
END
SUMS<AC> = INAME:VM:CSUM
END
END
REPEAT
WRITE SUMS ON BP.FILE,"CHECKSUMS.LIST"
GOTO NXT.FILE
END
~CHNG.QPNT~
*PROGRAM: CHNG.QPNT
*
* : *PROGRAM: CONTROL.AI.UTILITY
* : *  Changes 'Q' pointers
*
! * : ***
! * : ***
* : * INITialization
* : * FUNCtions
$INCLUDE IBP STANDARD.FUNCTIONS
! * : ***
* : * TABLes
! * : ***
*
OPEN "MD" TO INP.FILE ELSE STOP
*
PRINT "Are we moving items (Y/<cr>): ":; INPUT MOVE.ITEM
*
IF MOVE.ITEM EQ "Y" THEN MOVE.ITEM = TRUE ELSE MOVE.ITEM = FALSE
*
LOOP
*
PRINT
PRINT "Enter the attribute # to change: ":; INPUT AM.NUM
*
IF NUM(AM.NUM) THEN
IF AM.NUM LT ONE THEN AM.NUM = "?"
END
IF NOT(LEN(AM.NUM)) THEN STOP
*
WHILE NOT(NUM(AM.NUM)) DO REPEAT
*
PRINT "Enter the OLD string: ":; INPUT OLD.STRING
IF NOT(LEN(OLD.STRING)) THEN STOP
*
PRINT "Enter the NEW string: ":; INPUT NEW.STRING
IF NOT(LEN(NEW.STRING)) THEN
PRINT "NO new string, enter <cr> to continue: ":; INPUT RSP
IF LEN(RSP) THEN STOP
END
*
FIRST = TRUE
READNEXT ID THEN LIST.ON.FILE = TRUE ELSE LIST.ON.FILE = FALSE
*
IF MOVE.ITEM THEN
IF LIST.ON.FILE THEN
PRINT "Enter the replacement prefix: ":; INPUT REPL.PREFIX
END ELSE REPL.PREFIX = EMPTY
END; * of move.item
*
*
LOOP
*
IF LIST.ON.FILE THEN
*
IF NOT(FIRST) THEN
READNEXT ID ELSE STOP
END; * of not first
*
IF MOVE.ITEM THEN
OLD.FILE = ID
OLD.PREFIX = FIELD(OLD.FILE,".",ONE)
OLD.SUFFIX = OLD.FILE[COL2() + ONE,999]
NEW.FILE   = REPL.PREFIX:OLD.SUFFIX
*
PRINT ">":OLD.PREFIX:" >":OLD.SUFFIX:" >>":NEW.FILE
PRINT
*
END; * of move.item
*
END ELSE IF NOT(MOVE.ITEM) THEN
PRINT
PRINT "Enter the item id: ":; INPUT ID
IF ID EQ EMPTY THEN STOP
END; * of list on file
*
IF NOT(LIST.ON.FILE) OR NOT(MOVE.ITEM) THEN
*
IF FIRST OR MOVE.ITEM THEN
*
LOOP
*
PRINT "Enter CURRENT/OLD file item name: ":; INPUT OLD.FILE
*
IF MOVE.ITEM THEN
*
READ OLD.ITEM FROM INP.FILE,OLD.FILE THEN OLD.ON.FILE = TRUE ELSE OLD.ON.FILE = FALSE
*
END ELSE
*
OPEN OLD.FILE TO INP.FILE THEN OLD.ON.FILE = TRUE ELSE OLD.ON.FILE = FALSE
*
END
*
WHILE NOT(OLD.ON.FILE) AND OLD.FILE NE EMPTY DO REPEAT
*
END; * of first
*
END ELSE
OLD.FILE = "CHNG.QPNT"
END; * of not list
*
WHILE OLD.FILE NE EMPTY DO
*
IF NOT(LIST.ON.FILE) AND MOVE.ITEM THEN
*
LOOP
*
PRINT
PRINT "Enter NEW file item name: ":; INPUT NEW.FILE
*
READ NEW.ITEM FROM INP.FILE,NEW.FILE THEN NEW.ON.FILE = TRUE ELSE NEW.ON.FILE = FALSE
*
WHILE NEW.ON.FILE AND NEW.FILE NE EMPTY DO REPEAT
*
END; * of first
*
IF NOT(MOVE.ITEM) THEN
ITEM.ON.FILE = FALSE
READ ITEM FROM INP.FILE,ID THEN
TMP = INDEX(ITEM<AM.NUM>,OLD.STRING,ONE)
IF TMP THEN
ITEM.ON.FILE = TRUE
TMP1 = TMP - ONE
TMP2 = TMP + LEN(OLD.STRING)
NEW.FIELD = ITEM<AM.NUM>[ONE,TMP1]:NEW.STRING:ITEM<AM.NUM>[TMP2,9999]
PRINT
PRINT ITEM<AM.NUM>
PRINT NEW.FIELD
PRINT
END; * of TMP
END; * of read
END; * of not move.item
*
PRINT "Enter <cr> to continue: ":; INPUT RSP
*
IF RSP EQ EMPTY THEN
*
IF NOT(MOVE.ITEM) THEN
*
IF ITEM.ON.FILE THEN
ITEM<AM.NUM> = NEW.FIELD
WRITE ITEM ON INP.FILE,ID
END
*
END ELSE
*
IF NEW.FILE NE EMPTY THEN
*
IF OLD.ON.FILE AND NOT(NEW.ON.FILE) THEN
*
WRITE OLD.ITEM ON INP.FILE,NEW.FILE
DELETE INP.FILE,OLD.FILE
PRINT
PRINT
PRINT "OLD file ":OLD.FILE:" was moved to ":NEW.FILE
PRINT
*
END; * of files present and missing
END; * of not empty
END; * of move.item
END; * of cr to continue
*
FIRST = FALSE
*
REPEAT
*
STOP
END
~CLEAR.INPUT~
*PROGRAM: CLEAR.CONV 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
*
ECHO OFF
*
*
BEGIN CASE
*
CASE OPSYS EQ "U"
*
INPUTCLEAR
*
CASE OPSYS EQ "M"
*
LOOP WHILE SYSTEM(11) DO
TC = OCONV(TC,"U51EA")
REPEAT
*
CASE TRUE
*
LOOP
INPUT TC,1:
WHILE LEN(TC) DO REPEAT
*
END CASE
*
*
ECHO ON
*
*
END
~CLEAR.LOCKS~
*PROGRAM:           CLEAR.LOCKS
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       CLEAR LOCKS
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE
PRINT CLB:"Can't open LOCKS File!! Enter <cr> . . . ":; INPUT TMP:; * ULT ONLY
STOP; * ULT ONLY
* ULT ONLY
END
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
! Start of program
*
PORT.NUM = EMPTY
*
IF OPSYS NE "R" THEN
*
LOOP
*
PRINT
PRINT "Enter port # to unlock or <cr> for all: ":
INPUT PORT.NUM:
PRINT
IF NOT(NUM(PORT.NUM)) THEN PORT.NUM = EMPTY
*
WHILE PORT.NUM LT ZERO DO PRINT BELL: REPEAT
*
IF PORT.NUM NE EMPTY THEN
PORT.NUM = ("000":PORT.NUM) "R#3"
END
*
END
*
! Clear Locks
*
BEGIN CASE
*
CASE OPSYS EQ "R"
*
* UNLOCK ALL; * REV ONLY
*
CASE TRUE
*
*
BEGIN CASE
*
CASE PORT.NUM EQ EMPTY
*
* ULT ONLY
EXECUTE "CLEAR-FILE DATA LOCKS"
*
CASE TRUE
*
EXEC.VERB = 'SSELECT LOCKS WITH PORT EQ "':PORT.NUM:'"'
PRINT
PRINT EXEC.VERB:
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > LOCKS.ID.LIST
*
PRINT
PRINT " Items deleted"
*
LOOP
READNEXT LOCKS.ID FROM LOCKS.ID.LIST ELSE STOP
WHILE TRUE DO
*
READ LOCKS.ITEM FROM LCK.FILE,LOCKS.ID THEN
*
PRINT LOCKS.ITEM
*
DELETE LCK.FILE,LOCKS.ID
*
END ELSE NULL
*
REPEAT
*
END CASE
*
END CASE
*
*
END
~COMPARE.ITEMS~
*PROGRAM: COMPARE.ITEMS 
*
$INCLUDE IBP STANDARD.FUNCTIONS
DIM ITEM(2),LINE(2),AC(2),TABLE(3)
*
START: *
PRINT
LOOP
PRINT
PRINT "Which file? ":
INPUT FNAME
IF FNAME = "" THEN STOP
OPEN "",FNAME TO COMP.FILE ELSE FNAME = ""
WHILE FNAME = "" DO
PRINT BELL:
REPEAT
*
FOR REF = 1 TO 2
LOOP
PRINT
PRINT "Item <":REF:"> name? ":
INPUT INAME
IF INAME = "" THEN GOTO START
READ ITEM(REF) FROM COMP.FILE,INAME ELSE INAME = ""
WHILE INAME = "" DO
PRINT BELL:
REPEAT
AC(REF) = 1
LINE(REF) = ITEM(REF)<AC(REF)>
TABLE(REF) = "On ":INAME:" only"
NEXT REF
TABLE(3) = "Mismatches"
*
PRINT
PRINT "Are items already sorted (<cr>/N)? ":
INPUT RSP
IF RSP = "N" THEN GOSUB SORT.ITEMS
PRINT
PRINT "Now comparing items... "
!
NEXT: *
BEGIN CASE
CASE LINE(1)<1,1> = "" OR LINE(2)<1,1> = ""
IF LINE(1)<1,1> # "" THEN REF = 1 ELSE REF = 2
LOOP
LINE(REF) = ITEM(REF)<AC(REF)>
UNTIL LINE(REF) = "" DO
TABLE(REF)<-1> = LINE(REF)
AC(REF) = AC(REF)+1
REPEAT
GOTO FINISH
CASE LINE(1)<1,1> = LINE(2)<1,1>
IF LINE(1)<1,2> # LINE(2)<1,2> THEN TABLE(3)<-1> = LINE(1):VM:LINE(2)<1,2>
FOR REF = 1 TO 2
AC(REF) = AC(REF)+1
LINE(REF) = ITEM(REF)<AC(REF)>
NEXT REF
CASE 1
IF LINE(1)<1,1> < LINE(2)<1,1> THEN REF = 1 ELSE REF = 2
TABLE(REF)<-1> = LINE(REF)
AC(REF) = AC(REF)+1
LINE(REF) = ITEM(REF)<AC(REF)>
END CASE
GOTO NEXT
!
FINISH: *
FOR REF = 1 TO 3
WRITE TABLE(REF) ON COMP.FILE,"CHECKSUM.TABLE.":REF
EXECUTE "COPY ":FNAME:" CHECKSUM.TABLE.":REF:" (P)"
NEXT REF
PRINT
PRINT "Finished"
STOP
!
SORT.ITEMS: *
FOR REF = 1 TO 2
PRINT
PRINT "Now sorting item <":REF:">... "
PROGS = ""
CSUMS = ""
LOOP
UNTIL ITEM(REF) = "" DO
PROG = ITEM(REF)<1,1>
CSUM = ITEM(REF)<1,2>
LOCATE PROG IN PROGS BY "AL" SETTING LOC ELSE
PROGS = INSERT(PROGS,LOC,0,0,PROG)
CSUMS = INSERT(CSUMS,LOC,0,0,CSUM)
END
ITEM(REF) = DELETE(ITEM(REF),1,0,0)
REPEAT
LOOP
UNTIL PROGS = "" DO
ITEM(REF)<-1> = PROGS<1>:VM:CSUMS<1>
PROGS = DELETE(PROGS,1,0,0)
CSUMS = DELETE(CSUMS,1,0,0)
REPEAT
NEXT REF
RETURN
END
~COMPARE.LISTS~
*PROGRAM: COMPARE.LISTS 
*
* COMPARES 2 CHECKSUMS.LISTS ITEMS AND PRINTS DIFFERENCES...
* PROGRAM:           COMPARE.LISTS
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       COMPARES 2 CHECKSUMS.LIST FILES AND PRINTS DIFFERENCES...
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT PGM.NAME:
IF PGM.NAME = "" THEN PGM.NAME = "CHECKSUMS.LIST"
NO.OLD = ""
IF PGM.NAME[1,8] = "*NO.OLD*" THEN
NO.OLD = 1
PGM.NAME = PGM.NAME[9,99]
END
FL.NAME = TRIM(FIELD(PGM.NAME,",",1))
THIRD.PART = TRIM(FIELD(PGM.NAME,",",3))
PGM.NAME = TRIM(FIELD(PGM.NAME,",",2))
IF THIRD.PART # "" THEN FL.NAME = FL.NAME:",":PGM.NAME; PGM.NAME = THIRD.PART
IF PGM.NAME = "" THEN PGM.NAME = FL.NAME; FL.NAME = "BP"
OPEN FL.NAME TO BP.FILE ELSE PRINT "Can't find ":FL.NAME:; INPUT RSP:; STOP
OPEN "OLD.":FL.NAME TO OLD.FILE ELSE PRINT "Can't find OLD.":FL.NAME:; INPUT RSP:; STOP
CH.NAME = FL.NAME:".CHANGES"
OPEN CH.NAME TO CH.FILE ELSE PRINT "Can't find ":CH.NAME:; INPUT RSP:; STOP
IF NO.OLD THEN OLN = "" ELSE
READ OLN FROM OLD.FILE, PGM.NAME ELSE OLN = ""
END
READ NLN FROM BP.FILE, PGM.NAME ELSE PRINT PGM.NAME:" not in ":FL.NAME:; INPUT RSP:; STOP
PRINTER ON
PRINT "CHECKSUMS.COMPARE:"
PRINT
AC = 1
MAX.AC = COUNT(NLN,AM)+1
MAX.AC1 = COUNT(OLN,AM)+1
LOOP UNTIL AC > MAX.AC DO
TEST.LINE = NLN<AC>
IF TEST.LINE # "" THEN
AC1 = 1; FOUND = ""
LOOP
TEST.LINE1 = OLN<AC1>
IF TEST.LINE<1,1> = TEST.LINE1<1,1> THEN
FOUND = 1
IF TEST.LINE<1,2> # TEST.LINE1<1,2> THEN
PRINT TEST.LINE<1,1> "L#40":"old ":TEST.LINE1<1,2> "L#15":"new ":TEST.LINE<1,2>
END
DEL NLN<AC>
DEL OLN<AC1>
AC = AC-1; MAX.AC = MAX.AC-1; MAX.AC1 = MAX.AC1-1
AC1 = MAX.AC1
END
AC1 = AC1+1
UNTIL AC1 > MAX.AC1 DO REPEAT
IF NOT(FOUND) THEN PRINT TEST.LINE<1,1> "L#40":"old ":SPACE(15):"new ":TEST.LINE<1,2>
END
AC = AC+1
REPEAT
PRINT
AC1 = 1
LOOP UNTIL AC1 > MAX.AC1 DO
TEST.LINE1 = OLN<AC1>
PRINT TEST.LINE1<1,1> "L#40":"old ":TEST.LINE1<1,2> "L#15"
AC1 = AC1+1
REPEAT
PRINTER OFF
STOP
END
~COMPARE.PROG.87~
*PROGRAM: COMPARE.PROG 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       COMPARES VERSION OF A PROGRAM (OR OTHER ITEM) IN 
*                    <file.name> WITH THE ONE IN OLD.<file.name> AND OUTPUTS THE CHANGES
*                    INTO FILE <file.name>.CHANGES UNDER THE SAME ITEM ID.
*                    FORMAT OF <file.name>.CHANGES ITEM:
*                       ATTR 1: <byte total>,<cksum>,<byte total>,<cksum>
*                                      from CHECK-SUM verb:
*                                           . first are for change item less attr 1
*                                           . second are for item in <file.name>
*                       ATTR 2: <from>[-<to>] [,...]       (deletions from OLD.<file.name>)
*                       ATTR 3- <line#> <space> <line>
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT PGM.NAME:
NO.OLD = ""
IF PGM.NAME[1,8] EQ "*NO.OLD*" THEN
NO.OLD = 1
PGM.NAME = PGM.NAME[9,99]
END
DICT.NAME = ""; FL.NAME = TRIM(FIELD(PGM.NAME,";",1))
THIRD.PART = TRIM(FIELD(PGM.NAME,";",3))
PGM.NAME = TRIM(FIELD(PGM.NAME,";",2))
IF THIRD.PART NE "" THEN DICT.NAME = FL.NAME; FL.NAME = PGM.NAME; PGM.NAME = THIRD.PART
IF PGM.NAME EQ "" THEN PGM.NAME = FL.NAME; FL.NAME = "BP"
IF FL.NAME[1,5] EQ "DICT " THEN DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
COMBINED.FL = TRIM(DICT.NAME:" ":FL.NAME)
OPEN DICT.NAME,FL.NAME TO BP.FILE ELSE PRINT "Can't find ":COMBINED.FL:; INPUT RSP:; STOP
COMBINED.OLD.FL = TRIM(DICT.NAME:" OLD.":FL.NAME)
OPEN DICT.NAME,"OLD.":FL.NAME TO OLD.FILE ELSE PRINT "Can't find ":COMBINED.OLD.FL:; INPUT RSP:; STOP
CH.NAME = FL.NAME:".CHANGES"
COMBINED.CHANGES = TRIM(DICT.NAME:" ":CH.NAME)
OPEN DICT.NAME,CH.NAME TO CH.FILE ELSE PRINT "Can't find ":COMBINED.CHANGES:; INPUT RSP:; STOP
IF NO.OLD THEN OLN = "" ELSE
READ OLN FROM OLD.FILE, PGM.NAME ELSE OLN = ""
END
READ NLN FROM BP.FILE, PGM.NAME ELSE PRINT PGM.NAME:" not in ":COMBINED.FL:; INPUT RSP:; STOP
*
!
*
EXLN = 'CHECK-SUM ':COMBINED.FL:' "':PGM.NAME:'"'
CH.OUT = ""
* ULT ONLY
EXECUTE EXLN, //OUT. > CH.OUT
*
CHG = ""
CH.OUT = TRIM(CH.OUT<2>)
CH.OUT = FIELD(CH.OUT," ",3):",":FIELD(CH.OUT," ",12)
CHC = 1; *CHANGE COUNTER
NLC = 0; *BP COUNTER
NLCTR = 0; *OVERALL BP COUNTER
OLC = 0; *OLD.BP COUNTER
OLCTR = 0; *OVERALL OLD.BP COUNTER
MAX.NLC = COUNT(NLN,AM)+1
MAX.OLC = COUNT(OLN,AM)+1
LST.DLT = 9999; LST.RNG = ""
DELIM = "$$$":"%%%":"$$$"
*
!
*
LOOP
*
* PRINT ".":
*
IF NLC GT 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
*
IF OLC GT 49 THEN
OLN<OLC> = DELIM
TMP = INDEX(OLN,DELIM,1)
OLN = OLN[TMP+LEN(DELIM)+1,50000]
MAX.OLC = MAX.OLC-OLC
OLC = 0
END
*
NLC = NLC+1
NLCTR = NLCTR+1
OLC = OLC+1
OLCTR = OLCTR+1
NEWL = NLN<NLC>
OLDL = OLN<OLC>
*
UNTIL OLC GT MAX.OLC DO
*
IF NEWL NE OLDL THEN
PRINT NLCTR "R#3":" ":NEWL "L#30":"<NE>":OLCTR "R#3":" ":OLDL "L#30"
NLC1 = NLC
OLC1 = OLC
TRY.CN = ZERO
*
NXT.TRY: *
*
* CN = ZERO
* LOOP
* CN = CN + ONE
* NLC1 = NLC1 + ONE
* NEWL = NLN<NLC1>
* UNTIL NLC1 GT MAX.NLC OR NEWL EQ OLDL OR CN GT 50 DO
* REPEAT
* *
* IF CN GT 50 THEN
TRY.CN = TRY.CN + ONE
TMP = INDEX(NLN,OLDL,TRY.CN)
IF TMP AND TRY.CN LT 15 THEN
TMP = COUNT(NLN[ONE,TMP],AM) + ONE
NLC1 = TMP
PRINT (NLCTR + (NLC1 - NLC)) "R#3":" ":NLN<NLC1> "L#30":"<EQ>":(OLCTR + (OLC1 - OLC)) "R#3":" ":OLDL "L#30"
END ELSE
NLC1 = MAX.NLC + ONE
END
* END
*
IF NLC1 GT MAX.NLC THEN
IF LST.DLT EQ OLCTR-1 THEN LST.RNG = OLCTR ELSE
IF LST.RNG THEN CHG<1> = CHG<1>:"-":LST.RNG; LST.RNG = ""
IF CHG<1> NE "" THEN CHG<1> = CHG<1>:","
CHG<1> = CHG<1>:OLCTR
END
LST.DLT = OLCTR
NLC = NLC-1
NLCTR = NLCTR-1
END ELSE
FOR EQCTR = 1 TO 9 UNTIL NLN<NLC1+EQCTR> NE OLN<OLC+EQCTR>
PRINT (NLCTR + (NLC1 + EQCTR - NLC)) "R#3":" ":NLN<NLC1 + EQCTR> "L#30":"<EQ>":(OLCTR + (OLC1 - OLC + EQCTR)) "R#3":" ":OLN<OLC+EQCTR> "L#30"
NEXT EQCTR
IF EQCTR LT 9 THEN
PRINT (NLCTR + (NLC1 + EQCTR - NLC)) "R#3":" ":NLN<NLC1 + EQCTR> "L#30":"<NE>":(OLCTR + (OLC1 - OLC + EQCTR)) "R#3":" ":OLN<OLC+EQCTR> "L#30"
PRINT
GOTO NXT.TRY
END
*
PRINT "MATCH"
IF NLC GT NLC1 THEN
NLC = NLC1
END ELSE
LOOP UNTIL NLC GE NLC1 DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NLN<NLC>
IF NLC GT 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC1 = NLC1 - NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
REPEAT
END
*
END
*
END
*
REPEAT
*
!
*
LOOP UNTIL NLC GT MAX.NLC DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NEWL
IF NLC GT 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
NEWL = NLN<NLC>
REPEAT
*
!
*
IF LST.RNG THEN CHG<1> = CHG<1>:"-":LST.RNG
WRITE CHG ON CH.FILE, PGM.NAME
*
CH.OUTC = ""
EXLN = 'CHECK-SUM ':COMBINED.CHANGES:' "':PGM.NAME:'"'
* ULT ONLY
EXECUTE EXLN, //OUT. > CH.OUTC
*
CH.OUTC = TRIM(CH.OUTC<2>)
CH.OUTC = FIELD(CH.OUTC," ",3):",":FIELD(CH.OUTC," ",12)
OLN = ""; NLN = ""; CHG = ""
READ CHG FROM CH.FILE, PGM.NAME ELSE PRINT "Just wrote it, now I can't find it":; INPUT RSP; STOP
CH.OUT = CH.OUTC:",":CH.OUT
INS CH.OUT BEFORE CHG<1>
*
WRITE CHG ON CH.FILE, PGM.NAME
*
END
~COMPARE.PROGRAM~
*PROGRAM: COMPARE.PROG 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       COMPARES VERSION OF A PROGRAM (OR OTHER ITEM) IN 
*                    <file.name> WITH THE ONE IN OLD.<file.name> AND OUTPUTS THE CHANGES
*                    INTO FILE <file.name>.CHANGES UNDER THE SAME ITEM ID.
*                    FORMAT OF <file.name>.CHANGES ITEM:
*                       ATTR 1: <byte total>,<cksum>,<byte total>,<cksum>
*                                      from CHECK-SUM verb:
*                                           . first are for change item less attr 1
*                                           . second are for item in <file.name>
*                       ATTR 2: <from>[-<to>] [,...]       (deletions from OLD.<file.name>)
*                       ATTR 3- <line#> <space> <line>
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE ULT.IBP STANDARD.FUNCTIONS
!
PRINT "Enter program name: ":;INPUT PGM.NAME:
PRINT
NO.OLD = ""
IF PGM.NAME[1,8] = "*NO.OLD*" THEN
NO.OLD = 1
PGM.NAME = PGM.NAME[9,99]
END
DICT.NAME = ""; FL.NAME = TRIM(FIELD(PGM.NAME,";",1))
THIRD.PART = TRIM(FIELD(PGM.NAME,";",3))
PGM.NAME = TRIM(FIELD(PGM.NAME,";",2))
IF THIRD.PART # "" THEN DICT.NAME = FL.NAME; FL.NAME = PGM.NAME; PGM.NAME = THIRD.PART
* CAN BE DICT;FILE;ITEM OR FILE;ITEM
* IF JUST ITEM THEN FILE IS "BP"
IF PGM.NAME = "" THEN PGM.NAME = FL.NAME; FL.NAME = "BP"
IF FL.NAME[1,5] = "DICT " THEN DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
COMBINED.FL = TRIM(DICT.NAME:" ":FL.NAME)
OPEN DICT.NAME,FL.NAME TO BP.FILE ELSE PRINT "Can't find ":COMBINED.FL:; INPUT RSP:; STOP
*
COMBINED.OLD.FL = TRIM(DICT.NAME:" OLD.":FL.NAME)
PRINT "Enter old file name (":COMBINED.OLD.FL:"): ":; INPUT OLD.FILE.NAME
IF OLD.FILE.NAME = "" THEN OLD.FILE.NAME = COMBINED.OLD.FL
IF OLD.FILE.NAME[1,5] = "DICT " THEN OLD.FILE.NAME = OLD.FILE.NAME[6,99]; DICT.NAME = "DICT"
OLD.FL.NAME = OLD.FILE.NAME
COMBINED.OLD.FL = TRIM(DICT.NAME:" ":OLD.FL.NAME)
OPEN DICT.NAME,OLD.FL.NAME TO OLD.FILE ELSE PRINT "Can't find ":COMBINED.OLD.FL:; INPUT RSP:; STOP
*
CH.NAME = FL.NAME:".CHANGES"
COMBINED.CHANGES = TRIM(DICT.NAME:" ":CH.NAME)
PRINT "Enter change file name (":COMBINED.CHANGES:"): ":; INPUT CHANGE.NAME
IF CHANGE.NAME = "" THEN CHANGE.NAME = COMBINED.CHANGES
IF CHANGE.NAME[1,5] EQ "DICT " THEN DICT.NAME = "DICT"; CHANGE.NAME = CHANGE.NAME[6,99]
CH.NAME = CHANGE.NAME
COMBINED.CHANGES = TRIM(DICT.NAME:" ":CH.NAME)
OPEN DICT.NAME,CH.NAME TO CH.FILE ELSE PRINT "Can't find ":COMBINED.CHANGES:; INPUT RSP:; STOP
*
IF NO.OLD THEN OLN = "" ELSE
READ OLN FROM OLD.FILE, PGM.NAME ELSE OLN = ""
END
READ NLN FROM BP.FILE, PGM.NAME ELSE PRINT PGM.NAME:" not in ":COMBINED.FL:; NLN = ""
EXLN = 'CHECK-SUM ':COMBINED.FL:' "':PGM.NAME:'"'
EXECUTE EXLN, //OUT. > CH.OUT
CHG = ""
CH.OUT = TRIM(CH.OUT<2>)
CH.OUT = FIELD(CH.OUT," ",3):",":FIELD(CH.OUT," ",12)
CHC = 1; *CHANGE COUNTER
NLC = 0; *BP COUNTER
NLCTR = 0; *OVERALL BP COUNTER
OLC = 0; *OLD.BP COUNTER
OLCTR = 0; *OVERALL OLD.BP COUNTER
MAX.NLC = COUNT(NLN,AM)+1
MAX.OLC = COUNT(OLN,AM)+1
LST.DLT = 9999; LST.RNG = ""
DELIM = "$$$":"%%%":"$$$"
LOOP
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
IF OLC > 49 THEN
OLN<OLC> = DELIM
TMP = INDEX(OLN,DELIM,1)
OLN = OLN[TMP+LEN(DELIM)+1,50000]
MAX.OLC = MAX.OLC-OLC
OLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
OLC = OLC+1
OLCTR = OLCTR+1
NEWL = NLN<NLC>
OLDL = OLN<OLC>
UNTIL OLC > MAX.OLC DO
IF NEWL # OLDL THEN
NLC1 = NLC
OLC1 = OLC
NXT.TRY: *
LOOP
NLC1 = NLC1+1
NEWL = NLN<NLC1>
UNTIL NLC1 > MAX.NLC OR NEWL = OLDL DO
REPEAT
IF NLC1 > MAX.NLC THEN
IF LST.DLT = OLCTR-1 THEN LST.RNG = OLCTR ELSE
IF LST.RNG THEN CHG<1> = CHG<1>:"-":LST.RNG; LST.RNG = ""
IF CHG<1> # "" THEN CHG<1> = CHG<1>:","
CHG<1> = CHG<1>:OLCTR
END
LST.DLT = OLCTR
NLC = NLC-1
NLCTR = NLCTR-1
END ELSE
FOR EQCTR = 1 TO 9 UNTIL NLN<NLC1+EQCTR> # OLN<OLC+EQCTR>
NEXT EQCTR
IF EQCTR < 9 THEN GOTO NXT.TRY
LOOP UNTIL NLC = NLC1 DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NLN<NLC>
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC1 = NLC1 - NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
REPEAT
END
END
REPEAT
LOOP UNTIL NLC > MAX.NLC DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NEWL
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
NEWL = NLN<NLC>
REPEAT
IF LST.RNG THEN CHG<1> = CHG<1>:"-":LST.RNG
WRITE CHG ON CH.FILE, PGM.NAME
EXLN = 'CHECK-SUM ':COMBINED.CHANGES:' "':PGM.NAME:'"'
EXECUTE EXLN, //OUT. > CH.OUTC
CH.OUTC = TRIM(CH.OUTC<2>)
CH.OUTC = FIELD(CH.OUTC," ",3):",":FIELD(CH.OUTC," ",12)
OLN = ""; NLN = ""; CHG = ""
READ CHG FROM CH.FILE, PGM.NAME ELSE PRINT "Just wrote it, now I can't find it":; INPUT RSP; STOP
CH.OUT = CH.OUTC:",":CH.OUT
INS CH.OUT BEFORE CHG<1>
WRITE CHG ON CH.FILE, PGM.NAME
END
~COMPARE.PROGRAMS~
*PROGRAM: COMPARE.PROGRAMS
*
* AUTHOR:            BOB CONARROE - AXION
*                    DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*
* DESCRIPTION:       COMPARES VERSION OF A PROGRAM (OR OTHER ITEM) IN 
*     <file.name> WITH THE ONE IN OLD.<file.name> AND OUTPUTS THE CHANGES
*                 INTO FILE <file.name>.CHANGES UNDER THE SAME ITEM ID.
*                 FORMAT OF <file.name>.CHANGES ITEM:
*                    ATTR 1: <byte total>,<cksum>,<byte total>,<cksum>
*                                   from CHECK-SUM verb:
*                              . first are for change item less attr 1
*                              . second are for item in <file.name>
*                    ATTR 2: <from>[-<to>] [,...]       (deletions from OLD.<file.name>)
*                    ATTR 3- <line#> <space> <line>
*
* DATE WRITTEN:   1985
* DATE RELEASED:  1985
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    1987    DAVID HORSMAN  REWRITE FOR CLEANER CODE
*                    16 MAR 92 D. HORSMAN   COMPARE & DISPLAY ANY ITEM
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "Can't open SYS":BELL; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
AM.CN.ADJ = ZERO; * ADJUSTED BP COUNTER
AM.CN = ZERO; *OVERALL BP COUNTER
AM.CN.MAX = ZERO; * # OF LINES IN ITEM
AM.CN.ADJ.CH = ZERO
*
AM.CN.ADJ.OLD = ZERO; * ADJUSTED OLD.BP COUNTER
AM.CN.OLD = ZERO; *OVERALL OLD.BP COUNTER
AM.CN.MAX.OLD = ZERO; * # OF LINE IN OLD.ITEM
AM.CN.ADJ.OLD.CH = ZERO
*
AM.CN.ADJ.DSP = ZERO; AM.CN.ADJ.OLD.DSP = ZERO
*
EQLOC = "!"; EQTC = "!"; ONEWL = "!"; OOLDL = "!"; NEWL = "!"; OLDL = "!"
WDTH = 32; STAT = FALSE; ITEM.MISSING = FALSE; SAVE.ONEWL = EMPTY
*
CHG = EMPTY; CH.OUT = EMPTY; CH.OUTC = EMPTY; CHG.CN = ONE; * CHANGES
*
LST.DLT = 9999; LST.RNG = EMPTY
DELIM = "$$$":"%%%":"$$$"
DEPTH.MAX = ZERO
READ DEPTH.PARAMS FROM SYS.FILE,"COMPARE.RANGES" THEN
DEPTH = DEPTH.PARAMS<ONE>
DEPTH.CH = DEPTH.PARAMS<TWO>
DEPTH.TRIM = DEPTH.PARAMS<3>
END ELSE
DEPTH = 50; DEPTH.CH = 7; DEPTH.TRIM = 99
END
OLD.RANGE = ZERO; NEW.RANGE = ZERO; MAX.RANGE = ZERO
*
!
*
PROG.LIST = EMPTY; CSEG.LIST = EMPTY; SUBR.LIST = EMPTY; PROC.LIST = EMPTY
OTHER.LIST = EMPTY; ITEM.LIST = EMPTY; CODE.LIST = EMPTY
*
LN.CN = 9999; PG.CN = ZERO; LN.CN.MAX = 60
TITLE = EMPTY; TITLE1 = EMPTY
FILE.ID.DSP = EMPTY; OLD.FILE.ID.DSP = EMPTY
ITEM.ID = EMPTY; OLD.ITEM.ID = EMPTY
EXEC.VERB = EMPTY
LIST.EMPTY = FALSE
*
NOPAGE.FL = FALSE; LPTR.FL = FALSE
FAST.FL = FALSE; FAST.FF = FALSE
TST.FL = FALSE
EQ.DISP = TRUE
*
FIRST = TRUE; NO.OLD = FALSE; CONT = TRUE; OLD.CONT = TRUE
CONT.RSP = "START"; CONT.RSP.CN = ZERO
PRINT @(0,0):CLS:
CONT.EQ.SINGLE = FALSE; CONT.OLD = FALSE; EQ.CN.MULTI = ZERO
!
*
LOOP
*
PRINT "Format: {*NO.OLD* }{Dict;}File;Item"
PRINT
PRINT "Enter new item: ":
INPUT RSP
IF RSP EQ EMPTY THEN STOP
IF RSP EQ "KILL" THEN STOP
*
*
IF RSP[ONE,8] EQ "*NO.OLD* " THEN
NO.OLD = TRUE
RSP = RSP[9,99]
END
*
ITEM.DICT.ID = EMPTY; ITEM.FILE.ID = TRIM(FIELD(RSP,";",ONE))
THIRD.PART = TRIM(FIELD(RSP,";",3))
ITEM.ID = TRIM(FIELD(RSP,";",TWO))
*
IF THIRD.PART NE EMPTY THEN ITEM.DICT.ID = ITEM.FILE.ID; ITEM.FILE.ID = ITEM.ID; ITEM.ID = THIRD.PART
** *
** IF ITEM.ID EQ EMPTY THEN ITEM.ID = ITEM.FILE.ID; ITEM.FILE.ID = "BP"
*
IF ITEM.FILE.ID[ONE,5] EQ "DICT " THEN ITEM.DICT.ID = "DICT"; ITEM.FILE.ID = ITEM.FILE.ID[6,99]
*
IF ITEM.FILE.ID EQ EMPTY THEN ITEM.FILE.ID = "BP"
*
FILE.ID.DSP = TRIM(ITEM.DICT.ID:" ":ITEM.FILE.ID)
*
OPEN ITEM.DICT.ID,ITEM.FILE.ID TO ITEM.FILE ELSE PRINT @(ZERO,23):CLL:"Can't find ":FILE.ID.DSP:; INPUT TMP; CONT = FALSE
** *
** IF CONT THEN
** *
** READ NLN FROM ITEM.FILE,ITEM.ID ELSE PRINT @(ZERO,23):CLL:ITEM.ID:" not in ":FILE.ID.DSP:; INPUT TMP; CONT = FALSE; NLN = EMPTY
** AM.CN.MAX = DCOUNT(NLN,AM)
*
IF CONT THEN
*
!
*
OLD.CONT = TRUE
*
LOOP
*
PRINT
PRINT "Format: {Dict;}File;Item"
PRINT
PRINT "Enter old item if different ":
INPUT RSP
IF RSP EQ "KILL" THEN STOP
*
IF RSP EQ EMPTY THEN
*
OLD.ITEM.ID = ITEM.ID
OLD.FILE.ID.DSP = TRIM(ITEM.DICT.ID:" OLD.":ITEM.FILE.ID)
OLD.ITEM.DICT.ID = ITEM.DICT.ID
OLD.ITEM.FILE.ID = "OLD.":ITEM.FILE.ID
*
END ELSE
*
OLD.ITEM.DICT.ID = EMPTY; OLD.ITEM.FILE.ID = TRIM(FIELD(RSP,";",ONE))
THIRD.PART = TRIM(FIELD(RSP,";",3))
OLD.ITEM.ID = TRIM(FIELD(RSP,";",TWO))
*
IF THIRD.PART NE EMPTY THEN OLD.ITEM.DICT.ID = OLD.ITEM.FILE.ID; OLD.ITEM.FILE.ID = OLD.ITEM.ID; OLD.ITEM.ID = THIRD.PART
** *
** IF OLD.ITEM.ID EQ EMPTY THEN OLD.ITEM.ID = OLD.ITEM.FILE.ID; OLD.ITEM.FILE.ID = "BP"
IF OLD.ITEM.ID EQ EMPTY THEN OLD.ITEM.ID = ITEM.ID
*
IF OLD.ITEM.FILE.ID[ONE,5] EQ "DICT " THEN OLD.ITEM.DICT.ID = "DICT"; OLD.ITEM.FILE.ID = OLD.ITEM.FILE.ID[6,99]
*
OLD.FILE.ID.DSP = TRIM(OLD.ITEM.DICT.ID:" ":OLD.ITEM.FILE.ID)
*
END; * of old rsp not empty
*
*
OPEN OLD.ITEM.DICT.ID,OLD.ITEM.FILE.ID TO OLD.ITEM.FILE ELSE PRINT @(ZERO,23):CLL:"Can't find ":OLD.FILE.ID.DSP:; INPUT TMP; OLD.CONT = FALSE
*
*
** IF OLD.CONT THEN
** IF NO.OLD THEN OLN = EMPTY ELSE
** READ OLN FROM OLD.ITEM.FILE,OLD.ITEM.ID ELSE OLN = EMPTY; OLD.CONT = FALSE
** AM.CN.MAX.OLD = DCOUNT(OLN,AM)
** END
** END
*
WHILE NOT(OLD.CONT) DO
OLD.CONT = TRUE
REPEAT
*
!
*
CH.NAME = ITEM.FILE.ID:".CHANGES"
COMBINED.CHANGES = TRIM(ITEM.DICT.ID:" ":CH.NAME)
OPEN ITEM.DICT.ID,CH.NAME TO CH.FILE ELSE
OPEN "","BP.CHANGES" TO CH.FILE ELSE
PRINT @(ZERO,23):CLL:"Can't find ":COMBINED.CHANGES:; INPUT TMP; CONT = FALSE
END
END
*
!
*
** END; * of cont (read)
** *
END; * of cont(  (open)
*
WHILE NOT(CONT) DO
CONT = TRUE
REPEAT
*
!
*
PRINT
PRINT "---------- Valid Options ----------"
PRINT " T - display on the Terminal"
PRINT " P - print on the printer"
PRINT " N - No <enter> at end of page (GO)"
PRINT " F - Fast printing (send each page to printer immediately)"
PRINT " E - Eject page with a form feed while in Fast mode"
PRINT " S - turn on Software test flag"
PRINT " Q - turn off printing of lines eQual to each other"
PRINT
PRINT "Enter options (T,P,N,F,FE,S,Q): ":
INPUT LPTR.DVC
IF LPTR.DVC EQ "KILL" THEN STOP
LOOP WHILE LEN(LPTR.DVC) DO
TC = LPTR.DVC[ONE,ONE]
LPTR.DVC = LPTR.DVC[TWO,9999]
IF TC = "T" THEN LPTR.FL = FALSE
IF TC = "P" THEN LPTR.FL = TRUE; WDTH = 58
IF TC = "N" THEN NOPAGE.FL = TRUE
IF TC = "F" THEN FAST.FL = TRUE; FAST.FF = FALSE
IF TC = "E" THEN FAST.FF = TRUE
IF TC = "S" THEN TST.FL = TRUE
IF TC = "Q" THEN EQ.DISP = FALSE
REPEAT
OWDTH = "L#":WDTH
*
*
IF NOT(LPTR.FL) THEN LN.CN.MAX = 22
TITLE = "Program Compare Utility"
*
!! Start or program main loop
*
CONT = TRUE
*
LOOP
*
IF ITEM.ID EQ EMPTY THEN
*
IF NOT(LIST.EMPTY) THEN
READNEXT ITEM.ID ELSE ITEM.ID = EMPTY; LIST.EMPTY = TRUE
OLD.ITEM.ID = ITEM.ID
END
*
IF LIST.EMPTY THEN
* @@@@@ TEMPORARY
CONT = FALSE
END
*
END; * of ID empty
*
TITLE1 = FILE.ID.DSP:" ":ITEM.ID:"  to  ":OLD.FILE.ID.DSP:" ":OLD.ITEM.ID
*
! Read the new and old items
*
IF CONT THEN
*
READ NLN FROM ITEM.FILE,ITEM.ID ELSE
PRINT @(ZERO,23):CLL:ITEM.ID:" not in ":FILE.ID.DSP:
ITEM.MISSING = TRUE
NLN = STR("*",5):"  ":ITEM.ID:" missing from ":FILE.ID.DSP:"  ":STR("*",5)
END
AM.CN.MAX = DCOUNT(NLN,AM)
*
IF NO.OLD THEN OLN = EMPTY ELSE
READ OLN FROM OLD.ITEM.FILE,OLD.ITEM.ID ELSE
OLN = "?"; ITEM.MISSING = TRUE
NLN = STR("*",5):"  ":OLD.ITEM.ID:" missing from ":OLD.FILE.ID.DSP:"  ":STR("*",5)
END
END
AM.CN.MAX.OLD = DCOUNT(OLN,AM)
*
END; * Of cont
*
*
WHILE CONT DO
*
! Perform check-sum on new item
*
EXEC.VERB = 'CHECK-SUM ':FILE.ID.DSP:' "':ITEM.ID:'"'
EXECUTE EXEC.VERB, //OUT. > CH.OUT
*
CHG = EMPTY
CH.OUT = TRIM(CH.OUT<TWO>)
CH.OUT = FIELD(CH.OUT," ",3):",":FIELD(CH.OUT," ",12)
CHG.CN = ONE; *CHANGE COUNTER
*
PRINT @(ZERO,ZERO):CLS:
*
!! Start or program main loop
*
CONT.ANAL = TRUE
*
LOOP
*
*
LOOP
*
* Trim front of new item
*
IF AM.CN.ADJ GT DEPTH.TRIM THEN
AM.CN = AM.CN + AM.CN.ADJ
NLN<AM.CN.ADJ> = DELIM
TMP = INDEX(NLN,DELIM,ONE)
NLN = NLN[TMP + LEN(DELIM) + ONE,50000]
AM.CN.MAX = AM.CN.MAX - AM.CN.ADJ
AM.CN.ADJ = ZERO
END
*
*
* Trim front of old item
*
IF AM.CN.ADJ.OLD GT DEPTH.TRIM THEN
AM.CN.OLD = AM.CN.OLD + AM.CN.ADJ.OLD
OLN<AM.CN.ADJ.OLD> = DELIM
TMP = INDEX(OLN,DELIM,ONE)
OLN = OLN[TMP + LEN(DELIM) + ONE,50000]
AM.CN.MAX.OLD = AM.CN.MAX.OLD - AM.CN.ADJ.OLD
AM.CN.ADJ.OLD = ZERO
END
*
!
*
AM.CN.ADJ = AM.CN.ADJ + ONE
AM.CN.ADJ.CH = AM.CN.ADJ
*
AM.CN.ADJ.OLD = AM.CN.ADJ.OLD + ONE
AM.CN.ADJ.OLD.CH = AM.CN.ADJ.OLD
*
NEWL = NLN<AM.CN.ADJ>
OLDL = OLN<AM.CN.ADJ.OLD>
ONEWL = NEWL; OOLDL = OLDL
*
*
WHILE NEWL EQ OLDL AND AM.CN.ADJ.OLD LE AM.CN.MAX.OLD DO
*
EQLOC = "="; EQTC = "="
AM.CN.ADJ.DSP = AM.CN.ADJ.CH; AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD.CH
IF EQ.DISP THEN GOSUB DISP.LINE
IF TST.FL THEN PRINT @(ZERO,23):"EQ":AM.CN "R#4":
*
REPEAT
*
*
UNTIL NOT(CONT.ANAL) OR (AM.CN.ADJ.OLD GT AM.CN.MAX.OLD OR AM.CN.ADJ GT AM.CN.MAX) DO
*
! A change has been found
*
EQLOC = "C"; EQTC = "#"
*
IF AM.CN.ADJ.OLD LE AM.CN.MAX.OLD AND AM.CN.ADJ LE AM.CN.MAX THEN
AM.CN.ADJ.DSP = AM.CN.ADJ; ONEWL = STR("*",WDTH)
AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD; * OOLDL = STR("*",WDTH)
END ELSE
*
IF AM.CN.ADJ GT AM.CN.MAX THEN
AM.CN.ADJ.DSP = AM.CN.MAX; ONEWL = STR("*",WDTH)
END ELSE AM.CN.ADJ.DSP = AM.CN.ADJ
*
IF AM.CN.ADJ.OLD GT AM.CN.MAX.OLD THEN
AM.CN.ADJ.OLD.DSP = AM.CN.MAX.OLD; OOLDL = STR("*",WDTH)
END ELSE AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD
*
END
*
GOSUB DISP.LINE
*
*
IF NEWL NE OLDL THEN
*
* Change has been detected
*
AM.CN.ADJ.CH = AM.CN.ADJ
AM.CN.ADJ.OLD.CH = AM.CN.ADJ.OLD
*
! Analysis Area to locate next matching code
*
NXT.TRY: *
*
* Look for a match on new line for DEPTH lines
*
* Set range (DEPTH.MAX) using DEPTH
*
OLD.RANGE = AM.CN.OLD + AM.CN.ADJ.OLD.CH
NEW.RANGE = AM.CN + AM.CN.ADJ.CH
IF NEW.RANGE GT OLD.RANGE THEN
DEPTH.MAX = AM.CN + AM.CN.ADJ.CH + DEPTH
MAX.RANGE = AM.CN + AM.CN.ADJ + (TWO * DEPTH)
IF MAX.RANGE GT AM.CN + AM.CN.MAX THEN MAX.RANGE = AM.CN + AM.CN.MAX
END ELSE
DEPTH.MAX = AM.CN.OLD + AM.CN.ADJ.OLD.CH + DEPTH
MAX.RANGE = AM.CN.OLD + AM.CN.ADJ.OLD + (TWO * DEPTH)
IF MAX.RANGE GT AM.CN.OLD + AM.CN.MAX.OLD THEN MAX.RANGE = AM.CN.OLD + AM.CN.MAX.OLD
END
IF DEPTH.MAX GT MAX.RANGE THEN DEPTH.MAX = MAX.RANGE
*
! Loop to look for a match on a single line
*
CONT.EQ.SINGLE = TRUE
*
LOOP
*
AM.CN.ADJ.CH = AM.CN.ADJ.CH + ONE
NEWL = NLN<AM.CN.ADJ.CH>
*
IF NEWL EQ OLDL THEN CONT.EQ.SINGLE = FALSE
IF NEWL[ONE,ONE] EQ "*" OR NEWL[ONE,ONE] EQ "!" THEN CONT.EQ.SINGLE = TRUE
IF NEWL EQ "END" OR NEWL[ONE,4] EQ "END;" THEN CONT.EQ.SINGLE = TRUE
IF NEWL EQ "END ELSE" THEN CONT.EQ.SINGLE = TRUE
*
UNTIL (AM.CN.ADJ.CH GT AM.CN.MAX OR AM.CN.ADJ.CH GT DEPTH.MAX - AM.CN) OR NOT(CONT.EQ.SINGLE) DO
*
IF TST.FL THEN PRINT @(ZERO,23):"? ":(AM.CN + AM.CN.ADJ.CH) "R#4":" ":
IF TERM.DISP THEN PRINT NEWL "L#25":" ?":(AM.CN.OLD + AM.CN.ADJ.OLD.CH) "R#4":" ":OLDL "L#25":
REPEAT
*
ONEWL = NEWL
*
! Continue analyzing
*
! The match must continue for DEPTH.CH lines
*
FOR EQ.CN.MULTI = ONE TO DEPTH.CH UNTIL NLN<AM.CN.ADJ.CH + EQ.CN.MULTI - ONE> NE OLN<AM.CN.ADJ.OLD.CH + EQ.CN.MULTI - ONE>
IF TST.FL THEN PRINT @(ZERO,23):EQ.CN.MULTI "R#2":(AM.CN + AM.CN.ADJ.CH + EQ.CN.MULTI - ONE) "R#4":
IF TERM.DISP THEN PRINT NEWL "L#25":" e":(AM.CN.OLD + AM.CN.ADJ.OLD.CH + EQ.CN.MULTI - ONE) "R#4":" ":OLDL "L#25":
* RQM
NEXT EQ.CN.MULTI
*
* If match LT DEPTH.CH then it failed depth check
*
IF EQ.CN.MULTI LT DEPTH.CH THEN
*
IF AM.CN.ADJ.OLD.CH GT DEPTH.MAX - AM.CN.OLD THEN
*
CONT.ANAL = FALSE
*
END ELSE IF AM.CN.ADJ.CH GT DEPTH.MAX - AM.CN THEN
*
CONT.OLD = FALSE
*
LOOP
*
AM.CN.ADJ.OLD.CH = AM.CN.ADJ.OLD.CH + ONE
OLDL = OLN<AM.CN.ADJ.OLD.CH>
*
* AM.CN.ADJ.DSP = AM.CN.ADJ.CH; AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD.CH
* EQLOC = "R"; EQTC = "?"; ONEWL = NEWL; OOLDL = OLDL; GOSUB DISP.LINE
*
IF OLDL EQ "*" OR OLDL EQ "!" THEN CONT.OLD = TRUE
IF OLDL EQ "END" OR OLDL[ONE,4] EQ "END;" THEN CONT.OLD = TRUE
IF OLDL EQ "END ELSE" THEN CONT.OLD = TRUE
*
WHILE CONT.OLD DO CONT.OLD = FALSE REPEAT
*
OOLDL = OLDL
AM.CN.ADJ.CH = AM.CN.ADJ - ONE
*
END; * Of cont.anal = false or reloop
*
IF CONT.ANAL THEN
NEWL = NLN<AM.CN.ADJ.CH>
ONEWL = NEWL
GOTO NXT.TRY
END
*
END; * Of not enough line matched
*
IF CONT.ANAL THEN
*
!! Found a match
*
! Display old deleted lines first
*
IF CHG<ONE> NE EMPTY THEN CHG<ONE> = CHG<ONE>:","
CHG<ONE> = CHG<ONE>:AM.CN.OLD + AM.CN.ADJ.OLD
IF AM.CN.ADJ.OLD.CH GT AM.CN.ADJ.OLD THEN
CHG<ONE> = CHG<ONE>:"-":AM.CN.OLD + AM.CN.ADJ.OLD.CH
END
*
SAVE.ONEWL = ONEWL; ONEWL = EMPTY
*
IF AM.CN.ADJ.OLD LT AM.CN.ADJ.OLD.CH THEN
OLD.DONE = TRUE
*
LOOP UNTIL AM.CN.ADJ.OLD GE AM.CN.ADJ.OLD.CH DO
*
AM.CN.ADJ.DSP = AM.CN.ADJ; AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD
EQLOC = "d"; EQTC = "d"; OOLDL = OLN<AM.CN.ADJ.OLD>; GOSUB DISP.LINE
IF TST.FL THEN PRINT @(ZERO,23):("d":(AM.CN.OLD + AM.CN.ADJ.OLD.CH)) "R#4":
*
* Trim front of old item
*
IF AM.CN.ADJ.OLD GT DEPTH.TRIM AND AM.CN.ADJ.OLD.CH GT DEPTH.TRIM THEN
OLN<AM.CN.ADJ.OLD> = DELIM
TMP = INDEX(OLN,DELIM,ONE)
OLN = OLN[TMP + LEN(DELIM) + ONE,50000]
AM.CN.MAX.OLD = AM.CN.MAX.OLD - AM.CN.ADJ.OLD
AM.CN.OLD = AM.CN.OLD + AM.CN.ADJ.OLD
AM.CN.ADJ.OLD.CH = AM.CN.ADJ.OLD.CH - AM.CN.ADJ.OLD
AM.CN.ADJ.OLD = ZERO
END
*
AM.CN.ADJ.OLD = AM.CN.ADJ.OLD + ONE
*
REPEAT
*
** AM.CN.ADJ.OLD = AM.CN.ADJ.OLD.CH
*
END ELSE OLD.DONE = FALSE
*
ONEWL = SAVE.ONEWL; OOLDL = EMPTY
*
IF AM.CN.ADJ LT AM.CN.ADJ.CH THEN
NEW.DONE = TRUE
*
LOOP UNTIL AM.CN.ADJ GE AM.CN.ADJ.CH DO
*
CHG.CN = CHG.CN + ONE
CHG<CHG.CN> = AM.CN + AM.CN.ADJ:" ":NLN<AM.CN.ADJ>
*
AM.CN.ADJ.DSP = AM.CN.ADJ; AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD.CH
EQLOC = "i"; EQTC = "i"; ONEWL = NLN<AM.CN.ADJ>; GOSUB DISP.LINE
IF TST.FL THEN PRINT @(ZERO,23):("?":(AM.CN + AM.CN.ADJ.CH)) "R#4":
*
* Trim front of new item
*
IF AM.CN.ADJ GT DEPTH.TRIM AND AM.CN.ADJ.CH GT DEPTH.TRIM THEN
NLN<AM.CN.ADJ> = DELIM
TMP = INDEX(NLN,DELIM,ONE)
NLN = NLN[TMP + LEN(DELIM) + ONE,50000]
AM.CN.MAX = AM.CN.MAX - AM.CN.ADJ
AM.CN = AM.CN + AM.CN.ADJ
AM.CN.ADJ.CH = AM.CN.ADJ.CH - AM.CN.ADJ
AM.CN.ADJ = ZERO
END
*
AM.CN.ADJ = AM.CN.ADJ + ONE
*
REPEAT
*
END ELSE NEW.DONE = FALSE
*
*
AM.CN.ADJ.DSP = AM.CN.ADJ.CH; AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD.CH
EQLOC = "M"; EQTC = "="; ONEWL = NLN<AM.CN.ADJ>; OOLDL = OLN<AM.CN.ADJ.OLD>
IF EQ.DISP THEN GOSUB DISP.LINE
*
*
END; * Of cont.anal
*
*
END; * Of mismatch
*
*
REPEAT
*
*
!! End of comparing these items
*
* Mark deletions of old item first
*
IF AM.CN.ADJ.OLD LE AM.CN.MAX.OLD THEN
IF CHG<ONE> NE EMPTY THEN CHG<ONE> = CHG<ONE>:","
CHG<ONE> = CHG<ONE>:AM.CN.OLD + AM.CN.ADJ.OLD
IF AM.CN.ADJ.OLD LT AM.CN.MAX.OLD THEN
CHG<ONE> = CHG<ONE>:"-":AM.CN.MAX.OLD
END
END
*
! Display rest of programs
*
LOOP UNTIL AM.CN.ADJ GT AM.CN.MAX AND AM.CN.ADJ.OLD GT AM.CN.MAX.OLD DO
*
NEWL = NLN<AM.CN.ADJ>; OLDL = OLN<AM.CN.ADJ.OLD>
*
IF AM.CN.ADJ LE AM.CN.MAX THEN
CHG.CN = CHG.CN + ONE
CHG<CHG.CN> = AM.CN + AM.CN.ADJ:" ":NEWL
END
*
AM.CN.ADJ.DSP = AM.CN.ADJ; AM.CN.ADJ.OLD.DSP = AM.CN.ADJ.OLD
EQLOC = "X"; EQTC = "&"; ONEWL = NEWL; OOLDL = OLDL; GOSUB DISP.LINE
IF TST.FL THEN PRINT @(ZERO,23):AM.CN.ADJ:"&":AM.CN.ADJ.OLD:
*
* Trim front of new item
*
IF AM.CN.ADJ GT DEPTH.TRIM THEN
NLN<AM.CN.ADJ> = DELIM
TMP = INDEX(NLN,DELIM,ONE)
NLN = NLN[TMP + LEN(DELIM) + ONE,50000]
AM.CN.MAX = AM.CN.MAX - AM.CN.ADJ
AM.CN = AM.CN + AM.CN.ADJ
AM.CN.ADJ = ZERO
END
*
* Trim front of old item
*
IF AM.CN.ADJ.OLD GT DEPTH.TRIM THEN
AM.CN.OLD = AM.CN.OLD + AM.CN.ADJ.OLD
OLN<AM.CN.ADJ.OLD> = DELIM
TMP = INDEX(OLN,DELIM,ONE)
OLN = OLN[TMP + LEN(DELIM) + ONE,50000]
AM.CN.MAX.OLD = AM.CN.MAX.OLD - AM.CN.ADJ.OLD
AM.CN.ADJ.OLD = ZERO
END
*
*
AM.CN.ADJ = AM.CN.ADJ + ONE
AM.CN.ADJ.OLD = AM.CN.ADJ.OLD + ONE
*
REPEAT
*
! Write item to change file
*
IF LST.RNG THEN CHG<ONE> = CHG<ONE>:"-":LST.RNG
*
EXEC.VERB = 'CHECK-SUM ':COMBINED.CHANGES:' "':ITEM.ID:'"'
EXECUTE EXEC.VERB, //OUT. > CH.OUTC
*
CH.OUTC = TRIM(CH.OUTC<TWO>)
CH.OUTC = FIELD(CH.OUTC," ",3):",":FIELD(CH.OUTC," ",12)
*
CH.OUT = CH.OUTC:",":CH.OUT
*
INS CH.OUT BEFORE CHG<ONE>
*
WRITE CHG ON CH.FILE,ITEM.ID
*
OLN = EMPTY; NLN = EMPTY; CHG = EMPTY
LN.CN = 9999; PG.CN = ZERO
CH.OUT = EMPTY; CH.OUTC = EMPTY; CHG.CN = ZERO
ITEM.ID = EMPTY; OLD.ITEM.ID = EMPTY
*
AM.CN.ADJ = ZERO; * ADJUSTED BP COUNTER
AM.CN = ZERO; *OVERALL BP COUNTER
AM.CN.MAX = ZERO; * # OF LINES IN ITEM
AM.CN.ADJ.CH = ZERO
*
AM.CN.ADJ.OLD = ZERO; * ADJUSTED OLD.BP COUNTER
AM.CN.OLD = ZERO; *OVERALL OLD.BP COUNTER
AM.CN.MAX.OLD = ZERO; * # OF LINE IN OLD.ITEM
AM.CN.ADJ.OLD.CH = ZERO
*
AM.CN.ADJ.DSP = ZERO; AM.CN.ADJ.OLD.DSP = ZERO
*
EQLOC = "!"; EQTC = "!"; ONEWL = "!"; OOLDL = "!"; NEWL = "!"; OLDL = "!"
STAT = FALSE; ITEM.MISSING = FALSE; SAVE.ONEWL = EMPTY
*
LST.DLT = 9999; LST.RNG = EMPTY
DELIM = "$$$":"%%%":"$$$"
*
*
REPEAT
*
! Go get next item
*
*
STOP
*
!! END OF PROGRAM
*
DISP.LINE: *
*
LOOP
*
LN.CN = LN.CN + ONE
IF LN.CN GT LN.CN.MAX THEN GOSUB LPTR.HEADER
*
IF NOT(LPTR.FL) THEN
PRINT @(ZERO,LN.CN):
END ELSE
PRINTER ON
END
*
PRINT EQLOC "L#2":(AM.CN + AM.CN.ADJ.DSP) "R#4":" ":ONEWL OWDTH:" ":EQTC:(AM.CN.OLD + AM.CN.ADJ.OLD.DSP) "R#4":" ":OOLDL OWDTH:
*
ONEWL = ONEWL[WDTH+ONE,9999]; OOLDL = OOLDL[WDTH+ONE,9999]
*
IF LPTR.FL THEN
PRINT
PRINTER OFF
END
*
WHILE LEN(ONEWL) OR LEN(OOLDL) DO REPEAT
*
RETURN
*
!
*
LPTR.HEADER: *
*
PG.CN = PG.CN + ONE
*
IF NOT(LPTR.FL) THEN
IF NOT(NOPAGE.FL) OR SYSTEM(11) THEN
IF CONT.RSP.CN GT ZERO AND NOT(SYSTEM(11)) THEN
CONT.RSP.CN = CONT.RSP.CN - ONE
END ELSE
PRINT @(ZERO,22):CLL:"Enter <cr> to continue . . . ":
INPUT CONT.RSP:
PRINT @(ZERO,22):CLL:
IF CONT.RSP EQ "KILL" OR CONT.RSP EQ "END" THEN STOP
IF CONT.RSP EQ "GO" THEN NOPAGE.FL = TRUE
IF NUM(CONT.RSP) THEN
IF CONT.RSP GT ZERO THEN CONT.RSP.CN = CONT.RSP
END ELSE
CONT.RSP.CN = ZERO
END; * of num cont.rsp
END; * of cont.rsp.cn gt 0
END; * of nopage.fl
LN.CN = 4
FOR TMP = ZERO TO LN.CN; PRINT @(ZERO,TMP):CLL:; NEXT TMP
PRINT @(ZERO,ZERO):
END ELSE
*
PRINTER ON
IF NOT(FIRST) THEN
IF FAST.FL THEN
PRINTER CLOSE
IF FAST.FF THEN PRINT FF:
END ELSE
PRINT FF:
END
END; * of not first
LN.CN = 6
END; * of term / lptr
*
FIRST = FALSE
*
TMP = TWO * (WDTH - 8)
TMP = "L#":TMP
PRINT OCONV(DATE(),"D2") "L#14":(SPACE(WDTH - 8 - INT(LEN(TITLE) / TWO + .5)):TITLE) TMP:("Page ":PG.CN) "R#14"
PRINT OCONV(TIME(),"MTS") "L#14":(SPACE(WDTH - 8 - INT(LEN(TITLE1) / TWO + .5)):TITLE1) TMP:WHO "R#14"
PRINT
PRINT "v New. ":("Item Code":STR(".",WDTH)) OWDTH:
PRINT " ? ":
PRINT "Old ":("Item Code":STR(".",WDTH)) OWDTH:
PRINT
*
IF LPTR.FL THEN PRINTER OFF
*
RETURN
*
!
*
END
~COMPARE.PROGRAMS.ALL~
*PROGRAM: COMPARE.PROGRAMS.ALL 
*
$INCLUDE ULT.IBP STANDARD.FUNCTIONS
EXEC.LINE = ""
LOOP
EXEC.PARAMS = ""
READNEXT ID ELSE ID = "@"
WHILE ID NE "@" DO
EXEC.LINE = "COMPARE.PROGRAM"
EXEC.PARAMS<-1> = "BP;":ID
EXEC.PARAMS<-1> = "OLD.BP"
EXEC.PARAMS<-1> = "BP.CHANGES"
PRINT CLL:"[=| "
PRINT CLL:"[=| ":EXEC.LINE
CN = 0
LOOP
CN = CN + 1
PRINT CLL:"[=| ":EXEC.PARAMS<CN>
WHILE EXEC.PARAMS<CN> NE "" DO REPEAT
PRINT CLL:"[=| "
PRINT CLL:"[=| ":
EXECUTE EXEC.LINE, //IN. < EXEC.PARAMS
PRINT " |=]"
REPEAT
END
~COMPARE.REVISE~
*PROGRAM: REVISE.PROGRAM 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       REVISES PROGRAMS IN BP BASED ON BP.CHANGES
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT
PRINT "Revise............................"
PRINT "  WHICH FILE <BP>? ":; INPUT FL.NAME; IF FL.NAME = '' THEN FL.NAME = "BP"
IN.NAME = FL.NAME
IF IN.NAME[1,4] = "ULT." THEN IN.NAME = IN.NAME[5,99]
DICT.NAME = ""
IF IN.NAME[1,5] = "DICT " OR IN.NAME[1,5] = "DICT." THEN
DICT.NAME = "DICT"; IN.NAME = IN.NAME[6,99]
END
DISP.NAME = TRIM(DICT.NAME:" ":IN.NAME)
*OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT"; INPUT RSP; STOP
*READ CHANGES.LOG FROM CNT.FILE,"CHANGES.LOG" ELSE CHANGES.LOG = ""
*LOCATE DISP.NAME IN CHANGES.LOG<1> BY "AL" SETTING LOG.VC ELSE
*INS DISP.NAME BEFORE CHANGES.LOG<1,LOG.VC>
*INS "" BEFORE CHANGES.LOG<2,LOG.VC>
*INS "" BEFORE CHANGES.LOG<3,LOG.VC>
*INS "" BEFORE CHANGES.LOG<4,LOG.VC>
*INS "" BEFORE CHANGES.LOG<5,LOG.VC>
*INS "" BEFORE CHANGES.LOG<6,LOG.VC>
*INS "" BEFORE CHANGES.LOG<7,LOG.VC>
*INS "" BEFORE CHANGES.LOG<8,LOG.VC>
*INS "" BEFORE CHANGES.LOG<9,LOG.VC>
*END
OPEN DICT.NAME,IN.NAME TO BP.FILE ELSE PRINT "Can't open ":DISP.NAME; INPUT RSP; STOP
CH.NAME = IN.NAME
IF CH.NAME[1,4] EQ "OLD." THEN CH.NAME = CH.NAME[5,99]
IF CH.NAME[1,5] EQ "DICT." THEN CH.NAME = CH.NAME[6,99]
CH.NAME = CH.NAME:".CHANGES"
PRINT "ENTER CHANGE FILE (":CH.NAME:"): ":
INPUT CHG.NAME
IF CHG.NAME EQ "" THEN CHG.NAME = CH.NAME
IF CHG.NAME EQ "KILL" THEN STOP
CH.NAME = CHG.NAME
OPEN DICT.NAME,CH.NAME TO CHANGE.FILE ELSE PRINT "Can't open ":DICT.NAME:" ":CH.NAME; INPUT RSP; STOP
BASIC.REQD = ""
*IF DICT.NAME = "" AND (IN.NAME = "BP" OR IN.NAME[1,3] = "BP.") THEN
*BASIC.REQD = 1
*OPEN "DICT",IN.NAME TO OBJ.FILE ELSE PRINT "Can't open DICT ":IN.NAME; INPUT RSP; STOP
*END
*
*EX.LINE = 'SSELECT ':DISP.NAME:'.CHANGES # "$]"'
*PRINT
*PRINT "      ":EX.LINE
*PRINT
*EXECUTE EX.LINE
!
NEXT.ITEM: *
*READNEXT PROG.NAME ELSE WRITE CHANGES.LOG ON CNT.FILE,"CHANGES.LOG"; STOP
READNEXT PROG.NAME ELSE
PRINT "ENTER PROGRAM NAME: ":; INPUT PROG.NAME
PRINT
IF PROG.NAME EQ "" OR PROG.NAME EQ "KILL" THEN STOP
END
READ PROG.CHANGES FROM CHANGE.FILE,PROG.NAME ELSE GOTO NEXT.ITEM
PRINT PROG.NAME
FOR A = 1 TO 5
PRINT A "R#2":">":PROG.CHANGES<A>
NEXT A
PRINT "ARE YOU SURE(Y/N)? ":; INPUT RSP
IF RSP = "KILL" THEN STOP
IF RSP NE "Y" THEN GOTO NEXT.ITEM
*
*SUCCESS.AC = 5
*LOCATE PROG.NAME IN CHANGES.LOG<2,LOG.VC> BY "AL" SETTING LOG.SVC ELSE
*INS PROG.NAME BEFORE CHANGES.LOG<2,LOG.VC,LOG.SVC>
*INS "" BEFORE CHANGES.LOG<3,LOG.VC,LOG.SVC>
*INS "" BEFORE CHANGES.LOG<4,LOG.VC,LOG.SVC>
*INS "" BEFORE CHANGES.LOG<5,LOG.VC,LOG.SVC>
*INS "" BEFORE CHANGES.LOG<6,LOG.VC,LOG.SVC>
*INS "" BEFORE CHANGES.LOG<7,LOG.VC,LOG.SVC>
*INS "" BEFORE CHANGES.LOG<8,LOG.VC,LOG.SVC>
*INS "" BEFORE CHANGES.LOG<9,LOG.VC,LOG.SVC>
*END
*FOR TMP = 3 TO 9
*CHANGES.LOG<TMP,LOG.VC,LOG.SVC> = ""
*NEXT TMP
*IF PROG.CHANGES = "\\\DELETED\\\" THEN
*PROG.NAME = FIELD(PROG.NAME," ",1)
*DELETE BP.FILE,PROG.NAME
*DELETE CHANGE.FILE,PROG.NAME
*PRINT "          ":DISP.NAME:", ":PROG.NAME:" deleted."
*IF BASIC.REQD THEN
*EXECUTE "DECATALOG ":IN.NAME:" ":PROG.NAME
*END
*CHANGES.LOG<7,LOG.VC,LOG.SVC> = 1
*PRINT
*GOTO INSERT.DATE.TIME
*END
*CHECK.LINE = PROG.CHANGES<1>
*DEL PROG.CHANGES<1>
*WRITE PROG.CHANGES ON CHANGE.FILE,PROG.NAME
*EX.LINE = 'CHECK-SUM ':DISP.NAME:'.CHANGES "':PROG.NAME:'"'
*PRINT "          ":EX.LINE
*EXECUTE EX.LINE, //OUT. > RESULT
*INS CHECK.LINE BEFORE PROG.CHANGES<1>
*WRITE PROG.CHANGES ON CHANGE.FILE,PROG.NAME
*RESULT = RESULT<2>
*POS = INDEX(RESULT,"Total =",1); TOTAL = RESULT[POS+8,99]; TOTAL = TRIM(FIELD(TOTAL," ",1))
*POS = INDEX(RESULT,"Cksum =",1); CKSUM = RESULT[POS+8,99]; CKSUM = TRIM(FIELD(CKSUM," ",1))
*RQ.TOTAL = TRIM(FIELD(CHECK.LINE,",",1)); RQ.CKSUM = TRIM(FIELD(CHECK.LINE,",",2))
*CKSUM.DIFF = CKSUM - RQ.CKSUM
*IF ABS(CKSUM.DIFF) = 9984 THEN CKSUM.DIFF = 0; * ULTIMATE CHANGED THE CALCULATION - 23AUG85
*PRINT "             ":"TOTAL = ":TOTAL:"  RQ.TOTAL = ":RQ.TOTAL
*PRINT "             ":"CKSUM = ":CKSUM:"  RQ.CKSUM = ":RQ.CKSUM:"      DIFF = ":CKSUM-RQ.CKSUM
**
*IF TOTAL # RQ.TOTAL OR (CKSUM.DIFF) THEN
*PRINT "             ":"* ":DISP.NAME:".CHANGES ":PROG.NAME:" does not verify *"
*PRINT
*CHANGES.LOG<3,LOG.VC,LOG.SVC> = 1
*GOTO INSERT.DATE.TIME
*END
*
READ OLD.PROG FROM BP.FILE,PROG.NAME ELSE OLD.PROG = ""; SUCCESS.AC = 6
PROG = OLD.PROG
*
DELETES = PROG.CHANGES<2>
IF DELETES # "" THEN
MAX.LOC = COUNT(DELETES,",")+1
FOR LOC = MAX.LOC TO 1 STEP -1
DEL.RANGE = FIELD(DELETES,",",LOC)
DEL.FROM = FIELD(DEL.RANGE,"-",1); DEL.TO = FIELD(DEL.RANGE,"-",2); IF DEL.TO = "" THEN DEL.TO = DEL.FROM
FOR AC = DEL.TO TO DEL.FROM STEP -1
DEL PROG<AC>
NEXT AC
NEXT LOC
END
*
MAX.LOC = COUNT(PROG.CHANGES,AM)+1
MAX.AC = 0
FOR LOC = 3 TO MAX.LOC
ADD.LINE = PROG.CHANGES<LOC>
POS = INDEX(ADD.LINE," ",1); AC = ADD.LINE[1,POS-1]; ADD.LINE = ADD.LINE[POS+1,999]
INS ADD.LINE BEFORE PROG<AC>
IF AC > MAX.AC THEN MAX.AC = AC
NEXT LOC
*
WRITE PROG ON BP.FILE,PROG.NAME
READ PROG FROM BP.FILE,PROG.NAME ELSE PROG = ""
IF COUNT(PROG,AM)+1 < MAX.AC THEN
WRITEV "" ON BP.FILE,PROG.NAME,MAX.AC
END
*EX.LINE = 'CHECK-SUM ':DISP.NAME:' "':PROG.NAME:'"'
*PRINT "          ":EX.LINE
*EXECUTE EX.LINE, //OUT. > RESULT
*RESULT = RESULT<2>
*POS = INDEX(RESULT,"Total =",1); TOTAL = RESULT[POS+8,99]; TOTAL = TRIM(FIELD(TOTAL," ",1))
*POS = INDEX(RESULT,"Cksum =",1); CKSUM = RESULT[POS+8,99]; CKSUM = TRIM(FIELD(CKSUM," ",1))
*RQ.TOTAL = TRIM(FIELD(CHECK.LINE,",",3)); RQ.CKSUM = TRIM(FIELD(CHECK.LINE,",",4))
*IF RQ.TOTAL = -1 THEN RQ.TOTAL = TOTAL
*IF RQ.CKSUM = -1 THEN RQ.CKSUM = CKSUM
*CKSUM.DIFF = CKSUM - RQ.CKSUM
*IF ABS(CKSUM.DIFF) = 9984 THEN CKSUM.DIFF = 0; * ULTIMATE CHANGED THE CALCULATION - 23AUG85
*PRINT "             ":"TOTAL = ":TOTAL:"  RQ.TOTAL = ":RQ.TOTAL
*PRINT "             ":"CKSUM = ":CKSUM:"  RQ.CKSUM = ":RQ.CKSUM:"      DIFF = ":CKSUM-RQ.CKSUM
**
*IF TOTAL # RQ.TOTAL OR (CKSUM.DIFF) THEN
*WRITE OLD.PROG ON BP.FILE,PROG.NAME
*PRINT "             ":"* ":DISP.NAME:" ":PROG.NAME:" does not verify *"
*PRINT
*CHANGES.LOG<3,LOG.VC,LOG.SVC> = 1
*GOTO INSERT.DATE.TIME
*END
*
*DELETE CHANGE.FILE,PROG.NAME
*PRINT "             ":"* ":DISP.NAME:" ":PROG.NAME:" verifies *"
*PRINT
*IF BASIC.REQD THEN
*READV OLD.COMPILE.DATE FROM OBJ.FILE,PROG.NAME,5 ELSE OLD.COMPILE.DATE = "*NEW*"
*EXECUTE "BASIC ":DISP.NAME:" ":PROG.NAME:" (S)"
*READV COMPILE.DATE FROM OBJ.FILE,PROG.NAME,5 ELSE COMPILE.DATE = OLD.COMPILE.DATE
*IF OLD.COMPILE.DATE = COMPILE.DATE THEN CHANGES.LOG<4,LOG.VC,LOG.SVC> = 1; GOTO INSERT.DATE.TIME
*END
*CHANGES.LOG<SUCCESS.AC,LOG.VC,LOG.SVC> = 1
INSERT.DATE.TIME: *
*CHANGES.LOG<8,LOG.VC,LOG.SVC> = DATE()
*CHANGES.LOG<9,LOG.VC,LOG.SVC> = TIME()
GOTO NEXT.ITEM
END
~COMPILE.ALL~
*PROGRAM: COMPILE.ALL 
*
EXECUTE "GET-LIST PROGRAMS", //SELECT. > SLIST
EXECUTE "BASIC BP (S)", //SELECT. < SLIST
STOP
END
~COPYRIGHT~
SUBROUTINE COPYRIGHT
* PROGRAM:           COPYRIGHT
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       DISPLAY COPYRIGHT SCREEN...
* DATE WRITTEN:      19 DEC 85
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
* INPUT RSP,-1:; * REV ONLY
* IF LEN(RSP) THEN RETURN; * REV ONLY
PRINT @(0,0):CLS:
LN = "K-bil Subscriber Accounting System"
LN<2> = "__________________________________"
LN<3> = " Release 3, Version 0"
LN<5> = " Copyright 1983 through 1995.  All rights reserved."
LN<6> = " Axion Computer Systems Ltd."
LN<8> = " K-bil is a registered trademark."
LN<10> = " Programmers"
LN<11> = " Bob Conarroe * David Stern * David Horsman"
!
MX.L = 0; LNS = COUNT(LN,AM)+1; AC = 1
LOOP UNTIL AC > LNS DO
IF LEN(LN<AC>) > MX.L THEN MX.L = LEN(LN<AC>)
AC = AC+1
REPEAT
ST.LN = (18 - LNS) / 2
ST.COL = (66 - MX.L) / 2
*960324*DGH*IF SYSTEM(11) LT 3 THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
* IF TRUE THEN; * REV ONLY
PRINT @(ST.COL,ST.LN):RVB:SPACE(MX.L+14):
PRINT @(ST.COL,ST.LN+1):"  ":@(ST.COL+MX.L+12,ST.LN+1):"  ":
PRINT @(ST.COL,ST.LN+2):"  ":@(ST.COL+MX.L+12,ST.LN+2):"  ":
END
ST.LN = ST.LN+2
* ULT ONLY
FOR I = 1 TO LNS UNTIL SYSTEM(11)
*960324*DGH*FOR I = 1 TO LNS UNTIL SYSTEM(11) GE 3
* FOR I = 1 TO LNS; * REV ONLY
PRINT @(ST.COL,ST.LN):"  ":
IF LEN(LN<I>) THEN PRINT @(ST.COL+((11+MX.L-LEN(LN<I>)) / 2),ST.LN):RVE:LN<I>:RVB:
PRINT @(ST.COL+MX.L+12,ST.LN):"  ":
ST.LN = ST.LN+1
NEXT I
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
*960324*DGH*IF SYSTEM(11) LT 3 THEN
* IF TRUE THEN; * REV ONLY
PRINT @(ST.COL,ST.LN):"  ":@(ST.COL+MX.L+12,ST.LN):"  ":
PRINT @(ST.COL,ST.LN+1):"  ":@(ST.COL+MX.L+12,ST.LN+1):"  ":
PRINT @(ST.COL,ST.LN+2):SPACE(MX.L+14):RVE:
END
PRINT @(33,23):"press return...":; INPUT RSP:
*
RETURN
*
END
~COPYWRIGHT~
SUBROUTINE COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
* PROGRAM:           COPYWRIGHT
* AUTHOR:            DAVID HORSMAN - AXION
* DESCRIPTION:       DISPLAY COPYRIGHT SCREEN...
* DATE WRITTEN:      19 DEC 85
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
!
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
!
*
BREAK OFF
PRINT CLB:
*
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = EMPTY
*
OPEN "SEC" TO SEC.FILE ELSE
IF SEC.USER.ON THEN
STAT = TRUE
MAT PAR.MENU = EMPTY
* CHAIN "ZZOFF"
RETURN
END ELSE
PAR.MENU$USER.DT = DATE(); PAR.MENU$USER.TM = TIME()
PAR.MENU$GROUP = "TCL"
PAR.MENU$BF = TRUE
BREAK ON
RETURN
END
END
*
MAT SEC.USER = EMPTY
CONT = TRUE; TRY.CN = ZERO
*
!
*
IF PAR.MENU$USER EQ EMPTY OR SEC.USER.ID EQ EMPTY OR SEC.USER$DESC EQ EMPTY OR ((DATE() - PAR.MENU$USER.DT) * 86400) + (TIME() - PAR.MENU$USER.TM) GT 14400 THEN
**IF PAR.MENU$USER EQ EMPTY OR SEC.USER.ID EQ EMPTY OR ((DATE() - PAR.MENU$USER.DT) * 86400) + (TIME() - PAR.MENU$USER.TM) GT 14400 THEN
*
*
LOOP
*
*
IF PAR.MENU$USER EQ EMPTY THEN
LOOP
REDISP = FALSE; STAT = FALSE
PRINT @(ZERO,22):CLL:RVB:"Enter your operator id:":RVE:BELL:
IF NOT(SEC.USER.ON) THEN TMP = "RQ" ELSE
TMP = "EQ":SVM:"@":OPERATORS<ONE>:"@"
END
CALL INPUT.DATA.SG("COM","OPER",SEC.USER.ID,25,22,"L4","6",1,"",TMP,EMPTY,RSP,REDISP,STAT)
IF STAT THEN CHAIN "ZZOFF"
IF NOT(SEC.USER.ON) THEN
LOCATE SEC.USER.ID IN OPERATORS<ONE> BY "AL" SETTING PAR.LOC ELSE
PRINT CLB:RVB:"I can not find you, please re-enter:":RVE:BELL:; INPUT TMP:
REDISP = TRUE; * IF TMP NE "Y" THEN REDISP = TRUE
END
END
WHILE REDISP DO REPEAT
END ELSE RSP = PAR.MENU$USER
*
SEC.USER.ID = RSP
MATREAD SEC.USER FROM SEC.FILE,SEC.USER.ID THEN
*
! password
*
IF SEC.USER.ON AND PAR.MENU$USER EQ EMPTY THEN
ECHO OFF
PRINT @(ZERO,22):CLL:RVB:"Password: ":RVE:; INPUT RSP:
ECHO ON
END ELSE
RSP = SEC.USER$SAL
END
*
! Valid password or security off
*
IF RSP EQ SEC.USER$SAL OR NOT(SEC.USER.ON) THEN
*
CONT = FALSE; PAR.MENU$USER = SEC.USER.ID
PAR.MENU$USER.DT = DATE(); PAR.MENU$USER.TM = TIME()
PAR.MENU$GROUP = SEC.USER$GROUP
PAR.MENU$BF = SEC.USER$BF
*
IF NOT(LEN(SEC.USER$DESC)) THEN
LOCATE SEC.USER.ID IN OPERATORS<ONE> BY "AL" SETTING PAR.LOC THEN
FOR TMP = ONE TO 3 UNTIL LEN(SEC.USER$DESC) GE 3
SEC.USER$DESC = FIELD(OPERATORS<TWO,PAR.LOC>," ",TMP)
NEXT TMP
IF SEC.USER$GROUP EQ "EMPTY" THEN SEC.USER$GROUP = OPERATORS<TWO,PAR.LOC>
MATWRITE SEC.USER ON SEC.FILE,SEC.USER.ID
END ELSE NULL
END
*
END ELSE TRY.CN = TRY.CN + ONE; PAR.MENU$USER = EMPTY
*
! Not on file
*
END ELSE
*
*
TRY.CN = TRY.CN + ONE; PAR.MENU$USER = EMPTY
*
IF NOT(SEC.USER.ON) THEN
*
IF SEC.USER$DESC EQ EMPTY THEN
LOCATE SEC.USER.ID IN OPERATORS<ONE> BY "AL" SETTING PAR.LOC THEN
FOR TMP = ONE TO 3 UNTIL LEN(SEC.USER$DESC) GE 3
SEC.USER$DESC = FIELD(OPERATORS<TWO,PAR.LOC>," ",TMP)
NEXT TMP
IF SEC.USER$GROUP EQ "EMPTY" THEN SEC.USER$GROUP = OPERATORS<TWO,PAR.LOC>
MATWRITE SEC.USER ON SEC.FILE,SEC.USER.ID
END ELSE NULL
END
*
FOR TMP = ONE TO 3 UNTIL LEN(SEC.USER$DESC) GE 3
PRINT @(ZERO,22):CLL:RVB:"Enter your name: ":RVE:BELL:
RSP = SEC.USER$DESC
CALL INPUT.DATA.SG("COM","OPER.NAME",SEC.USER$DESC,20,22,"L6","10",1,"","",EMPTY,RSP,REDISP,STAT)
NEXT TMP
*
CONT = FALSE
PAR.MENU$GROUP = "TCL"; SEC.USER$GROUP = "TCL"
PAR.MENU$BF = TRUE; SEC.USER$BF = TRUE
PAR.MENU$USER = SEC.USER.ID
PAR.MENU$USER.DT = DATE(); PAR.MENU$USER.TM = TIME()
SEC.USER$ITEM.ID = SEC.USER.ID:".DATA"; SEC.USER$FILE.NAME = "COM"
*
MATWRITE SEC.USER ON SEC.FILE,SEC.USER.ID
*
END; * of security off (accept anything)
*
*
END; * Of not on file
*
IF NOT(SEC.USER.ON) THEN
LOCATE SEC.USER.ID IN OPERATORS<ONE> BY "AL" SETTING PAR.LOC ELSE
** INS SEC.USER.ID BEFORE OPERATORS<ONE,PAR.LOC>
** INS SEC.USER$DESC BEFORE OPERATORS<TWO,PAR.LOC>
** INS "?"           BEFORE OPERATORS<3,PAR.LOC>
WRITE OPERATORS ON PAR.FILE,"OPERATORS"
END
END
*
WHILE CONT AND TRY.CN LT 3 DO REPEAT
*
*
IF CONT AND TRY.CN GE 3 THEN
STAT = TRUE
CHAIN "ZZOFF"
PAR.MENU$USER = EMPTY; PAR.MENU$USER.DT = EMPTY; PAR.MENU$USER.TM = EMPTY
END
*
END; * Of date change or logon
*
!
*
IF PAR.MENU$BF THEN
BREAK ON
END
*
RETURN
*
END
~COUNT.ADD.BY.POSTAL.ZIP~
*PROGRAM:           COUNT.ADD.BY.POSTAL.ZIP
* VERSION: 940628 3.0  NEW
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       PRINT COUNTS OF THE NUMBER OF ADDRESSES BY CODE.
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
* 1994                 ALL RIGHTS RESERVED
!
VERSION = " (R:3.0)"
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP STT.DIM
$INCLUDE IBP STT.EQUATES
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP:; STOP
OPEN "STT" TO STT.FILE ELSE PRINT "Can't open file STT"; INPUT RSP:; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT "Can't open file ADD"; INPUT RSP:; STOP
* OPEN "LISTS" TO LISTS.FILE ELSE PRINT "Can't open file LISTS"; INPUT RSP:; STOP; * REV ONLY
*
INPUT AUTO.RUN
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP:; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Print Counts of Addresses by Postal/Zip Code":VERSION
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("COUNT.ADD.BY.POSTAL.ZIP","","Reassign areas")
!
POSTAL.TOTAL = 0; POSTAL.IDS = ""; POSTAL.ERRORS = ""; POSTAL.COUNTS = ""; CTR = 0
READ SYS.TST FROM CNT.FILE,"SYSTEM.TEST" ELSE SYS.TST = ""
$INCLUDE IBP SYSTEM.TEST
*
PRINT @(0,18):
IF OPSYS = "R" THEN
EXECUTE 'DELETE-LIST POSTAL.ERRORS'
END ELSE
DELETE CNT.FILE,"POSTAL.ERRORS"
END
PRINT @(0,10):CLS:
*
IF LIST.NAME EQ "" THEN
PRINT @(20,5):CLL:"Selecting addresses...":
EXLN = 'WITH STAT = "H" BY POST.CODE BY STREET.NUM'
* EXECUTE 'SSELECT ADD ':EXLN; * REV ONLY
* ULT ONLY
EXECUTE 'SSELECT ADD ':EXLN, //SELECT. > ADD.ID.LIST
END ELSE
* EXECUTE 'GET-LIST ':LIST.NAME; * REV ONLY
* ULT ONLY
EXECUTE "GET-LIST ":LIST.NAME, //SELECT. > ADD.ID.LIST
END
PREV.POSTAL.ID = ""; ZONE = "XXXX"
ADDR.CTR = 0; ERR.CTR = 0; POSTAL.CTR = 0; AC = 1
!
NXT: *
* READNEXT ADD.ID ELSE; * REV ONLY
* ULT ONLY
READNEXT ADD.ID FROM ADD.ID.LIST ELSE
IF POSTAL.ERRORS NE "" THEN
IF OPSYS = "R" THEN
WRITE POSTAL.ERRORS ON LISTS.FILE,"POSTAL.ERRORS"
IF NOT(AUTO.RUN) THEN
EXECUTE 'GET-LIST ':"POSTAL.ERRORS"
* IF TEST.FL THEN PRINT CLB:@LAST.ERROR:; INPUT TMP:; * REV ONLY
TMP = EMPTY
* TMP = @LAST.ERROR; * REV ONLY
IF NOT(TMP = 401) THEN
PRINT CLB:ERR.CTR:" Errors found. Printing Address Error List":
EXLN = 'LIST ADD STAT APT.NUM HOUSE.NUM STREET CITY ACT.IDS ACT.STAT ID-SUPP HEADING "':"'D'        ":CO.NAME:": MISSING POSTAL/ZIP CODES 'C'          Page 'P' 'L'":'" DBL-SPC (P)'
EXECUTE EXLN
END
END
END ELSE
PRINT CLB:ERR.CTR:" Errors found. They are in File CNT, Item POSTAL.ERRORS. Enter <cr>: ":; INPUT TMP:
WRITE POSTAL.ERRORS ON CNT.FILE,"POSTAL.ERRORS"
END
END
AC = 1; LN = 99
CALL PRINTER.ON(STAT)
LOOP POST.ID = POSTAL.IDS<AC> UNTIL POST.ID = "" DO
IF LN GT 60 THEN
PRINT FF:SPACE(10):OCONV(DATE(),"D2"):SPACE(5):"Counts of Addresses by Postal/Zip Code"
PRINT
PRINT
LN = 3
END
PRINT SPACE(25):POST.ID "L#11":"     ":POSTAL.COUNTS<AC> "R#6"
PRINT
AC = AC+1; LN = LN+2
POSTAL.TOTAL = POSTAL.TOTAL+POSTAL.COUNTS<AC>
REPEAT
PRINT
PRINT
PRINT SPACE(25):"Total" "L#11":"     ":POSTAL.TOTAL "R#6"
PRINT FF
PRINTER OFF
STOP
END
*
*
READV POST.CODE FROM ADD.FILE, ADD.ID, 6 ELSE GOSUB ADDR.ERRORS; GOTO NXT
STT.ID = FIELD(ADD.ID,"*",3); IF POST.CODE = "" THEN GOSUB ADDR.ERRORS; GOTO NXT
CTR = CTR+1
PRINT @(0,10):"Count: ":CTR "R#6":
IF POST.CODE # PREV.POSTAL.ID THEN
PRINT @(15,10):"Postal/Zip: ":POST.CODE:
IF PREV.POSTAL.ID NE "" THEN
POSTAL.IDS<AC> = PREV.POSTAL.ID
POSTAL.COUNTS<AC> = ADDR.CTR
AC = AC+1; ADDR.CTR = 0
END
PREV.POSTAL.ID = POST.CODE
END
ADDR.CTR = ADDR.CTR+1
PRINT @(35,10):"Count: ":ADDR.CTR "R#5":
MATREAD STT FROM STT.FILE,STT.ID ELSE MAT STT = ""
PRINT @(50,10):CLL:STT$NAME:", ":STT$CITY.NUM:
*
*
GOTO NXT
!
ADDR.ERRORS: *
ERR.CTR = ERR.CTR+1
LOCATE ADD.ID IN POSTAL.ERRORS BY "AL" SETTING LOC ELSE
INS ADD.ID BEFORE POSTAL.ERRORS<LOC>
END
RETURN
!
*
END
~COUNT.DATAS~
*PROGRAM: COUNT.DATAS 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "CNT" TO BP.FILE ELSE STOP
READ FILE.INDEX FROM BP.FILE,"FILES" ELSE STOP
FMAX = DCOUNT(FILE.INDEX<1>,VM)
FOR CN = 1 TO FMAX
BEGIN CASE
CASE OPSYS EQ "U"
EXLN = "CHECK-SUM ":FILE.INDEX<1,CN>
EXECUTE EXLN, //OUT. > EXEC.DATA
EXEC.DATA = TRIM(EXEC.DATA)
IF EXEC.DATA<1> EQ "" THEN DEL EXEC.DATA<1,0,0>
IF OPSYS EQ "M" THEN DEL EXEC.DATA<1,0,0>
IF EXEC.DATA<1> EQ "" THEN DEL EXEC.DATA<1,0,0>
EXEC.DATA = TRIM(EXEC.DATA)
TMP = INDEX(EXEC.DATA,"Items = ",1)
IF OPSYS EQ "M" THEN TMP = INDEX(EXEC.DATA,"ITEMS = ",1)
ICOUNT = EXEC.DATA[TMP+8,99]
ICOUNT = FIELD(ICOUNT," ",1)
TMP = INDEX(EXEC.DATA,"Average = ",1)
IF OPSYS EQ "M" THEN TMP = INDEX(EXEC.DATA,"AVERAGE = ",1)
ISIZE = EXEC.DATA[TMP+10,99]
ISIZE = FIELD(ISIZE," ",1)
CASE 1
TOT.CN = 0
TOT.SIZE = 0
ISIZE = 0
ICOUNT = 0
OPEN FILE.INDEX<1,CN> TO INP.FILE THEN
SELECT INP.FILE TO INP.ID.LIST
LOOP
READNEXT INP.ID FROM INP.ID.LIST ELSE INP.ID = "@"
WHILE INP.ID NE "@" DO
READ INP.ITEM FROM INP.FILE,INP.ID ELSE INP.ITEM = ""
*
*INP.ITEM+INP.ID+AM+HEXLENGTH
*   .    +   .  +1 +  5
TOT.SIZE = TOT.SIZE + LEN(INP.ITEM)+LEN(INP.ID)+1+5
*
TOT.CN = TOT.CN + 1
REPEAT
ICOUNT = TOT.CN
IF TOT.CN NE 0 THEN ISIZE = TOT.SIZE/TOT.CN ELSE ISIZE = 0
END ELSE NULL; * OF OPEN
END CASE
ISIZE = ICONV(ISIZE,"MR0")
PRINT CN "R#3":") ":FILE.INDEX<1,CN> "L#15":ICOUNT "R#5":ISIZE "R#10"
FILE.INDEX<2,CN> = ACCT
FILE.INDEX<4,CN> = ICOUNT
FILE.INDEX<6,CN> = ISIZE
WRITE FILE.INDEX ON BP.FILE,"FILES"
NEXT CN
END
~COUNT.DICTS~
*PROGRAM: COUNT.DICTS 
*
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN "CNT" TO BP.FILE ELSE STOP
READ FILE.INDEX FROM BP.FILE,"FILES" ELSE STOP
FMAX = DCOUNT(FILE.INDEX<1>,VM)
FOR CN = 1 TO FMAX
EXLN = "COUNT DICT ":FILE.INDEX<1,CN>
EXECUTE EXLN, //OUT. > EXEC.DATA
EXEC.DATA = TRIM(EXEC.DATA)
IF EXEC.DATA<1> EQ "" THEN DEL EXEC.DATA<1,0,0>
EXEC.DATA = TRIM(EXEC.DATA)
PRINT EXEC.DATA
ICOUNT = FIELD(EXEC.DATA," ",1)
IF ICOUNT EQ "ONE" THEN ICOUNT = 1
PRINT CN "R#3":") ":FILE.INDEX<1,CN> "L#15":ICOUNT "R#5"
FILE.INDEX<2,CN> = ACCT
FILE.INDEX<3,CN> = ICOUNT
NEXT CN
WRITE FILE.INDEX ON BP.FILE,"FILES"
END
~CREATE.ACX~
*PROGRAM: CREATE.ACX 
* VERSION: 
* DESCRIPITON:  CREATE.ACX - CREATE NAME INDEX FILE FROM ACT...
* IMPORTED:     20MAY90
!
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ACX.DIM
$INCLUDE IBP ACX.EQUATES
PRINT "SELECTING ACCOUNTS..."
OPEN "","ACT" TO ACT.FILE ELSE STOP
OPEN "","ACX" TO ACX.FILE ELSE STOP
SELECT ACT.FILE
CTR = 0
!
NXT: *
READNEXT ID ELSE STOP
MATREAD ACT FROM ACT.FILE,ID ELSE GOTO NXT
CTR = CTR+1
PRINT CTR "R#5":ID "R#10":"    ":ACT$CUS.NAME "L#30":ACT$ALT.NAME
LNM = FIELD(ACT$CUS.NAME,"*",1)
FNM = FIELD(ACT$CUS.NAME,"*",2)
ALNM = FIELD(ACT$ALT.NAME,"*",1)
IF ALNM = LNM THEN ALNM = ""
AFNM = FIELD(ACT$ALT.NAME,"*",2)
NM = TRIM(LNM:" ":FNM)
IF NM # "" THEN CALL ADD.ID(NM,ID,ACX.FILE,STAT)
IF ALNM # "" OR AFNM # "" THEN
IF ALNM = "" THEN ALNM = LNM
ANM = TRIM(ALNM:" ":AFNM)
IF ANM # NM THEN CALL ADD.ID(ANM,ID,ACX.FILE,STAT)
END
GOTO NXT
!
END
~CREATE.FILES.PROC.GEN~
*PROGRAM: CREATE.FILES.PROC.GEN 
*
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN "CNT" TO CNT.FILE ELSE STOP
*OPEN "MD" TO MD.FILE ELSE STOP
*OPEN "BP" TO BP.FILE ELSE STOP
OPEN "PL" TO PL.FILE ELSE STOP
READ FILE.INDEX FROM CNT.FILE,"FILES" ELSE STOP
LOOP
PRINT
PRINT "Will you use the calculated size (Y/N)? ":
INPUT RSP
IF RSP EQ "KILL" THEN STOP
WHILE RSP NE "Y" AND RSP NE "N" DO REPEAT
IF RSP EQ "Y" THEN SIZE.FLAG = 1 ELSE SIZE.FLAG = ""
*
LOOP
PRINT
PRINT "Will you use the minimum file modulo (Y/N)? ":
INPUT RSP
IF RSP EQ "KILL" THEN STOP
WHILE RSP NE "Y" AND RSP NE "N" DO REPEAT
IF RSP EQ "Y" THEN MIN.COUNT.FLAG = 1 ELSE MIN.COUNT.FLAG = ""
*
FMAX = DCOUNT(FILE.INDEX<1>,VM)
PROC = "PQN":AM:"C":AM:"C ":OCONV(DATE(),"D2"):" ":WHO:AM:"C":AM
FOR CN = 1 TO FMAX
FILE.NAME = FILE.INDEX<1,CN>
FILE.DICT.CN = FILE.INDEX<3,CN>
FILE.DICT.ESIZE = 40
FILE.DICT.MOD = FILE.DICT.CN * FILE.DICT.ESIZE / 512 * 1.2
IF FILE.DICT.MOD LT 3 THEN FILE.DICT.MOD = 3
FILE.DICT.MOD = ICONV(FILE.DICT.MOD,"MR0")
FILE.DICT.SEP = 1
FILE.DATA.CN = FILE.INDEX<4,CN>
FILE.DATA.ESIZE = FILE.INDEX<5,CN>
FILE.DATA.CSIZE = FILE.INDEX<6,CN>
FILE.DATA.MINCN = FILE.INDEX<7,CN>
IF NOT(NUM(FILE.DATA.MINCN)) THEN FILE.DATA.MINCN = 0
IF SIZE.FLAG THEN FILE.SIZE = FILE.DATA.CSIZE ELSE FILE.SIZE = FILE.DATA.ESIZE
IF NOT(FILE.SIZE) THEN FILE.SIZE = 100
FILE.DATA.MOD = FILE.DATA.CN * FILE.SIZE / 512 * 1.2
IF FILE.DATA.MOD LT FILE.DATA.MINCN AND MIN.COUNT.FLAG THEN FILE.DATA.MOD = FILE.DATA.MINCN
IF FILE.DATA.MOD LT 11 THEN FILE.DATA.MOD = 11
BEGIN CASE
CASE OPSYS = "M"
FILE.DATA.MOD = ICONV(FILE.DATA.MOD,"MR0")
FILE.DICT.MOD = ICONV(FILE.DICT.MOD,"MR0")
CASE 1
FILE.DATA.MOD = OCONV(FILE.DATA.MOD,"MR0")
FILE.DICT.MOD = OCONV(FILE.DICT.MOD,"MR0")
END CASE
FILE.DATA.SEP = 1
*
EXEC.LINE = "CREATE-FILE (":FILE.NAME:" ":FILE.DICT.MOD:",":FILE.DICT.SEP:" ":FILE.DATA.MOD:",":FILE.DATA.SEP:")"
PROC = PROC:"H":EXEC.LINE:AM:"P":AM:"C":AM:"C":AM
*
PRINT CN "R#3":") ":EXEC.LINE
FILE.INDEX<2,CN> = ACCT
FILE.INDEX<8,CN> = FILE.DICT.MOD
FILE.INDEX<9,CN> = FILE.DATA.MOD
NEXT CN
*
PROC = PROC:"C":AM:"C":AM
IF OPSYS = "M" THEN
PROC = PROC:"RTN":AM
END ELSE
PROC = PROC:"X":AM
END
*WRITE PROC ON MD.FILE,"CREATE.FILES.PROC"
*WRITE PROC ON BP.FILE,"CREATE.FILES.PROC"
WRITE PROC ON PL.FILE,"CREATE.FILES.PROC"
WRITE FILE.INDEX ON CNT.FILE,"FILES"
END
~CURSOR.KEYS.WORK~
?
53  50  56  52  54  13  43  45  25  24  16  17  53  48  60  62  126
05  02  08  04  06    02   <  04  06  06  04  05  00  04  06  00
03  13  16  17  24  45  60  92 126  48  49  50  51  52  53  54  55  56  57
DB  05  06  04   \   <   <   \   \  00  02  02  02  04  05  06  08  08  08 
HelpTestTclOffPrinterLptr FontUsersS/W
?.^MAINT.TSTTCLOFF.SP-MENU/MS.CALL-DH.PL LISTU/PG
~CURSOR.SUBR.POS~
SUBROUTINE CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
! *********************************
! IMPORTED TO FCI 11MAR94 *********
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
! *********************************
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
! *********************************
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
! *********************************
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
! *********************************
DIM STD(50); MAT STD = EMPTY
STD.FUNC = "READ"; STD.CONT = FALSE; STD.SUBR.NAME = EMPTY
*
! *********************************
*
$INCLUDE IBP CURSOR.POS
*
!
*
RETURN; * To calling program
*
!! ************ CALLS *****************
*
! Load STD DATA
*
LOAD.STD.DATA: *
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DATA
*
RETURN
*
! Standard System Call
*
ENTER.STD.SUBR: *
*
$INCLUDE IBP SYS.INCL.ENTER.STD.SUBR
*
RETURN
*
! Allow authorized entry into debug mode
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
END
~CURSOR.SUBR.POS.13MAR94~
SUBROUTINE CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
! *********************************
! IMPORTED TO FCI 11MAR94 *********
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
! *********************************
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
! *********************************
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
! *********************************
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
! *********************************
DIM STD(50); MAT STD = EMPTY
STD.FUNC = "READ"; STD.CONT = FALSE; STD.SUBR.NAME = EMPTY
! *********************************
*$INCLUDE IBP CURSOR.POS
*CODE.SEGMENT: CURSOR.POS
*
*
BEGIN CASE
*
! Select Key
*
CASE TC.FUNC EQ "5"
*
LOOP
POS.RSP = POS.REF<LN + ONE,CL.LOC>
RSP = FIELD(POS.RSP,"|",ONE)
LN.LOC = FIELD(POS.RSP,"|",TWO)
SUB.REF.LOC = FIELD(POS.RSP,"|",3)
WHILE RSP EQ '"' AND CL.LOC GT ONE DO CL.LOC = CL.LOC - ONE REPEAT
PRINT @(RSP.CL,RSP.LN):RVB:RSP:RVE:
CL = POS.LOC<LN + ONE,CL.LOC>
*
! Cursor Positioning
*
CASE INDEX("0123456789",TC.FUNC,ONE)
*
RSP = EMPTY
*
BEGIN CASE
*
! Prev Page
*
CASE TC.FUNC EQ "9"
*
TC.FUNC = EMPTY
*
! Next Page
*
CASE TC.FUNC EQ "3"
*
TC.FUNC = EMPTY
*
! Begining
*
CASE TC.FUNC EQ "7"
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; LN = ZERO; ORIG.LN = -ONE
LOOP UNTIL (POS.LOC<LN + ONE> NE EMPTY AND POS.REF<LN + ONE> NE EMPTY) OR LN EQ ORIG.LN DO
IF ORIG.LN EQ -ONE THEN ORIG.LN = LN
LN = LN + ONE
IF LN GT LN.MAX THEN LN = ZERO
REPEAT
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.LOC = ONE; CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
*
! End
*
CASE TC.FUNC EQ "1"
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; LN = LN.MAX; ORIG.LN = -ONE
LOOP UNTIL (POS.LOC<LN + ONE> NE EMPTY AND POS.REF<LN + ONE> NE EMPTY) OR LN EQ ORIG.LN DO
IF ORIG.LN EQ -ONE THEN ORIG.LN = LN.MAX
LN = LN - ONE
IF LN LT ZERO THEN LN = LN.MAX
REPEAT
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.LOC = CL.MAX; CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
*
! Not Used
*
CASE TC.FUNC EQ "0"
*
!     Up     Down     Left     Right          
*
CASE TRUE
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; CL.CONT = TRUE
ORIG.LN = -LN; ORIG.CL = CL; ORIG.DIR = TC.FUNC
IF NOT(ORIG.LN) THEN ORIG.LN = -1
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
*
*
LOOP
*
! Up or Down
*
IF TC.FUNC EQ "8" OR TC.FUNC EQ "2" THEN
*
UP.DN.CONT = TRUE
*
LOOP
*
LN = LN + (TC.FUNC EQ "2") - (TC.FUNC EQ "8")
IF LN LT ZERO THEN LN = LN.MAX
IF LN GT LN.MAX THEN LN = ZERO
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.CONT = TWO
* IF TC.FUNC EQ "2" THEN CL.STEP = ONE ELSE CL.STEP = -ONE
*
LOCATE CL IN POS.LOC<LN + ONE> BY "AR" SETTING CL.MIN ELSE NULL
FOR CL.CN = CL.MIN TO CL.MAX UNTIL CL.CONT LE ZERO
* STEP CL.STEP
IF NOT(INDEX("**hdr*bg*fg*key*","*":POS.REF<LN + ONE,CL.CN>:"*",ONE)) THEN
IF POS.LOC<LN + ONE,CL.CN> + 5 GE CL THEN CL.CONT = FALSE; CL.CN = CL.CN - ONE
END ELSE
IF CL.CN EQ CL.MAX THEN CL.CN = ZERO; CL.CONT = CL.CONT - ONE
END
IF CL.CN EQ CL.MIN THEN CL.CONT = CL.CONT - ONE
NEXT CL.CN
UP.DN.CONT = CL.CONT
IF POS.REF<LN + ONE,CL.CN> NE EMPTY THEN
CL.LOC = CL.CN
IF INDEX("**hdr*bg*fg*key*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE) THEN
IF TC.FUNC EQ "2" THEN
TC.FUNC = "6"
END ELSE TC.FUNC = "4"
END
END
*
IF LN EQ ORIG.LN THEN UP.DN.CONT = FALSE
IF (ORIG.DIR EQ "4" OR ORIG.DIR EQ "6") OR ORIG.LN GE ZERO THEN
IF POS.LOC<LN + ONE> NE EMPTY THEN UP.DN.CONT = FALSE
END
*
* IF LN EQ ABS(ORIG.LN) THEN ORIG.LN = ABS(ORIG.LN)
IF LN EQ -ORIG.LN THEN ORIG.LN = ABS(ORIG.LN); UP.DN.CONT = TRUE
*
WHILE UP.DN.CONT DO REPEAT
*
*
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
IF CL.LOC GT CL.MAX THEN CL.LOC = CL.MAX
IF NOT(CL.LOC) THEN CL.LOC = ONE
CL = POS.LOC<LN + ONE,CL.LOC>
CL.CONT = FALSE
*
END; * of dir is up/dn
*
! Left or Right
*
IF TC.FUNC EQ "4" OR TC.FUNC EQ "6" THEN
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
ORIG.CL = CL
ORIG.CL.LOC = CL.LOC
LOOP
CL.LOC = CL.LOC + (TC.FUNC EQ "6") - (TC.FUNC EQ "4")
IF NOT(CL.LOC) THEN CL.LOC = CL.MAX
IF CL.LOC GT CL.MAX THEN CL.LOC = ONE
* IF NOT(CL.LOC) THEN
IF CL.LOC EQ ORIG.CL.LOC THEN
IF TC.FUNC EQ "4" THEN
TC.FUNC = "8"
* CL.LOC = ONE
END ELSE
TC.FUNC = "2"
* CL.LOC = CL.MAX
END
CL.CONT = FALSE
END ELSE
IF CL.LOC GT CL.MAX THEN CL.LOC = ONE
IF NOT(CL.LOC) THEN CL.LOC = CL.MAX
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
END
CL = POS.LOC<LN + ONE,CL.LOC>
WHILE CL.CONT AND CL NE ORIG.CL DO REPEAT
* IF CL EQ ORIG.CL THEN PRINT BELL:
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
IF TC.FUNC NE "4" AND TC.FUNC NE "6" THEN CL.CONT = TRUE
END
*
IF LN EQ ABS(ORIG.LN) AND CL EQ ORIG.CL THEN PRINT BELL:; CL.CONT = FALSE
*
WHILE CL.CONT DO REPEAT
*
*
CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
* * PRINT @(CL,LN):
*
END CASE
*
* * PRINT @(CL,LN):RVB:">":RVE:
MARK.CL = OLD.CL - ONE
IF MARK.CL LT ZERO THEN MARK.CL = ZERO
PRINT @(MARK.CL,OLD.LN):" ":
*
! Special Call
*
CASE TC.FUNC EQ "@"
*
STD.FUNC = "PERFORM"
* SEC.USER$FUNC.NAME = STD.SUBR.NAME
GOSUB LOAD.STD.DATA
GOSUB ENTER.STD.SUBR
RSP = MENU.NAME
*
! Function Key Execute
*
CASE TC.FUNC EQ "E" OR TC.FUNC EQ "C"
*
IF TC.FUNC EQ "C" THEN TC.FUNC = EMPTY
*
! Error
*
CASE TRUE
*
RSP = MENU.NAME
*
*
END CASE
*
*@@@
*
RETURN; * To calling program
*
!! ************ CALLS *****************
*
! Load STD DATA
*
LOAD.STD.DATA: *
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DATA
*
RETURN
*
! Standard System Call
*
ENTER.STD.SUBR: *
*
$INCLUDE IBP SYS.INCL.ENTER.STD.SUBR
*
RETURN
*
! Allow authorized entry into debug mode
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
END
~CUSTOMIZE.GENERAL~
*PROGRAM: CUSTOMIZE.GENERAL 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
*                    SEE '*CUSTOM*' LINES.
*                    ANY 888 REFERENCE MUST BE CHANGED TO 'AA.VC'.
*                    ANY 777 REFERENCE MUST BE CHANGED TO 'LO.SVC'.
* DATE WRITTEN:      05 MAY 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
LOGON = ""; ADMIN.AREA = ""; *CUSTOM*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(3)
VALID.REFS = "AL":AM:"RF":AM:"RN"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
*CUSTOM* GOSUB DISPLAY.BACKGROUND
CNT.ID = ""; GOSUB GET.KEY; IF CNT.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ CNT FROM CNT.FILE,CNT.ID THEN NEW = "" ELSE NEW = 1; CNT = ""
GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
GOSUB DISPLAY.BACKGROUND; *CUSTOM*
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 3
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
GOSUB DEL.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
GOTO UPDATE; *CUSTOM*
PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE CNT.FILE,CNT.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE CNT ON CNT.FILE,CNT.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
GOTO NEXT.ITEM; *CUSTOM*
*CUSTOM* STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                                Customize GENIE                                 ":RVE:
PRINT @(0,3):RVB:"Administrative area......":RVE:"                 ":RVB:"valid functions:                      ":RVE:
PRINT @(0,4):RVB:"Data account password....":RVE:"                 ":RVB:"B*  modify basic data                 ":RVE:
PRINT @(0,5):"                                          ":RVB:"C*  modify comments                   ":RVE:
PRINT @(0,6):RVB:"AL>      ":RVE:"   ":RVB:"RF>     ":RVE:"    ":RVB:"RN>      ":RVE:"         ":RVB:"M*  modify mail address               ":RVE:
PRINT @(0,7):RVB:"Allowed  ":RVE:"   ":RVB:"Routing:":RVE:"    ":RVB:"Routing: ":RVE:"         ":RVB:"P*  modify PAC data                   ":RVE:
PRINT @(0,8):RVB:"Functions":RVE:"   ":RVB:"found   ":RVE:"    ":RVB:"not found":RVE:"         ":RVB:"T   display billing transactions      ":RVE:
PRINT @(0,9):"                                          ":RVB:"W   display work orders               ":RVE:
PRINT @(0,10):"                                          ":RVB:"W*  enter/modify orders               ":RVE:
PRINT @(0,11):"                                          ":RVB:"X   enter BILLING ONLY account        ":RVE:
PRINT @(0,14):"                                          ":RVB:"valid routing codes:                  ":RVE:
PRINT @(0,15):"                                          ":RVB:"T   display transactions              ":RVE:
PRINT @(0,16):"                                          ":RVB:"P   display/modify PAC data           ":RVE:
PRINT @(0,17):"                                          ":RVB:"W   display/modify work orders        ":RVE:
PRINT @(0,18):"                                          ":RVB:"B   display/modify basic data         ":RVE:
PRINT @(0,19):"                                          ":RVB:"S   display services                  ":RVE:
PRINT @(0,20):"                                          ":RVB:"H   print hardcopy                    ":RVE:
PRINT @(26,3):CNT<1,AA.VC> "L#8":; *CUSTOM*
PRINT @(26,4):CNT<2,AA.VC,LO.SVC> "L#8":; *CUSTOM*
RETURN
!
DISPLAY.FOREGROUND: *
*CUSTOM* PRINT @(26,3):CNT<1,AA.VC> "L#8":
*CUSTOM* PRINT @(26,4):CNT<2,AA.VC,LO.SVC> "L#8":
*CUSTOM* PRINT @(0,9):FIELD(CNT<3,AA.VC,LO.SVC>,",",) "L#2":
PRINT @(0,10):FIELD(CNT<3,AA.VC,LO.SVC>,",",1) "L#2":
PRINT @(0,11):FIELD(CNT<3,AA.VC,LO.SVC>,",",2) "L#2":
PRINT @(0,12):FIELD(CNT<3,AA.VC,LO.SVC>,",",3) "L#2":
PRINT @(0,13):FIELD(CNT<3,AA.VC,LO.SVC>,",",4) "L#2":
PRINT @(0,14):FIELD(CNT<3,AA.VC,LO.SVC>,",",5) "L#2":
PRINT @(0,15):FIELD(CNT<3,AA.VC,LO.SVC>,",",6) "L#2":
PRINT @(0,16):FIELD(CNT<3,AA.VC,LO.SVC>,",",7) "L#2":
PRINT @(0,17):FIELD(CNT<3,AA.VC,LO.SVC>,",",8) "L#2":
PRINT @(0,18):FIELD(CNT<3,AA.VC,LO.SVC>,",",9) "L#2":
PRINT @(0,19):FIELD(CNT<3,AA.VC,LO.SVC>,",",10) "L#2":
PRINT @(0,20):FIELD(CNT<3,AA.VC,LO.SVC>,",",11) "L#2":
*CUSTOM* PRINT @(12,9):FIELD(CNT<4,AA.VC,LO.SVC>,",",) "L#1":
PRINT @(12,10):FIELD(CNT<4,AA.VC,LO.SVC>,",",1) "L#1":
PRINT @(12,11):FIELD(CNT<4,AA.VC,LO.SVC>,",",2) "L#1":
PRINT @(12,12):FIELD(CNT<4,AA.VC,LO.SVC>,",",3) "L#1":
PRINT @(12,13):FIELD(CNT<4,AA.VC,LO.SVC>,",",4) "L#1":
*CUSTOM* PRINT @(24,9):FIELD(CNT<5,AA.VC,LO.SVC>,",",) "L#1":
PRINT @(24,10):FIELD(CNT<5,AA.VC,LO.SVC>,",",1) "L#1":
PRINT @(24,11):FIELD(CNT<5,AA.VC,LO.SVC>,",",2) "L#1":
PRINT @(24,12):FIELD(CNT<5,AA.VC,LO.SVC>,",",3) "L#1":
PRINT @(24,13):FIELD(CNT<5,AA.VC,LO.SVC>,",",4) "L#1":
RETURN
!
GET.KEY: *
CNT.ID = "GENIE"
RETURN
!
GET.DATA: *
ON REF GOSUB i01,i02,i03
RETURN
!
i01: FOR SUB.REF = 1 TO 12
ON SUB.REF GOSUB i01A,i01B,i01C,i01D,i01E,i01F,i01G,i01H,i01I,i01J,i01K,i01L
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 12
NEXT SUB.REF
AC = 3; GOSUB TRIM.COMMAS; *CUSTOM*
RETURN
*CUSTOM* i01A: CALL INPUT.DATA(CNT,0,9,"L2",3:",":AA.VC:",":LO.SVC:",":",","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01A: RETURN; *CUSTOM*
i01B: CALL INPUT.DATA(CNT,0,10,"L2",3:",":AA.VC:",":LO.SVC:",":",1","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01C: CALL INPUT.DATA(CNT,0,11,"L2",3:",":AA.VC:",":LO.SVC:",":",2","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01D: CALL INPUT.DATA(CNT,0,12,"L2",3:",":AA.VC:",":LO.SVC:",":",3","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01E: CALL INPUT.DATA(CNT,0,13,"L2",3:",":AA.VC:",":LO.SVC:",":",4","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01F: CALL INPUT.DATA(CNT,0,14,"L2",3:",":AA.VC:",":LO.SVC:",":",5","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01G: CALL INPUT.DATA(CNT,0,15,"L2",3:",":AA.VC:",":LO.SVC:",":",6","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01H: CALL INPUT.DATA(CNT,0,16,"L2",3:",":AA.VC:",":LO.SVC:",":",7","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01I: CALL INPUT.DATA(CNT,0,17,"L2",3:",":AA.VC:",":LO.SVC:",":",8","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01J: CALL INPUT.DATA(CNT,0,18,"L2",3:",":AA.VC:",":LO.SVC:",":",9","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01K: CALL INPUT.DATA(CNT,0,19,"L2",3:",":AA.VC:",":LO.SVC:",":",10","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i01L: CALL INPUT.DATA(CNT,0,20,"L2",3:",":AA.VC:",":LO.SVC:",":",11","","OPEQB*C*M*P*TWW*X","",RSP,STAT); RETURN
i02: FOR SUB.REF = 1 TO 5
ON SUB.REF GOSUB i02A,i02B,i02C,i02D,i02E
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 5
NEXT SUB.REF
AC = 4; GOSUB TRIM.COMMAS; *CUSTOM*
RETURN
*CUSTOM* i02A: CALL INPUT.DATA(CNT,12,9,"L1",4:",":AA.VC:",":LO.SVC:",":",","","OPEQTPWBSH","",RSP,STAT); RETURN
i02A: RETURN; *CUSTOM*
i02B: CALL INPUT.DATA(CNT,12,10,"L1",4:",":AA.VC:",":LO.SVC:",":",1","","OPEQTPWBSH","",RSP,STAT); RETURN
i02C: CALL INPUT.DATA(CNT,12,11,"L1",4:",":AA.VC:",":LO.SVC:",":",2","","OPEQTPWBSH","",RSP,STAT); RETURN
i02D: CALL INPUT.DATA(CNT,12,12,"L1",4:",":AA.VC:",":LO.SVC:",":",3","","OPEQTPWBSH","",RSP,STAT); RETURN
i02E: CALL INPUT.DATA(CNT,12,13,"L1",4:",":AA.VC:",":LO.SVC:",":",4","","OPEQTPWBSH","",RSP,STAT); RETURN
i03: FOR SUB.REF = 1 TO 5
ON SUB.REF GOSUB i03A,i03B,i03C,i03D,i03E
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 5
NEXT SUB.REF
AC = 5; GOSUB TRIM.COMMAS; *CUSTOM*
RETURN
*CUSTOM* i03A: CALL INPUT.DATA(CNT,24,9,"L1",5:",":AA.VC:",":LO.SVC:",":",","","OPEQTPWBSH","",RSP,STAT); RETURN
i03A: RETURN; *CUSTOM*
i03B: CALL INPUT.DATA(CNT,24,10,"L1",5:",":AA.VC:",":LO.SVC:",":",1","","OPEQTPWBSH","",RSP,STAT); RETURN
i03C: CALL INPUT.DATA(CNT,24,11,"L1",5:",":AA.VC:",":LO.SVC:",":",2","","OPEQTPWBSH","",RSP,STAT); RETURN
i03D: CALL INPUT.DATA(CNT,24,12,"L1",5:",":AA.VC:",":LO.SVC:",":",3","","OPEQTPWBSH","",RSP,STAT); RETURN
i03E: CALL INPUT.DATA(CNT,24,13,"L1",5:",":AA.VC:",":LO.SVC:",":",4","","OPEQTPWBSH","",RSP,STAT); RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
DEL.CALL: *
* DELETE ONLY A SINGLE LOGON FROM ITEM...
PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN STAT = 1; RETURN
FOR AC = 1 TO 5
DEL CNT<AC,AA.VC,LO.SVC>
NEXT AC
RETURN
!
READ.CALL: *
* DISPLAY LOGONS THEN SELECT ONE...
IF LOGON = "" THEN PRV.3 = ""; PRV.4 = ""; PRV.5 = "" ELSE
PRV.3 = CNT<3,AA.VC,LO.SVC>
PRV.4 = CNT<4,AA.VC,LO.SVC>
PRV.5 = CNT<5,AA.VC,LO.SVC>
END
READ CNT.ADM FROM CNT.FILE, "ADMIN.AREAS" ELSE PRINT "Can't find ADMIN.AREAS":; INPUT RSP:; STOP
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                                 Customize GENIE                                ":RVE:
PRINT @(0,3):RVB:"Administrative area: ":RVE:
TITLE = RVB:"Logon     ":RVE:"    ":RVB:"Description":RVE
PRINT @(0,5):TITLE:@(45,5):TITLE:
NUM.ADM = 0
LOOP NUM.ADM = NUM.ADM+1 UNTIL CNT.ADM<1,NUM.ADM> = "" DO
REPEAT
NUM.ADM = NUM.ADM-1
INP.ADMIN: *
IF ADMIN.AREA = "" THEN
IF NUM.ADM < 2 THEN AA.VCA = 1; ADMIN.AREA = CNT.ADM<1,AA.VCA> ELSE
PRINT @(22,3):CLL:; INPUT ADMIN.AREA:
IF ADMIN.AREA = "" OR ADMIN.AREA = "KILL" THEN CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE); STOP
LOCATE ADMIN.AREA IN CNT.ADM<1> SETTING AA.VCA ELSE PRINT BELL:; GOTO INP.ADMIN
END
END
PRINT @(22,3):ADMIN.AREA:"   ":CNT.ADM<2,AA.VCA>:
IF NEW THEN CNT = ""; NEW = ""
LOCATE ADMIN.AREA IN CNT BY "AL" SETTING AA.VC ELSE
INS ADMIN.AREA BEFORE CNT<1,AA.VC>
INS "" BEFORE CNT<2,AA.VC>
INS "" BEFORE CNT<3,AA.VC>
INS "" BEFORE CNT<4,AA.VC>
INS "" BEFORE CNT<5,AA.VC>
END
LO.SVCA = 1; CL = 0; LN = 6
LOOP LOGON = CNT.ADM<4,AA.VCA,LO.SVCA> UNTIL LOGON = "" DO
PRINT @(CL,LN):LOGON "L#14":CNT.ADM<5,AA.VCA,LO.SVCA> "L#25":
LN = LN+1; IF LN > 20 THEN LN = 6; IF CL = 0 THEN CL = 45 ELSE LO.SVCA = 999
LO.SVCA = LO.SVCA+1
REPEAT
INP.LOGON: *
PRINT @(10,22):CLL:"Enter Logon: ":
INPUT LOGON:
IF LOGON = "" THEN IF NUM.ADM < 2 THEN LOGON = "KILL" ELSE ADMIN.AREA = ""; GOTO INP.ADMIN
IF LOGON = "KILL" THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
END
LOCATE LOGON IN CNT.ADM<4,AA.VCA> BY "AL" SETTING LO.SVCA ELSE PRINT BELL:; GOTO INP.LOGON
LOCATE LOGON IN CNT<2,AA.VC> BY "AL" SETTING LO.SVC ELSE
INS LOGON BEFORE CNT<2,AA.VC,LO.SVC>
INS PRV.3 BEFORE CNT<3,AA.VC,LO.SVC>
INS PRV.4 BEFORE CNT<4,AA.VC,LO.SVC>
INS PRV.5 BEFORE CNT<5,AA.VC,LO.SVC>
END
RETURN
!
TRIM.COMMAS: *
FLD = CNT<AC,AA.VC,LO.SVC>
LOOP UNTIL NOT(FLD[LEN(FLD),1] = ",") DO
FLD = FLD[1,LEN(FLD)-1]
REPEAT
CNT<AC,AA.VC,LO.SVC> = FLD
RETURN
!
END
~CUSTOMIZE.MENUS~
*PROGRAM: CUSTOMIZE.MENUS 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
*                    ** MODIFIED VERSION OF 'MENU.HANDLER' WHICH SHOWS
*                       AND ACCEPTS CHANGES TO PASSWORDS **
* DATE WRITTEN:      03 MAR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT STARTING.MENU:
OPEN "MENUS" TO MU.FILE ELSE GOTO END.IT
OPEN "MD" TO MD.FILE ELSE GOTO END.IT
OPEN "ACC" TO AC.FILE ELSE GOTO END.IT
OPEN "CNT" TO CNT.FILE ELSE GOTO END.IT
OPEN "PAR" TO PAR.FILE ELSE GOTO END.IT
ADMIN.AREA = ""
READ PAR FROM PAR.FILE, "ADMIN.AREAS" ELSE PRINT "Can't find ADMIN.AREAS":; INPUT RSP:; GOTO END.IT
LOCATE ACCT IN PAR<1> BY "AL" SETTING AA.VC THEN ADMIN.AREA = ACCT; GOTO READ.CONAME
AA.VC = 1
LOOP
LOCATE ACCT IN PAR<4,AA.VC> BY "AL" SETTING SC THEN
ADMIN.AREA = PAR<1,AA.VC>
END
UNTIL ADMIN.AREA # "" OR PAR<1,AA.VC> = "" DO
AA.VC = AA.VC+1
REPEAT
IF ADMIN.AREA = "" THEN PRINT "Can't find ":ACCT:" in any administrative area":; INPUT RSP; GOTO END.IT
*
READ.CONAME: *
DIM MENU(100),ROUTE(100),PRMPT(100)
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 THEN CO.NAME = CO.NAME<1,1,1> ELSE CO.NAME = ""
ENDER = 0
CALL.ID = "MENU.":PORT
MENU.NAME = STARTING.MENU
MENU(1) = "Customize menus"
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#10":(SPACE(30-LEN(CO.NAME)/2+.5):CO.NAME) "L#60":("Port ":PORT:SPACE(LEN(ACCT)-2)) "R#10":
PRINT @(0,1):OCONV(TIME(),"MTS") "L#15":(SPACE(25-LEN(MENU(1))/2+.5):MENU(1)) "L#50":("Admin ":ADMIN.AREA) "R#15":RVE:
PRINT @(20,10):RVB:"Logon              ":RVE:
PRINT @(20,12):RVB:"Model logon        ":RVE:
PRINT @(20,14):RVB:"Delete? (Y,<cr>)   ":RVE:
INP.LOGON: *
PRINT @(40,10):
INPUT LOGON:
IF LOGON = "KILL" THEN GOTO END.IT
IF LOGON = "" THEN GOTO END.IT
IF LOGON # PAR<1,AA.VC> THEN
LOCATE LOGON IN PAR<4,AA.VC> BY "AL" SETTING SC ELSE
PRINT @(0,23):CLL:BELL:"Logon is not valid for this administrative area":; INPUT RSP:; PRINT @(0,23):CLL:; GOTO INP.LOGON
END
END
INP.MODEL: *
PRINT @(40,12):; INPUT MODEL:
IF MODEL = "KILL" THEN GOTO END.IT
IF MODEL = "^" THEN GOTO INP.LOGON
IF MODEL # PAR<1,AA.VC> THEN
IF MODEL # "" THEN
LOCATE MODEL IN PAR<4,AA.VC> BY "AL" SETTING SC ELSE
PRINT @(0,23):CLL:BELL:"Logon is not valid for this administrative area":; INPUT RSP:; PRINT @(0,23):CLL:; GOTO INP.MODEL
END
END
END
INP.DLT: *
IF MODEL = "" THEN
PRINT @(40,14):; INPUT RSP:
IF RSP = "KILL" THEN GOTO END.IT
IF RSP = "^" THEN GOTO INP.MODEL
IF RSP # "Y" AND RSP # "N" AND RSP # "" THEN PRINT BELL:; GOTO INP.DLT
IF RSP = "Y" THEN
PRINT @(0,23):CLL:"Please wait a few seconds while logon is cleared...":
IF LOGON # PAR<1,AA.VC> THEN DELETE MD.FILE, LOGON
EXECUTE 'SELECT MU.FILE', //SELECT. > FILE.ID.LIST
NXT.DLT: *
READNEXT MENU.NAME FROM FILE.ID.LIST ELSE PRINT @(0,23):CLL:; GOTO READ.CONAME
MATREAD MENU FROM MU.FILE, MENU.NAME ELSE GOTO NXT.DLT
AC = 3
LOOP LINE = MENU(AC) UNTIL LINE = "" OR AC = 100 DO
VALID.ACCTS = LINE<1,4>
LOCATE LOGON IN VALID.ACCTS<1,1> SETTING VALID THEN DEL VALID.ACCTS<1,1,VALID>; LINE<1,4> = VALID.ACCTS; MENU(AC) = LINE
AC = AC+1
REPEAT
MATWRITE MENU ON MU.FILE, MENU.NAME
GOTO NXT.DLT
END
END
*
LOOP
IF MODEL = "" THEN USE.MODEL = "" ELSE USE.MODEL = 1
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE GOTO END.IT
MAT ROUTE = ""; MAT PRMPT = ""
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#10":(SPACE(30-LEN(CO.NAME)/2+.5):CO.NAME) "L#60":("Port ":PORT:SPACE(LEN(ACCT)-2)) "R#10":
PRINT @(0,1):OCONV(TIME(),"MTS") "L#15":(SPACE(25-LEN(MENU(1))/2+.5):MENU(1)) "L#50":("Logon ":LOGON) "R#15":RVE:
*
*
STOPS = ""; * COLUMN]LINE]AMC]FLAG FOR ALL LINES ON MENU....
AC = 3; CL = 22; LN = 3
LOOP LINE = MENU(AC) UNTIL LINE = "" OR AC = 100 DO
VALID.ACCTS = LINE<1,4>
IF USE.MODEL THEN LOCATE LOGON IN VALID.ACCTS<1,1> SETTING VALID THEN USE.MODEL = ""
AC = AC+1; IF LINE<1,1> = ">" THEN CL = 2
REPEAT
IF USE.MODEL THEN SEARCH.ACCT = MODEL ELSE SEARCH.ACCT = LOGON
MAX.AC = AC-1
*
NUM = 1
FOR AC = 3 TO MAX.AC
LINE = MENU(AC)
VALID = 1; VALID.ACCTS = LINE<1,4>
IF VALID.ACCTS # "" THEN LOCATE SEARCH.ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN VALID = "*" ELSE VALID = " "
PRINT @(CL-1,LN):VALID:
TEXT = LINE<1,1>
STOPS = STOPS:CL-1:VM:LN:VM:AC:VM:VALID:AM; * save screen positions customization loop
IF TEXT = ">" THEN PRINT RVB:">  ":RVE:; CL = 42; LN = 3; PRINT @(CL,LN): ELSE
IF TEXT[1,1] # "*" THEN
PRMPT(NUM) = LINE<1,3>:VM:AC; IF PRMPT(NUM)<1,1> = "" THEN PRMPT(NUM)<1,1> = NUM
ROUTE(NUM) = LINE<1,2>
IF TEXT # "" THEN PRINT @(CL,LN):RVB:PRMPT(NUM)<1,1> "R#3":RVE:" ":TEXT
NUM = NUM+1
END ELSE IF TEXT # "*" THEN PRINT @(CL-2,LN):TEXT[2,99]
END
LN = LN+1
NEXT AC
LOOP
CHOICE: *
HELP = ""
PRINT @(20,23):CLL:"Enter your choice OR / to customize: ":
INPUT RSP:
IF RSP = "KILL" OR RSP = "TCL" THEN GOTO END.IT
IF RSP = "/" OR RSP = "\" THEN GOSUB CUSTOMIZE; IF CMD = "K" THEN GOTO END.IT ELSE GOTO CHOICE
IF RSP = "" THEN
ROUTING = MENU(2)<1,1>
IF ROUTING<1,1,1> = MENU.NAME THEN ENDER = 1
END ELSE
IF RSP[1,1] = "?" THEN
RSP = TRIM(RSP[2,99]); IF RSP[1,1] = "?" THEN RSP = RSP[2,99]; HELP = 2 ELSE HELP = 1
END
FOR NUM = 1 TO 100 UNTIL PRMPT(NUM)<1,1> = RSP OR PRMPT(NUM)<1,1> = ""; NEXT NUM
IF NUM <= 100 AND PRMPT(NUM)<1,1> # "" THEN ROUTING = ROUTE(NUM) ELSE ROUTING = ""
IF HELP THEN IF ROUTING # "" THEN GOSUB 2000; ROUTING = MENU.NAME
END
IF ROUTING = "" THEN PRINT BELL:
IF ROUTING[1,1] # "/" THEN ROUTING = ""
WHILE ROUTING = "" DO
REPEAT
GOSUB UPDATE.MENU
MENU.NAME = ROUTING<1,1,1>
WHILE ENDER = 0 DO REPEAT
GOTO READ.CONAME
*
!
2000 * HELP MESSAGES
PRINT @(0,2):CLS
IF HELP = 2 THEN ROUTING = "?":ROUTING
EXECUTE 'RUNOFF HLP CABLE.':ROUTING
PRINT @(0,23):CLL:"Enter <cr> to return to menu    ":
INPUT RSP:
PRINT @(0,23):CLL:
RETURN
!
CUSTOMIZE: *
PRINT @(0,23):CLL:"press one of following: <cr>=change, ARROW=move cursor, E=end, K=kill":
STAC = 1
LOOP
CL = STOPS<STAC,1>
LN = STOPS<STAC,2>
AC = STOPS<STAC,3>
VALID = STOPS<STAC,4>
PRINT @(CL,LN):
INP.CMD: *
ECHO OFF
INPUT CMD,1
ECHO ON
BEGIN CASE
CASE CMD = "K" OR CMD = "E"; STAC = 0
CASE CMD = "8"
STAC = STAC-1
IF STAC = 0 THEN LOOP STAC = STAC+1 UNTIL STOPS<STAC+1> = "" DO REPEAT
CASE CMD = "2"
STAC = STAC+1
IF STOPS<STAC> = "" THEN STAC = 1
CASE CMD = ""
IF VALID = " " THEN VALID = "*" ELSE VALID = " "
STOPS<STAC,4> = VALID
PRINT @(CL,LN):VALID:
STAC = STAC+1
IF STOPS<STAC> = "" THEN STAC = 1
CASE 1; PRINT BELL:
END CASE
WHILE STAC DO REPEAT
PRINT @(0,23):CLL:
RETURN
!
UPDATE.MENU: *
READ LOGON.PROC FROM MD.FILE, LOGON ELSE
READ LOGON.PROC FROM MD.FILE, PAR<1,AA.VC> THEN
WRITE LOGON.PROC ON MD.FILE, LOGON
END
END
STAC = 0
LOOP STAC = STAC+1 UNTIL STOPS<STAC> = "" DO
AC = STOPS<STAC,3>
VALID = STOPS<STAC,4>
LINE = MENU(AC)
VALID.ACCTS = LINE<1,4>
LOCATE LOGON IN VALID.ACCTS<1,1> BY "AL" SETTING VVC THEN
IF VALID = " " THEN DEL VALID.ACCTS<1,1,VVC>
END ELSE IF VALID = "*" THEN INS LOGON BEFORE VALID.ACCTS<1,1,VVC>
LINE<1,4> = VALID.ACCTS
MENU(AC) = LINE
REPEAT
MATWRITE MENU ON MU.FILE, MENU.NAME
RETURN
!
END.IT: *
PRINT @(0,3):CLS:
STOP
!
END
~DATE.CONVERT~
*PROGRAM: DATE.CONVERT 
*
PROMPT ""
LOOP
PRINT "Date to convert or <cr> to end: ":
INPUT DT
UNTIL DT = "" DO
IF DT MATCHES "0N" THEN DT = OCONV(DT,"D") ELSE CALL GET.ICONV(DT,"D")
PRINT DT
PRINT
REPEAT
DT = DATE(); TM = TIME()
PRINT DT:" ":TM
PRINT OCONV(DT,"D2"):" ":OCONV(DT,"D2/"):" ":OCONV(TM,"MTS")
END
~DAVE~
*PROGRAM: CHAR.CONV 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
LOOP
*
PRINT @(0,3):"ENTER THE LETTER TO CONVERT: ":
*
INPUT RSP
PRINT
PRINT RSP
PRINT
*
WHILE TRUE DO
*
EXECUTE RSP
*
REPEAT
*
*
STOP
*
END
~DAYS.SUBR.CONV~
SUBROUTINE DAYS.SUBR.CONV(TMP.TM,ORSLT)
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP DAYS.INCL.CONV
*
RETURN
*
END
~DEC.PRINTER.FONT~
*PROGRAM: DEC.PRINTER.FONT 
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       SETS DEC LA120 PRINTER FONT
* DATE WRITTEN:      16 FEB 88
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Select printer font for DEC LA120 series printers"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
PRINT @(20,4):"1, 17 CPI draft font":
PRINT @(20,6):"2. 12 CPI draft font":
PRINT @(20,8):"3. 10 CPI draft font":
*
LOOP
PRINT @(20,22):CLL:"Enter your choice: ":
INPUT RSP:
IF RSP = "" THEN STOP
WHILE RSP < 1 OR RSP > 6 DO PRINT BELL: REPEAT
*
PITCH.CODES = "421"
*
PITCH.CODE = CHAR(27):"[":PITCH.CODES<1,RSP>:"w"
*
PRINTER ON
PRINT PITCH.CODE:
PRINTER OFF
*
PRINT @(20,23):CLL:"Set to mode ":RSP:" - hit <cr> to end   ":
INPUT RSP:
END
~DEC.PRINTER.LINES~
*PROGRAM: DEC.PRINTER.LINES 
* AUTHOR:            HARVEY HORSMAN - AXION
* DESCRIPTION:       SETS DEC LA120 LINES PER INCH
* DATE WRITTEN:      25 SEP 88
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Select Lines per Inch for GE-3000 series printers"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
PRINT @(20,4):"1. 6 Lines per inch":@(20,5):"2. 8 Lines per inch":
LOOP
PRINT @(20,22):CLL:"Enter your choice: ":
INPUT RSP:
IF RSP = "" THEN STOP
WHILE RSP < 1 OR RSP > 2 DO PRINT BELL: REPEAT
*
LINE.CODES = "12"
*
LINE.CODE = CHAR(27):"[":LINE.CODES<1,RSP>:"z"
* PAGE.CODE = CHAR(27):"[7920r"
*
PRINTER ON
PRINT LINE.CODE
PRINTER OFF
*
PRINT @(20,23):CLL:"Set to lines ":RSP:" - hit <cr> to end   ":
INPUT RSP:
END
~DELETE.ITEM~
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN "DICT","SCR" TO SCR.DICT ELSE STOP
ID = "111":VM:"0":VM:"111":VM:"1":VM:VM:"IBP"
READ TEMP FROM SCR.DICT,ID ELSE
PRINT BELL:
STOP
END
DELETE SCR.DICT,ID
STOP
END
~DISPLAY.FILES~
*PROGRAM: SH.DISPLAY.FILES 
* AUTHOR:            XXX
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      17 AUG 88
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "LISTS" TO LST.FILE ELSE TEXT = "Can't open LISTS"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(1)
VALID.REFS = "FI"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
LST.ID = ""; GOSUB GET.KEY; IF LST.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(LST.FILE,"LST",LST.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ LST FROM LST.FILE,LST.ID THEN NEW = "" ELSE NEW = 1; LST = ""
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = LST.ID; LST.ID = "!":LST.ID; GOSUB GET.KEY; LST.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
TEXT = "Not on file"; GOSUB ERROR; GOTO UNLOCK
END
!
CHANGES: *
PRINT CLB:"Enter CHange, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = LST.ID; LST.ID = "!":LST.ID; GOSUB GET.KEY; LST.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE LST ON LST.FILE,LST.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(LST.FILE,"LST",LST.ID,LCK.FILE)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                            System File Definitions                             ":RVE:
PRINT @(0,4):"                              ":RVB:"Dict Leve":RVB:"Data Level       ":RVE:
PRINT @(0,5):RVB:"FI> File Name  ":RVE:"   ":RVB:"Account   ":RVE:"  ":RVB:"# items ":RVE:" ":RVB:"Modulo  ":RVE:" ":RVB:"# items ":RVE:" ":RVB:"Modulo  ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = ""; GOSUB D01; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
PRINT @(0,3):
PRINT
PRINT "Enter Application: ":; INPUT TMP:
IF TMP EQ EMPTY THEN
LST.ID = "FILES"
END ELSE
LST.ID = TMP:"@FILES"
END
RETURN
!
GET.DATA: *
ON REF GOSUB I01
RETURN
!
I01:  PRINT CLB:"Enter File.name: ":
FLD = ""; CALL INPUT.DATA(FLD,17,23,"L15",1,"","SE":VM:"OP","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I01
IF FLD = "" THEN RETURN
LOCATE FLD IN LST<1> BY "AR" SETTING VC THEN
PRINT CLB:FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL LST<1,VC>
DEL LST<2,VC>
DEL LST<3,VC>
DEL LST<8,VC>
DEL LST<4,VC>
DEL LST<9,VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
DYNAMIC = "D"; GOSUB D01; IF STAT = 999 THEN RETURN
GOTO I01
END
END ELSE
IF LST<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I01
END
INS FLD BEFORE LST<1,VC>
INS "" BEFORE LST<2,VC>
INS "" BEFORE LST<3,VC>
INS "" BEFORE LST<8,VC>
INS "" BEFORE LST<4,VC>
INS "" BEFORE LST<9,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB D01; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,15)+6
FOR SUB.REF = 1 TO 5
ON SUB.REF GOSUB I01B,I01C,I01D,I01E,I01F
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 6
NEXT SUB.REF
GOTO I01
I01A: CALL INPUT.DATA(LST,0,LN,"L15",1:",":VC,"","","",RSP,STAT)
RETURN
I01B: CALL INPUT.DATA(LST,18,LN,"L10",2:",":VC,"","","",RSP,STAT)
RETURN
I01C: CALL INPUT.DATA(LST,30,LN,"L8",3:",":VC,"MR0ZM","OP":VM:"NU","",RSP,STAT)
RETURN
I01D: CALL INPUT.DATA(LST,39,LN,"L8",8:",":VC,"MR0ZM","OP":VM:"NU","",RSP,STAT)
RETURN
I01E: CALL INPUT.DATA(LST,48,LN,"L8",4:",":VC,"MR0ZM","OP":VM:"NU","",RSP,STAT)
RETURN
I01F: CALL INPUT.DATA(LST,57,LN,"L8",9:",":VC,"MR0ZM","OP":VM:"NU","",RSP,STAT)
RETURN
D01: SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+14 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,15)+6; PRINT @(0,LN):LST<1,VC> "L#15":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,15); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 6 TO 20 UNTIL LST<1,VC> = ""
IF LN = 6 THEN TOP.LOC = VC
PRINT @(0,LN):LST<1,VC> "L#15":
PRINT @(18,LN):LST<2,VC> "L#10":
PRINT @(30,LN):OCONV(LST<3,VC>,"MR0ZM") "L#8":
PRINT @(39,LN):OCONV(LST<8,VC>,"MR0ZM") "L#8":
PRINT @(48,LN):OCONV(LST<4,VC>,"MR0ZM") "L#8":
PRINT @(57,LN):OCONV(LST<9,VC>,"MR0ZM") "L#8":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR LST<1,VC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 6; GOSUB C01 REPEAT
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
C01: FOR LN = LN TO 20
PRINT @(0,LN):SPACE(15):
PRINT @(18,LN):SPACE(10):
PRINT @(30,LN):SPACE(8):
PRINT @(39,LN):SPACE(8):
PRINT @(48,LN):SPACE(8):
PRINT @(57,LN):SPACE(8):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~DOS.TO.ULT~
*PROGRAM: DOS.TO.ULT 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       RECEIVES DATA FROM MS-DOS SYSTEM
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT
PRINT "DOS.TO.ULT - Receives data from MS-DOS system"
PRINT "To which file? ":
INPUT FL.NAME
IF FL.NAME[1,4] = "ULT." THEN FL.NAME = FL.NAME[5,99]
DICT.NAME = ""
IF FL.NAME[1,5] = "DICT " OR FL.NAME[1,5] = "DICT." THEN
DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
END
DISP.NAME = TRIM(DICT.NAME:" ":FL.NAME)
OPEN DICT.NAME,FL.NAME ELSE PRINT "No such file"; STOP
PRINT
PRINT "If using CROSSTALK, hit ESC then enter 'SE REVULT' to start file transfer"
PRINT
DIM ITEM(1000); MAT ITEM = ""; ID = ""; AC = ""; LAST = ""; COMBINE.NEXT = ""; USING.CSUM = ""
ECHO OFF
!
LOOP
COMBINE = COMBINE.NEXT
INPUT LINE:; IF LEN(LINE) = 140 THEN COMBINE.NEXT = 1 ELSE COMBINE.NEXT = ""
LOOP IX = INDEX(LINE,"}",1) WHILE IX DO LINE = LINE[1,IX-1]:VM:LINE[IX+1,999] REPEAT
LOOP IX = INDEX(LINE,"|",1) WHILE IX DO LINE = LINE[1,IX-1]:SVM:LINE[IX+1,999] REPEAT
IF LINE = "$$$" THEN
IF LAST THEN LAST = 2 ELSE
LAST = 1
GOSUB STORE.LINE
MATWRITE ITEM ON ID
PRINT
MAT ITEM = ""; ID = ""; AC = ""
END
END ELSE
LAST = ""
IF ID = "" THEN
IF USING.CSUM = "" THEN IF LINE[1,3] MATCHES "3N" THEN USING.CSUM = 1 ELSE USING.CSUM = 0
VLINE = LINE; GOSUB VALIDATE.LINE; ID = VLINE
PRINT ID
END ELSE
IF COMBINE THEN ITEM(AC) = ITEM(AC):LINE ELSE
GOSUB STORE.LINE
AC = AC+1
ITEM(AC) = LINE
END
END
END
PRINT "*":
WHILE LAST < 2 DO REPEAT
ECHO ON
STOP
!
STORE.LINE: *
IF AC THEN
VLINE = ITEM(AC)
GOSUB VALIDATE.LINE
ITEM(AC) = VLINE
END
RETURN
!
VALIDATE.LINE: *
IF NOT(USING.CSUM) THEN RETURN
REQD.CSUM = VLINE[1,3]; VLINE = VLINE[4,999]
CSUM = 0; POS = 1; MULT = 5
LOOP CHR = VLINE[POS,1] UNTIL CHR = "" DO
CSUM = (CSUM+(SEQ(CHR)*MULT)+10000)[3,3]
POS = POS+1; MULT = MULT-1; IF MULT = 0 THEN MULT = 5
REPEAT
* CSUM = LEN(VLINE)
IF CSUM # REQD.CSUM THEN VLINE = "###ERROR### ":VLINE
RETURN
END
~DOWNLOADER~
*PROGRAM: DOWNLOADER 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       TRANSMITS DATA FROM ULTIMATE TO OTHER MACHINE
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
PROMPT ""; AM = CHAR(254)
PRINT "DOWNLOADER - Transmits data to you"
!
NEXT.FILE: *
PRINT "Enter file name: ":
INPUT FILE.NAME:; IF FILE.NAME = "" THEN STOP
PRINT
OPEN FILE.NAME ELSE PRINT "Can't open ":FILE.NAME; GOTO NEXT.FILE
!
NEXT.ITEM: *
PRINT "Enter item name: ":
INPUT ITEM.NAME:; IF ITEM.NAME = "" THEN GOTO NEXT.FILE
READ ITEM FROM ITEM.NAME ELSE PRINT "Can't read ":FILE.NAME:" ":ITEM.NAME; GOTO NEXT.ITEM
MAX.AC = COUNT(ITEM,AM)+1
PRINT
*
PRINT
PRINT "Ready to send ":FILE.NAME:" ":ITEM.NAME:" (":MAX.AC:" lines)"
AC = 0
ECHO OFF
*
LOOP
INPUT RSP:
BEGIN CASE
CASE RSP = "+"; AC = AC+1; IF AC <= MAX.AC THEN GOSUB SEND.LINE
CASE RSP = "-"; IF AC > 0 THEN GOSUB SEND.LINE
CASE RSP = "="; AC = MAX.AC+1
END CASE
UNTIL AC > MAX.AC DO REPEAT
PRINT "="
*
ECHO ON
PRINT "Dump of ":FILE.NAME:" ":ITEM.NAME:" complete"
STOP
!
SEND.LINE: *
LINE = ITEM<AC>
CSUM = 0; POS = 1; MULT = 5
LOOP CHR = LINE[POS,1] UNTIL CHR = "" DO
CSUM = CSUM+(SEQ(CHR)*MULT)
POS = POS+1; MULT = MULT-1; IF MULT = 0 THEN MULT = 5
REPEAT
CSUM = (CSUM+1000000)[5,3]
PRINT CSUM:LINE
RETURN
END
~ECHO.ON~
*PROGRAM: ECHO.ON
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
ECHO ON
*
END
~ELAPSED.SUBR.CONV~
SUBROUTINE ELAPSED.SUBR.CONV(START.DT,START.TM,END.DT,END.TM,RSLT,ORSLT)
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP ELAPSED.INCL.CONV
*
RETURN
*
END
~EQUATE.DICTS~
*PROGRAM: EQUATE.DICTS 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       GENERATES DICTIONARY ITEM EQUATES TO 'BP' FILE,
*                    ALLOWING USE OF $INCLUDE STATEMENT.
*                    ALSO GENERATES DICT ITEM USING DICT.NAME AS ID
*                    ID OF 'IBP' ITEM IS file.name:".EQUATES"
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "CNT" TO CNT.FILE ELSE STOP
OPEN "PAR" TO PAR.FILE ELSE STOP
OPEN "LISTS" TO LST.FILE ELSE STOP
OPEN "MD" TO MD.FILE ELSE STOP
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",ONE ELSE CO.NAME = EMPTY
*
CO.NAME = CO.NAME<ONE,ONE,ONE>
TITLE = "Equate.dicts - Generate dictionary equates"
PRINT @(ZERO,ZERO):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(ZERO,ONE):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
*
* LOOP
PRINT @(10,4):CLL:"Enter file name or A(ll): ":
INPUT RSP:; IF RSP EQ EMPTY OR RSP EQ "KILL" THEN STOP
* IF RSP EQ "A" THEN DUMMY = "Q" ELSE READ DUMMY FROM MD.FILE,RSP ELSE DUMMY = EMPTY
* DUMMY = DUMMY[ONE,ONE]
* UNTIL DUMMY EQ "D" OR DUMMY EQ "Q" DO PRINT BELL: REPEAT
*
FILE.NAME = RSP
*
LOOP
PRINT @(10,6):CLL:"Enter <cr> for any, P(rimary only), or M(ultiple types): ":
INPUT RSP:; IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ EMPTY OR RSP EQ "M" OR RSP EQ "P" DO PRINT BELL: REPEAT
*
RECORD.FLAG = RSP
*
*
IF FILE.NAME NE "A" OR (RECORD.FLAG EQ "M" OR RECORD.FLAG EQ "P") THEN FILE.NAMES = FILE.NAME ELSE
EXECUTE 'SSELECT MD WITH *A1 "D" OR *A1 "Q"', //SELECT. > FILE.ID.LIST
FILE.NAMES = EMPTY
LOOP READNEXT FILE.NAME FROM FILE.ID.LIST ELSE FILE.NAME = EMPTY UNTIL FILE.NAME = EMPTY DO FILE.NAMES<-ONE> = FILE.NAME REPEAT
END
*
*
RECORD.FLAG = RSP
*
*
OPEN "IBP" TO IBP.FILE ELSE STOP
READV COMMON.AREA FROM IBP.FILE,"GENERAL.COMMON.AREA",ONE ELSE COMMON.AREA = EMPTY
!
NEXT.FILE: *
*
FILE.NAME = FILE.NAMES<ONE>
IF FILE.NAME EQ EMPTY THEN STOP
*
DEL FILE.NAMES<ONE>
PRINT @(27,11):CLL:"File: ":FILE.NAME
*
TRUE.FILE.NAME = FILE.NAME
BASE.FILE.NAME = FIELD(FILE.NAME,".",ONE)
RECORD.TYPE = FIELD(FILE.NAME,".",TWO)
IF (RECORD.FLAG EQ "M" OR RECORD.FLAG EQ "P") THEN
OPEN "DICT",BASE.FILE.NAME TO DICT.FILE ELSE GOTO NEXT.FILE
END ELSE
OPEN "DICT",TRUE.FILE.NAME TO DICT.FILE ELSE GOTO NEXT.FILE
END
*
READ FILE.DESC FROM PAR.FILE,FILE.NAME:"@FILE@DESC" ELSE FILE.DESC = EMPTY
*
IF INDEX(COMMON.AREA,"SAVE.":FILE.NAME,ONE) THEN SAVE.VERSION = ONE ELSE SAVE.VERSION = ZERO
*
IF (RECORD.FLAG EQ "M" OR RECORD.FLAG EQ "P") THEN
EXECUTE 'SSELECT DICT ':BASE.FILE.NAME:' EQ "':RECORD.TYPE:']" BY NUM.ORDER', //SELECT. > ITEM.ID.LIST
END ELSE
EXECUTE 'SSELECT DICT ':FILE.NAME:' BY NUM.ORDER', //SELECT. > ITEM.ID.LIST
END
*
IBP.ITEM = EMPTY
IBP.VAR.ITEM = EMPTY
*
SAVE.IBP.ITEM = EMPTY
SAVE.IBP.VAR.ITEM = EMPTY
*
MAX.AC = EMPTY
ID.ALL = EMPTY; ID.NUM = EMPTY
LINE.LEN = 40
LINE.LEN.V = 40
SAVE.LINE.LEN = 40
SAVE.LINE.LEN.V = 40
!
GENERATE: *
*
READNEXT ID FROM ITEM.ID.LIST ELSE
*
IF MAX.AC THEN
ADJ = MOD(MAX.AC,5); IF ADJ THEN MAX.AC = MAX.AC + 5 - ADJ
LINE = FILE.NAME:"("
OCC = ONE
*
LOOP POS = INDEX(COMMON.AREA,LINE,OCC) WHILE POS DO
POS = POS + LEN(FILE.NAME)
END.POS = POS + ONE
LOOP UNTIL COMMON.AREA[END.POS,ONE] EQ ")" DO END.POS = END.POS + ONE REPEAT
COMMON.AREA = COMMON.AREA[ONE,POS]:MAX.AC:COMMON.AREA[END.POS,999]
OCC = OCC + ONE
REPEAT
*
IF OCC GT ONE THEN WRITEV COMMON.AREA ON IBP.FILE,"GENERAL.COMMON.AREA",ONE
LINE = "DIM ":LINE:MAX.AC:")"
LINE = "*CODE.SEGMENT: ":FILE.NAME:".DIM":AM:"*":AM:LINE
WRITE LINE ON IBP.FILE,FILE.NAME:".DIM"
*
IF SAVE.VERSION THEN
LINE = "DIM SAVE.":FILE.NAME:"(":MAX.AC:")"
LINE = "*CODE.SEGMENT: SAVE.":FILE.NAME:".DIM":AM:"*":AM:LINE
WRITE LINE ON IBP.FILE,"SAVE.":FILE.NAME:".DIM"
END
*
IF LEN(ID.ALL) THEN
WRITE ID.NUM ON LST.FILE,FILE.NAME:"@DICT@LIST@NUM"
WRITE ID.ALL ON LST.FILE,FILE.NAME:"@DICT@LIST"
END
*
END; * of MAX.AC
*
FOR TEMP = ONE TO 2
*
IF TEMP EQ ONE THEN TEMP1 = "" ELSE TEMP1 = ".VAR"
LINE = "*CODE.SEGMENT: ":FILE.NAME:TEMP1:".EQUATES"
LINE<-ONE> = "*"
LINE<-ONE> = "* FILE '":FILE.NAME:"' EQUATES - GENERATED ":TIMEDATE()
*
IF FILE.DESC NE EMPTY THEN
LINE<-ONE> = "*"
TEMP2 = DCOUNT(FILE.DESC,AM)
FOR TEMP3 = ONE TO TEMP2
LINE<-ONE> = "*  ":FILE.DESC<TEMP3>
NEXT TEMP2
LINE<-ONE> = "*"
LINE<-ONE> = "*"
END
*
IF TEMP EQ ONE THEN
INS LINE BEFORE IBP.ITEM<ONE>
WRITE IBP.ITEM ON IBP.FILE,FILE.NAME:".EQUATES"
END ELSE
*
INS LINE BEFORE IBP.VAR.ITEM<ONE>
WRITE IBP.VAR.ITEM ON IBP.FILE,FILE.NAME:".VAR.EQUATES"
END
*
NEXT TEMP
*
*
IF SAVE.VERSION THEN
LINE = "* FILE 'SAVE.":FILE.NAME:"' EQUATES - GENERATED ":TIMEDATE()
INS LINE BEFORE SAVE.IBP.ITEM<ONE>
LINE = "* FILE 'SAVE.":FILE.NAME:"' EQUATES (VARiables) - GENERATED ":TIMEDATE()
INS LINE BEFORE SAVE.IBP.VAR.ITEM<ONE>
WRITE SAVE.IBP.ITEM ON IBP.FILE,"SAVE.":FILE.NAME:".EQUATES"
WRITE SAVE.IBP.VAR.ITEM ON IBP.FILE,"SAVE.":FILE.NAME:".VAR.EQUATES"
END
*
GOTO NEXT.FILE
*
END; * of list of dict items
*
!
*
PROCESS.NEXT.ITEM: *
*
READ ITEM FROM DICT.FILE,ID ELSE
PRINT @(27,15):CLL:RVB:"End Of List":RVE:" ":
GOTO GENERATE
END
*
PRINT @(27,13):CLL:"Item: ":ID:" ":
*
IF ITEM<ONE>[ONE,ONE] EQ "D" OR ITEM<ONE>[ONE,ONE] EQ "Q" THEN
PRINT @(27,14):CLL:RVB:"File Pointer":RVE:" ":
GOTO GENERATE
END
*
IF ITEM<ONE> EQ "S" OR ITEM<ONE> EQ "X" THEN 
PRINT @(27,14):CLL:RVB:"Dict Pointer Skip":RVE:" ":
GOTO GENERATE
END
*
!
*
IF RECORD.FLAG EQ "P" THEN
*
IF NOT(NUM(ID)) THEN
PRINT @(27,14):CLL:RVB:"Pr. NOT numeric":RVE:" ":
GOTO GENERATE
END
IF ID LT ZERO THEN  
PRINT @(27,14):CLL:RVB:"Pr. LT ZERO":RVE:" ":
GOTO GENERATE
END
PRINT @(27,14):CLL:"Pr. OK. ":
*
END ELSE IF RECORD.FLAG EQ "M" THEN
*
IF NOT(ID MATCHES "'":RECORD.TYPE:".'0N") THEN
PRINT @(27,14):CLL:RVB:"Se. NOT ":RECORD.TYPE:RVE:" ":
GOTO GENERATE
END
PRINT @(27,14):CLL:"Se. OK. ":
*
ID.ATTR = FIELD(ID,".",TWO)
*
*
END ELSE
*
IF NOT(ID MATCHES "0N") THEN
GOTO GENERATE
END
*
ID.ATTR = ID
*
*
END; * of 'P', 'M', or any
*
!
*
PROCESS.VALID.ITEM: *
*
IF ITEM<19> NE EMPTY THEN
IF ITEM<19> NE "none" THEN DICT.NAME = ITEM<19> ELSE GOTO GENERATE
END ELSE
DICT.NAME = ITEM<3>
IF DICT.NAME NE EMPTY THEN
ITEM<19> = DICT.NAME
WRITE ITEM ON DICT.FILE,ID
END
END
*
DESCRIP = ITEM<11>
* DESCRIP = ITEM<11>; IF DESCRIP NE EMPTY THEN ITEM<3> = DESCRIP
*
IF ID NE DICT.NAME THEN IF ID NE BASE.FILE.NAME THEN
* IF DESCRIP NE DICT.NAME THEN IF BASE.FILE.NAME NE DICT.NAME THEN WRITE ITEM ON DICT.FILE,DICT.NAME
IF BASE.FILE.NAME NE DICT.NAME THEN WRITE ITEM ON DICT.FILE,DICT.NAME
END
*
ID.ALL<-ONE> = ID
*
IF RECORD.FLAG EQ "M" THEN
IF NOT(ID MATCHES "'":RECORD.TYPE:".'0N") THEN GOTO GENERATE
ID.ATTR = FIELD(ID,".",TWO)
END ELSE
IF NOT(ID MATCHES "0N") THEN GOTO GENERATE
ID.ATTR = ID
END
*
ID.NUM<-ONE> = ID
*
IF ID.ATTR LT ONE THEN GOTO GENERATE
*
*
TMP = "EQU ":FILE.NAME:"$":DICT.NAME:" TO ":FILE.NAME:"(":ID.ATTR:");"
LOOP WHILE LEN(TMP) GT LINE.LEN DO
LINE.LEN = LINE.LEN + 5
REPEAT
TMP1 = "L#":LINE.LEN
IBP.ITEM<-ONE> = TMP TMP1:"* ":DESCRIP[ONE,80]
*
TMP = "EQU ":FILE.NAME:"$":DICT.NAME:" TO ":ID.ATTR:";"
LOOP WHILE LEN(TMP) GT LINE.LEN.V DO
LINE.LEN.V = LINE.LEN.V + 5
REPEAT
TMP1 = "L#":LINE.LEN.V
IBP.VAR.ITEM<-ONE> = TMP TMP1:"* ":DESCRIP[ONE,80]
*
IF SAVE.VERSION THEN
*
TMP = "EQU ":"SAVE.":FILE.NAME:"$":DICT.NAME:" TO ":"SAVE.":FILE.NAME:"(":ID.ATTR:");"
LOOP WHILE LEN(TMP) GT SAVE.LINE.LEN DO
SAVE.LINE.LEN = SAVE.LINE.LEN + 5
REPEAT
TMP1 = "L#":SAVE.LINE.LEN
SAVE.IBP.ITEM<-ONE> = TMP TMP1:"* ":DESCRIP[ONE,80]
*
TMP = "EQU ":"SAVE.":FILE.NAME:"$":DICT.NAME:" TO ":ID.ATTR:";"
LOOP WHILE LEN(TMP) GT SAVE.LINE.LEN.V DO
SAVE.LINE.LEN.V = SAVE.LINE.LEN.V + 5
REPEAT
TMP1 = "L#":SAVE.LINE.LEN.V
SAVE.IBP.VAR.ITEM<-ONE> = TMP TMP1:"* ":DESCRIP[ONE,80]
*
END
*
IF MAX.AC LT ID.ATTR THEN MAX.AC = ID.ATTR
*
GOTO GENERATE
*
END
~EXEC.SUBR.OUT.PARSE~
SUBROUTINE EXEC.SUBR.OUT.PARSE(EXEC.OUTPUT,PAR.FILE,ITEM.CN,DISP,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP PAR.SERR.DIM
$INCLUDE IBP PAR.SERR.EQUATES
*
*
MATREAD PAR.SERR FROM PAR.FILE,"SYSTEM.ERRORS.":OPSYS ELSE
MATREAD PAR.SERR FROM PAR.FILE,"SYSTEM.ERRORS" ELSE
MAT PAR.SERR = EMPTY
BEGIN CASE
CASE OPSYS EQ "U"
PAR.SERR$EXTERN.TEXT = "items selected.":VM:"No items present."
CASE TRUE
PAR.SERR$EXTERN.TEXT = "items selected.":VM:"No items present."
END CASE
END
END
*
EXEC.TEXT = EXEC.OUTPUT
*
LOOP WHILE LEN(EXEC.TEXT) DO
*
LINE = EXEC.TEXT<ONE>
LOOP WHILE LINE[ONE,ONE] EQ " " DO LINE = LINE[TWO,9999] REPEAT
IF DISP EQ TWO THEN PRINTER ON
IF DISP THEN PRINT LINE
IF DISP EQ TWO THEN PRINTER OFF
DEL EXEC.TEXT<ONE>
*
IF LINE NE EMPTY THEN
*
EXTERN.STAT = FIELD(LINE," ",ONE)
IF NOT(NUM(EXTERN.STAT)) AND INDEX(EXTERN.STAT,"]",ONE) THEN
EXTERN.STAT = FIELD(EXTERN.STAT,"[",TWO)
EXTERN.STAT = FIELD(EXTERN.STAT,"]",ONE)
END
IF NUM(EXTERN.STAT) THEN
EXTERN.TEXT = LINE[COL2()+ONE,9999]
END ELSE EXTERN.TEXT = LINE; EXTERN.STAT = FALSE
*
LOCATE EXTERN.TEXT IN PAR.SERR$EXTERN.TEXT<ONE> SETTING SERR.LOC ELSE SERR.LOC = ZERO
IF NOT(SERR.LOC) AND EXTERN.STAT THEN
LOCATE EXTERN.STAT IN PAR.SERR$EXTERN.ERR<ONE> SETTING SERR.LOC ELSE SERR.LOC = ZERO
END
*
IF SERR.LOC THEN
BEGIN CASE
CASE PAR.SERR$INTERN.ERR<ONE,SERR.LOC> EQ 404
ITEM.CN = EXTERN.STAT
EXTERN.STAT = FALSE
CASE PAR.SERR$INTERN.ERR<ONE,SERR.LOC> EQ 401
ITEM.CN = ZERO
STAT = EXTERN.STAT
END CASE
END
*
END; * of line not empty
*
REPEAT
*
RETURN
*
END
~FF~
*PROGRAM: FF 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
START: *
PRINTER ON
PRINT FF:
PRINTER OFF
*
END
~FILE.SAVE~
*PROGRAM: FILE.SAVE 
*
CHAIN "AXION-FILESAVE"
*
END
~FIND.BIG~
*PROGRAM: COUNT.DATAS 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT
PRINT "ENTER FILE NAME: ":
INPUT FILE.NAME
*
IF FILE.NAME EQ "KILL" OR FILE.NAME EQ "" THEN STOP
*
PRINT
PRINT "ENTER SIZE TO FIND: "
INPUT SIZE.TO.FIND
*
IF NOT(NUM(SIZE.TO.FIND)) THEN STOP
*
CN = 1
TOT.CN = 0
TOT.SIZE = 0
ISIZE = 0
ICOUNT = 0
OPEN FILE.NAME TO INP.FILE THEN
SELECT INP.FILE TO INP.ID.LIST
PRINT CN "R#3":") ":FILE.NAME "L#15":ICOUNT "R#5":ISIZE "R#10"
LOOP
READNEXT INP.ID FROM INP.ID.LIST ELSE INP.ID = "@"
WHILE INP.ID NE "@" DO
READ INP.ITEM FROM INP.FILE,INP.ID ELSE INP.ITEM = ""
ISIZE = LEN(INP.ITEM)
IF ISIZE GE SIZE.TO.FIND THEN
PRINT TOT.CN "R#5":") ":FILE.NAME:" ":INP.ID:" ":ISIZE "L#5"
END
TOT.SIZE = TOT.SIZE + ISIZE
TOT.CN = TOT.CN + 1
REPEAT
ICOUNT = TOT.CN
IF TOT.CN NE 0 THEN ISIZE = TOT.SIZE/TOT.CN ELSE ISIZE = 0
END ELSE NULL; * OF OPEN
PRINT CN "R#3":") ":FILE.NAME "L#15":ICOUNT "R#5":ISIZE "R#10"
END
END
~FIND.MISSING.ACTS~
*PROGRAM:           FIND.MISSING.ACTS
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       FINDS ACCOUNTS ON ACX OR ADD BUT NOT ON ACT
*
* DATE WRITTEN:      28 JUL 86
* DATE RELEASED:     28 JUL 86
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP STT.DIM
$INCLUDE IBP STT.EQUATES
$INCLUDE IBP ACX.DIM
$INCLUDE IBP ACX.EQUATES
*
OPEN "ACT" TO ACT.FILE ELSE PRINT "Can't open file ACT"; INPUT RSP; STOP
OPEN "ACX" TO ACX.FILE ELSE PRINT "Can't open file ACX"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT "Can't open file ADD"; INPUT RSP; STOP
OPEN "STT" TO STT.FILE ELSE PRINT "Can't open file STT"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Find missing accounts"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
INPUT AUTO.RUN
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("FIND.MISSING.ACTS","","Missing Accts")
!
PRINT @(20,10):CLL:"Selecting name index...":
EXECUTE "SSELECT ACX "
PRINT @(20,10):CLL:"Reading by name index...":
PRINT @(0,11):CLL:
PRINT @(0,12):CLL:
PRINT @(0,13):CLL:
*
ACT.IDS = ""
LOOP
READNEXT ACX.ID ELSE ACX.ID = ""
UNTIL ACX.ID = "" DO
MATREAD ACX FROM ACX.FILE,ACX.ID THEN
PRINT @(20,14):CLL:"Names starting with ":ACX.ID:
VC = 1
LOOP
ACT.ID = ACX$ACT.IDS<1,VC>
UNTIL ACT.ID = "" DO
READV ACT.STAT FROM ACT.FILE,ACT.ID,2 ELSE
NAMAC = 3
LOCATE ACT.ID IN ACT.IDS<1> BY "AR" SETTING ERRVC ELSE
INS ACT.ID BEFORE ACT.IDS<1,ERRVC>
INS "" BEFORE ACT.IDS<2,ERRVC>
INS "" BEFORE ACT.IDS<3,ERRVC>
INS "" BEFORE ACT.IDS<4,ERRVC>
INS "" BEFORE ACT.IDS<5,ERRVC>
NAMAC = 2
END
ACT.IDS<1,ERRVC> = ACT.ID
ACT.IDS<NAMAC,ERRVC> = ACX.ID:ACX$SCAN.NAMES<1,VC>
ACT.IDS<5,ERRVC> = "Account missing"
DEL ACX$ACT.IDS<1,VC>
DEL ACX$SCAN.NAMES<1,VC>
VC = VC-1
MATWRITE ACX ON ACX.FILE,ACX.ID
END
VC = VC+1
REPEAT
END
REPEAT
!
PRINT @(0,11):CLL:
PRINT @(0,12):CLL:
PRINT @(0,13):CLL:
PRINT @(0,14):CLL:
PRINT @(20,10):CLL:"Selecting addresses...":
EXECUTE "SSELECT ADD BY STREET.NUM BY HOUSE.NUM BY APT.NUM"
PRINT @(0,11):CLL:
PRINT @(0,12):CLL:
PRINT @(0,13):CLL:
PRINT @(0,14):CLL:
PRINT @(20,10):CLL:"Reading by address...":
*
PREV.STT.ID = ""
LOOP
READNEXT ADD.ID ELSE ADD.ID = ""
UNTIL ADD.ID = "" DO
STT.ID = FIELD(ADD.ID,"*",3)
IF STT.ID # PREV.STT.ID THEN
PREV.STT.ID = STT.ID
MATREAD STT FROM STT.FILE,STT.ID ELSE MAT STT = ""
PRINT @(20,14):CLL:STT.ID:". ":STT$CITY.NUM:",":STT$NAME:
END
MATREAD ADD FROM ADD.FILE, ADD.ID THEN
NUM.ACTIVES = 0; VC = 1
LOOP ACT.ID = ADD$ACT.IDS<1,VC> UNTIL ACT.ID = "" DO
ERROR.MESSAGE = "Account not on file"
READV ACT.STAT FROM ACT.FILE,ACT.ID,2 THEN
ERROR.MESSAGE = ""
IF ACT.STAT = "A" THEN
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = ""
IF ACT$ADD.ID = ADD.ID THEN
HOT.OUTLETS = 1
LOCATE "(BASIC)" IN ACT$SERVICES<1> SETTING LOC THEN HOT.OUTLETS = ACT$QNTYS<1,LOC>
IF HOT.OUTLETS # ADD$HOT.OUTLETS THEN
ERROR.MESSAGE<1,1,-1> = "Hot outlets: ":ADD$HOT.OUTLETS
ADD$HOT.OUTLETS = HOT.OUTLETS
IF HOT.OUTLETS > ADD$WIRED.OUTLETS THEN ADD$WIRED.OUTLETS = HOT.OUTLETS
END
IF ADD$STAT # "H" THEN ADD$STAT = "H"; ERROR.MESSAGE<1,1,-1> = "Address not hot"
IF ADD$ACT.TO.DATES<1,VC> # "" THEN ERROR.MESSAGE<1,1,-1> = "Disc date removed"; ADD$ACT.TO.DATES<1,VC> = ""
TMP = 1
LOOP UNTIL ADD$ACT.IDS<1,TMP> = "" DO
IF TMP # VC AND ADD$ACT.IDS<1,TMP> = ACT.ID THEN
ERROR.MESSAGE<1,1,-1> = "Dupl acct pointer"
DEL ADD$ACT.IDS<1,VC>
DEL ADD$ACT.FROM.DATES<1,VC>
DEL ADD$ACT.TO.DATES<1,VC>
VC = VC-1
NUM.ACTIVES = NUM.ACTIVES-1
TMP = 999
END
TMP = TMP+1
REPEAT
NUM.ACTIVES = NUM.ACTIVES+1
IF NUM.ACTIVES > 1 THEN ERROR.MESSAGE<1,1,-1> = "Active account # ":NUM.ACTIVES
END
END
END
IF ERROR.MESSAGE = "Account not on file" THEN
DEL ADD$ACT.IDS<1,VC>
DEL ADD$ACT.FROM.DATES<1,VC>
DEL ADD$ACT.TO.DATES<1,VC>
VC = VC-1
MATWRITE ADD ON ADD.FILE,ADD.ID
ERROR.MESSAGE = ""
END
IF ERROR.MESSAGE # "" THEN
LOCATE ACT.ID IN ACT.IDS<1> BY "AR" SETTING ERRVC ELSE
INS ACT.ID BEFORE ACT.IDS<1,ERRVC>
INS "" BEFORE ACT.IDS<2,ERRVC>
INS "" BEFORE ACT.IDS<3,ERRVC>
INS "" BEFORE ACT.IDS<4,ERRVC>
INS "" BEFORE ACT.IDS<5,ERRVC>
END
ADDR = TRIM(FIELD(ADD.ID,"*",1):"-":FIELD(ADD.ID,"*",2):" ":STT$NAME:", ":STT$CITY.NUM)
IF ADDR[1,1] = "-" THEN ADDR = ADDR[2,99]
ACT.IDS<4,ERRVC> = ADDR
ACT.IDS<5,ERRVC> = ERROR.MESSAGE
MATWRITE ADD ON ADD.FILE,ADD.ID
END
VC = VC+1
REPEAT
END
REPEAT
!
WRITE ACT.IDS ON CNT.FILE,"MISSING.ACT.IDS"
EXECUTE 'LIST CNT "MISSING.ACT.IDS" ACT.ID NAME ALT.NAME ADDR ERROR.MESSAGE ID-SUPP (P)'
STOP
!
END
~FIX.DUPL.XTR~
*PROGRAM: FIX.DUPL.XTR
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1993              ALL RIGHTS RESERVED
*  
* DESCRIPTION:     REMOVE DUPLICATES AND OPTIONALLY REVERSE THE ENTRIES
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
$INCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
$INCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*
OPEN "ACT" TO ACT.FILE ELSE PRINT "Can't open file ACT"; INPUT RSP; STOP
IF OPSYS NE "R" THEN OPEN "AAX" TO AAX.FILE ELSE PRINT "Can't open file AAX"; INPUT RSP; STOP
OPEN "ACG" TO ACG.FILE ELSE PRINT "Can't open file ACG"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT "Can't open file ADD"; INPUT RSP; STOP
OPEN "ATR" TO ATR.FILE ELSE PRINT "Can't open file ATR"; INPUT RSP; STOP
OPEN "EFT" TO EFT.FILE ELSE PRINT "Can't open file EFT"; INPUT RSP; STOP
OPEN "CAJ" TO CAJ.FILE ELSE PRINT "Can't open file CAJ"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
* LCK.FILE = 0; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
READ SYS.TST FROM CNT.FILE,"FIX.XTR.TEST" ELSE SYS.TST = ""
$INCLUDE IBP SYSTEM.TEST
*
STAT = FALSE
MAX.DESC = ONE; DESC.LEN = 5; INPUT.DESC = "N"
BELL.CN = ZERO; LIST.ALL = FALSE
RUN.TYPE = ZERO
RUN.TYPE.CURR = ONE
ENTRY.TYPE = 1
*
!
*
$INCLUDE IBP CASH.INCL.OR.ADJ.INIT
*
!
*
START: *
*
* $INCLUDE IBP CASH.INCL.OR.ADJ.BG
*
BUS.DATE = EMPTY
EFF.DATE = EMPTY
POST.DATE = EMPTY
POST.TIME = EMPTY
OPERATOR = EMPTY
DEFAULT.TYPE = EMPTY
!
WHICH.BATCH: *
SOURCE = RUN.SOURCE
LC.SOURCE = RUN.LC.SOURCE
TRANS.CLASS = RUN.TRANS.CLASS
*
PRINT @(0,10):CLL:"Enter the List Name to be processed: ":
INPUT LIST.NAME:; IF LIST.NAME EQ "KILL" OR LIST.NAME = "" THEN STOP
PRINT @(0,12):CLL:"Do you want to reverse the amounts (N/<cr>)?: ":
INPUT REVERSAL:
IF REVERSAL = "N" THEN REVERSAL = 0 ELSE REVERSAL = 1
*
EXLN = "GET-LIST ":LIST.NAME
EXECUTE EXLN, //SELECT. > BATCH.ID.LIST
PRINT @(0,16):CLL:"Enter 'KILL' or <cr> to proceed: ":;
INPUT RSP:
IF RSP = "KILL" THEN STOP
*
NEXT.BATCH: *
READNEXT BATCH.NUM FROM BATCH.ID.LIST ELSE GOTO FINISH
*
READ CAJ FROM CAJ.FILE,BATCH.NUM THEN
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
GOSUB EXTRACT.HEADER.DATA
POST.DATE = ""; POST.TIME = ""
CAJ.AM = 1
LOOP CAJ.DETAIL = CAJ<CAJ.AM> UNTIL CAJ.DETAIL = "" DO
NEXT.ACT.ID = CAJ<CAJ.AM+1,1>
ACT.ID = CAJ<CAJ.AM,1>
AMOUNT = CAJ<CAJ.AM,3>
IF REVERSAL THEN
AMOUNT = "-":AMOUNT
END
CAJ<CAJ.AM,3> = AMOUNT
BATCH.TOTAL = BATCH.TOTAL+AMOUNT
ENTERED.TOTAL = BATCH.TOTAL
PRINT @(5,19):CLL:ACT.ID:"    ":AMOUNT:
IF TEST.FL THEN
PRINT @(0,21):CLL:CAJ<CAJ.AM>:
PRINT CLB:"Enter <cr> to continue: ":; INPUT RSP:
END
IF ACT.ID = NEXT.ACT.ID THEN
DEL CAJ<CAJ.AM+1>; ITEM.COUNT = ITEM.COUNT-1
END
CAJ.AM = CAJ.AM+1
REPEAT
*
BATCH.STATUS = "B"; GOSUB UPDATE.FILE
GOTO NEXT.BATCH
*
END
*
*
*
*
*
*
IF RSP EQ "N" THEN NEW = ONE ELSE NEW = EMPTY
IF DOLLAR.EDIT EQ EMPTY THEN
LOOP
PRINT @(ZERO,22):CLL:"Do you prefer to key the decimal point (Y/N)? ":
INPUT DOLLAR.EDIT:; IF DOLLAR.EDIT EQ "KILL" THEN STOP
UNTIL DOLLAR.EDIT EQ "Y" OR DOLLAR.EDIT EQ "N" DO PRINT BELL: REPEAT
IF DOLLAR.EDIT EQ "N" THEN DOLLAR.EDIT = "NC" ELSE DOLLAR.EDIT = "ND"
END
IF NOT(NEW) THEN GOTO EXISTING.BATCH
!
NEW.BATCH: *
CAJ = EMPTY
BATCH.STATUS = "B"
ENTRY.DATE = CONTROL.DT
ENTRY.TIME = OCONV(TIME(),"MT")
BATCH.TOTAL = EMPTY
ENTERED.TOTAL = EMPTY
ADJUST.TOTAL = EMPTY
DEFAULT.TYPE = EMPTY
ITEM.COUNT = ZERO
*
* GOSUB GET.HEADER.DATA; IF STAT EQ 999 THEN GOTO START
IF DEFAULT.TYPE EQ EMPTY THEN GOTO WHICH.BATCH
*
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CNT.FILE,"CNT","CASH.BATCH.NUM",LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO START
WHILE LCK.STAT DO REPEAT
*
READ BATCH.NUM FROM CNT.FILE,"CASH.BATCH.NUM" ELSE BATCH.NUM = ONE
WRITE BATCH.NUM + ONE ON CNT.FILE,"CASH.BATCH.NUM"
CALL UNLOCK.ITEM(CNT.FILE,"CNT","CASH.BATCH.NUM",LCK.FILE)
*
BATCH.NUM = (BATCH.NUM + 100000)[TWO,5]
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO NEW.BATCH
WHILE LCK.STAT DO REPEAT
*
*
* GOSUB DISPLAY.HEADER.DATA
CURR.PG = ONE
* IF OPSYS EQ "U" THEN * GOSUB IMPRINT.HEADER; *CHEQUE IMPRINTER HEADER LINE..
* GOSUB ADD.TRANS
GOTO WHAT.NEXT
!
EXISTING.BATCH: *
BATCH.NUM = STR(ZERO,5 - LEN(RSP)):RSP
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO START
WHILE LCK.STAT DO REPEAT
READ CAJ FROM CAJ.FILE,BATCH.NUM ELSE PRINT BELL:; GOTO FINISH
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
* GOSUB EXTRACT.HEADER.DATA
IF BATCH.SOURCE NE SOURCE THEN PRINT BELL:; GOTO FINISH
IF STAT EQ 999 THEN GOTO FINISH
DEFAULT.TYPE = "!":DEFAULT.TYPE; * GOSUB GET.DEFAULT.TYPE
* GOSUB DISPLAY.HEADER.DATA
* GOSUB LIST.BATCH
IF STAT THEN GOTO FINISH
*
IF BATCH.STATUS NE "P" AND BATCH.STATUS NE "Z" THEN
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN BATCH.STATUS = EMPTY
* GOSUB CHECK.BALANCE
END ELSE
MSG = " ":ITEM.COUNT:" item"; IF ITEM.COUNT - ONE THEN MSG = MSG:"s"
MSG = MSG:" - Batch posted on ":OCONV(POST.DATE<ONE,ONE,ONE>,"D2"):" "
MSG = STR("*",40-LEN(MSG) / TWO):MSG:STR("*",40)
PRINT @(ZERO,23):RVB:MSG "L#79":RVE:
LOOP
PRINT @(ZERO,22):CLL:"Enter L(ist again), P(rint again), or <cr> to end: ":
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
* IF RSP EQ "L" THEN * GOSUB LIST.BATCH
* IF RSP EQ "P" THEN * GOSUB PRINT.BATCH; IF OPSYS NE "R" THEN PRINTER CLOSE
WHILE RSP EQ "L" OR RSP EQ "P" DO REPEAT
GOTO FINISH
END
* IF OPSYS EQ "U" THEN * GOSUB IMPRINT.HEADER; *CHEQUE IMPRINTER HEADER LINE..
!
WHAT.NEXT: *
PRINT @(ZERO,21):CLL:"Enter # to alter, A(dd), L(ist), P(rint), R(emove error status),"
PRINT @(ZERO,22):CLL:"    C(hange header) or <cr> if okay: ":
INPUT RSP:
PRINT @(0,21):CLL:; IF RSP EQ "KILL" THEN GOTO FINISH
*
BEGIN CASE
CASE RSP EQ EMPTY; GOTO ENTRY.COMPLETED
CASE RSP EQ "A"; * GOSUB ADD.TRANS
CASE RSP EQ "C"; * GOSUB GET.HEADER.DATA; IF STAT EQ 999 THEN GOTO FINISH ELSE GOSUB UPDATE.FILE; GOSUB CHECK.BALANCE
CASE RSP EQ "L"; * GOSUB LIST.BATCH
CASE RSP EQ "P"; * GOSUB PRINT.BATCH; IF OPSYS NE "R" THEN PRINTER CLOSE
CASE RSP EQ "R"
IF BATCH.STATUS EQ "E" OR BATCH.STATUS EQ "R" THEN
BATCH.STATUS = EMPTY; * GOSUB CHECK.BALANCE
LIST.ALL = TRUE; * GOSUB LIST.BATCH; LIST.ALL = FALSE
IF STAT THEN GOTO FINISH
END ELSE PRINT BELL:
CASE RSP EQ ZERO OR NOT(RSP MATCHES "0N"); PRINT BELL:
* CASE ONE; IF CAJ<RSP> EQ EMPTY THEN PRINT BELL: ELSE * GOSUB CHANGE.TRANS
END CASE
GOTO WHAT.NEXT
!
UPDATE.FILE: *
*
$INCLUDE IBP CASH.INCL.UPD.HDR
*
RETURN
!
ENTRY.COMPLETED: *
IF BATCH.TOTAL EQ ENTERED.TOTAL THEN
MSG = "Batch is in balance - S(ave but don't post), D(elete it) or <cr> to post: "
END ELSE MSG = "Batch is not in balance - S(ave it), D(elete it) or <cr> to continue: "
*
LOOP
PRINT @(ZERO,22):CLL:MSG:
INPUT RSP:; IF RSP EQ "KILL" THEN GOTO FINISH
IF RSP EQ "S" THEN
IF OPSYS NE "U" THEN GOTO FINISH
* GOSUB IMPRINT.TOTAL
* GOSUB UPDATE.FILE
GOTO FINISH
END
IF RSP EQ "D" THEN GOTO DELETE.BATCH
UNTIL RSP EQ EMPTY DO PRINT BELL: REPEAT
IF BATCH.TOTAL NE ENTERED.TOTAL THEN GOTO WHAT.NEXT
*
IF BATCH.STATUS NE "E" AND BATCH.STATUS NE "R" THEN
CLS.COL = ZERO; CLS.ROW = 3; * GOSUB CLS.ROUTINE
PRINT RVB:STR("*",80):RVE:
POST.DATE = CONTROL.DT
POST.TIME = OCONV(TIME(),"MT")
* IF OPSYS EQ "U" THEN * GOSUB IMPRINT.TOTAL; *CHEQUE IMPRINTER TOTAL LINE..
CALL CASH.OR.ADJ.POST(LCK.FILE,PAR.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,LCK.ITM,LCK.TYPE,LCK.STAT,STAT,CAJ,RUN.TYPE,RUN.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,MIN.DELINQ.STAT,MIN.DELINQ.AMT,BUS.DATE,ENTRY.TYPE,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG)
IF NOT(STAT) THEN BATCH.STATUS = "P" ELSE BATCH.STATUS = "E"
POSTED.BATCHES<-ONE> = BATCH.NUM
END
* GOSUB UPDATE.FILE
*
!
*
FINISH: *
*
CALL UNLOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LCK.FILE)
*
STOP
*
!
*
EXTRACT.HEADER.DATA: *
*
$INCLUDE IBP CASH.INCL.EXT.HDR
*
RETURN
*
!
*
RETURN
!
DELETE.BATCH: *
RETURN
*
$INCLUDE IBP CLS.ROUTINE
!
END
~FREEZE.PORT~
*PROGRAM: * FREEZE.PORT
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
LOOP
*
EXECUTE "SLEEP 86400"
*
WHILE TRUE DO REPEAT
*
CHAIN "OFF"
*
END
~GARBAGE.SEARCH~
*PROGRAM:           GARBAGE.SEARCH
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       SEARCH FOR GARBAGE IN KBIL DATABASE (REVELATION ONLY)...
* DATE WRITTEN:      21 OCT 86
* DATE RELEASED:     21 OCT 86
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
*
INPUT AUTO.RUN
IF AUTO.RUN THEN READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Quest for garbage"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("GARBAGE.SEARCH","","Garbage search")
FILE.LIST = "ACG\ACM\ACT\ACX\ADD\CNT\DLQ\DVC\EFT\PAR\REV\RTE\STT\STX\SVC\SVS\TAX\WKH\WKO\WKP"
!
GARBAGE = "No garbage found..."; GAC = 1; FNUM = 1
LOOP FILEID = FIELD(FILE.LIST,"\",FNUM) UNTIL FILEID = "" DO
OPEN FILEID TO FLVAR ELSE PRINT "Can't open ":FILEID:; INPUT RSP; STOP
CTR = 0; CTR1 = 0; PRINT @(30,10):FILEID:
SELECT FLVAR TO FLVAR.ID.LST
LOOP
READNEXT ID FROM FLVAR.ID.LST ELSE ID = "\\@@&&"
UNTIL ID = "\\@@&&" DO
READ RCRD FROM FLVAR,ID THEN
CTR = CTR+1; CTR1 = CTR1+1; IF CTR1 = 100 THEN CTR1 = 0; PRINT @(40,10):CTR "R#5":
OTHER.ERR = ""
IF FILEID = "ACT" THEN
IF RCRD<19>[1,1] = "-" THEN RCRD<19> = RCRD<19>[2,99]; IF RCRD<19> = "" THEN OTHER.ERR = 1
IF RCRD<19> # "" THEN IF NOT(RCRD<19> MATCHES "0N") THEN OTHER.ERR = 1
MAX.VC = COUNT(RCRD<34>,VM)+1
FOR VC = 1 TO MAX.VC
IF RCRD<34,VC> # "" THEN IF NOT(RCRD<34,VC> MATCHES "0N") THEN OTHER.ERR = 1
NEXT VC
END
IF OTHER.ERR OR INDEX(RCRD,"\ROS",1) OR INDEX(RCRD,".LNK",1) THEN
GARBAGE<GAC> = FILEID "L#6":ID
GAC = GAC+1
END
END
REPEAT
FNUM = FNUM+1
REPEAT
WRITE GARBAGE ON CNT.FILE,"GARBAGE"
EXECUTE "COPY CNT GARBAGE (P)"
STOP
!
END
~GET.ICONV~
SUBROUTINE GET.ICONV(FLD,CONV)
* VERSION: 911220 261  RE CSS
* PROGRAM:           GET.ICONV
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       VALIDATED "ICONV" FUNCTION FOR ULTIMATE
* DATE WRITTEN:      29 NOV 83
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*SETTERM
!
FLD = TRIM(FLD)
*
IF CONV[ONE,ONE] EQ "D" THEN
*
XFLD = FLD
IF CONV MATCHES "'D'1N'N'" THEN FLD = ICONV(FLD,CONV[ONE,TWO]) ELSE FLD = ICONV(FLD,CONV)
IF NOT(NUM(FLD)) THEN FLD = EMPTY; RETURN
*
MTHS = "JAN":VM:"FEB":VM:"MAR":VM:"APR":VM:"MAY":VM:"JUN":VM:"JUL":VM:"AUG":VM:"SEP":VM:"OCT":VM:"NOV":VM:"DEC"; MTH = EMPTY; POS = ONE
LOOP TEMP = XFLD[POS,ONE] WHILE TEMP MATCHES "1N" DO POS = POS + ONE REPEAT
*
IF TEMP MATCHES "1A" THEN MTH = XFLD[POS,3] ELSE TEMP = XFLD[POS + ONE,ONE]; IF TEMP MATCHES "1A" THEN MTH = XFLD[POS + ONE,3]
IF MTH EQ EMPTY THEN MTH = XFLD[ONE,POS - ONE] ELSE LOCATE MTH IN MTHS<ONE> SETTING MTH ELSE MTH = EMPTY
IF MTH NE OCONV(FLD,"D2-")[ONE,TWO] THEN FLD = EMPTY
*
RETURN
*
END
*
*
IF CONV[ONE,TWO] EQ "MT" THEN
*
FOR POS = 1 TO 3
*
TEMP = FIELD(FLD,":",POS); IF NOT(TEMP MATCH "0N") THEN FLD = EMPTY; RETURN
*
BEGIN CASE
CASE POS EQ ONE; IF TEMP LT ZERO OR TEMP GT 23 THEN FLD = EMPTY; RETURN
CASE POS EQ 2; IF TEMP LT ZERO OR TEMP GT 59 THEN FLD = EMPTY; RETURN
CASE POS EQ 3; IF TEMP AND TEMP LT ZERO OR TEMP GT 59 THEN FLD = EMPTY; RETURN
END CASE
*
NEXT POS
*
*
END ELSE
IF CONV[ONE,ONE] EQ "M" THEN
IF FLD EQ EMPTY THEN RETURN ELSE IF NOT(NUM(FLD)) THEN FLD = EMPTY; RETURN
IF OPSYS EQ "M" AND CONV[TWO,TWO] EQ "R" THEN CONV = "MD":CONV[TWO,99999]
END
END
*
FLD = ICONV(FLD,CONV)
*
RETURN
*
*
END
~HI.BIT~
*PROGRAM: HI.BIT 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       SETS OR CLEARS HI BIT ON $7C-$7D/$FC-$FD
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
PROMPT ""; AM = CHAR(254)
PRINT
*
LOOP
PRINT "Turn hi bit on (Y) or off (N)? ":; INPUT HI.ON
UNTIL HI.ON = "Y" OR HI.ON = "N" DO PRINT REPEAT
PRINT "TURN HI BIT ":; IF HI.ON = "Y" THEN HI.ON = 1; PRINT "ON" ELSE HI.ON = ""; PRINT "OFF"
!
NEXT.FILE: *
PRINT
PRINT "Which file <BP>? ":; INPUT FLNAME; IF FLNAME = '' THEN FLNAME = "BP"
OPEN FLNAME ELSE STOP
PRINT
!
NEXT.ITEM: *
PRINT "Which item? ":; INPUT ID; IF ID = "" THEN STOP
READ ITEM FROM ID ELSE PRINT "Not on file"; GOTO NEXT.ITEM
MAX.AC = COUNT(ITEM,AM)+1; UPD = ""
FOR AC = 1 TO MAX.AC
LINE = ITEM<AC>; OLD.LINE = LINE
IF HI.ON THEN
LOOP POS = INDEX(LINE,CHAR(125),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(253):LINE[POS+1,999] REPEAT
LOOP POS = INDEX(LINE,CHAR(124),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(252):LINE[POS+1,999] REPEAT
END ELSE
LOOP POS = INDEX(LINE,CHAR(253),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(125):LINE[POS+1,999] REPEAT
LOOP POS = INDEX(LINE,CHAR(252),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(124):LINE[POS+1,999] REPEAT
END
IF LINE # OLD.LINE THEN ITEM<AC> = LINE; UPD = 1
NEXT AC
IF UPD THEN WRITE ITEM ON ID
PRINT "Done"
PRINT
GOTO NEXT.ITEM
*
END
~HOURS.SUBR.CONV~
SUBROUTINE HOURS.SUBR.CONV(TMP.TM,ORSLT)
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP HOURS.INCL.CONV
*
RETURN
*
END
~INITIALIZATION~
*PROGRAM:           INITIALIZATION
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       INITIALIZATION AT LOGON TIME
* DATE WRITTEN:      DD MMM 82
* DATE RELEASED:     DD MMM 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
BEGIN: *
$INCLUDE IBP STANDARD.FUNCTIONS
!
IF OPSYS = "R" THEN
* IF @USER0 = "" THEN; * REV ONLY
OPEN "DOS" TO DOS.FILE THEN
READ GENERIC FROM DOS.FILE,"GENERIC.DAT" ELSE GENERIC = ""
IF GENERIC # "1" THEN GENERIC = ""
END
* ACCT = XLATE("LISTS","SYSTEM.LOCATIONS",4,"X"); * REV ONLY
* OVERNIGHT = FIELD(ACCT,"/",2); * REV ONLY
* ACCT = FIELD(ACCT,"/",1); * REV ONLY
* IF ACCT = "" THEN ACCT = @ACCOUNT; * REV ONLY
LISTS.FILE.THERE = ""; OPEN "LISTS" TO LISTS.FILE THEN LISTS.FILE.THERE = 1
* IF @ACCOUNT # ACCT THEN; * REV ONLY
IF LISTS.FILE.THERE THEN
READ LISTS.REC FROM LISTS.FILE,"SYSTEM.LOCATIONS" THEN
LOCATE ACCT IN LISTS.REC<5> SETTING VC THEN
FOR AC = 8 TO 9
DRIVE = LISTS.REC<AC,VC>
IF DRIVE # "" THEN
DRIVE = DRIVE:":\CABLE\":ACCT
PRINT CLB:"Attaching ":DRIVE:
EXLN = "ATTACH ":DRIVE
EXECUTE EXLN
END
NEXT AC
END
END
END
* END; * REV ONLY
* @USER0 = XLATE("PAR","PORT.NUM",1,"X"); * REV ONLY
* IF @USER0 = "" THEN @USER0 = 0; * REV ONLY
* @USER0 = @USER0:" ":ACCT; * REV ONLY
* IF GENERIC THEN @USER0 = @USER0:" ":GENERIC; * REV ONLY
IF LISTS.FILE.THERE THEN
OPEN "CNT" TO CNT.FILE ELSE STOP
READ RAMDISK.REC FROM LISTS.FILE,"RAMDISK.FILES" THEN
IF RAMDISK.REC<1> # "" THEN CALL SETUP.RAMDISK(CNT.FILE,RAMDISK.REC)
END
END
GOTO BEGIN
* END; * REV ONLY
* CLEARDATA; * REV ONLY
* IF OVERNIGHT = "OV" THEN STOP; * REV ONLY
END
!
OPEN "PAR" TO PAR.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
MD.OPEN = 1
OPEN "MD" TO MD.FILE ELSE
OPEN "VOC" TO MD.FILE ELSE MD.OPEN = ""
END
IF MD.OPEN THEN
READ KBIL.EXPIRY FROM MD.FILE,"PGX" THEN
KBIL.EXPIRY = KBIL.EXPIRY<1>:KBIL.EXPIRY<2>:KBIL.EXPIRY<3>:KBIL.EXPIRY<4>:KBIL.EXPIRY<5>
IF KBIL.EXPIRY <= DATE() THEN
PRINT @(0,23):"Call Axion 1-604-294-9811    ":
INPUT RSP:
IF RSP = CHAR(27):CHAR(27):"PGX" THEN
DELETE MD.FILE,"PGX"
END ELSE
EXECUTE "OFF"
END
END
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = "Unknown"
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE CURR.ACCTG.DATE = CONTROL.DATE-1
*
* VERIFY DATE IF IT DOES NOT MATCH CONTROL (Don't worry if before 3:00 next morning!)
IF CONTROL.DATE # CURR.ACCTG.DATE OR CONTROL.DATE # DATE() THEN
IF NOT(DATE() = CONTROL.DATE+1 AND TIME() < 10000) THEN
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
* CLEARDATA; * REV ONLY
*
IF OPSYS = "U" THEN PTR.TYPE = "Q0" ELSE PTR.TYPE = "REG"
READ PTR.CNTL FROM PAR.FILE,"PRINTER.":PTR.TYPE ELSE PTR.CNTL = ""
PTR.ON = ""; COM.FONT = ""
LOOP UNTIL PTR.CNTL<2> = "" DO PTR.ON = PTR.ON:CHAR(PTR.CNTL<2,1>); DEL PTR.CNTL<2,1> REPEAT
LOOP UNTIL PTR.CNTL<5> = "" DO COM.FONT = COM.FONT:CHAR(PTR.CNTL<5,1>); DEL PTR.CNTL<5,1> REPEAT
CALL PRINTER.ON(STAT); IF NOT(STAT) THEN PRINT PTR.ON:COM.FONT:
END
END
* CLEARDATA; * REV ONLY
STOP
END
~INPUT.DATA~
SUBROUTINE INPUT.DATA (ITEM,CL,LN,LH,LOCN,CONV,EDITS,EDIT.FILE,RSP,STAT)
* VERSION: 911203 261  TIME.ENTRY.ADDED
* PROGRAM:           INPUT.DATA
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       STANDARDIZED DATA INPUT
*            STAT    MEANING
*               0    GOOD RESPONSE
*              -1    REQUEST BACKUP
*               1    BAD RESPONSE (ERROR MESSAGE IN RSP<2>)
*             998    <ESC> WAS PRESSED
*             999    REQUEST KILL
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*SETTERM
!
START: *
SUPPRESS.ERROR.PRINT = ""; CLEAR.BOTTOM.LINE = ""
AC = FIELD(LOCN,",",1); VC = FIELD(LOCN,",",2); SC = FIELD(LOCN,",",3)
SB = INDEX(LOCN,",",3); IF NOT(SB) THEN SB = "" ELSE SB = LOCN[SB+1,9]
IF LH[1,1] MATCHES "1A" THEN MS = LH[1,1]:"#":LH[2,99]; LH = LH[2,99] ELSE MS = "L#":LH
IF AC THEN FLD = ITEM<AC,VC,SC> ELSE FLD = ""
IF SB # "" THEN FLD = FIELD(FLD,SB[1,1],SB[2,9])
IF FLD[1,1] # "!" THEN NO.PROMPT = 0 ELSE
IF STAT = -1 THEN GOTO FINISH
FLD = FLD[2,999]; NO.PROMPT = 1
END
IF CONV[1,1] = "M" OR CONV[1,1] = "D" THEN NON.NUMERIC.CONV = 0 ELSE NON.NUMERIC.CONV = 1
STAT = 0
DEF = FLD
IF DEF # "" THEN
IF CONV # "" THEN
IF NUM(DEF) OR NON.NUMERIC.CONV THEN
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[1,2] ELSE MOD.CONV = CONV
DEF = OCONV(DEF,MOD.CONV)
IF MOD.CONV # CONV THEN DEF = DEF[1,2]:DEF[4,3]:DEF[8,2]
END
END
END
DISP.DEF = DEF:STR(".",LH-LEN(DEF))
LOOP
PRINT @(CL,LN):DISP.DEF MS:@(CL,LN):; IF LH > 4 THEN ML = LH ELSE ML = 4
IF NO.PROMPT THEN RSP = DEF ELSE
INPUT RSP,ML:_; IF RSP = "KILL" THEN STAT = 999; GOTO FINISH
IF RSP[1,1] = CHAR(27) THEN STAT = 998; GOTO FINISH
IF RSP = "\" THEN RSP = "" ELSE IF RSP = "" OR RSP = "^" THEN
IF RSP = "^" THEN STAT = -1
RSP = DEF; PRINT @(CL,LN):RSP MS:; DEFAULT.USED = 1
IF STAT = -1 THEN GOTO FINISH
END ELSE DEFAULT.USED = ""
IF RSP = "?" THEN QUERY = 1 ELSE QUERY = ""
FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
GOSUB DO.EDITS
END
WHILE STAT > 0 DO
IF SUPPRESS.ERROR.PRINT THEN RSP<2> = TEXT; GOTO FINISH ELSE GOSUB ERROR.ADVICE; STAT = 0
REPEAT
FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
IF CONV = "" THEN RSP = FLD ELSE
IF NUM(FLD) OR NON.NUMERIC.CONV THEN
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[1,2] ELSE MOD.CONV = CONV
RSP = OCONV(FLD,MOD.CONV)
IF MOD.CONV # CONV THEN RSP = RSP[1,2]:RSP[4,3]:RSP[8,2]
END
END
PRINT @(CL,LN):RSP MS:
IF SB # "" THEN
IF AC THEN PRE.FLD = ITEM<AC,VC,SC> ELSE PRE.FLD = ""
PAR = SB[2,9]; SB = SB[1,1]; PART.FLD = FLD; FLD = ""
FLD.PAR = COUNT(PRE.FLD,SB)+1; IF FLD.PAR < PAR THEN FLD.PAR = PAR
FOR NUM = 1 TO FLD.PAR
IF NUM > 1 THEN FLD = FLD:SB
IF NUM = PAR THEN FLD = FLD:PART.FLD ELSE FLD = FLD:FIELD(PRE.FLD,SB,NUM)
NEXT NUM
END
IF AC THEN
ITEM<AC,VC,SC> = FLD; POS = LEN(ITEM<AC>)
LOOP WHILE ITEM<AC>[POS,1] > CHAR(250) DO POS = POS-1; ITEM<AC> = ITEM<AC>[1,POS] REPEAT
END
!
FINISH: *
IF CLEAR.BOTTOM.LINE THEN PRINT CLB:
RETURN
!
DO.EDITS: *
IF COUNT(RSP,AM) THEN TEXT = "attr mark was entered"; STAT = 1; RETURN
ED.VC = 1; IF EDITS<1,ED.VC> = "SE" THEN SUPPRESS.ERROR.PRINT = 1; ED.VC = ED.VC+1
IF LEN(RSP) > LH THEN STAT = 1; TEXT = "No more than ":LH:" characters please"; PRINT @(CL+LH,LN):SPACE(LEN(RSP)-LH):; RETURN
IF SB # "" THEN IF COUNT(RSP,SB[1,1]) THEN STAT = 1; TEXT = "Don't use a '":SB[1,1]:"' please"; RETURN
LOOP ED = EDITS<1,ED.VC> UNTIL ED = "" DO
ED1 = ED<1,1,1>; ED2 = ED<1,1,2>; ED3 = ED<1,1,3>
IF ED1 # "" THEN IF ED1 MATCHES "2A" THEN GOSUB SPECIFIC.EDIT
IF STAT < 1 THEN ED.VC = ED.VC+1 ELSE RETURN
REPEAT
IF NOT(STAT) THEN IF RSP = "?" THEN STAT = 1; TEXT = "Anything up to ":LH:" characters is okay"
RETURN
!
SPECIFIC.EDIT: *
ED2CONV = ED2
BEGIN CASE
CASE ED1 = "OP"; IF RSP = "" THEN ED.VC = 99
CASE ED1 = "RQ"; IF RSP = "" THEN STAT = 1; TEXT = "Please enter something here"
CASE ED1 = "LO"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD < ED2 THEN STAT = 1; TEXT = "Your entry should be at least ":ED2CONV:" please"
CASE ED1 = "HI"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD > ED2 THEN STAT = 1; TEXT = "Your entry should be no more than ":ED2CONV:" please"
CASE ED1 = "NC"
TEMP = RSP[LEN(RSP),1]; IF TEMP = " " OR TEMP = "-" THEN RSP = TRIM(TEMP):RSP[1,LEN(RSP)-1]
IF NOT(NUM(RSP)) THEN STAT = 1; TEXT = "Please enter it in cents only" ELSE
IF NOT(DEFAULT.USED) THEN RSP = RSP/100
END
CASE ED1 = "ND"
TEMP = RSP[LEN(RSP),1]; IF TEMP = " " OR TEMP = "-" THEN RSP = TRIM(TEMP):RSP[1,LEN(RSP)-1]
IF NOT(NUM(RSP)) THEN STAT = 1; TEXT = "Please enter it in dollars and cents"
CASE ED1 = "NU"
TEMP = RSP[LEN(RSP),1]; IF TEMP = " " OR TEMP = "-" THEN RSP = TRIM(TEMP):RSP[1,LEN(RSP)-1]
IF NOT(NUM(RSP)) THEN STAT = 1; TEXT = "Please enter a number"
CASE ED1 = "DT"
IF RSP # "" THEN TEMP = RSP; CALL GET.ICONV(TEMP,"D"); IF TEMP = "" THEN STAT = 1; TEXT = "I need a date please"
CASE ED1 = "DD"; IF RSP = "" THEN RSP = OCONV(DATE(),"D0.")
CASE ED1 = "TM"
* PRINT CLB:BELL:"Please enter time (1PM = 13:00)":
IF RSP # "" THEN TEMP = RSP; CALL GET.ICONV(TEMP,"MT"); IF TEMP = "" THEN STAT = 1; TEXT = "I need a time please in the format HH:MM"
CASE ED1 = "LF"
IF RSP MATCHES "0N" OR RSP MATCHES "0N'#'" OR RSP MATCHES "0N'+'" THEN
IF ED3 = "" THEN RSP = ED2:RSP ELSE RSP = STR(ED2,ED3-LEN(RSP)):RSP
END
CASE ED1 = "RF"
IF ED3 = "" THEN RSP = ED2:RSP ELSE IF NUM(RSP) OR NOT(NUM(ED3)) THEN RSP = RSP:STR(ED2,ED3-LEN(RSP))
CASE ED1 = "FI"; READV DUMMY FROM EDIT.FILE,RSP,1 ELSE STAT = 1; TEXT = "Sorry, that's not a valid entry - please check your documentation"
CASE ED1 = "DF"
IF RSP = "" THEN
IF ED2[1,1] # "*" THEN RSP = ED2 ELSE
ED4 = ED<1,1,4>; IF ED4 < 1 THEN ED4 = 1
READV RSP FROM EDIT.FILE,ED3,ED4 ELSE RSP = ""
END
END
CASE ED1 = "EQ"
IF NOT(ED2[1,1] = "*" OR ED2[1,1] = "@") THEN DEL ED<1,1,1> ELSE
IF ED2[1,1] = "*" THEN
ED4 = ED<1,1,4>; IF ED4 < 1 THEN ED4 = 1
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = ""
END ELSE ED = FIELD(EDITS,"@",2); ED.VC = ED.VC+COUNT(ED,VM)
END
TEXT = ""; SCAN.VC = 1; IF COUNT(ED,VM) THEN SCAN.SC = 0 ELSE SCAN.SC = 1
LOOP TEMP = ED<1,SCAN.VC,SCAN.SC>[1,LH] UNTIL TEMP = RSP OR TEMP = "" DO
TEXT = TEXT:TEMP:", "; IF SCAN.SC THEN SCAN.SC = SCAN.SC+1 ELSE SCAN.VC = SCAN.VC+1
REPEAT
IF TEMP # "" THEN RETURN
TEXT = TEXT[1,LEN(TEXT)-2]
STAT = 1
IF LEN(TEXT) > 65 THEN
IF LEN(TEXT)-COUNT(TEXT,", ") > 65 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",1) WHILE POS DO TEXT = TEXT[1,POS]:TEXT[POS+2,99] REPEAT
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[1,POS-1]:" or":TEXT[POS+1,99]
END
TEXT = "Please use ":TEXT
CASE ED1 = "MA"
IF NOT(ED2[1,1] = "*" OR ED2[1,1] = "@") THEN DEL ED<1,1,1> ELSE
IF ED2[1,1] = "*" THEN
ED4 = ED<1,1,4>; IF ED4 < 1 THEN ED4 = 1
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = ""
END ELSE ED = FIELD(EDITS,"@",2); ED.VC = ED.VC+COUNT(ED,VM)
END
TEXT = ""; SCAN.VC = 1; IF COUNT(ED,SVM) THEN SCAN.SC = 1 ELSE SCAN.SC = 0
LOOP TEMP = ED<1,SCAN.VC,SCAN.SC> UNTIL RSP MATCHES TEMP OR TEMP = "" DO
TEXT<-1> = TEMP; IF SCAN.SC THEN SCAN.SC = SCAN.SC+1 ELSE SCAN.VC = SCAN.VC+1
REPEAT
IF TEMP # "" THEN RETURN
STAT = 1; TEXT = AM:TEXT
LOOP OLD.TEMP = TEXT<2> UNTIL OLD.TEMP = "" DO
POS = 1; NUMERALS = ""; ALL.QUOTES = 1; QUOTES = ""; TEMP = ""
LOOP CHAR = OLD.TEMP[POS,1] UNTIL CHAR = "" DO
BEGIN CASE
CASE CHAR = "'"; IF QUOTES THEN QUOTES = "" ELSE QUOTES = 1
CASE QUOTES; TEMP = TEMP:CHAR
CASE CHAR MATCHES "1N"; NUMERALS = NUMERALS:CHAR; ALL.QUOTES = ""
CASE CHAR = "A" OR CHAR = "N" OR CHAR = "X"
IF CHAR = "N" THEN CHAR = "9" ELSE IF CHAR = "A" THEN CHAR = "X" ELSE CHAR = "_"
IF NOT(NUMERALS) THEN NUMERALS = LH; IF NUMERALS > 3 THEN NUMERALS = 3
TEMP = TEMP:STR(CHAR,NUMERALS); NUMERALS = ""; ALL.QUOTES = ""
CASE 1; TEMP = TEMP:CHAR; ALL.QUOTES = ""
END CASE
POS = POS+1
REPEAT
IF ALL.QUOTES THEN TEMP = "'":TEMP:"'"
DEL TEXT<2>; TEXT<1> = TEXT<1>:TEMP:", "
REPEAT
TEXT = TEXT[1,LEN(TEXT)-2]
IF LEN(TEXT) > 60 THEN
IF LEN(TEXT)-COUNT(TEXT,", ") > 60 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",1) WHILE POS DO TEXT = TEXT[1,POS]:TEXT[POS+2,99] REPEAT
END
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[1,POS-1]:" or":TEXT[POS+1,99]
TEXT = "Please use format ":TEXT
END CASE
RETURN
!
ERROR.ADVICE: *
IF TEXT = "" THEN RETURN
IF NOT(QUERY) THEN PRINT BELL:
PRINT CLB:TEXT[1,80]:; IF LN # 23 THEN CLEAR.BOTTOM.LINE = 1; RETURN
IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN TO UNCON.RETURN ELSE PRINT CLB:
UNCON.RETURN: RETURN
END
~INPUT.DATA.SG~
SUBROUTINE INPUT.DATA.SG(FILE.NAME,ITEM.NAME,ITEM,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,REDISP,STAT)
* PROGRAM:           INPUT.DATA
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       STANDARDIZED DATA INPUT
*            STAT    MEANING
*               0    GOOD RESPONSE
*              -1    REQUEST BACKUP
*               1    BAD RESPONSE (ERROR MESSAGE IN RSP<2>)
*             998    <ESC> WAS PRESSED
*             999    REQUEST KILL
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*SETTERM
!
*
START: *
*
SUPPRESS.ERROR.PRINT = EMPTY; CLEAR.BOTTOM.LINE = EMPTY
AC = FIELD(LOCN,",",ONE); VC = FIELD(LOCN,",",TWO); SC = FIELD(LOCN,",",3)
SB = INDEX(LOCN,",",3); IF NOT(SB) THEN SB = EMPTY ELSE SB = LOCN[SB + ONE,9]
IF LH[ONE,ONE] MATCHES "1A" THEN MS = LH[ONE,ONE]:"#":LH[TWO,999]; LH = LH[TWO,999] ELSE MS = "L#":LH
IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,999]
IF AC OR VC OR SC THEN FLD = ITEM<AC,VC,SC> ELSE FLD = ITEM
IF SB NE EMPTY THEN FLD = FIELD(FLD,SB[ONE,ONE],SB[TWO,9])
IF FLD[ONE,ONE] NE "!" THEN NO.PROMPT = ZERO ELSE
IF STAT EQ -ONE THEN GOTO FINISH
FLD = FLD[TWO,999]; NO.PROMPT = ONE
END
IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO ELSE NON.NUMERIC.CONV = ONE
DEFAULT.USED = FALSE; STAT = FALSE; * REDISP = FALSE
DEF = FLD; FLD.LEN = LEN(FLD)
IF DEF NE EMPTY THEN
IF CONV NE EMPTY THEN
IF NUM(DEF) OR NON.NUMERIC.CONV THEN
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
DEF = OCONV(DEF,MOD.CONV)
IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
END
END
END
DISP.DEF = DEF:STR(".",LH-LEN(DEF))
LOOP
PRINT @(CL,LN):DISP.DEF MS:@(CL,LN):
IF LH GT 4 THEN ML = LH ELSE ML = 4
IF NO.PROMPT THEN RSP = DEF ELSE
*
BEGIN CASE
*
CASE NOT(OPSYS EQ "U" OR OPSYS EQ "M") OR LH EQ LHM
*INPUT RSP,ML:_; IF RSP = "KILL" THEN STAT = 999; GOTO FINISH
INPUT RSP,ML:_
*
CASE TRUE
RSP = EMPTY
TC.CN = ZERO
TC.CL = CL
TC.STOP = CL + ML
TC.ADJ = FALSE
*
LOOP
TC = EMPTY
BEGIN CASE
CASE OPSYS NE "U"
INPUT TC,ONE:
IF TC EQ "<" THEN
TC = CHAR(8)
IF TC.CN THEN
TCO = FLD[TC.CN + ONE,ONE]
IF TCO EQ EMPTY THEN TCO = "."
PRINT TC:TCO:TC:
END
END
IF TC EQ EMPTY THEN TC = CHAR(13)
CASE TRUE
TC = OCONV(TC,"U51EA")
END CASE
TC.SEQ = SEQ(TC)
*
WHILE TC.SEQ NE 13 DO
*
IF TC.SEQ EQ 124 THEN
IF LEN(FLD) GT TC.CN THEN
TC = FLD[TC.CN + ONE,ONE]
TC.SEQ = SEQ(TC)
PRINT CHAR(8):TC:
END
END
*
IF TC.SEQ GE 28 THEN
*
IF TC.SEQ LE 30 THEN
TC.SEQ = TC.SEQ + 224
TC = CHAR(TC.SEQ)
IF TT EQ "D" OR TT EQ "R" THEN PRINT TC:
END
*
RSP = RSP:TC
TC.CN = TC.CN + ONE
TC.CL = TC.CL + ONE
*
END ELSE IF TC.SEQ EQ 8 THEN
*
IF TC.CN THEN
TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = "."
TC.CN = TC.CN - ONE
TC.CL = TC.CL - ONE
PRINT TC:TCO:TC:
RSP = RSP[ONE,TC.CN]
END ELSE
PRINT @(CL,LN):DISP.DEF MS:@(CL,LN):
TC.ADJ = FALSE
END
*
END
*
IF TC.CL GE TC.STOP OR (TC.CL LE CL AND TC.ADJ) THEN
TC.ADJ = TRUE
TMP = INT(LH / TWO)
IF TMP GT TC.CN THEN TMP = TC.CN - ONE
TC.CL = CL + TMP + ONE
TMP1 = FLD[TC.CN + ONE,LH - TMP - ONE]
TMP1 = TMP1:STR(".",LH - TMP - ONE - LEN(TMP1))
PRINT @(CL,LN):RSP[TC.CN - TMP,999]:TMP1:@(CL + TMP + ONE,LN):
END
*
IF TC.CN EQ LHM THEN
TEXT = "No more than ":LHM:" characters please"
PRINT CLB:TEXT[ONE,80]:BELL:@(TC.CL,LN):; IF LN NE 23 THEN CLEAR.BOTTOM.LINE = ONE
END
*
REPEAT
*
IF TC.ADJ THEN
PRINT @(CL,LN):RSP[ONE,ML]:
END
*
IF CLEAR.BOTTOM.LINE THEN PRINT CLB:; CLEAR.BOTTOM.LINE = FALSE
*
END CASE
*
IF RSP EQ "KILL" THEN STAT = 999; GOTO FINISH
IF RSP[ONE,ONE] EQ CHAR(27) THEN STAT = 998; GOTO FINISH
CLEAR.FLAG = ZERO
IF RSP EQ "\" THEN RSP = EMPTY; CLEAR.FLAG = ONE ELSE
IF RSP EQ EMPTY OR RSP EQ "^" THEN
IF RSP EQ "^" THEN STAT = -ONE
RSP = DEF; PRINT @(CL,LN):RSP MS:; DEFAULT.USED = ONE
IF STAT EQ -ONE THEN GOTO FINISH
END ELSE DEFAULT.USED = EMPTY
END
QUERY = FALSE
IF RSP EQ "?" THEN QUERY = ONE
IF RSP EQ "??" THEN QUERY = TWO
IF RSP EQ "???" THEN QUERY = 3
IF QUERY THEN GOSUB QUERY.HELP ELSE
*FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
FLD = RSP
IF NOT(NON.NUMERIC.CONV) THEN
CALL GET.ICONV(FLD,CONV)
END
GOSUB DO.EDITS
END
END
WHILE STAT GT ZERO DO
IF NOT(QUERY) THEN
IF SUPPRESS.ERROR.PRINT THEN RSP<TWO> = TEXT; GOTO FINISH ELSE GOSUB ERROR.ADVICE; STAT = FALSE
END ELSE
STAT = FALSE
IF REDISP THEN RETURN
END
REPEAT
FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
IF CONV EQ EMPTY THEN RSP = FLD ELSE
IF NUM(FLD) OR NON.NUMERIC.CONV THEN
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
RSP = OCONV(FLD,MOD.CONV)
IF MOD.CONV NE CONV THEN RSP = RSP[ONE,TWO]:RSP[4,3]:RSP[8,TWO]
END
END
PRINT @(CL,LN):RSP MS:
IF SB NE EMPTY THEN
IF AC THEN PRE.FLD = ITEM<AC,VC,SC> ELSE PRE.FLD = EMPTY
PAR = SB[TWO,9]; SB = SB[ONE,ONE]; PART.FLD = FLD; FLD = EMPTY
FLD.PAR = COUNT(PRE.FLD,SB) + ONE; IF FLD.PAR LT PAR THEN FLD.PAR = PAR
FOR NUM = ONE TO FLD.PAR
IF NUM GT ONE THEN FLD = FLD:SB
IF NUM EQ PAR THEN FLD = FLD:PART.FLD ELSE FLD = FLD:FIELD(PRE.FLD,SB,NUM)
NEXT NUM
END
IF AC THEN
ITEM<AC,VC,SC> = FLD; POS = LEN(ITEM<AC>)
LOOP WHILE ITEM<AC>[POS,ONE] GT CHAR(250) DO POS = POS - ONE; ITEM<AC> = ITEM<AC>[ONE,POS] REPEAT
END
*
!
*
FINISH: *
*
IF CLEAR.BOTTOM.LINE THEN PRINT CLB:
RETURN
*
!
*
DO.EDITS: *
*
IF COUNT(RSP,AM) THEN TEXT = "attr mark was entered"; STAT = TRUE; RETURN
ED.VC = ONE; IF EDITS<ONE,ED.VC> EQ "SE" THEN SUPPRESS.ERROR.PRINT = ONE; ED.VC = ED.VC + ONE
IF LEN(RSP) GT LHM THEN STAT = TRUE; TEXT = "No more than ":LHM:" characters please"; PRINT @(CL + LH,LN):SPACE(LEN(RSP) - LH):; RETURN
IF SB NE EMPTY THEN IF COUNT(RSP,SB[ONE,ONE]) THEN STAT = TRUE; TEXT = "Don't use a '":SB[ONE,ONE]:"' please"; RETURN
LOOP ED = EDITS<ONE,ED.VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>; ED2 = ED<ONE,ONE,TWO>; ED3 = ED<ONE,ONE,3>
IF ED1 NE EMPTY THEN IF ED1 MATCHES "2A" THEN GOSUB SPECIFIC.EDIT
IF STAT LT ONE THEN ED.VC = ED.VC + ONE ELSE RETURN
REPEAT
IF NOT(STAT) THEN
IF RSP EQ "?" THEN STAT = TRUE; TEXT = "Anything up to ":LHM:" characters is okay"
END ELSE
GOSUB LOAD.EDITS; QUERY = 3; GOSUB QUERY.HELP
END
*
RETURN
*
!
*
SPECIFIC.EDIT: *
*
ED2CONV = ED2
*
BEGIN CASE
*
CASE ED1 EQ "OP"; IF RSP EQ EMPTY THEN ED.VC = 999
*
CASE ED1 EQ "RQ"; IF RSP EQ EMPTY THEN STAT = TRUE; TEXT = "Please enter something here"
*
CASE ED1 EQ "LO"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD LT ED2 THEN STAT = TRUE; TEXT = "Your entry should be at least ":ED2CONV:" please"
*
CASE ED1 EQ "HI"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD GT ED2 THEN STAT = TRUE; TEXT = "Your entry should be no more than ":ED2CONV:" please"
*
CASE ED1 EQ "NC"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter it in cents only" ELSE
IF NOT(DEFAULT.USED) THEN RSP = RSP / 100
END
*
CASE ED1 EQ "ND"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter it in dollars and cents"
*
CASE ED1 EQ "NU"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter a number"
*
CASE ED1 EQ "DT"
IF RSP NE EMPTY THEN TEMP = RSP; CALL GET.ICONV(TEMP,"D"); IF TEMP EQ EMPTY THEN STAT = TRUE; TEXT = "Enter a date please"
*
CASE ED1 EQ "DD"; IF RSP EQ EMPTY THEN RSP = OCONV(DATE(),"D0.")
*
CASE ED1 EQ "TM"; IF RSP EQ EMPTY THEN RSP = OCONV(TIME(),"MT")
*
CASE ED1 EQ "LF"
IF RSP MATCHES "0N" OR RSP MATCHES "0N'#'" OR RSP MATCHES "0N'+'" THEN
IF ED3 EQ EMPTY THEN RSP = ED2:RSP ELSE RSP = STR(ED2,ED3-LEN(RSP)):RSP
END
*
CASE ED1 EQ "RF"
IF ED3 EQ EMPTY THEN RSP = ED2:RSP ELSE IF NUM(RSP) OR NOT(NUM(ED3)) THEN RSP = RSP:STR(ED2,ED3-LEN(RSP))
*
CASE ED1 EQ "FI"; READV DUMMY FROM EDIT.FILE,RSP,ONE ELSE STAT = TRUE; TEXT = "Sorry, that's not a valid entry - please check your documentation"
*
CASE ED1 EQ "DF"
IF RSP EQ EMPTY AND NOT(CLEAR.FLAG) THEN
IF ED2[ONE,ONE] NE "*" THEN RSP = ED2 ELSE
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV RSP FROM EDIT.FILE,ED3,ED4 ELSE RSP = EMPTY
END
END
*
CASE ED1 EQ "EQ"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
TEXT = EMPTY; SCAN.VC = ONE; IF COUNT(ED,VM) THEN SCAN.SC = ZERO ELSE SCAN.SC = ONE
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC>[ONE,LHM] UNTIL TEMP EQ RSP OR TEMP EQ EMPTY DO
TEXT = TEXT:TEMP:", "; IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
IF TEMP NE EMPTY THEN RETURN
TEXT = TEXT[ONE,LEN(TEXT) - TWO]
STAT = TRUE
IF LEN(TEXT) GT 65 THEN
IF LEN(TEXT) - COUNT(TEXT,", ") GT 65 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",ONE) WHILE POS DO TEXT = TEXT[ONE,POS]:TEXT[POS + TWO,999] REPEAT
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[ONE,POS - ONE]:" or":TEXT[POS + ONE,999]
END
TEXT = "Please use ":TEXT
*
CASE ED1 EQ "MA"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
TEXT = EMPTY; SCAN.VC = ONE; IF COUNT(ED,SVM) THEN SCAN.SC = ONE ELSE SCAN.SC = ZERO
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC> UNTIL RSP MATCHES TEMP OR TEMP EQ EMPTY DO
TEXT<-ONE> = TEMP; IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
IF TEMP NE EMPTY THEN RETURN
STAT = TRUE; TEXT = AM:TEXT
LOOP OLD.TEMP = TEXT<TWO> UNTIL OLD.TEMP EQ EMPTY DO
POS = ONE; NUMERALS = EMPTY; ALL.QUOTES = ONE; QUOTES = EMPTY; TEMP = EMPTY
LOOP CHAR = OLD.TEMP[POS,ONE] UNTIL CHAR EQ EMPTY DO
BEGIN CASE
CASE CHAR EQ "'"; IF QUOTES THEN QUOTES = EMPTY ELSE QUOTES = ONE
CASE QUOTES; TEMP = TEMP:CHAR
CASE CHAR MATCHES "1N"; NUMERALS = NUMERALS:CHAR; ALL.QUOTES = EMPTY
CASE CHAR EQ "A" OR CHAR EQ "N" OR CHAR EQ "X"
IF CHAR EQ "N" THEN CHAR = "9" ELSE IF CHAR EQ "A" THEN CHAR = "X" ELSE CHAR = "x"
IF NOT(NUMERALS) THEN NUMERALS = LHM; IF NUMERALS GT 3 THEN NUMERALS = 3
TEMP = TEMP:STR(CHAR,NUMERALS); NUMERALS = EMPTY; ALL.QUOTES = EMPTY
CASE ONE; TEMP = TEMP:CHAR; ALL.QUOTES = EMPTY
END CASE
POS = POS + ONE
REPEAT
IF ALL.QUOTES THEN TEMP = "'":TEMP:"'"
DEL TEXT<TWO>; TEXT<ONE> = TEXT<ONE>:TEMP:", "
REPEAT
TEXT = TEXT[ONE,LEN(TEXT) - TWO]
IF LEN(TEXT) GT 60 THEN
IF LEN(TEXT) - COUNT(TEXT,", ") GT 60 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",ONE) WHILE POS DO TEXT = TEXT[ONE,POS]:TEXT[POS + TWO,999] REPEAT
END
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[ONE,POS - ONE]:" or":TEXT[POS + ONE,999]
TEXT = "Please use format ":TEXT
*
END CASE
*
RETURN
*
!
*
ERROR.ADVICE: *
*
IF TEXT EQ EMPTY THEN RETURN
IF NOT(QUERY) THEN PRINT BELL:
PRINT CLB:TEXT[ONE,80]:; IF LN NE 23 THEN CLEAR.BOTTOM.LINE = ONE; RETURN
IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN TO UNCON.RETURN ELSE PRINT CLB:
*
UNCON.RETURN: *
*
RETURN
*
!
*
QUERY.HELP: *
*
STAT = ONE
*
IF COUNT(FILE.NAME,"$") THEN
ITEM.NAME = FIELD(FILE.NAME,"$",TWO)
FILE.NAME = FIELD(FILE.NAME,"$",ONE)
END
*
IF COUNT(ITEM.NAME,"$") THEN
FILE.NAME = FIELD(ITEM.NAME,"$",ONE)
ITEM.NAME = FIELD(ITEM.NAME,"$",TWO)
END
*
IF COUNT(FILE.NAME,".") THEN
FILE.NAME = FIELD(FILE.NAME,".",ONE)
END
*
IF QUERY NE 3 THEN
OPEN "DICT",FILE.NAME TO FILE.DICT THEN
*
IF ITEM.NAME[ONE,ONE] EQ "<" THEN
ITEM.NAME = ITEM.NAME[TWO,9999]
ITEM.NAME = FIELD(ITEM.NAME,">",ONE)
ITEM.NAME = FIELD(ITEM.NAME,",",ONE)
END
*
IF ITEM.NAME EQ "ONE" THEN ITEM.NAME = "1"
*
READ DICT.ITEM FROM FILE.DICT,ITEM.NAME ELSE DICT.ITEM = EMPTY; QUERY = 3
*
END ELSE DICT.ITEM = EMPTY; QUERY = 3
END ELSE DICT.ITEM = EMPTY
*
* PRINT CLB:DICT.ITEM<13> "L#79":
IF QUERY EQ ONE THEN QUERY.TEXT = DICT.ITEM<12>; IF NOT(LEN(QUERY.TEXT)) THEN QUERY = TWO
IF QUERY EQ TWO THEN QUERY.TEXT = DICT.ITEM<21>; IF NOT(LEN(QUERY.TEXT)) THEN QUERY = 3
IF QUERY EQ 3 THEN
GOSUB LOAD.EDITS
QUERY.TEXT = DICT.ITEM<13>
QUERY.TEXT<ONE,-ONE> = DICT.ITEM<11>
IF LEN(QT) THEN QUERY.TEXT<ONE,-ONE> = VM:VM:QT
END
*
QUERY.CN.MAX = DCOUNT(QUERY.TEXT,VM); QUERY.CN = ONE
*
IF QUERY.CN.MAX GT 5 THEN
REDISP = TRUE
PRINT @(ZERO,4):CLS:
PRINT @(ZERO,5):"   ":RVB:"File: ":FILE.NAME "L#5":"   Field: ":DICT.ITEM<TWO> "L#3":"   English: ":DICT.ITEM<3> "L#15":"   Name: ":DICT.ITEM<13> "L#19":RVE:
LOOP
FOR TMP.LN = 6 TO 20 UNTIL QUERY.CN GT QUERY.CN.MAX
PRINT @(ZERO,TMP.LN):"   ":QUERY.TEXT<ONE,QUERY.CN> "L#70":
QUERY.CN = QUERY.CN + ONE
NEXT TMP.LN
TMP = EMPTY
IF QUERY.CN LT QUERY.CN.MAX THEN
PRINT CLB:"Enter N(ext), P(rev), or <cr> to end: ":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
END ELSE
FOR TMP.LN = TMP.LN TO 20; PRINT @(ZERO,TMP.LN):CLL:; NEXT TMP.LN
END
IF TMP EQ "P" THEN
QUERY.CN = QUERY.CN - 30
IF QUERY.CN LE ONE THEN QUERY.CN = ONE
END
WHILE TMP EQ "N" OR TMP EQ "P" DO REPEAT
PRINT CLB:"Enter <cr> to resume: ":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
END ELSE IF QUERY.CN.MAX THEN
*
LOOP
IF LEN(QUERY.TEXT<ONE,QUERY.CN>) THEN
PRINT CLB:QUERY.TEXT<ONE,QUERY.CN> "L#70":" <cr>":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
END
WHILE QUERY.CN LT QUERY.CN.MAX DO
QUERY.CN = QUERY.CN + ONE
REPEAT
PRINT CLB:
*
END; * OF GT 5
*
PRINT CLB:DICT.ITEM<13> "L#79":
IF LN NE 23 THEN CLEAR.BOTTOM.LINE = ONE; RETURN
*
RETURN
*
!
*
LOAD.EDITS: *
*
ED.VC = ONE; IF EDITS<ONE,ED.VC> EQ "SE" THEN SUPPRESS.ERROR.PRINT = ONE; ED.VC = ED.VC + ONE
QT = EMPTY
*
LOOP ED = EDITS<ONE,ED.VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>; ED2 = ED<ONE,ONE,TWO>; ED3 = ED<ONE,ONE,3>
*
IF ED1 NE EMPTY THEN IF ED1 MATCHES "2A" THEN
*
BEGIN CASE
*
CASE ED1 EQ "OP"
QT<ONE,-ONE> = "An entry is not mandatory here."
*
CASE ED1 EQ "RQ"
QT<ONE,-ONE> = "An entry is mandatory here."
*
CASE ED1 EQ "LO"
QT<ONE,-ONE> = "Your entry should be at least ":ED2:"."
*
CASE ED1 EQ "HI"
QT<ONE,-ONE> = "Your entry should be no more than ":ED2:"."
*
CASE ED1 EQ "NC"
QT<ONE,-ONE> = "Enter an amount in cents only."
*
CASE ED1 EQ "ND"
QT<ONE,-ONE> = "Enter an amount in dollars and cents."
*
CASE ED1 EQ "NU"
QT<ONE,-ONE> = "Enter a number."
*
CASE ED1 EQ "DT"
QT<ONE,-ONE> = "Enter a date."
*
CASE ED1 EQ "DD"
QT<ONE,-ONE> = "The system date will be used as a default."
*
CASE ED1 EQ "LF"
QT<ONE,-ONE> = "Your entry will be right justified in a fied of ":ED3:" ":ED2:"'s."
*
CASE ED1 EQ "RF"
QT<ONE,-ONE> = "Your entry will be left justified in a field of ":ED3:" ":ED2:"'s."
*
CASE ED1 EQ "FI"
QT<ONE,-ONE> = "Your entry must already exist on file."
*
CASE ED1 EQ "DF"
IF ED2[ONE,ONE] NE "*" THEN
QT<ONE,-ONE> = ED2:" will be used if you do not make an entry."
END ELSE
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV TMP FROM EDIT.FILE,ED3,ED4 ELSE TMP = EMPTY
QT<ONE,-ONE> = TMP:" will be used if you do not make an entry."
END
*
CASE ED1 EQ "EQ"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
*
QTD = EMPTY; SCAN.VC = ONE; IF COUNT(ED,VM) THEN SCAN.SC = ZERO ELSE SCAN.SC = ONE
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC>[ONE,LHM] UNTIL TEMP EQ EMPTY DO
QTD<ONE,-ONE> = "     - ":TEMP
IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
*
IF QTD NE EMPTY THEN
QT<ONE,-ONE> = "Valid entries appear in the following list: ":VM:QTD
QTD = EMPTY
END
*
*
CASE ED1 EQ "MA"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
*
QTD = EMPTY; SCAN.VC = ONE; IF COUNT(ED,SVM) THEN SCAN.SC = ONE ELSE SCAN.SC = ZERO
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC> UNTIL TEMP EQ EMPTY DO
QTD<ONE,-ONE> = TEMP
IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
*
IF QTD NE EMPTY THEN
SCAN.AC = ZERO
*
LOOP SCAN.AC = SCAN.AC + ONE; OLD.TEMP = QTD<ONE,SCAN.AC> UNTIL OLD.TEMP EQ EMPTY DO
POS = ONE; NUMERALS = EMPTY;
ALL.QUOTES = TRUE; QUOTES = FALSE; TEMP = EMPTY
*
LOOP CHAR = OLD.TEMP[POS,ONE] UNTIL CHAR EQ EMPTY DO
BEGIN CASE
CASE CHAR EQ "'"; IF QUOTES THEN QUOTES = FALSE ELSE QUOTES = TRUE
CASE QUOTES; TEMP = TEMP:CHAR
CASE CHAR MATCHES "1N"; NUMERALS = NUMERALS:CHAR; ALL.QUOTES = FALSE
CASE CHAR EQ "A" OR CHAR EQ "N" OR CHAR EQ "X"
IF CHAR EQ "N" THEN CHAR = "9" ELSE IF CHAR EQ "A" THEN CHAR = "X" ELSE CHAR = "x"
IF NOT(NUMERALS) THEN NUMERALS = LHM; IF NUMERALS GT 3 THEN NUMERALS = 3
TEMP = TEMP:STR(CHAR,NUMERALS); NUMERALS = EMPTY; ALL.QUOTES = FALSE
CASE ONE; TEMP = TEMP:CHAR; ALL.QUOTES = FALSE
END CASE
POS = POS + ONE
REPEAT
*
IF ALL.QUOTES THEN TEMP = "'":TEMP:"'"
QTD<ONE,SCAN.AC> = "     - ":TEMP
REPEAT
*
QT<ONE,-ONE> = "Valid entries must match one of the following masks: ":VM:QTD
QTD = EMPTY
*
END; * of QTD
*
END CASE
*
END; * of 2A
*
ED.VC = ED.VC + ONE
*
REPEAT
*
QT<ONE,-ONE> = "Enter no more than ":LHM:" characters."
*
RETURN
*
!
*
*
END
~INPUT.DATA.SG1~
SUBROUTINE INPUT.DATA.SG1(FILE.NAME,ITEM.NAME,ITEM,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
* PROGRAM:           INPUT.DATA
*TM.MAX C/B 300]OFF for the menu handler (300 secs or OFF)
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       STANDARDIZED DATA INPUT
*            STAT    MEANING
*               0    GOOD RESPONSE
*              -1    REQUEST BACKUP
*               1    BAD RESPONSE (ERROR MESSAGE IN RSP<2>)
*             998    <ESC> WAS PRESSED
*             999    REQUEST KILL
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*NOTERM
*
*
*%%MDD%%=INCLUDE STANDARD.FUNCTIONS.CLB FROM OUT.IBP
*OVERRIDE
*
!
*
START: *
*
SUPPRESS.ERROR.PRINT = EMPTY; CLEAR.BOTTOM.LINE = FALSE
AC = FIELD(LOCN,",",ONE); VC = FIELD(LOCN,",",TWO); SC = FIELD(LOCN,",",3)
SB = INDEX(LOCN,",",3); IF NOT(SB) THEN SB = EMPTY ELSE SB = LOCN[SB + ONE,9]
* IF LH[ONE,ONE] MATCHES "1A" THEN MS = LH[ONE,ONE]:"#":LH[TWO,999]; LH = LH[TWO,999] ELSE MS = "L#":LH
* IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,999]
MS = EMPTY
CLEAR.FLAG = FALSE
IF AC OR VC OR SC THEN FLD = ITEM<AC,VC,SC> ELSE FLD = ITEM
IF SB NE EMPTY THEN FLD = FIELD(FLD,SB[ONE,ONE],SB[TWO,9])
IF FLD[ONE,ONE] NE "!" THEN NO.PROMPT = ZERO ELSE
IF STAT EQ -ONE THEN GOTO FINISH
FLD = FLD[TWO,999]; NO.PROMPT = ONE
END
DEF.SUPP = FALSE
* IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO ELSE NON.NUMERIC.CONV = ONE
STAT = FALSE; * REDISP = FALSE
* DEF = FLD; FLD.LEN = LEN(FLD)
* IF DEF NE EMPTY THEN
* IF CONV NE EMPTY THEN
* IF NUM(DEF) OR NON.NUMERIC.CONV THEN
* IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
* DEF = OCONV(DEF,MOD.CONV)
* IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
* END
* END
* END
*
!
*
LOOP
*
$INCLUDE IBP CURSOR.STD
*
!
*
IF RSP EQ "KILL" THEN STAT = 999; GOTO FINISH
* IF RSP[ONE,ONE] EQ CHAR(27) THEN STAT = 998; GOTO FINISH
* CLEAR.FLAG = ZERO
* IF RSP EQ "\" THEN RSP = EMPTY; CLEAR.FLAG = ONE ELSE
IF NOT(CLEAR.FLAG) THEN
* IF RSP EQ EMPTY OR RSP EQ "^" THEN
IF (TC.FUNC NE "C" AND TC.FUNC NE EMPTY) OR RSP EQ "^" THEN
IF RSP EQ "^" THEN STAT = -ONE; TC.FUNC = "8"
RSP = DEF; PRINT @(RSP.CL,RSP.LN):RSP MS:; DEFAULT.USED = ONE
* IF STAT EQ -ONE THEN GOTO FINISH
* TC.FUNC = TC.OUT
**?TC.FUNC = EMPTY
GOTO FINISH
END ELSE DEFAULT.USED = EMPTY
END
QUERY = FALSE
IF RSP EQ "?" THEN QUERY = ONE
IF RSP EQ "??" THEN QUERY = TWO
IF RSP EQ "???" THEN QUERY = 3
IF QUERY THEN GOSUB QUERY.HELP ELSE
*FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
FLD = RSP
IF NOT(NON.NUMERIC.CONV) THEN
CALL GET.ICONV(FLD,CONV)
END
GOSUB DO.EDITS
END
* END
*
WHILE STAT GT ZERO DO
*
IF NOT(QUERY) THEN
IF SUPPRESS.ERROR.PRINT THEN RSP<TWO> = TEXT; GOTO FINISH ELSE GOSUB ERROR.ADVICE; STAT = FALSE
END ELSE
STAT = FALSE
IF REDISP THEN RETURN
END
*
REPEAT
*
!
*
FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
IF CONV EQ EMPTY THEN RSP = FLD ELSE
IF NUM(FLD) OR NON.NUMERIC.CONV THEN
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
RSP = OCONV(FLD,MOD.CONV)
IF MOD.CONV NE CONV THEN RSP = RSP[ONE,TWO]:RSP[4,3]:RSP[8,TWO]
END
END
PRINT @(RSP.CL,RSP.LN):RSP MS:
IF SB NE EMPTY THEN
IF AC THEN PRE.FLD = ITEM<AC,VC,SC> ELSE PRE.FLD = ITEM
PAR = SB[TWO,9]; SB = SB[ONE,ONE]; PART.FLD = FLD; FLD = EMPTY
FLD.PAR = COUNT(PRE.FLD,SB) + ONE; IF FLD.PAR LT PAR THEN FLD.PAR = PAR
FOR NUM = ONE TO FLD.PAR
IF NUM GT ONE THEN FLD = FLD:SB
IF NUM EQ PAR THEN FLD = FLD:PART.FLD ELSE FLD = FLD:FIELD(PRE.FLD,SB,NUM)
NEXT NUM
END
IF AC THEN
ITEM<AC,VC,SC> = FLD; POS = LEN(ITEM<AC>)
LOOP WHILE ITEM<AC>[POS,ONE] GT CHAR(250) DO POS = POS - ONE; ITEM<AC> = ITEM<AC>[ONE,POS] REPEAT
END ELSE ITEM = FLD
*
!
*
FINISH: *
*
IF CLEAR.BOTTOM.LINE THEN PRINT @(ZERO,CLEAR.BOTTOM.LINE):CLL:
RETURN
*
!
*
DO.EDITS: *
*
IF COUNT(RSP,AM) THEN TEXT = "attr mark was entered"; STAT = TRUE; RETURN
ED.VC = ONE; IF EDITS<ONE,ED.VC> EQ "SE" THEN SUPPRESS.ERROR.PRINT = ONE; ED.VC = ED.VC + ONE
IF LEN(RSP) GT LHM THEN STAT = TRUE; TEXT = "No more than ":LHM:" characters please"; PRINT @(RSP.CL + LH,RSP.LN):SPACE(LEN(RSP) - LH):; RETURN
IF SB NE EMPTY THEN IF COUNT(RSP,SB[ONE,ONE]) THEN STAT = TRUE; TEXT = "Don't use a '":SB[ONE,ONE]:"' please"; RETURN
LOOP ED = EDITS<ONE,ED.VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>; ED2 = ED<ONE,ONE,TWO>; ED3 = ED<ONE,ONE,3>
IF ED1 NE EMPTY THEN IF ED1 MATCHES "2A" THEN GOSUB SPECIFIC.EDIT
IF STAT LT ONE THEN ED.VC = ED.VC + ONE ELSE RETURN
REPEAT
IF NOT(STAT) THEN
IF RSP EQ "?" THEN STAT = TRUE; TEXT = "Anything up to ":LHM:" characters is okay"
END ELSE
GOSUB LOAD.EDITS; QUERY = 3; GOSUB QUERY.HELP
END
*
RETURN
*
!
*
SPECIFIC.EDIT: *
*
ED2CONV = ED2
*
BEGIN CASE
*
CASE ED1 EQ "OP"; IF RSP EQ EMPTY THEN ED.VC = 999
*
CASE ED1 EQ "RQ"; IF RSP EQ EMPTY THEN STAT = TRUE; TEXT = "Please enter something here"
*
CASE ED1 EQ "LO"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD LT ED2 THEN STAT = TRUE; TEXT = "Your entry should be at least ":ED2CONV:" please"
*
CASE ED1 EQ "HI"
IF NOT(NON.NUMERIC.CONV) THEN ED2CONV = OCONV(ED2,CONV)
IF FLD GT ED2 THEN STAT = TRUE; TEXT = "Your entry should be no more than ":ED2CONV:" please"
*
CASE ED1 EQ "NC"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter it in cents only" ELSE
IF NOT(DEFAULT.USED) THEN RSP = RSP / 100
END
*
CASE ED1 EQ "ND"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter it in dollars and cents"
*
CASE ED1 EQ "NU"
TEMP = RSP[LEN(RSP),ONE]; IF TEMP EQ " " OR TEMP EQ "-" THEN RSP = TRIM(TEMP):RSP[ONE,LEN(RSP) - ONE]
IF NOT(NUM(RSP)) THEN STAT = TRUE; TEXT = "Please enter a number"
*
CASE ED1 EQ "DT"
IF RSP NE EMPTY THEN TEMP = RSP; CALL GET.ICONV(TEMP,"D"); IF TEMP EQ EMPTY THEN STAT = TRUE; TEXT = "Enter a date please"
*
CASE ED1 EQ "DD"; IF RSP EQ EMPTY THEN RSP = OCONV(DATE(),"D0.")
*
CASE ED1 EQ "TM"; IF RSP EQ EMPTY THEN RSP = OCONV(TIME(),"MT")
*
CASE ED1 EQ "LF"
IF RSP MATCHES "0N" OR RSP MATCHES "0N'#'" OR RSP MATCHES "0N'+'" THEN
IF ED3 EQ EMPTY THEN RSP = ED2:RSP ELSE RSP = STR(ED2,ED3-LEN(RSP)):RSP
END
*
CASE ED1 EQ "RF"
IF ED3 EQ EMPTY THEN RSP = ED2:RSP ELSE IF NUM(RSP) OR NOT(NUM(ED3)) THEN RSP = RSP:STR(ED2,ED3-LEN(RSP))
*
CASE ED1 EQ "FI"; READV DUMMY FROM EDIT.FILE,RSP,ONE ELSE STAT = TRUE; TEXT = "Sorry, that's not a valid entry - please check your documentation"
*
CASE ED1 EQ "FF"
FIXED.FIELD = TRUE
*
CASE ED1 EQ "DF"
IF RSP EQ EMPTY AND NOT(CLEAR.FLAG) THEN
IF ED2[ONE,ONE] NE "*" THEN RSP = ED2 ELSE
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV RSP FROM EDIT.FILE,ED3,ED4 ELSE RSP = EMPTY
END
END
*
CASE ED1 EQ "EQ"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
TEXT = EMPTY; SCAN.VC = ONE; IF COUNT(ED,VM) THEN SCAN.SC = ZERO ELSE SCAN.SC = ONE
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC>[ONE,LHM] UNTIL TEMP EQ RSP OR TEMP EQ EMPTY DO
TEXT = TEXT:TEMP:", "; IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
IF TEMP NE EMPTY THEN RETURN
TEXT = TEXT[ONE,LEN(TEXT) - TWO]
STAT = TRUE
IF LEN(TEXT) GT 65 THEN
IF LEN(TEXT) - COUNT(TEXT,", ") GT 65 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",ONE) WHILE POS DO TEXT = TEXT[ONE,POS]:TEXT[POS + TWO,999] REPEAT
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[ONE,POS - ONE]:" or":TEXT[POS + ONE,999]
END
TEXT = "Please use ":TEXT
*
CASE ED1 EQ "MA"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
TEXT = EMPTY; SCAN.VC = ONE; IF COUNT(ED,SVM) THEN SCAN.SC = ONE ELSE SCAN.SC = ZERO
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC> UNTIL RSP MATCHES TEMP OR TEMP EQ EMPTY DO
TEXT<-ONE> = TEMP; IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
IF TEMP NE EMPTY THEN RETURN
STAT = TRUE; TEXT = AM:TEXT
LOOP OLD.TEMP = TEXT<TWO> UNTIL OLD.TEMP EQ EMPTY DO
POS = ONE; NUMERALS = EMPTY; ALL.QUOTES = ONE; QUOTES = EMPTY; TEMP = EMPTY
LOOP CHAR = OLD.TEMP[POS,ONE] UNTIL CHAR EQ EMPTY DO
BEGIN CASE
CASE CHAR EQ "'"; IF QUOTES THEN QUOTES = EMPTY ELSE QUOTES = ONE
CASE QUOTES; TEMP = TEMP:CHAR
CASE CHAR MATCHES "1N"; NUMERALS = NUMERALS:CHAR; ALL.QUOTES = EMPTY
CASE CHAR EQ "A" OR CHAR EQ "N" OR CHAR EQ "X"
IF CHAR EQ "N" THEN CHAR = "9" ELSE IF CHAR EQ "A" THEN CHAR = "X" ELSE CHAR = "x"
IF NOT(NUMERALS) THEN NUMERALS = LHM; IF NUMERALS GT 3 THEN NUMERALS = 3
TEMP = TEMP:STR(CHAR,NUMERALS); NUMERALS = EMPTY; ALL.QUOTES = EMPTY
CASE ONE; TEMP = TEMP:CHAR; ALL.QUOTES = EMPTY
END CASE
POS = POS + ONE
REPEAT
IF ALL.QUOTES THEN TEMP = "'":TEMP:"'"
DEL TEXT<TWO>; TEXT<ONE> = TEXT<ONE>:TEMP:", "
REPEAT
TEXT = TEXT[ONE,LEN(TEXT) - TWO]
IF LEN(TEXT) GT 60 THEN
IF LEN(TEXT) - COUNT(TEXT,", ") GT 60 THEN TEXT = "Please check your documentation for a valid entry"; RETURN
LOOP POS = INDEX(TEXT,", ",ONE) WHILE POS DO TEXT = TEXT[ONE,POS]:TEXT[POS + TWO,999] REPEAT
END
POS = COUNT(TEXT,","); IF POS THEN POS = INDEX(TEXT,",",POS); TEXT = TEXT[ONE,POS - ONE]:" or":TEXT[POS + ONE,999]
TEXT = "Please use format ":TEXT
*
END CASE
*
RETURN
*
!
*
ERROR.ADVICE: *
*
IF TEXT EQ EMPTY THEN RETURN
IF NOT(QUERY) THEN PRINT BELL:
IF LN NE 23 AND RSP.LN NE 23 THEN TMP1 = 23 ELSE TMP1 = 22
PRINT @(ZERO,TMP1):CLL:TEXT[ONE,78]:
CLEAR.BOTTOM.LINE = TMP1
IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
*TM = TIME
*LOOP
*INPUT TC FOR 100 ELSE ??
*WHILE TM + TM.MAX GT TIME() DO REPEAT
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN TO UNCON.RETURN ELSE PRINT CLB:
*
UNCON.RETURN: *
*
RETURN
*
!
*
QUERY.HELP: *
*
STAT = ONE
*
IF COUNT(FILE.NAME,"$") THEN
ITEM.NAME = FIELD(FILE.NAME,"$",TWO)
FILE.NAME = FIELD(FILE.NAME,"$",ONE)
END
*
IF COUNT(ITEM.NAME,"$") THEN
FILE.NAME = FIELD(ITEM.NAME,"$",ONE)
ITEM.NAME = FIELD(ITEM.NAME,"$",TWO)
END
*
IF COUNT(FILE.NAME,".") THEN
FILE.NAME = FIELD(FILE.NAME,".",ONE)
END
*
IF QUERY NE 3 THEN
OPEN "DICT",FILE.NAME TO FILE.DICT THEN
*
IF ITEM.NAME[ONE,ONE] EQ "<" THEN
ITEM.NAME = ITEM.NAME[TWO,9999]
ITEM.NAME = FIELD(ITEM.NAME,">",ONE)
ITEM.NAME = FIELD(ITEM.NAME,",",ONE)
END
*
IF ITEM.NAME EQ "ONE" THEN ITEM.NAME = "1"
*
READ DICT.ITEM FROM FILE.DICT,ITEM.NAME ELSE DICT.ITEM = EMPTY; QUERY = 3
*
END ELSE DICT.ITEM = EMPTY; QUERY = 3
END ELSE DICT.ITEM = EMPTY
*
* PRINT CLB:DICT.ITEM<13> "L#79":
IF QUERY EQ ONE THEN QUERY.TEXT = DICT.ITEM<12>; IF NOT(LEN(QUERY.TEXT)) THEN QUERY = TWO
IF QUERY EQ TWO THEN QUERY.TEXT = DICT.ITEM<21>; IF NOT(LEN(QUERY.TEXT)) THEN QUERY = 3
IF QUERY EQ 3 THEN
GOSUB LOAD.EDITS
QUERY.TEXT = DICT.ITEM<13>
QUERY.TEXT<ONE,-ONE> = DICT.ITEM<11>
IF LEN(QT) THEN QUERY.TEXT<ONE,-ONE> = VM:VM:QT
END
*
QUERY.CN.MAX = DCOUNT(QUERY.TEXT,VM); QUERY.CN = ONE
*
IF QUERY.CN.MAX GT 5 THEN
REDISP = TRUE
PRINT @(ZERO,4):CLS:
PRINT @(ZERO,5):"   ":RVB:"File: ":FILE.NAME "L#5":"   Field: ":DICT.ITEM<TWO> "L#3":"   English: ":DICT.ITEM<3> "L#15":"   Name: ":DICT.ITEM<13> "L#19":RVE:
LOOP
FOR TMP.LN = 6 TO 20 UNTIL QUERY.CN GT QUERY.CN.MAX
PRINT @(ZERO,TMP.LN):"   ":QUERY.TEXT<ONE,QUERY.CN> "L#70":
QUERY.CN = QUERY.CN + ONE
NEXT TMP.LN
TMP = EMPTY
IF QUERY.CN LT QUERY.CN.MAX THEN
PRINT CLB:"Enter N(ext), P(rev), or <cr> to end: ":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
END ELSE
FOR TMP.LN = TMP.LN TO 20; PRINT @(ZERO,TMP.LN):CLL:; NEXT TMP.LN
END
IF TMP EQ "P" THEN
QUERY.CN = QUERY.CN - 30
IF QUERY.CN LE ONE THEN QUERY.CN = ONE
END
WHILE TMP EQ "N" OR TMP EQ "P" DO REPEAT
PRINT CLB:"Enter <cr> to resume: ":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
END ELSE IF QUERY.CN.MAX THEN
*
LOOP
IF LEN(QUERY.TEXT<ONE,QUERY.CN>) THEN
PRINT CLB:QUERY.TEXT<ONE,QUERY.CN> "L#70":" <cr>":
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
END
WHILE QUERY.CN LT QUERY.CN.MAX DO
QUERY.CN = QUERY.CN + ONE
REPEAT
PRINT CLB:
*
END; * OF GT 5
*
PRINT CLB:DICT.ITEM<13> "L#79":
IF LN NE 23 THEN CLEAR.BOTTOM.LINE = ONE; RETURN
*
RETURN
*
!
*
LOAD.EDITS: *
*
ED.VC = ONE; IF EDITS<ONE,ED.VC> EQ "SE" THEN SUPPRESS.ERROR.PRINT = ONE; ED.VC = ED.VC + ONE
QT = EMPTY
*
LOOP ED = EDITS<ONE,ED.VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>; ED2 = ED<ONE,ONE,TWO>; ED3 = ED<ONE,ONE,3>
*
IF ED1 NE EMPTY THEN IF ED1 MATCHES "2A" THEN
*
BEGIN CASE
*
CASE ED1 EQ "OP"
QT<ONE,-ONE> = "An entry is not mandatory here."
*
CASE ED1 EQ "RQ"
QT<ONE,-ONE> = "An entry is mandatory here."
*
CASE ED1 EQ "LO"
QT<ONE,-ONE> = "Your entry should be at least ":ED2:"."
*
CASE ED1 EQ "HI"
QT<ONE,-ONE> = "Your entry should be no more than ":ED2:"."
*
CASE ED1 EQ "NC"
QT<ONE,-ONE> = "Enter an amount in cents only."
*
CASE ED1 EQ "ND"
QT<ONE,-ONE> = "Enter an amount in dollars and cents."
*
CASE ED1 EQ "NU"
QT<ONE,-ONE> = "Enter a number."
*
CASE ED1 EQ "DT"
QT<ONE,-ONE> = "Enter a date."
*
CASE ED1 EQ "DD"
QT<ONE,-ONE> = "The system date will be used as a default."
*
CASE ED1 EQ "LF"
QT<ONE,-ONE> = "Your entry will be right justified in a field of ":ED3:" ":ED2:"'s."
*
CASE ED1 EQ "RF"
QT<ONE,-ONE> = "Your entry will be left justified in a field of ":ED3:" ":ED2:"'s."
*
CASE ED1 EQ "FF"
QT<ONE,-ONE> = "Your entry will be in a fixed instead of floating window."
*
CASE ED1 EQ "FI"
QT<ONE,-ONE> = "Your entry must already exist on file."
*
CASE ED1 EQ "DF"
IF ED2[ONE,ONE] NE "*" THEN
QT<ONE,-ONE> = ED2:" will be used if you do not make an entry."
END ELSE
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV TMP FROM EDIT.FILE,ED3,ED4 ELSE TMP = EMPTY
QT<ONE,-ONE> = TMP:" will be used if you do not make an entry."
END
*
CASE ED1 EQ "EQ"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
*
QTD = EMPTY; SCAN.VC = ONE; IF COUNT(ED,VM) THEN SCAN.SC = ZERO ELSE SCAN.SC = ONE
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC>[ONE,LHM] UNTIL TEMP EQ EMPTY DO
QTD<ONE,-ONE> = "     - ":TEMP
IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
*
IF QTD NE EMPTY THEN
QT<ONE,-ONE> = "Valid entries appear in the following list: ":VM:QTD
QTD = EMPTY
END
*
*
CASE ED1 EQ "MA"
IF NOT(ED2[ONE,ONE] EQ "*" OR ED2[ONE,ONE] EQ "@") THEN DEL ED<ONE,ONE,ONE> ELSE
IF ED2[ONE,ONE] EQ "*" THEN
ED4 = ED<ONE,ONE,4>; IF ED4 LT ONE THEN ED4 = ONE
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = EMPTY
END ELSE ED = FIELD(EDITS,"@",TWO); ED.VC = ED.VC + COUNT(ED,VM)
END
*
QTD = EMPTY; SCAN.VC = ONE; IF COUNT(ED,SVM) THEN SCAN.SC = ONE ELSE SCAN.SC = ZERO
LOOP TEMP = ED<ONE,SCAN.VC,SCAN.SC> UNTIL TEMP EQ EMPTY DO
QTD<ONE,-ONE> = TEMP
IF SCAN.SC THEN SCAN.SC = SCAN.SC + ONE ELSE SCAN.VC = SCAN.VC + ONE
REPEAT
*
IF QTD NE EMPTY THEN
SCAN.AC = ZERO
*
LOOP SCAN.AC = SCAN.AC + ONE; OLD.TEMP = QTD<ONE,SCAN.AC> UNTIL OLD.TEMP EQ EMPTY DO
POS = ONE; NUMERALS = EMPTY;
ALL.QUOTES = TRUE; QUOTES = FALSE; TEMP = EMPTY
*
LOOP CHAR = OLD.TEMP[POS,ONE] UNTIL CHAR EQ EMPTY DO
BEGIN CASE
CASE CHAR EQ "'"; IF QUOTES THEN QUOTES = FALSE ELSE QUOTES = TRUE
CASE QUOTES; TEMP = TEMP:CHAR
CASE CHAR MATCHES "1N"; NUMERALS = NUMERALS:CHAR; ALL.QUOTES = FALSE
CASE CHAR EQ "A" OR CHAR EQ "N" OR CHAR EQ "X"
IF CHAR EQ "N" THEN CHAR = "9" ELSE IF CHAR EQ "A" THEN CHAR = "X" ELSE CHAR = "x"
IF NOT(NUMERALS) THEN NUMERALS = LHM; IF NUMERALS GT 3 THEN NUMERALS = 3
TEMP = TEMP:STR(CHAR,NUMERALS); NUMERALS = EMPTY; ALL.QUOTES = FALSE
CASE ONE; TEMP = TEMP:CHAR; ALL.QUOTES = FALSE
END CASE
POS = POS + ONE
REPEAT
*
IF ALL.QUOTES THEN TEMP = "'":TEMP:"'"
QTD<ONE,SCAN.AC> = "     - ":TEMP
REPEAT
*
QT<ONE,-ONE> = "Valid entries must match one of the following masks: ":VM:QTD
QTD = EMPTY
*
END; * of QTD
*
END CASE
*
END; * of 2A
*
ED.VC = ED.VC + ONE
*
REPEAT
*
QT<ONE,-ONE> = "Enter no more than ":LHM:" characters."
*
RETURN
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
*
END
~INPUT.DATA.TEST~
*PROGRAM: INPUT.DATA.TEST 
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "PAR" TO PAR.FILE ELSE STOP
*
READ CURSOR.KEYS FROM PAR.FILE,"CURSOR.KEYS" ELSE STOP
*
*
LOOP
*
FILE.NAME = "PAR"
ITEM.NAME = "TEST"
ITEM = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ZYXWVUTSRQPONMLKJIHGFEDCBA"
CL = 10
LN = 15
LH = "L25"
LHM = "100"
LOCN = "1"
CONV = ""
EDITS = ""
EDIT.FILE = ""
RSP = ""
REDISP = FALSE
NUMC = TRUE
TC.FUNC = FALSE
RSP.CL = 15
RSP.LN = 20
TC.FILL = "."
STD.SUBR.NAME = EMPTY
STAT = FALSE
*
*
CALL INPUT.DATA.SG1(FILE.NAME,ITEM.NAME,ITEM,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,REDISP,TT,CURSOR.KEYS,NUMC,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,STAT)
*
WHILE RSP NE "KILL" DO REPEAT
*
PRINT
PRINT
PRINT
PRINT RSP
PRINT
*
*
END
~INSTALL.KBIL~
*PROGRAM: INSTALL.KBIL 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
*                    *CUSTOM* LINES HAVE BEEN INSERTED...
* DATE WRITTEN:      20 APR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "MODEL.CNT" TO MODEL.CNT.FILE ELSE TEXT = "Can't open MODEL.CNT"; GOSUB ERROR; STOP
OPEN "MD" TO MD.FILE ELSE TEXT = "Can't open MD"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(4)
VALID.REFS = "AA":AM:"DS":AM:"SU":AM:"SA"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
MODEL.CNT.ID = ""; GOSUB GET.KEY; IF MODEL.CNT.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(MODEL.CNT.FILE,"MODEL.CNT",MODEL.CNT.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ MODEL.CNT FROM MODEL.CNT.FILE,MODEL.CNT.ID THEN NEW = "" ELSE NEW = 1; MODEL.CNT = ""
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = MODEL.CNT.ID; MODEL.CNT.ID = "!":MODEL.CNT.ID; GOSUB GET.KEY; MODEL.CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 4
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE MODEL.CNT.FILE,MODEL.CNT.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = MODEL.CNT.ID; MODEL.CNT.ID = "!":MODEL.CNT.ID; GOSUB GET.KEY; MODEL.CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE MODEL.CNT ON MODEL.CNT.FILE,MODEL.CNT.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(MODEL.CNT.FILE,"MODEL.CNT",MODEL.CNT.ID,LCK.FILE)
GOSUB SETUP.INSTALL; *CUSTOM*
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                         Install KBIL in a user account                         ":RVE:
PRINT @(0,3):RVB:"AA> Administrative area..":RVE:
PRINT @(0,5):RVB:"DS> Description..........":RVE:
PRINT @(0,8):RVB:"SU> Number of subscribers":RVE:
PRINT @(0,9):RVB:"    (approximate)        ":RVE:
PRINT @(0,11):RVB:"SA> Saturation per cent..":RVE:
PRINT @(0,12):RVB:"    (approximate)        ":RVE:
PRINT @(0,15):RVB:"Notes: 1. Before using this option, create the account in SYSPROG               ":RVE:
PRINT @(0,16):RVB:"          using the CREATE-ACCOUNT verb.                                        ":RVE:
PRINT @(0,17):RVB:"       2. After, LOGTO the above admin area, and enter INSTALL.KBIL.admin       ":RVE:
PRINT @(0,18):RVB:"                . all files will be initialized                                 ":RVE:
PRINT @(0,19):RVB:"                . MODEL menus will be transferred                               ":RVE:
PRINT @(0,20):RVB:"                . MODEL control file items will be transferred                  ":RVE:
PRINT @(0,21):RVB:"                . MODEL master dictionary items will be transferred             ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(26,3):MODEL.CNT<1> "L#8":
PRINT @(26,5):MODEL.CNT<2> "L#25":
PRINT @(26,8):MODEL.CNT<3> "L#6":
PRINT @(26,11):MODEL.CNT<4> "L#2":
RETURN
!
GET.KEY: *
MODEL.CNT.ID = "INSTALL.KBIL"
RETURN
!
GET.DATA: *
ON REF GOSUB i01,i02,i03,i04
RETURN
!
i01: CALL INPUT.DATA(MODEL.CNT,26,3,"L8",1,"","","",RSP,STAT); RETURN
i02: CALL INPUT.DATA(MODEL.CNT,26,5,"L25",2,"","","",RSP,STAT); RETURN
i03: CALL INPUT.DATA(MODEL.CNT,26,8,"L6",3,"","MA0N","",RSP,STAT); RETURN
i04: CALL INPUT.DATA(MODEL.CNT,26,11,"L2",4,"","MA0N","",RSP,STAT); RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
* THE FOLLOWING ROUTINE IS *CUSTOM* ...
SETUP.INSTALL: *
ITM = "Q":AM:MODEL.CNT<1>:AM:"MD"
WRITE ITM ON MD.FILE, "QFILE"
READ FILE.LIST FROM MD.FILE, "KBIL.FILES" ELSE
PRINT "The file list KBIL.FILES is missing from your MD!"
STOP
END
READ AX.FILE.LIST FROM MD.FILE, "AX.FILES" ELSE
PRINT "The file list AX.FILES is missing from your MD!"
STOP
END
OPEN "QFILE" TO Q.FILE ELSE PRINT MODEL.CNT<1>:" not set up yet":; INPUT RSP:; STOP
FILE.CN.MAX = DCOUNT(FILE.LIST,AM)
FOR FILE.CN = 1 TO FILE.CN.MAX
FILE.NAME = FILE.LIST<FILE.CN>
ITM = "Q":AM:"PROGRAMS":AM:FILE.NAME:",":MODEL.CNT<1>:".":FILE.NAME:AM:AM:AM:AM:AM:AM:"L":AM:"15"
WRITE ITM ON Q.FILE,FILE.NAME
NEXT FILE.CN
*#
FILE.CN.MAX = DCOUNT(AX.FILE.LIST,AM)
FOR FILE.CN = 1 TO FILE.CN.MAX
FILE.NAME = AX.FILE.LIST<FILE.CN>
ITM = "Q":AM:"PROGRAMS":AM:FILE.NAME:AM:AM:AM:AM:AM:AM:"L":AM:"30"
WRITE ITM ON Q.FILE,FILE.NAME
NEXT FILE.CN
*#
OPEN "PL" TO PL.FILE ELSE PRINT "Can't find PL":; INPUT RSP:; STOP
READ ITM FROM PL.FILE, "MODEL.INSTALL" ELSE PRINT "Can't find MODEL.INSTALL":; INPUT RSP:; STOP
MD.ID = "INSTALL.KBIL.":MODEL.CNT<1>
WRITE ITM ON Q.FILE, MD.ID
EXLN = 'SELECT QFILE = "':MD.ID:'"'
EXECUTE EXLN, //SELECT. > SLCT
EXLN = 'RUN BP.UTL MODEL.CUSTOMIZE'
EXECUTE EXLN, //SELECT. < SLCT, //IN. < "QFILE"
PRINT @(0,23):CLL:"Log to ":MODEL.CNT<1>:", then enter ":MD.ID:"      Press return ":; INPUT RSP:
RETURN
!
END
~LISTDICT~
*PROGRAM: LISTDICT 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       LIST DICTIONARIES OF ALL FILES IN LIST 'GL.FILES'
* DATE WRITTEN:      27 JUL 84
* DATE RELEASED:     27 JUL 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
TITLE = "List G/L dictionaries"
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
PRINT @(10,8):CLL:"Enter name of list: ":; INPUT LIST.ID
EXECUTE "GET-LIST ":LIST.ID
!
NXT: *
READNEXT ID ELSE STOP
PRINT @(10,10):CLL:"now printing dictionary for ":ID:"....":
EXECUTE 'SORT DICT D/CODE A/AMC S/NAME S/AMC V/CONV V/CORR V/TYP V/MAX WITH D/CODE "A""X" BY A/AMC BY D/CODE BY *A0 ':ID:' (P)'
GOTO NXT
!
END
~LOAD.FILE.MODULO~
*PROGRAM: COUNT.DATAS 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT
PRINT "MOVE TO MINIMUM (Y/N)? "
INPUT MIN.FLAG
IF MIN.FLAG EQ "KILL" THEN STOP
IF MIN.FLAG EQ "Y" THEN MIN.FLAG = 1 ELSE MIN.FLAG = ""
*
*
OPEN "CNT" TO BP.FILE ELSE STOP
OPEN "MD" TO MDI.FILE ELSE STOP
READ FILE.INDEX FROM BP.FILE,"FILES" ELSE STOP
FMAX = DCOUNT(FILE.INDEX<1>,VM)
FOR CN = 1 TO FMAX
OPEN "DICT",FILE.INDEX<1,CN> TO DI.FILE THEN OK=1 ELSE OK=""
IF OK THEN
READ DICT.ITEM FROM MDI.FILE,FILE.INDEX<1,CN> ELSE OK = ""
IF OK THEN
READ DATA.ITEM FROM DI.FILE,"DL/ID" ELSE OK = ""
END
END
IF OK THEN
FILE.DICT.MOD = DICT.ITEM<3>
FILE.DATA.MOD = DATA.ITEM<3>
PRINT CN "R#3":") ":FILE.INDEX<1,CN> "L#15"
*FILE.INDEX<2,CN> = ACCT
*FILE.INDEX<4,CN> = ICOUNT
*FILE.INDEX<6,CN> = ISIZE
IF MIN.FLAG AND FILE.DATA.MOD GT FILE.INDEX<7,CN> AND NUM(FILE.DATA.MOD) THEN
FILE.INDEX<7,CN> = FILE.DATA.MOD
END
IF NUM(FILE.DICT.MOD) THEN
FILE.INDEX<8,CN> = FILE.DICT.MOD
END
IF NUM(FILE.DATA.MOD) THEN
FILE.INDEX<9,CN> = FILE.DATA.MOD
END
END; * OF OK
NEXT CN
WRITE FILE.INDEX ON BP.FILE,"FILES"
END
~LOCK.ITEM~
SUBROUTINE LOCK.ITEM(ITEM.FILE,FILE.NAME,ITEM.ID,LCK.FILE,LCK.STAT)
* VERSION: 950427 3.0  DO NOT PROMPT FOR INPUT IF No INPUT TYPE.
* PRIOR: 930312 2.8  SCREEN I/O FOR REV LOCKING ADDED BY DH.
* PRIOR: 910917 261  MAJOR CHANGES MADE BY DH
* (ITEM.FILE,FILE.NAME,ITEM.ID,LCK.FILE,RETRY,DISP,INPT,OVERRIDE,LCK.STAT)
* PRIOR: 900415 1.9
* PROGRAM:           LOCK.ITEM
* AUTHOR:            DAVID HORSMAN - AXION
* DESCRIPTION:       LOCK AN ITEM
*
* PASSED TO CALLING PROGRAM:
*     LCK.STAT      MEANING
*     ____      __________________________________
*        0      SUCCESSFULLY LOCKED
*      nnn      ALREADY LOCKED AT TERMINAL nnn - 1
*      900      SYSTEM LEVEL LOCK PRESENT
*      999      OPERATOR 'KILL' REQUEST
*
* IF RSP EQ 'OVERRIDE'    -   OPERATOR 'OVERRIDE' REQUEST
* 'RETRY' MEANS RETRYING TO LOCK *** WITHIN THIS PROGRAM ***
* 'T/O' MEANS A THREE SECOND TIMEOUT BEFORE RETRYING
*
* PASSED TO THIS PROGRAM BY LCK.STAT: 
*       ZERO = Normal: RETRY, MSG, INPUT (T/O)
*       -ONE = No RETRY if already locked, MSG, INPUT (IMMED)
*       -TWO = No RETRY, MSG, INPUT <cr> if locked (IMMED)
*       -3   = RETRY, MSG, No INPUT if already locked (T/O)
*       -4   = No RETRY, MSG, No INPUT if already locked (IMMED)
*       -5   = No RETRY, No MSG, No INPUT if already locked (IMMED)
*       -6   = No RETRY, No MSG, No INPUT, OVERRIDE if locked (IMMED) ** DANGEROUS **
*       -7   = RETRY, No MSG, No INPUT, OVERRIDE if locked (T/O) ** DANGEROUS **
*
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LOCKS.VAR.EQUATES
*
LCK.TYPE = LCK.STAT
IF COUNT(FILE.NAME,"#") THEN
LCK.PROG.NAME = FIELD(FILE.NAME,"#",TWO)
FILE.NAME = FIELD(FILE.NAME,"#",ONE)
END ELSE LCK.PROG.NAME = EMPTY
LCK.ID = FILE.NAME:"*":ITEM.ID
!
READ.IT: * ATTEMPT TO READ THE LOCK ITEM
*
MSG = EMPTY; TRY.CN = 1
*
LOOP
*
IF MSG NE EMPTY THEN IF LCK.TYPE GE -4 THEN
PRINT CLB2:MSG:; * of TYPE
PRINT CLB1:"Lock attempt no. ":TRY.CN-ONE:; * of TYPE
END; * of TYPE
IF MSG NE EMPTY AND LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
*
LCK.LOCKED = FALSE
*
* LOCK ITEM.FILE, ITEM.ID THEN; * REV ONLY
* GOTO LCK.IT; * REV ONLY
* END ELSE; * REV ONLY
* MSG = FILE.NAME:" ":ITEM.ID:" in use."; * REV ONLY
* GOSUB LCK.IT; * REV ONLY
* IF STATUS() NE ONE THEN; * REV ONLY
* LCK.REC<LOCKS$ACCT.NAME> = "UNKNOWN"; * REV ONLY
* LCK.REC<LOCKS$PORT> = 999; * REV ONLY
* END; * REV ONLY
* END; * REV ONLY
*
* ULT ONLY
READU LCK.REC FROM LCK.FILE,LCK.ID LOCKED LCK.LOCKED = TRUE ELSE GOTO LCK.IT
*
IF LCK.LOCKED THEN LCK.REC = EMPTY 
*
IF LCK.REC<LOCKS$PORT> EQ PORT THEN
MSG = "Lock is already present for this port!"
* IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
* IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[????]":RVE:
GOTO LCK.IT
END
*
* ULT ONLY
IF NOT(LCK.LOCKED) THEN RELEASE LCK.FILE,LCK.ID
*
IF LCK.LOCKED THEN
*
MSG = "LOCKS control information is not available yet . . . "
LCK.STAT = 900
*
END ELSE
*
IF OPSYS NE "R" THEN
*
PORT.NUM = LCK.REC<LOCKS$PORT>
ACCT.NUM = LCK.REC<LOCKS$ACCT.NAME>
LCK.DATE = LCK.REC<LOCKS$LCK.DATE>
LCK.TIME = LCK.REC<LOCKS$LCK.TIME>
LCK.ELP = ((DATE() - LCK.DATE) * 86400) + (TIME() - LCK.TIME)
IF LCK.ELP GT 7200 THEN
MSG = "Lock item is ":OCONV(LCK.ELP,"MTS"):" hours old and has expired."
IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[EXPR]":RVE:
GOTO LCK.IT
END
*
LCK.DATE = OCONV(LCK.DATE,"D2")
LCK.DATE = FIELD(LCK.DATE," ",ONE):" ":FIELD(LCK.DATE," ",2)
*
LCK.TIME.DISP = OCONV(LCK.TIME,"MTS")
*
MSG = FILE.NAME:" ":ITEM.ID:" in use by ":PORT.NUM:" ":ACCT.NUM:" (":LCK.DATE:" ":LCK.TIME.DISP:" for ":OCONV(LCK.ELP,"MTS"):")"
*
END; * OF OPSYS NOT 'R'
*
LCK.STAT = PORT.NUM + ONE
*
IF LCK.TYPE EQ -ONE OR LCK.TYPE EQ -TWO OR (LCK.TYPE LE -4 AND LCK.TYPE GE -6) THEN TRY.CN = 999
*
END; * of lock not locked
*
NEXT.TRY: *
*
* WHILE TRY.CN LT 5 DO; * REV ONLY
* ULT ONLY
WHILE TRY.CN LT 5 AND NOT(SYSTEM(11)) DO
IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
TRY.CN = TRY.CN + ONE
FOR COUNTER = ONE TO 3
RQM
NEXT COUNTER
REPEAT
*
IF LCK.TYPE LE -6 AND LCK.TYPE GE -7 AND OPSYS NE "R" THEN
MSG = "Lock OVERRIDE in effect. Now locked by your port"; * of TYPE
GOTO LCK.IT; * of TYPE
END; * of TYPE
*
IF LCK.TYPE GE -4 THEN
PRINT CLB1:MSG:; * of TYPE
PRINT CLB2:"Can't lock this information.":; * of TYPE
END; * of TYPE
IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[FAIL]":RVE:
IF LCK.TYPE EQ -TWO THEN
PRINT BELL:" Enter <cr>: ":
END
*
IF LCK.TYPE LE -TWO THEN GOTO RELEASE.IT
*
RQM; RQM
PRINT BELL:CLB1:MSG:
* ULT ONLY
PRINT CLB2:"Try to lock it again (<cr>/N/OVERRIDE)? ":
* PRINT CLB2:"Try to lock it again (<cr>/N)? ":; * REV ONLY
* ULT ONLY
INPUTCLEAR
IF LCK.TYPE GE -2 THEN INPUT RSP:; IF RSP EQ "KILL" THEN LCK.STAT = 999; GOTO RELEASE.IT
IF RSP EQ "OVERRIDE" AND OPSYS NE "R" THEN
* ULT ONLY
DELETE LCK.FILE,LCK.ID
* ULT ONLY
PRINT CLB1:CLB2:; GOTO READ.IT
END
IF RSP NE "N" THEN
IF MSG NE EMPTY AND LCK.TYPE GE -4 THEN PRINT CLB1:CLB2:
IF MSG NE EMPTY AND LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
GOTO READ.IT
END
*
GOTO RELEASE.IT
*
!
*
LCK.IT: * LOCK THE ITEM
*
IF MSG NE EMPTY AND LCK.TYPE GE -4 THEN
RQM; * of TYPE
PRINT CLB1:CLB2:; * of TYPE
END; * of TYPE
IF MSG NE EMPTY AND LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[LOCK]":RVE:
*
LCK.REC    = EMPTY
LCK.REC<LOCKS$PORT> = PORT
LCK.REC<LOCKS$ACCT.NAME> = ACCT
LCK.REC<LOCKS$LCK.DATE> = DATE()
LCK.REC<LOCKS$LCK.TIME> = TIME()
LCK.REC<LOCKS$LCK.TYPE> = LCK.TYPE
LCK.REC<LOCKS$MSG>       = MSG
LCK.REC<LOCKS$PROG.NAME> = LCK.PROG.NAME
*
* ULT ONLY
WRITE LCK.REC ON LCK.FILE,LCK.ID
*
LCK.STAT = FALSE
*
RETURN
*
!
*
RELEASE.IT: *
*
* ULT ONLY
RELEASE LCK.FILE,LCK.ID
*
RETURN
*
END
~LOCK.TEST~
*PROGRAM: LCK.TEST
*
*
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS!"; STOP 
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT!"; STOP 
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
*
LOOP
*
PRINT @(ZERO,ZERO):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28  - (((LEN(CO.NAME) + ONE) /  TWO))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
TITLE = "System Lock Test Utility"
PRINT @(ZERO,ONE):RVB:(SPACE(40 - (((LEN(TITLE) + ONE) / TWO))):TITLE) "L#80":RVE:
*
PRINT @(ZERO,3):
PRINT "        0   = Normal, RETRY, INPUT, SCREEN I/O (T/O)"
PRINT "        1   = RETRY allowed if already locked (IMMED)"
PRINT "        2   = No RETRY, INPUT <cr> if locked (IMMED)"
PRINT "        3   = No RETRY, no INPUT if already locked (T/O)"
PRINT "        4   = No RETRY, no INPUT if already locked (IMMED)"
PRINT "        5   = No RETRY, no SCREEN I/O if already locked (IMMED)"
PRINT "        6   = No RETRY, no SCREEN I/O, OVERRIDE if locked (IMMED)"
PRINT "        7   = No RETRY, no SCREEN I/O, OVERRIDE if locked (T/O)"
*
LOOP
PRINT @(5,12):CLL:"Enter the type of lock: ":; INPUT LCK.TYPE:
*
IF LCK.TYPE EQ "KILL" THEN LCK.TYPE = EMPTY
IF NOT(NUM(LCK.TYPE)) THEN LCK.TYPE = 999
*
WHILE LCK.TYPE NE EMPTY AND (LCK.TYPE GT 7 OR LCK.TYPE LT ZERO) DO
PRINT CLB:BELL:"Enter a number from 0 to 7 or <cr> to end":
REPEAT
*
*
WHILE LCK.TYPE NE EMPTY DO
*
*
CONT = TRUE
FOR LCK.CYCLE = ONE TO 100 UNTIL NOT(CONT)
*
PRINT @(ZERO,14):"Lock cycle ":LCK.CYCLE:" of 100.":
*
START.DT = DATE(); START.TM = TIME()
PRINT @(ZERO,16):CLL:RVB:"I will now lock the record.":RVE:
LOOP
CURR.DT = DATE(); CURR.TM = TIME()
LCK.STAT = -ABS(LCK.TYPE)
CALL LOCK.ITEM(CNT.FILE,"CNT","LCK.TEST",LCK.FILE,LCK.STAT)
* ULT ONLY
IF SYSTEM(11) THEN CONT = FALSE
WHILE ((CURR.DT - START.DT) * 86400) + (CURR.TM - START.TM) LT 20 AND LCK.STAT AND CONT DO
TMP = ((CURR.DT - START.DT) * 86400) + (CURR.TM - START.TM)
PRINT @(ZERO,17):CLL:RVB:"It is locked, will try for ":(20-TMP):" more seconds.":RVE:
REPEAT
*
PRINT @(ZERO,16):CLL:@(ZERO,17):CLL:
*
*
IF NOT(LCK.STAT) THEN
START.DT = DATE(); START.TM = TIME()
LOOP
CURR.DT = DATE(); CURR.TM = TIME()
TMP = ((CURR.DT - START.DT) * 86400) + (CURR.TM - START.TM)
PRINT @(ZERO,16):CLL:RVB:"I now have the record locked and will keep it for ":(10-TMP):" seconds":RVE:
* ULT ONLY
IF SYSTEM(11) THEN CONT = FALSE
WHILE ((CURR.DT - START.DT) * 86400) + (CURR.TM - START.TM) LT 10 AND CONT DO
RQM; * ULT ONLY
* FOR A = 1 TO 1000; NULL; NEXT A; * REV ONLY
REPEAT
*
CALL UNLOCK.ITEM(CNT.FILE,"CNT","LCK.TEST",LCK.FILE)
*
START.DT = DATE(); START.TM = TIME()
LOOP
CURR.DT = DATE(); CURR.TM = TIME()
TMP = ((CURR.DT - START.DT) * 86400) + (CURR.TM - START.TM)
PRINT @(ZERO,16):CLL:RVB:"Waiting for other terminal to lock record (":(5-TMP):")":RVE:
* ULT ONLY
IF SYSTEM(11) THEN CONT = FALSE
WHILE ((CURR.DT - START.DT) * 86400) + (CURR.TM - START.TM) LT 5 AND CONT DO 
RQM; * ULT ONLY
* FOR A = 1 TO 1000; NULL; NEXT A; * REV ONLY
REPEAT
*
END ELSE
PRINT @(ZERO,16):CLL:BELL:RVB:"I was not able to lock the record!":RVE:
END; * of not(lock.stat)
*
* ULT ONLY
IF SYSTEM(11) THEN CONT = FALSE
*
NEXT LCK.CYCLE
*
*
REPEAT; * for lock.type ne empty
*
CALL UNLOCK.ITEM(CNT.FILE,"CNT","LCK.TEST",LCK.FILE)
*
END
~LOGOFF.OTHERS~
*PROGRAM: LOGOFF.OTHERS 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       LOGS OFF ALL BUT 'THIS' LINE...
* DATE RELEASED:     10 AUG 84
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
THIS.PORT = PORT+0
OPEN "DICT","ACC" TO AC.FILE.D ELSE STOP
OPEN "ACC" TO AC.FILE ELSE STOP
EXECUTE 'SSELECT ACC < "A" WITH NAME.', //SELECT. > FILE.ID.LIST
100 READNEXT KEY FROM FILE.ID.LIST ELSE
PRINTER ON
PRINT CHAR(27):"[;12m":
PRINTER OFF
STOP
END
READV ACCT FROM AC.FILE,KEY,1 ELSE GO 100
PORT = OCONV(KEY,"U3079"); PORT = PORT[LEN(PORT)-1,2]+0
*
PORT.KEY = PORT + 0
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
READV PORT.DEF FROM AC.FILE.D,PORT.KEY ELSE PORT.DEF = EMPTY
PORT.NAME = PORT.DEF<ONE>
PORT.PARAMS = PORT.DEF<TWO>
PORT.TERM   = PORT.DEF<3>
*
HANDLER.PORT = INDEX(ACCT,"HANDLER",1)
IF PORT.NAME EQ "Axion" OR INDEX("*SECURITY*FC*PROGRAMS*SYSPROG*PKH*CABLE*","*":ACCT:"*",ONE) THEN DEV.PORT = TRUE ELSE DEV.PORT = FALSE
IF PORT NE THIS.PORT AND NOT(DEV.PORT) AND NOT(HANDLER.PORT) THEN
EXECUTE "LOGOFF", //IN. < PORT, //OUT. > TCL.MSG
PRINT "Line No. ":PORT:": ":TCL.MSG[7,LEN(TCL.MSG)-7]
END
GOTO 100
END
~LPT.CLOSE~
*PROGRAM: LPT.CLOSE
*
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESC: CLOSES PRINT JOBS
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LPT.INCL.CLOSE
*
STOP
*
END
~LPT.OFF~
*PROGRAM: LPT.OFF 
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LPT.INCL.OFF
*
STOP
*
END
~LPT.ON~
*PROGRAM: LPT.ON 
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LPT.INCL.ON
*
STOP
*
END
~LPT.OPEN~
*PROGRAM: LPT.OPEN
*
* SUBROUTINE LPT.SUBR.OPEN(PAR.FILE,PTY,PQUE,PQUE.FUNC,PTR.ON,PTR.OFF,REGF,COMF,C12.FONT,C12.FONT.CR,CRCOM78,CRCOM72,CRCOMF,LPI6,LPI8,LPT.STAT)
* VERSION: 
* PRIOR: 891028 NEW
* DESCRIPTION:       LOAD PRINTER SETTINGS
*
* AUTHOR: DAVID HORSMAN
*   DATE: 6 NOV 95
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*SETTERM
*
EXEC.BUFF = EMPTY; PTY.TYPE = "P"
*
!
*
IF PQUE NE EMPTY THEN
*
READ PQUE.REC FROM PAR.FILE,"PRINTER.Q":PQUE THEN
PTY = PQUE.REC<17>
EXEC.BUFF = PQUE.REC<11>
END ELSE
READ PQUE.REC FROM PAR.FILE,"PRINTER.":PQUE THEN
PTY = PQUE.REC<17>
EXEC.BUFF = PQUE.REC<11>
END ELSE NULL
END
*
*
END ELSE IF NUM(PTY) NE EMPTY THEN
*
IF PTY NE EMPTY THEN
READ PQUES FROM PAR.FILE,"PRINTER.QUE.NAMES" THEN
LOCATE PTY IN PQUES<ONE> BY "AR" SETTING LOC THEN
PQUE = PQUES<3,LOC>
IF PQUE NE EMPTY THEN
READ PQUE.REC FROM PAR.FILE,"PRINTER.":PQUE THEN
EXEC.BUFF = PQUE.REC<11>
PTY = PQUE.REC<17>
PTY.TYPE = "Q"
END ELSE NULL
END; * Of PQUE not empty
END ELSE NULL
END ELSE NULL
END; * Of PTY not empty
*
*
END
*
!
*
IF PTY = EMPTY THEN
BEGIN CASE
CASE OPSYS EQ "U"
PTY = "Q1"
CASE OPSYS EQ "M"
PTY = "STANDARD"
CASE TRUE
PTY = "REG"
END CASE
END
*
!
*
READ PCL FROM PAR.FILE,"PRINTER.":PTY ELSE PCL = EMPTY
IF PCL<11> EQ EMPTY THEN PCL<11> = EXEC.BUFF
*
*
PTR.ON = EMPTY; PTR.OFF = EMPTY; REGF = EMPTY; COMF = EMPTY; C12.FONT = EMPTY
*
LOOP UNTIL PCL<2> EQ EMPTY DO
PTR.ON = PTR.ON:CHAR(PCL<TWO,ONE>)
DEL PCL<TWO,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<3> EQ EMPTY DO
PTR.OFF = PTR.OFF:CHAR(PCL<3,ONE>)
DEL PCL<3,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<4> EQ EMPTY DO
REGF = REGF:CHAR(PCL<4,ONE>)
DEL PCL<4,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<5> EQ EMPTY DO
COMF = COMF:CHAR(PCL<5,ONE>)
DEL PCL<5,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<8> EQ EMPTY DO
LPI6 = LPI6:CHAR(PCL<8,ONE>)
DEL PCL<8,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<9> EQ EMPTY DO
LPI8 = LPI8:CHAR(PCL<9,ONE>)
DEL PCL<9,ONE,ZERO>
REPEAT
*
!
*
CRCOM78 = CR:COMF:SPACE(78)
CRCOM72 = CR:COMF:SPACE(72)
CRCOMF = CRCOM78:SPACE(8)
*
LOOP UNTIL PCL<10> EQ EMPTY DO
C12.FONT = C12.FONT:CHAR(PCL<10,ONE>)
DEL PCL<10,ONE,ZERO>
REPEAT
C12.FONT.CR = REGF:CR:C12.FONT
*
! Perform Assignment verbs for start and stop of job
*
IF PQUE.FUNC EQ "START" THEN
*
IF  LEN(PCL<11>) THEN
LOOP UNTIL NOT(LEN(PCL<11>)) DO
TMP = PCL<11,ONE>
EXEC.VERB = TMP<ONE,ONE,ONE>
DEL TMP<ONE,ONE,ONE>
EXEC.IN = TMP<ONE,ONE>
IF EXEC.IN EQ EMPTY THEN
* ULT ONLY
EXECUTE EXEC.VERB
END ELSE
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
END
DEL PCL<11,ONE>
REPEAT
END ELSE
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
EXECUTE 'SP-ASSIGN ':PTY
CASE OPSYS EQ "M"
EXECUTE 'SP-ASSIGN =':PQUE
CASE TRUE
NULL
END CASE
END
*
!
*
END ELSE IF PQUE.FUNC EQ "STOP" THEN
*
IF  LEN(PCL<18>) THEN
LOOP UNTIL NOT(LEN(PCL<18>)) DO
TMP = PCL<18,ONE>
EXEC.VERB = TMP<ONE,ONE,ONE>
DEL TMP<ONE,ONE,ONE>
EXEC.IN = TMP<ONE,ONE>
IF EXEC.IN EQ EMPTY THEN
* ULT ONLY
EXECUTE EXEC.VERB
END ELSE
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
END
DEL PCL<18,ONE>
REPEAT
*
END ELSE
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
EXECUTE 'SP-ASSIGN'
CASE OPSYS EQ "M"
EXECUTE 'SP-ASSIGN'
CASE TRUE
NULL
END CASE
END
*
END; * Of pque.func
*
* RETURN; * to calling program
*
STOP
END
~LPT.SUBR.CLOSE~
SUBROUTINE LPT.SUBR.CLOSE(LPT.STAT)
*
* PROGRAM:           LPT.SUBR.CLOSE
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       TURNS PRINTER ON
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LPT.INCL.CLOSE
*
RETURN
*
END
~LPT.SUBR.OFF~
SUBROUTINE LPT.SUBR.OFF(LPT.STAT)
*
* PROGRAM:           LPT.SUBR.OFF
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       TURNS PRINTER ON
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LPT.INCL.OFF
*
RETURN
*
END
~LPT.SUBR.ON~
SUBROUTINE LPT.SUBR.ON(LPT.STAT)
*
* PROGRAM:           LPT.SUBR.ON
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       TURNS PRINTER ON
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LPT.INCL.ON
*
RETURN
*
END
~LPT.SUBR.OPEN~
SUBROUTINE LPT.SUBR.OPEN(PAR.FILE,PTY,PQUE,PQUE.FUNC,PTR.ON,PTR.OFF,REGF,COMF,C12.FONT,C12.FONT.CR,CRCOM78,CRCOM72,CRCOMF,LPI6,LPI8,LPT.STAT)
* VERSION: 
* PRIOR: 891028 NEW
* DESCRIPTION:       LOAD PRINTER SETTINGS
*
* AUTHOR: DAVID HORSMAN
*   DATE: 6 NOV 95
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*SETTERM
*
EXEC.BUFF = EMPTY; PTY.TYPE = "P"
*
!
*
IF PQUE NE EMPTY THEN
*
READ PQUE.REC FROM PAR.FILE,"PRINTER.Q":PQUE THEN
PTY = PQUE.REC<17>
EXEC.BUFF = PQUE.REC<11>
END ELSE
READ PQUE.REC FROM PAR.FILE,"PRINTER.":PQUE THEN
PTY = PQUE.REC<17>
EXEC.BUFF = PQUE.REC<11>
END ELSE NULL
END
*
*
END ELSE IF NUM(PTY) NE EMPTY THEN
*
IF PTY NE EMPTY THEN
READ PQUES FROM PAR.FILE,"PRINTER.QUE.NAMES" THEN
LOCATE PTY IN PQUES<ONE> BY "AR" SETTING LOC THEN
PQUE = PQUES<3,LOC>
IF PQUE NE EMPTY THEN
READ PQUE.REC FROM PAR.FILE,"PRINTER.":PQUE THEN
EXEC.BUFF = PQUE.REC<11>
PTY = PQUE.REC<17>
PTY.TYPE = "Q"
END ELSE NULL
END; * Of PQUE not empty
END ELSE NULL
END ELSE NULL
END; * Of PTY not empty
*
*
END
*
!
*
IF PTY = EMPTY THEN
BEGIN CASE
CASE OPSYS EQ "U"
PTY = "Q1"
CASE OPSYS EQ "M"
PTY = "STANDARD"
CASE TRUE
PTY = "REG"
END CASE
END
*
!
*
READ PCL FROM PAR.FILE,"PRINTER.":PTY ELSE PCL = EMPTY
IF PCL<11> EQ EMPTY THEN PCL<11> = EXEC.BUFF
*
*
PTR.ON = EMPTY; PTR.OFF = EMPTY; REGF = EMPTY; COMF = EMPTY; C12.FONT = EMPTY
*
LOOP UNTIL PCL<2> EQ EMPTY DO
PTR.ON = PTR.ON:CHAR(PCL<TWO,ONE>)
DEL PCL<TWO,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<3> EQ EMPTY DO
PTR.OFF = PTR.OFF:CHAR(PCL<3,ONE>)
DEL PCL<3,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<4> EQ EMPTY DO
REGF = REGF:CHAR(PCL<4,ONE>)
DEL PCL<4,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<5> EQ EMPTY DO
COMF = COMF:CHAR(PCL<5,ONE>)
DEL PCL<5,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<8> EQ EMPTY DO
LPI6 = LPI6:CHAR(PCL<8,ONE>)
DEL PCL<8,ONE,ZERO>
REPEAT
*
LOOP UNTIL PCL<9> EQ EMPTY DO
LPI8 = LPI8:CHAR(PCL<9,ONE>)
DEL PCL<9,ONE,ZERO>
REPEAT
*
!
*
CRCOM78 = CR:COMF:SPACE(78)
CRCOM72 = CR:COMF:SPACE(72)
CRCOMF = CRCOM78:SPACE(8)
*
LOOP UNTIL PCL<10> EQ EMPTY DO
C12.FONT = C12.FONT:CHAR(PCL<10,ONE>)
DEL PCL<10,ONE,ZERO>
REPEAT
C12.FONT.CR = REGF:CR:C12.FONT
*
! Perform Assignment verbs for start and stop of job
*
IF PQUE.FUNC EQ "START" THEN
*
IF  LEN(PCL<11>) THEN
LOOP UNTIL NOT(LEN(PCL<11>)) DO
TMP = PCL<11,ONE>
EXEC.VERB = TMP<ONE,ONE,ONE>
DEL TMP<ONE,ONE,ONE>
EXEC.IN = TMP<ONE,ONE>
IF EXEC.IN EQ EMPTY THEN
* ULT ONLY
EXECUTE EXEC.VERB
END ELSE
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
END
DEL PCL<11,ONE>
REPEAT
END ELSE
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
EXECUTE 'SP-ASSIGN ':PTY
CASE OPSYS EQ "M"
EXECUTE 'SP-ASSIGN =':PQUE
CASE TRUE
NULL
END CASE
END
*
!
*
END ELSE IF PQUE.FUNC EQ "STOP" THEN
*
IF  LEN(PCL<18>) THEN
LOOP UNTIL NOT(LEN(PCL<18>)) DO
TMP = PCL<18,ONE>
EXEC.VERB = TMP<ONE,ONE,ONE>
DEL TMP<ONE,ONE,ONE>
EXEC.IN = TMP<ONE,ONE>
IF EXEC.IN EQ EMPTY THEN
* ULT ONLY
EXECUTE EXEC.VERB
END ELSE
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
END
DEL PCL<18,ONE>
REPEAT
*
END ELSE
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
EXECUTE 'SP-ASSIGN'
CASE OPSYS EQ "M"
EXECUTE 'SP-ASSIGN'
CASE TRUE
NULL
END CASE
END
*
END; * Of pque.func
*
RETURN; * to calling program
*
*
END
~MAINT.ACCS~
*PROGRAM: MAINT.ACCS 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      09 JUL 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "ACCS" TO ACCS.FILE ELSE TEXT = "Can't open ACCS"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
$INCLUDE IBP ACCS.DIM
$INCLUDE IBP ACCS.EQUATES
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(2)
VALID.REFS = "SZ":AM:"PA"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
ACCS.ID = ""; GOSUB GET.KEY; IF ACCS.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(ACCS.FILE,"ACCS",ACCS.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
MATREAD ACCS FROM ACCS.FILE,ACCS.ID THEN NEW = "" ELSE NEW = 1; MAT ACCS = ""
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = ACCS.ID; ACCS.ID = "!":ACCS.ID; GOSUB GET.KEY; ACCS.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 2
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE ACCS.FILE,ACCS.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = ACCS.ID; ACCS.ID = "!":ACCS.ID; GOSUB GET.KEY; ACCS.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
MATWRITE ACCS ON ACCS.FILE,ACCS.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(ACCS.FILE,"ACCS",ACCS.ID,LCK.FILE)
GOTO NEXT.ITEM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                 Account Disk Usage Statistics File Maintenance                 ":RVE:
PRINT @(0,3):RVB:"    PICK account..":RVE:
PRINT @(0,5):RVB:"SZ> Size (bytes)..":RVE:
PRINT @(0,6):RVB:"PA> Pad  (bytes)..":RVE:
PRINT @(0,7):RVB:"    Total used....":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(20,5):ACCS$SIZE<1> "L#7":
PRINT @(20,6):ACCS$PAD<1> "L#7":
GOSUB CUSTOM.DISPLAY; *CUSTOM*
RETURN
!
GET.KEY: *
CALL INPUT.DATA(ACCS.ID,20,3,"L16",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
RETURN
!
GET.DATA: *
ON REF GOSUB i01,i02
RETURN
!
i01: CALL INPUT.DATA(ACCS$SIZE,20,5,"L7",1,"","NU","",RSP,STAT); *CUSTOM*
GOSUB CUSTOM.DISPLAY; *CUSTOM*
RETURN; *CUSTOM*
i02: CALL INPUT.DATA(ACCS$PAD,20,6,"L7",1,"","NU","",RSP,STAT); *CUSTOM*
GOSUB CUSTOM.DISPLAY; *CUSTOM*
RETURN; *CUSTOM*
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
CUSTOM.DISPLAY: *
ACCS$PER.SZ = ACCS$SIZE / 3000
ACCS$PER.SZ = FIELD(ACCS$PER.SZ,".",1)
PRINT @(30,5):OCONV(ACCS$PER.SZ,"MR2ZM") "R#7":"%":
ACCS$PER.PAD = ACCS$PAD / 3000
ACCS$PER.PAD = FIELD(ACCS$PER.PAD,".",1)
PRINT @(30,6):OCONV(ACCS$PER.PAD,"MR2ZM") "R#7":"%":
ACCS$TOTAL = ACCS$SIZE+ACCS$PAD
PRINT @(20,7):ACCS$TOTAL<1> "L#7":
ACCS$PER.TOT = ACCS$TOTAL / 3000
ACCS$PER.TOT = FIELD(ACCS$PER.TOT,".",1)
PRINT @(30,7):OCONV(ACCS$PER.TOT,"MR2ZM") "R#7":"%":
RETURN
!
END
~MAINT.CONFIG~
*PROGRAM: MAINT.CONFIG 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      10 JUL 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
CUSTOM.START: *CUSTOM*
EXECUTE "SORT CFG 0 6 ID-SUPP"; *CUSTOM*
PRINT "Enter 'E' to end, SYS.NAME, LIst all, or <cr> to continue... ":; INPUT CFG.ID:; *CUSTOM*
IF CFG.ID = "E" OR CFG.ID = "KILL" OR CFG.ID = "END" THEN STOP; *CUSTOM*
IF CFG.ID = "LI" THEN EXECUTE "SORT CFG 0 2 3 4 5 6 ID-SUPP (P)"; GOTO CUSTOM.START; *CUSTOM*
IF CFG.ID # "" THEN CFG.ID = "!":CFG.ID; *CUSTOM*
OPEN "CFG" TO CFG.FILE ELSE TEXT = "Can't open CFG"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
$INCLUDE IBP CFG.DIM
$INCLUDE IBP CFG.EQUATES
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(1)
VALID.REFS = "IX"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
GOSUB GET.KEY; IF CFG.ID = "" THEN GOTO CUSTOM.START; *CUSTOM*
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(CFG.FILE,"CFG",CFG.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
MATREAD CFG FROM CFG.FILE,CFG.ID THEN NEW = "" ELSE NEW = 1; MAT CFG = ""
CUSTOM.SPLAT: *CUSTOM*
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = CFG.ID; CFG.ID = "!":CFG.ID; GOSUB GET.KEY; CFG.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
PRINT @(0,23):CLL:"Model after (SYS.NAME or <cr>)? ":; *CUSTOM*
INPUT MODEL.ID:; IF MODEL.ID = "KILL" THEN STAT = 999; GOTO UNLOCK; *CUSTOM*
IF MODEL.ID # "" THEN MATREAD CFG FROM CFG.FILE,MODEL.ID THEN NEW = ""; GOTO CUSTOM.SPLAT; *CUSTOM*
FOR REF = 1 TO 1
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter CHange, DElete, REdisplay, LIst, or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = "" OR RSP = "LI"; GOTO UPDATE; *CUSTOM*
CASE RSP = "DE"
PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE CFG.FILE,CFG.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = CFG.ID; CFG.ID = "!":CFG.ID; GOSUB GET.KEY; CFG.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
MATWRITE CFG ON CFG.FILE,CFG.ID
UPDATED = 1
IF RSP # "" THEN; *CUSTOM*
IF RSP = "LI" THEN EXECUTE 'LIST CFG "':CFG.ID:'" 0 2 3 4 5 6 ID-SUPP (P)'; *CUSTOM*
END; *CUSTOM*
!
UNLOCK: *
CALL UNLOCK.ITEM(CFG.FILE,"CFG",CFG.ID,LCK.FILE)
CFG.ID = ""; *CUSTOM*
GOTO NEXT.ITEM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                         System Disk Usage Configurator                         ":RVE:
PRINT @(0,3):RVB:"System type":RVE:"                             ":RVB:"    Total megs":RVE:
PRINT @(0,5):RVB:"Index":RVE:"   ":RVB:"Description":RVE:"                     ":RVB:"Megs per":RVE:"  ":RVB:"...#":RVE:"      ":RVB:"Megs used":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
GOSUB CUSTOM.TOTAL; *CUSTOM*
DYNAMIC = ""; GOSUB d01; IF STAT = 999 THEN RETURN
GOSUB CUSTOM.TOTAL; *CUSTOM*
RETURN
!
GET.KEY: *
CALL INPUT.DATA(CFG.ID,13,3,"L16",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
RETURN
!
GET.DATA: *
ON REF GOSUB i01
RETURN
!
i01:  PRINT @(0,23):CLL:"Enter Index: ":
FLD = ""; CALL INPUT.DATA(FLD,13,23,"L3",1,"","SEOPLF03MA0N","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i01
IF FLD = "" THEN RETURN
LOCATE FLD IN CFG$INDEX<1> BY "AR" SETTING VC THEN
PRINT @(0,23):CLL:FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT @(0,23):CLL: ELSE
DEL CFG$INDEX<1,VC>
DEL CFG$DESC<1,VC>
DEL CFG$MEGS.PER<1,VC>
DEL CFG$NUM<1,VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
DYNAMIC = "D"; GOSUB d01; IF STAT = 999 THEN RETURN
GOTO i01
END
END ELSE
IF CFG$INDEX<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO i01
END
INS FLD BEFORE CFG$INDEX<1,VC>
INS "" BEFORE CFG$DESC<1,VC>
INS "" BEFORE CFG$MEGS.PER<1,VC>
INS "" BEFORE CFG$NUM<1,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB d01; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,15)+6
FOR SUB.REF = 1 TO 3
ON SUB.REF GOSUB i01B,i01C,i01D
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 4
NEXT SUB.REF
GOSUB CUSTOM.EXTEND; *CUSTOM*
GOSUB CUSTOM.TOTAL; *CUSTOM*
GOTO i01
i01A: CALL INPUT.DATA(CFG$INDEX,0,LN,"L3",1:",":VC,"","LF03MA0N","",RSP,STAT)
RETURN
i01B: CALL INPUT.DATA(CFG$DESC,8,LN,"L30",1:",":VC,"","","",RSP,STAT)
RETURN
i01C: CALL INPUT.DATA(CFG$MEGS.PER,40,LN,"R8",1:",":VC,"MR2ZM","OPNU","",RSP,STAT)
RETURN
i01D: CALL INPUT.DATA(CFG$NUM,50,LN,"R4",1:",":VC,"","OPMA0N","",RSP,STAT)
RETURN
d01: SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+14 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,15)+6; PRINT @(0,LN):CFG$INDEX<1,VC> "L#3":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,15); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 6 TO 20 UNTIL CFG$INDEX<1,VC> = ""
IF LN = 6 THEN TOP.LOC = VC
PRINT @(0,LN):CFG$INDEX<1,VC> "L#3":
PRINT @(8,LN):CFG$DESC<1,VC> "L#30":
PRINT @(40,LN):OCONV(CFG$MEGS.PER<1,VC>,"MR2ZM") "R#8":
PRINT @(50,LN):CFG$NUM<1,VC> "R#4":
GOSUB CUSTOM.EXTEND; *CUSTOM*
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR CFG$INDEX<1,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 6; GOSUB c01 REPEAT
IF CLEAR THEN GOSUB c01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
c01: FOR LN = LN TO 20
PRINT @(0,LN):SPACE(3):
PRINT @(8,LN):SPACE(30):
PRINT @(40,LN):SPACE(8):
PRINT @(50,LN):SPACE(4):
PRINT @(60,LN):SPACE(8):; *CUSTOM*
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
CUSTOM.EXTEND: *
CFG$MEGS.TOT<1,VC> = CFG$MEGS.PER<1,VC> * CFG$NUM<1,VC>
PRINT @(60,LN):OCONV(CFG$MEGS.TOT<1,VC>,"MR2ZM") "R#8":
RETURN
!
CUSTOM.TOTAL: *
CFG$SYSTEM.TOTAL = 0; CUSTOM.VC = 0
LOOP CUSTOM.VC = CUSTOM.VC+1 UNTIL CFG$INDEX<1,CUSTOM.VC> = "" DO
CFG$SYSTEM.TOTAL = CFG$SYSTEM.TOTAL+CFG$MEGS.TOT<1,CUSTOM.VC>
REPEAT
PRINT @(60,3):OCONV(CFG$SYSTEM.TOTAL,"MR2ZM") "R#8":
RETURN
!
END
~MAINT.CONTROL.DATE~
SUBROUTINE MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
* PROGRAM:           MAINT.CONTROL.DATE
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       MAINTAIN CONTROL DATE
* DATE WRITTEN:      DD MMM 82
* DATE RELEASED:     DD MMM 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
CO.NAME = CO.DATA<1,1,1>; OLD.CONTROL.DATE = CO.DATA<2,1,1>
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":("Port ":PORT:SPACE(LEN(ACCT)-2)) "R#20":
PRINT @(0,1):OCONV(TIME(),"MTS") "L#15":(SPACE(16):"Set Time and Date") "L#50":("Acct ":ACCT) "R#15":RVE:
*
DATE.CHANGE = ""; TIME.CHANGE = ""
IF NOT(CO.DATA<4>) THEN CONTROL.DATE = DATE() ELSE CONTROL.DATE = CO.DATA<2,1,1>
LOOP
* GOSUB DISPLAY.TIME.AND.DATE; GOTO ENTER.ARE.YOU.SURE; * REV ONLY
LOOP
CLS.COL = 20; CLS.ROW = 7; GOSUB CLS.ROUTINE
TMP = OCONV(DATE(),"D2")
IF CO.DATA<4> THEN TMP = OCONV(OLD.CONTROL.DATE,"D2")
PRINT "Enter the correct date: ":TMP:@(44,7):
INPUT CONTROL.DATE:
IF CONTROL.DATE = "" THEN
IF NOT(CO.DATA<4>) THEN
CONTROL.DATE = DATE(); DATE.CHANGE = 0
END ELSE CONTROL.DATE = OLD.CONTROL.DATE; DATE.CHANGE = 0
END ELSE CALL GET.ICONV(CONTROL.DATE,"D"); DATE.CHANGE = 1
IF NOT(CONTROL.DATE) THEN PRINT BELL: ELSE
IF CONTROL.DATE < OLD.CONTROL.DATE THEN
PRINT @(20,10):CLL:"The prior setting of the system date is ":OCONV(OLD.CONTROL.DATE,"D"):".":
LOOP
* CLEARDATA; * REV ONLY
PRINT @(20,11):CLL:"Are you sure that the above date is correct (Y/N)? ":
INPUT RSP:
UNTIL RSP = "Y" OR RSP = "N" DO PRINT BELL: REPEAT
PRINT @(20,10):CLL:@(20,11):CLL:
IF RSP = "N" THEN CONTROL.DATE = ""
END
END
UNTIL CONTROL.DATE DO REPEAT
IF DATE.CHANGE THEN PRINT @(44,7):CLL:OCONV(CONTROL.DATE,"D2"):
LOOP
PRINT @(20,8):CLL:"Enter the correct time: ":OCONV(TIME(),"MT"):@(44,8):
INPUT NEW.TIME:
IF NEW.TIME = "" THEN TIME.CHANGE = 0 ELSE
TIME.CHANGE = 1
HRS = FIELD(NEW.TIME,":",1); MINS = FIELD(NEW.TIME,":",2)
IF NOT(HRS MATCH "1N" OR HRS MATCH "2N") THEN NEW.TIME = "" ELSE
IF NOT(MINS MATCH "2N") THEN NEW.TIME = "" ELSE IF HRS > 23 OR MINS > 59 THEN NEW.TIME = ""
END
END
WHILE NEW.TIME = "" AND TIME.CHANGE DO PRINT BELL: REPEAT
ENTER.ARE.YOU.SURE: *
LOOP
* CLEARDATA; * REV ONLY
PRINT @(20,10):CLL:"Are you sure date and time are correct (Y/N)? ":
INPUT RSP:
IF RSP EQ "ON" THEN CO.DATA<4> = 1 ELSE
IF RSP EQ "OFF" THEN CO.DATA<4> = "" ELSE
IF RSP EQ "FLAG" THEN
PRINT @(0,22):CLL:RVB:"The control date override flag is ":
IF NOT(CO.DATA<4>) THEN PRINT "OFF.":RVE: ELSE PRINT "ON.":RVE:
END
END
END
UNTIL RSP = "Y" OR RSP = "N" DO PRINT BELL: REPEAT
* IF RSP = "N" THEN STOP; * REV ONLY
UNTIL RSP = "Y" DO REPEAT
*
PRINT
IF DATE.CHANGE AND NOT(CO.DATA<4>) THEN EXECUTE "SET-DATE ":OCONV(CONTROL.DATE,"D2"), //OUT. > RSP; * DON'T CHANGE
IF TIME.CHANGE THEN EXECUTE "SET-TIME ":NEW.TIME, //OUT. > RSP; * DON'T CHANGE
*
CO.DATA<2> = CONTROL.DATE
WRITE CO.DATA ON CNT.FILE,"CO.DATA"
WRITE CONTROL.DATE ON CNT.FILE,"CURR.ACCTG.DATE"
RETURN
!
DISPLAY.TIME.AND.DATE: *
CLS.COL = 20; CLS.ROW = 7; GOSUB CLS.ROUTINE
PRINT "The current system date is: ":OCONV(DATE(),"D2"):
PRINT @(20,8):CLL:"The current system time is: ":OCONV(TIME(),"MT"):
PRINT @(20,13):CLL:"To change either of the above, proceed as follows:":
PRINT @(20,14):CLL:"   Enter N, then OFF.":
PRINT @(20,15):CLL:"   Single user system:":
PRINT @(20,16):CLL:"          Re-boot the system.":
PRINT @(20,17):CLL:"          Enter TIME and DATE when requested.":
PRINT @(20,18):CLL:"   Multi-user system:":
PRINT @(20,19):CLL:"          Log out of network (LOGOUT).":
PRINT @(20,20):CLL:"          Change on system console using SET TIME command.":
PRINT @(20,21):CLL:"          Re-boot the workstation.":
RETURN
$INCLUDE IBP CLS.ROUTINE
!
END
~MAINT.DICT~
*PROGRAM: MAINT.DICT 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      13 FEB 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Cannot open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Cannot open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(11)
VALID.REFS = "DN":AM:"DS":AM:"LH":AM:"JN":AM:"CV":AM:"VL":AM:"CA":AM:"DD":AM:"ED":AM:"CO":AM:"FD"
*
FILE.NAME = ""
GOSUB DISPLAY.BACKGROUND
!
NEXT.FILE: *
STAT = ""; UPDATED = ""
GOSUB GET.FILE; IF FILE.NAME = "" THEN STOP
!
NEXT.ITEM: *
ITEM.ID = ""; GOSUB GET.KEY; IF ITEM.ID = "" THEN FILE.NAME = ""; GOTO NEXT.FILE
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(NAMED.FILE,FILE.NAME,ITEM.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ ITEM FROM NAMED.FILE,ITEM.ID THEN NEW = "" ELSE NEW = 1; ITEM = ""
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = ITEM.ID; ITEM.ID = "!":ITEM.ID; GOSUB GET.KEY; ITEM.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 11
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter screen ref., DElete, REdisplay, END, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE NAMED.FILE,ITEM.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = ITEM.ID; ITEM.ID = "!":ITEM.ID; GOSUB GET.KEY; ITEM.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
ITEM<1> = "A"
ITEM<2> = FIELD(ITEM.ID,",",1)
WRITE ITEM ON NAMED.FILE,ITEM.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(NAMED.FILE,FILE.NAME,ITEM.ID,LCK.FILE)
GOSUB DISPLAY.BACKGROUND
GOTO NEXT.ITEM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                             Dictionary maintenance                             ":RVE:
PRINT @(0,3):"                     ":RVB:"    File name..":RVE:
PRINT @(0,4):"                     ":RVB:"    Dict. id...":RVE:
PRINT @(0,6):RVB:"    Attribute No...":RVE:
PRINT @(0,8):RVB:"DN> Dict. name.....":RVE:
PRINT @(0,9):RVB:"DS> Description....":RVE:
PRINT @(0,11):RVB:"LH> Length.........":RVE:"                     ":RVB:"ED> Edit criteria..":RVE:
PRINT @(0,12):RVB:"JN> Justification..":RVE:
PRINT @(0,13):RVB:"CV> Conversion.....":RVE:
PRINT @(0,14):RVB:"VL> Val/Subvalued..":RVE:
PRINT @(0,15):RVB:"CA> Control.attrib.":RVE:
PRINT @(0,16):RVB:"DD> Display.def....":RVE:
PRINT @(0,17):RVB:"CO> Prog.comments..":RVE:
PRINT @(0,19):RVB:"FD> Full definit'n.":RVE:
PRINT @(37,3):FILE.NAME "L#6":
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(20,6):FIELD(ITEM.ID,",",1) "L#3":
PRINT @(20,8):ITEM<3> "L#20":
PRINT @(20,9):ITEM<11> "L#40":
PRINT @(20,11):ITEM<10> "L#3":
PRINT @(20,12):ITEM<9> "L#3":
PRINT @(20,13):ITEM<7> "L#10":
PRINT @(20,14):FIELD(ITEM<15>,"-",1) "L#1":
PRINT @(20,15):FIELD(ITEM<15>,"-",2) "L#5":
PRINT @(20,16):ITEM<13> "L#50":
GOSUB d09; IF STAT = 999 THEN RETURN
GOSUB d10; IF STAT = 999 THEN RETURN
GOSUB d11; IF STAT = 999 THEN RETURN
RETURN
!
GET.FILE: *
CALL INPUT.DATA(FILE.NAME,37,3,"L6",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF FILE.NAME = "" THEN RETURN
OPEN "DICT",FILE.NAME TO NAMED.FILE ELSE TEXT = "Cannot open ":FILE.NAME; GOSUB ERROR; GOTO GET.KEY
RETURN
!
GET.KEY: *
CALL INPUT.DATA(ITEM.ID,37,4,"L7",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF RSP MATCHES "0N" THEN RETURN
IF RSP MATCHES "0N,0N" THEN RETURN
IF RSP MATCHES "0N,0N,0N" THEN RETURN
IF RSP MATCHES "0N,1X0N" THEN RETURN
TEXT = "Formats: ## ##,## ##,##,## ##,@# (##-A/V/SMC, @#-separator/field pos.)" 
GOSUB ERROR
GOTO GET.KEY
!
GET.DATA: *
ON REF GOSUB i01,i02,i03,i04,i05,i06,i07,i08,i09,i10,i11
RETURN
!
i01: CALL INPUT.DATA(ITEM,20,8,"L20",3,"","","",RSP,STAT); RETURN
i02: CALL INPUT.DATA(ITEM,20,9,"L40",11,"","","",RSP,STAT); RETURN
i03: CALL INPUT.DATA(ITEM,20,11,"L3",10,"","MA0N","",RSP,STAT); RETURN
i04: CALL INPUT.DATA(ITEM,20,12,"L3",9,"","EQLRLNRN","",RSP,STAT); RETURN
i05: CALL INPUT.DATA(ITEM,20,13,"L10",7,"","","",RSP,STAT); RETURN
i06: CALL INPUT.DATA(ITEM,20,14,"L1",15:",,,-1","","OPEQVS","",RSP,STAT); RETURN
i07: CALL INPUT.DATA(ITEM,20,15,"L5",15:",,,-2","","MA0N0N/0N","",RSP,STAT); RETURN
i08: CALL INPUT.DATA(ITEM,20,16,"L50",13,"","","",RSP,STAT); RETURN
i09: IF NEW THEN
LOCATE "" IN ITEM<16> SETTING VC ELSE NULL
RSP = "N"
END ELSE
PRINT @(0,23):CLL:"Ref. ED - Enter line no., N(ext line) or <cr> if okay: ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP = "" OR RSP = "^" THEN RETURN
IF RSP = "N" THEN
LOCATE "" IN ITEM<16> SETTING VC ELSE NULL
END ELSE
IF NOT(RSP MATCHES "0N") THEN PRINT BELL:; GOTO i09
IF NOT(RSP) THEN PRINT BELL:; GOTO i09
VC = RSP
IF ITEM<16,VC> = "" THEN PRINT BELL:; GOTO i09
LOOP
PRINT @(0,23):CLL:"Enter I(nsert), D(elete) or <cr> to change line: ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
UNTIL RSP = "I" OR RSP = "D" OR RSP = "" DO PRINT BELL: REPEAT
END
END
IF NOT(RSP = "I" OR RSP = "N") THEN
IF RSP = "D" THEN
DEL ITEM<16,VC>
TOP.DISP.LOC(9) = -ABS(TOP.DISP.LOC(9))
GOSUB d09; IF STAT = 999 THEN RETURN
GOTO i09
END
END ELSE
IF VC > 4 THEN TEXT = "Max. entries allowed is 4"; GOSUB ERROR; GOTO i09
INS " " BEFORE ITEM<16,VC>
IF RSP = "I" THEN TOP.DISP.LOC(9) = -ABS(TOP.DISP.LOC(9)) ELSE IF NOT(TOP.DISP.LOC(9)) THEN TOP.DISP.LOC(9) = 1
END
GOSUB d09; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,4)+12
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB i09A
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 1
IF SUB.REF = 1 THEN IF RSP = "" THEN RETURN
NEXT SUB.REF
GOTO i09
i09A: IF ITEM<16,VC> = " " THEN ITEM<16,VC> = ""
PRINT @(43,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":; CALL INPUT.DATA(ITEM,46,LN,"L25",16:",":VC,"","","",RSP,STAT); RETURN
d09: SAVE.VC = VC
IF TOP.DISP.LOC(9) < 0 THEN TOP.DISP.LOC(9) = ABS(TOP.DISP.LOC(9)) ELSE
IF VC >= TOP.DISP.LOC(9) THEN IF VC <= TOP.DISP.LOC(9)+3 THEN RETURN
END
IF TOP.DISP.LOC(9) THEN VC = VC-MOD(VC-1,4); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 12 TO 15 UNTIL ITEM<16,VC> = ""
IF LN = 12 THEN TOP.LOC = VC
PRINT @(43,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":ITEM<16,VC> "L#25":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(9) OR ITEM<16,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 12; GOSUB c09 REPEAT
IF CLEAR THEN GOSUB c09 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(9) = TOP.LOC
VC = SAVE.VC
RETURN
c09: FOR LN = LN TO 15
PRINT @(43,LN):SPACE(33):
NEXT LN
RETURN
i10: IF NEW THEN
LOCATE "" IN ITEM<14> SETTING VC ELSE NULL
RSP = "N"
END ELSE
PRINT @(0,23):CLL:"Ref. CO - Enter line no., N(ext line) or <cr> if okay: ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP = "" OR RSP = "^" THEN RETURN
IF RSP = "N" THEN
LOCATE "" IN ITEM<14> SETTING VC ELSE NULL
END ELSE
IF NOT(RSP MATCHES "0N") THEN PRINT BELL:; GOTO i10
IF NOT(RSP) THEN PRINT BELL:; GOTO i10
VC = RSP
IF ITEM<14,VC> = "" THEN PRINT BELL:; GOTO i10
LOOP
PRINT @(0,23):CLL:"Enter I(nsert), D(elete) or <cr> to change line: ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
UNTIL RSP = "I" OR RSP = "D" OR RSP = "" DO PRINT BELL: REPEAT
END
END
IF NOT(RSP = "I" OR RSP = "N") THEN
IF RSP = "D" THEN
DEL ITEM<14,VC>
TOP.DISP.LOC(10) = -ABS(TOP.DISP.LOC(10))
GOSUB d10; IF STAT = 999 THEN RETURN
GOTO i10
END
END ELSE
IF VC > 2 THEN TEXT = "Max. entries allowed is 2"; GOSUB ERROR; GOTO i10
INS " " BEFORE ITEM<14,VC>
IF RSP = "I" THEN TOP.DISP.LOC(10) = -ABS(TOP.DISP.LOC(10)) ELSE IF NOT(TOP.DISP.LOC(10)) THEN TOP.DISP.LOC(10) = 1
END
GOSUB d10; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,2)+17
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB i10A
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 1
IF SUB.REF = 1 THEN IF RSP = "" THEN RETURN
NEXT SUB.REF
GOTO i10
i10A: IF ITEM<14,VC> = " " THEN ITEM<14,VC> = ""
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":; CALL INPUT.DATA(ITEM,22,LN,"L25",14:",":VC,"","","",RSP,STAT); RETURN
d10: SAVE.VC = VC
IF TOP.DISP.LOC(10) < 0 THEN TOP.DISP.LOC(10) = ABS(TOP.DISP.LOC(10)) ELSE
IF VC >= TOP.DISP.LOC(10) THEN IF VC <= TOP.DISP.LOC(10)+1 THEN RETURN
END
IF TOP.DISP.LOC(10) THEN VC = VC-MOD(VC-1,2); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 17 TO 18 UNTIL ITEM<14,VC> = ""
IF LN = 17 THEN TOP.LOC = VC
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":ITEM<14,VC> "L#25":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(10) OR ITEM<14,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 17; GOSUB c10 REPEAT
IF CLEAR THEN GOSUB c10 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(10) = TOP.LOC
VC = SAVE.VC
RETURN
c10: FOR LN = LN TO 18
PRINT @(19,LN):SPACE(33):
NEXT LN
RETURN
i11: IF NEW THEN
LOCATE "" IN ITEM<12> SETTING VC ELSE NULL
RSP = "N"
END ELSE
PRINT @(0,23):CLL:"Ref. FD - Enter line no., N(ext line) or <cr> if okay: ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP = "" OR RSP = "^" THEN RETURN
IF RSP = "N" THEN
LOCATE "" IN ITEM<12> SETTING VC ELSE NULL
END ELSE
IF NOT(RSP MATCHES "0N") THEN PRINT BELL:; GOTO i11
IF NOT(RSP) THEN PRINT BELL:; GOTO i11
VC = RSP
IF ITEM<12,VC> = "" THEN PRINT BELL:; GOTO i11
LOOP
PRINT @(0,23):CLL:"Enter I(nsert), D(elete) or <cr> to change line: ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
UNTIL RSP = "I" OR RSP = "D" OR RSP = "" DO PRINT BELL: REPEAT
END
END
IF NOT(RSP = "I" OR RSP = "N") THEN
IF RSP = "D" THEN
DEL ITEM<12,VC>
TOP.DISP.LOC(11) = -ABS(TOP.DISP.LOC(11))
GOSUB d11; IF STAT = 999 THEN RETURN
GOTO i11
END
END ELSE
IF VC > 99 THEN TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO i11
INS " " BEFORE ITEM<12,VC>
IF RSP = "I" THEN TOP.DISP.LOC(11) = -ABS(TOP.DISP.LOC(11)) ELSE IF NOT(TOP.DISP.LOC(11)) THEN TOP.DISP.LOC(11) = 1
END
GOSUB d11; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,4)+19
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB i11A
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 1
IF SUB.REF = 1 THEN IF RSP = "" THEN RETURN
NEXT SUB.REF
GOTO i11
i11A: IF ITEM<12,VC> = " " THEN ITEM<12,VC> = ""
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":; CALL INPUT.DATA(ITEM,22,LN,"L40",12:",":VC,"","","",RSP,STAT); RETURN
d11: SAVE.VC = VC
IF TOP.DISP.LOC(11) < 0 THEN TOP.DISP.LOC(11) = ABS(TOP.DISP.LOC(11)) ELSE
IF VC >= TOP.DISP.LOC(11) THEN IF VC <= TOP.DISP.LOC(11)+3 THEN RETURN
END
IF TOP.DISP.LOC(11) THEN VC = VC-MOD(VC-1,4); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 19 TO 22 UNTIL ITEM<12,VC> = ""
IF LN = 19 THEN TOP.LOC = VC
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":ITEM<12,VC> "L#40":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(11) OR ITEM<12,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 19; GOSUB c11 REPEAT
IF CLEAR THEN GOSUB c11 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(11) = TOP.LOC
VC = SAVE.VC
RETURN
c11: FOR LN = LN TO 22
PRINT @(19,LN):SPACE(43):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
END
~MAINT.DICTS~
*PROGRAM: SH.MAINT.DICTS 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      05 MAY 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
INPUT RECORD.FLAG
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(12)
VALID.REFS = "DN":AM:"DB":AM:"DS":AM:"LH":AM:"JN":AM:"CV":AM:"CL":AM:"VL":AM:"CA":AM:"DD":AM:"ED":AM:"CO":AM:"FD"
*
FILE.NAME = ""; ITEM.ID = ""
GOSUB DISPLAY.BACKGROUND
!
NEXT.FILE: *
STAT = ""; UPDATED = ""
GOSUB GET.FILE; IF FILE.NAME = "" THEN STOP
!
NEXT.ITEM: *
ITEM.ID = ""; GOSUB GET.KEY; IF ITEM.ID = "" THEN FILE.NAME = ""; GOTO NEXT.FILE
IF RECORD.FLAG EQ "M" THEN
TRUE.ID = RECORD.TYPE:".":ITEM.ID
END ELSE TRUE.ID = ITEM.ID
*
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(NAMED.FILE,TRUE.FILE.NAME,TRUE.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ ITEM FROM NAMED.FILE,TRUE.ID THEN NEW = "" ELSE NEW = 1; ITEM = ""
IF ITEM<19> EQ "" THEN ITEM<19> = ITEM<3>
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = ITEM.ID; ITEM.ID = "!":ITEM.ID; GOSUB GET.KEY; ITEM.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 13
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE NAMED.FILE,TRUE.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = ITEM.ID; ITEM.ID = "!":ITEM.ID; GOSUB GET.KEY; ITEM.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
ITEM<1> = "A"
ITEM<2> = FIELD(ITEM.ID,",",1)
WRITE ITEM ON NAMED.FILE,TRUE.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(NAMED.FILE,TRUE.FILE.NAME,TRUE.ID,LCK.FILE)
GOSUB DISPLAY.BACKGROUND
GOTO NEXT.ITEM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
SCR.HDR = "Dictionary maintenance"
IF RECORD.FLAG EQ "M" THEN SCR.HDR = SCR.HDR:" - Record Types"
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:("Acct ":ACCT) "L#12":(SPACE(28-((LEN(SCR.HDR)/2) "0")):CO.NAME) "L#56":" " "R#12":RVE:
* PRINT @(0,1):RVB:"                             Dictionary maintenance                             ":RVE:
PRINT @(0,3):"                     ":RVB:"    File name..":RVE:
PRINT @(0,4):"                     ":RVB:"    Dict. id...":RVE:
PRINT @(0,5):RVB:"    Attribute No...":RVE:
PRINT @(0,6):RVB:"DB> DBasic Equate..":RVE:
PRINT @(0,8):RVB:"DN> Dict. name.....":RVE:
PRINT @(0,9):RVB:"DS> Description....":RVE:
PRINT @(0,10):RVB:"LH> Length.........":RVE:
PRINT @(0,11):RVB:"JN> Justification..":RVE:"                     ":RVB:"ED> Edit criteria..":RVE:
PRINT @(0,12):RVB:"CV> Conversion.....":RVE:
PRINT @(0,13):RVB:"CL> Correlative....":RVE:
PRINT @(0,14):RVB:"VL> Val/Subvalued..":RVE:
PRINT @(0,15):RVB:"CA> Control.attrib.":RVE:
PRINT @(0,16):RVB:"DD> Display.def....":RVE:
PRINT @(0,17):RVB:"CO> Prog.comments..":RVE:
PRINT @(0,19):RVB:"FD> Full definit'n.":RVE:
PRINT @(37,3):FILE.NAME "L#16":
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(20,5):FIELD(ITEM.ID,",",1) "L#3":
PRINT @(20,6):ITEM<19> "L#20":
PRINT @(20,8):ITEM<3> "L#20":
PRINT @(20,9):ITEM<11> "L#40":
PRINT @(20,10):ITEM<10> "L#3":
PRINT @(20,11):ITEM<9> "L#3":
PRINT @(20,12):ITEM<7> "L#7":
PRINT @(20,13):ITEM<8> "L#7":
PRINT @(20,14):FIELD(ITEM<15>,"-",1) "L#1":
PRINT @(20,15):FIELD(ITEM<15>,"-",2) "L#5":
PRINT @(20,16):ITEM<13> "L#50":
DYNAMIC = ""; GOSUB d10; IF STAT = 999 THEN RETURN
DYNAMIC = ""; GOSUB d11; IF STAT = 999 THEN RETURN
DYNAMIC = ""; GOSUB d12; IF STAT = 999 THEN RETURN
RETURN
!
GET.FILE: *
CALL INPUT.DATA(FILE.NAME,37,3,"L16",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF FILE.NAME = "" THEN RETURN
BASE.FILE.NAME = FIELD(FILE.NAME,".",ONE)
IF RECORD.FLAG EQ "M" THEN
TRUE.FILE.NAME = BASE.FILE.NAME
END ELSE TRUE.FILE.NAME = FILE.NAME
RECORD.TYPE = FIELD(FILE.NAME,".",TWO)
OPEN "DICT",TRUE.FILE.NAME TO NAMED.FILE ELSE TEXT = "Can't open ":TRUE.FILE.NAME; GOSUB ERROR; GOTO GET.FILE
RETURN
!
GET.KEY: *
CALL INPUT.DATA(ITEM.ID,37,4,"L7",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF RSP MATCHES "0N" THEN RETURN
IF RSP MATCHES "0N,0N" THEN RETURN
IF RSP MATCHES "0N,0N,0N" THEN RETURN
IF RSP MATCHES "0N,1X0N" THEN RETURN
TEXT = "Formats: ## ##,## ##,##,## ##,@# (##-A/V/SMC, @#-separator/field pos.)" 
GOSUB ERROR
GOTO GET.KEY
!
GET.DATA: *
ON REF GOSUB i01A,i01,i02,i03,i04,i05,i06,i07,i08,i09,i10,i11,i12
RETURN
!
i01A: CALL INPUT.DATA(ITEM,20,8,"L20",3,"","","",RSP,STAT); RETURN
i01: CALL INPUT.DATA(ITEM,20,6,"L20",19,"","","",RSP,STAT); RETURN
i02: CALL INPUT.DATA(ITEM,20,9,"L40",11,"","","",RSP,STAT); RETURN
i03: CALL INPUT.DATA(ITEM,20,10,"L3",10,"","MA|0N","",RSP,STAT); RETURN
i04: CALL INPUT.DATA(ITEM,20,11,"L3",9,"","EQ|L|R|LN|RN","",RSP,STAT); RETURN
i05: CALL INPUT.DATA(ITEM,20,12,"L7",7,"","","",RSP,STAT); RETURN
i06: CALL INPUT.DATA(ITEM,20,13,"L7",8,"","","",RSP,STAT); RETURN
i07: CALL INPUT.DATA(ITEM,20,14,"L1",15:",,,":"-1","","OP}EQ|V|S","",RSP,STAT); RETURN
i08: CALL INPUT.DATA(ITEM,20,15,"L5",15:",,,":"-2","","MA|0N|0N/0N","",RSP,STAT); RETURN
i09: CALL INPUT.DATA(ITEM,20,16,"L50",13,"","","",RSP,STAT); RETURN
i10: IF NEW THEN
LOCATE "" IN ITEM<16> SETTING VC ELSE NULL
DYNAMIC = "N"
END ELSE
PRINT @(0,23):CLL:"Ref. ED> - Enter line no., N(ext line) or <cr> if okay: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
IF DYNAMIC = "" OR DYNAMIC = "^" THEN RETURN
IF DYNAMIC = "N" THEN
LOCATE "" IN ITEM<16> SETTING VC ELSE NULL
END ELSE
IF NOT(DYNAMIC MATCHES "0N") THEN PRINT BELL:; GOTO i10
IF NOT(DYNAMIC) THEN PRINT BELL:; GOTO i10
VC = DYNAMIC
IF ITEM<16,VC> = "" THEN PRINT BELL:; GOTO i10
LOOP
PRINT @(0,23):CLL:"Enter I(nsert), D(elete) or <cr> to change line: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
UNTIL DYNAMIC = "I" OR DYNAMIC = "D" OR DYNAMIC = "" DO PRINT BELL: REPEAT
END
END
IF NOT(DYNAMIC = "I" OR DYNAMIC = "N") THEN
IF DYNAMIC = "D" THEN
DEL ITEM<16,VC>
TOP.DISP.LOC(10) = -ABS(TOP.DISP.LOC(10))
DYNAMIC = "D"; GOSUB d10; IF STAT = 999 THEN RETURN
GOTO i10
END
END ELSE
IF VC > 4 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 4"; GOSUB ERROR; GOTO i10
END
INS " " BEFORE ITEM<16,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(10) = -ABS(TOP.DISP.LOC(10)) ELSE IF NOT(TOP.DISP.LOC(10)) THEN TOP.DISP.LOC(10) = 1
END
GOSUB d10; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,4)+12
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB i10A
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 1
IF SUB.REF = 1 THEN IF RSP = "" THEN RETURN
NEXT SUB.REF
GOTO i10
i10A: IF ITEM<16,VC> = " " THEN ITEM<16,VC> = ""
PRINT @(43,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":; CALL INPUT.DATA(ITEM,46,LN,"L30",16:",":VC,"","","",RSP,STAT)
IF RSP = "" THEN IF DYNAMIC # "N" THEN PRINT BELL:; GOTO i10A
RETURN
d10: SAVE.VC = VC
IF TOP.DISP.LOC(10) < 0 THEN TOP.DISP.LOC(10) = ABS(TOP.DISP.LOC(10)) ELSE
IF VC >= TOP.DISP.LOC(10) THEN IF VC <= TOP.DISP.LOC(10)+3 THEN RETURN
END
IF TOP.DISP.LOC(10) THEN VC = VC-MOD(VC-1,4); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 12 TO 15 UNTIL ITEM<16,VC> = ""
IF LN = 12 THEN TOP.LOC = VC
PRINT @(43,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":ITEM<16,VC> "L#30":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(10) OR ITEM<16,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 12; GOSUB c10 REPEAT
IF CLEAR THEN GOSUB c10 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(10) = TOP.LOC
VC = SAVE.VC
RETURN
c10: FOR LN = LN TO 15
PRINT @(43,LN):SPACE(33):
NEXT LN
RETURN
i11: IF NEW THEN
LOCATE "" IN ITEM<14> SETTING VC ELSE NULL
DYNAMIC = "N"
END ELSE
PRINT @(0,23):CLL:"Ref. CO> - Enter line no., N(ext line) or <cr> if okay: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
IF DYNAMIC = "" OR DYNAMIC = "^" THEN RETURN
IF DYNAMIC = "N" THEN
LOCATE "" IN ITEM<14> SETTING VC ELSE NULL
END ELSE
IF NOT(DYNAMIC MATCHES "0N") THEN PRINT BELL:; GOTO i11
IF NOT(DYNAMIC) THEN PRINT BELL:; GOTO i11
VC = DYNAMIC
IF ITEM<14,VC> = "" THEN PRINT BELL:; GOTO i11
LOOP
PRINT @(0,23):CLL:"Enter I(nsert), D(elete) or <cr> to change line: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
UNTIL DYNAMIC = "I" OR DYNAMIC = "D" OR DYNAMIC = "" DO PRINT BELL: REPEAT
END
END
IF NOT(DYNAMIC = "I" OR DYNAMIC = "N") THEN
IF DYNAMIC = "D" THEN
DEL ITEM<14,VC>
TOP.DISP.LOC(11) = -ABS(TOP.DISP.LOC(11))
DYNAMIC = "D"; GOSUB d11; IF STAT = 999 THEN RETURN
GOTO i11
END
END ELSE
IF VC > 2 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 2"; GOSUB ERROR; GOTO i11
END
INS " " BEFORE ITEM<14,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(11) = -ABS(TOP.DISP.LOC(11)) ELSE IF NOT(TOP.DISP.LOC(11)) THEN TOP.DISP.LOC(11) = 1
END
GOSUB d11; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,2)+17
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB i11A
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 1
IF SUB.REF = 1 THEN IF RSP = "" THEN RETURN
NEXT SUB.REF
GOTO i11
i11A: IF ITEM<14,VC> = " " THEN ITEM<14,VC> = ""
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":; CALL INPUT.DATA(ITEM,22,LN,"L30",14:",":VC,"","","",RSP,STAT)
IF RSP = "" THEN IF DYNAMIC # "N" THEN PRINT BELL:; GOTO i11A
RETURN
d11: SAVE.VC = VC
IF TOP.DISP.LOC(11) < 0 THEN TOP.DISP.LOC(11) = ABS(TOP.DISP.LOC(11)) ELSE
IF VC >= TOP.DISP.LOC(11) THEN IF VC <= TOP.DISP.LOC(11)+1 THEN RETURN
END
IF TOP.DISP.LOC(11) THEN VC = VC-MOD(VC-1,2); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 17 TO 18 UNTIL ITEM<14,VC> = ""
IF LN = 17 THEN TOP.LOC = VC
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":ITEM<14,VC> "L#30":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(11) OR ITEM<14,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 17; GOSUB c11 REPEAT
IF CLEAR THEN GOSUB c11 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(11) = TOP.LOC
VC = SAVE.VC
RETURN
c11: FOR LN = LN TO 18
PRINT @(19,LN):SPACE(33):
NEXT LN
RETURN
i12: IF NEW THEN
LOCATE "" IN ITEM<12> SETTING VC ELSE NULL
DYNAMIC = "N"
END ELSE
PRINT @(0,23):CLL:"Ref. FD> - Enter line no., N(ext line) or <cr> if okay: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
IF DYNAMIC = "" OR DYNAMIC = "^" THEN RETURN
IF DYNAMIC = "N" THEN
LOCATE "" IN ITEM<12> SETTING VC ELSE NULL
END ELSE
IF NOT(DYNAMIC MATCHES "0N") THEN PRINT BELL:; GOTO i12
IF NOT(DYNAMIC) THEN PRINT BELL:; GOTO i12
VC = DYNAMIC
IF ITEM<12,VC> = "" THEN PRINT BELL:; GOTO i12
LOOP
PRINT @(0,23):CLL:"Enter I(nsert), D(elete) or <cr> to change line: ":
INPUT DYNAMIC:; IF DYNAMIC = "KILL" THEN STAT = 999; RETURN
UNTIL DYNAMIC = "I" OR DYNAMIC = "D" OR DYNAMIC = "" DO PRINT BELL: REPEAT
END
END
IF NOT(DYNAMIC = "I" OR DYNAMIC = "N") THEN
IF DYNAMIC = "D" THEN
DEL ITEM<12,VC>
TOP.DISP.LOC(12) = -ABS(TOP.DISP.LOC(12))
DYNAMIC = "D"; GOSUB d12; IF STAT = 999 THEN RETURN
GOTO i12
END
END ELSE
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO i12
END
INS " " BEFORE ITEM<12,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(12) = -ABS(TOP.DISP.LOC(12)) ELSE IF NOT(TOP.DISP.LOC(12)) THEN TOP.DISP.LOC(12) = 1
END
GOSUB d12; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,4)+19
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB i12A
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 1
IF SUB.REF = 1 THEN IF RSP = "" THEN RETURN
NEXT SUB.REF
GOTO i12
i12A: IF ITEM<12,VC> = " " THEN ITEM<12,VC> = ""
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":; CALL INPUT.DATA(ITEM,22,LN,"L40",12:",":VC,"","","",RSP,STAT)
IF RSP = "" THEN IF DYNAMIC # "N" THEN PRINT BELL:; GOTO i12A
RETURN
d12: SAVE.VC = VC
IF TOP.DISP.LOC(12) < 0 THEN TOP.DISP.LOC(12) = ABS(TOP.DISP.LOC(12)) ELSE
IF VC >= TOP.DISP.LOC(12) THEN IF VC <= TOP.DISP.LOC(12)+3 THEN RETURN
END
IF TOP.DISP.LOC(12) THEN VC = VC-MOD(VC-1,4); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 19 TO 22 UNTIL ITEM<12,VC> = ""
IF LN = 19 THEN TOP.LOC = VC
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":ITEM<12,VC> "L#40":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(12) OR ITEM<12,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 19; GOSUB c12 REPEAT
IF CLEAR THEN GOSUB c12 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(12) = TOP.LOC
VC = SAVE.VC
RETURN
c12: FOR LN = LN TO 22
PRINT @(19,LN):SPACE(43):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
END
~MAINT.PASSWORD~
*PROGRAM: MAINT.PASSWORD 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       PROGRAM REMOVED OCT9/85 - WOULD NOT WORK WITH REV140G.
* DATE WRITTEN:      10 APR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                              Change your PASSWORD                              ":RVE:
TEXT = "Passwords must now be changed using SECURITY logon"
GOSUB ERROR
STOP
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
END
~MAINT.PASSWORDS~
*PROGRAM: MAINT.PASSWORDS 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
*                    see *CUSTOM CODE* lines...
* DATE WRITTEN:      04 APR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "MD" TO MD.FILE ELSE TEXT = "Can't open MD"; GOSUB ERROR; STOP; *CUSTOM*
SYSPROG.QPTR = "Q":AM:"SYSPROG":AM:"MD":AM:AM:AM:AM:AM:AM:"L":AM:"10"; *CUSTOM*
SYSTEM.QPTR = "Q":AM:"SYSPROG":AM:"SYSTEM":AM:AM:AM:AM:AM:AM:"L":AM:"10"; *CUSTOM*
WRITE SYSPROG.QPTR ON MD.FILE, "SYSPROG.MD"; *CUSTOM*
WRITE SYSTEM.QPTR ON MD.FILE, "SYSPROG.SYSTEM"; *CUSTOM*
OPEN "SYSPROG.MD" TO SYSPROG.MD.FILE ELSE TEXT = "Can't open SYSPROG.MD"; GOSUB ERROR; STOP
OPEN "SYSPROG.SYSTEM" TO SYSPROG.SYSTEM.FILE ELSE TEXT = "Can't open SYSPROG.SYSTEM"; GOSUB ERROR; STOP
*CUSTOM* OPEN "MD" TO MD.FILE ELSE TEXT = "Can't open MD"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM MD.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(1)
VALID.REFS = "LO"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
SYSPROG.MD.ID = ""; GOSUB GET.KEY; IF SYSPROG.MD.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(SYSPROG.MD.FILE,"SYSPROG.MD",SYSPROG.MD.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ SYSPROG.MD FROM SYSPROG.MD.FILE,SYSPROG.MD.ID THEN NEW = "" ELSE NEW = 1; SYSPROG.MD = ""
GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = SYSPROG.MD.ID; SYSPROG.MD.ID = "!":SYSPROG.MD.ID; GOSUB GET.KEY; SYSPROG.MD.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 1
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter CHange, REdisplay, KILL or <cr> to update: ":; *CUSTOM*
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
*CUSTOM* CASE RSP = "DE"
*CUSTOM* PRINT @(0,23):CLL:"Delete - Are you sure (Y/<cr>)? ":
*CUSTOM* INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
*CUSTOM* IF RSP # "Y" THEN GOTO CHANGES
*CUSTOM* DELETE SYSPROG.MD.FILE,SYSPROG.MD.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = SYSPROG.MD.ID; SYSPROG.MD.ID = "!":SYSPROG.MD.ID; GOSUB GET.KEY; SYSPROG.MD.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE SYSPROG.MD ON SYSPROG.MD.FILE,SYSPROG.MD.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(SYSPROG.MD.FILE,"SYSPROG.MD",SYSPROG.MD.ID,LCK.FILE)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                      Pending Password Changes Maintenance                      ":RVE:
PRINT @(0,3):RVB:"Logon account":RVE:"         ":RVB:"Synonym for  ":RVE:"         ":RVB:"Current password":RVE:"  ":RVB:"New password      ":RVE:
PRINT @(0,22):RVB:"The new passwords will be effective after the next FILE-SAVE is done.          ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = ""; GOSUB d01; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
SYSPROG.MD.ID = "PENDING.PASSWORD.CHANGES"
RETURN
!
GET.DATA: *
ON REF GOSUB i01
RETURN
!
i01:  PRINT @(0,23):CLL:"Enter Logon: ":
FLD = ""; CALL INPUT.DATA(FLD,13,23,"L20",1,"","SEOP","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i01
IF FLD = "" THEN RETURN
LOCATE FLD IN SYSPROG.MD<1> BY "AL" SETTING VC THEN
*CUSTOM* PRINT @(0,23):CLL:FLD:" - Delete it (Y/<cr>)? ":
*CUSTOM* INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
RSP = ""; *CUSTOM*
IF RSP # "Y" THEN DYNAMIC = ""; PRINT @(0,23):CLL: ELSE
DEL SYSPROG.MD<1,VC>
DEL SYSPROG.MD<2,VC>
DEL SYSPROG.MD<3,VC>
DEL SYSPROG.MD<4,VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
DYNAMIC = "D"; GOSUB d01; IF STAT = 999 THEN RETURN
GOTO i01
END
END ELSE
IF SYSPROG.MD<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO i01
END
INS FLD BEFORE SYSPROG.MD<1,VC>
INS "" BEFORE SYSPROG.MD<2,VC>
INS "" BEFORE SYSPROG.MD<3,VC>
INS "" BEFORE SYSPROG.MD<4,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB d01; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,16)+5
FOR SUB.REF = 3 TO 3; *CUSTOM*
ON SUB.REF GOSUB i01B,i01C,i01D
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 4
NEXT SUB.REF
GOTO i01
i01A: CALL INPUT.DATA(SYSPROG.MD,0,LN,"L20",1:",":VC,"","","",RSP,STAT)
RETURN
i01B: CALL INPUT.DATA(SYSPROG.MD,22,LN,"L20",2:",":VC,"","","",RSP,STAT)
RETURN
i01C: CALL INPUT.DATA(SYSPROG.MD,44,LN,"L16",3:",":VC,"","","",RSP,STAT)
RETURN
i01D: CALL INPUT.DATA(SYSPROG.MD,62,LN,"L16",4:",":VC,"","OPMA5X6X7X8X","",RSP,STAT)
RETURN
d01: SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+15 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,16)+5; PRINT @(0,LN):SYSPROG.MD<1,VC> "L#20":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,16); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 5 TO 20 UNTIL SYSPROG.MD<1,VC> = ""
IF LN = 5 THEN TOP.LOC = VC
PRINT @(0,LN):SYSPROG.MD<1,VC> "L#20":
PRINT @(22,LN):SYSPROG.MD<2,VC> "L#20":
PRINT @(44,LN):SYSPROG.MD<3,VC> "L#16":
PRINT @(62,LN):SYSPROG.MD<4,VC> "L#16":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR SYSPROG.MD<1,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 5; GOSUB c01 REPEAT
IF CLEAR THEN GOSUB c01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
c01: FOR LN = LN TO 20
PRINT @(0,LN):SPACE(20):
PRINT @(22,LN):SPACE(20):
PRINT @(44,LN):SPACE(16):
PRINT @(62,LN):SPACE(16):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
READ.CALL: *
* Read all accounts from SYSPROG SYSTEM file and generate pending changes item...
NEW = ""
PRINT @(0,23):CLL:"Please wait a few seconds while the list of LOGONS is being compiled...":
SYSPROG.OLD = SYSPROG.MD
SYSPROG.MD = ""
LOC = 0
NLOC = 0
LOOP LOC = LOC+1 UNTIL SYSPROG.OLD<1,LOC> = "" DO
IF SYSPROG.OLD<3,LOC>[1,10]="&&PENDING:" THEN
NLOC = NLOC+1
FOR NAC = 1 TO 4
SYSPROG.MD<NAC,NLOC> = SYSPROG.OLD<NAC,LOC>
NEXT NAC
END
REPEAT
SELECT SYSPROG.SYSTEM.FILE, //SELECT. > FILE.ID.LIST
NXT.ACCT: *
READNEXT SYSTM.ID FROM FILE.ID.LIST ELSE PRINT @(0,23):CLL:; RETURN
READ SYSTM FROM SYSPROG.SYSTEM.FILE, SYSTM.ID ELSE GOTO NXT.ACCT
IF SYSTM<1> # "D" AND SYSTM<1> # "Q" THEN GOTO NXT.ACCT
LOCATE SYSTM.ID IN SYSPROG.MD<1> BY "AL" SETTING LOC ELSE
INS SYSTM.ID BEFORE SYSPROG.MD<1,LOC>
INS "" BEFORE SYSPROG.MD<2,LOC>
INS "" BEFORE SYSPROG.MD<3,LOC>
INS "" BEFORE SYSPROG.MD<4,LOC>
END
IF SYSTM<1> = "Q" THEN SYSPROG.MD<2,LOC> = SYSTM<2>
SYSPROG.MD<3,LOC> = SYSTM<7>
LOCATE SYSTM.ID IN SYSPROG.OLD<1> BY "AL" SETTING OLD.LOC THEN
SYSPROG.MD<4> = SYSPROG.OLD<4>
END
IF SYSPROG.MD<3,LOC> = SYSPROG.MD<4,LOC> THEN SYSPROG.MD<4,LOC> = ""
GOTO NXT.ACCT
!
END
~MAINT.PRINTER.QUEUES~
*PROGRAM: SH.MAINT.PRINTER.QUEUES 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      18 SEP 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<ONE,ONE> ELSE CO.NAME = EMPTY
*
AC = EMPTY; VC = EMPTY; SC = EMPTY
DIM TOP.DISP.LOC(TWO)
VALID.REFS = "P":AM:"QD"
VALID.REFS = VALID.REFS:AM:"Q"; *CUSTOM*
!
NEXT.ITEM: *
STAT = EMPTY; UPDATED = EMPTY
GOSUB DISPLAY.BACKGROUND
CNT.ID = EMPTY; GOSUB GET.KEY; IF CNT.ID EQ EMPTY THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ CNT FROM CNT.FILE,CNT.ID THEN NEW = EMPTY ELSE NEW = ONE; CNT = EMPTY
GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(ZERO,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(ZERO,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(ZERO,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO TWO
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ZERO
NEXT REF
NEW = EMPTY
END
!
CHANGES: *
PRINT @(ZERO,23):CLL:"Enter screen ref., REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP EQ "KILL"; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE TRUE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
GOSUB UPD.CALL; IF STAT EQ 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
WRITE CNT ON CNT.FILE,CNT.ID
UPDATED = ONE
!
UNLOCK: *
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = EMPTY
PRINT @(ZERO,0):CLS:
PRINT @(ZERO,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28 - ((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(ZERO,ONE):RVB:"                      Maintain System Printers and Queues                       ":RVE:
PRINT @(ZERO,3):RVB:"P>                                        Q>    ":RVE:"  ":RVB:"QD>                           ":RVE:
PRINT @(ZERO,4):RVB:"   Printer                  Port Printer     Que":RVE:"  ":RVB:"   Print                      ":RVE:
PRINT @(ZERO,5):RVB:"         #  Location           # Status        #":RVE:"  ":RVB:"   Queue  Description         ":RVE:
PRINT @(ZERO,18):RVB:"CAUTION:                                       ":RVE:
PRINT @(ZERO,19):RVB:"    1. Do NOT use P> unless you are installing ":RVE:
PRINT @(ZERO,20):RVB:"       or removing a printer from the system   ":RVE:
PRINT @(ZERO,21):RVB:"       or changing the location or port #.     ":RVE:
PRINT @(ZERO,22):RVB:"    2. Use Q> to change a printer's queue #.   ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = EMPTY; GOSUB d01; IF STAT EQ 999 THEN RETURN
DYNAMIC = EMPTY; GOSUB d02; IF STAT EQ 999 THEN RETURN
RETURN
!
GET.KEY: *
CNT.ID = "PRINTER.QUEUES"
RETURN
!
GET.DATA: *
ON REF GOSUB i01,i02,i01; *CUSTOM*
RETURN
!
i01:  PRINT @(ZERO,23):CLL:"Enter printer number: ":
FLD = EMPTY; CALL INPUT.DATA(FLD,22,23,"L1",1,EMPTY,"SEOPNU",EMPTY,RSP,STAT)
IF STAT EQ 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i01
IF FLD EQ EMPTY THEN RETURN
LOCATE FLD IN CNT<ONE> BY "AR" SETTING VC THEN
IF REF EQ 3 THEN DYNAMIC = EMPTY; *CUSTOM*
IF REF EQ ONE THEN; *CUSTOM*
PRINT @(ZERO,23):CLL:"Ref. P> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN DYNAMIC = EMPTY; PRINT @(ZERO,23):CLL: ELSE
DEL CNT<ONE,VC>
DEL CNT<2,VC>
DEL CNT<3,VC>
DEL CNT<4,VC>
DEL CNT<5,VC>
DEL CNT<8,VC>
DEL CNT<9,VC>
DEL CNT<10,VC>
DEL CNT<11,VC>
TOP.DISP.LOC(ONE) = -ABS(TOP.DISP.LOC(ONE))
DYNAMIC = "D"; GOSUB d01; IF STAT EQ 999 THEN RETURN
GOTO i01
END
END; *CUSTOM*
END ELSE
IF REF EQ 3 THEN TEXT = "not a valid printer number"; GOTO i01; *CUSTOM*
IF CNT<ONE,VC> EQ EMPTY THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC GT 10 THEN IF NEW AND DYNAMIC EQ "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 10"; GOSUB ERROR; GOTO i01
END
INS FLD BEFORE CNT<ONE,VC>
INS EMPTY BEFORE CNT<2,VC>
INS EMPTY BEFORE CNT<3,VC>
INS EMPTY BEFORE CNT<4,VC>
INS EMPTY BEFORE CNT<5,VC>
INS EMPTY BEFORE CNT<8,VC>
INS EMPTY BEFORE CNT<9,VC>
INS EMPTY BEFORE CNT<10,VC>
INS EMPTY BEFORE CNT<11,VC>
IF DYNAMIC EQ "I" THEN TOP.DISP.LOC(ONE) = -ABS(TOP.DISP.LOC(ONE)) ELSE IF NOT(TOP.DISP.LOC(ONE)) THEN TOP.DISP.LOC(ONE) = ONE
END
GOSUB d01; IF STAT EQ 999 THEN RETURN
LN = MOD(VC - ONE,9) + 7
CUSTOM.START = ONE; CUSTOM.END = 3; *CUSTOM*
IF REF EQ 3 THEN CUSTOM.START = 4; CUSTOM.END = 4; *CUSTOM*
FOR SUB.REF = CUSTOM.START TO CUSTOM.END; *CUSTOM* was ONE to 4
ON SUB.REF GOSUB i01B,i01C,i01D,i01E
IF STAT EQ 999 THEN RETURN
IF STAT THEN IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO; IF SUB.REF LT ZERO THEN SUB.REF = 5
NEXT SUB.REF
GOTO i01
i01A: CALL INPUT.DATA(CNT,9,LN,"L1",1:",":VC,EMPTY,"NU",EMPTY,RSP,STAT)
RETURN
i01B: CALL INPUT.DATA(CNT,12,LN,"L15",2:",":VC,EMPTY,EMPTY,EMPTY,RSP,STAT)
RETURN
i01C: CALL INPUT.DATA(CNT,30,LN,"L2",3:",":VC,"MR(#2)","MA0N' '1N",EMPTY,RSP,STAT)
RETURN
i01D: CALL INPUT.DATA(CNT,33,LN,"L10",4:",":VC,EMPTY,EMPTY,EMPTY,RSP,STAT)
RETURN
i01E: CALL INPUT.DATA(CNT,46,LN,"L2",5:",":VC,"MR(#2)","MA0N' '1N",EMPTY,RSP,STAT)
RETURN
d01: SAVE.VC = VC
IF TOP.DISP.LOC(ONE) LT ZERO THEN TOP.DISP.LOC(ONE) = ABS(TOP.DISP.LOC(ONE)) ELSE
IF VC GE TOP.DISP.LOC(ONE) THEN IF VC LE TOP.DISP.LOC(ONE) + 8 THEN
IF DYNAMIC EQ "N" THEN LN = MOD(VC - ONE,9) + 7; PRINT @(9,LN):CNT<ONE,VC> "L#1":
RETURN
END
END
IF TOP.DISP.LOC(ONE) THEN VC = VC - MOD(VC - ONE,9); CLEAR = ONE ELSE VC = ONE; CLEAR = ZERO
TOP.LOC = EMPTY
LOOP
FOR LN = 7 TO 15 UNTIL CNT<ONE,VC> EQ EMPTY
IF LN EQ 7 THEN TOP.LOC = VC
PRINT @(9,LN):CNT<ONE,VC> "L#1":
PRINT @(12,LN):CNT<2,VC> "L#15":
PRINT @(30,LN):OCONV(CNT<3,VC>,"MR(#2)") "L#2":
PRINT @(33,LN):CNT<4,VC> "L#10":
PRINT @(46,LN):OCONV(CNT<5,VC>,"MR(#2)") "L#2":
VC = VC + ONE
NEXT LN
IF TOP.DISP.LOC(ONE) OR CNT<ONE,VC> EQ EMPTY THEN RSP = EMPTY ELSE
PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
END
WHILE RSP EQ "Y" DO LN = 7; GOSUB c01 REPEAT
IF CLEAR THEN GOSUB c01 ELSE CLEAR = ONE
IF TOP.LOC THEN TOP.DISP.LOC(ONE) = TOP.LOC
VC = SAVE.VC
RETURN
c01: FOR LN = LN TO 15
PRINT @(9,LN):SPACE(ONE):
PRINT @(12,LN):SPACE(15):
PRINT @(30,LN):SPACE(TWO):
PRINT @(33,LN):SPACE(10):
PRINT @(46,LN):SPACE(TWO):
NEXT LN
RETURN
i02:  PRINT @(ZERO,23):CLL:"Enter Queue number: ":
FLD = EMPTY; CALL INPUT.DATA(FLD,20,23,"L2",1,"MR(#2)","SEOPMA0N' '1N",EMPTY,RSP,STAT)
IF STAT EQ 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i02
IF FLD EQ EMPTY THEN RETURN
LOCATE FLD IN CNT<6> BY "AR" SETTING VC THEN
PRINT @(ZERO,23):CLL:"Ref. QD> ":OCONV(FLD,"MR(#2)"):" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN DYNAMIC = EMPTY; PRINT @(ZERO,23):CLL: ELSE
DEL CNT<6,VC>
DEL CNT<7,VC>
TOP.DISP.LOC(TWO) = -ABS(TOP.DISP.LOC(TWO))
DYNAMIC = "D"; GOSUB d02; IF STAT EQ 999 THEN RETURN
GOTO i02
END
END ELSE
IF CNT<6,VC> EQ EMPTY THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC GT 99 THEN IF NEW AND DYNAMIC EQ "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO i02
END
INS FLD BEFORE CNT<6,VC>
INS EMPTY BEFORE CNT<7,VC>
IF DYNAMIC EQ "I" THEN TOP.DISP.LOC(TWO) = -ABS(TOP.DISP.LOC(TWO)) ELSE IF NOT(TOP.DISP.LOC(TWO)) THEN TOP.DISP.LOC(TWO) = ONE
END
GOSUB d02; IF STAT EQ 999 THEN RETURN
LN = MOD(VC - ONE,14) + 7
FOR SUB.REF = ONE TO ONE
ON SUB.REF GOSUB i02B
IF STAT EQ 999 THEN RETURN
IF STAT THEN IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO; IF SUB.REF LT ZERO THEN SUB.REF = TWO
NEXT SUB.REF
GOTO i02
i02A: CALL INPUT.DATA(CNT,56,LN,"L2",6:",":VC,"MR(#2)","MA0N' '1N",EMPTY,RSP,STAT)
RETURN
i02B: CALL INPUT.DATA(CNT,60,LN,"L20",7:",":VC,EMPTY,EMPTY,EMPTY,RSP,STAT)
RETURN
d02: SAVE.VC = VC
IF TOP.DISP.LOC(TWO) LT ZERO THEN TOP.DISP.LOC(TWO) = ABS(TOP.DISP.LOC(TWO)) ELSE
IF VC GE TOP.DISP.LOC(TWO) THEN IF VC LE TOP.DISP.LOC(TWO) + 13 THEN
IF DYNAMIC EQ "N" THEN LN = MOD(VC - ONE,14) + 7; PRINT @(56,LN):OCONV(CNT<6,VC>,"MR(#2)") "L#2":
RETURN
END
END
IF TOP.DISP.LOC(TWO) THEN VC = VC - MOD(VC - ONE,14); CLEAR = ONE ELSE VC = ONE; CLEAR = ZERO
TOP.LOC = EMPTY
LOOP
FOR LN = 7 TO 20 UNTIL CNT<6,VC> EQ EMPTY
IF LN EQ 7 THEN TOP.LOC = VC
PRINT @(56,LN):OCONV(CNT<6,VC>,"MR(#2)") "L#2":
PRINT @(60,LN):CNT<7,VC> "L#20":
VC = VC + ONE
NEXT LN
IF TOP.DISP.LOC(TWO) OR CNT<6,VC> EQ EMPTY THEN RSP = EMPTY ELSE
PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
END
WHILE RSP EQ "Y" DO LN = 7; GOSUB c02 REPEAT
IF CLEAR THEN GOSUB c02 ELSE CLEAR = ONE
IF TOP.LOC THEN TOP.DISP.LOC(TWO) = TOP.LOC
VC = SAVE.VC
RETURN
c02: FOR LN = LN TO 20
PRINT @(56,LN):SPACE(TWO):
PRINT @(60,LN):SPACE(20):
NEXT LN
RETURN
!
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:@(ZERO,23):CLL:TEXT[ONE,80]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(ZERO,23):CLL:
*
RETURN
*
!
*
UPD.CALL: *
*
* Set printer(s) as per screen...
VM.CN.MAX = DCOUNT(CNT<ONE>,VM)
VM.CN = ZERO
*
LOOP VM.CN = VM.CN + ONE WHILE VM.CN LE VM.CN.MAX DO
*
IF CNT<ONE,VM.CN> NE EMPTY THEN
*
*
LOCATE CNT<ONE,VM.CN> IN PREV.PRINTERS<ONE> SETTING LOC THEN NULL
*
IF CNT<ONE,VM.CN> NE PREV.PRINTERS<ONE,LOC> OR CNT<5,VM.CN> NE PREV.QUEUES<ONE,LOC> THEN
*
STOPPED = TRUE
*
LOOP WHILE STOPPED DO
*
TCL.MSG = EMPTY
*
! Handle different operating system
*
BEGIN CASE
*
CASE OPSYS EQ "U"
*
EX.LINE = "SP-STARTLPTR ":CNT<ONE,VM.CN>:",":CNT<5,VM.CN>:",0,S":CNT<3,VM.CN>
*
EXECUTE EX.LINE, //OUT. > TCL.MSG
MSG.NUM = FIELD(TCL.MSG<ONE>,"]",ONE); MSG.NUM = FIELD(MSG.NUM,"[",TWO)
MSG.TEXT = TCL.MSG[COL2() + ONE,9999]
MSG.TEXT = MSG.TEXT<ONE,ONE,ONE>
BEGIN CASE
CASE MSG.NUM EQ "1116"; STOPPED = FALSE
CASE MSG.NUM EQ "1118"; STOPPED = FALSE
CASE MSG.NUM EQ "1105"; STOPPED = TRUE; TCL.MSG = "printer not stopped"
CASE TRUE; STOPPED = ONE; TCL.MSG = "Error ":MSG.NUM:" ":MSG.TEXT "L#50"
END CASE
*
*
CASE OPSYS EQ "M"
EX.LINE = "SP-CREATE STANDARD ":CNT<8,?>:" ":CNT<3,?>
EXUCUTE EX.LINE, //OUT. > TCL.MSG
MSG.NUM = FIELD(TCL.MSG<ONE>,"]",ONE); MSG.NUM = FIELD(MSG.NUM,"[",TWO)
MSG.TEXT = TCL.MSG[COL2() + ONE,9999]
MSG.TEXT = MSG.TEXT<ONE,ONE,ONE>
STOPPED = ONE; TCL.MSG = "Result ":MSG.NUM:" ":MSG.TEXT "L#50"
*
*
CASE TRUE
STOPPED = ONE; TCL.MSG = "Invalid Operating System for this routine"
*
END CASE
*
IF STOPPED THEN
PRINT @(ZERO,23):CLL:TCL.MSG:" - Enter KILL or <return> when OK ":
INPUT RSP:
IF RSP EQ "KILL" THEN VM.CN = 99; STOPPED = ZERO
END
*
REPEAT
*
*
END; * Of diff from prev
*
END; * Of CNT<ONE,VM.CN> ne empty
*
REPEAT
*
RETURN
*
!
*
READ.CALL: *
*
* Retrieve actual statuses of the printers...
*
*
BEGIN CASE
CASE OPSYS EQ "U"
CTR = 6
EXECUTE "SP-LISTLPTR", //OUT. > TCL.MSG
CASE OPSYS EQ "M"
CTR = ONE
*%%MDD%%=TCL.MSG = SPOOLER(1,"DUMMY")
CASE TRUE
CTR = ONE
TCL.MSG = EMPTY
END CASE
*
*
CNT<3> = EMPTY; CNT<4> = EMPTY; CNT<5> = EMPTY
CNT<8> = EMPTY; CNT<9> = EMPTY; CNT<10> = EMPTY; CNT<11> = EMPTY
*
LOOP CTR = CTR + ONE UNTIL TCL.MSG<CTR> EQ EMPTY DO
*
BEGIN CASE
*
CASE OPSYS EQ "U"
MSG = TRIM(TCL.MSG<CTR>)
MSG.PRINTER.NO = FIELD(MSG," ",TWO)
MSG.QUEUE = FIELD(MSG," ",3)
MSG.TYPE    = MSG.QUEUE
MSG.PORT = FIELD(MSG," ",5)
MSG.CLASS = "LPTR"
MSG.STATUS = FIELD(MSG," ",6)
MSG.JOBS   = ZERO
MSG.SKIP   = 0
*
CASE OPSYS EQ "M"
MSG = TCL.MSG<CTR>
MSG.PRINTER.NO = CTR - ONE
MSG.QUEUE      = TCL.MSG<ONE,ONE>
MSG.TYPE = FIELD(MSG.QUEUE,".",TWO)
MSG.TWO        = TCL.MSG<ONE,TWO>
MSG.PORT       = TCL.MSG<ONE,3>
MSG.CLASS      = TCL.MSG<ONE,4>
MSG.STATUS     = TCL.MSG<ONE,5>
MSG.JOBS       = TCL.MSG<ONE,6>
MSG.SKIP       = TCL.MSG<ONE,7>
*
BEGIN CASE
CASE (MSG.QUEUE EQ "STANDARD" OR MSG.TYPE EQ "STANDARD" OR MSG.TYPE EQ "STD") AND MSG.STATUS NE "NO DEVICE"
MSG.PRINTER.NO = ZERO
CASE (MSG.QUEUE EQ "LABELS" OR MSG.TYPE EQ "LABELS") AND MSG.STATUS NE "NO DEVICE"
MSG.PRINTER.NO = 3
CASE (MSG.QUEUE EQ "WO" OR MSG.TYPE EQ "WO") AND MSG.STATUS NE "NO DEVICE"
MSG.PRINTER.NO = TWO
CASE (MSG.QUEUE EQ "DM" OR MSG.TYPE EQ "DM") AND MSG.STATUS NE "NO DEVICE"
MSG.PRINTER.NO = 5
CASE (MSG.QUEUE EQ "STMT" OR MSG.TYPE EQ "STMT") AND MSG.STATUS NE "NO DEVICE"
MSG.PRINTER.NO = ONE
CASE (MSG.QUEUE EQ "XTR" OR MSG.TYPE EQ "XTR") AND MSG.STATUS NE "NO DEVICE"
MSG.PRINTER.NO = 6
CASE TRUE
MSG.PRINTER.NO = CTR + 10
END CASE
*
CASE TRUE
MSG = EMPTY; MSG.PRINTER.NO = EMPTY; MSG.QUEUE = EMPTY
MSG.PORT = EMPTY; MSG.CLASS = EMPTY; MSG.STATUS = EMPTY
MSG.JOBS = ZERO; MSG.SKIP = EMPTY
*
END CASE
*
*
LOCATE MSG.PRINTER.NO IN CNT<ONE> SETTING MSG.LOC ELSE
INS MSG.PRINTER.NO BEFORE CNT<ONE,MSG.LOC>
INS "<unknown>" BEFORE CNT<2,MSG.LOC>
INS EMPTY BEFORE CNT<3,MSG.LOC>
INS EMPTY BEFORE CNT<4,MSG.LOC>
INS EMPTY BEFORE CNT<5,MSG.LOC>
INS EMPTY BEFORE CNT<8,MSG.LOC>
INS EMPTY BEFORE CNT<9,MSG.LOC>
INS EMPTY BEFORE CNT<10,MSG.LOC>
INS EMPTY BEFORE CNT<11,MSG.LOC>
END
*
CNT<3,MSG.LOC> = MSG.PORT
CNT<4,MSG.LOC> = MSG.STATUS
CNT<5,MSG.LOC> = MSG.QUEUE
CNT<8,MSG.LOC> = MSG.CLASS
CNT<9,MSG.LOC> = MSG.SKIP
CNT<10,MSG.LOC>= MSG.JOBS
CNT<11,MSG.LOC>= "?"
*
REPEAT
*
!
*
PREV.PRINTERS = CNT<ONE>
PREV.QUEUES = CNT<5>
RETURN
!
END
~MAINT.PRINTER.QUEUES.DEC~
*PROGRAM: SH.MAINT.PRINTER.QUEUES 
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      18 SEP 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(2)
VALID.REFS = "P":AM:"QD"
VALID.REFS = VALID.REFS:AM:"Q"; *CUSTOM*
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
CNT.ID = ""; GOSUB GET.KEY; IF CNT.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ CNT FROM CNT.FILE,CNT.ID THEN NEW = "" ELSE NEW = 1; CNT = ""
GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 2
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT @(0,23):CLL:"Enter screen ref., REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
GOSUB UPD.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
WRITE CNT ON CNT.FILE,CNT.ID
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                      Maintain System Printers and Queues                       ":RVE:
PRINT @(0,3):RVB:"P>                                        Q>    ":RVE:"  ":RVB:"QD>                           ":RVE:
PRINT @(0,4):RVB:"   Printer                  Port Printer     Que":RVE:"  ":RVB:"   Print                      ":RVE:
PRINT @(0,5):RVB:"         #  Location           # Status        #":RVE:"  ":RVB:"   Queue  Description         ":RVE:
PRINT @(0,18):RVB:"CAUTION:                                       ":RVE:
PRINT @(0,19):RVB:"    1. Do NOT use P> unless you are installing ":RVE:
PRINT @(0,20):RVB:"       or removing a printer from the system   ":RVE:
PRINT @(0,21):RVB:"       or changing the location or port #.     ":RVE:
PRINT @(0,22):RVB:"    2. Use Q> to change a printer's queue #.   ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = ""; GOSUB d01; IF STAT = 999 THEN RETURN
DYNAMIC = ""; GOSUB d02; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
CNT.ID = "PRINTER.QUEUES"
RETURN
!
GET.DATA: *
ON REF GOSUB i01,i02,i01; *CUSTOM*
RETURN
!
i01:  PRINT @(0,23):CLL:"Enter printer number: ":
FLD = ""; CALL INPUT.DATA(FLD,22,23,"L1",1,"","SEOPNU","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i01
IF FLD = "" THEN RETURN
LOCATE FLD IN CNT<1> BY "AR" SETTING VC THEN
IF REF = 3 THEN DYNAMIC = ""; *CUSTOM*
IF REF = 1 THEN; *CUSTOM*
PRINT @(0,23):CLL:"Ref. P> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT @(0,23):CLL: ELSE
DEL CNT<1,VC>
DEL CNT<2,VC>
DEL CNT<3,VC>
DEL CNT<4,VC>
DEL CNT<5,VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
DYNAMIC = "D"; GOSUB d01; IF STAT = 999 THEN RETURN
GOTO i01
END
END; *CUSTOM*
END ELSE
IF REF = 3 THEN TEXT = "not a valid printer number"; GOTO i01; *CUSTOM*
IF CNT<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 10 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 10"; GOSUB ERROR; GOTO i01
END
INS FLD BEFORE CNT<1,VC>
INS "" BEFORE CNT<2,VC>
INS "" BEFORE CNT<3,VC>
INS "" BEFORE CNT<4,VC>
INS "" BEFORE CNT<5,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB d01; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,9)+7
CUSTOM.START = 1; CUSTOM.END = 3; *CUSTOM*
IF REF = 3 THEN CUSTOM.START = 4; CUSTOM.END = 4; *CUSTOM*
FOR SUB.REF = CUSTOM.START TO CUSTOM.END; *CUSTOM* was 1 to 4
ON SUB.REF GOSUB i01B,i01C,i01D,i01E
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 5
NEXT SUB.REF
GOTO i01
i01A: CALL INPUT.DATA(CNT,9,LN,"L1",1:",":VC,"","NU","",RSP,STAT)
RETURN
i01B: CALL INPUT.DATA(CNT,12,LN,"L15",2:",":VC,"","","",RSP,STAT)
RETURN
i01C: CALL INPUT.DATA(CNT,30,LN,"L2",3:",":VC,"MR(#2)","MA0N' '1N","",RSP,STAT)
RETURN
i01D: CALL INPUT.DATA(CNT,33,LN,"L10",4:",":VC,"","","",RSP,STAT)
RETURN
i01E: CALL INPUT.DATA(CNT,46,LN,"L2",5:",":VC,"MR(#2)","MA0N' '1N","",RSP,STAT)
RETURN
d01: SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+8 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,9)+7; PRINT @(9,LN):CNT<1,VC> "L#1":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,9); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 7 TO 15 UNTIL CNT<1,VC> = ""
IF LN = 7 THEN TOP.LOC = VC
PRINT @(9,LN):CNT<1,VC> "L#1":
PRINT @(12,LN):CNT<2,VC> "L#15":
PRINT @(30,LN):OCONV(CNT<3,VC>,"MR(#2)") "L#2":
PRINT @(33,LN):CNT<4,VC> "L#10":
PRINT @(46,LN):OCONV(CNT<5,VC>,"MR(#2)") "L#2":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR CNT<1,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 7; GOSUB c01 REPEAT
IF CLEAR THEN GOSUB c01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
c01: FOR LN = LN TO 15
PRINT @(9,LN):SPACE(1):
PRINT @(12,LN):SPACE(15):
PRINT @(30,LN):SPACE(2):
PRINT @(33,LN):SPACE(10):
PRINT @(46,LN):SPACE(2):
NEXT LN
RETURN
i02:  PRINT @(0,23):CLL:"Enter Queue number: ":
FLD = ""; CALL INPUT.DATA(FLD,20,23,"L2",1,"MR(#2)","SEOPMA0N' '1N","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i02
IF FLD = "" THEN RETURN
LOCATE FLD IN CNT<6> BY "AR" SETTING VC THEN
PRINT @(0,23):CLL:"Ref. QD> ":OCONV(FLD,"MR(#2)"):" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT @(0,23):CLL: ELSE
DEL CNT<6,VC>
DEL CNT<7,VC>
TOP.DISP.LOC(2) = -ABS(TOP.DISP.LOC(2))
DYNAMIC = "D"; GOSUB d02; IF STAT = 999 THEN RETURN
GOTO i02
END
END ELSE
IF CNT<6,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO i02
END
INS FLD BEFORE CNT<6,VC>
INS "" BEFORE CNT<7,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(2) = -ABS(TOP.DISP.LOC(2)) ELSE IF NOT(TOP.DISP.LOC(2)) THEN TOP.DISP.LOC(2) = 1
END
GOSUB d02; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,14)+7
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB i02B
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 2
NEXT SUB.REF
GOTO i02
i02A: CALL INPUT.DATA(CNT,56,LN,"L2",6:",":VC,"MR(#2)","MA0N' '1N","",RSP,STAT)
RETURN
i02B: CALL INPUT.DATA(CNT,60,LN,"L20",7:",":VC,"","","",RSP,STAT)
RETURN
d02: SAVE.VC = VC
IF TOP.DISP.LOC(2) < 0 THEN TOP.DISP.LOC(2) = ABS(TOP.DISP.LOC(2)) ELSE
IF VC >= TOP.DISP.LOC(2) THEN IF VC <= TOP.DISP.LOC(2)+13 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,14)+7; PRINT @(56,LN):OCONV(CNT<6,VC>,"MR(#2)") "L#2":
RETURN
END
END
IF TOP.DISP.LOC(2) THEN VC = VC-MOD(VC-1,14); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 7 TO 20 UNTIL CNT<6,VC> = ""
IF LN = 7 THEN TOP.LOC = VC
PRINT @(56,LN):OCONV(CNT<6,VC>,"MR(#2)") "L#2":
PRINT @(60,LN):CNT<7,VC> "L#20":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(2) OR CNT<6,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 7; GOSUB c02 REPEAT
IF CLEAR THEN GOSUB c02 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(2) = TOP.LOC
VC = SAVE.VC
RETURN
c02: FOR LN = LN TO 20
PRINT @(56,LN):SPACE(2):
PRINT @(60,LN):SPACE(20):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
UPD.CALL: *
* Set printer(s) as per screen...
CTR = 0
LOOP CTR = CTR+1 UNTIL CNT<1,CTR> = '' DO
LOCATE CNT<1,CTR> IN PREV.PRINTERS<1> SETTING LOC THEN NULL
IF CNT<1,CTR> # PREV.PRINTERS<1,LOC> OR CNT<5,CTR> # PREV.QUEUES<1,LOC> THEN
EX.LINE = "SP-STARTLPTR ":CNT<1,CTR>:",":CNT<5,CTR>:",0,S":CNT<3,CTR>
STOPPED = 1
LOOP WHILE STOPPED = 1 DO
TCL.MSG = ''
EXECUTE EX.LINE, //OUT. > TCL.MSG
MSG.NUM = FIELD(TCL.MSG<1>,"]",1); MSG.NUM = FIELD(MSG.NUM,"[",2)
BEGIN CASE
CASE MSG.NUM = "1116"; STOPPED = 0
CASE MSG.NUM = "1118"; STOPPED = 0
CASE MSG.NUM = "1105"; STOPPED = 1; TCL.MSG = "printer not stopped"
CASE 1; STOPPED = 1; TCL.MSG = "Error ":MSG.NUM
END CASE
IF STOPPED THEN
PRINT @(0,23):CLL:TCL.MSG:" - Enter KILL or <return> when OK ":
INPUT RSP:
IF RSP = "KILL" THEN CTR = 99; STOPPED = 0
END
REPEAT
END
REPEAT
RETURN
!
READ.CALL: *
* Retrieve actual statuses of the printers...
EXECUTE "SP-LISTLPTR", //OUT. > TCL.MSG
CNT<3> = ''; CNT<4> = ''; CNT<5> = ''
CTR = 6
LOOP CTR = CTR+1 UNTIL TCL.MSG<CTR> = '' DO
MSG = TRIM(TCL.MSG<CTR>)
MSG.PRINTER.NO = FIELD(MSG," ",2)
MSG.QUEUE = FIELD(MSG," ",3)
MSG.PORT = FIELD(MSG," ",5)
MSG.STATUS = FIELD(MSG," ",6)
LOCATE MSG.PRINTER.NO IN CNT<1> SETTING MSG.LOC ELSE
INS MSG.PRINTER.NO BEFORE CNT<1,MSG.LOC>
INS "<unknown>" BEFORE CNT<2,MSG.LOC>
INS '' BEFORE CNT<3,MSG.LOC>
INS '' BEFORE CNT<4,MSG.LOC>
INS '' BEFORE CNT<5,MSG.LOC>
END
CNT<3,MSG.LOC> = MSG.PORT
CNT<4,MSG.LOC> = MSG.STATUS
CNT<5,MSG.LOC> = MSG.QUEUE
REPEAT
PREV.PRINTERS = CNT<1>
PREV.QUEUES = CNT<5>
RETURN
!
END
~MAINT.TERMINAL.TYPES~
*PROGRAM:           SH.MAINT.TERMINAL.TYPES
* AUTHOR:            XXX
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      26 AUG 88
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "DICT","TERMINAL.FILE" TO DICT.TERMINAL.FILE.FILE ELSE TEXT = "Can't open DICT.TERMINAL.FILE"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(1)
VALID.REFS = "PO"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
DICT.TERMINAL.FILE.ID = ""; GOSUB GET.KEY; IF DICT.TERMINAL.FILE.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(DICT.TERMINAL.FILE.FILE,"DICT.TERMINAL.FILE",DICT.TERMINAL.FILE.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ DICT.TERMINAL.FILE FROM DICT.TERMINAL.FILE.FILE,DICT.TERMINAL.FILE.ID THEN NEW = "" ELSE NEW = 1; DICT.TERMINAL.FILE = ""
*vvv CUSTOM
FOR A = 1 TO 99
DICT.TERMINAL.FILE<1,A> = ("00":A-1) "R#2"
NEXT A
*^^^ CUSTOM
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = DICT.TERMINAL.FILE.ID; DICT.TERMINAL.FILE.ID = "!":DICT.TERMINAL.FILE.ID; GOSUB GET.KEY; DICT.TERMINAL.FILE.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 1
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
* CUSTOM *PRINT CLB:"Enter CHange, DElete, REdisplay, KILL or <cr> to update: ":
PRINT CLB:"Enter CHange, REdisplay, KILL or <cr> to update: ":; * CUSTOM
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
* CUSTOM *CASE RSP = "DE"
* CUSTOM *PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
* CUSTOM *INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
* CUSTOM *IF RSP # "Y" THEN GOTO CHANGES
* CUSTOM *DELETE DICT.TERMINAL.FILE.FILE,DICT.TERMINAL.FILE.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = DICT.TERMINAL.FILE.ID; DICT.TERMINAL.FILE.ID = "!":DICT.TERMINAL.FILE.ID; GOSUB GET.KEY; DICT.TERMINAL.FILE.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE DICT.TERMINAL.FILE ON DICT.TERMINAL.FILE.FILE,DICT.TERMINAL.FILE.ID
*vvv CUSTOM
TEMP = ""
FOR A = 1 TO 99
TEMP<A> = DICT.TERMINAL.FILE<2,A>
NEXT A
WRITE TEMP ON DICT.TERMINAL.FILE.FILE,"TERMINALS"
*^^^ CUSTOM
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(DICT.TERMINAL.FILE.FILE,"DICT.TERMINAL.FILE",DICT.TERMINAL.FILE.ID,LCK.FILE)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                            Device Type Maintenance                             ":RVE:
PRINT @(0,3):RVB:"Port ":RVE:"   ":RVB:"Terminal Type  ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = ""; GOSUB D01; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
DICT.TERMINAL.FILE.ID = "TERMINAL.MAINT"
RETURN
!
GET.DATA: *
ON REF GOSUB I01
RETURN
!
I01: *
PRINT CLB:"ENTER PORT number: ":
FLD = ""; CALL INPUT.DATA(FLD,19,23,"L2",1,"","SE":VM:"OP":VM:"MA2N","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I01
IF FLD = "" THEN RETURN
LOCATE FLD IN DICT.TERMINAL.FILE<1> BY "AR" SETTING VC THEN
* CUSTOM *PRINT CLB:FLD:" - Delete it (Y/<cr>)? ":
* CUSTOM *INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
* CUSTOM *IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
* CUSTOM *DEL DICT.TERMINAL.FILE<1,VC>
* CUSTOM *DEL DICT.TERMINAL.FILE<2,VC>
* CUSTOM *TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
* CUSTOM *DYNAMIC = "D"; GOSUB D01; IF STAT = 999 THEN RETURN
* CUSTOM *GOTO I01
* CUSTOM *END
DYNAMIC = ""; * CUSTOM
END ELSE
IF DICT.TERMINAL.FILE<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I01
END
INS FLD BEFORE DICT.TERMINAL.FILE<1,VC>
INS "" BEFORE DICT.TERMINAL.FILE<2,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB D01; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,17)+4
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB I01B
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 2
NEXT SUB.REF
GOTO I01
I01A: *
CALL INPUT.DATA(DICT.TERMINAL.FILE,2,LN,"L2",1:",":VC,"","MA2N","",RSP,STAT)
RETURN
I01B: *
CALL INPUT.DATA(DICT.TERMINAL.FILE,15,LN,"L1",2:",":VC,"","MADUHEPpR","",RSP,STAT)
RETURN
D01: *
SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+16 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,17)+4; PRINT @(2,LN):DICT.TERMINAL.FILE<1,VC> "L#2":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,17); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 4 TO 20 UNTIL DICT.TERMINAL.FILE<1,VC> = ""
IF LN = 4 THEN TOP.LOC = VC
PRINT @(2,LN):DICT.TERMINAL.FILE<1,VC> "L#2":
PRINT @(15,LN):DICT.TERMINAL.FILE<2,VC> "L#1":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR DICT.TERMINAL.FILE<1,VC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 4; GOSUB C01 REPEAT
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
C01: *
FOR LN = LN TO 20
PRINT @(2,LN):SPACE(2):
PRINT @(15,LN):SPACE(1):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~MDD.LOCK.ITEM~
SUBROUTINE LOCK.ITEM(FILE.NAME,ITEM.ID,LCK.FILE,LCK.STAT)
* VERSION: 950427 3.0  DO NOT PROMPT FOR INPUT IF No INPUT TYPE.
* PRIOR: 930312 2.8  SCREEN I/O FOR REV LOCKING ADDED BY DH.
* PRIOR: 910917 261  MAJOR CHANGES MADE BY DH
* (ITEM.FILE,FILE.NAME,ITEM.ID,LCK.FILE,RETRY,DISP,INPT,OVERRIDE,LCK.STAT)
* PRIOR: 900415 1.9
* PROGRAM:           LOCK.ITEM
* AUTHOR:            DAVID HORSMAN - AXION
* DESCRIPTION:       LOCK AN ITEM
*
* PASSED TO CALLING PROGRAM:
*     LCK.STAT      MEANING
*     ____      __________________________________
*        0      SUCCESSFULLY LOCKED
*      nnn      ALREADY LOCKED AT TERMINAL nnn - 1
*      900      SYSTEM LEVEL LOCK PRESENT
*      999      OPERATOR 'KILL' REQUEST
*
* IF RSP EQ 'OVERRIDE'    -   OPERATOR 'OVERRIDE' REQUEST
* 'RETRY' MEANS RETRYING TO LOCK *** WITHIN THIS PROGRAM ***
* 'T/O' MEANS A THREE SECOND TIMEOUT BEFORE RETRYING
*
* PASSED TO THIS PROGRAM BY LCK.STAT: 
*       ZERO = Normal: RETRY, MSG, INPUT (T/O)
*       -ONE = No RETRY if already locked, MSG, INPUT (IMMED)
*       -TWO = No RETRY, MSG, INPUT <cr> if locked (IMMED)
*       -3   = RETRY, MSG, No INPUT if already locked (T/O)
*       -4   = No RETRY, MSG, No INPUT if already locked (IMMED)
*       -5   = No RETRY, No MSG, No INPUT if already locked (IMMED)
*       -6   = No RETRY, No MSG, No INPUT, OVERRIDE if locked (IMMED) ** DANGEROUS **
*       -7   = RETRY, No MSG, No INPUT, OVERRIDE if locked (T/O) ** DANGEROUS **
*
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LOCKS.VAR.EQUATES
*
LCK.TYPE = LCK.STAT
IF COUNT(FILE.NAME,"#") THEN
LCK.PROG.NAME = FIELD(FILE.NAME,"#",TWO)
FILE.NAME = FIELD(FILE.NAME,"#",ONE)
END ELSE LCK.PROG.NAME = EMPTY
LCK.ID = FILE.NAME:"*":ITEM.ID
!
READ.IT: * ATTEMPT TO READ THE LOCK ITEM
*
MSG = EMPTY; TRY.CN = 1
*
LOOP
*
IF MSG NE EMPTY THEN IF LCK.TYPE GE -4 THEN
PRINT CLB2:MSG:; * of TYPE
PRINT CLB1:"Lock attempt no. ":TRY.CN-ONE:; * of TYPE
END; * of TYPE
IF MSG NE EMPTY AND LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
*
LCK.LOCKED = FALSE
*
* LOCK ITEM.FILE, ITEM.ID THEN; * REV ONLY
* GOTO LCK.IT; * REV ONLY
* END ELSE; * REV ONLY
* MSG = FILE.NAME:" ":ITEM.ID:" in use."; * REV ONLY
* GOSUB LCK.IT; * REV ONLY
* IF STATUS() NE ONE THEN; * REV ONLY
* LCK.REC<LOCKS$ACCT.NAME> = "UNKNOWN"; * REV ONLY
* LCK.REC<LOCKS$PORT> = 999; * REV ONLY
* END; * REV ONLY
* END; * REV ONLY
*
* ULT ONLY
READU LCK.REC FROM LCK.FILE,LCK.ID LOCKED LCK.LOCKED = TRUE ELSE GOTO LCK.IT
*
IF LCK.LOCKED THEN LCK.REC = EMPTY 
*
IF LCK.REC<LOCKS$PORT> EQ PORT THEN
MSG = "Lock is already present for this port!"
* IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
* IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[????]":RVE:
GOTO LCK.IT
END
*
* ULT ONLY
IF NOT(LCK.LOCKED) THEN RELEASE LCK.FILE,LCK.ID
*
IF LCK.LOCKED THEN
*
MSG = "LOCKS control information is not available yet . . . "
LCK.STAT = 900
*
END ELSE
*
IF OPSYS NE "R" THEN
*
PORT.NUM = LCK.REC<LOCKS$PORT>
ACCT.NUM = LCK.REC<LOCKS$ACCT.NAME>
LCK.DATE = LCK.REC<LOCKS$LCK.DATE>
LCK.TIME = LCK.REC<LOCKS$LCK.TIME>
LCK.ELP = ((DATE() - LCK.DATE) * 86400) + (TIME() - LCK.TIME)
IF LCK.ELP GT 7200 THEN
MSG = "Lock item is ":OCONV(LCK.ELP,"MTS"):" hours old and has expired."
IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[EXPR]":RVE:
GOTO LCK.IT
END
*
LCK.DATE = OCONV(LCK.DATE,"D2")
LCK.DATE = FIELD(LCK.DATE," ",ONE):" ":FIELD(LCK.DATE," ",2)
*
LCK.TIME.DISP = OCONV(LCK.TIME,"MTS")
*
MSG = FILE.NAME:" ":ITEM.ID:" in use by ":PORT.NUM:" ":ACCT.NUM:" (":LCK.DATE:" ":LCK.TIME.DISP:" for ":OCONV(LCK.ELP,"MTS"):")"
*
END; * OF OPSYS NOT 'R'
*
LCK.STAT = PORT.NUM + ONE
*
IF LCK.TYPE EQ -ONE OR LCK.TYPE EQ -TWO OR (LCK.TYPE LE -4 AND LCK.TYPE GE -6) THEN TRY.CN = 999
*
END; * of lock not locked
*
NEXT.TRY: *
*
* WHILE TRY.CN LT 5 DO; * REV ONLY
* ULT ONLY
WHILE TRY.CN LT 5 AND NOT(SYSTEM(11)) DO
IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
TRY.CN = TRY.CN + ONE
FOR COUNTER = ONE TO 3
RQM
NEXT COUNTER
REPEAT
*
IF LCK.TYPE LE -6 AND LCK.TYPE GE -7 AND OPSYS NE "R" THEN
MSG = "Lock OVERRIDE in effect. Now locked by your port"; * of TYPE
GOTO LCK.IT; * of TYPE
END; * of TYPE
*
IF LCK.TYPE GE -4 THEN
PRINT CLB1:MSG:; * of TYPE
PRINT CLB2:"Can't lock this information.":; * of TYPE
END; * of TYPE
IF LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[FAIL]":RVE:
IF LCK.TYPE EQ -TWO THEN
PRINT BELL:" Enter <cr>: ":
END
*
IF LCK.TYPE LE -TWO THEN GOTO RELEASE.IT
*
RQM; RQM
PRINT BELL:CLB1:MSG:
* ULT ONLY
PRINT CLB2:"Try to lock it again (<cr>/N/OVERRIDE)? ":
* PRINT CLB2:"Try to lock it again (<cr>/N)? ":; * REV ONLY
* ULT ONLY
INPUTCLEAR
IF LCK.TYPE GE -2 THEN INPUT RSP:; IF RSP EQ "KILL" THEN LCK.STAT = 999; GOTO RELEASE.IT
IF RSP EQ "OVERRIDE" AND OPSYS NE "R" THEN
* ULT ONLY
DELETE LCK.FILE,LCK.ID
* ULT ONLY
PRINT CLB1:CLB2:; GOTO READ.IT
END
IF RSP NE "N" THEN
IF MSG NE EMPTY AND LCK.TYPE GE -4 THEN PRINT CLB1:CLB2:
IF MSG NE EMPTY AND LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
GOTO READ.IT
END
*
GOTO RELEASE.IT
*
!
*
LCK.IT: * LOCK THE ITEM
*
IF MSG NE EMPTY AND LCK.TYPE GE -4 THEN
RQM; * of TYPE
PRINT CLB1:CLB2:; * of TYPE
END; * of TYPE
IF MSG NE EMPTY AND LCK.TYPE EQ -8 THEN PRINT @(ZERO,23):RVB:"[LOCK]":RVE:
*
LCK.REC    = EMPTY
LCK.REC<LOCKS$PORT> = PORT
LCK.REC<LOCKS$ACCT.NAME> = ACCT
LCK.REC<LOCKS$LCK.DATE> = DATE()
LCK.REC<LOCKS$LCK.TIME> = TIME()
LCK.REC<LOCKS$LCK.TYPE> = LCK.TYPE
LCK.REC<LOCKS$MSG>       = MSG
LCK.REC<LOCKS$PROG.NAME> = LCK.PROG.NAME
*
* ULT ONLY
WRITE LCK.REC ON LCK.FILE,LCK.ID
*
LCK.STAT = FALSE
*
RETURN
*
!
*
RELEASE.IT: *
*
* ULT ONLY
RELEASE LCK.FILE,LCK.ID
*
RETURN
*
END
~MDD.MAINT.PRINTER.QUEUES~
*PROGRAM:           SH.MAINT.PRINTER.QUEUES
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
* DATE WRITTEN:      18 SEP 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
*%%STD%%=$INCLUDE IBP STANDARD.FUNCTIONS
INCLUDE STANDARD.FUNCTIONS FROM IBP
*
*%%STD%%=OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB 2200 ; STOP
*%%STD%%=OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB 2200 ; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(2)
VALID.REFS = "P":AM:"QD"
VALID.REFS = VALID.REFS:AM:"Q"; *CUSTOM*
!
*%%STD%%=NEXT.ITEM: *
100 * NEXT.ITEM *
STAT = ""; UPDATED = ""
**%%STD%%=GOSUB DISPLAY.BACKGROUND
*GOSUB 500 
*%%STD%%=CNT.ID = ""; GOSUB GET.KEY; IF CNT.ID = "" THEN STOP
CNT.ID = ""; GOSUB 700 ; IF CNT.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE,STAT)
*%%STD%%=IF STAT THEN GOTO UNLOCK
IF STAT THEN GOTO 400 
READ CNT FROM CNT.FILE,CNT.ID THEN NEW = "" ELSE NEW = 1; CNT = ""
*%%STD%%=GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
GOSUB 2400 ; IF STAT THEN GOTO 400 
*%%STD%%=GOSUB DISPLAY.BACKGROUND
GOSUB 500 
IF NOT(NEW) THEN
*%%STD%%=GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
GOSUB 600 ; IF STAT = 999 THEN GOTO 400 
IF DISPLAY.ONLY THEN
LOOP
PRINT @(0,23):CLL:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
*%%STD%%=GOSUB DISPLAY.BACKGROUND
GOSUB 500 
*%%STD%%=TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB 700 ; CNT.ID = TEMP
*%%STD%%=GOSUB DISPLAY.FOREGROUND
GOSUB 600 
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT @(0,23):CLL:"Not on file - hit <cr> to end: ":
INPUT RSP:
*%%STD%%=GOTO NEXT.ITEM
GOTO 100 
END
LOOP
PRINT @(0,23):CLL:"New item - Do you wish to add (Y/<cr>)? ":
*%%STD%%=INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO 400 
*%%STD%%=IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO 400 
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 2
*%%STD%%=GOSUB GET.DATA
GOSUB 800 
*%%STD%%=IF STAT = 999 THEN GOTO UNLOCK
IF STAT = 999 THEN GOTO 400 
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
*%%STD%%=CHANGES: *
200 * CHANGES *
PRINT @(0,23):CLL:"Enter screen ref., REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
*%%STD%%=CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "KILL"; GOTO 400 
*%%STD%%=CASE RSP = "END"; GOTO UNLOCK
CASE RSP = "END"; GOTO 400 
*%%STD%%=CASE RSP = ""; GOTO UPDATE
CASE RSP = ""; GOTO 300 
CASE RSP = "RE"
*%%STD%%=GOSUB DISPLAY.BACKGROUND
GOSUB 500 
*%%STD%%=TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB GET.KEY; CNT.ID = TEMP
TEMP = CNT.ID; CNT.ID = "!":CNT.ID; GOSUB 700 ; CNT.ID = TEMP
*%%STD%%=GOSUB DISPLAY.FOREGROUND
GOSUB 600 
*%%STD%%=CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB 800 ELSE PRINT BELL:
END CASE
*%%STD%%=IF STAT = 999 THEN GOTO UNLOCK
IF STAT = 999 THEN GOTO 400 
*%%STD%%=GOTO CHANGES
GOTO 200 
!
*%%STD%%=UPDATE: *
300 * UPDATE *
*%%STD%%=GOSUB UPD.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
GOSUB 2300 ; IF STAT = 999 THEN GOTO 400 ELSE IF STAT THEN GOTO 200 
WRITE CNT ON CNT.FILE,CNT.ID
UPDATED = 1
!
*%%STD%%=UNLOCK: *
400 * UNLOCK *
CALL UNLOCK.ITEM(CNT.FILE,"CNT",CNT.ID,LCK.FILE)
STOP
!
*%%STD%%=DISPLAY.BACKGROUND: *
500 * DISPLAY.BACKGROUND *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-((LEN(CO.NAME)/2) "0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                      Maintain System Printers and Queues                       ":RVE:
PRINT @(0,3):RVB:"P>                                        Q>    ":RVE:"  ":RVB:"QD>                           ":RVE:
PRINT @(0,4):RVB:"   Printer                  Port Printer     Que":RVE:"  ":RVB:"   Print                      ":RVE:
PRINT @(0,5):RVB:"         #  Location           # Status        #":RVE:"  ":RVB:"   Queue  Description         ":RVE:
PRINT @(0,18):RVB:"CAUTION:                                       ":RVE:
PRINT @(0,19):RVB:"    1. Do NOT use P> unless you are installing ":RVE:
PRINT @(0,20):RVB:"       or removing a printer from the system   ":RVE:
PRINT @(0,21):RVB:"       or changing the location or port #.     ":RVE:
PRINT @(0,22):RVB:"    2. Use Q> to change a printer's queue #.   ":RVE:
RETURN
!
*%%STD%%=DISPLAY.FOREGROUND: *
600 * DISPLAY.FOREGROUND *
*%%STD%%=DYNAMIC = ""; GOSUB d01; IF STAT = 999 THEN RETURN
DYNAMIC = ""; GOSUB 1500 ; IF STAT = 999 THEN RETURN
*%%STD%%=DYNAMIC = ""; GOSUB d02; IF STAT = 999 THEN RETURN
DYNAMIC = ""; GOSUB 2000 ; IF STAT = 999 THEN RETURN
RETURN
!
*%%STD%%=GET.KEY: *
700 * GET.KEY *
CNT.ID = "PRINTER.QUEUES"
RETURN
!
*%%STD%%=GET.DATA: *
800 * GET.DATA *
*%%STD%%=ON REF GOSUB i01,i02,i01; *CUSTOM*
ON REF GOSUB 900,1700,900 ; *CUSTOM*
RETURN
!
*%%STD%%=i01:  PRINT @(0,23):CLL:"Enter printer number: ":
900   PRINT @(0,23):CLL:"Enter printer number: ":
FLD = ""; CALL INPUT.DATA(FLD,22,23,"L1",1,"","SEOPNU","",RSP,STAT)
IF STAT = 999 THEN RETURN
*%%STD%%=IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i01
IF STAT THEN TEXT = RSP<2>; GOSUB 2200 ; GOTO 900 
IF FLD = "" THEN RETURN
LOCATE FLD IN CNT<1> BY "AR" SETTING VC THEN
IF REF = 3 THEN DYNAMIC = ""; *CUSTOM*
IF REF = 1 THEN; *CUSTOM*
PRINT @(0,23):CLL:"Ref. P> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT @(0,23):CLL: ELSE
DEL CNT<1,VC>
DEL CNT<2,VC>
DEL CNT<3,VC>
DEL CNT<4,VC>
DEL CNT<5,VC>
DEL CNT<8,VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
*%%STD%%=DYNAMIC = "D"; GOSUB d01; IF STAT = 999 THEN RETURN
DYNAMIC = "D"; GOSUB 1500 ; IF STAT = 999 THEN RETURN
*%%STD%%=GOTO i01
GOTO 900 
END
END; *CUSTOM*
END ELSE
*%%STD%%=IF REF = 3 THEN TEXT = "not a valid printer number"; GOTO i01; *CUSTOM*
IF REF = 3 THEN TEXT = "not a valid printer number"; GOTO 900 ; *CUSTOM*
IF CNT<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 10 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
*%%STD%%=TEXT = "Max. entries allowed is 10"; GOSUB ERROR; GOTO i01
TEXT = "Max. entries allowed is 10"; GOSUB 2200 ; GOTO 900 
END
INS FLD BEFORE CNT<1,VC>
INS "" BEFORE CNT<2,VC>
INS "" BEFORE CNT<3,VC>
INS "" BEFORE CNT<4,VC>
INS "" BEFORE CNT<5,VC>
INS "" BEFORE CNT<8,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
*%%STD%%=GOSUB d01; IF STAT = 999 THEN RETURN
GOSUB 1500 ; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,9)+7
CUSTOM.START = 1; CUSTOM.END = 3; *CUSTOM*
IF REF = 3 THEN CUSTOM.START = 4; CUSTOM.END = 4; *CUSTOM*
FOR SUB.REF = CUSTOM.START TO CUSTOM.END; *CUSTOM* was 1 to 4
*%%STD%%=ON SUB.REF GOSUB i01B,i01C,i01D,i01E
ON SUB.REF GOSUB 1100,1200,1300,1400 
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 5
NEXT SUB.REF
*%%STD%%=GOTO i01
GOTO 900 
*%%STD%%=i01A: CALL INPUT.DATA(CNT,9,LN,"L1",1:",":VC,"","NU","",RSP,STAT)
1000  CALL INPUT.DATA(CNT,9,LN,"L1",1:",":VC,"","NU","",RSP,STAT)
RETURN
*%%STD%%=i01B: CALL INPUT.DATA(CNT,12,LN,"L15",2:",":VC,"","","",RSP,STAT)
1100  CALL INPUT.DATA(CNT,12,LN,"L15",2:",":VC,"","","",RSP,STAT)
RETURN
*%%STD%%=i01C: CALL INPUT.DATA(CNT,30,LN,"L2",3:",":VC,"MR2","MA0N' '1N","",RSP,STAT)
1200  CALL INPUT.DATA(CNT,30,LN,"L2",3:",":VC,"MD0","MA0N' '1N","",RSP,STAT)
RETURN
*%%STD%%=i01D: CALL INPUT.DATA(CNT,33,LN,"L10",4:",":VC,"","","",RSP,STAT)
1300  CALL INPUT.DATA(CNT,33,LN,"L10",4:",":VC,"","","",RSP,STAT)
RETURN
*%%STD%%=i01E: CALL INPUT.DATA(CNT,46,LN,"L2",5:",":VC,"MR2","MA0N' '1N","",RSP,STAT)
1400  CALL INPUT.DATA(CNT,46,LN,"L2",5:",":VC,"MD0","MA0N' '1N","",RSP,STAT)
RETURN
*%%STD%%=d01: SAVE.VC = VC
1500  SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+8 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,9)+7; PRINT @(9,LN):CNT<1,VC> "L#1":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,9); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 7 TO 15 UNTIL CNT<1,VC> = ""
IF LN = 7 THEN TOP.LOC = VC
PRINT @(3,LN):CNT<1,VC> "L#1":" - ":CNT<8,VC>:
PRINT @(12,LN):CNT<2,VC> "L#15":
*%%STD%%=PRINT @(30,LN):OCONV(CNT<3,VC>,"MR2") "L#2":
PRINT @(30,LN):OCONV(CNT<3,VC>,"MD0") "L#2":
PRINT @(33,LN):CNT<4,VC> "L#10":
*%%STD%%=PRINT @(46,LN):OCONV(CNT<5,VC>,"MR2") "L#2":
PRINT @(46,LN):OCONV(CNT<5,VC>,"MD0") "L#2":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR CNT<1,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
*%%STD%%=WHILE RSP = "Y" DO LN = 7; GOSUB c01 REPEAT
WHILE RSP = "Y" DO LN = 7; GOSUB 1600 REPEAT
*%%STD%%=IF CLEAR THEN GOSUB c01 ELSE CLEAR = 1
IF CLEAR THEN GOSUB 1600 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
*%%STD%%=c01: FOR LN = LN TO 15
1600  FOR LN = LN TO 15
PRINT @(9,LN):SPACE(1):
PRINT @(12,LN):SPACE(15):
PRINT @(30,LN):SPACE(2):
PRINT @(33,LN):SPACE(10):
PRINT @(46,LN):SPACE(2):
NEXT LN
RETURN
*%%STD%%=i02:  PRINT @(0,23):CLL:"Enter Queue number: ":
1700   PRINT @(0,23):CLL:"Enter Queue number: ":
*%%STD%%=FLD = ""; CALL INPUT.DATA(FLD,20,23,"L2",1,"MR2","SEOPMA0N' '1N","",RSP,STAT)
FLD = ""; CALL INPUT.DATA(FLD,20,23,"L2",1,"MD0","SEOPMA0N' '1N","",RSP,STAT)
IF STAT = 999 THEN RETURN
*%%STD%%=IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO i02
IF STAT THEN TEXT = RSP<2>; GOSUB 2200 ; GOTO 1700 
IF FLD = "" THEN RETURN
LOCATE FLD IN CNT<6> BY "AR" SETTING VC THEN
*%%STD%%=PRINT @(0,23):CLL:"Ref. QD> ":OCONV(FLD,"MR2"):" - Delete it (Y/<cr>)? ":
PRINT @(0,23):CLL:"Ref. QD> ":OCONV(FLD,"MD0"):" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT @(0,23):CLL: ELSE
DEL CNT<6,VC>
DEL CNT<7,VC>
TOP.DISP.LOC(2) = -ABS(TOP.DISP.LOC(2))
*%%STD%%=DYNAMIC = "D"; GOSUB d02; IF STAT = 999 THEN RETURN
DYNAMIC = "D"; GOSUB 2000 ; IF STAT = 999 THEN RETURN
*%%STD%%=GOTO i02
GOTO 1700 
END
END ELSE
IF CNT<6,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
*%%STD%%=TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO i02
TEXT = "Max. entries allowed is 99"; GOSUB 2200 ; GOTO 1700 
END
INS FLD BEFORE CNT<6,VC>
INS "" BEFORE CNT<7,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(2) = -ABS(TOP.DISP.LOC(2)) ELSE IF NOT(TOP.DISP.LOC(2)) THEN TOP.DISP.LOC(2) = 1
END
*%%STD%%=GOSUB d02; IF STAT = 999 THEN RETURN
GOSUB 2000 ; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,14)+7
FOR SUB.REF = 1 TO 1
*%%STD%%=ON SUB.REF GOSUB i02B
ON SUB.REF GOSUB 1900 
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 2
NEXT SUB.REF
*%%STD%%=GOTO i02
GOTO 1700 
*%%STD%%=i02A: CALL INPUT.DATA(CNT,56,LN,"L2",6:",":VC,"MR2","MA0N' '1N","",RSP,STAT)
1800  CALL INPUT.DATA(CNT,56,LN,"L2",6:",":VC,"MD0","MA0N' '1N","",RSP,STAT)
RETURN
*%%STD%%=i02B: CALL INPUT.DATA(CNT,60,LN,"L20",7:",":VC,"","","",RSP,STAT)
1900  CALL INPUT.DATA(CNT,60,LN,"L20",7:",":VC,"","","",RSP,STAT)
RETURN
*%%STD%%=d02: SAVE.VC = VC
2000  SAVE.VC = VC
IF TOP.DISP.LOC(2) < 0 THEN TOP.DISP.LOC(2) = ABS(TOP.DISP.LOC(2)) ELSE
IF VC >= TOP.DISP.LOC(2) THEN IF VC <= TOP.DISP.LOC(2)+13 THEN
*%%STD%%=IF DYNAMIC = "N" THEN LN = MOD(VC-1,14)+7; PRINT @(56,LN):OCONV(CNT<6,VC>,"MR2") "L#2":
IF DYNAMIC = "N" THEN LN = MOD(VC-1,14)+7; PRINT @(56,LN):OCONV(CNT<6,VC>,"MD0") "L#2":
RETURN
END
END
IF TOP.DISP.LOC(2) THEN VC = VC-MOD(VC-1,14); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 7 TO 20 UNTIL CNT<6,VC> = ""
IF LN = 7 THEN TOP.LOC = VC
*%%STD%%=PRINT @(56,LN):OCONV(CNT<6,VC>,"MR2") "L#2":
PRINT @(56,LN):OCONV(CNT<6,VC>,"MD0") "L#2":
PRINT @(60,LN):CNT<7,VC> "L#20":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(2) OR CNT<6,VC> = "" THEN RSP = "" ELSE
PRINT @(0,23):CLL:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
*%%STD%%=WHILE RSP = "Y" DO LN = 7; GOSUB c02 REPEAT
WHILE RSP = "Y" DO LN = 7; GOSUB 2100 REPEAT
*%%STD%%=IF CLEAR THEN GOSUB c02 ELSE CLEAR = 1
IF CLEAR THEN GOSUB 2100 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(2) = TOP.LOC
VC = SAVE.VC
RETURN
*%%STD%%=c02: FOR LN = LN TO 20
2100  FOR LN = LN TO 20
PRINT @(56,LN):SPACE(2):
PRINT @(60,LN):SPACE(20):
NEXT LN
RETURN
!
*%%STD%%=ERROR: *
2200 * ERROR *
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT @(0,23):CLL:
RETURN
!
*%%STD%%=UPD.CALL: *
2300 * UPD.CALL *
* Set printer(s) as per screen...
CTR = 0
LOOP CTR = CTR+1 UNTIL CNT<1,CTR> = '' DO
LOCATE CNT<1,CTR> IN PREV.PRINTERS<1> SETTING LOC THEN NULL
IF CNT<1,CTR> # PREV.PRINTERS<1,LOC> OR CNT<5,CTR> # PREV.QUEUES<1,LOC> THEN
*EX.LINE = "SP-STARTLPTR ":CNT<1,CTR>:",":CNT<5,CTR>:",0,S":CNT<3,CTR>
LOCATE CNT<5,CTR> IN CNT<7> SETTING QUE.LOC ELSE QUE.LOC = 1
EX.LINE = "SP-DEVICE ":CNT<7,QUE.LOC>:" ":CNT<8,CTR>:" ":CNT<3,CTR>
STOPPED = 1
LOOP WHILE STOPPED = 1 DO
TCL.MSG = ''
*%%STD%%=EXECUTE EX.LINE, //OUT. > TCL.MSG
PERFORM EX.LINE CAPTURING TCL.MSG
MSG.NUM = FIELD(TCL.MSG<1>,"]",1); MSG.NUM = FIELD(MSG.NUM,"[",2)
BEGIN CASE
CASE MSG.NUM = "1116"; STOPPED = 0
CASE MSG.NUM = "1118"; STOPPED = 0
CASE MSG.NUM = "1105"; STOPPED = 1; TCL.MSG = "printer not stopped"
CASE 1; STOPPED = 1; TCL.MSG = "Error ":MSG.NUM
END CASE
IF STOPPED THEN
PRINT @(0,23):CLL:TCL.MSG:" - Enter KILL or <return> when OK ":
INPUT RSP:
IF RSP = "KILL" THEN CTR = 99; STOPPED = 0
END
REPEAT
END
REPEAT
RETURN
!
*%%STD%%=READ.CALL: *
2400 * READ.CALL *
* Retrieve actual statuses of the printers...
*%%STD%%=EXECUTE "SP-LISTLPTR", //OUT. > TCL.MSG
PERFORM "SP-LISTLPTR" CAPTURING TCL.MSG
CNT<3> = ''; CNT<4> = ''; CNT<5> = ''; CNT<8> = ''
*CTR = 6
CTR = 5
LOOP CTR = CTR+1 UNTIL TCL.MSG<CTR> = '' DO
MSG = TRIM(TCL.MSG<CTR>)
*MSG.PRINTER.NO = FIELD(MSG," ",2)
*MSG.QUEUE = FIELD(MSG," ",3)
*MSG.PORT = FIELD(MSG," ",5)
*MSG.STATUS = FIELD(MSG," ",6)
*
MSG.PRINTER.NO = CTR-5
MSG.QUEUE      = FIELD(MSG," ",1)
*MSG.FORM       = FIELD(MSG," ",2); * NOT USED *
MSG.PORT       = FIELD(MSG," ",2)
MSG.TYPE       = FIELD(MSG," ",3)
MSG.STATUS     = FIELD(MSG," ",4)
MSG.ENTRIES    = FIELD(MSG," ",5)
MSG.SKIP       = FIELD(MSG," ",6)
MSG.DESC       = MSG.QUEUE
*
LOCATE MSG.PRINTER.NO IN CNT<1> SETTING MSG.LOC ELSE
INS MSG.PRINTER.NO BEFORE CNT<1,MSG.LOC>
INS "<unknown>" BEFORE CNT<2,MSG.LOC>
INS '' BEFORE CNT<3,MSG.LOC>
INS '' BEFORE CNT<4,MSG.LOC>
INS '' BEFORE CNT<5,MSG.LOC>
INS '' BEFORE CNT<8,MSG.LOC>
END
LOCATE MSG.QUEUE IN CNT<7> SETTING QUE.LOC ELSE
INS MSG.QUEUE BEFORE CNT<7,QUE.LOC>
TEMP = 99-MSG.PRINTER.NO
IF MSG.QUEUE EQ "STANDARD" THEN TEMP = 0
INS TEMP      BEFORE CNT<6,QUE.LOC>
END
MSG.QUE.NUM = CNT<6,QUE.LOC>
CNT<3,MSG.LOC> = MSG.PORT
CNT<4,MSG.LOC> = MSG.STATUS
CNT<5,MSG.LOC> = MSG.QUE.NUM
CNT<8,MSG.LOC> = MSG.TYPE
REPEAT
PREV.PRINTERS = CNT<1>
PREV.QUEUES = CNT<5>
RETURN
!
END
~MDD.UNLOCK.ITEM~
SUBROUTINE MDD.UNLOCK.ITEM(FILE.NAME,ITEM.NAME,LCK.FILE)
* PROGRAM:           UNLOCK.ITEM
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       UNLOCK AN ITEM
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
! ATTEMPT TO READ THE LOCK ITEM
*
* ULT ONLY
READ LOCK.ITEM FROM LCK.FILE,FILE.NAME:"*":ITEM.NAME ELSE 
* ULT ONLY
MSG = "was missing!"
* ULT ONLY
GOSUB REPORT.ERROR
* ULT ONLY
RETURN
* ULT ONLY
END
*
! Check the port number
*
* ULT ONLY
IF LOCK.ITEM<ONE> NE PORT THEN 
* ULT ONLY
MSG = "was not locked by you!"
* ULT ONLY
RETURN
* ULT ONLY
END
*
! Remove the lock
*
* ULT ONLY
DELETE LCK.FILE,FILE.NAME:"*":ITEM.NAME
*
! Revelation version
*
* UNLOCK ITEM.FILE, ITEM.NAME; * REV ONLY
*
*
RETURN
*
!
*
REPORT.ERROR: *
*
PRINTER ON
PRINT STR("*",70)
PRINT
PRINT "The lock for file ":FILE.NAME:", item ":ITEM.NAME:" ":MSG
PRINT SPACE(10):"Account: ":ACCT "L#15":" Port: ":PORT
PRINT SPACE(10):"Date ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
PRINT
PRINT STR("*",70)
PRINTER OFF
*
RETURN
*
END
~MDD.UPDATE.LOCK~
SUBROUTINE MDD.UPDATE.LOCK
* PROGRAM:           UPDATE.LOCK
* VERSION: 901022 2.4  CHANGE.TO.GENERAL.CMMN.AREA
* AUTHOR:            DAVID STERN  -  AXION
* DESCRIPTION:       LOCK ITEM AND RECORD IN 'UPDATED' FIELD
*
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
** LCK.ITM = TRUE; LCK.TYPE = ZERO
TMP = INDEX(REF,"*",ONE)
FILE.NAME = REF[ONE,TMP - ONE]
ITEM.NAME = REF[TMP + ONE,9999]
*
IF ITEM.NAME NE EMPTY THEN
*
LOCATE REF IN UPDATED SETTING LOC THEN
IF DISP.ONLY THEN
PRINT CLB:BELL:"Changes will not be allowed. Inquiries only.":
END
END ELSE
*
UPDATED<LOC> = REF
*
LOOP
*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(NUM.FILE,FILE.NAME,ITEM.NAME,LCK.FILE,LCK.STAT)
END ELSE LCK.STAT = TRUE
*
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN
IF NOT(STAT) THEN STAT = LCK.STAT
*
END ELSE IF LCK.STAT THEN
PRINT CLB:BELL:"Changes will not be allowed. Inquiries only.":
IF NOT(DISP.ONLY) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE
PRINT BELL:
END
DISP.ONLY = TRUE; LCK.STAT = FALSE
*
END; * of lock stat
*
WHILE NOT(STAT) AND LCK.STAT DO REPEAT
*
IF STAT GT ZERO THEN STAT = 999
*
END; * Of ref not found and disp only
*
END; * of item not empty
*
REF = EMPTY
*
RETURN
*
*
END
~MENU.DOCUMENTER~
*PROGRAM: MENU.DOCUMENTER 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       FORMAT AND PRINT ALL MENUS CALLED FROM A SPECIFIC MENU
* DATE WRITTEN:      02 APR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "MENUS" TO MU.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
*
DIM MENU(100),LINES(24)
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = ""
CO.NAME = CO.NAME<1,1,1>
ASTERS = "* * * * * * * * * * * * * * * * "; ASTERS = ASTERS:ASTERS:ASTERS:ASTERS:"*  *"
STK = ""; * STK IS STACK OF MENUS
INPUT MENU.NAME
PRINT
PRINT
PRINT "            menu documenter in progress ...."
IF MENU.NAME = "" THEN MENU.NAME = "/"
IF MENU.NAME[1,1] # "/" THEN MENU.NAME = "/":MENU.NAME
READ DEFAULTS FROM MU.FILE, "DEFAULTS" ELSE DEFAULTS = ""
MNUS = MENU.NAME
AC = 3
NXT: *
MATREAD MENU FROM MU.FILE, MENU.NAME ELSE GOTO NEXT.MENU
LOOP MENU.LINE = MENU(AC) UNTIL MENU.LINE = "" OR AC = 100 DO
IF MENU.LINE[1,1] # "*" THEN
PGM = MENU.LINE<1,2,1>
IF PGM[1,1] = "/" THEN
STK = MENU.NAME:SVM:AC+1:VM:STK
MNUS = MNUS:VM:PGM
MENU.NAME = PGM
AC = 3
GOTO NXT
END
END
AC = AC+1
REPEAT
IF STK # "" THEN
MENU.NAME = STK<1,1,1>
AC = STK<1,1,2>
DEL STK<1,1>
GOTO NXT
END
!
NEXT.MENU: *
MENU.NAME = MNUS<1,1>
IF MENU.NAME = "" THEN STOP
DEL MNUS<1,1>
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE GOTO NEXT.MENU
*
MAT LINES = ""
LINES(1) = ("Acct: ":ACCT) "L#20":(SPACE(44-LEN(CO.NAME)/2+.5):CO.NAME) "L#88":OCONV(DATE(),"D2") "R#20"
LINES(2) = ("Port: ":PORT) "L#15":(SPACE(49-LEN(MENU(1))/2+.5):MENU(1)) "L#98":OCONV(TIME(),"MTS") "R#15"
LINES(24) = SPACE(44):"Enter your choice:"
*
AC = 3; CL = 22; LN = 4
LOOP MENU.LINE = MENU(AC) UNTIL MENU.LINE = "" OR AC = 100 DO
IF MENU.LINE[1,1] = ">" THEN CL = 2
AC = AC+1
REPEAT
MAX.AC = AC-1
*
NUM = 1
FOR AC = 3 TO MAX.AC
MENU.LINE = MENU(AC)
VALID = 1; VALID.ACCTS = MENU.LINE<1,4>
IF VALID.ACCTS # "" THEN LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN
TEXT = MENU.LINE<1,1>
IF TEXT = ">" THEN CL = 66; LN = 4 ELSE
IF TEXT[1,1] # "*" THEN
PRMPT = MENU.LINE<1,3>
IF PRMPT = "" THEN PRMPT = NUM
IF TEXT # "" THEN
PROCNM = MENU.LINE<1,2,1>
IF PROCNM[1,1] = "/" THEN PROCNM = "menu ":PROCNM
TEXT = PROCNM "L#22":TEXT
IF LEN(LINES(LN)) < CL THEN LINES(LN) = LINES(LN):STR(" ",CL-LEN(LINES(LN)))
LINES(LN) = LINES(LN)[1,CL]:PRMPT "R#3":". ":TEXT:LINES(LN)[CL+LEN(TEXT)+6]
END
NUM = NUM+1
END ELSE IF TEXT # "*" THEN
IF LEN(LINES(LN)) < CL THEN LINES(LN) = LINES(LN):STR(" ",CL-LEN(LINES(LN)))
LINES(LN) = LINES(LN)[1,CL-2]:TEXT:LINES(LN)[CL+LEN(TEXT)-1]
END
END
LN = LN+1
END
NEXT AC
PRINTER ON
PRINT FF:"MENU: ":MENU.NAME "L#20":TIMEDATE():CR:LF:CR:LF:ASTERS:CR:LF:"* ":SPACE(128):" *"
FOR LN = 1 TO 24; PRINT "* ":LINES(LN) "L#128":" *"; NEXT LN
PRINT "* ":SPACE(128):" *":CR:LF:ASTERS
*
PRINTER OFF
*
GOTO NEXT.MENU
*
*
END
~MENU.HANDLER~
*PROGRAM:           MENU.HANDLER
* VERSION: 960403 5.0  ADDED execute OF ATR 13 OF PRINTER.Q0. (sp-assign = XXX)
*
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                    DAVID STERN - AXION
*
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
* ALL
* SYMNGR SYMNTC SYS
* SWMNGR SEC DEV TCL
* SWINST PARAM PURGE MENUS
*
* MNGR BRMNGR OFMNGR ACCT CRDT ADJ CASH
* SLMNGR MKRTG SALES
* PLMNGR DSPTCH INV SCHED WKO
* DELETE ENTRY INQRY
*
* EFT AI LATE WKO INV
*
EQU VS TO "9205"
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP MENUS.VM.VAR.EQUATES
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
SYS.APPL.LOC = ONE
VERSION = VS; AUTO.RUN = FALSE; REDISP = FALSE
STAT = FALSE; STAT.LN = 23; DISP.ONLY = FALSE
CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
EXEC.VERB = EMPTY; EXEC.DESC = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
CALL.ID = EMPTY; PORT.KEY = EMPTY; CLEAR.FLAG = FALSE
SEC.USER.ID = EMPTY; MENU.NAME = EMPTY; LAST.MENU = EMPTY
REOPEN.SW = FALSE; CR.FLAG = FALSE; RESET.SW = FALSE
NUM = ZERO; CNT.FILE.OPEN = FALSE; NUMC = FALSE; TC.FILL = " "
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = ONE
OLD.CL = EMPTY; OLD.LN = EMPTY; OLD.CL.LOC = ONE; OLD.LN.LOC = ONE
*
*: * Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*CNT.TST = EMPTY
*$INCLUDE IBP CNT.TST.VAR.EQUATES
*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
BREAK OFF
*
CALL COPYRIGHT
*
!!
*
! Perform initialization
*
* IF @USER0 EQ EMPTY THEN PERFORM "RUN BP.OBJ INITIALIZATION"; * REV ONLY
*
NEXT.SYSTEM: *
*
! Open files
*
OPEN "MENUS" TO MU.FILE ELSE PRINT CLB:"MENUS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
*
OPEN "COM" TO COM.FILE THEN COM.FILE.OPEN = TRUE ELSE
PRINT CLB:"COM file is missing!":BELL:; RQM; RQM; RQM
COM.FILE.OPEN = FALSE
END
*
OPEN "CNT" TO CNT.FILE THEN CNT.FILE.OPEN = TRUE ELSE
PRINT CLB:"CNT file is missing!":BELL:; RQM; RQM; RQM
CNT.FILE.OPEN = FALSE
END
*
OPEN "PAR" TO PAR.FILE ELSE
OPEN "LISTS" TO PAR.FILE ELSE PRINT CLB:"LISTS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
*
OPEN "LOCKS" TO LCK.FILE ELSE
PRINT CLB:"LOCKS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
* LCK.FILE = 0; * REV ONLY
LCK.ITM = FALSE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
! Set ACC file settings
*
ACC.CNT = 111
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
! Set port control key
*
SEC.USER.ID = EMPTY; MENU.NAME = EMPTY
RESET.SW = FALSE; LAST.MENU = EMPTY
$INCLUDE IBP SYS.INCL.LOAD.PORT.KEY
*
! Initialize tables
*
IF OPSYS = "R" THEN PTR.TYPE = "REG" ELSE PTR.TYPE = "Q0"
READ PTR.CNTL FROM PAR.FILE,"PRINTER.":PTR.TYPE ELSE PTR.CNTL = ""
PTR.ON = ""; COM.FONT = ""
LOOP UNTIL PTR.CNTL<2> = "" DO PTR.ON = PTR.ON:CHAR(PTR.CNTL<2,1>); DEL PTR.CNTL<2,1> REPEAT
LOOP UNTIL PTR.CNTL<5> = "" DO COM.FONT = COM.FONT:CHAR(PTR.CNTL<5,1>); DEL PTR.CNTL<5,1> REPEAT
*
IF PTR.CNTL<13>[1,3] = "SP-" THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
PRINT CLB:RVB:PTR.CNTL<13>:RVE:@(ZERO,3):
* ULT ONLY
END
EXECUTE PTR.CNTL<13>
*
CALL PRINTER.ON(STAT)
IF NOT(STAT) THEN
PRINT PTR.ON:COM.FONT:
PRINTER OFF
END
*
END; * of <13> not empty
*
!
*
MAT PAR.MENU = EMPTY; MAT SEC.USER = EMPTY
DIM MENU(70),ROUTE(70),DOC(70),PRMPT(70),MDESC(70)
$INCLUDE IBP STD.DIM
MAT STD = EMPTY
STD.FUNC = "READ"; STD.CONT = FALSE; STD.SUBR.NAME = EMPTY
*
! Read default menu and generic terminal type flag
*
READV DF.MENU.NAME FROM MU.FILE,"FIRST.MENU",ONE ELSE
DF.MENU.NAME = "/"
END
*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE 
IF OPSYS EQ "M" OR OPSYS EQ "U" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
*
! Load port control record
*
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID THEN
*
* SEC.USER.ID = PAR.MENU$USER
MENU.NAME = PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = PAR.MENU$LOCN<ONE,ONE>
OLD.CL.LOC = SCR.LOCN<ONE,ONE,ONE>
OLD.CL     = SCR.LOCN<ONE,ONE,TWO>
OLD.LN     = SCR.LOCN<ONE,ONE,3>
*
* Was this port ever active?
IF PAR.MENU$MENU.ID NE EMPTY THEN
*
* Pop last run off of menu stack
LOOP
DEL PAR.MENU$MENU.ID<ONE,ONE>
DEL PAR.MENU$LOCN<ONE,ONE>
WHILE LEN(PAR.MENU$MENU.ID) AND PAR.MENU$MENU.ID<ONE,ONE> EQ MENU.NAME DO SCR.LOCN = PAR.MENU$LOCN<ONE,ONE> REPEAT
*
* Delete stack item where duplicate exist
* back to duplicate
LOOP
LOCATE MENU.NAME IN PAR.MENU$MENU.ID<ONE> SETTING TMP ELSE TMP = FALSE
WHILE LEN(PAR.MENU$MENU.ID) AND TMP DO
TMP = DCOUNT(PAR.MENU$MENU.ID,VM)
DEL PAR.MENU$MENU.ID<ONE,TMP>
DEL PAR.MENU$LOCN<ONE,TMP>
REPEAT
*
* now put curr back on front
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
*
END; * of active port
*
* Set menu to be displayed
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = "Logon / Initialization"
* * Clear user data for this port
* PAR.MENU$GROUP = EMPTY
* PAR.MENU$USER = EMPTY
* PAR.MENU$USER.DT = EMPTY; PAR.MENU$USER.TM = EMPTY
*
END ELSE
*
! Port control record missing
*
MAT PAR.MENU = EMPTY
PAR.MENU$PORT.KEY = PORT.KEY
MENU.NAME = DF.MENU.NAME
PAR.MENU$MENU.ID = MENU.NAME
SCR.LOCN = ONE:SVM:ZERO:SVM:ZERO
PAR.MENU$LOCN = SCR.LOCN
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = "Logon / Initialization"
*
END; * of load port control
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Load operating system file, field, and attribute
*
IF ACC.ID EQ EMPTY THEN
*
ACC.ID = PAR.MENU$PORT.KEY
*
** ACC.FILE.NAME = FIELD(ACC.ID,"@",TWO)
** **IF ACC.ID NE EMPTY THEN
** **ACC.AM.DESC = FIELD(ACC.ID,"@",3) 
** **ACC.AM.VERB = FIELD(ACC.ID,"@",6)
** **ACC.AM.DT   = FIELD(ACC.ID,"@",4)
** **ACC.AM.TM   = FIELD(ACC.ID,"@",5)
** ACC.ID = FIELD(ACC.ID,"@",ONE) 
** **END
** IF ACC.FILE.NAME EQ EMPTY THEN ACC.FILE.NAME = "ACC"
** IF ACC.ID EQ EMPTY THEN ACC.ID = CALL.ID 
** *
** TMP = FIELD(ACC.FILE.NAME," ",TWO)
** IF LEN(TMP) THEN
** ACC.FILE.NAME = TMP
** ACC.FILE.DICT = FIELD(ACC.FILE.NAME," ",ONE)
** END ELSE ACC.FILE.DICT = EMPTY
*
END ELSE
PAR.MENU$PORT.KEY = ACC.ID:"@":ACC.FILE.NAME:"@":ACC.AM.DESC:"@":ACC.AM.DT:"@":ACC.AM.TM:"@":ACC.AM.VERB
END
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:ACC.FILE.DICT:" ":ACC.FILE.NAME:" file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
*
! Set first response to current Menu attr 1
*
READV RSP FROM MU.FILE,MENU.NAME,ONE ELSE MENU.NAME = DF.MENU.NAME; SCR.LOCN = ONE:SVM:TWO:SVM:TWO
*
! Load company data
*
CO.DATA = "System not on disk":AM:DATE():AM:(15*60*60)
IF CNT.FILE.OPEN THEN
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CNT.FILE.OPEN = FALSE
END
CO.NAME = CO.DATA<ONE,ONE,ONE>; CO.DATE = CO.DATA<TWO,ONE,ONE>
DT = DATE(); TM = TIME()
IF PAR.MENU$USER EQ EMPTY THEN SEC.USER.ID = EMPTY
*
! Maintain special copyright info
*
IF SEC.USER.ID EQ EMPTY OR CO.DATA<4> OR (CO.DATE NE DT AND NOT(CO.DATE + ONE EQ DT AND TM LT 10000)) THEN
EXEC.DESC = (SEC.USER.ID:" ":"Operator ID") ACC.DESC.FMT
$INCLUDE IBP SYS.INCL.LOAD.ACC
*CHECK ACC VALUES
ACC.DESC = EXEC.DESC
ACC.VERB = EXEC.VERB
ACC.DT   = DT
ACC.TM   = TM
$INCLUDE IBP SYS.INCL.UPDT.ACC
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
IF STAT THEN CHAIN "ZZOFF"
IF NOT(STAT) THEN
IF PAR.MENU$BF THEN BREAK ON
END
*
END
*
* MSG
*
PRINT @(ZERO,3):
EXEC.VERB = "SYS.MSG.SEND"
EXEC.IN = "-2":AM:SEC.USER.ID
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
*
! Load control information
*
* System Test Flag
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
* User data
STD.FUNC = "READ"
GOSUB LOAD.STD.DATA
*
* Cursor keys
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":OPSYS ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE CURSOR.KEYS = EMPTY
END
*
* Function keys
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = STAT.LN; FUNC.CL = 0
IF CURSOR.KEYS<4> EQ EMPTY THEN
CURSOR.KEYS<4>  = "What?":VM:"How?":VM:"tcl":VM:"off":VM:"spool":VM:"compress":VM:"large":VM:"system"
CURSOR.KEYS<5> = "?":VM:"??":VM:"TCL":VM:"OFF":VM:"SPO":VM:"COM":VM:"REG":VM:"ACT"
END
FUNC.VC.MAX = DCOUNT(CURSOR.KEYS<4>,VM)
*
!!
*
! Display the next menu
*
NEXT.MENU: *
*
*
CO.NAME = CO.DATA<ONE,ONE,ONE>; CO.DATE = CO.DATA<TWO,ONE,ONE>
DT = DATE(); TM = TIME()
*
* Check control date to maintain it; * : *
* (OK if before 03:00 the next mourning)
IF CO.DATE NE DT AND NOT(DT EQ CO.DATE + ONE AND TM LT 10000) THEN
IF NOT(CO.DATA<4>) THEN
PAR.MENU$USER = EMPTY; * clear user on date change
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
EXEC.DESC = (SEC.USER.ID:" ":"Control Date") ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
GOTO NEXT.SYSTEM
END ELSE
PRINT CLB:"CONTROL DATE OVERRIDE IS SET!":BELL:
RQM
END
END
*
!
*
LOOP
*
HELP = ZERO
*
* Check control date reset on user; * : *
IF ((DATE() - PAR.MENU$USER.DT) * 86400) + (TIME() - PAR.MENU$USER.TM) GT 14400 THEN
PAR.MENU$USER = EMPTY
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
GOTO NEXT.SYSTEM
END
*
* Load menu record if it has changed.; * : *
IF MENU.NAME NE LAST.MENU THEN
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE
IF MENU.NAME EQ DF.MENU.NAME THEN
PRINT CLB:"MENUS ":DF.MENU.NAME:" item missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END ELSE
MENU.NAME = DF.MENU.NAME
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE PRINT CLB:"MENUS ":MENU.NAME:" item missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
END
CL.START = 22; CL.INC = 40; CL.NUM = ONE
* Clear menu tables
MAT ROUTE = EMPTY; MAT PRMPT = EMPTY; MAT MDESC = EMPTY
POS.LOC = EMPTY
POS.REF = EMPTY
POS.LN = EMPTY
END
*
* Write location to system accounting file; * : *
EXEC.DESC = (SEC.USER.ID:" ":MENU(1)) ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = MENU(1)
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Display Menu; * : *
*
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
PRINT @(ZERO,ZERO):CLS:RVB:(OCONV(CO.DATE,"D2"):" ":OCONV(TIME(),"MTS")[1,5]) "L#15":(SPACE(25 - (LEN(CO.NAME) + ONE) / TWO):CO.NAME) "L#50":("Oper ":SEC.USER.ID:SPACE(LEN(SEC.USER$DESC) - LEN(SEC.USER.ID))) "R#15":RVE:
* ULT ONLY
END
* ULT ONLY
IF SYSTEM(11) LT 3 THEN
PRINT @(ZERO,ONE):CLS:RVB:(WHO:"\":MENU.NAME) "L#20":(SPACE(20 - (LEN(MENU(ONE)) + ONE) / TWO):MENU(ONE)) "L#40":("Name ":SEC.USER$DESC) "R#20":RVE:
* ULT ONLY
END
*
! Determine number of columns and width; * : *
*
IF MENU.NAME NE LAST.MENU THEN
AM.CN = TWO; CL = CL.START; CL.NUM = ONE
LOOP LINE = MENU(AM.CN) UNTIL LINE EQ EMPTY OR AM.CN EQ 100 DO
AM.CN = AM.CN + ONE
IF LINE<ONE,MENUS.VM$DESC> EQ ">" THEN
IF CL EQ TWO THEN
CL.INC = 30
END ELSE
CL.START = TWO; CL = CL.START
END
CL.NUM = CL.NUM + ONE
END
REPEAT
MAX.AM.CN = AM.CN - ONE
END
*
NUM = ONE; CL = CL.START; LN = 3; CL.NUM = ONE
*
! Load menu tables; * : *
*
FOR AM.CN = TWO TO MAX.AM.CN
*
LINE = MENU(AM.CN)
*
! Validate operating system, user and group info; * : *
*
! Check operating system; * : *
*
IF LINE<ONE,MENUS.VM$OPSYS> EQ EMPTY OR INDEX(LINE<ONE,MENUS.VM$OPSYS>,OPSYS,ONE) THEN
*
IF LINE<ONE,MENUS.VM$USER> EQ EMPTY AND LINE<ONE,MENUS.VM$GROUP> EQ EMPTY THEN CONT = TRUE ELSE
*
!  Group; * : *
*
CN.MAX = DCOUNT(PAR.MENU$GROUP,SVM)
IF CN.MAX THEN
CN = ZERO; CONT = FALSE
LOOP CN = CN + ONE WHILE CN LE CN.MAX AND NOT(CONT) DO
LOCATE PAR.MENU$GROUP<ONE,ONE,CN> IN LINE<ONE,MENUS.VM$GROUP> SETTING TMP THEN CONT = TRUE ELSE NULL
IF PAR.MENU$GROUP<ONE,ONE,CN> EQ "ALL" THEN CONT = TWO
REPEAT
END ELSE CONT = TRUE
*
! User; * : *
*
IF LINE<ONE,MENUS.VM$USER> NE EMPTY THEN
LOCATE PAR.MENU$USER IN LINE<ONE,MENUS.VM$USER> SETTING TMP THEN NULL ELSE
IF CONT NE TWO THEN CONT = FALSE
END
END
*
END; * Of group or user not empty
*
END ELSE CONT = FALSE
*
! Menu line is valid; * : *
*
IF CONT THEN
*
TEXT = LINE<ONE,MENUS.VM$DESC>
*
* Is line a column seperator
IF TEXT EQ ">" THEN
CL = CL + CL.INC; LN = TWO; CL.NUM = CL.NUM + ONE; PRINT @(CL,LN):
END ELSE
*
* Check if line is comment or menu parameter
IF TEXT[ONE,ONE] NE "*" THEN
*
IF MENU.NAME NE LAST.MENU THEN
*
PRMPT(NUM) = LINE<ONE,MENUS.VM$LABEL>; IF PRMPT(NUM) EQ EMPTY THEN PRMPT(NUM) = NUM
*
LOCATE CL IN POS.LOC<LN + ONE> BY "AR" SETTING CL.LOC ELSE
INS "" BEFORE POS.LOC<LN + ONE,CL.LOC>
INS "" BEFORE POS.REF<LN + ONE,CL.LOC>
END
*
POS.LOC<LN + ONE,CL.LOC> = CL
POS.REF<LN + ONE,CL.LOC> = PRMPT(NUM):"|0|0"
POS.LN<NUM> = LN
*
IF MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE> AND NUM EQ ONE THEN
OLD.CL.LOC = CL.NUM; OLD.CL = CL; OLD.LN = LN
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
END
*
ROUTE(NUM) = LINE<ONE,MENUS.VM$VERB>
DOC(NUM) = LINE<ONE,MENUS.VM$HELP>
MDESC(NUM) = LINE<ONE,MENUS.VM$DESC>
*
END
*
IF PAR.MENU$MENU.ID EQ EMPTY AND NUM EQ ONE THEN
OLD.CL.LOC = CL.NUM; OLD.CL = CL; OLD.LN = LN
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
PAR.MENU$MENU.ID = MENU.NAME
PAR.MENU$LOCN = SCR.LOCN
END
*
* don't display lines if user is entering information
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
IF TEXT NE EMPTY THEN PRINT @(CL,LN):RVB:PRMPT(NUM) "R#3":RVE:" ":TEXT
* ULT ONLY
END
*
NUM = NUM + ONE
*
END ELSE
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
 IF TEXT NE "*" THEN PRINT @(CL - TWO,LN):TEXT[TWO,99]
* ULT ONLY
END
END
*
END; * Of column seperator
*
LN = LN + ONE
*
END; * of valid for this OPerating SYStem
*
NEXT AM.CN
*
IF MENU.NAME NE LAST.MENU THEN
LAST.MENU = MENU.NAME
END
CL = OLD.CL; CL.LOC = OLD.CL.LOC; LN = OLD.LN
*
!! Response; * : *
*
! Accept response from user; * : *
*
LOOP
*
OLD.CL.LOC = SCR.LOCN<ONE,ONE,ONE>
OLD.CL     = SCR.LOCN<ONE,ONE,TWO>
OLD.LN     = SCR.LOCN<ONE,ONE,3>
* CL = OLD.CL; CL.LOC = OLD.CL.LOC; LN = OLD.LN
*
* If no cursor keys defined or generic
*
PRINT @(20,22):"Enter your choice: ":
* * ULT ONLY
* INPUTCLEAR
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
*
* Input using cursor keys
*
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
PRINT CLB:; *PRINT @(ZERO,TWO):CLL:
* ULT ONLY
END
DEF.SUPP = FALSE
VC = ONE
*
* Display function keys; * : *
**IF NOT(GENERIC) THEN
**LOOP UNTIL CURSOR.KEYS<4,VC> EQ EMPTY OR VC GT 8 DO
*** ULT ONLY
**IF NOT(SYSTEM(11)) THEN
**PRINT RVB:("F":VC):RVE:" ":CURSOR.KEYS<4,VC>:"  ":
*** ULT ONLY
**END
**VC = VC + ONE
**REPEAT
**END
*
$INCLUDE IBP SYS.INCL.FKEY.DISP
*
! Standard character input; * : *
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
LH = "L25"; LHM = 135
MS = EMPTY; NO.PROMPT = FALSE; FIXED = FALSE
RSP.LN = 22; RSP.CL = 40
*
$INCLUDE IBP CURSOR.STD
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
*$INCLUDE IBP CURSOR.POS
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
END
*
! Help?; * : *
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO
DEF.SUPP = INDEX("2846",TC.FUNC,ONE)
REPEAT
*
! Process response; * : *
*
PRINT @(ZERO,23):CLL:@(ZERO,22):CLL:@(20,22):"Enter your choice: ":RVB:RSP:RVE:
*
* END; * OF CURSOR KEYS NE EMPTY
*
!!
*
! Process command; * : *
*
EXEC.VERB = EMPTY; EXEC.DESC = EMPTY; CR.FLAG = FALSE
*
BEGIN CASE
*
! TCL dot command; * : *
*
CASE RSP[ONE,ONE] EQ "."
PAR.MENU$DESC = "Menu: ":MENU.NAME:" ":RSP
EXEC.VERB = RSP; EXEC.DESC = (SEC.USER.ID:" ":MENU(1)) ACC.DESC.FMT:RSP ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
PRINT @(ZERO,3):CLS:RSP[TWO,9999]
EXEC.VERB = RSP
CR.FLAG = TRUE
*
! Pop - Request for previous menu; * : *
CASE RSP EQ EMPTY OR RSP[ONE,3] EQ "POP"
IF RSP[ONE,3] EQ "POP" THEN
EXEC.DESC = (SEC.USER.ID:" ":"PoP") ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
* CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
EXEC.VERB = EMPTY
END
*
LOOP
EXEC.VERB = PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = PAR.MENU$LOCN<ONE,ONE>
IF EXEC.VERB EQ EMPTY THEN EXEC.VERB = DF.MENU.NAME
POP.CONT = FALSE
IF LEN(PAR.MENU$MENU.ID) AND EXEC.VERB EQ MENU.NAME THEN POP.CONT = TRUE
* IF PAR.MENU$?<ONE,ONE> EQ EMPTY THEN POP.CONT = TRUE
WHILE POP.CONT DO
IF MENU.NAME EQ PAR.MENU$MENU.ID<ONE,ONE> THEN
DEL PAR.MENU$MENU.ID<ONE,ONE>
DEL PAR.MENU$LOCN<ONE,ONE>
END
REPEAT
PAR.MENU$DESC = "previous menu"
EXEC.DESC = PAR.MENU$DESC
*
* CASE RSP EQ CHAR(1)
* IF GENERIC THEN GENERIC = FALSE ELSE GENERIC = TRUE
* EXEC.VERB = MENU.NAME
*
* Redisplay; * : *
CASE RSP EQ "RE"
EXEC.VERB = MENU.NAME
*
* Push; * : *
CASE RSP[ONE,4] EQ "PUSH"
EXEC.DESC = (SEC.USER.ID:" ":"Function") ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
EXEC.VERB = RSP[4,9999]
IF EXEC.VERB[ONE,ONE] EQ " " THEN EXEC.VERB = EXEC.VERB[TWO,9999]
* PAR$MENU? = (DATE*100000) + TIME()) "R#10":EXEC.VERB
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
* Date; * : *
CASE RSP EQ "DATE"
EXEC.DESC = (SEC.USER.ID:" ":"Control Date") ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
EXEC.VERB = MENU.NAME
*
* Test Flag; * : *
CASE RSP[ONE,3] EQ "TST"
CNT.TST$MAINT = TRUE
EXEC.DESC = (SEC.USER.ID:" ":"System Test Maint") ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
TYPE.RUN = FIELD(RSP," ",TWO)
IF TYPE.RUN EQ EMPTY THEN TYPE.RUN = "9"
IF NOT(NUM(TYPE.RUN)) THEN
CNT.TST.ID = TYPE.RUN; CNT.TST.ID.SAVE = CNT.TST.ID
TYPE.RUN = 5
END
CNT.TST$MAINT = TRUE
GOSUB LOAD.TST; * : *
EXEC.VERB = MENU.NAME
*
! Other command; * : *
CASE TRUE
*
IF RSP[ONE,ONE] EQ "?" THEN
SUB = EMPTY; RSP = TRIM(RSP[TWO,99]); IF RSP[ONE,ONE] EQ "?" THEN RSP = RSP[TWO,99]; HELP = TWO ELSE HELP = ONE
EXEC.VERB = STR("?",HELP); DOC.NAME = RSP
EXEC.DESC = EXEC.VERB:" ":DOC.NAME
*IF RSP EQ EMPTY THEN RSP = MENU.NAME
IF DOC.NAME EQ EMPTY THEN DOC.NAME = MENU.NAME
END ELSE SUB = FIELD(RSP,"/",TWO); RSP = FIELD(RSP,"/",ONE); HELP = ZERO
*
IF SUB NE EMPTY THEN
READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
IF EXEC.VERB NE EMPTY THEN READ DEFAULTS FROM MU.FILE,"/":RSP THEN RSP = SUB; GOSUB CHECK.DEFAULTS
END ELSE
*
! Cycle thru menu to find response; * : *
FOR NUM = ONE TO 70 UNTIL PRMPT(NUM) EQ RSP OR PRMPT(NUM) EQ EMPTY; NEXT NUM
*
IF PRMPT(NUM) NE EMPTY THEN
EXEC.VERB = ROUTE(NUM); EXEC.DESC = (SEC.USER.ID:" ":MENU(1)) ACC.DESC.FMT:MDESC(NUM) ACC.DESC.FMT
DOC.NAME = DOC(NUM)
IF DOC.NAME EQ EMPTY THEN DOC.NAME = STR("?",HELP):EXEC.VERB
* SCR.LOCN = NUM
LN = POS.LN<NUM>
TMP = PRMPT(NUM):"|0|0"
LOCATE TMP IN POS.REF<LN + ONE> SETTING CL.LOC ELSE NULL
CL = POS.LOC<LN + ONE,CL.LOC>
PRINT @(CL,LN):
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
END ELSE IF EXEC.VERB[ONE,ONE] NE "?" AND EXEC.VERB[ONE,ONE] NE "/" THEN
READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
END
*
END; * of empty SUB
*
IF HELP OR EXEC.VERB[ONE,ONE] EQ "?" THEN
*
IF NOT(HELP) THEN
IF EXEC.VERB[TWO,ONE] EQ "?" THEN HELP = TWO ELSE HELP = ONE
END
*
IF HELP AND EXEC.VERB NE EMPTY THEN GOSUB HELP.MESSAGE; EXEC.VERB = MENU.NAME
*
END; * OF "?"
*
END CASE
*
WHILE EXEC.VERB = EMPTY DO PRINT BELL: REPEAT
*
!
*
IF MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE> AND RSP NE EMPTY THEN
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
END ELSE
PAR.MENU$LOCN<ONE,ONE> = SCR.LOCN
END
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
WHILE EXEC.VERB[ONE,ONE] EQ "/" DO
*
MENU.NAME = EXEC.VERB
*
REPEAT
*
!!
*
CLS.COL = 0; CLS.ROW = 3; GOSUB CLS.ROUTINE
*INCLUDE IBP SYS.INCL.EXEC.STD.FUNC
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
!
*
UNLOCK: *
*
REOPEN.SW = EMPTY
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF CNT.FILE.OPEN THEN
READ RAMDISK.CNT FROM CNT.FILE,"RAMDISK.FILES" THEN
LOCATE ONE IN RAMDISK.CNT<TWO> SETTING LOC THEN
OPEN "LISTS" TO LISTS.FILE THEN
READ RAMDISK.REC FROM LISTS.FILE,"RAMDISK.FILES" THEN
EXEC.DESC = (SEC.USER.ID:" ":"Download Ram Disk") ACC.DESC.FMT
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL DOWNLOAD.RAMDISK(CNT.FILE,RAMDISK.CNT,LISTS.FILE,RAMDISK.REC)
REOPEN.SW = ONE
END
END
END
END
END
*
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF REOPEN.SW THEN GOTO NEXT.SYSTEM
*
IF RESET.SW THEN GOTO NEXT.SYSTEM
*
IF NOT(CNT.FILE.OPEN) THEN GOTO NEXT.MENU
*
GOTO NEXT.MENU
*
!
*
STOP
*
!
*
CHECK.DEFAULTS: *
*
LCK.STAT = FALSE
LOCATE "TCL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "MENUS" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "DEV" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "ALL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE LCK.STAT = TRUE
END
END
END
*
IF LCK.STAT THEN EXEC.VERB = MENU.NAME ELSE
*
AM.CN = TWO
LOOP DEFAULT = DEFAULTS<AM.CN> UNTIL DEFAULT<ONE,MENUS.VM$LABEL> EQ RSP OR DEFAULT EQ EMPTY DO AM.CN = AM.CN + ONE REPEAT
IF DEFAULT EQ EMPTY THEN
* EXEC.VERB = "/":RSP
* READV TMP FROM MU.FILE,EXEC.VERB,ONE ELSE EXEC.VERB = MENU.NAME
TMP1 = "/":RSP
READV TMP FROM MU.FILE,TMP1,ONE THEN EXEC.VERB = TMP1 ELSE NULL
END ELSE
EXEC.VERB = DEFAULT<ONE,MENUS.VM$VERB>; DOC.NAME = DEFAULT<ONE,MENUS.VM$HELP>; IF DOC.NAME EQ EMPTY THEN DOC.NAME = EXEC.VERB
END
*
END
*
RETURN
*
! Load STD DATA
*
LOAD.STD.DATA: *
*
*INCLUDE IBP SYS.INCL.LOAD.STD.DATA
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
! Standard System Call
*
ENTER.STD.SUBR: *
*
*INCLUDE IBP SYS.INCL.ENTER.STD.SUBR
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
! Allow authorized entry into debug mode
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!!
*
! Help Features
*
HELP.MESSAGE: *
*
CLS.COL = ZERO; CLS.ROW = TWO; GOSUB CLS.ROUTINE
*
IF NOT(GENERIC) AND (EXEC.VERB EQ "?" OR DOC.NAME EQ "?") THEN
HELP.VERB = 'COPY PAR MASK (T,S)'
PRINT @(ZERO,3):CLL:"Help Mask":
EXECUTE HELP.VERB
END
PRINT @(ZERO,22):CLL:"You are about to view ":DOC.NAME:"... ":
HELP.FIRST = TRUE
*
LOOP
*
PRINT CLB:"Enter a help selection or <cr> to continue: ":; INPUT HELP.RSP:
IF HELP.RSP EQ "KILL" THEN RETURN
HELP.CMD = FIELD(HELP.RSP," ",ONE)
HELP.RSP = HELP.RSP[COL2()+ONE,9999]
IF HELP.RSP NE EMPTY THEN DOC.NAME = HELP.RSP; HELP.FIRST = TRUE
*
HELP.VERB = "RUNOFF"
IF INDEX("*ED*EDIT*Q*","*":HELP.CMD:"*",ONE) THEN
HELP.VERB = "ED"
END ELSE IF INDEX("*WP*SH*SCR*CH*","*":HELP.CMD:"*",ONE) THEN
HELP.VERB = "SH.MAINT.ITM"
END ELSE
HELP.CMD = EMPTY
END
*
WHILE HELP.FIRST OR HELP.CMD NE EMPTY DO
*
CLS.COL = ZERO; CLS.ROW = ZERO; GOSUB CLS.ROUTINE
HELP.FIRST = FALSE
TMP.RSP = DOC.NAME
HELP = ZERO
LOOP WHILE TMP.RSP[ONE,ONE] EQ "?" DO TMP.RSP = TMP.RSP[TWO,999]; HELP = HELP + ONE REPEAT
*
DOC.NAME.F = FIELD(DOC.NAME," ",ONE)
*
IF DOC.NAME.F NE EMPTY THEN
*
DOC.NAME.I = FIELD(DOC.NAME," ",TWO)
IF DOC.NAME.I EQ EMPTY THEN DOC.NAME.I = DOC.NAME.F; DOC.NAME.F = "CABLE"
IF HELP EQ TWO THEN DOC.NAME.I = "?":DOC.NAME.I
*
IF DOC.NAME.I NE EMPTY THEN
*
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
HELP.FILE = 'HLP,':DOC.NAME.F
HELP.ITEM = DOC.NAME.I
HELP.TEXT = ' ':HELP.FILE:' ':HELP.ITEM
CASE OPSYS EQ "R"
* HELP.FILE = ' HLP ':DOC.NAME.F
* HELP.ITEM = DOC.NAME.I; * REV ONLY
* HELP.TEXT = ' ':HELP.FILE:'.':HELP.ITEM; * REV ONLY
CASE OPSYS EQ "M"
HELP.FILE = 'HLP-':DOC.NAME.F
HELP.ITEM = DOC.NAME.I
HELP.TEXT = ' ':HELP.FILE:' ':HELP.ITEM
CASE TRUE
HELP.FILE = 'HLP,':DOC.NAME.F
HELP.ITEM = DOC.NAME.I
HELP.TEXT = ' ':HELP.FILE:' ':HELP.ITEM
END CASE
*
PRINT @(ZERO,3):
HELP.IN = "0":AM:"0":AM:HELP.ITEM:AM:HELP.FILE
HELP.VERB = HELP.VERB:HELP.TEXT
*
IF HELP.CMD NE EMPTY THEN
EXECUTE HELP.VERB, //IN. < HELP.IN
END ELSE
EXECUTE HELP.VERB
END
*
END; * of DOC.NAME.I present
END; * of DOC.NAME.F present
*
REPEAT
*
RETURN
*
! Clear screen
*
$INCLUDE IBP CLS.ROUTINE
*
! Load test data
*
LOAD.TST: *
*
*INCLUDE IBP TST.INCL.LOAD
RUN.TYPE = TYPE.RUN
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.TST.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,RUN.TYPE,PHANTOM.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
*
END
~MENU.HANDLER.13MAR94~
*PROGRAM:           MENU.HANDLER
*
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                    DAVID STERN - AXION
*
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
* ALL
* SYMNGR SYMNTC SYS
* SWMNGR SEC DEV TCL
* SWINST PARAM PURGE MENUS
*
* MNGR BRMNGR OFMNGR ACCT CRDT ADJ CASH
* SLMNGR MKRTG SALES
* PLMNGR DSPTCH INV SCHED WKO
* DELETE ENTRY INQRY
*
* EFT AI LATE WKO INV
*
EQU VS TO "9205"
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP MENUS.VM.VAR.EQUATES
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
SYS.APPL.LOC = ONE
VERSION = VS; AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE; DISP.ONLY = FALSE
CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
EXEC.VERB = EMPTY; EXEC.DESC = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
CALL.ID = EMPTY; PORT.KEY = EMPTY; CLEAR.FLAG = FALSE
SEC.USER.ID = EMPTY; MENU.NAME = EMPTY; LAST.MENU = EMPTY
REOPEN.SW = FALSE; CR.FLAG = FALSE; RESET.SW = FALSE
NUM = ZERO; CNT.FILE.OPEN = FALSE; NUMC = FALSE; TC.FILL = " "
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = ONE
OLD.CL = EMPTY; OLD.LN = EMPTY; OLD.CL.LOC = ONE; OLD.LN.LOC = ONE
*
*: * Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*CNT.TST = EMPTY
*$INCLUDE IBP CNT.TST.VAR.EQUATES
*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
BREAK OFF
*
CALL COPYRIGHT
*
!!
*
! Perform initialization
*
* IF @USER0 EQ EMPTY THEN PERFORM "RUN BP.OBJ INITIALIZATION"; * REV ONLY
*
NEXT.SYSTEM: *
*
! Open files
*
OPEN "MENUS" TO MU.FILE ELSE PRINT CLB:"MENUS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
*
OPEN "COM" TO COM.FILE THEN COM.FILE.OPEN = TRUE ELSE
PRINT CLB:"COM file is missing!":BELL:; RQM; RQM; RQM
COM.FILE.OPEN = FALSE
END
*
OPEN "CNT" TO CNT.FILE THEN CNT.FILE.OPEN = TRUE ELSE
PRINT CLB:"CNT file is missing!":BELL:; RQM; RQM; RQM
CNT.FILE.OPEN = FALSE
END
*
OPEN "PAR" TO PAR.FILE ELSE
OPEN "LISTS" TO PAR.FILE ELSE PRINT CLB:"LISTS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
*
OPEN "LOCKS" TO LCK.FILE ELSE
PRINT CLB:"LOCKS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
* LCK.FILE = 0; * REV ONLY
LCK.ITM = FALSE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
! Set ACC file settings
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
! Set port control key
*
SEC.USER.ID = EMPTY; MENU.NAME = EMPTY
RESET.SW = FALSE; LAST.MENU = EMPTY
$INCLUDE IBP SYS.INCL.LOAD.PORT.KEY
*
! Initialize tables
*
MAT PAR.MENU = EMPTY; MAT SEC.USER = EMPTY
DIM MENU(70),ROUTE(70),DOC(70),PRMPT(70),MDESC(70)
$INCLUDE IBP STD.DIM
MAT STD = EMPTY
STD.FUNC = "READ"; STD.CONT = FALSE; STD.SUBR.NAME = EMPTY
*
! Read default menu and generic terminal type flag
*
READV DF.MENU.NAME FROM MU.FILE,"FIRST.MENU",ONE ELSE
DF.MENU.NAME = "/"
END
*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE 
IF OPSYS EQ "M" OR OPSYS EQ "U" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
*
! Load port control record
*
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID THEN
*
* SEC.USER.ID = PAR.MENU$USER
MENU.NAME = PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = PAR.MENU$LOCN<ONE,ONE>
OLD.CL.LOC = SCR.LOCN<ONE,ONE,ONE>
OLD.CL     = SCR.LOCN<ONE,ONE,TWO>
OLD.LN     = SCR.LOCN<ONE,ONE,3>
*
* Was this port ever active?
IF PAR.MENU$MENU.ID NE EMPTY THEN
*
* Pop last run off of menu stack
LOOP
DEL PAR.MENU$MENU.ID<ONE,ONE>
DEL PAR.MENU$LOCN<ONE,ONE>
WHILE LEN(PAR.MENU$MENU.ID) AND PAR.MENU$MENU.ID<ONE,ONE> EQ MENU.NAME DO SCR.LOCN = PAR.MENU$LOCN<ONE,ONE> REPEAT
*
* Delete stack item where duplicate exist
* back to duplicate
LOOP
LOCATE MENU.NAME IN PAR.MENU$MENU.ID<ONE> SETTING TMP ELSE TMP = FALSE
WHILE LEN(PAR.MENU$MENU.ID) AND TMP DO
TMP = DCOUNT(PAR.MENU$MENU.ID,VM)
DEL PAR.MENU$MENU.ID<ONE,TMP>
DEL PAR.MENU$LOCN<ONE,TMP>
REPEAT
*
* now put curr back on front
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
*
END; * of active port
*
* Set menu to be displayed
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = "Logon / Initialization"
* * Clear user data for this port
* PAR.MENU$GROUP = EMPTY
* PAR.MENU$USER = EMPTY
* PAR.MENU$USER.DT = EMPTY; PAR.MENU$USER.TM = EMPTY
*
END ELSE
*
! Port control record missing
*
MAT PAR.MENU = EMPTY
PAR.MENU$PORT.KEY = PORT.KEY
MENU.NAME = DF.MENU.NAME
PAR.MENU$MENU.ID = MENU.NAME
SCR.LOCN = ONE:SVM:ZERO:SVM:ZERO
PAR.MENU$LOCN = SCR.LOCN
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = "Logon / Initialization"
*
END; * of load port control
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Load operating system file, field, and attribute
*
IF ACC.ID EQ EMPTY THEN
*
ACC.ID = PAR.MENU$PORT.KEY
ACC.FILE.NAME = FIELD(ACC.ID,"@",TWO)
ACC.AM.DESC = FIELD(ACC.ID,"@",3) 
ACC.AM.DT   = FIELD(ACC.ID,"@",4)
ACC.AM.TM   = FIELD(ACC.ID,"@",5)
ACC.AM.VERB = FIELD(ACC.ID,"@",6)
ACC.ID = FIELD(ACC.ID,"@",ONE) 
IF ACC.FILE.NAME EQ EMPTY THEN ACC.FILE.NAME = "ACC"
IF ACC.ID EQ EMPTY THEN ACC.ID = CALL.ID 
*
TMP = FIELD(ACC.FILE.NAME," ",TWO)
IF LEN(TMP) THEN
ACC.FILE.NAME = TMP
ACC.FILE.DICT = FIELD(ACC.FILE.NAME," ",ONE)
END ELSE ACC.FILE.DICT = EMPTY
*
END ELSE
PAR.MENU$PORT.KEY = ACC.ID:"@":ACC.FILE.NAME:"@":ACC.AM.DESC:"@":ACC.AM.DT:"@":ACC.AM.TM:"@":ACC.AM.VERB
END
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:ACC.FILE.DICT:" ":ACC.FILE.NAME:" file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
*
! Set first response to current Menu attr 1
*
READV RSP FROM MU.FILE,MENU.NAME,ONE ELSE MENU.NAME = DF.MENU.NAME; SCR.LOCN = ONE:SVM:TWO:SVM:TWO
*
! Load company data
*
CO.DATA = "System not on disk":AM:DATE():AM:(15*60*60)
IF CNT.FILE.OPEN THEN
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CNT.FILE.OPEN = FALSE
END
CO.NAME = CO.DATA<ONE,ONE,ONE>; CO.DATE = CO.DATA<TWO,ONE,ONE>
DT = DATE(); TM = TIME()
IF PAR.MENU$USER EQ EMPTY THEN SEC.USER.ID = EMPTY
*
! Maintain special copyright info
*
IF SEC.USER.ID EQ EMPTY OR CO.DATA<4> OR (CO.DATE NE DT AND NOT(CO.DATE + ONE EQ DT AND TM LT 10000)) THEN
EXEC.DESC = (SEC.USER.ID:" ":"Operator ID") "L#25"
READ TMP FROM ACC.FILE,ACC.ID ELSE TMP = EMPTY
TMP<ACC.AM.DESC> = EXEC.DESC
TMP<ACC.AM.VERB> = EXEC.VERB
TMP<ACC.AM.DT>   = DATE()
TMP<ACC.AM.TM>   = TIME()
WRITE TMP ON ACC.FILE,ACC.ID
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
IF STAT THEN CHAIN "AXOFF"
IF NOT(STAT) THEN
IF PAR.MENU$BF THEN BREAK ON
END
END
*
! Load control information
*
* System Test Flag
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
* User data
STD.FUNC = "READ"
GOSUB LOAD.STD.DATA
*
* Cursor keys
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":OPSYS ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE CURSOR.KEYS = EMPTY
END
*
* Function keys
IF CURSOR.KEYS<4> EQ EMPTY THEN
CURSOR.KEYS<4>  = "What?":VM:"How?":VM:"tcl":VM:"off":VM:"spool":VM:"compress":VM:"large":VM:"system"
CURSOR.KEYS<5> = "?":VM:"??":VM:"TCL":VM:"OFF":VM:"SPO":VM:"COM":VM:"REG":VM:"ACT"
END
*
!!
*
! Display the next menu
*
NEXT.MENU: *
*
*
CO.NAME = CO.DATA<ONE,ONE,ONE>; CO.DATE = CO.DATA<TWO,ONE,ONE>
DT = DATE(); TM = TIME()
*
* Check control date to maintain it (OK if before 03:00 the next mourning)
IF CO.DATE NE DT AND NOT(DT EQ CO.DATE + ONE AND TM LT 10000) THEN
IF NOT(CO.DATA<4>) THEN
PAR.MENU$USER = EMPTY; * clear user on date change
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
EXEC.DESC = (SEC.USER.ID:" ":"Control Date") "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
GOTO NEXT.SYSTEM
END ELSE
PRINT CLB:"CONTROL DATE OVERRIDE IS SET!":BELL:
RQM
END
END
*
!
*
LOOP
*
HELP = ZERO
*
* Check control date reset on user
IF ((DATE() - PAR.MENU$USER.DT) * 86400) + (TIME() - PAR.MENU$USER.TM) GT 14400 THEN
PAR.MENU$USER = EMPTY
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
GOTO NEXT.SYSTEM
END
*
* Load menu record if it has changed.
IF MENU.NAME NE LAST.MENU THEN
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE
IF MENU.NAME EQ DF.MENU.NAME THEN
PRINT CLB:"MENUS ":DF.MENU.NAME:" item missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END ELSE
MENU.NAME = DF.MENU.NAME
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE PRINT CLB:"MENUS ":MENU.NAME:" item missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
END
CL.START = 22; CL.INC = 40; CL.NUM = ONE
* Clear menu tables
MAT ROUTE = EMPTY; MAT PRMPT = EMPTY; MAT MDESC = EMPTY
POS.LOC = EMPTY
POS.REF = EMPTY
POS.LN = EMPTY
END
*
* Write location to system accounting file
EXEC.DESC = (SEC.USER.ID:" ":MENU(1)) "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = MENU(1)
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Display Menu
*
PRINT @(ZERO,ZERO):CLS:RVB:(OCONV(CO.DATE,"D2"):" ":OCONV(TIME(),"MTS")[1,5]) "L#15":(SPACE(25 - (LEN(CO.NAME) + ONE) / TWO):CO.NAME) "L#50":("Oper ":SEC.USER.ID:SPACE(LEN(SEC.USER$DESC) - LEN(SEC.USER.ID))) "R#15":
PRINT @(ZERO,ONE):(WHO:"\":MENU.NAME) "L#15":(SPACE(25 - (LEN(MENU(ONE)) + ONE) / TWO):MENU(ONE)) "L#50":("Name ":SEC.USER$DESC) "R#15":RVE:
*
* Determine number of columns and width
*
IF MENU.NAME NE LAST.MENU THEN
AM.CN = TWO; CL = CL.START; CL.NUM = ONE
LOOP LINE = MENU(AM.CN) UNTIL LINE EQ EMPTY OR AM.CN EQ 100 DO
AM.CN = AM.CN + ONE
IF LINE<ONE,MENUS.VM$DESC> EQ ">" THEN
IF CL EQ TWO THEN
CL.INC = 30
END ELSE
CL.START = TWO; CL = CL.START
END
CL.NUM = CL.NUM + ONE
END
REPEAT
MAX.AM.CN = AM.CN - ONE
END
*
NUM = ONE; CL = CL.START; LN = 3; CL.NUM = ONE
*
! Load menu tables
*
FOR AM.CN = TWO TO MAX.AM.CN
*
LINE = MENU(AM.CN)
*
! Validate operating system, user and group info
*
! Check operating system
*
IF LINE<ONE,MENUS.VM$OPSYS> EQ EMPTY OR INDEX(LINE<ONE,MENUS.VM$OPSYS>,OPSYS,ONE) THEN
*
IF LINE<ONE,MENUS.VM$USER> EQ EMPTY AND LINE<ONE,MENUS.VM$GROUP> EQ EMPTY THEN CONT = TRUE ELSE
*
!  Group
*
CN.MAX = DCOUNT(PAR.MENU$GROUP,SVM)
IF CN.MAX THEN
CN = ZERO; CONT = FALSE
LOOP CN = CN + ONE WHILE CN LE CN.MAX AND NOT(CONT) DO
LOCATE PAR.MENU$GROUP<ONE,ONE,CN> IN LINE<ONE,MENUS.VM$GROUP> SETTING TMP THEN CONT = TRUE ELSE NULL
IF PAR.MENU$GROUP<ONE,ONE,CN> EQ "ALL" THEN CONT = TWO
REPEAT
END ELSE CONT = TRUE
*
! User
*
IF LINE<ONE,MENUS.VM$USER> NE EMPTY THEN
LOCATE PAR.MENU$USER IN LINE<ONE,MENUS.VM$USER> SETTING TMP THEN NULL ELSE
IF CONT NE TWO THEN CONT = FALSE
END
END
*
END; * Of group or user not empty
*
END ELSE CONT = FALSE
*
! Menu line is valid
*
IF CONT THEN
*
TEXT = LINE<ONE,MENUS.VM$DESC>
*
* Is line a column seperator
IF TEXT EQ ">" THEN
CL = CL + CL.INC; LN = TWO; CL.NUM = CL.NUM + ONE; PRINT @(CL,LN):
END ELSE
*
* Check if line is comment or menu parameter
IF TEXT[ONE,ONE] NE "*" THEN
*
IF MENU.NAME NE LAST.MENU THEN
*
PRMPT(NUM) = LINE<ONE,MENUS.VM$LABEL>; IF PRMPT(NUM) EQ EMPTY THEN PRMPT(NUM) = NUM
*
LOCATE CL IN POS.LOC<LN + ONE> BY "AR" SETTING CL.LOC ELSE
INS "" BEFORE POS.LOC<LN + ONE,CL.LOC>
INS "" BEFORE POS.REF<LN + ONE,CL.LOC>
END
*
POS.LOC<LN + ONE,CL.LOC> = CL
POS.REF<LN + ONE,CL.LOC> = PRMPT(NUM):"|0|0"
POS.LN<NUM> = LN
*
IF MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE> AND NUM EQ ONE THEN
OLD.CL.LOC = CL.NUM; OLD.CL = CL; OLD.LN = LN
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
END
*
ROUTE(NUM) = LINE<ONE,MENUS.VM$VERB>
DOC(NUM) = LINE<ONE,MENUS.VM$HELP>
MDESC(NUM) = LINE<ONE,MENUS.VM$DESC>
*
END
*
IF PAR.MENU$MENU.ID EQ EMPTY AND NUM EQ ONE THEN
OLD.CL.LOC = CL.NUM; OLD.CL = CL; OLD.LN = LN
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
PAR.MENU$MENU.ID = MENU.NAME
PAR.MENU$LOCN = SCR.LOCN
END
*
* don't display lines if user is entering information
* ULT ONLY
IF SYSTEM(11) LT 3 THEN
IF TEXT NE EMPTY THEN PRINT @(CL,LN):RVB:PRMPT(NUM) "R#3":RVE:" ":TEXT
* ULT ONLY
END
*
NUM = NUM + ONE
*
END ELSE
* ULT ONLY
IF SYSTEM(11) LT 3 THEN
 IF TEXT NE "*" THEN PRINT @(CL - TWO,LN):TEXT[TWO,99]
* ULT ONLY
END
END
*
END; * Of column seperator
*
LN = LN + ONE
*
END; * of valid for this OPerating SYStem
*
NEXT AM.CN
*
IF MENU.NAME NE LAST.MENU THEN
LAST.MENU = MENU.NAME
END
CL = OLD.CL; CL.LOC = OLD.CL.LOC; LN = OLD.LN
*
!!
*
! Accept response from user
*
LOOP
*
OLD.CL.LOC = SCR.LOCN<ONE,ONE,ONE>
OLD.CL     = SCR.LOCN<ONE,ONE,TWO>
OLD.LN     = SCR.LOCN<ONE,ONE,3>
* CL = OLD.CL; CL.LOC = OLD.CL.LOC; LN = OLD.LN
*
* If no cursor keys defined or generic
*
PRINT @(20,22):"Enter your choice: ":
* * ULT ONLY
* INPUTCLEAR
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
*
* Input using cursor keys
*
* ULT ONLY
IF SYSTEM(11) LT 3 THEN
PRINT CLB:; *PRINT @(ZERO,TWO):CLL:
* ULT ONLY
END
DEF.SUPP = FALSE
VC = ONE
*
* Display function keys
IF NOT(GENERIC) THEN
LOOP UNTIL CURSOR.KEYS<4,VC> EQ EMPTY OR VC GT 8 DO
* ULT ONLY
IF SYSTEM(11) LT 3 THEN
PRINT RVB:("F":VC):RVE:" ":CURSOR.KEYS<4,VC>:"  ":
* ULT ONLY
END
VC = VC + ONE
REPEAT
END
*
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
LH = "L25"; LHM = 135
MS = EMPTY; NO.PROMPT = FALSE; FIXED = FALSE
RSP.LN = 22; RSP.CL = 40
*
$INCLUDE IBP CURSOR.STD
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
*$INCLUDE IBP CURSOR.POS
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO
DEF.SUPP = INDEX("2846",TC.FUNC,ONE)
REPEAT
*
! Process response
*
PRINT @(ZERO,23):CLL:@(ZERO,22):CLL:@(20,22):"Enter your choice: ":RVB:RSP:RVE:
*
* END; * OF CURSOR KEYS NE EMPTY
*
!!
*
! Process command
*
EXEC.VERB = EMPTY; EXEC.DESC = EMPTY; CR.FLAG = FALSE
*
BEGIN CASE
*
! TCL dot command
*
CASE RSP[ONE,ONE] EQ "."
PAR.MENU$DESC = "Menu: ":MENU.NAME:" ":RSP
EXEC.VERB = RSP; EXEC.DESC = (SEC.USER.ID:" ":MENU(1)) "L#25":RSP "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
PRINT @(ZERO,3):CLS:RSP[TWO,9999]
EXEC.VERB = RSP
CR.FLAG = TRUE
*
! Request for previous menu
*
CASE RSP EQ EMPTY OR RSP[ONE,3] EQ "POP"
IF RSP[ONE,3] EQ "POP" THEN
EXEC.DESC = (SEC.USER.ID:" ":"PoP") "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
* CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
EXEC.VERB = EMPTY
END
*
LOOP
EXEC.VERB = PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = PAR.MENU$LOCN<ONE,ONE>
IF EXEC.VERB EQ EMPTY THEN EXEC.VERB = DF.MENU.NAME
POP.CONT = FALSE
IF LEN(PAR.MENU$MENU.ID) AND EXEC.VERB EQ MENU.NAME THEN POP.CONT = TRUE
* IF PAR.MENU$?<ONE,ONE> EQ EMPTY THEN POP.CONT = TRUE
WHILE POP.CONT DO
IF MENU.NAME EQ PAR.MENU$MENU.ID<ONE,ONE> THEN
DEL PAR.MENU$MENU.ID<ONE,ONE>
DEL PAR.MENU$LOCN<ONE,ONE>
END
REPEAT
PAR.MENU$DESC = "previous menu"
EXEC.DESC = PAR.MENU$DESC
*
* CASE RSP EQ CHAR(1)
* IF GENERIC THEN GENERIC = FALSE ELSE GENERIC = TRUE
* EXEC.VERB = MENU.NAME
*
CASE RSP EQ "RE"
EXEC.VERB = MENU.NAME
*
CASE RSP[ONE,4] EQ "PUSH"
EXEC.DESC = (SEC.USER.ID:" ":"Function") "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
EXEC.VERB = RSP[4,9999]
IF EXEC.VERB[ONE,ONE] EQ " " THEN EXEC.VERB = EXEC.VERB[TWO,9999]
* PAR$MENU? = (DATE*100000) + TIME()) "R#10":EXEC.VERB
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
CASE RSP EQ "DATE"
EXEC.DESC = (SEC.USER.ID:" ":"Control Date") "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
EXEC.VERB = MENU.NAME
*
! Other command
*
CASE TRUE
*
IF RSP[ONE,ONE] EQ "?" THEN
SUB = EMPTY; RSP = TRIM(RSP[TWO,99]); IF RSP[ONE,ONE] EQ "?" THEN RSP = RSP[TWO,99]; HELP = TWO ELSE HELP = ONE
EXEC.VERB = STR("?",HELP); DOC.NAME = RSP
EXEC.DESC = EXEC.VERB:" ":DOC.NAME
*IF RSP EQ EMPTY THEN RSP = MENU.NAME
IF DOC.NAME EQ EMPTY THEN DOC.NAME = MENU.NAME
END ELSE SUB = FIELD(RSP,"/",TWO); RSP = FIELD(RSP,"/",ONE); HELP = ZERO
*
IF SUB NE EMPTY THEN
READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
IF EXEC.VERB NE EMPTY THEN READ DEFAULTS FROM MU.FILE,"/":RSP THEN RSP = SUB; GOSUB CHECK.DEFAULTS
END ELSE
*
FOR NUM = ONE TO 70 UNTIL PRMPT(NUM) EQ RSP OR PRMPT(NUM) EQ EMPTY; NEXT NUM
*
IF PRMPT(NUM) NE EMPTY THEN
EXEC.VERB = ROUTE(NUM); EXEC.DESC = (SEC.USER.ID:" ":MENU(1)) "L#25":MDESC(NUM) "L#25"
DOC.NAME = DOC(NUM)
IF DOC.NAME EQ EMPTY THEN DOC.NAME = STR("?",HELP):EXEC.VERB
* SCR.LOCN = NUM
LN = POS.LN<NUM>
TMP = PRMPT(NUM):"|0|0"
LOCATE TMP IN POS.REF<LN + ONE> SETTING CL.LOC ELSE NULL
CL = POS.LOC<LN + ONE,CL.LOC>
PRINT @(CL,LN):
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
END ELSE IF EXEC.VERB[ONE,ONE] NE "?" AND EXEC.VERB[ONE,ONE] NE "/" THEN
READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
END
*
END; * of empty SUB
*
IF HELP OR EXEC.VERB[ONE,ONE] EQ "?" THEN
*
IF NOT(HELP) THEN
IF EXEC.VERB[TWO,ONE] EQ "?" THEN HELP = TWO ELSE HELP = ONE
END
*
IF HELP AND EXEC.VERB NE EMPTY THEN GOSUB HELP.MESSAGE; EXEC.VERB = MENU.NAME
*
END; * OF "?"
*
END CASE
*
WHILE EXEC.VERB = EMPTY DO PRINT BELL: REPEAT
*
!
*
IF MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE> AND RSP NE EMPTY THEN
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
END ELSE
PAR.MENU$LOCN<ONE,ONE> = SCR.LOCN
END
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
WHILE EXEC.VERB[ONE,ONE] EQ "/" DO
*
MENU.NAME = EXEC.VERB
*
REPEAT
*
!!
*
*INCLUDE IBP SYS.INCL.EXEC.STD.FUNC
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
!
*
UNLOCK: *
*
REOPEN.SW = EMPTY
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF CNT.FILE.OPEN THEN
READ RAMDISK.CNT FROM CNT.FILE,"RAMDISK.FILES" THEN
LOCATE ONE IN RAMDISK.CNT<TWO> SETTING LOC THEN
OPEN "LISTS" TO LISTS.FILE THEN
READ RAMDISK.REC FROM LISTS.FILE,"RAMDISK.FILES" THEN
EXEC.DESC = (SEC.USER.ID:" ":"Download Ram Disk") "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL DOWNLOAD.RAMDISK(CNT.FILE,RAMDISK.CNT,LISTS.FILE,RAMDISK.REC)
REOPEN.SW = ONE
END
END
END
END
END
*
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF REOPEN.SW THEN GOTO NEXT.SYSTEM
*
IF RESET.SW THEN GOTO NEXT.SYSTEM
*
IF NOT(CNT.FILE.OPEN) THEN GOTO NEXT.MENU
*
GOTO NEXT.MENU
*
!
*
STOP
*
!
*
CHECK.DEFAULTS: *
*
LCK.STAT = FALSE
LOCATE "TCL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "MENUS" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "DEV" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "ALL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE LCK.STAT = TRUE
END
END
END
*
IF LCK.STAT THEN EXEC.VERB = MENU.NAME ELSE
*
AM.CN = TWO
LOOP DEFAULT = DEFAULTS<AM.CN> UNTIL DEFAULT<ONE,MENUS.VM$LABEL> EQ RSP OR DEFAULT EQ EMPTY DO AM.CN = AM.CN + ONE REPEAT
IF DEFAULT EQ EMPTY THEN
* EXEC.VERB = "/":RSP
* READV TMP FROM MU.FILE,EXEC.VERB,ONE ELSE EXEC.VERB = MENU.NAME
TMP1 = "/":RSP
READV TMP FROM MU.FILE,TMP1,ONE THEN EXEC.VERB = TMP1 ELSE NULL
END ELSE
EXEC.VERB = DEFAULT<ONE,MENUS.VM$VERB>; DOC.NAME = DEFAULT<ONE,MENUS.VM$HELP>; IF DOC.NAME EQ EMPTY THEN DOC.NAME = EXEC.VERB
END
*
END
*
RETURN
*
! Load STD DATA
*
LOAD.STD.DATA: *
*
*INCLUDE IBP SYS.INCL.LOAD.STD.DATA
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
! Standard System Call
*
ENTER.STD.SUBR: *
*
*INCLUDE IBP SYS.INCL.ENTER.STD.SUBR
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
! Allow authorized entry into debug mode
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!!
*
! Help Features
*
HELP.MESSAGE: *
CLS.COL = ZERO; CLS.ROW = TWO; GOSUB CLS.ROUTINE
IF NOT(GENERIC) AND (EXEC.VERB EQ "?" OR DOC.NAME EQ "?") THEN
EXEC.VERB = 'COPY PAR MASK (T,S)'
PRINT @(ZERO,3):
EXECUTE EXEC.VERB
PRINT CLB:"Enter <cr> to continue with help . . . ":; INPUT TMP.RSP:
PRINT @(ZERO,ZERO):CLS:
END
DOC.NAME.F = FIELD(DOC.NAME," ",ONE)
IF DOC.NAME.F NE EMPTY THEN
DOC.NAME.I = FIELD(DOC.NAME," ",TWO)
IF DOC.NAME.I EQ EMPTY THEN DOC.NAME.I = DOC.NAME.F; DOC.NAME.F = "CABLE"
IF HELP EQ TWO THEN DOC.NAME.I = "?":DOC.NAME.I
* ULT ONLY
EXEC.VERB = 'RUNOFF HLP,':DOC.NAME.F:' ':DOC.NAME.I
* EXEC.VERB = 'RUNOFF HLP ':DOC.NAME.F:'.':DOC.NAME.I; * REV ONLY
PRINT @(ZERO,3):
EXECUTE EXEC.VERB
PRINT CLB:"Enter <cr> to return to menu . . . ":; INPUT TMP.RSP:
END
*
RETURN
*
! Clear screen
*
$INCLUDE IBP CLS.ROUTINE
*
! Load test data
*
LOAD.TST: *
*
*INCLUDE IBP TST.INCL.LOAD
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,RUN.TYPE,PHANTOM.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
*
END
~MENU.HANDLER.BU~
*PROGRAM:           MENU.HANDLER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
NEXT.SYSTEM: *
* IF @USER0 EQ EMPTY THEN PERFORM "RUN BP.OBJ INITIALIZATION"; * REV ONLY
!
*
OPEN "MENUS" TO MU.FILE ELSE STOP
OPEN "PAR" TO PAR.FILE ELSE
OPEN "LISTS" TO PAR.FILE ELSE STOP
END
*
!
*
LAST.MENU = EMPTY
PORT.KEY = (PORT+1000) "R#3"
CALL.ID = "MENU.":PORT.KEY
IF OPSYS NE "R" THEN
* IF OPSYS NE "U" THEN
OPEN "ACC" TO AC.FILE ELSE STOP
* END ELSE
IF OPSYS EQ "U" THEN
OPEN "DICT","ACC" TO AC.FILE.D ELSE STOP
END
END
*
!
*
DIM SCR.POSN(5); MAT SCR.POSN = EMPTY
DIM MENU(50),ROUTE(50),DOC(50),PRMPT(50),POSN(50)
*
READV DF.MENU.NAME FROM MU.FILE,"FIRST.MENU",ONE THEN
READ GENERIC FROM PAR.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM PAR.FILE,"GENERIC" ELSE NULL
END
END ELSE
DF.MENU.NAME = "/"
END
*
!
*
MATREAD SCR.POSN FROM PAR.FILE,CALL.ID THEN
*
ACC.ID = SCR.POSN(ONE)
MENU.NAME = SCR.POSN(TWO)<ONE,ONE>
SCR.LOCN = SCR.POSN(3)<ONE,ONE>
*
IF SCR.POSN(TWO) NE EMPTY THEN
*
LOOP
DEL SCR.POSN(TWO)<ONE,ONE>
DEL SCR.POSN(3)<ONE,ONE>
WHILE LEN(SCR.POSN(TWO)) AND SCR.POSN(TWO)<ONE,ONE> EQ MENU.NAME DO SCR.LOCN = SCR.POSN(3)<ONE,ONE> REPEAT
*
LOOP
LOCATE MENU.NAME IN SCR.POSN(TWO)<ONE> SETTING TMP ELSE TMP = FALSE
WHILE LEN(SCR.POSN(TWO)) AND TMP DO
TMP = DCOUNT(SCR.POSN(TWO),VM)
DEL SCR.POSN(TWO)<ONE,TMP>
DEL SCR.POSN(3)<ONE,TMP>
REPEAT
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "Logon / Initialization"
*
END
*
END ELSE
MAT SCR.POSN = EMPTY
CALL COPYRIGHT
ACC.ID = "MENU.":PORT.KEY
SCR.POSN(ONE) = ACC.ID
MENU.NAME = DF.MENU.NAME
SCR.POSN(TWO) = MENU.NAME
SCR.LOCN = ONE
SCR.POSN(3) = SCR.LOCN
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "Logon / Initialization"
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
END
*
!
*
READV RSP FROM MU.FILE,MENU.NAME,ONE ELSE MENU.NAME = DF.MENU.NAME; SCR.LOCN = ONE
RSP = EMPTY
IF NOT(NUM(SCR.LOCN)) THEN SCR.LOCN = ONE
IF SCR.LOCN LT ONE THEN SCR.LOCN = ONE
*
CO.DATA = "System not on disk":AM:DATE(); CNT.FILE.SW = EMPTY
CNT.FILE.OPEN = EMPTY
OPEN "CNT" TO CNT.FILE THEN
CNT.FILE.OPEN = ONE
READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN CNT.FILE.SW = ONE ELSE CO.DATA = EMPTY; CNT.FILE.SW = EMPTY
END
*CKEYS
IF GENERIC THEN CURSOR.KEYS = EMPTY ELSE
*CKEYS
READ CURSOR.KEYS FROM PAR.FILE,"CURSOR.KEYS" ELSE CURSOR.KEYS = EMPTY
*CKEYS
END
*CKEYS
FKEYS="F1":VM:"F2":VM:"F3":VM:"F4":VM:"F5":VM:"F6":VM:"F7":VM:"F8":AM:"What?":VM:"How?":VM:"off":VM:"tcl":VM:"spool":VM:"compress":VM:"large":VM:"system"
IF LEN(CURSOR.KEYS<4>) THEN FKEYS = FKEYS<ONE>:AM:CURSOR.KEYS<4>
CO.NAME = CO.DATA<ONE,ONE,ONE>; CONTROL.DATE = CO.DATA<TWO,ONE,ONE>
IF CONTROL.DATE NE DATE() THEN
IF NOT(DATE() EQ CONTROL.DATE AND TIME() LT 10000) THEN
IF NOT(CO.DATA<3>) THEN
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
END ELSE
PRINT @(ZERO,23):CLL:"CONTROL DATE OVERRIDE IS SET!":
RQM
END
END
END
*
!
*
NEXT.MENU: *
*
*
LOOP
*
HELP = ZERO
*
IF MENU.NAME NE LAST.MENU THEN
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE
IF MENU.NAME EQ DF.MENU.NAME THEN STOP ELSE
MENU.NAME = DF.MENU.NAME
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE STOP
END
END
LAST.MENU = MENU.NAME
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV MENU(1) ON AC.FILE.D,ACC.ID,4
END
WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
END
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = MENU(1)
END
*
!
*
MAT ROUTE = EMPTY; MAT PRMPT = EMPTY; MAT POSN = EMPTY
TMP = ACCT; IF LEN(TMP) EQ ONE THEN TMP = TMP:" "
PRINT @(ZERO,ZERO):CLS:RVB:OCONV(CONTROL.DATE,"D2") "L#12":(SPACE(28 - (LEN(CO.NAME) + ONE) / TWO):CO.NAME) "L#56":("Port ":PORT:SPACE(LEN(TMP) - TWO)) "R#12":
PRINT @(ZERO,ONE):OCONV(TIME(),"MTS") "L#12":(SPACE(28 - (LEN(MENU(ONE)) + ONE) / TWO):MENU(ONE)) "L#56":("Acct ":TMP) "R#12":RVE:
*
AC = TWO; CL = 22; LN = 3
LOOP LINE = MENU(AC) UNTIL LINE EQ EMPTY OR AC EQ 100 DO
AC = AC + ONE
IF LINE<ONE,ONE> EQ ">" THEN CL = TWO
REPEAT
*
MAX.AC = AC - ONE
NUM = ONE
*
!
*
FOR AC = TWO TO MAX.AC
*
LINE = MENU(AC)
IF LINE<ONE,5> EQ EMPTY OR INDEX(LINE<ONE,5>,OPSYS,ONE) THEN
TEXT = LINE<ONE,ONE>
IF TEXT EQ ">" THEN CL = 42; LN = TWO; PRINT @(CL,LN): ELSE
IF TEXT[ONE,ONE] NE "*" THEN
PRMPT(NUM) = LINE<ONE,3>; IF PRMPT(NUM) EQ EMPTY THEN PRMPT(NUM) = NUM
POSN(NUM) = CL:AM:LN
ROUTE(NUM) = LINE<ONE,TWO>
DOC(NUM) = LINE<ONE,4>
IF TEXT NE EMPTY THEN PRINT @(CL,LN):RVB:PRMPT(NUM) "R#3":RVE:" ":TEXT
NUM = NUM + ONE
END ELSE IF TEXT NE "*" THEN PRINT @(CL - TWO,LN):TEXT[TWO,99]
END
LN = LN + ONE
END
*
NEXT AC
*
!
*
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
*SCR.POSN(5) = MENU.NAME
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV MENU(1) ON AC.FILE,ACC.ID,4
END
WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
END
*
!
*
LOOP
*
*CKEYS
IF CURSOR.KEYS EQ EMPTY THEN
PRINT @(20,23):"Enter your choice: ":
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
INPUT RSP:
END ELSE
*CKEYS
*
PRINT CLB:
VC = ONE
*
LOOP UNTIL FKEYS<ONE,VC> EQ EMPTY DO
PRINT RVB:FKEYS<ONE,VC>:RVE:" ":FKEYS<TWO,VC>:"  ":
VC = VC + ONE
REPEAT
*
RSP = "\\\"
CRSP = EMPTY
*
* CURSOR POSITIONING LOOP
*
LOOP WHILE RSP EQ "\\\" DO
*
IF NOT(NUM(SCR.LOCN)) THEN SCR.LOCN = ONE
IF SCR.LOCN LT ONE THEN SCR.LOCN = ONE
FUNC.KEY = EMPTY
CLLN = POSN(SCR.LOCN)
CL = CLLN<ONE> - ONE
LN = CLLN<TWO>
PRINT @(CL,LN):
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
ECHO OFF
INPUT RSPC,ONE:
ECHO ON
RSPN = SEQ(RSPC)
*
LOCATE RSPN IN CURSOR.KEYS<TWO> SETTING LOC THEN
RSPC = CURSOR.KEYS<3,LOC>; FUNC.KEY = ONE
RSPN = SEQ(RSPC)
END
*
IF NOT(RSPN) OR RSPN EQ 255 THEN
* MATCHES MINI'S MORE ACCURATELYRSP = PRMPT(SCR.LOCN)
RSP = EMPTY
IF CRSP NE EMPTY THEN RSP = CRSP
*
END ELSE IF FUNC.KEY AND RSPC EQ "5" THEN
RSP = PRMPT(SCR.LOCN)
IF CRSP NE EMPTY THEN RSP = CRSP
*
END ELSE
*
IF RSPN EQ 27 OR RSPN EQ 251 THEN
ECHO OFF
PRINT @(ZERO,22):CLL:RVB:"Enter function key number: ":RVE:
INPUT RSPC,ONE:
PRINT @(ZERO,22):CLL:
IF NUM(RSPC) THEN
IF RSPC GT ZERO AND RSPC LT 10 THEN
IF LEN(CURSOR.KEYS<5>) THEN
RSP = CURSOR.KEYS<5,RSPC>
END ELSE
RSPC = "NIOTSCRA"[RSPC,ONE]
FUNC.KEY = ONE
END
END
END ELSE
IF INDEX("NIOTSCRA",RSPC,ONE) THEN FUNC.KEY = ONE ELSE RSPC = EMTPY
END
ECHO ON
END; * OF ESC ENTERED
*
IF FUNC.KEY THEN
*
IF RSPC EQ ZERO THEN
CRSP = EMPTY
PRINT @(ZERO,22):CLL:
*
END ELSE IF RSPC EQ TWO THEN
SCR.LOCN = SCR.LOCN + ONE
IF PRMPT(SCR.LOCN) EQ EMPTY THEN SCR.LOCN = ONE
*
END ELSE IF RSPC EQ "8" THEN
SCR.LOCN = SCR.LOCN - ONE
IF NOT(SCR.LOCN) THEN RSP = EMPTY
*
END ELSE IF RSPC EQ "4" THEN
SCR.LOCN = ZERO
NCL = EMPTY; NLN = EMPTY; FOUND = EMPTY
*
LOOP UNTIL NLN GE LN DO
IF NCL LT CL THEN FOUND = FOUND + ONE
SCR.LOCN = SCR.LOCN + ONE
CLLN = POSN(SCR.LOCN)
NCL = CLLN<ONE> - ONE
NLN = CLLN<TWO>
REPEAT
*
IF NCL >= CL THEN
IF FOUND LT TWO THEN RSP = EMPTY ELSE SCR.LOCN = SCR.LOCN - ONE
END
*
END ELSE IF RSPC EQ "6" THEN
*
LOOP
*
SCR.LOCN = SCR.LOCN + ONE
CLLN = POSN(SCR.LOCN)
NCL = CLLN<ONE> - ONE
NLN = CLLN<TWO>
IF PRMPT(SCR.LOCN) EQ EMPTY THEN LN = ZERO; CL = ZERO; NLN = 999; NCL = 999; SCR.LOCN = SCR.LOCN - ONE
UNTIL NLN GE LN AND NCL GT CL DO
REPEAT
*
END ELSE
*
IF RSPC EQ "N" THEN RSP = "?":PRMPT(SCR.LOCN) ELSE
IF RSPC EQ "I" THEN RSP = "??":PRMPT(SCR.LOCN) ELSE
IF RSPC EQ "O" THEN RSP = "OFF" ELSE
IF RSPC EQ "T" THEN RSP = "TCL" ELSE
IF RSPC EQ "S" THEN RSP = "SPO" ELSE
IF RSPC EQ "C" THEN RSP = "COM" ELSE
IF RSPC EQ "R" THEN RSP = "REG" ELSE
IF RSPC EQ "A" THEN RSP = "ACT"
*
END; * REG
END; * COM
END; * SPO
END; * TCL
END; * OFF
END; * ??
END; * ?
*
END; * OF FKEY FUNCTIONS vs DEFINED POSITIONING
*
END ELSE
*
CRSP = CRSP:RSPC
IF LEN(CRSP) GT 3 AND CRSP[ONE,ONE] NE "." THEN CRSP = CRSP[TWO,3]
PRINT @(25,22):"Entry: ":RVB:CRSP:RVE:"  ":
*
END; * OF CHARACTER
*
END; * OF RSPN NOT NULL
*
REPEAT; * FOR CURSOR POSITIONING LOOP
*
PRINT @(ZERO,23):CLL:@(ZERO,22):CLL:@(20):"Enter your choice: ":RVB:RSP:RVE:
*CKEYS
END; * OF CURSOR KEYS NE EMPTY
*CKEYS
*
!
*
ROUTING = EMPTY; CR.FLAG = FALSE
*
IF RSP[ONE,ONE] EQ "." THEN
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV "Menu: ":MENU.NAME:" ":RSP ON AC.FILE.D,ACC.ID,4
END
WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
END
PRINT @(ZERO,23):CLL:@(ZERO,22):CLL:RSP[TWO,999]
* EXECUTE RSP[TWO,999]
* PRINT CLB:"Enter <cr> to return to menu . . .  ":; INPUT RSP:
* RSP = MENU.NAME
ROUTING = RSP[TWO,999]
END
*
IF RSP EQ EMPTY THEN
LOOP
ROUTING = SCR.POSN(TWO)<ONE,ONE>
IF ROUTING EQ EMPTY THEN ROUTING = DF.MENU.NAME
SCR.LOCN = SCR.POSN(3)<ONE,ONE>
IF NOT(NUM(SCR.LOCN)) THEN SCR.LOCN = ONE
IF SCR.LOCN LT ONE THEN SCR.LOCN = ONE
IF SCR.POSN(TWO) NE EMPTY THEN
DEL SCR.POSN(TWO)<ONE,ONE>
DEL SCR.POSN(3)<ONE,ONE>
END
WHILE LEN(SCR.POSN(TWO)) AND ROUTING EQ MENU.NAME DO REPEAT
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "previous menu"
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
*
END ELSE IF RSP EQ "DATE" THEN
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
ROUTING = MENU.NAME
*
END ELSE IF RSP[ONE,ONE] NE "." THEN
*
IF RSP[ONE,ONE] EQ "?" THEN
SUB = EMPTY; RSP = TRIM(RSP[TWO,99]); IF RSP[ONE,ONE] EQ "?" THEN RSP = RSP[TWO,99]; HELP = TWO ELSE HELP = ONE
ROUTING = STR("?",HELP); DOC.NAME = EMPTY
*IF RSP EQ EMPTY THEN RSP = MENU.NAME
IF DOC.NAME EQ EMPTY THEN DOC.NAME = MENU.NAME
END ELSE SUB = FIELD(RSP,"/",TWO); RSP = FIELD(RSP,"/",ONE); HELP = ZERO
*
IF SUB NE EMPTY THEN
READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
IF ROUTING NE EMPTY THEN READ DEFAULTS FROM MU.FILE,"/":RSP THEN RSP = SUB; GOSUB CHECK.DEFAULTS
END ELSE
*
* IF ROUTING[ONE,ONE] NE "?" AND ROUTING[ONE,ONE] NE "/" THEN
*
FOR NUM = ONE TO 100 UNTIL PRMPT(NUM) EQ RSP OR PRMPT(NUM) EQ EMPTY; NEXT NUM
*
IF NUM LE 100 AND PRMPT(NUM) NE EMPTY THEN
ROUTING = ROUTE(NUM); DOC.NAME = DOC(NUM); IF DOC.NAME EQ EMPTY THEN DOC.NAME = STR("?",HELP):ROUTING
END ELSE READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
*
* END; * OF "?"
*
END; * of empty SUB
*
IF ROUTING[ONE,ONE] EQ "?" THEN
*
IF ROUTING[TWO,ONE] EQ "?" THEN HELP = TWO ELSE HELP = ONE
*
IF HELP THEN IF ROUTING NE EMPTY THEN GOSUB HELP.MESSAGE; ROUTING = MENU.NAME
*
END; * OF "?"
*
END; * of other scan / help
*
WHILE ROUTING = EMPTY DO PRINT BELL: REPEAT
*
!
*
WHILE ROUTING[ONE,ONE] EQ "/" DO
*
MENU.NAME = ROUTING
*
IF MENU.NAME NE EMPTY THEN
IF MENU.NAME NE SCR.POSN(TWO)<ONE,ONE> AND RSP NE EMPTY THEN
INS MENU.NAME BEFORE SCR.POSN(TWO)<ONE,ONE>
INS SCR.LOCN BEFORE SCR.POSN(3)<ONE,ONE>
*IF OPSYS NE "R" THEN
*IF OPSYS EQ "U" THEN
*WRITEV ROUTING ON AC.FILE.D,ACC.ID,4
*END
*WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
*END
END
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
*SCR.POSN(5) = MENU.NAME
*MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
SCR.LOCN = ONE
END
*
REPEAT
*
!
*
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = ROUTING
*
IF (OPSYS EQ "M" OR ROUTING EQ "TCL") AND MENU.NAME NE EMPTY THEN
INS MENU.NAME BEFORE SCR.POSN(TWO)<ONE,ONE>
INS SCR.LOCN BEFORE SCR.POSN(3)<ONE,ONE>
END
*
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV ROUTING ON AC.FILE.D,ACC.ID,4
END
WRITE AM:ROUTING:AM:(DATE() + 100000)[TWO,5]:(TIME() + 100000)[TWO,5] ON AC.FILE,CALL.ID
END
*
IF ROUTING EQ "OFF" OR ROUTING EQ "CHAIN OFF" THEN
*
*DELETE PAR.FILE,CALL.ID
SCR.POSN(TWO) = EMPTY
SCR.POSN(3)   = ONE
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "OFF"
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
END
*
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
*
IF ROUTING = "TCL" THEN
BEGIN CASE
CASE OPSYS EQ "M"
ABORT
CASE TRUE
STOP
END CASE
END
*
IF ROUTING[ONE,6] = "CHAIN " THEN CHAIN ROUTING[7,999]
*
PARAMS = ROUTING
ROUTING = ROUTING<ONE,ONE,ONE>
DEL PARAMS<ONE,ONE,ONE>
INPARAMS = EMPTY
*
LOOP UNTIL PARAMS = EMPTY DO
IF OPSYS = "R" THEN DATA PARAMS<ONE,ONE,ONE> ELSE INPARAMS = INPARAMS:PARAMS<ONE,ONE,ONE>:AM
DEL PARAMS<ONE,ONE,ONE>
REPEAT
*
IF ROUTING[ONE,ONE] EQ "%" THEN CR.FLAG = TRUE; ROUTING = ROUTING[TWO,999]
*
LOOP TC = INDEX(ROUTING,"$",ONE) WHILE TC DO
ROUTING = ROUTING[ONE,TC - ONE]:PORT.KEY:ROUTING[TC + ONE,999]
REPEAT
*
LOOP TC = INDEX(ROUTING,"*",ONE) WHILE TC DO
TMP = ROUTING[TC,TWO]
TMP = TMP[TWO,ONE]
IF NOT(NUM(TMP)) THEN TMP = ONE
IF NOT(TMP) THEN TMP = ONE
ROUTING = ROUTING[ONE,TC - ONE]:FIELD(ACCT,".",TMP):ROUTING[TC + TWO,999]
REPEAT
*
TMP = ROUTING[LEN(ROUTING) - ONE,TWO]
IF TMP EQ ".?" THEN
ROUTING = ROUTING[ONE,LEN(ROUTING) - TWO]
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = EMPTY
LOCATE ROUTING IN SPECIAL.ROUTINES<ONE> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<TWO,LOC>
ROUTING = ROUTING:".":ROUTINE.SUFFIX
END
IF OPSYS NE "R" THEN
WRITE AM:ROUTING:AM:(DATE() + 100000)[TWO,5]:(TIME() + 100000)[TWO,5] ON AC.FILE,CALL.ID
END
*
BEGIN CASE
*
CASE OPSYS = "U"
* ULT ONLY
*
IF ROUTING NE "OFF" AND RSP[ONE,ONE] NE "." THEN
IF FIELD(ROUTING," ",TWO) = EMPTY THEN ROUTING = "RUN BP ":ROUTING
END
WRITEV ROUTING ON AC.FILE.D,ACC.ID,4
*
CASE OPSYS = "R"
* IF FIELD(ROUTING," ",TWO) = EMPTY THEN ROUTING = "RUN BP.OBJ ":ROUTING; * REV ONLY
*
CASE TRUE
TMP = FIELD(ROUTING," ",ONE)
IF TMP EQ "RUN" THEN
TMP = FIELD(ROUTING," ",TWO)
ROUTING = ROUTING[COL2() + ONE,9999]
END
*
END CASE
*
*
IF ROUTING[ONE,3] EQ "PC " THEN
EXECUTE ROUTING; * DON'T CHANGE
*
END ELSE
IF INPARAMS = EMPTY THEN
*
BEGIN CASE
*
CASE OPSYS = "M"
CHAIN ROUTING
*
CASE TRUE
EXECUTE ROUTING
*
END CASE
*
END ELSE
INPARAMS = INPARAMS[ONE,LEN(INPARAMS) - ONE]
*
BEGIN CASE
*
CASE OPSYS = "M"
DTEMP = INPARAMS
LOOP
DTCN = ZERO
LOOP DTCN = DTCN + 120 WHILE DTCN LT LEN(DTEMP<ONE>) DO
DTEMP<ONE> = DTEMP<ONE>[ONE,DTCN]:CHAR(31):CHAR(13):DTEMP<ONE>[DTCN + ONE,999]
REPEAT
DATA DTEMP<ONE>
DEL DTEMP<ONE,ZERO,ZERO>
WHILE LEN(DTEMP) DO REPEAT
CHAIN ROUTING
*
CASE TRUE
EXECUTE ROUTING, //IN. < INPARAMS
*
END CASE
*
END
*
END
*
*
REOPEN = EMPTY
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF CNT.FILE.OPEN THEN
READ RAMDISK.CNT FROM CNT.FILE,"RAMDISK.FILES" THEN
LOCATE ONE IN RAMDISK.CNT<TWO> SETTING LOC THEN
OPEN "LISTS" TO LISTS.FILE THEN
READ RAMDISK.REC FROM LISTS.FILE,"RAMDISK.FILES" THEN
CALL DOWNLOAD.RAMDISK(CNT.FILE,RAMDISK.CNT,LISTS.FILE,RAMDISK.REC)
REOPEN = ONE
END
END
END
END
END
*
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF REOPEN THEN GOTO NEXT.SYSTEM
*
*
* VERIFY DATE IF IT DOES NOT MATCH CONTROL (Don't worry if before 3:00 next morning!)
IF NOT(CNT.FILE.SW) THEN GOTO NEXT.MENU
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE,ONE>; CONTROL.DATE = CO.DATA<TWO,ONE,ONE>
IF CONTROL.DATE NE DATE() THEN IF NOT(DATE() EQ CONTROL.DATE + ONE AND TIME() LT 10000) THEN
IF NOT(CO.DATA<3>) THEN
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
END ELSE
PRINT @(ZERO,23):CLL:"CONTROL DATE OVERRIDE IS SET!":
RQM
END
CONTROL.DATE = CO.DATA<TWO>
END
*
IF CR.FLAG EQ TWO THEN
PRINT CLB:"Returning to menu . . . ":; RQM; RQM
END ELSE IF CR.FLAG THEN
PRINT CLB:"Enter <cr> to return to menu . . . ":; INPUT RSP:
END
*
GOTO NEXT.MENU
*
*
!
*
*
CHECK.DEFAULTS: *
AC = TWO
LOOP DEFAULT = DEFAULTS<AC> UNTIL DEFAULT<ONE,3> EQ RSP OR DEFAULT EQ EMPTY DO AC = AC + ONE REPEAT
IF DEFAULT EQ EMPTY THEN
ROUTING = "/":RSP
READV TEMP FROM MU.FILE,ROUTING,ONE ELSE ROUTING = MENU.NAME
END ELSE
ROUTING = DEFAULT<ONE,TWO>; DOC.NAME = DEFAULT<ONE,4>; IF DOC.NAME = EMPTY THEN DOC.NAME = ROUTING
END
RETURN
!
HELP.MESSAGE: *
CLS.COL = ZERO; CLS.ROW = TWO; GOSUB CLS.ROUTINE
IF NOT(GENERIC) OR RSP EQ "?" OR DOC.NAME EQ "?" THEN
EXEC.LINE = 'COPY PAR MASK (T,S)'
EXECUTE EXEC.LINE
PRINT CLB:"Enter <cr> to continue . . . ":; INPUT RSP:
END
DOC.NAME.F = FIELD(DOC.NAME," ",ONE)
IF DOC.NAME.F NE EMPTY THEN
DOC.NAME.I = FIELD(DOC.NAME," ",TWO)
IF DOC.NAME.I = EMPTY THEN DOC.NAME.I = DOC.NAME.F; DOC.NAME.F = "CABLE"
IF HELP EQ TWO THEN DOC.NAME.I = "?":DOC.NAME.I
* ULT ONLY
EXLN = 'RUNOFF HLP,':DOC.NAME.F:' ':DOC.NAME.I
* EXLN = 'RUNOFF HLP ':DOC.NAME.F:'.':DOC.NAME.I; * REV ONLY
EXECUTE EXLN
PRINT CLB:"Enter <cr> to return to menu . . . ":; INPUT RSP:
END
RETURN
$INCLUDE IBP CLS.ROUTINE
END
~MENU.HANDLER.LOG~
SUBROUTINE MENU.HANDLER.LOG(PAR.FILE,SEC.USER.ID,MENU.STACK,MENU.STAT.FUNC,STAT)
SUBROUTINE MENU.HANDLER.LOG(STD.FILE,SEC.USER$ITEM.ID,MAT STD,PAR.FILE,LCK.FILE,TMP1,TMP,CO.DATA,DISP.ONLY,AUTO.RUN,SYS.TST,REDISP,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
STD.SUBR.NAME = "MENU.HANDLER.LOG"
*
*
IF LEN(MENU.STACK) GT 300 THEN
MENU.STACK.REC = MENU.STACK[ONE,300]
*
***MENU.ID,MENU.ID.SEQ
**
WRITE MENU.STACK.REC ON PAR.FILE,MENU.STACK.ID:"*":MENU.STACK.ID.SEQ
*
MENU.STACK = MENU.STACK[301,9999]
*
END
*
RETURN
~MENU.INIT~
EXEC.VERB = ROUTE(NUM); EXEC.DESC = (SEC.USER.ID:" ":SEC.USER$DESC) "L#25":MENU(1) "L#25":MDESC(NUM) "L#25"
*PROGRAM:           MENU.HANDLER
*
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*                    DAVID STERN - AXION
*
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
* ALL
* SYMNGR SYMNTC SYS
* SWMNGR SEC DEV TCL
* SWINST PARAM PURGE MENUS
*
* MNGR BRMNGR OFMNGR ACCT CRDT ADJ CASH
* SLMNGR MKRTG SALES
* PLMNGR DSPTCH INV SCHED WKO
* DELETE ENTRY INQRY
*
* EFT AI LATE WKO INV
*
EQU VS TO "9205"
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP MENUS.VM.VAR.EQUATES
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
SYS.APPL.LOC = ONE
VERSION = VS; AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE; DISP.ONLY = FALSE
CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
EXEC.VERB = EMPTY; EXEC.DESC = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
CALL.ID = EMPTY; PORT.KEY = EMPTY; CLEAR.FLAG = FALSE
SEC.USER.ID = EMPTY; MENU.NAME = EMPTY; LAST.MENU = EMPTY
REOPEN.SW = FALSE; CR.FLAG = FALSE; RESET.SW = FALSE
NUM = ZERO; CNT.FILE.OPEN = FALSE; NUMC = FALSE; TC.FILL = " "
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = ONE
OLD.CL = EMPTY; OLD.LN = EMPTY; OLD.CL.LOC = ONE; OLD.LN.LOC = ONE
*
*: * Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
BREAK OFF
*
CALL COPYRIGHT
*
!!
*
! Perform initialization
*
* IF @USER0 EQ EMPTY THEN PERFORM "RUN BP.OBJ INITIALIZATION"; * REV ONLY
*
NEXT.SYSTEM: *
*
! Open files
*
OPEN "MENUS" TO MU.FILE ELSE PRINT CLB:"MENUS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
*
OPEN "COM" TO COM.FILE THEN COM.FILE.OPEN = TRUE ELSE
PRINT CLB:"COM file is missing!":BELL:; RQM; RQM; RQM
COM.FILE.OPEN = FALSE
END
*
OPEN "CNT" TO CNT.FILE THEN CNT.FILE.OPEN = TRUE ELSE
PRINT CLB:"CNT file is missing!":BELL:; RQM; RQM; RQM
CNT.FILE.OPEN = FALSE
END
*
OPEN "PAR" TO PAR.FILE ELSE
OPEN "LISTS" TO PAR.FILE ELSE PRINT CLB:"LISTS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
*
OPEN "LOCKS" TO LCK.FILE ELSE
PRINT CLB:"LOCKS file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
* LCK.FILE = 0; * REV ONLY
LCK.ITM = FALSE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*
! Set ACC file settings
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
! Set port control key
*
SEC.USER.ID = EMPTY; MENU.NAME = EMPTY
RESET.SW = FALSE; LAST.MENU = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
*
! Initialize tables
*
MAT PAR.MENU = EMPTY; MAT SEC.USER = EMPTY
DIM MENU(70),ROUTE(70),DOC(70),PRMPT(70),MDESC(70)
MAT MENU = EMPTY; MAT ROUTE = EMPTY; MAT DOC = EMPTY
MAT PRMPT = EMPTY; MAT MDESC = EMPTY
MENU(1) = "External User Control"
*
DIM STD(50); MAT STD = EMPTY
STD.FUNC = "READ"; STD.CONT = FALSE; STD.SUBR.NAME = EMPTY
*
! Read default menu and generic terminal type flag
*
READV DF.MENU.NAME FROM MU.FILE,"FIRST.MENU",ONE ELSE
DF.MENU.NAME = "/"
END
*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE 
IF OPSYS EQ "M" OR OPSYS EQ "U" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
*
! Load port control record
*
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID THEN
*
* SEC.USER.ID = PAR.MENU$USER
MENU.NAME = PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = PAR.MENU$LOCN<ONE,ONE>
OLD.CL.LOC = SCR.LOCN<ONE,ONE,ONE>
OLD.CL     = SCR.LOCN<ONE,ONE,TWO>
OLD.LN     = SCR.LOCN<ONE,ONE,3>
*
* Was this port ever active?
IF PAR.MENU$MENU.ID NE EMPTY THEN
*
* Pop last run off of menu stack
LOOP
DEL PAR.MENU$MENU.ID<ONE,ONE>
DEL PAR.MENU$LOCN<ONE,ONE>
WHILE LEN(PAR.MENU$MENU.ID) AND PAR.MENU$MENU.ID<ONE,ONE> EQ MENU.NAME DO SCR.LOCN = PAR.MENU$LOCN<ONE,ONE> REPEAT
*
* Delete stack item where duplicate exist
* back to duplicate
LOOP
LOCATE MENU.NAME IN PAR.MENU$MENU.ID<ONE> SETTING TMP ELSE TMP = FALSE
WHILE LEN(PAR.MENU$MENU.ID) AND TMP DO
TMP = DCOUNT(PAR.MENU$MENU.ID,VM)
DEL PAR.MENU$MENU.ID<ONE,TMP>
DEL PAR.MENU$LOCN<ONE,TMP>
REPEAT
*
* now put curr back on front
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
*
END; * of active port
*
* Set menu to be displayed
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = "Logon / Initialization"
* * Clear user data for this port
* PAR.MENU$GROUP = EMPTY
* PAR.MENU$USER = EMPTY
* PAR.MENU$USER.DT = EMPTY; PAR.MENU$USER.TM = EMPTY
*
END ELSE
*
! Port control record missing
*
MAT PAR.MENU = EMPTY
PAR.MENU$PORT.KEY = PORT.KEY
MENU.NAME = DF.MENU.NAME
PAR.MENU$MENU.ID = MENU.NAME
SCR.LOCN = ONE:SVM:ZERO:SVM:ZERO
PAR.MENU$LOCN = SCR.LOCN
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = "Logon / Initialization"
*
END; * of load port control
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Load operating system file, field, and attribute
*
IF ACC.ID EQ EMPTY THEN
*
ACC.ID = PAR.MENU$PORT.KEY
ACC.FILE.NAME = FIELD(ACC.ID,"@",TWO)
ACC.AM.DESC = FIELD(ACC.ID,"@",3) 
ACC.AM.DT   = FIELD(ACC.ID,"@",4)
ACC.AM.TM   = FIELD(ACC.ID,"@",5)
ACC.AM.VERB = FIELD(ACC.ID,"@",6)
ACC.ID = FIELD(ACC.ID,"@",ONE) 
IF ACC.FILE.NAME EQ EMPTY THEN ACC.FILE.NAME = "ACC"
IF ACC.ID EQ EMPTY THEN ACC.ID = CALL.ID 
*
TMP = FIELD(ACC.FILE.NAME," ",TWO)
IF LEN(TMP) THEN
ACC.FILE.NAME = TMP
ACC.FILE.DICT = FIELD(ACC.FILE.NAME," ",ONE)
END ELSE ACC.FILE.DICT = EMPTY
*
END ELSE
PAR.MENU$PORT.KEY = ACC.ID:"@":ACC.FILE.NAME:"@":ACC.AM.DESC:"@":ACC.AM.DT:"@":ACC.AM.TM:"@":ACC.AM.VERB
END
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:ACC.FILE.DICT:" ":ACC.FILE.NAME:" file is missing! Enter <cr> . . . ":BELL:; INPUT TMP.RSP:; STOP
END
*
! Set first response to current Menu attr 1
*
READV RSP FROM MU.FILE,MENU.NAME,ONE ELSE MENU.NAME = DF.MENU.NAME; SCR.LOCN = ONE:SVM:TWO:SVM:TWO
*
! Load company data
*
CO.DATA = "System not on disk":AM:DATE()
IF CNT.FILE.OPEN THEN
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CNT.FILE.OPEN = FALSE
END
CO.NAME = CO.DATA<ONE,ONE,ONE>; CO.DATE = CO.DATA<TWO,ONE,ONE>
DT = DATE(); TM = TIME()
IF PAR.MENU$USER EQ EMPTY THEN SEC.USER.ID = EMPTY
*
! Maintain special copyright info
*
IF SEC.USER.ID EQ EMPTY OR CO.DATA<3> OR (CO.DATE NE DT AND NOT(CO.DATE + ONE EQ DT AND TM LT 10000)) THEN
EXEC.DESC = (SEC.USER.ID:" ":"Operator ID") "L#25"
READ TMP FROM ACC.FILE,ACC.ID ELSE TMP = EMPTY
TMP<ACC.AM.DESC> = EXEC.DESC
TMP<ACC.AM.VERB> = EXEC.VERB
TMP<ACC.AM.DT>   = DATE()
TMP<ACC.AM.TM>   = TIME()
WRITE TMP ON ACC.FILE,ACC.ID
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
IF STAT THEN CHAIN "ZZOFF"
IF NOT(STAT) THEN
IF PAR.MENU$BF THEN BREAK ON
END
END
*
! Load control information
*
* System Test Flag
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
* User data
STD.FUNC = "READ"
GOSUB LOAD.STD.DATA; * : *
*
* Cursor keys
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":OPSYS ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE CURSOR.KEYS = EMPTY
END
*
* Function keys
IF CURSOR.KEYS<4> EQ EMPTY THEN
CURSOR.KEYS<4>  = "What?":VM:"How?":VM:"tcl":VM:"off":VM:"spool":VM:"compress":VM:"large":VM:"system"
CURSOR.KEYS<5> = "?":VM:"??":VM:"TCL":VM:"OFF":VM:"SPO":VM:"COM":VM:"REG":VM:"ACT"
END
*
!!
*
! Display the next menu
*
NEXT.MENU: *
*
*
CO.NAME = CO.DATA<ONE,ONE,ONE>; CO.DATE = CO.DATA<TWO,ONE,ONE>
DT = DATE(); TM = TIME()
*
* Check control date to maintain it (OK if before 03:00 the next mourning)
IF CO.DATE NE DT AND NOT(DT EQ CO.DATE + ONE AND TM LT 10000) THEN
IF NOT(CO.DATA<3>) THEN
PAR.MENU$USER = EMPTY; * clear user on date change
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
EXEC.DESC = (SEC.USER.ID:" ":"Control Date") "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL MAINT.CONTROL.DATE(CNT.FILE,CO.DATA)
GOTO NEXT.SYSTEM; * : *
END ELSE
PRINT CLB:"CONTROL DATE OVERRIDE IS SET!":BELL:
RQM
END
END
*
!
*
LOOP
*
HELP = ZERO
*
* Check control date reset on user
IF ((DATE() - PAR.MENU$USER.DT) * 86400) + (TIME() - PAR.MENU$USER.TM) GT 14400 THEN
PAR.MENU$USER = EMPTY
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
GOTO NEXT.SYSTEM; * : *
END
*
*
! Execution Verb
*
READ EXEC.VERB.ACCT FROM COM.FILE,ACCT:"@LOGON" ELSE
EXEC.VERB.ACCT = "Q":AM:ACCT:AM:LOGON.SCRIPT:AM:AM:EXEC.VERB:AM:
END
EXEC.VERB = <5>
EXEC.DESC = (SEC.USER.ID:" ":SEC.USER$DESC) "L#25":MENU(1) "L#25":EXEC.VERB.ACCT<6> "L#25"
EXEC.IN   = EXEC.VERB.ACCT<7>
EXEC.VERB.DEF = ACCT
*
! Execution Loop
*
LOOP
*
EXEC.VERB = EXEC.VERB.ACCT
*
*
WHILE EXEC.VERB EQ EMPTY DO
PRINT BELL:
EXEC.VERB = ACCT
REPEAT
*
!
*
IF MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE> AND RSP NE EMPTY THEN
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
SCR.LOCN = OLD.CL.LOC:SVM:OLD.CL:SVM:OLD.LN
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
END ELSE
PAR.MENU$LOCN<ONE,ONE> = SCR.LOCN
END
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
WHILE EXEC.VERB[ONE,ONE] EQ "/" DO
*
MENU.NAME = EXEC.VERB
*
REPEAT
*
!!
*
$INCLUDE IBP SYS.INCL.EXEC.STD.FUNC
*
!
*
UNLOCK: *
*
REOPEN.SW = EMPTY
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF CNT.FILE.OPEN THEN
READ RAMDISK.CNT FROM CNT.FILE,"RAMDISK.FILES" THEN
LOCATE ONE IN RAMDISK.CNT<TWO> SETTING LOC THEN
OPEN "LISTS" TO LISTS.FILE THEN
READ RAMDISK.REC FROM LISTS.FILE,"RAMDISK.FILES" THEN
EXEC.DESC = (SEC.USER.ID:" ":"Download Ram Disk") "L#25"
WRITEV EXEC.DESC ON ACC.FILE,ACC.ID,ACC.AM.DESC
CALL DOWNLOAD.RAMDISK(CNT.FILE,RAMDISK.CNT,LISTS.FILE,RAMDISK.REC)
REOPEN.SW = ONE
END
END
END
END
END
*
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF REOPEN.SW THEN GOTO NEXT.SYSTEM; * : *
*
IF RESET.SW THEN GOTO NEXT.SYSTEM; * : *
*
IF NOT(CNT.FILE.OPEN) THEN GOTO NEXT.MENU; * : *
*
GOTO NEXT.MENU; * : *
*
!
*
STOP
*
!
*
CHECK.DEFAULTS: *
*
LCK.STAT = FALSE
LOCATE "TCL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "MENUS" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "DEV" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "ALL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE LCK.STAT = TRUE
END
END
END
*
IF LCK.STAT THEN EXEC.VERB = MENU.NAME ELSE
*
AM.CN = TWO
LOOP DEFAULT = DEFAULTS<AM.CN> UNTIL DEFAULT<ONE,MENUS.VM$LABEL> EQ RSP OR DEFAULT EQ EMPTY DO AM.CN = AM.CN + ONE REPEAT
IF DEFAULT EQ EMPTY THEN
EXEC.VERB = "/":RSP
READV TEMP FROM MU.FILE,EXEC.VERB,ONE ELSE EXEC.VERB = MENU.NAME
END ELSE
EXEC.VERB = DEFAULT<ONE,MENUS.VM$VERB>; DOC.NAME = DEFAULT<ONE,MENUS.VM$HELP>; IF DOC.NAME EQ EMPTY THEN DOC.NAME = EXEC.VERB
END
*
END
*
RETURN
*
! Load STD DATA
*
LOAD.STD.DATA: *
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DATA
*
RETURN
*
! Standard System Call
*
ENTER.STD.SUBR: *
*
$INCLUDE IBP SYS.INCL.ENTER.STD.SUBR
*
RETURN
*
! Allow authorized entry into debug mode
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!!
*
! Help Features
*
HELP.MESSAGE: *
CLS.COL = ZERO; CLS.ROW = TWO; GOSUB CLS.ROUTINE; * : *
IF NOT(GENERIC) AND (EXEC.VERB EQ "?" OR DOC.NAME EQ "?") THEN
EXEC.VERB = 'COPY PAR MASK (T,S)'
PRINT @(ZERO,3):
EXECUTE EXEC.VERB
PRINT CLB:"Enter <cr> to continue with help . . . ":; INPUT TMP.RSP:
PRINT @(ZERO,ZERO):CLS:
END
DOC.NAME.F = FIELD(DOC.NAME," ",ONE)
IF DOC.NAME.F NE EMPTY THEN
DOC.NAME.I = FIELD(DOC.NAME," ",TWO)
IF DOC.NAME.I EQ EMPTY THEN DOC.NAME.I = DOC.NAME.F; DOC.NAME.F = "CABLE"
IF HELP EQ TWO THEN DOC.NAME.I = "?":DOC.NAME.I
* ULT ONLY
EXEC.VERB = 'RUNOFF HLP,':DOC.NAME.F:' ':DOC.NAME.I
* EXEC.VERB = 'RUNOFF HLP ':DOC.NAME.F:'.':DOC.NAME.I; * REV ONLY
PRINT @(ZERO,3):
EXECUTE EXEC.VERB
PRINT CLB:"Enter <cr> to return to menu . . . ":; INPUT TMP.RSP:
END
*
RETURN
*
! Clear screen
*
$INCLUDE IBP CLS.ROUTINE
*
! Load test data
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
*
END
~MENU.LISTU~
*PROGRAM:           MENU.LISTU
* AUTHOR:            DAVID HORSMAN - MACROSCOPE
* DESCRIPTION:       PLACE A LABEL FOR DISPLAY IN LISTU
* DATE WRITTEN:      5 MAR 91
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
NEXT.SYSTEM: *
*
INPUT RSP.INP:
*
* IF @USER0 EQ EMPTY THEN PERFORM "RUN BP.OBJ INITIALIZATION"; * REV ONLY
!
*
OPEN "MENUS" TO MU.FILE ELSE STOP
OPEN "PAR" TO PAR.FILE ELSE
OPEN "LISTS" TO PAR.FILE ELSE STOP
END
*
!
*
LAST.MENU = EMPTY
PORT.KEY = (PORT+1000) "R#3"
CALL.ID = "MENU.":PORT.KEY
IF OPSYS NE "R" THEN
IF OPSYS NE "U" THEN
OPEN "ACC" TO AC.FILE.D ELSE STOP
END ELSE
OPEN "DICT","ACC" TO AC.FILE ELSE STOP
END
END
*
!
*
DIM SCR.POSN(5); MAT SCR.POSN = EMPTY
* *
READV DF.MENU.NAME FROM MU.FILE,"FIRST.MENU",ONE THEN
READ GENERIC FROM PAR.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM PAR.FILE,"GENERIC" ELSE NULL
END
END ELSE
DF.MENU.NAME = "/"
END
*
!
*
MATREAD SCR.POSN FROM PAR.FILE,CALL.ID THEN
*
ACC.ID = SCR.POSN(ONE)
MENU.NAME = SCR.POSN(TWO)<ONE,ONE>
SCR.LOCN = SCR.POSN(3)<ONE,ONE>
*
** IF SCR.POSN(TWO) NE EMPTY THEN
** *
** LOOP
** DEL SCR.POSN(TWO)<ONE,ONE>
** DEL SCR.POSN(3)<ONE,ONE>
** WHILE LEN(SCR.POSN(TWO)) AND SCR.POSN(TWO)<ONE,ONE> EQ MENU.NAME DO SCR.LOCN = SCR.POSN(3)<ONE,ONE> REPEAT
** *
** LOOP
** LOCATE MENU.NAME IN SCR.POSN(TWO)<ONE> SETTING TMP ELSE TMP = FALSE
** WHILE LEN(SCR.POSN(TWO)) AND TMP DO
** TMP = DCOUNT(SCR.POSN(TWO),VM)
** DEL SCR.POSN(TWO)<ONE,TMP>
** DEL SCR.POSN(3)<ONE,TMP>
** REPEAT
** SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
** SCR.POSN(5) = "Logon / Initialization"
** *
** END
*
*
*
END ELSE
MAT SCR.POSN = EMPTY
CALL COPYRIGHT
ACC.ID = "MENU.":PORT.KEY
SCR.POSN(ONE) = ACC.ID
MENU.NAME = DF.MENU.NAME
SCR.POSN(TWO) = MENU.NAME
SCR.LOCN = ONE
SCR.POSN(3) = SCR.LOCN
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "Logon / Initialization"
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
END
*
!
*
*
** IF MENU.NAME NE EMPTY THEN
** IF MENU.NAME NE SCR.POSN(TWO)<ONE,ONE> AND RSP NE EMPTY THEN
** INS MENU.NAME BEFORE SCR.POSN(TWO)<ONE,ONE>
** INS SCR.LOCN BEFORE SCR.POSN(3)<ONE,ONE>
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV RSP.INP ON AC.FILE.D,ACC.ID,4
END
WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
END
** END
** SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
** SCR.POSN(5) = MENU.NAME
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
SCR.LOCN = ONE
** END
*
*
END
~MENU.PRINT~
*PROGRAM: MENU.PRINT 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND PRINT MENU
* DATE WRITTEN:      09 SEP 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "MENUS" TO MU.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
*
DIM MENU(100),LINES(24)
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = ""
CO.NAME = CO.NAME<1,1,1>
ASTERS = "* * * * * * * * * * "; ASTERS = ASTERS:ASTERS:ASTERS:ASTERS:"*  *"
!
NEXT.MENU: *
READNEXT MENU.NAME ELSE STOP
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE GOTO NEXT.MENU
*
MAT LINES = ""
LINES(1) = ("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20"
LINES(2) = ("Port: ":PORT) "L#15":(SPACE(25-LEN(MENU(1))/2+.5):MENU(1)) "L#50":OCONV(TIME(),"MTS") "R#15"
LINES(24) = SPACE(20):"Enter your choice:"
*
AC = 3; CL = 22; LN = 4
LOOP MENU.LINE = MENU(AC) UNTIL MENU.LINE = "" OR AC = 100 DO
IF MENU.LINE = ">" THEN CL = 2
AC = AC+1
REPEAT
MAX.AC = AC-1
*
NUM = 1
FOR AC = 3 TO MAX.AC
MENU.LINE = MENU(AC)
VALID = 1; VALID.ACCTS = MENU.LINE<1,4>
IF VALID.ACCTS # "" THEN LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN
TEXT = MENU.LINE<1,1>
IF TEXT = ">" THEN CL = 42; LN = 4 ELSE
IF TEXT[1,1] # "*" THEN
PRMPT = MENU.LINE<1,3>
IF PRMPT = "" THEN PRMPT = NUM
IF TEXT # "" THEN
IF LEN(LINES(LN)) < CL THEN LINES(LN) = LINES(LN):STR(" ",CL-LEN(LINES(LN)))
LINES(LN) = LINES(LN)[1,CL]:PRMPT "R#3":". ":TEXT:LINES(LN)[CL+LEN(TEXT)+6]
END
NUM = NUM+1
END ELSE IF TEXT # "*" THEN
IF LEN(LINES(LN)) < CL THEN LINES(LN) = LINES(LN):STR(" ",CL-LEN(LINES(LN)))
LINES(LN) = LINES(LN)[1,CL-2]:TEXT:LINES(LN)[CL+LEN(TEXT)-1]
END
END
LN = LN+1
END
NEXT AC
PRINTER ON
PRINT FF:TIMEDATE():CR:LF:CR:LF:ASTERS:CR:LF:"* ":SPACE(80):" *"
FOR LN = 1 TO 24; PRINT "* ":LINES(LN) "L#80":" *"; NEXT LN
PRINT "* ":SPACE(80):" *":CR:LF:ASTERS
PRINTER OFF
GOTO NEXT.MENU
END
~MINUTES.SUBR.CONV~
SUBROUTINE MINUTES.SUBR.CONV(TMP.TM,ORSLT)
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP MINUTES.INCL.CONV
*
RETURN
*
END
~MISC.PROCWRITE~
*PROGRAM: MISC.PROCWRITE 
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   15 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","SYS" TO BP.FILE ELSE STOP
*
PRINT "ENTER LIST NAME IN MD: ":
INPUT LIST.NAME
PRINT
PRINT "ENTER FILE NAME: ":
INPUT FILE.NAME
PRINT
*
PRINT
PRINT "ENTER PROC VERB: ":
INPUT PROC.VERB
*
PRINT
PRINT "USE FILE NAME (Y/N): ":
INPUT USE.FILE.NAME
*
PRINT
PRINT "ENTER OUTPUT PROCNAME (MISC.PROC):":
INPUT MISC.NAME
IF MISC.NAME EQ "" THEN MISC.NAME = "MISC.PROC"
IF USE.FILE.NAME NE "N" THEN USE.FILE.NAME = 1 ELSE USE.FILE.NAME = ""
*
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:"C":AM:"C":AM:"C     ":MISC.NAME:"C":AM:"C":AM
PROC1 = PROC1:"HDATE":AM:"P":AM:"O":AM:"HWHO":AM:"P":AM:"O":AM:"O":AM
*
*
*
LOOP
LOOP
PROGNAME = FILE.LIST<1>
WHILE FILE.LIST[1,1] EQ "*" DO FILE.LIST = DELETE(FILE.LIST,1,0,0) REPEAT
*
PRINT PROGNAME
WHILE FILE.LIST NE "" DO
*
PROC1 = PROC1:"C":AM:"C":AM:"O     ":PROGNAME:AM:"O":AM
PROC1 = PROC1:"H":PROC.VERB:" "
IF USE.FILE.NAME THEN PROC1 = PROC1:FILE.NAME:" "
PROC1 = PROC1:PROGNAME:AM:"P":AM
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
*PROC1 = PROC1:"C":AM:"C":AM:"HMSG PROGRAMS   COM-CAT STEP OF ":LIST.NAME:" IS DONE!!!":AM:"P":AM
*%%STD%%=PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"X":AM
*%%MDD%%=PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"RTN":AM
*
WRITE PROC1 ON MDI.FILE,MISC.NAME
WRITE PROC1 ON BP.FILE,MISC.NAME
*
STOP
END
*
~MOD11.DIGIT~
SUBROUTINE MOD11.DIGIT (ID,CD)
* PROGRAM:           MOD11.DIGIT
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       CALCULATES CHECK DIGIT
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
IF ID MATCHES "0N" AND LEN(ID) < 7 THEN TEMP = (ID+1000000)[2,6] ELSE CD = 0; RETURN
CD = TEMP[1,1]*8+TEMP[2,1]*7+TEMP[3,1]*6+TEMP[4,1]*5+TEMP[5,1]*4+TEMP[6,1]*3; CD = MOD(CD,11); IF CD = 10 THEN CD = 4
RETURN
END
~MODEL.CUSTOMIZE~
*PROGRAM: MODEL.CUSTOMIZE 
* AUTHOR:            BOB CONARROE
* DESCRIPTION:       USED TO CUSTOMIZE AN ACCOUNT SET UP BY INSTALL.KBIL
* DATE WRITTEN:      22 APR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
*
INPUT FLNAME
OPEN FLNAME TO FL ELSE PRINT "Can't open ":FLNAME:; INPUT RSP:; STOP
OPEN "MODEL.CNT" TO MODEL.CNT.FILE ELSE PRINT "Can't open MODEL.CNT":; INPUT RSP:; STOP
READ MODEL.CNT FROM MODEL.CNT.FILE, "INSTALL.KBIL" ELSE PRINT "Can't find INSTALL.KBIL":; INPUT RSP:; STOP
!
NXT: *
READNEXT ID ELSE STOP
READ ITM FROM FL, ID ELSE GOTO NXT
PRINT @(0,23):CLL:"customizing ":ID:
CTR = 1
LOOP
INDX = INDEX(ITM,"@",CTR)
WHILE INDX DO
XXX = ITM[INDX+1,3]
BEGIN CASE
CASE XXX = "AAA"; REPL = MODEL.CNT<1>; GOSUB REPL.STRING
CASE XXX = "ADS"; REPL = MODEL.CNT<2>; GOSUB REPL.STRING
CASE XXX = "PER"
TDT = OCONV(DATE(),"D2*")
REPL = FIELD(TDT,"*",3):FIELD(TDT,"*",1)
GOSUB REPL.STRING
CASE XXX = "TDT"; REPL = DATE(); GOSUB REPL.STRING
CASE XXX = "SSS"
DVD = ITM[INDX+4,6]
IF DVD[1,1] = "/" AND INDEX(DVD,",",1) > 0 THEN
DVD = FIELD(DVD,",",1)
XXX = XXX:DVD
DVD = DVD[2,99]
REPL = MODEL.CNT<3> / DVD + 1; REPL = FIELD(REPL:'.','.',1)
GOSUB PRIME.NUMBER
GOSUB REPL.STRING
END ELSE CTR = CTR+1
CASE 1; CTR = CTR+1
END CASE
REPEAT
WRITE ITM ON FL, ID
*
GOTO NXT
!
REPL.STRING: *
ITM = ITM[1,INDX-1]:REPL:ITM[INDX+LEN(XXX)+1,9999]
RETURN
!
PRIME.NUMBER: *
EXECUTE "PRIME", //IN. < REPL, //OUT. > EXOUT
EXOUT.ATTR = COUNT(EXOUT,AM)
LOOP UNTIL INDEX(EXOUT<EXOUT.ATTR>,'prime',1) DO EXOUT.ATTR = EXOUT.ATTR-1 REPEAT
EXOUT.FLD = 1
LOOP REPL = FIELD(EXOUT<EXOUT.ATTR>," ",EXOUT.FLD) UNTIL REPL MATCHES "0N" DO EXOUT.FLD = EXOUT.FLD+1 REPEAT
RETURN
!
END
~MOVE.DICTS~
*PROGRAM: MOVE.DICTS 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       MOVES DICT. ITEMS UNDER USER CONTROL
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Move.dicts - Moves dictionary items"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
100 * START
PRINT @(10,4):CLL:"Enter file name: ":
INPUT FILE.NAME:
IF FILE.NAME = "" THEN STOP
OPEN "DICT",FILE.NAME ELSE PRINT @(10,5):"File does not exist"; GOTO 100
*
ID.STRING = ""
EXECUTE "SSELECT DICT ":FILE.NAME:" BY NUM.ORDER"
LOOP READNEXT ID ELSE ID = "@" UNTIL ID = "@" DO
IF ID # "" THEN IF NUM(FIELD(ID,",",1)) THEN ID.STRING<-1> = ID
REPEAT
*
200 *
LOOP
PRINT @(10,5):CLS:"Enter current attribute number(s) (## or ##-##): ":
INPUT OLD.AMC:
IF OLD.AMC = "" THEN PRINT @(10,5):CLL:; GOTO 100
FIRST.AMC = FIELD(OLD.AMC,"-",1)
LAST.AMC = FIELD(OLD.AMC,"-",2); IF NOT(LAST.AMC) THEN LAST.AMC = FIRST.AMC
UNTIL FIRST.AMC MATCHES "0N" AND LAST.AMC MATCHES "0N" AND FIRST.AMC <= LAST.AMC DO PRINT BELL: REPEAT
*
LOOP
PRINT @(10,6):CLL:"Enter future attribute number (first no. if series): ":
INPUT NEW.AMC:
IF NEW.AMC = "" THEN GOTO 200
UNTIL NEW.AMC MATCHES "0N" DO PRINT BELL: REPEAT
*
PRINT @(10,8):"Okay to move the item(s) (<cr>/N)? ":
INPUT RSP:
IF NOT(RSP = "Y" OR RSP = "") THEN GOTO 200
*
INCREMENT = NEW.AMC-FIRST.AMC
IF INCREMENT < 0 THEN STEPPING = 1 ELSE
STEPPING = -1
TEMP = FIRST.AMC
FIRST.AMC = LAST.AMC
LAST.AMC = TEMP
END
*
FOR OLD.AMC = FIRST.AMC TO LAST.AMC STEP STEPPING
NEW.AMC = OLD.AMC+INCREMENT
LOC = 1
GOSUB 1000
NEXT OLD.AMC
GOTO 200
!
1000 * MOVE ITEMS
ID = ID.STRING<LOC>
IF ID = "" THEN RETURN
LOC = LOC+1
READ ITEM FROM ID ELSE GOTO 1000
POS = INDEX(ID,",",1)
IF POS THEN AMC = ID[1,POS-1] ELSE AMC = ID
IF AMC = OLD.AMC THEN
ITEM<2> = NEW.AMC
IF POS THEN NEW.ID = NEW.AMC:ID[POS,99] ELSE NEW.ID = NEW.AMC
WRITE ITEM ON NEW.ID
DELETE ID
ID.STRING<LOC-1> = NEW.ID
GOTO 1000
END
*
DYNAMIC = FIELD(ITEM<15>,"-",2)
IF DYNAMIC = "" THEN GOTO 1000
NEW.DYNAMIC = ""
POS = 1
LOOP
ASSOC = FIELD(DYNAMIC,"/",POS)
UNTIL ASSOC = "" DO
IF ASSOC = OLD.AMC THEN ASSOC = NEW.AMC
NEW.DYNAMIC = NEW.DYNAMIC:"/":ASSOC
POS = POS+1
REPEAT
NEW.DYNAMIC = NEW.DYNAMIC[2,99]
IF NEW.DYNAMIC = DYNAMIC THEN GOTO 1000
ITEM<15> = FIELD(ITEM<15>,"-",1):"-":NEW.DYNAMIC
WRITE ITEM ON ID
GOTO 1000
END
~MV.CONV~
*PROGRAM: MV.CONV 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT
PRINT "Enter file name (BP): ":
INPUT FILE.NAME
IF FILE.NAME = "" THEN FILE.NAME = "BP"
OPEN FILE.NAME TO INP.FILE ELSE STOP
*
PRINT
PRINT "Convert MV's (<cr>/N): ":
INPUT MVCONV.FLAG
IF MVCONV.FLAG NE "N" THEN MVCONV.FLAG = 1 ELSE MVCONV.FLAG = 0
*
*
PRINT
PRINT "Convert SV's (<cr>/N): ":
INPUT SVCONV.FLAG
IF SVCONV.FLAG NE "N" THEN SVCONV.FLAG = 1 ELSE SVCONV.FLAG = 0
*
IF NOT(SVCONV.FLAG OR MVCONV.FLAG) THEN STOP
*
LOOP
PRINT
PRINT "Is this a (D)ata or (P)rogram conversion: ":
INPUT CONV.TYPE
WHILE CONV.TYPE NE "D" AND CONV.TYPE NE "P" DO REPEAT
*
FIRST = 1
NAME.INP = ""
PRINT
LOOP
IF NOT(NAME.INP) THEN
READNEXT ID ELSE ID = "@"
IF ID = "@" AND FIRST THEN NAME.INP = 1
END ELSE ID = "@"
IF NAME.INP THEN
PRINT
PRINT "Enter ID: ":
INPUT ID
IF ID EQ "" OR ID EQ "END" OR ID EQ "KILL" THEN ID = "@"
END
FIRST = ""
WHILE ID NE "@" DO
PRINT ID:"   ":
READ ITEM FROM INP.FILE,ID THEN
IF MVCONV.FLAG THEN
MV.MAX = COUNT(ITEM,VM)
IF MV.MAX THEN
MV.CN = 0
LOOP
MV.CN = MV.CN +1
MV.LOC = INDEX(ITEM,VM,1)
WHILE MV.LOC DO
IF CONV.TYPE EQ "P" THEN
ITEM = ITEM[1,MV.LOC-1]:'":VM:"':ITEM[MV.LOC+1,99999]
END ELSE
ITEM = ITEM[1,MV.LOC-1]:CHAR(29):ITEM[MV.LOC+1,99999]
END
REPEAT
PRINT MV.CN "R#4":" ":
END
END
IF SVCONV.FLAG THEN
SV.MAX = COUNT(ITEM,SVM)
IF SV.MAX THEN
SV.CN = 0
LOOP
SV.CN = SV.CN +1
SV.LOC = INDEX(ITEM,SVM,1)
WHILE SV.LOC DO
IF CONV.TYPE EQ "P" THEN
ITEM = ITEM[1,SV.LOC-1]:'":SVM:"':ITEM[SV.LOC+1,99999]
END ELSE
ITEM = ITEM[1,SV.LOC-1]:CHAR(28):ITEM[SV.LOC+1,99999]
END
REPEAT
PRINT SV.CN "R#5":
END
END
WRITE ITEM ON INP.FILE,ID
END ELSE
PRINT @(0,23):CLL:BELL:"Item is missing: ":ID
END
PRINT
REPEAT
END
~OFF~
*PROGRAM: OFF 
*
CHAIN "OFF"
*
END
~PACK.NUMBER~
SUBROUTINE PACK.NUMBER(NUM.IN,NUM.OUT)
* PROGRAM:           PACK.NUMBER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       PACK A NUMBER IN HEX
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*SETTERM
!
$INCLUDE IBP SYS.INCL.PACK.NUMBER
*
*
RETURN
*
*
END
~PICK.TRANSFER~
*PROGRAM: PICK.TRANSFER 
*      
*AUTHOR: DAVID HORSMAN
*      
*COMPANY: AXION COMPUTER SOFTWARE LTD
*      
*DATE: 23 SEP 88
*      
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*      
$INCLUDE IBP STANDARD.CHARACTERS
*      
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
*# Open files
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP:; STOP
*      
*# Read program run control data
READ TRANS.PORT FROM PAR.FILE,"TRANSFER.PORT":PORT ELSE TRANS.PORT = "05"
*      
READ COMM.PARAM FROM PAR.FILE,"TRANSFER.QUIET":PORT ELSE
READ COMM.PARAM FROM PAR.FILE,"TRANSFER.QUIET" ELSE
CP = TEN; COMM.WAIT.QUIET = TEN
END
END
*
$INCLUDE IBP SYS.INCL.QUIET.LOAD
*
ERR.CN = CP<5>
IF NOT(NUM(ERR.CN)) THEN ERR.CN = ZERO
IF NOT(ERR.CN) THEN ERR.CN = 3
LOOP WHILE ERR.CN GE ERR.MAX AND ERR.CN GT TEN DO ERR.CN = ERR.CN - TEN REPEAT
ERR.CN.ALL = CP<9>
ERR.CN.ALL = ZERO
ERR.CN.TOTAL = CP<TEN>
IF NOT(NUM(ERR.CN.TOTAL)) THEN ERR.CN.TOTAL = ZERO
IF NOT(NUM(ERR.CN.ALL)) THEN ERR.CN.ALL = ZERO
ERR.CN.ARRAY = CP<17>
IF ERR.CN LT ERR.LOW THEN ERR.CN = ERR.LOW
IF ERR.CN - 5 GT ERR.LOW THEN ERR.CN = ERR.CN - 5
*      
TP = EMPTY 
IF TRANS.PORT EQ PORT THEN
READ MAIN.FLAG FROM PAR.FILE,"TRANSFER.PORT.TYPE":PORT THEN
IF NUM(MAIN.FLAG) THEN
IF MAIN.FLAG THEN
MAIN.FLAG = MASTER
END ELSE MAIN.FLAG = SLAVE
END
END ELSE MAIN.FLAG = SLAVE
END ELSE MAIN.FLAG = ENTRY
IF MAIN.FLAG = SLAVE AND TRANS.PORT NE PORT THEN MAIN.FLAG = ENTRY
*
STAT = FALSE; SYSTEM.NAME = EMPTY
CALL SYS.SUBR.SYSTEM.NAME(PAR.FILE,SYSTEM.NAME,STAT)
IF STAT THEN PRINT BELL:"SYSTEM NAME IS MISSING":; STOP
*
*# Load program control variables
ACK.RSP = EMPTY; CHK.ID = "@"
DIR.FLAG = EMPTY; IN.FILE.NAME  = EMPTY; OUT.FILE.NAME = EMPTY; IN.ITEM.NAME  = EMPTY
OUT.ITEM.NAME = EMPTY; OPTIONS = EMPTY; LIST.NAME = EMPTY; ACCT.NAME = EMPTY
ACCT.PASS = EMPTY; SYS.NAME = SYSTEM.NAME; COMM.SYS.NAME = EMPTY; LIST.SOURCE = EMPTY
DONE.FLAG = FALSE; STAT = FALSE; TP.CN = ZERO; ABORT.FLAG = FALSE
COMM.INIT = FALSE; COMM.ERROR = FALSE; COMM.STARTUP = FALSE; COMM.SHUTDOWN = FALSE
TRANS.FIRST = FALSE; TP.MAX = HI.NUM; TRANS.NUMBER = ZERO; ITEM = EMPTY
*
*
MD.FILE.NAME = "MD"; DICT.NAME = EMPTY; DICT.BASE = ZERO; DICT.MOD = ZERO; DICT.SEP = ZERO; FILE.MOD = ZERO; FILE.SEP = ZERO; FILE.OPT = "MC,S,?"; FILE.NAME = EMPTY; FILE.BASE = ZERO; STAT = ZERO; PROG.DEBUG = FALSE
*
$INCLUDE IBP SYS.INCL.PICKTR.HEADER
*
RECV.TRANSFER: *#
*      
IF MAIN.FLAG NE ENTRY THEN ECHO OFF
*
LOOP
*
COMM.INIT = FALSE; COMM.ERROR = FALSE; COMM.STARTUP = FALSE; COMM.SHUTDOWN = FALSE
*
TRANS.NUMBER = ZERO
*
IF MAIN.FLAG EQ SLAVE THEN TP.MAX = HI.NUM
*
IF NOT(COMM.ERROR OR STAT) AND MAIN.FLAG EQ MASTER THEN
LOOP
$INCLUDE IBP SYS.INCL.ABORT.CHECK
IF NOT(STAT) THEN
$INCLUDE IBP SYS.INCL.SCHED.CHECK
IF SCHED.OK THEN
TRANS.SUF = "NEXT"
GOSUB PARAM.READ
ITEM = EMPTY
END ELSE
DONE.FLAG = UNAVAIL.SCHED
END
END ELSE IF STAT = LOGOFF.COMMAND OR STAT = ABORT.RECVD THEN DONE.FLAG = STAT
WHILE NOT(STAT) AND (DONE.FLAG = ABORT.PRESENT OR DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED) DO
EXECUTE "SLEEP ":COMM.WAIT.MAX
REPEAT
TP.MAX = DCOUNT(TP,AM) - ONE
IF TP.MAX LE ONE THEN TP.MAX = ONE
ACCT.NAME = "#?#"
END
*      
TRANS.ALL.OK = TRUE
*
IF NOT(STAT) THEN
*
FROM.LIST = FALSE; LIST.CN = ZERO; LIST.SCAN = FALSE; SCAN.CONT = TRUE
*      
LOOP
*
LOOP 
*# Increment item counter
IF NOT(FROM.LIST) THEN TP.CN = TP.CN + ONE
*      
IF NOT(SYSTEM(ELEVEN) LE 3) AND MAIN.FLAG EQ ENTRY THEN
IF TP.CN EQ ONE THEN
*PAGE
END
*ITEM
END
*
*# Are we finished yet?
IF MAIN.FLAG EQ ENTRY THEN
IF NOT(LEN(TP<TP.CN+ONE>)) THEN SCAN.CONT = FALSE
END ELSE
IF NOT(TP<TP.CN+ONE,12>) THEN SCAN.CONT = FALSE
END
*
WHILE NOT(FROM.LIST) AND TP.CN LE TP.MAX AND SCAN.CONT DO REPEAT
*      
IF NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED) AND MAIN.FLAG EQ MASTER OR MAIN.FLAG EQ SLAVE THEN
*      
*COMM.WAIT.ERROR = EMPTY
*COMM.WAIT.KEY = EMPTY
*CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,COMM.WAIT.KEY,COMM.WAIT.QUIET,COMM.WAIT.MAX,COMM.WAIT.ERROR,COMM.WAIT.PAUSE,COMM.WAIT.CLEAR)
*IF COMM.WAIT.ERROR THEN STAT = WAIT.ERROR
*INPUTCLEAR
**      
*# Loop to transmit control parameters
LOOP
*
IF MAIN.FLAG EQ MASTER THEN
*      
 IN.FILE.NAME = TP<TP.CN+ONE,ONE>
OUT.FILE.NAME = TP<TP.CN+ONE,TWO>
 IN.ITEM.NAME = TP<TP.CN+ONE,3>
OUT.ITEM.NAME = TP<TP.CN+ONE,4>
     OPTIONS  = TP<TP.CN+ONE,5>
     DIR.FLAG = TP<TP.CN+ONE,6>
     ITEM = EMPTY
*      
IF NUM(DIR.FLAG) THEN
IF NOT(DIR.FLAG) AND LEN(DIR.FLAG) THEN
DIR.FLAG = DIN
END ELSE
DIR.FLAG = DOUT
END
END ELSE IF DIR.FLAG NE DIN AND DIR.FLAG NE DOUT THEN
DIR.FLAG = DOUT
END
*      
    LIST.NAME = TP<TP.CN+ONE,7>
*      
*# Perform port initialization if needed
*      
IF ((ACCT.NAME NE TP<TP.CN+ONE,8,ONE> AND TP<TP.CN+ONE,8,ONE> NE EMPTY) OR (TP.CN EQ ONE AND NOT(FROM.LIST))) AND TP.CN LE TP.MAX THEN
    ACCT.NAME = TP<TP.CN+ONE,8>
    ACCT.PASS = EMPTY
IF ACCT.NAME EQ EMPTY THEN
    ACCT.NAME = WHO
    ACCT.NAME = FIELD(ACCT.NAME," ",TWO)
    ACCT.PASS = "AXION"
END
IF ACCT.NAME<ONE,ONE,TWO> NE EMPTY THEN
    ACCT.PASS = ACCT.NAME<ONE,ONE,TWO>
    ACCT.NAME = ACCT.NAME<ONE,ONE,ONE>
END
*# Load System name
IF TP<TP.CN+ONE,9,ONE> NE EMPTY THEN
SYS.NAME = TP<TP.CN+ONE,9,ONE>
COMM.SYS.NAME = SYS.NAME
END
*      
*# Perform end of processing script if needed
*# plus additional processing for hung port
*
COMM.WAIT.ERROR = EMPTY
COMM.WAIT.KEY   = "PICK.TRANSFER@SCRIPT@":SYS.NAME:"@":ACCT.NAME:"@DONE"
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,COMM.WAIT.KEY,COMM.WAIT.QUIET,COMM.WAIT.MAX,COMM.WAIT.ERROR,COMM.WAIT.PAUSE,COMM.WAIT.CLEAR)
IF COMM.WAIT.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
*      
*# Perform port initialization if needed
*
*# Wait for line to go quiet
*      
COMM.WAIT.ERROR = EMPTY
COMM.WAIT.KEY   = EMPTY
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,COMM.WAIT.KEY,COMM.WAIT.QUIET,COMM.WAIT.MAX,COMM.WAIT.ERROR,COMM.WAIT.PAUSE,COMM.WAIT.CLEAR)
IF COMM.WAIT.ERROR THEN STAT = WAIT.ERROR
*      
*# Logon the account now
*
IF NOT(STAT OR DONE.FLAG) THEN
*
RQM
LINE.PACKET =  CR; IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
*
LINE.PACKET =  CR; IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
*
RQM
INPUTCLEAR
LINE.PACKET =  ACCT.NAME:CR; IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
*
IF ACCT.PASS NE EMPTY THEN
LINE.PACKET =  ACCT.PASS:CR; IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
*
LINE.PACKET =  CR; IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
RQM
END
*
*# Perform script file processing
*# This is releated to the system and account
COMM.WAIT.ERROR = EMPTY
COMM.WAIT.KEY   = "PICK.TRANSFER@SCRIPT@":SYS.NAME:"@":ACCT.NAME
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,COMM.WAIT.KEY,COMM.WAIT.QUIET,COMM.WAIT.MAX,COMM.WAIT.ERROR,COMM.WAIT.PAUSE,COMM.WAIT.CLEAR)
IF COMM.WAIT.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
*      
COMM.INIT = FALSE
*
END; *# of initialize if no error
*
END; *# of initialize or new account
*      
COMM.SYS.NAME = TP<TP.CN+ONE,9,ONE>
     FILE.OPT = TP<TP.CN+ONE,9,TWO>
     DICT.MOD = TP<TP.CN+ONE,9,3>
     DICT.SEP = TP<TP.CN+ONE,9,4>
     FILE.MOD = TP<TP.CN+ONE,9,5>
     FILE.SEP = TP<TP.CN+ONE,9,6>
     DICT.BASE = ZERO; FILE.BASE = ZERO
*
  LIST.SOURCE = TP<TP.CN+ONE,TEN>
    ITEM.DATE = TP<TP.CN+ONE,ELEVEN,ONE>
    LIST.SCAN = FIELD(ITEM.DATE,"*",8)
    IF NOT(NUM(LIST.SCAN)) THEN LIST.SCAN = TRUE
    IF NOT(LIST.SCAN) THEN LIST.SCAN = TRUE
    ITEM.SENT = TP<TP.CN+ONE,12>
END; *# of MASTER
*
IF NOT(COMM.ERROR OR STAT) AND NOT(COMM.INIT) AND MAIN.FLAG NE ENTRY THEN
*
IF NOT(COMM.SYNC) THEN
COMM.STARTUP = TRUE
END ELSE
COMM.STARTUP = FALSE
LOOP
IF MAIN.FLAG EQ MASTER THEN
LINE.PACKET = ESC:STB:"STARTUP":CR:NUL
END ELSE
IF NOT(COMM.STARTUP) THEN
LINE.PACKET = ESC:STB:"?STARTUP":CR:NUL
END ELSE
LINE.PACKET = ESC:STB:"YSTARTUP":CR:NUL
END
END
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
IF ACK.RSP NE "GO" THEN GOSUB ACK.RSP.INPUT ELSE COMM.STARTUP = TRUE
IF VALID.PKT AND MAIN.FLAG EQ MASTER AND ACK.RSP EQ "YSTARTUP" THEN COMM.STARTUP = TRUE
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERROR.ABORT
UNTIL STAT OR COMM.STARTUP DO
IF VALID.PKT AND MAIN.FLAG EQ SLAVE AND ACK.RSP EQ "STARTUP" THEN COMM.STARTUP = TRUE 
ERR.CN = ERR.CN + ONE 
REPEAT
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
END; *# of COMM.SYNC
IF NOT(COMM.INIT) THEN COMM.INIT = TRUE 
*
END; *# of ne ENTRY
*      
$INCLUDE IBP SYS.INCL.ABORT.CHECK
*
IF MAIN.FLAG EQ MASTER AND NOT(FROM.LIST) THEN
*
ITEM<-ONE> =  COMMAND:"INIT"
*      
IF DONE.FLAG OR (TP.CN GT TP.MAX AND MAIN.FLAG EQ MASTER) THEN
ITEM<-ONE> = COMMAND:"DONE"
DONE.FLAG = SHUTDOWN.DONE
END ELSE
IF STAT THEN
ITEM<-ONE> = COMMAND:"ERROR?":STAT
END
*
ITEM.TYPE = ONE 
ITEM<-ONE> = COMMAND:"ITEM.TYPE"
ITEM<-ONE> = ITEM.TYPE; ITEM<-ONE> = NULL.FLAG
*
ITEM<-ONE> =  COMMAND:"TDIR"
IF DIR.FLAG EQ DIN THEN
ITEM<-ONE> =  DOUT
END ELSE
ITEM<-ONE> =  DIN
END
*      
ITEM<-ONE> =  COMMAND:"FNAM"
ITEM<-ONE> =  OUT.FILE.NAME
ITEM<-ONE> =  IN.FILE.NAME; ITEM<-ONE> = NULL.FLAG; ITEM<-ONE> = NULL.FLAG
*      
ITEM<-ONE> =  COMMAND:"INAM"
ITEM<-ONE> =  OUT.ITEM.NAME
ITEM<-ONE> =  OUT.ITEM.NAME; ITEM<-ONE> = NULL.FLAG; ITEM<-ONE> = NULL.FLAG
*      
ITEM<-ONE> =  COMMAND:"OPTN"
ITEM<-ONE> =  OPTIONS; ITEM<-ONE> = NULL.FLAG
*
ITEM<-ONE> = COMMAND:"LIST.CN"
ITEM<-ONE> = LIST.CN; ITEM<-ONE> = NULL.FLAG
*
ITEM<-ONE> = COMMAND:"LIST.SCAN"
ITEM<-ONE> = LIST.SCAN; ITEM<-ONE> = NULL.FLAG
*
ITEM<-ONE> =  COMMAND:"SRCE"
TEMP = ABS(LIST.SOURCE-ONE)
ITEM<-ONE> =  TEMP; ITEM<-ONE> = NULL.FLAG
*      
ITEM<-ONE> =  COMMAND:"LIST"
ITEM<-ONE> =  LIST.NAME; ITEM<-ONE> = NULL.FLAG
IF NOT(LEN(LIST.NAME)) THEN LIST.FLAG = FALSE; FROM.LIST = FALSE; LIST.SCAN = FALSE ELSE
LIST.FLAG = TRUE 
IF LIST.SOURCE THEN
IF NOT(FROM.LIST) THEN
IF COUNT(LIST.NAME," ") THEN
EXEC.VERB = LIST.NAME
END ELSE IF LIST.NAME EQ "*" OR LIST.NAME EQ "ALL" THEN
EXEC.VERB = "SSELECT ":IN.FILE.NAME
END ELSE
EXEC.VERB = "GET-LIST ":LIST.NAME
END
EXECUTE EXEC.VERB, //OUT. > EXEC.RSP
CP<20> = EXEC.RSP
LIST.CN = ZERO
END; *# of NOT(FROM.LIST)
END; *# of LIST.SOURCE
FROM.LIST = TRUE 
END; *# of LEN(LIST.NAME)
*      
ITEM<-ONE> =  COMMAND:"ACCT"
ITEM<-ONE> =  ACCT.NAME; ITEM<-ONE> = NULL.FLAG
*      
ITEM<-ONE> =  COMMAND:"SYST"
ITEM<-ONE> =  SYS.NAME:"#":FILE.OPT:"#":DICT.MOD:"#":DICT.SEP:"#":FILE.MOD:"#":FILE.SEP
ITEM<-ONE> = NULL.FLAG
*      
ITEM<-ONE> = COMMAND:"TP.MAX"
ITEM<-ONE> = TP.MAX; ITEM<-ONE> = NULL.FLAG
*
ITEM<-ONE> = COMMAND:"ERR.CN"
ITEM<-ONE> = ERR.CN; ITEM<-ONE> = NULL.FLAG
*
END; *# of not(DONE)
*
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
INIT.FLAG = TRUE; CDIR.FLAG = TRUE; FILE.FLAG = TRUE; ITEM.FLAG = TRUE 
OPTN.FLAG = TRUE; ACCT.FLAG = TRUE; SYST.FLAG = TRUE
SRCE.FLAG = TRUE
*      
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DOUT,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,COMM.WAIT.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.DELAY,ERR.OFFSET,ERR.CHOKE)
*      
*#  MAIN.FLAG = SLAVE
*      
END ELSE IF MAIN.FLAG EQ SLAVE AND NOT(FROM.LIST) THEN
*      
INIT.FLAG = FALSE; CDIR.FLAG = FALSE; FILE.FLAG = FALSE; ITEM.FLAG = FALSE
OPTN.FLAG = FALSE; LIST.FLAG = FALSE; ACCT.FLAG = FALSE; SYST.FLAG = FALSE
SRCE.FLAG = FALSE; ITEM = EMPTY
*      
MD.FILE.NAME = "MD"; DICT.NAME = EMPTY; DICT.BASE = ZERO; DICT.MOD = ZERO; DICT.SEP = ZERO; FILE.MOD = ZERO; FILE.SEP = ZERO; FILE.OPT = "MC,S,?,QC"; FILE.NAME = EMPTY; FILE.BASE = ZERO; STAT = ZERO; PROG.DEBUG = FALSE
*
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
ITEM.TYPE = ONE 
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIN,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,COMM.WAIT.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.DELAY,ERR.OFFSET,ERR.CHOKE)
*      
CNTR.FLAG = TRUE 
GOSUB COMMAND.PROCESS
*      
END; *# of MAIN.FLAG EQ SLAVE
*
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
*      
IF FROM.LIST THEN
ITEM = EMPTY
LIST.CN = LIST.CN + ONE 
*      
IF LIST.SOURCE THEN
*      
ITEM.TYPE = TWO
*
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERROR.ABORT
IF STAT THEN
ITEM<-ONE> = COMMAND:"ERROR?":STAT
END
*
ITEM<-ONE> = COMMAND:"ITEM.TYPE"
ITEM<-ONE> = ITEM.TYPE; ITEM<-ONE> = NULL.FLAG
*
LOOP
READNEXT ID ELSE
FROM.LIST = FALSE
ID = EMPTY
ITEM<-ONE> = COMMAND:"END.LIST"
END
UNTIL NOT(FROM.LIST) OR LIST.CN GE LIST.SCAN DO LIST.CN = LIST.CN + ONE REPEAT
*      
IF FROM.LIST THEN
IN.ITEM.NAME = ID; OUT.ITEM.NAME = ID
ITEM<-ONE> = COMMAND:"INAM"
ITEM<-ONE> = IN.ITEM.NAME
ITEM<-ONE> = OUT.ITEM.NAME; ITEM<-ONE> = NULL.FLAG; ITEM<-ONE> = NULL.FLAG
*
ITEM<-ONE> = COMMAND:"LIST.CN"
ITEM<-ONE> = LIST.CN; ITEM<-ONE> = NULL.FLAG; ISIZE = LEN(ITEM)
*
END
*      
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DOUT,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,COMM.WAIT.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.DELAY,ERR.OFFSET,ERR.CHOKE)
IF STAT AND STAT NE LIST.FINISHED THEN TRANS.ALL.OK = FALSE
*      
END ELSE
*      
CN = ZERO; MAX = HI.NUM; ITEM.TYPE = TWO; ISIZE = HI.NUM
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIN,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,COMM.WAIT.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.DELAY,ERR.OFFSET,ERR.CHOKE)
IF STAT AND STAT NE LIST.FINISHED THEN TRANS.ALL.OK = FALSE
*      
CNTR.FLAG = TRUE 
GOSUB COMMAND.PROCESS
*      
END; *# of LIST.SOURCE
*      
IF NOT(FROM.LIST) THEN STAT = LIST.FINISHED; LIST.CN = LIST.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
*
END; *# of FROM.LIST
*      
*# Loopback for parameter input
WHILE NOT(DONE.FLAG OR STAT) AND NOT(INIT.FLAG AND CDIR.FLAG AND (ITEM.FLAG OR LIST.FLAG OR FROM.LIST) AND FILE.FLAG AND OPTN.FLAG) DO REPEAT
*      
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
END; *# of MAIN.FLAG EQ MASTER OR SLAVE
*      
*#  MAIN.FLAG EQ ENTRY
IF MAIN.FLAG EQ ENTRY THEN
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
PRINT
PRINT
PRINT "Enter item name: ":
LOOP
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "LIST" OR RSP EQ "*" OR RSP EQ "ALL" THEN
PRINT
PRINT "Enter list name: ":
IF RSP EQ "*" OR RSP EQ "ALL" THEN LIST.NAME = "*" ELSE INPUT LIST.NAME
LOOP TC = LIST.NAME[ONE,ONE] WHILE LEN(LIST.NAME) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO LIST.NAME = LIST.NAME[TWO,HI.NUM] REPEAT
IF LIST.NAME EQ "KILL" THEN ABORT
IF LIST.NAME EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF LIST.NAME[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
PRINT
PRINT "On this system (Y/N)? ":
INPUT YES.NO
IF YES.NO[ONE,ONE] EQ "Y" OR YES.NO[ONE,ONE] EQ "y" OR YES.NO = EMPTY THEN LIST.SOURCE = TRUE ELSE LIST.SOURCE = FALSE
END ELSE
LIST.SOURCE = EMPTY; LIST.NAME = EMPTY
END
WHILE NOT(DONE.FLAG) AND NOT(LEN(RSP)) OR SYSTEM(ELEVEN) GT 3 DO REPEAT
*
IN.ITEM.NAME = RSP
PRINT
*
IF NOT(DONE.FLAG OR LEN(LIST.NAME) OR STAT) THEN
PRINT "Enter output item name (":IN.ITEM.NAME:"): ":
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = IN.ITEM.NAME ELSE OUT.FILE.NAME = EMPTY
*
IF OUT.FILE.NAME NE IN.FILE.NAME THEN
IF NOT(LEN(OUT.FILE.NAME)) THEN OUT.FILE.NAME = IN.FILE.NAME
PRINT
PRINT "Enter output file name (":OUT.FILE.NAME:"): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = OUT.FILE.NAME
* OUT.FILE.NAME = IN.FILE.NAME
END
OUT.ITEM.NAME = RSP
END; *# of not done
*
MAX = 0
ISIZE = 0
*      
END; *# of MAIN.FLAG EQ ENTRY
*      
IF NOT(COMM.ERROR OR DONE.FLAG OR STAT) THEN
*      
IF MAIN.FLAG NE ENTRY THEN
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
*      
IF DIR.FLAG EQ DOUT THEN
FILE.NAME = IN.FILE.NAME
ITEM.NAME = IN.ITEM.NAME
END ELSE
*      
*#  DIR.FLAG EQ DIN
FILE.NAME = OUT.FILE.NAME
ITEM.NAME = OUT.ITEM.NAME
END
*
ITEM = EMPTY
*      
IF NOT(STAT) THEN
*
IF NOT(NUM(FILE.MOD)) THEN FILE.MOD = ZERO
IF NOT(NUM(DICT.MOD)) THEN DICT.MOD = ZERO
IF NOT(NUM(FILE.BASE)) THEN FILE.BASE = ZERO
IF NOT(NUM(DICT.BASE)) THEN DICT.BASE = ZERO
IF NOT(FILE.MOD OR DICT.MOD OR DICT.BASE OR FILE.BASE) OR DIR.FLAG EQ DIN THEN
CFILE.NAME = FILE.NAME
*
MD.FILE.NAME = "MD"; DICT.NAME = CFILE.NAME
*; DICT.BASE = ZERO; DICT.MOD = ZERO; DICT.SEP = ZERO; FILE.MOD = ZERO; FILE.SEP = ZERO; FILE.NAME = CFILE.NAME; FILE.BASE = ZERO; STAT = ZERO; PROG.DEBUG = FALSE
*
CALL SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,FILE.OPT,CFILE.NAME,FILE.BASE,STAT,PROG.DEBUG)
*
END
*PRINT BELL:; INPUT POP
*
OPEN FILE.NAME TO TRF.FILE ELSE
ITEM<-ONE> = COMMAND:"ERROR?":FILE.NAME:" file missing?"
STAT = TWO
END
*      
IF NOT(STAT) THEN
*
READ ITEM FROM TRF.FILE,ITEM.NAME THEN
ITEM.ON.FILE = TRUE; ITEM.A1 = ITEM<ONE>; IF LEN(ITEM.A1) EQ TWO THEN ITEM.A1 = ITEM.A1[ONE,ONE]
END ELSE
ITEM<-ONE> = COMMAND:"ERROR?":ITEM.NAME:" item missing!"
ITEM.ON.FILE = FALSE; ITEM.A1 = EMPTY
END
*
END ELSE
ITEM<-ONE> = COMMAND:"ERROR?":ITEM.NAME:" was not read from ":FILE.NAME:"!"
ITEM.ON.FILE = FALSE; ITEM.A1 = EMPTY
END
*
IF DIR.FLAG EQ DOUT THEN
*
IF NOT(ITEM.ON.FILE) THEN STAT = ITEM.MISSING ELSE
IF ITEM.A1 EQ "Q" OR ITEM.A1 EQ "D" THEN 
STAT = FPOINTER.TR.ERROR
ITEM<ONE> = "**":ITEM<ONE>:"**"
END
END
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
*
END ELSE
IF ITEM.ON.FILE THEN
IF ITEM.A1 EQ "Q" OR ITEM.A1 EQ "D" THEN STAT = FPOINTER.OV.ERROR
IF NOT(INDEX(OPTIONS,"O",ONE)) THEN STAT = ITEM.OV.ERROR
IF INDEX(OPTIONS,"N",ONE) THEN STAT = ITEM.NEW.ERROR
END ELSE
IF INDEX(OPTIONS,"E",ONE) THEN STAT = ITEM.OV.RQRD.ERROR
END
CN = ZERO; MAX = HI.NUM; ISIZE = HI.NUM; ITEM = EMPTY
END; *# OF DIR.FLAG
*
ITEM.TYPE = 3
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIR.FLAG,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,COMM.WAIT.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.DELAY,ERR.OFFSET,ERR.CHOKE)
*      
*#  DIR.FLAG EQ DIN
IF DIR.FLAG EQ DIN AND NOT(STAT) THEN
*
IF ITEM[ONE,LEN(COMMAND)] EQ COMMAND THEN CNTR.FLAG = FALSE; GOSUB COMMAND.PROCESS
*
IF INDEX(OPTIONS,"A",ONE) THEN
READ TMP FROM TRF.FILE,ITEM.NAME ELSE TMP = EMPTY
IF LEN(TMP) + LEN(ITEM) GT 32250 THEN STAT = MAX.ITEM.SIZE ELSE ITEM = TMP:AM:ITEM
TMP = EMPTY
END; *# of "A"
*
ITEM.A1 = ITEM<ONE>; IF LEN(ITEM.A1) EQ TWO THEN ITEM.A1 = ITEM.A1[ONE,ONE]
IF ITEM.A1 EQ "Q" OR ITEM.A1 EQ "D" THEN 
STAT = FPOINTER.TR.ERROR
ITEM<ONE> = "**":ITEM<ONE>:"**"
END
*
IF NOT(STAT) OR STAT EQ FPOINTER.TR.ERROR THEN 
WRITE ITEM ON TRF.FILE,ITEM.NAME
END
*
* DIR EQ DOUT
END ELSE IF DIR.FLAG EQ DOUT AND NOT(STAT) THEN
IF INDEX(OPTIONS,"D",ONE) THEN DELETE TRF.FILE,ITEM.NAME
END; *# of DIR DIN DOUT
END; *# of not(STAT)
*
END; *# of ne ENTRY
*
END; *# of not finished or error
*      
*PRINT BELL; PRINT TP<TP.CN+ONE>
*PRINT BELL; PRINT TP.CN:" _ ":TP.MAX:" _ ":TRANS.ALL.OK; PRINT BELL:; INPUT TMP
IF TP.CN LE TP.MAX AND NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED OR DONE.FLAG EQ SHUTDOWN.DONE) THEN
*
IF NOT(FROM.LIST) OR LIST.CN EQ ONE OR STAT THEN TP<TP.CN+ONE,ELEVEN> = SVM:TP<TP.CN+ONE,ELEVEN>
TP<TP.CN+ONE,ELEVEN,ONE> = DATE():"*":TIME():"*":WHO:"*":COMM.ERROR:"*":STAT:"*":CN:"*":MAX:"*":LIST.CN:"*":ISIZE:"*":DONE.FLAG
*
IF MAIN.FLAG NE ENTRY AND (NOT(STAT) OR STAT EQ LIST.FINISHED) THEN
IF NOT(FROM.LIST) THEN TP<TP.CN+ONE,12> = ONE
END ELSE
*IF NOT(LEN(TP<TP.CN+ONE,13>)) THEN TP<TP.CN+ONE,13> = ZERO
IF MAIN.FLAG NE ENTRY THEN
TP<TP.CN+ONE,13> = TP<TP.CN+ONE,13> + ONE
END ELSE TP<TP.CN+ONE,13> = TP<TP.CN+ONE,13> + ZERO
IF TP<TP.CN+ONE,13> GE 3 THEN
TP<TP.CN+ONE,12> = 9
END ELSE
TRANS.ALL.OK = FALSE
TP<TP.CN+ONE,12> = ZERO
END; *# of set mv 12 if # of errors exceeded
END; *# of set mv 12 or incr. 13 depending on error
*
END; *# of trans.cn le trans.max
*
IF NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED) THEN
*      
IF STAT EQ UNAVAIL.SCHED THEN DONE.FLAG = STAT; STAT = FALSE
*
IF STAT EQ MAX.ERROR.ABORT.SUB OR STAT EQ MAX.ERROR.ABORT THEN COMM.ERROR = STAT
IF STAT EQ 6 OR STAT EQ 7 THEN COMM.ERROR = STAT
*
IF LEN(TP) GT 31500 THEN STAT = 18
*      
IF (MAIN.FLAG EQ ENTRY OR MAIN.FLAG EQ SLAVE) AND DONE.FLAG NE ENTRY.DONE THEN
*      
IF TP.MAX LT TP.CN THEN TP.MAX = TP.CN
TP<TP.CN+ONE,ONE> =  IN.FILE.NAME
TP<TP.CN+ONE,TWO> = OUT.FILE.NAME
TP<TP.CN+ONE,3> =  IN.ITEM.NAME
TP<TP.CN+ONE,4> = OUT.ITEM.NAME
TP<TP.CN+ONE,5> =       OPTIONS
TP<TP.CN+ONE,6> =      DIR.FLAG
TP<TP.CN+ONE,7> =     LIST.NAME
TP<TP.CN+ONE,8,ONE> = ACCT.NAME
TP<TP.CN+ONE,8,TWO> = ACCT.PASS
TP<TP.CN+ONE,9,ONE> = COMM.SYS.NAME
TP<TP.CN+ONE,9,TWO> = FILE.OPT
TP<TP.CN+ONE,9,3>   = DICT.MOD
TP<TP.CN+ONE,9,4>   = DICT.SEP
TP<TP.CN+ONE,9,5>   = FILE.MOD
TP<TP.CN+ONE,9,6>   = FILE.SEP
TP<TP.CN+ONE,TEN> =  LIST.SOURCE
IF MAIN.FLAG EQ ENTRY THEN
TP<TP.CN+ONE,ELEVEN> = EMPTY
TP<TP.CN+ONE,12> = ZERO
END
END; *# of SLAVE or ENTER
*IF TP.CN LE TP.MAX OR MAIN.FLAG EQ ENTRY AND DONE.FLAG NE SHUTDOWN.DONE THEN
IF TP.CN LE TP.MAX AND MAIN.FLAG NE ENTRY AND DONE.FLAG NE SHUTDOWN.DONE THEN
WRITEV TP<TP.CN+ONE> ON PAR.FILE,"PICK.TRANSFER":TRANS.PORT,TP.CN+ONE
END
*      
CP<5> = ERR.CN
CP<9> = ERR.CN.ALL
CP<TEN> = ERR.CN.TOTAL + ERR.CN.ALL
CP<12> = DATE():SVM:TIME():SVM:WHO:SVM:COMM.ERROR:SVM:STAT:SVM:TP.CN:SVM:TP.MAX:SVM:DONE.FLAG:SVM:COMM.INIT:SVM:COMM.STARTUP:SVM:COMM.SHUTDOWN:SVM:ACK.RSP:SVM:OUT.FILE.NAME:SVM:OUT.ITEM.NAME:SVM:LIST.NAME
CP<15> = TP<TP.CN+ONE>
CP<17> = ERR.CN.ARRAY
WRITE COMM.PARAM ON PAR.FILE,"TRANSFER.QUIET":PORT
*      
IF STAT EQ LIST.FINISHED OR STAT = 9 OR STAT EQ TWO OR STAT EQ ITEM.MISSING OR (STAT GE 20 AND STAT LT 30) THEN STAT = FALSE; LIST.CN = FALSE; *# SKIP to next TP.CN
*      
END; *# of not finished yet
*      
WHILE NOT(COMM.ERROR OR DONE.FLAG OR STAT) DO REPEAT
END; *# of STAT upon program initalization
*      
IF (MAIN.FLAG EQ MASTER AND NOT(TRANS.ALL.OK)) OR MAIN.FLAG EQ ENTRY THEN
IF NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED OR DONE.FLAG EQ ABORT.PRESENT) OR MAIN.FLAG EQ ENTRY THEN
TRANS.SUF = "NEXT"
GOSUB PARAM.WRITE
END
END
*
IF MAIN.FLAG NE ENTRY THEN
*
CP<5> = ERR.CN
CP<9> = ERR.CN.ALL
CP<TEN> = ERR.CN.TOTAL + ERR.CN.ALL
CP<12> = DATE():SVM:TIME():SVM:WHO:SVM:COMM.ERROR:SVM:STAT:SVM:TP.CN:SVM:TP.MAX:SVM:DONE.FLAG:SVM:COMM.INIT:SVM:COMM.STARTUP:SVM:COMM.SHUTDOWN:SVM:ACK.RSP:SVM:OUT.FILE.NAME:SVM:OUT.ITEM.NAME:SVM:LIST.NAME
CP<15> = TP<TP.CN+1>
* CP<16> USED
* CP<17> ERROR TYPE COUNTS
IF LEN(CP) GT 1000 THEN CP = CP[ONE,600]
WRITE COMM.PARAM ON PAR.FILE,"TRANSFER.QUIET":PORT
*
IF NOT(COMM.ERROR OR STAT) THEN
IF NOT(COMM.SYNC) THEN
COMM.SHUTDOWN = ONE
END ELSE
COMM.SHUTDOWN = FALSE
LOOP
LINE.PACKET = ESC:STB:"SHUTDOWN":CR:NUL; IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET: 
IF ACK.RSP NE "GO" THEN GOSUB ACK.RSP.INPUT ELSE COMM.SHUTDOWN = TRUE
UNTIL COMM.SHUTDOWN DO
IF VALID.PKT AND ACK.RSP EQ "SHUTDOWN" THEN COMM.SHUTDOWN = TRUE
ERR.CN = ERR.CN + ONE
REPEAT
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE
END; *# of COMM.SYNC
END; *# of not(COMM.ERROR OR STAT)
*
IF NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED OR DONE.FLAG EQ ABORT.PRESENT) THEN
* NOT(COMM.ERROR OR STAT) AND
TRANS.SUF = "LAST"
GOSUB PARAM.WRITE
IF MAIN.FLAG EQ MASTER AND DONE.FLAG EQ SHUTDOWN.DONE THEN DONE.FLAG = FALSE; COMM.INIT = FALSE; COMM.ERROR = FALSE; COMM.STARTUP = FALSE; COMM.SHUTDOWN = EMPTY
*
IF MAIN.FLAG EQ MASTER THEN
*IF TRANS.NUMBER THEN
*TRANS.DELETE = TRUE
*END ELSE TRANS.DELETE = FALSE
OUT.ID = "PICK.TRANSFER":TRANS.PORT
*
*IF TRANS.DELETE THEN
DELETE PAR.FILE,OUT.ID
*TRANS.DELETE = FALSE
*END
END
*
END
*
END; *# of MASTER / SLAVE or ENTER
*      
WHILE NOT(COMM.ERROR OR STAT) AND (MAIN.FLAG EQ MASTER AND DONE.FLAG NE ABORT.PRESENT) DO REPEAT
*
COMM.WAIT.ERROR = EMPTY
COMM.WAIT.KEY   = EMPTY
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,COMM.WAIT.KEY,COMM.WAIT.QUIET,COMM.WAIT.MAX,COMM.WAIT.ERROR,COMM.WAIT.PAUSE,COMM.WAIT.CLEAR)
IF COMM.WAIT.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
*
ECHO ON
*      
*      
STOP
*      
$INCLUDE IBP SYS.INCL.ACK.OR.SEND
*      
COMMAND.PROCESS: *# Subroutine to parse control parameters
*      
$INCLUDE IBP SYS.INCL.PICKTR.COMMANDS
*
RETURN
*
PARAM.READ: *# Subroutine to read in next control parameters
*
* TRANS.SUF = "NEXT", "LAST", EMPTY
* TRANS.FIRST = 1/0
* TRANS.PORT = Communications port
*
DONE.FLAG = FALSE
*IF TRANS.NUMBER THEN
*TRANS.DELETE = TRUE; DONE.FLAG = SCAN.FOR.WORK
*END ELSE TRANS.DELETE = FALSE
TRANS.DELETE = FALSE
OUT.ID = "PICK.TRANSFER":TRANS.PORT
TRANS.NUMBER = TRANS.NUMBER + ONE
ERR.FL = EMPTY
*
NEXT.CN = ZERO; CONT = TRUE; TRANS.FIRST = FALSE; INC = ONE
LOOP
*
IF TRANS.DELETE THEN
DELETE PAR.FILE,OUT.ID
TRANS.DELETE = FALSE
END
*
IF NOT(DONE.FLAG) THEN
OUT.ID = "PICK.TRANSFER":TRANS.PORT
READ TRANS.PARAM FROM PAR.FILE,OUT.ID THEN
DONE.FLAG   = FALSE
TRANS.FIRST = FALSE
*FROM.LIST   = FALSE
TP.CN    = ZERO
TP.MAX = DCOUNT(TP,AM) - ONE
IF TP.MAX LT ONE THEN TP.MAX = ONE
CONT = FALSE
END ELSE DONE.FLAG = SCAN.FOR.WORK
END
*
IF DONE.FLAG EQ SCAN.FOR.WORK THEN
*
NEXT.CN = NEXT.CN + INC
IN.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":NEXT.CN
IF NEXT.CN EQ ONE THEN
OUT.ID = "PICK.TRANSFER":TRANS.PORT
END ELSE
OUT.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":NEXT.CN - TRUE
END
*
READ NEXT.PARAM FROM PAR.FILE,IN.ID THEN
WRITE NEXT.PARAM ON PAR.FILE,OUT.ID
END ELSE
*
IF NEXT.CN EQ ONE THEN
DONE.FLAG = NO.WORK
TP = EMPTY
TP.CN = ONE
END ELSE
TRANS.DELETE = TRUE
*CP<14> = OUT.ID:VM:TRANS.NUMBER:VM:DATE():VM:TIME():VM:WHO:VM:OUT.FILE.NAME:VM:OUT.ITEM.NAME:VM:LIST.NAME
DONE.FLAG = FALSE
END
*
END
*
END ELSE CONT = FALSE
*
WHILE CONT DO REPEAT
*
RETURN
*
PARAM.WRITE: *# Subroutine to write in next control parameters
*
* TRANS.SUF = "NEXT", "LAST", EMPTY
* TRANS.FIRST = 1/0
* TRANS.PORT = Communications port
*
IF TRANS.SUF = "LAST" THEN OUT.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":ONE ELSE
OUT.ID = "PICK.TRANSFER":TRANS.PORT
END
ERR.FL = FALSE
*
READ NEXT.PARAM FROM PAR.FILE,OUT.ID THEN
NEXT.CN = ZERO; CONT = TRUE; INC = ONE; TRANS.FIRST = FALSE
LOOP
IF INC GT 100000 THEN ERR.FL = TRUE; CONT = FALSE
NEXT.CN = NEXT.CN + INC
OUT.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":NEXT.CN
READ NEXT.PARAM FROM PAR.FILE,OUT.ID THEN
IF NOT(TRANS.FIRST) THEN
INC = INC * TWO
END ELSE IF INC GE TWO THEN
INC = INT(INC / TWO)
END
END ELSE
*# not on file
TRANS.FIRST = TRUE
IF INC EQ ONE THEN
CONT = FALSE
END ELSE
NEXT.CN = NEXT.CN - INC
INC = INT(INC / TWO)
END
END; *# of not on file
WHILE CONT DO REPEAT
END
IF NOT(ERR.FL) THEN
WRITE TRANS.PARAM ON PAR.FILE,OUT.ID
IF TRANS.SUF EQ "NEXT" THEN
CP<13> = OUT.ID:VM:TRANS.NUMBER:VM:DATE():VM:TIME():VM:WHO:VM:OUT.FILE.NAME:VM:OUT.ITEM.NAME:VM:LIST.NAME
END ELSE
CP<14> = OUT.ID:VM:TRANS.NUMBER:VM:DATE():VM:TIME():VM:WHO:VM:OUT.FILE.NAME:VM:OUT.ITEM.NAME:VM:LIST.NAME
END
END
*
RETURN
*      
END
~PICK.TRANSFER.SUB~
SUBROUTINE PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIR.FLAG,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,COMM.WAIT.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.DELAY,ERR.OFFSET,ERR.CHOKE)
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
TRANS.PARAM = EMPTY
CHK.START.DATE = DATE(); CHK.START.TIME = TIME()
*
IF DIR.FLAG = "OUT" THEN
MAX = DCOUNT(ITEM,AM) + ONE; CN = ZERO
*ITEM<-ONE> = ESC:"END"; MAX = MAX + ONE
END ELSE MAX = 99999
*
CHK.ID = "A"; CHK.SUM = ZERO; CHK.VRF.ERROR = FALSE; VALID.PKT = FALSE
CHK.SUM.ERR = FALSE; CONC = FALSE; LINE.CONT = FALSE; DONE.FLAG = FALSE
IF MAX GT AM.MAX THEN
TMP = INDEX(ITEM,AM,AM.MAX)
ITEM.OVFL = ITEM[TMP,HI.NUM]
ITEM = ITEM[ONE,TMP-ONE]
ITEM.OVFL.FLAG = TRUE
ITEM.OVFL.CN = AM.MAX - TWO
END ELSE
ITEM.OVFL.FLAG = FALSE
END
LINE = EMPTY; LINE.PACKET = EMPTY; *ERR.CN.ARRAY = EMPTY
ERR.CN.LAST = ERR.CN; ERR.CONSEC = ZERO; ERR.REPEAT = 3; ERR.RECVD = FALSE; ERR.SENT = FALSE
IF ERR.CN - 3 GT ERR.LOW THEN ERR.CN = ERR.CN - 3
*
$INCLUDE IBP SYS.INCL.QUIET.WRITE
*
IF DIR.FLAG EQ "DIN" THEN
FOR A = ONE TO 10 UNTIL SYSTEM(11) GT 5
RQM
NEXT A
END
LINE.OUT = EMPTY
LINE.OUT.ID = EMPTY
*
LOOP
*
CHK.ID.VRF = EMPTY
CHK.SUM.VRF = EMPTY
*
IF DIR.FLAG EQ DIN AND CN LE MAX THEN
*
*#  DIR.FLAG EQ DIN
*
CN = CN + ONE
*# Loop to input valid block
LOOP
*
*# Input next block or command
IF ACK.RSP NE "GO" THEN GOSUB ACK.RSP.INPUT
RSP = ACK.RSP
CHK.ID.VRF = EMPTY
CHK.SUM.VRF = EMPTY
*
*# Is this a valid block?
IF VALID.PKT THEN
*
IF STAT AND NOT(ERR.RECVD) THEN
LINE.PACKET = ESC:"ERROR.":MAIN.FLAG:".":STAT:CR:NULL
ERR.CN.ARRAY<ONE,ONE> = ERR.CN.ARRAY<ONE,ONE> + ONE
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
ERR.SENT = TRUE
END; *# of STAT
*
CHK.ID.VRF = FIELD(RSP,STB,ONE)
CHK.SUM.VRF = FIELD(RSP,STB,TWO)
*
*# Is this a transmission error message
IF MAIN.FLAG NE MASTER AND (CHK.ID.VRF EQ "OFF" OR CHK.ID.VRF EQ "KILL" OR CHK.ID.VRF EQ "TCL") THEN
CONT = FALSE
CONC = FALSE
MAX = CN - ONE
CHK.VRF.ERROR = FALSE
STAT = ERROR.RECVD
*
*# Is this an packet error report?
END ELSE IF CHK.ID.VRF[ONE,ONE] EQ "?" OR CHK.ID.VRF[ONE,ONE] EQ ESC OR CHK.ID.VRF[ONE,ONE] EQ PICK.ESC THEN 
*
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = 5; ERR.CONSEC = ERR.CONSEC + ONE; ERR.CN.ALL = ERR.CN.ALL + ONE
LINE.PACKET = "?":ACK.RSP[2,9999]:CR:NULL; *# ECHO THE ERROR BACK 
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
CONT = TRUE
*
*# Is this a valid block (not a line contiuation command)
END ELSE IF CHK.ID.VRF EQ CHK.ID THEN
*
*# Is the check-sum a valid numeric?
IF NOT(NUM(CHK.SUM.VRF)) THEN
CONT = TRUE
LINE.PACKET = ESC:"?":CHK.ID:"?bad sum?":CHK.SUM.VRF:"?":CR:NUL
ERR.CN.ARRAY<ONE,TWO> = ERR.CN.ARRAY<ONE,TWO> + ONE
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
END ELSE
*
*# The check-sum is a valid numeric, set the line
LINE = RSP[COL2()+ONE,HI.NUM]
CONT = ZERO
*
END; *# of valid numeric check-sum
*
END ELSE
*
*# The block ID is not correct
CONT = TRUE
TEMP = CHK.ID
IF TEMP EQ "A" THEN TEMP = "Y" ELSE TEMP = CHAR(SEQ(TEMP)-ONE)
IF CHK.ID.VRF EQ TEMP THEN
*# Block OK
LINE.PACKET = ESC:"Y":TEMP:CR:NUL
ERR.CN = ERR.CN + 3; ERR.CN.ALL = ERR.CN.ALL + 3
END ELSE
LINE.PACKET = ESC:"?":CHK.ID:"?bad id?":CHK.ID.VRF:"?":CR:NUL
END
ERR.CN.ARRAY<ONE,3> = ERR.CN.ARRAY<ONE,3> + ONE
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
END; *# of valid block processing
*#
END ELSE 
*
*# This is a bad block
CONT = TRUE
LINE.PACKET = ESC:"?":CHK.ID:"?bad block?":RSP:"?":CR:NUL
ERR.CN.ARRAY<ONE,4> = ERR.CN.ARRAY<ONE,4> + ONE
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
END; *# of valid/invalid block processing
*
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERROR.ABORT.SUB
IF ERR.CONSEC GE ERR.MAX/4 THEN
IF ERR.REPEAT GT ZERO THEN ERR.CONSEC = -ERR.MAX ELSE ERR.CONSEC = ZERO; ERR.REPEAT = ERR.REPEAT - ONE; ERR.CN = ZERO
END
*
WHILE CONT AND STAT NE MAX.ERROR.ABORT.SUB DO
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = 5; ERR.CONSEC = ERR.CONSEC + ONE; ERR.CN.ALL = ERR.CN.ALL + ONE
*
TMP = DATE(); TMP1 = TIME()
IF TMP GT CHK.START.TIME OR (TMP GE CHK.START.DATE AND TMP1 GE CHK.START.TIME+COMM.WAIT.MAX) THEN
GOSUB ABORT.CHECK
CHK.START.DATE = TMP; CHK.START.TIME = TMP1
END
*
REPEAT
*
END; *# OF DIR.FLAG
*
*
WHILE CN LT MAX AND NOT(CHK.VRF.ERROR) AND STAT NE MAX.ERROR.ABORT.SUB DO
*
*# Loop to transmit or receive an attribute
LOOP
*
TMP = DATE(); TMP1 = TIME()
IF TMP GT CHK.START.TIME OR (TMP GE CHK.START.DATE AND TMP1 GE CHK.START.TIME+COMM.WAIT.MAX) THEN
GOSUB ABORT.CHECK
CHK.START.DATE = TMP; CHK.START.TIME = TMP1
END
*
*
*# Increment block ID
* CHK.ID = CHAR(SEQ(CHK.ID)+ONE)
* IF CHK.ID = "Z" THEN CHK.ID = "A"
*
IF DIR.FLAG EQ DOUT THEN
*
IF STAT AND NOT(ERR.SENT) THEN
MAX = DCOUNT(ITEM,AM) + ONE; CN = ZERO
IF ITEM[1,1] NE ESC AND ITEM[1,1] NE "@" THEN
ITEM = EMPTY; MAX = ZERO; CN = ZERO
ITEM<-ONE> = ESC:"ERROR.":MAIN.FLAG:".":STAT; MAX = MAX + ONE
ITEM<-ONE> = ESC:"ABORT"; MAX = MAX + ONE
END ELSE
ITEM<-ONE> = ESC:"ERROR.":MAIN.FLAG:".":STAT; MAX = MAX + ONE
ITEM<-ONE> = ESC:"ABORT"; MAX = MAX + ONE
END
*ITEM<-ONE> = ESC:"END"; MAX = MAX + ONE
LINE.CONT = EMPTY
ERR.SENT = TRUE
END
*
*# Line continuation
IF LEN(LINE.CONT) THEN
LINE = LINE.CONT<ONE>
DEL LINE.CONT<ONE,ZERO,ZERO>
END ELSE
*# Get next attribute to transmit
CN = CN + ONE
IF CN LE MAX THEN
IF ITEM.OVFL.FLAG THEN
ITEM.OVFL.CN = ITEM.OVFL.CN - ONE
IF NOT(ITEM.OVFL.CN) THEN
ITEM.OVFL.CN = AM.MAX - TWO
IF NOT(LEN(ITEM.OVFL)) THEN
ITEM.OVFL.FLAG = FALSE
END ELSE
TMP = INDEX(ITEM.OVFL,AM,AM.MAX)
IF NOT(TMP) THEN TMP = HI.NUM; ITEM.OVFL.CN = ONE
ITEM = ITEM:ITEM.OVFL[ONE,TMP-ONE]
ITEM.OVFL = ITEM.OVFL[TMP,HI.NUM]
END
END
END
IF NOT(LEN(ITEM)) THEN ITEM<-ONE> = ESC:"END"
LINE = ITEM<ONE>
DEL ITEM<ONE,ZERO,ZERO>
*IF LINE EQ ESC:"END" THEN ITEM = EMPTY; CN = ONE; MAX = ONE
*
IF LEN(LINE) GT LINE.MAX.LEN THEN
LOOP WHILE LEN(LINE) DO
IF LEN(LINE.CONT) THEN
LINE.CONT = LINE.CONT:AM:ESC:"+++":AM:LINE[ONE,LINE.MAX.LEN]
END ELSE LINE.CONT = LINE[ONE,LINE.MAX.LEN]
LINE = LINE[LINE.MAX.LEN+ONE,HI.NUM]
REPEAT
LINE = LINE.CONT<ONE>
DEL LINE.CONT<ONE,ZERO,ZERO>
END; *# of line too long
*
END; *# of CN LT MAX
*
END; *# of line continuation
*
END; *# of DIR.FLAG     eq DOUT
*
IF ERR.CHOKE THEN
FOR TMP = ONE TO ERR.CHOKE
RQM
NEXT TMP
END
*
*# Calculate check-sum
IF DIR.FLAG NE DOUT OR CN LE MAX THEN
TC.CN = ZERO
CHK.SUM = ZERO
TC.MAX = LEN(LINE)
LOOP
TC.CN = TC.CN + ONE
WHILE TC.CN LE TC.MAX DO
CHK.SUM = CHK.SUM + SEQ(LINE[TC.CN,ONE])
*SPOT TO SUB
REPEAT
CHK.SUM.ERR = FALSE
END
*
IF DIR.FLAG EQ DIN THEN
*
*# Bad block
IF CHK.SUM NE CHK.SUM.VRF THEN
LINE.PACKET = ESC:"?":CHK.ID:"?sum?":CHK.SUM:"?ne?":CHK.SUM.VRF:"?":CR:NUL
ERR.CN.ARRAY<ONE,5> = ERR.CN.ARRAY<ONE,5> + ONE
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
CHK.SUM.ERR = TRUE
END ELSE
*
*# Block OK
LINE.PACKET = ESC:"Y":CHK.ID:CR:NUL
IF ERR.CN GT ERR.LOW THEN
IF ERR.CN.LAST LE ZERO AND ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE; ERR.CN.LAST = 5 ELSE ERR.CN.LAST = ERR.CN.LAST - ONE
END
ERR.CONSEC = ZERO
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
*
*# Is this a command of some sort ?
IF LINE[ONE,ONE] EQ ESC OR LINE[ONE,ONE] EQ PICK.ESC THEN
LINE = LINE[TWO,HI.NUM]
*
* is this a line continuation command
IF LINE EQ "+++" THEN
CONC = TRUE
*
*# Is this the end of transmission
END ELSE IF LINE EQ "END" OR LINE EQ "ABORT" THEN
CONC = FALSE
IF LINE EQ "END" AND CN GT 1 THEN MAX = CN - ONE
* (^^^ MIGHT BE TRUE FOR ABORT AS WELL)
IF LINE EQ "ABORT" THEN STAT = 9
*
END ELSE IF LINE[1,6] EQ "ERROR." THEN
*IF ACK.RSP[1,6] EQ "ERROR." THEN
TMP = FIELD(CHK.ID.VRF,".",3)
IF TMP EQ "RECVD" THEN
ERR.RECVD = TRUE
END ELSE
*
*IF DIR.FLAG EQ DIN THEN
LINE.PACKET = ESC:"ERROR.P.RECVD":CR:NULL
GOSUB CHAR.SEND.PKT
*END ELSE
*ITEM = ESC:"RECVD":AM:ITEM; MAX = MAX + ONE
*END
IF NOT(NUM(TMP)) THEN STAT = ERROR.RECVD ELSE STAT = TMP
*IF STAT GE 20 AND STAT LE 29 THEN STAT = ZERO
ERR.RECVD = TRUE
END; *# of not RECVD
*END; *# of "ERROR."
*
END ELSE IF LINE[1,1] EQ "?" THEN
*
* I DON'T KNOW WHAT TO DO HERE (POINTS OUT THE TYPE OF ERROR)
END
*
END ELSE
*
*# Line continuation
IF CONC THEN
ITEM = ITEM:LINE
CONC = FALSE
END ELSE
*
*# Next attribute
IF CN GT ONE THEN ITEM=ITEM:AM:LINE ELSE ITEM = LINE
END; *# OF CONC
*
END; *# of types of lines
END; *# OF CHK.VRF
*
END ELSE
*
*#  DIR.FLAG EQ DOUT
*
IF LEN(LINE.OUT) THEN
LOOP
*
*# Input block verfication message
IF ACK.RSP NE "GO" THEN GOSUB ACK.RSP.INPUT
*
IF ACK.RSP[1,6] EQ "ERROR." THEN
TMP = FIELD(CHK.ID.VRF,".",3)
IF TMP EQ "RECVD" THEN
ERR.RECVD = TRUE
END ELSE
*
ITEM = ESC:"ERROR.P.RECVD":AM:ITEM; MAX = MAX + ONE
IF NOT(NUM(TMP)) THEN STAT = ERROR.RECVD ELSE STAT = TMP
ERR.RECVD = TRUE
END; *# of not RECVD
END; *# of "ERROR."
*
*IF STAT EQ 6 THEN
*ACK.RSP = "Y":CHK.ID
*IF ITEM[1,1] NE ESC AND ITEM[1,1] NE "@" THEN ITEM = ESC:"ABORT":AM:ESC:"END"; MAX = TWO ELSE ITEM<MAX-CN> = ESC:"ABORT"; ITEM<-ONE> = ESC:"END"; MAX = MAX + 1
*END
*
*# Loop back for bad block
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERROR.ABORT.SUB
IF ERR.CONSEC GE ERR.MAX/4 THEN
IF ERR.REPEAT GT ZERO THEN ERR.CONSEC = -ERR.MAX ELSE ERR.CONSEC = ZERO; ERR.REPEAT = ERR.REPEAT - ONE; ERR.CN = ZERO
END
*
WHILE ACK.RSP NE "GO" AND ACK.RSP[ONE,TWO] NE "Y":LINE.OUT.ID AND STAT NE MAX.ERROR.ABORT.SUB DO
*
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = 5; ERR.CONSEC = ERR.CONSEC + ONE; ERR.CN.ALL = ERR.CN.ALL + ONE
*
*# Send block
LINE.PACKET = LINE.OUT
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
*
TMP = DATE(); TMP1 = TIME()
IF TMP GT CHK.START.TIME OR (TMP GE CHK.START.DATE AND TMP1 GE CHK.START.TIME+COMM.WAIT.MAX) THEN
GOSUB ABORT.CHECK
CHK.START.DATE = TMP; CHK.START.TIME = TMP1
END
*
REPEAT
END; * of LINE.OUT
*
IF CN LE MAX THEN
LINE.OUT = ESC:STB:CHK.ID:STB:(100000+CHK.SUM) "R#5":STB:LINE:CR:NUL
LINE.OUT.ID = CHK.ID
*# Send block
LINE.PACKET = LINE.OUT
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:
END
*
IF ERR.CN GT ERR.LOW THEN
IF ERR.CN.LAST LE ZERO AND ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE; ERR.CN.LAST = 5 ELSE ERR.CN.LAST = ERR.CN.LAST - ONE
END
ERR.CONSEC = ZERO
*
END; *# OF DIR.FLAG
*
*# Increment block ID
IF NOT(CHK.SUM.ERR) THEN
CHK.ID = CHAR(SEQ(CHK.ID)+ONE)
IF CHK.ID = "Z" THEN CHK.ID = "A"
END ELSE IF DIR.FLAG EQ DIN THEN
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = 5; ERR.CONSEC = ERR.CONSEC + ONE; ERR.CN.ALL = ERR.CN.ALL + ONE
END
*
WHILE CN LE MAX AND DIR.FLAG EQ DOUT AND STAT NE MAX.ERROR.ABORT.SUB DO REPEAT
*
REPEAT
*
*IF DONE.FLAG EQ UNAVAIL.SCHED THEN 
IF DONE.FLAG THEN STAT = DONE.FLAG
*
$INCLUDE IBP SYS.INCL.QUIET.WRITE
*
RETURN
*
ABORT.CHECK: *# Subroutine to check for abort every MAX.WAIT seconds
*
$INCLUDE IBP SYS.INCL.ABORT.CHECK
*
$INCLUDE IBP SYS.INCL.SCHED.CHECK
*
IF NOT(SCHED.OK) THEN DONE.FLAG = UNAVAIL.SCHED; STAT = UNAVAIL.SCHED
IF STAT EQ LOGOFF.COMMAND THEN DONE.FLAG = STAT; STAT = MAX.ERROR.ABORT.SUB
*
$INCLUDE IBP SYS.INCL.QUIET.WRITE
*
$INCLUDE IBP SYS.INCL.QUIET.LOAD
*
RETURN
*
$INCLUDE IBP SYS.INCL.ACK.OR.SEND
*
END
~PLUG.ATTR.13~
*PROGRAM: CREATE.FILES.PROC.GEN 
*
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN "CNT" TO CNT.FILE ELSE STOP
OPEN "MD" TO MD.FILE ELSE STOP
READ FILE.INDEX FROM CNT.FILE,"FILES" ELSE STOP
LOOP
PRINT
PRINT "Will you use the calculated size (Y/N)? ":
INPUT RSP
IF RSP EQ "KILL" THEN STOP
WHILE RSP NE "Y" AND RSP NE "N" DO REPEAT
IF RSP EQ "Y" THEN SIZE.FLAG = 1 ELSE SIZE.FLAG = ""
*
LOOP
PRINT
PRINT "Will you use the minimum file modulo (Y/N)? ":
INPUT RSP
IF RSP EQ "KILL" THEN STOP
WHILE RSP NE "Y" AND RSP NE "N" DO REPEAT
IF RSP EQ "Y" THEN MIN.COUNT.FLAG = 1 ELSE MIN.COUNT.FLAG = ""
*
FMAX = DCOUNT(FILE.INDEX<1>,VM)
*
FOR CN = 1 TO FMAX
*
FILE.NAME = FILE.INDEX<1,CN>
*
OPEN "DICT",FILE.NAME TO FILE.DICT THEN
READ MD.ITEM FROM MD.FILE,FILE.NAME THEN
READ DATA.ITEM FROM FILE.DICT,"DL/ID" THEN
FILE.DICT.CN = FILE.INDEX<3,CN>
FILE.DICT.ESIZE = 40
FILE.DICT.MOD = FILE.DICT.CN * FILE.DICT.ESIZE / 512 * 1.2
IF FILE.DICT.MOD LT 3 THEN FILE.DICT.MOD = 3
FILE.DICT.MOD = ICONV(FILE.DICT.MOD,"MR0")
FILE.DICT.SEP = 1
FILE.DATA.CN = FILE.INDEX<4,CN>
FILE.DATA.ESIZE = FILE.INDEX<5,CN>
FILE.DATA.CSIZE = FILE.INDEX<6,CN>
FILE.DATA.MINCN = FILE.INDEX<7,CN>
IF NOT(NUM(FILE.DATA.MINCN)) THEN FILE.DATA.MINCN = 0
IF SIZE.FLAG THEN FILE.SIZE = FILE.DATA.CSIZE ELSE FILE.SIZE = FILE.DATA.ESIZE
IF NOT(FILE.SIZE) THEN FILE.SIZE = FILE.DATA.ESIZE
IF NOT(FILE.SIZE) THEN FILE.SIZE = 100
FILE.DATA.MOD = FILE.DATA.CN * FILE.SIZE / 512 * 1.2
IF FILE.DATA.MOD LT FILE.DATA.MINCN AND MIN.COUNT.FLAG THEN FILE.DATA.MOD = FILE.DATA.MINCN
IF FILE.DATA.MOD LT 11 THEN FILE.DATA.MOD = 11
BEGIN CASE
CASE OPSYS = "M"
FILE.DATA.MOD = ICONV(FILE.DATA.MOD,"MR0")
FILE.DICT.MOD = ICONV(FILE.DICT.MOD,"MR0")
CASE 1
FILE.DATA.MOD = OCONV(FILE.DATA.MOD,"MR0")
FILE.DICT.MOD = OCONV(FILE.DICT.MOD,"MR0")
END CASE
FILE.DATA.SEP = 1
*
VAL.TO.PLUG = "(":FILE.DATA.MOD:",1)"
DICT.VAL.TO.PLUG = "(":FILE.DICT.MOD:",1)"
DATA.ITEM<13> = VAL.TO.PLUG
MD.ITEM<13> = DICT.VAL.TO.PLUG
WRITE MD.ITEM ON MD.FILE,FILE.NAME
WRITE DATA.ITEM ON FILE.DICT,"DL/ID"
*
PRINT CN "R#3":") ":FILE.NAME
FILE.INDEX<2,CN> = ACCT
FILE.INDEX<8,CN> = FILE.DICT.MOD
FILE.INDEX<9,CN> = FILE.DATA.MOD
*
END ELSE NULL; * OF DICT READ
*
END ELSE NULL; * OF MD READ
*
END ELSE NULL; * OF OPEN
*
NEXT CN
*
IF OPSYS = "M" THEN
END ELSE
END
WRITE FILE.INDEX ON CNT.FILE,"FILES"
END
~PRINT.DICTS~
*PROGRAM: PRINT.DICTS 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       PRINTS FILE LAYOUTS AS DEFINED IN DICTIONARY
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
MAX.LINES = 55
!
INPUT RUN.TYPE
OPEN "MD" TO MD.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = ""
CO.NAME = CO.NAME<1,1,1>
TITLE = "Print.dicts - Prints dictionary file layouts"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
*
LOOP
PRINT @(10,4):CLL:"Enter file name or A(ll): ":
INPUT RSP:; IF RSP = "" OR RSP = "KILL" THEN STOP
IF RSP = "A" THEN DUMMY = "Q" ELSE READ DUMMY FROM MD.FILE,RSP ELSE DUMMY = ""
DUMMY = DUMMY[1,1]
UNTIL DUMMY = "D" OR DUMMY = "Q" DO PRINT BELL: REPEAT
FILE.NAME = RSP
*
LOOP
PRINT @(10,5):CLL:"Include detail (<cr>/N)? ":
INPUT DETAIL:; IF DETAIL = "KILL" THEN STOP
UNTIL DETAIL = "Y" OR DETAIL = "N" OR DETAIL = "" DO PRINT BELL: REPEAT
IF DETAIL = "N" THEN DETAIL = "" ELSE DETAIL = 1
*
IF FILE.NAME # "A" THEN FILE.NAMES = FILE.NAME ELSE
IF RUN.TYPE NE 1 THEN
EXECUTE 'SSELECT MD WITH *A1 = "D" OR *A1 = "Q"'
END ELSE
EXECUTE 'GET-LIST KBIL-FILES'
END
FILE.NAMES = ""
LOOP READNEXT FILE.NAME ELSE FILE.NAME = "" UNTIL FILE.NAME = "" DO FILE.NAMES<-1> = FILE.NAME REPEAT
END
!
100 * START
FILE.NAME = FILE.NAMES<1>; IF FILE.NAME = "" THEN STOP
DEL FILE.NAMES<1>
OPEN "DICT",FILE.NAME ELSE GOTO 100
TITLE = "FILE LAYOUT - '":FILE.NAME:"'"
PRINT @(24,11):CLL:TITLE
*
EXECUTE "SSELECT DICT ":FILE.NAME:" BY NUM.ORDER"
PAGE.NUM = 1
LINE.NUM = 99
PRINTER ON
!
200 *
READNEXT ID ELSE GOTO 900
IF NOT(NUM(FIELD(ID,",",1))) THEN GOTO 200
READ ITEM FROM ID ELSE GOTO 200
GOSUB 1000; * HEADER
AMC = FIELD(ID,",",1)
VMC = FIELD(ID,",",2)
SMC = FIELD(ID,",",3)
DICT.NAME = ITEM<3>
IF SMC # "" THEN DICT.NAME = SPACE(4):DICT.NAME; VMC = ""; AMC = "" ELSE
IF VMC # "" THEN DICT.NAME = SPACE(2):DICT.NAME; AMC = ""
END
CONVERSION = ITEM<7>
CORROLATIVE = ITEM<8>
IF CORROLATIVE # "" THEN CONVERSION = TRIM(CONVERSION:" [":CORROLATIVE:"]")
DESCRIP = ITEM<11>
IF ITEM<12> # "" THEN DESCRIP<1,-1> = ITEM<12>
DYNAMIC = ITEM<15>
IF DYNAMIC = "" THEN ASSOC = "" ELSE
TYPE = FIELD(DYNAMIC,"-",1); ASSOC = FIELD(DYNAMIC,"-",2)
IF TYPE = "V" THEN VMC = "#" ELSE IF TYPE = "S" THEN VMC = "#"; SMC = "#"
END
COMMENT.EDITS = ITEM<16>
IF ITEM<14> # "" THEN INS ITEM<14> BEFORE COMMENT.EDITS<1>
PRINT AMC "R#3":VMC "R#4":SMC "R#4":"  ":DICT.NAME "L#20":" ":ITEM<10> "R#3":" ":
PRINT ITEM<9> "L#4":CONVERSION "L#11":ASSOC "L#7":COMMENT.EDITS<1,1> "L#27":"  ":DESCRIP<1,1> "L#40"
IF DETAIL THEN
LOOP
DEL DESCRIP<1,1>
DEL COMMENT.EDITS<1,1>
UNTIL DESCRIP<1,1> = "" AND COMMENT.EDITS<1,1> = "" DO
IF LINE.NUM < MAX.LINES+3 THEN LINE.NUM = LINE.NUM+1 ELSE GOSUB 1000; * HEADER
PRINT SPACE(60):COMMENT.EDITS<1,1> "L#27":SPACE(2):DESCRIP<1,1> "L#40"
REPEAT
DISPLAY.DEF = ITEM<13>
IF DISPLAY.DEF # "" THEN
PRINT SPACE(60):"displays-":DISPLAY.DEF
LINE.NUM = LINE.NUM+1
END
PRINT
LINE.NUM = LINE.NUM+1
END ELSE
LOOP DEL COMMENT.EDITS<1,1> UNTIL COMMENT.EDITS<1,1> = "" DO
IF LINE.NUM < MAX.LINES+3 THEN LINE.NUM = LINE.NUM+1 ELSE GOSUB 1000; * HEADER
PRINT SPACE(60):COMMENT.EDITS<1,1> "L#27"
REPEAT
END
GOTO 200
*
900 *
PRINTER OFF
GOTO 100
!
1000 * HEADER
LINE.NUM = LINE.NUM+1
IF LINE.NUM < MAX.LINES THEN RETURN
*
PRINT FF:TIMEDATE() "L#25":(SPACE(40-LEN(TITLE)/2+.5):TITLE) "L#80":("PAGE ":PAGE.NUM) "R#25"
PRINT
PRINT "amc vmc smc" "L#13":"dict.name" "L#21":"lth" "L#4":"l/r" "L#4":"conversion" "L#11":"assoc." "L#7":
PRINT "comment/edits" "L#29":"description"
PRINT
PAGE.NUM = PAGE.NUM+1
LINE.NUM = 4
RETURN
END
~PRINTER.FONT~
*PROGRAM: PRINTER.FONT 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       SETS G.E. 3000 PRINTER FONT
* DATE WRITTEN:      16 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Select printer font for GE-3000 series printers"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
FONT.CODES = "11121314"
PRINT @(20,4):"1. 17 CPI NLQ font":@(20,5):"2. 17 CPI draft font":
PRINT @(20,6):"3. 12 CPI NLQ font":@(20,7):"4. 12 CPI draft font":
PRINT @(20,8):"5. 10 CPI NLQ font":@(20,9):"6. 10 CPI draft font":
*
LOOP
PRINT @(20,22):CLL:"Enter your choice: ":
INPUT RSP:
IF RSP = "" THEN STOP
WHILE RSP < 1 OR RSP > 6 DO PRINT BELL: REPEAT
*
FONT.CODES = "141213111311"
PITCH.CODES = "444460607272"
*
FONT.CODE = CHAR(27):"[;":FONT.CODES<1,RSP>:"m"
PITCH.CODE = CHAR(27):"[;":PITCH.CODES<1,RSP>:" G"
* PAGE.CODE = CHAR(27):"[7920r"
*
PRINTER ON
PRINT FONT.CODE:PITCH.CODE:
PRINTER OFF
*
PRINT @(20,23):CLL:"Set to mode ":RSP:" - hit <cr> to end   ":
INPUT RSP:
END
~PRINTER.FONT.DEC~
*PROGRAM: DEC.PRINTER.FONT 
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       SETS DEC LA120 PRINTER FONT
* DATE WRITTEN:      16 FEB 88
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Select printer font for DEC LA120 series printers"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
PRINT @(20,4):"1, 17 CPI draft font":
PRINT @(20,6):"2. 12 CPI draft font":
PRINT @(20,8):"3. 10 CPI draft font":
*
LOOP
PRINT @(20,22):CLL:"Enter your choice: ":
INPUT RSP:
IF RSP = "" THEN STOP
WHILE RSP < 1 OR RSP > 6 DO PRINT BELL: REPEAT
*
PITCH.CODES = "421"
*
PITCH.CODE = CHAR(27):"[":PITCH.CODES<1,RSP>:"w"
*
PRINTER ON
PRINT PITCH.CODE:
PRINTER OFF
*
PRINT @(20,23):CLL:"Set to mode ":RSP:" - hit <cr> to end   ":
INPUT RSP:
END
~PRINTER.LINES~
*PROGRAM: PRINTER.LINES 
* AUTHOR:            HARVEY HORSMAN - AXION
* DESCRIPTION:       SETS G.E. 3000 LINES PER INCH
* DATE WRITTEN:      25 SEP 86
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Select Lines per Inch for GE-3000 series printers"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
PRINT @(20,4):"1. 6 Lines per inch":@(20,5):"2. 8 Lines per inch":
LOOP
PRINT @(20,22):CLL:"Enter your choice: ":
INPUT RSP:
IF RSP = "" THEN STOP
WHILE RSP < 1 OR RSP > 2 DO PRINT BELL: REPEAT
*
LINE.CODES = "12090"
*
LINE.CODE = CHAR(27):"[":LINE.CODES<1,RSP>:" G"
* PAGE.CODE = CHAR(27):"[7920r"
*
PRINTER ON
PRINT LINE.CODE
PRINTER OFF
*
PRINT @(20,23):CLL:"Set to lines ":RSP:" - hit <cr> to end   ":
INPUT RSP:
END
~PRINTER.LINES.DEC~
*PROGRAM: DEC.PRINTER.LINES 
* AUTHOR:            HARVEY HORSMAN - AXION
* DESCRIPTION:       SETS DEC LA120 LINES PER INCH
* DATE WRITTEN:      25 SEP 88
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Select Lines per Inch for GE-3000 series printers"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
PRINT @(20,4):"1. 6 Lines per inch":@(20,5):"2. 8 Lines per inch":
LOOP
PRINT @(20,22):CLL:"Enter your choice: ":
INPUT RSP:
IF RSP = "" THEN STOP
WHILE RSP < 1 OR RSP > 2 DO PRINT BELL: REPEAT
*
LINE.CODES = "12"
*
LINE.CODE = CHAR(27):"[":LINE.CODES<1,RSP>:"z"
* PAGE.CODE = CHAR(27):"[7920r"
*
PRINTER ON
PRINT LINE.CODE
PRINTER OFF
*
PRINT @(20,23):CLL:"Set to lines ":RSP:" - hit <cr> to end   ":
INPUT RSP:
END
~PRINTER.ON~
SUBROUTINE PRINTER.ON(STAT)
* PROGRAM:           PRINTER.ON
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       TURNS PRINTER ON
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
PRINTER ON; * INST SKIP
STAT = ""
RETURN
END
~PRINTER.SUBR.CLOSE~
SUBROUTINE PRINTER.SUBR.CLOSE(STAT)
* PROGRAM:           PRINTER.SUBR.CLOSE
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       CLOSES PRINTER FILE
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
IF NOT(AUX.PTR) THEN PRINTER CLOSE
STAT = ""
RETURN
END
~PRINTER.SUBR.OFF~
SUBROUTINE PRINTER.OFF(STAT)
* PROGRAM:           PRINTER.OFF
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       TURNS PRINTER OFF
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
PRINTER OFF
STAT = ""
RETURN
END
~PRINTER.SUBR.ON~
SUBROUTINE PRINTER.ON(STAT)
* PROGRAM:           PRINTER.ON
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       TURNS PRINTER ON
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
PRINTER ON
STAT = ""
RETURN
END
~PRINTER.TESTER~
*PROGRAM: PRINTER.TESTER 
*
*TESTER - TEST PRINTING AT 8LPI 12CPI...
*
COMPRESS.OFF = CHAR(27):"[11m"
COMPRESS.ON = CHAR(27):"[12m"
LPI6 = CHAR(27):"[120 G"
LPI8 = CHAR(27):"[90 G"
CPI12 = CHAR(27):"[;60 G"
CPI10 = CHAR(27):"[;72 G"
CPI6 = CHAR(27):"[;120 G"
EXECUTE "SP-ASSIGN Q2"
PRINTER ON
FOR NUM = 1 TO 3
TEXT = "LPI8,COMPRESS OFF"; PRINT LPI8:COMPRESS.OFF:; GOSUB PRTN
TEXT = "COMPRESS ON,LPI6"; PRINT COMPRESS.ON:LPI6:; GOSUB PRTN
NEXT NUM
TEXT = "No changes"; GOSUB PRTN
TEXT = "Compress off"; PRINT COMPRESS.OFF:; GOSUB PRTN
TEXT = "6 LPI"; PRINT LPI6:; GOSUB PRTN
TEXT = "12 CPI"; PRINT CPI12:; GOSUB PRTN
TEXT = "10 CPI"; PRINT CPI10:; GOSUB PRTN
TEXT = "6 CPI"; PRINT CPI6:; GOSUB PRTN
TEXT = "8 LPI"; PRINT LPI8:; GOSUB PRTN
TEXT = "12 CPI"; PRINT CPI12:; GOSUB PRTN
TEXT = "10 CPI"; PRINT CPI10:; GOSUB PRTN
TEXT = "6 CPI"; PRINT CPI6:; GOSUB PRTN
TEXT = "6LPI,10CPI"; PRINT LPI6:CPI10:; GOSUB PRTN
TEXT = "compress on"; PRINT COMPRESS.ON:; GOSUB PRTN
PRINT CHAR(12):"This should be at the top of a page...."
PRINTER OFF
STOP
!
PRTN: *
PLINE = TEXT
LOOP UNTIL LEN(PLINE) > 60 DO
PLINE = PLINE:"...  ":TEXT
REPEAT
FOR I = 1 TO 10
PRINT PLINE
NEXT I
PRINT
RETURN
!
END
~PROGLISTC~
*PROGRAM: PROGLISTC 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND PRINT BASIC PROGRAMS IN FILE 'BP.CONV'
* DATE WRITTEN:      11 APR 88
*                    COPIED FROM PROGLIST
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
FAST.PRINT = ""
INPUT EQUATES:
IF EQUATES[1,1] = "F" THEN EQUATES = EQUATES[2,99]; FAST.PRINT = 1
INPUT FILE.NAME:
*
OPEN FILE.NAME TO BP.FILE ELSE STOP
OPEN "IBP" TO IBP.FILE ELSE STOP
*
DIM INCL.LINES(600); MAX.LINES = 82
FONT.17 = CHAR(27):"[;12m":CHAR(27):"[;44 G"; FONT.12 = CHAR(27):"[;11m":CHAR(27):"[;60 G"
IF EQUATES[1,1] = "X" THEN EQUATES = EQUATES[2,1]; REQD.FONT = FONT.12; MAX.COLS = 98 ELSE REQD.FONT = FONT.17; MAX.COLS = 130
PRINTER ON; PRINT REQD.FONT:; PRINTER OFF
IF EQUATES # 1 THEN EQUATES = 0
TAB.STRING = "|  "
LOOP UNTIL LEN(TAB.STRING) > MAX.COLS DO TAB.STRING = TAB.STRING:TAB.STRING REPEAT
!
MAIN: * READ EACH PROGRAM SELECTED
READNEXT PROG ELSE PRINTER ON; PRINT FONT.17:; STOP
PRINT; PRINT PROG
PROG.ID = PROG
PROG = "Program Listing - '":FILE.NAME:" ":PROG:"'"; LINE.NUM = MAX.LINES; PAGE.NUM = 1; TAB = 0; NUM = 1; CASE.FLAG = 0
LOOP
READV LINE FROM BP.FILE,PROG.ID,NUM ELSE LINE = ""
UNTIL LINE = "" DO
GOSUB PRINTLINE
IF LINE[1,1] = "$" THEN IF EQUATES THEN
SAVE.NUM = NUM; NUM = "$   "; INCL.PROG = FIELD(LINE," ",3)
MATREAD INCL.LINES FROM IBP.FILE,INCL.PROG ELSE MAT INCL.LINES = ""
LINE = "*"; GOSUB PRINTLINE; INCL.NUM = 1
LOOP LINE = INCL.LINES(INCL.NUM) UNTIL LINE = "" DO GOSUB PRINTLINE; INCL.NUM = INCL.NUM+1 REPEAT
IF INCL.NUM > 1 THEN LINE = "*"; GOSUB PRINTLINE
NUM = SAVE.NUM
END
NUM = NUM+1
REPEAT
PRINTER CLOSE
GOTO MAIN
!
PRINTLINE: * ANALYSE AND PRINT LINE
T.LEFT = 0; T.RIGHT = 0; LABEL = ""
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-T.LEFT; IF TAB < 0 THEN TAB = 0
INDENT = TAB*3; P.LINE = NUM "R#4":"  "
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6):TAB.STRING[1,INDENT]:STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":TAB.STRING[1,INDENT]:LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE # "" THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
PRINTER ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]
P.LINE = SPACE(12+INDENT):P.LINE[POS+1,999]
REPEAT
PRINT P.LINE; TAB = TAB+T.RIGHT; PRINTER OFF; PRINT "*":
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
BEGIN CASE
CASE FIRST = "IF" OR FIRST = "LOCATE" OR FIRST[1,4] = "READ" OR FIRST[1,7] = "MATREAD" OR FIRST = "WRITET" OR FIRST = "WEOF" OR FIRST = "OPEN"
GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "LOOP"; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "WHILE" OR FIRST = "UNTIL"; T.LEFT = 1; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "FOR"; POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN T.RIGHT = 1
CASE FIRST = "BEGIN"; T.RIGHT = 1; CASE.FLAG = 1
CASE FIRST = "CASE"; T.RIGHT = 1; IF CASE.FLAG = 1 THEN CASE.FLAG = 0 ELSE T.LEFT = 1
CASE FIRST = "END"
IF LINE[POS+1,4] = "CASE" THEN T.LEFT = 2; RETURN
T.LEFT = 1; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "NEXT" OR FIRST = "REPEAT"; T.LEFT = 1
END CASE
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
LASTWORD: * GET LAST WORD
POS = LEN(LINE)
LOOP WHILE LINE[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" OR NOT(POS) DO POS = POS-1 REPEAT
LAST = TRIM(LINE[POS+1,999])
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
MSK = "L#":MAX.COLS-50
IF (FAST.PRINT) AND PAGE.NUM > 1 THEN PRINTER CLOSE
PRINT FF:TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":CR:LF
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
RETURN
END
~PROGMAP~
*PROGRAM: PROGMAP 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       PRINT A MAP OF A BASIC PROGRAM SHOWING ALL
*                    SUBROUTINE CALLS AND INCLUDES...
* DATE WRITTEN:      10 NOV 83
* DATE RELEASED:     10 NOV 83
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT BP.ID
OPEN BP.ID TO BP.FILE ELSE STOP
INPUT IBP.ID
OPEN IBP.ID TO IBP.FILE ELSE STOP
DIM LINES(1200),STK(20),CTBL(100),INCTBL(200),STKCALL(20)
MAX.LINES = 60
*
EQUATES = 1
*
PRINTER ON
!
MAIN: * READ EACH PROGRAM SELECTED
READNEXT PROG ELSE STOP
LINE.NUM = MAX.LINES; PAGE.NUM = 1; TAB = 0; NUM = 1; CASE.FLAG = 0
MAT CTBL = ""
MAT STK = ""
MAT STKCALL = ""
MAT INCTBL = ""
INCSUB = 0
STS = 1; CSUB = 1
CURR.FILE = 1
CURR.PROG = PROG
CTBL(1) = PROG
OLINE = PROG
HDPROG = "PROGRAM MAP - '":PROG:"' OF ":BP.ID
GOSUB SPLAT
TAB = 4
GOSUB READER
!
LOOPER: * CHECK ALL LINES OF THE PROGRAM (RECURSIVE ROUTINE)...
LOOP LINE = LINES(NUM) UNTIL LINE = "" DO
GOSUB PRINTLINE
NUM = NUM+1
REPEAT
IF STS = 1 THEN GOSUB ENDER; GOTO MAIN
*
* TAKE AN ENTRY OFF OF THE STACK...
NUM = STK(STS)<1,3,1>
IF STK(STS)<1,5,1> # "$" THEN TAB = TAB - 4
CURR.FILE = STK(STS)<1,1,1>
CURR.PROG = STK(STS)<1,2,1>
GOSUB READER
LINES(NUM) = STK(STS)<1,4,1>
STS=STS-1
GOTO LOOPER
!
PRINTLINE: * ANALYSE A PRINT LINE FOR INCLUDES AND CALLS...
IF LINE[1,1] = "$" THEN IF EQUATES THEN
STS = STS + 1
STK(STS) = CURR.FILE:VM:CURR.PROG:VM:NUM+1:VM:"*":VM:"$"
STKCALL(STS) = STKCALL(STS-1)
CURR.FILE = 2
CURR.PROG = FIELD(LINE," ",3)
I=1
LOOP UNTIL I > INCSUB OR INCTBL(I) = CURR.PROG DO
I=I+1
REPEAT
IF I > INCSUB THEN INCSUB = I; INCTBL(INCSUB) = CURR.PROG
GOSUB READER
NUM = 0
RETURN
END
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
!
CHCALL: *
IF LINE = "!" OR LINE[1,1] = "*" THEN RETURN
CALL.STR = " CA":"LL "
CIX = INDEX(LINE,CALL.STR,1)
IF CIX > 0 THEN CIX = CIX + 1
CALL.STR = "CA":"LL "
IF LINE[1,5] = CALL.STR THEN CIX = 1
IF CIX = 0 THEN RETURN
CMNT = 0; QUOT = ""
IF CIX > 1 THEN
CX = 1
LOOP CHR = LINE[CX,1] UNTIL CMNT = 1 OR CX = CIX DO
IF QUOT # "" THEN IF QUOT = CHR THEN QUOT = ""; CHR=" "
IF CHR="'" OR CHR='"' THEN QUOT=CHR
IF QUOT = "" THEN IF CHR = "*" OR CHR = "!" THEN CMNT = 1
CX = CX + 1
REPEAT
END
LINE = LINE [CIX+5,999]
IF CMNT = 1 THEN RETURN
IF QUOT # "" THEN
CIX = INDEX(LINE,QUOT,1)
IF CIX = 0 THEN RETURN
LINE = LINE[CIX+1,999]
GOTO CHCALL
END
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
IF INDEX("=><#*/(+-",FIRST[1,1],1) > 0 THEN GOTO CHCALL
IF INDEX(STKCALL(STS),VM:FIRST:VM,1) > 0 THEN GOTO CHCALL
STKCALL(STS) = STKCALL(STS):VM:FIRST:VM
OLINE = FIRST
I=1
LOOP UNTIL I > CSUB OR FIRST = CTBL(I)<1,1,1> DO I=I+1 REPEAT
IF I <= CSUB THEN
CTBL(I)<1,2,1> = CTBL(I)<1,2,1> + 1
OLINE = OLINE:" *"
GOSUB SPLAT
END ELSE
CSUB=CSUB+1
CTBL(CSUB)=FIRST:VM:"1"
GOSUB SPLAT
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
STS = STS + 1
TAB = TAB + 4
STK(STS) = CURR.FILE:VM:CURR.PROG:VM:NUM:VM:LINE:VM:"C"
STKCALL(STS) = ""
CURR.FILE = 1
CURR.PROG = FIRST
GOSUB READER
NUM = 0
END
RETURN
!
KEYWORD: * REMOVE ANY LABELS AND TABBING...
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST
LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
END
*
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = "" OR INDEX(" ;(",CHAR,1) > 0 DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
PRINT FF:TIMEDATE() "L#25":(SPACE(40-LEN(HDPROG)/2):HDPROG) "L#80":("PAGE ":PAGE.NUM) "R#25":CR:LF
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
RETURN
!
SPLAT: * PRINT A LINE...
GOSUB HEADER
PRINT SPACE(TAB):OLINE
PRINTER OFF
PRINT SPACE(TAB):OLINE
PRINTER ON
RETURN
!
READER: * READ A SOURCE PROGRAM...
MAT LINES = ""
GOSUB READERA
IF LINES(1) = "" THEN
IF CURR.FILE = 1 THEN CURR.FILE = 2 ELSE CURR.FILE = 1
GOSUB READERA
END
RETURN
*
READERA: *
MAT LINES = ""
IF CURR.FILE = 1 THEN
MATREAD LINES FROM BP.FILE, CURR.PROG ELSE MAT LINES = "" 
END
IF CURR.FILE = 2 THEN
MATREAD LINES FROM IBP.FILE, CURR.PROG ELSE MAT LINES = ""
END
RETURN
!
ENDER: * END OF PROGRAM - PRINT OUT "$INCLUDE" TABLE...
IF INCSUB > 0 THEN
GOSUB HEADER
PRINT
GOSUB HEADER
PRINT "$INCLUDE IBP:"
FOR I = 1 TO INCSUB
GOSUB HEADER
PRINT '    ':INCTBL(I)
NEXT I
END
RETURN
!
END
~QPNT.CHNG.ACCT~
*PROGRAM: QPNT.CHNG.ACCT
*
* : *PROGRAM: QPTN.CHNG.ACCT
* : *  Changes file name prefixes for acct control
*
! * : ***
! * : ***
* : * INITialization
* : * FUNCtions
$INCLUDE IBP STANDARD.FUNCTIONS
! * : ***
* : * TABLes
! * : ***
*
OPEN "MD" TO MD.FILE ELSE STOP
*
PRINT
PRINT "Write to new acct prefix (Y/<cr>): ":; INPUT MOVE.FLAG
IF MOVE.FLAG EQ "Y" THEN MOVE.FLAG = TRUE ELSE MOVE.FLAG = FALSE
*
PRINT
PRINT "Replace attr 2 with acct prefix (Y/<cr>): ":; INPUT ATTR.TWO.FLAG
IF ATTR.TWO.FLAG EQ "Y" THEN ATTR.TWO.FLAG = TRUE ELSE ATTR.TWO.FLAG = FALSE
*
PRINT
PRINT "Replace attr 3 with acct prefix (Y/<cr>): ":; INPUT ATTR.THREE.FLAG
IF ATTR.THREE.FLAG EQ "Y" THEN ATTR.THREE.FLAG = TRUE ELSE ATTR.THREE.FLAG = FALSE
*
FIRST = TRUE
READNEXT ID THEN LIST.ON.FILE = TRUE ELSE LIST.ON.FILE = FALSE
*
*
LOOP
*
IF NOT(LIST.ON.FILE) OR FIRST THEN
*
LOOP
*
PRINT "Enter OLD acct prefix: ":; INPUT OLD.PREFIX
IF OLD.PREFIX EQ "KILL" THEN STOP
*
WHILE OLD.PREFIX EQ EMPTY DO REPEAT
*
LOOP
*
PRINT "Enter the replacement acct prefix: ":; INPUT ACCT.PREFIX
IF ACCT.PREFIX EQ "KILL" THEN STOP
*
WHILE ACCT.PREFIX EQ EMPTY DO REPEAT
*
FILE.PREFIX = OLD.PREFIX
IF MOVE.FLAG THEN FILE.PREFIX = ACCT.PREFIX
*
END; * of not list or first
*
LOOP
*
IF LIST.ON.FILE THEN
*
IF FIRST THEN
FIRST = FALSE
END ELSE
READNEXT ID ELSE STOP
END; * of not first
*
END ELSE
*
PRINT
PRINT "Enter the file id: ":; INPUT ID
IF ID EQ "KILL" THEN STOP
*
END
*
OPEN "DICT",ID TO INP.FILE THEN
READ ITEM FROM INP.FILE,OLD.PREFIX:".":ID THEN ITEM.ON.FILE = TRUE ELSE ITEM.ON.FILE = FALSE
END ELSE ITEM.ON.FILE = FALSE
*
WHILE NOT(ITEM.ON.FILE) DO REPEAT
*
IF ITEM.ON.FILE THEN
*
IF ATTR.THREE.FLAG THEN
ITEM.LINE = ITEM<3>
COMMA.CN = INDEX(ITEM.LINE,",",ONE)
IF COMMA.CN THEN
COMMA.START = ITEM.LINE[ONE,COMMA.CN]
ITEM.LINE  = ITEM.LINE[COMMA.CN+ONE,9999]
END ELSE COMMA.START = EMPTY
TMP.PREFIX = FIELD(ITEM.LINE,".",ONE)
OLD.SUFFIX = ITEM.LINE[COL2(),999]
NEW.LINE   = COMMA.START:ACCT.PREFIX:OLD.SUFFIX
END ELSE NEW.LINE = EMPTY
*
PRINT
PRINT OLD.PREFIX:".":ID
PRINT ITEM<1>
PRINT ITEM<2>
PRINT ITEM<3>
PRINT
IF ATTR.THREE.FLAG THEN
PRINT ">":TMP.PREFIX:" >":OLD.SUFFIX:" >>":NEW.LINE
PRINT
END
*
*
PRINT "Enter <cr> to continue: ":; INPUT RSP
*
IF RSP EQ EMPTY THEN
*
IF ATTR.TWO.FLAG OR ATTR.THREE.FLAG THEN
*
IF ATTR.TWO.FLAG THEN
ITEM<2> = ACCT.PREFIX
END
IF ATTR.THREE.FLAG THEN
ITEM<3> = NEW.LINE
END
WRITE ITEM ON INP.FILE,FILE.PREFIX:".":ID
PRINT
PRINT FILE.PREFIX:".":ID
PRINT ITEM<1>
PRINT ITEM<2>
PRINT ITEM<3>
PRINT
*
END; * of not empty
*
END; * of cr to continue
*
END ELSE
PRINT
PRINT "Item missing!"
END; * of item on file
*
WHILE TRUE DO REPEAT
*
STOP
END
~RCOM.CHANGES~
*PROGRAM: RCOM.CHANGES 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       MOVES CHANGES TO RCOM FILE FOR UPLOADING BY XTALK...
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
PROMPT ""; AM = CHAR(254)
AC = ""
PRINT
PRINT
PRINT "RCOM.CHANGES:      Moves changes to RCOM file for XTALK."
PRINT "____________"
PRINT
PRINT
LOOP
PRINT "Clear RCOM? ":; INPUT RSP
UNTIL RSP = "N" OR RSP = "Y" DO
REPEAT
IF RSP = "Y" THEN EXECUTE "CLEAR-FILE DATA RCOM"
PRINT
PRINT
PRINT "WHICH FILE <ALL>? ":; INPUT FLNAME; IF FLNAME = '' THEN FLNAME = "BPMENUSHLP"
PRINT
OPEN "RCOM" TO RCOM.FILE ELSE STOP
LOOP
PRINT "Enter change date (or file name starting with $): ":
INPUT RSP:; IF RSP = "" THEN STOP
IF RSP[1,1] # "$" THEN RSP = ICONV(RSP,"D")
UNTIL RSP # "" DO REPEAT
VC = 0
*
LOOP
VC = VC+1
UNTIL FLNAME<1,VC> = "" DO
OPEN FLNAME<1,VC>:".CHANGES" TO IN.FILE ELSE STOP
OPEN FLNAME<1,VC> TO BIG.FILE ELSE STOP
PRINT; PRINT; PRINT; PRINT "Moving ":FLNAME<1,VC>
READ.COUNT = 0
IF RSP[1,1] = "$" THEN FILE.ID = RSP ELSE
FILE.ID = OCONV(RSP,"D2"); FILE.ID = "$CHANGES.":FILE.ID[1,2]:FILE.ID[4,3]:FILE.ID[8,2]
END
LOOP
READ.COUNT = READ.COUNT+1
ID = FILE.ID:".":CHAR(READ.COUNT+64)
READ CONSOL.ITEM FROM IN.FILE,ID ELSE CONSOL.ITEM = ""
UNTIL CONSOL.ITEM = "" DO
PRINT; PRINT ID; PRINT
CON.AC = 1
LOOP LINE = CONSOL.ITEM<CON.AC> WHILE LINE = "&&&" DO CON.AC = CON.AC+1 REPEAT
LOOP
LINE = CONSOL.ITEM<CON.AC>; EOI = ''; IF LINE = "" THEN GOSUB CHECK.EOI
UNTIL EOI DO
IF LINE = "%%%" THEN GOSUB WRITE.ITEM ELSE AC = AC+1; CON.AC = CON.AC+1
REPEAT
REPEAT
GOSUB WRITE.ITEM
AC = ""
REPEAT
STOP
!
WRITE.ITEM: *
IF AC THEN
READ ITEM FROM BIG.FILE,ITEM.ID ELSE ITEM = ""
WRITE ITEM ON RCOM.FILE, "\":FLNAME<1,VC>:"\":ITEM.ID
END
IF CONSOL.ITEM = "" THEN RETURN
CON.AC = CON.AC+1
ITEM.ID = CONSOL.ITEM<CON.AC>
PRINT ITEM.ID
CON.AC = CON.AC+1
AC = 1
ITEM = ""
RETURN
!
CHECK.EOI: *
IF AC > 2 THEN
EOI = 1
FOR AC.TST = CON.AC+1 TO CON.AC+20
IF CONSOL.ITEM<AC.TST> # "" THEN EOI = ''
NEXT AC.TST
END
RETURN
!
END
~RECEIVE.ANYTHING~
*PROGRAM: RECEIVE.ANYTHING 
*
* RECEIVE.ANYTHING - RECEIVES ANYTHING (FROM XTALK FOR EXAMPLE...)
PROMPT ""
PRINT
PRINT "RECEIVE.ANYTHING:"
PRINT
PRINT "            TO WHAT FILE? ":; INPUT FILE.NAME
PRINT "                    ITEM? ":; INPUT ID
PRINT "DELETE BLANK LINES (Y/N)? ":; INPUT DLT; IF DLT = "Y" THEN DLT = 1 ELSE DLT = 0
PRINT
OPEN FILE.NAME ELSE STOP
ITM = ""
CTR = 0; AC = 0
PRINT "AFTER THE ITEM IS SENT ENTER '===' TO END TRANSMISSION..."
PRINT
EXECUTE "ECHO-OFF"
LOOP
INPUT LN:
UNTIL LN = "===" DO
IF NOT(DLT) OR LN # "" THEN
AC = AC+1
ITM<AC> = LN
PRINT "*":
CTR = CTR+1
IF CTR > 49 THEN PRINT; CTR = 0
END
REPEAT
WRITE ITM ON ID
EXECUTE "ECHO-ON"
STOP
END
~RENAME-FILE~
*PROGRAM: RENAME-FILE
*
* : *PROGRAM: CONTROL.AI.UTILITY
* : *  Moves 'D' pointers
*
! * : ***
! * : ***
* : * INITialization
* : * FUNCtions
$INCLUDE IBP STANDARD.FUNCTIONS
! * : ***
* : * TABLes
! * : ***
*
OPEN "MD" TO MD.FILE ELSE STOP
*
FIRST = TRUE
READNEXT ID THEN LIST.ON.FILE = TRUE ELSE LIST.ON.FILE = FALSE
*
IF LIST.ON.FILE THEN
PRINT "Enter the replacement prefix: ":; INPUT REPL.PREFIX
END ELSE REPL.PREFIX = EMPTY
*
*
LOOP
*
IF LIST.ON.FILE THEN
*
IF FIRST THEN
FIRST = FALSE
END ELSE
READNEXT ID ELSE STOP
END; * of not first
OLD.FILE = ID
OLD.PREFIX = FIELD(OLD.FILE,".",ONE)
OLD.SUFFIX = OLD.FILE[COL2() + ONE,999]
NEW.FILE   = REPL.PREFIX:OLD.SUFFIX
*
PRINT ">":OLD.PREFIX:" >":OLD.SUFFIX:" >>":NEW.FILE
PRINT
*
END; * of list on file
*
IF NOT(LIST.ON.FILE) THEN
*
LOOP
*
PRINT "Enter OLD file name: ":; INPUT OLD.FILE
*
READ OLD.ITEM FROM MD.FILE,OLD.FILE THEN OLD.ON.FILE = TRUE ELSE OLD.ON.FILE = FALSE
*
WHILE NOT(OLD.ON.FILE) AND OLD.FILE NE EMPTY DO REPEAT
*
END; * of not list
*
WHILE OLD.FILE NE EMPTY DO
*
LOOP
*
PRINT
PRINT "Enter NEW file name: ":; INPUT NEW.FILE
*
READ NEW.ITEM FROM MD.FILE,NEW.FILE THEN NEW.ON.FILE = TRUE ELSE NEW.ON.FILE = FALSE
*
WHILE NEW.ON.FILE AND NEW.FILE NE EMPTY DO REPEAT
*
PRINT "Enter <cr> to continue: ":; INPUT RSP
IF RSP EQ EMPTY THEN
IF NEW.FILE NE EMPTY THEN
IF OLD.ON.FILE AND NOT(NEW.ON.FILE) THEN
*
WRITE OLD.ITEM ON MD.FILE,NEW.FILE
DELETE MD.FILE,OLD.FILE
PRINT
PRINT
PRINT "OLD file ":OLD.FILE:" was moved to ":NEW.FILE
PRINT
*
END; * of files present and missing
END; * of not empty
END; * of cr to continue
*
REPEAT
*
STOP
END
~REPLACE.CHAR~
*PROGRAM: REPLACE.VM.SVM 
*
*PROGRAM: ?
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT "ENTER FILE NAME: ":; INPUT FILE.NAME
*
IF FILE.NAME[1,5] EQ "DICT " THEN
DICT.NAME = "DICT"
FILE.NAME = FILE.NAME[6,999]
END ELSE
DICT.NAME = ""
END
OPEN DICT.NAME,FILE.NAME TO INP.FILE ELSE STOP
*
PRINT
PRINT "Enter characters to find: ":
INPUT CHAR.TO.FIND
PRINT
*
PRINT
PRINT "Enter replacement characters: ":
INPUT CHAR.TO.SUB
PRINT
*
IF NOT(LEN(CHAR.TO.FIND)) THEN STOP
*
*
NEXT.ITEM: *
READNEXT PROG.NAME ELSE
PRINT "ENTER PROGRAM NAME: ":; INPUT PROG.NAME
IF PROG.NAME = "KILL" THEN STOP
IF PROG.NAME = "" THEN STOP
END
*
READ PROG.ITEM FROM INP.FILE,PROG.NAME ELSE GOTO NEXT.ITEM
*
*AC.MAX = DCOUNT(PROG.ITEM,AM)
*
LINE1 = PROG.ITEM<1>
IF LINE1[1,9] EQ "* " THEN
LINE1 = "*":LINE1[3,999]
PROG.ITEM<1> = LINE1
END
*
LOOP
MV.LOC = INDEX(PROG.ITEM,CHAR.TO.FIND,1)
WHILE MV.LOC DO
PROG.ITEM = PROG.ITEM[1,MV.LOC-1]:CHAR.TO.SUB:PROG.ITEM[MV.LOC+(LEN(CHAR.TO.FIND)),999]
REPEAT
*
WRITE PROG.ITEM ON INP.FILE,PROG.NAME
*
GOTO NEXT.ITEM
*
END
~REPLACE.CHAR.2~
*PROGRAM: REPLACE.CHAR.2 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT
PRINT "Enter file name (BP): ":
INPUT FILE.NAME
IF FILE.NAME = "" THEN FILE.NAME = "BP"
OPEN FILE.NAME TO INP.FILE ELSE STOP
*
DIM CHARS(50)
DIM OUT.CHARS(50)
*
MAT CHARS = ""
MAT OUT.CHARS = ""
*
CN = 0
LOOP
CN = CN + 1
PRINT
PRINT "Enter character to convert: ":
INPUT CHAR.TO.CONV
IF CHAR.TO.CONV = "END" OR CHAR.TO.CONV = "KILL" THEN STOP
WHILE CHAR.TO.CONV NE "" DO
*IF NOT(NUM(CHAR.TO.CONV)) OR LEN(CHAR.TO.CONV) NE 2 THEN
*CHAR.TO.CONV = SEQ(CHAR.TO.CONV)
*END
CHARS(CN) = CHAR.TO.CONV
PRINT
PRINT "Enter output character: ":
INPUT OUT.CHAR
IF OUT.CHAR = "END" OR OUT.CHAR = "KILL" THEN STOP
*IF NOT(NUM(OUT.CHAR)) OR LEN(OUT.CHAR) NE 2 THEN
*OUT.CHAR = SEQ(OUT.CHAR)
*END
OUT.CHARS(CN) = OUT.CHAR
REPEAT
*
IF CN EQ 1 THEN STOP
*
FIRST = 1
NAME.INP = ""
PRINT
LOOP
IF NOT(NAME.INP) THEN
READNEXT ID ELSE ID = "@"
IF ID = "@" AND FIRST THEN NAME.INP = 1
END ELSE ID = "@"
IF NAME.INP THEN
PRINT
PRINT "Enter ID: ":
INPUT ID
IF ID EQ "" OR ID EQ "END" OR ID EQ "KILL" THEN ID = "@"
END
FIRST = ""
*
WHILE ID NE "@" DO
*
PRINT
PRINT STR("-",20)
PRINT
PRINT ID:"   ":
*
READ ITEM FROM INP.FILE,ID THEN
*
CN = 0
LOOP
CN = CN + 1
CHAR.TO.CONV = CHARS(CN)
OUT.CHAR = OUT.CHARS(CN)
WHILE CHAR.TO.CONV NE "" AND CN LT 50 DO
*
*CHAR.TO.CONV = CHR(CHAR.TO.CONV)
*
MV.MAX = COUNT(ITEM,CHAR.TO.CONV)
*
IF MV.MAX THEN
MV.CN = 0
*
LOOP
MV.CN = MV.CN +1
MV.LOC = INDEX(ITEM,CHAR.TO.CONV,1)
WHILE MV.LOC DO
ITEM = ITEM[1,MV.LOC-1]:OUT.CHAR:ITEM[MV.LOC+1,99999]
REPEAT
* FOR NEXT OCCURANCE
*
PRINT ID:"   ":
PRINT CN "R#3":" ":MV.CN "R#4"
END; *# OF MV.MAX
*
REPEAT
* FOR CHARS
*
WRITE ITEM ON INP.FILE,ID
*
END ELSE
PRINT @(0,23):CLL:BELL:"Item is missing: ":ID
END
PRINT
REPEAT
END
~REPLACE.PARAM~
*PROGRAM: REPLACE.PARAM 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE STOP
PRINT
PRINT "Enter item name: ":
INPUT ITEM.NAME
PRINT
IF ITEM.NAME EQ "" THEN ITEM.NAME = "KBIL.INSTALL"
IF ITEM.NAME EQ "KILL" THEN STOP
*
READ INST.ITEM FROM SYS.FILE,ITEM.NAME ELSE STOP
*
LOOP
OLD.ITEM = INST.ITEM
PRINT
PRINT "Enter parameter: ":
INPUT PARAM.NUM
PRINT
IF PARAM.NUM EQ "KILL" THEN STOP
WHILE PARAM.NUM NE "" DO
IF NUM(PARAM.NUM) THEN
IF PARAM.NUM GT 0 THEN
PRINT
PRINT INST.ITEM<4,PARAM.NUM>
PRINT INST.ITEM<5,PARAM.NUM>
PRINT INST.ITEM<6,PARAM.NUM>
PRINT INST.ITEM<7,PARAM.NUM>
*
PRINT
PRINT "Enter new location: ":
INPUT NEW.NUM
IF NEW.NUM EQ "CH" THEN
PRINT ">":INST.ITEM<4,PARAM.NUM>
PRINT ">":
INPUT RSP
IF RSP NE "" THEN INST.ITEM<4,PARAM.NUM> = RSP
*
PRINT ">":INST.ITEM<5,PARAM.NUM>
PRINT ">":
INPUT RSP
IF RSP NE "" THEN INST.ITEM<5,PARAM.NUM> = RSP
*
PRINT ">":INST.ITEM<6,PARAM.NUM>
PRINT ">":
INPUT RSP
IF RSP NE "" THEN INST.ITEM<6,PARAM.NUM> = RSP
*
PRINT ">":INST.ITEM<7,PARAM.NUM>
PRINT ">":
INPUT RSP
IF RSP NE "" THEN INST.ITEM<7,PARAM.NUM> = RSP
*
END ELSE IF NUM(NEW.NUM) THEN
IF NEW.NUM GT 0 AND NEW.NUM NE PARAM.NUM THEN
MAX.CN = COUNT(INST.ITEM<4>,VM)+1
IF NEW.NUM GT MAX.CN THEN NEW.NUM = MAX.CN+1
DEL INST.ITEM<4,PARAM.NUM,0>
DEL INST.ITEM<5,PARAM.NUM,0>
DEL INST.ITEM<6,PARAM.NUM,0>
DEL INST.ITEM<7,PARAM.NUM,0>
*
IF NEW.NUM GE PARAM.NUM THEN NEW.NUM = NEW.NUM - 1
INS OLD.ITEM<4,PARAM.NUM> BEFORE INST.ITEM<4,NEW.NUM>
INS OLD.ITEM<5,PARAM.NUM> BEFORE INST.ITEM<5,NEW.NUM>
INS OLD.ITEM<6,PARAM.NUM> BEFORE INST.ITEM<6,NEW.NUM>
INS OLD.ITEM<7,PARAM.NUM> BEFORE INST.ITEM<7,NEW.NUM>
*
END
END
END
END
REPEAT
WRITE INST.ITEM ON SYS.FILE,ITEM.NAME
END
~REPLACE.VM.SVM~
*PROGRAM: REPLACE.VM.SVM 
*
*PROGRAM: ?
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT "ENTER FILE NAME: ":; INPUT FILE.NAME
IF FILE.NAME[1,5] EQ "DICT " THEN
DICT.NAME = "DICT"
FILE.NAME = FILE.NAME[6,999]
END ELSE
DICT.NAME = ""
END
OPEN DICT.NAME,FILE.NAME TO INP.FILE ELSE STOP
*
NEXT.ITEM: *
READNEXT PROG.NAME ELSE
PRINT "ENTER PROGRAM NAME: ":; INPUT PROG.NAME
IF PROG.NAME = "KILL" THEN STOP
IF PROG.NAME = "" THEN STOP
END
*
READ PROG.ITEM FROM INP.FILE,PROG.NAME ELSE GOTO NEXT.ITEM
*
*AC.MAX = DCOUNT(PROG.ITEM,AM)
*
LINE1 = PROG.ITEM<1>
IF LINE1[1,9] EQ "* PROGRAM" THEN
LINE1 = "*":LINE1[3,999]
PROG.ITEM<1> = LINE1
END
*
MV.MAX = COUNT(PROG.ITEM,VM)
IF MV.MAX THEN
MV.CN = 0
LOOP
MV.CN = MV.CN + 1
WHILE MV.CN LE MV.MAX DO
MV.LOC = INDEX(PROG.ITEM,VM,1)
IF MV.LOC THEN
PROG.ITEM = PROG.ITEM[1,MV.LOC-1]:'":VM:"':PROG.ITEM[MV.LOC+1,999]
END
REPEAT
END
*@@@
SV.MAX = COUNT(PROG.ITEM,SVM)
IF SV.MAX THEN
SV.CN = 0
LOOP
SV.CN = SV.CN + 1
WHILE SV.CN LE SV.MAX DO
SV.LOC = INDEX(PROG.ITEM,SVM,1)
IF SV.LOC THEN
PROG.ITEM = PROG.ITEM[1,SV.LOC-1]:'":SVM:"':PROG.ITEM[SV.LOC+1,999]
END
REPEAT
END
*
IF MV.MAX OR SV.MAX THEN
WRITE PROG.ITEM ON INP.FILE,PROG.NAME
END
*
GOTO NEXT.ITEM
*
END
~ROSDOWN~
*PROGRAM: ROSDOWN 
*
STX = CHAR(2)
ETX = CHAR(3)
ESC = CHAR(27)
FM = CHAR(254)
*
50 *
PRINT; PRINT
PRINT "Enter FROM file (file on host to download) ":
INPUT FROM
IF FROM = "END" THEN STOP
DICT = FIELD(FROM," ",1)
IF DICT EQ "DICT" THEN FROM = FIELD(FROM," ",2) ELSE DICT = ""
OPEN DICT,FROM TO FILE.FROM ELSE PRINT "Invalid file"; GOTO 50
*
75 *
PRINT; PRINT "Enter TO file (REV RCOM file e.g. C:ROS10066, be careful!) ":
INPUT TO.FN
IF TO.FN = "END" THEN STOP
*
OVER = 0
TO.FN = TO.FN:".01"
GOSUB 500
*
100 *
READNEXT ID ELSE PRINT ETX; STOP
READ REC FROM FILE.FROM,ID ELSE GOTO 100
REC.LEN = LEN(ID)+1+LEN(REC)
IF TOT.LEN+REC.LEN+5 >= 65530 THEN
PRINT ETX
PRINT; PRINT; PRINT "Hit RETURN for next frame ":
INPUT RESP
IF RESP = "END" THEN STOP
OVER = OVER+1
GOSUB 500
END
*
PRINT ("00000":REC.LEN) "R#5":ID:FM:REC:
TOT.LEN=TOT.LEN+REC.LEN+5
GOTO 100
*
500 *
PRINT ESC:"D":ESC:"F":TO.FN:OVER
PRINT STX:1:
TOT.LEN = 1
RETURN
END
~ROUTE.LOGON~
*PROGRAM: ROUTE.LOGON 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       CHECKS IF PH-DATA CONTAINS STACKED INPUT TO RUN THEN
*                    CHAINS TO MAIN MENU
* DATE WRITTEN:      12 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT CHAIN.TO:
OPEN "PH-DATA" TO PH.FILE ELSE GOTO 900
READ STACK FROM PH.FILE, PORT ELSE GOTO 900
IF STACK = "" THEN GOTO 900
CHAIN.TO = STACK<1>
DEL STACK<1>
LOOP UNTIL STACK = "" DO
DATA STACK<1>
DEL STACK<1>
REPEAT
DELETE PH.FILE, PORT
900 *
CHAIN CHAIN.TO
END
~RVE~
*PROGRAM: RVE 
*
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT RVE:
END
~SECONDS.SUBR.CONV~
SUBROUTINE SECONDS.SUBR.CONV(TMP.TM,ORSLT)
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP SECONDS.INCL.CONV
*
RETURN
*
END
~SET.FILE~
*PROGRAM: SET.FILE 
$INCLUDE IBP STANDARD.FUNCTIONS
INPUT ACCOUNT
INPUT FILENAME
OPEN "MD" TO MDI.FILE ELSE STOP
WRITE "Q":AM:ACCOUNT:AM:FILENAME:AM ON MDI.FILE,"QFILE"
END
~SET.FONT~
*PROGRAM:           SET.FONT
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       SETS FONT TO COMPRESSED OR REGULAR
* DATE WRITTEN:      DD MMM 82
* DATE RELEASED:     DD MMM 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
INPUT COM.OR.REG
* CLEARDATA; * REV ONLY
IF NOT(COM.OR.REG) THEN
COM.OR.REG = 1
LOOP
PRINT CLB:"Enter (S)pool or (P)rint locally: ":; INPUT RSP:
IF RSP = "KILL" THEN STOP
UNTIL RSP = "S" OR RSP = "P" DO
REPEAT
* IF RSP = "S" THEN PCPERFORM "SPOOL / NO BANNER / NO TABS"; * REV ONLY
* IF RSP = "P" THEN PCPERFORM "ENDSPOOL"; * REV ONLY
END
IF COM.OR.REG = 1 THEN COM.OR.REG = 5 ELSE COM.OR.REG = 4
OPEN "PAR" TO PAR.FILE ELSE STOP
IF OPSYS = "U" THEN PTR.TYPE = "Q0" ELSE PTR.TYPE = "REG"
READ PTR.CNTL FROM PAR.FILE,"PRINTER.":PTR.TYPE ELSE PTR.CNTL = ""
PTR.ON = ""; COM.FONT = ""
LOOP UNTIL PTR.CNTL<2> = "" DO PTR.ON = PTR.ON:CHAR(PTR.CNTL<2,1>); DEL PTR.CNTL<2,1> REPEAT
LOOP UNTIL PTR.CNTL<COM.OR.REG> = "" DO COM.FONT = COM.FONT:CHAR(PTR.CNTL<COM.OR.REG,1>); DEL PTR.CNTL<COM.OR.REG,1> REPEAT
CALL PRINTER.ON(STAT); IF NOT(STAT) THEN PRINT PTR.ON:COM.FONT:
* CLEARDATA; * REV ONLY
STOP
END
~SET.USER0~
*PROGRAM: SET.USER0
*SET.USER0 - INITIALIZE @USER0 TO NULL - RUN AT LOGON OR LOGTO...
*
*%%STD%%=USER0 = "";  * STD ONLY
USER0 = ""; * ULT ONLY
* @USER0 = ""; * REV ONLY
*%%MDD%%=USER0 = ""; * MDD ONLY
STOP
END
~SHARE.DICTS~
*PROGRAM: SHARE.DICTS 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       CONVERT FILES TO SHARING OF DICTIONARIES WITH
*                    THE DEVELOPMENT ACCOUNT.
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "MD" TO MD.FILE ELSE PRINT "Can't open MD"
PRINT "DICTIONARY ACCOUNT: ":; INPUT DICT.ACCT
IF DICT.ACCT = "" THEN STOP
PRINT "      DATA ACCOUNT: ":; INPUT DATA.ACCT
IF DATA.ACCT = "" THEN STOP
PRINT
PRINTER ON
PRINT FF:"CONVERT FILES TO DICTIONARY SHARING..........":SPACE(20):TIMEDATE()
PRINT
PRINT
PRINT
PRINT "DICTIONARY ACCOUNT: ":DICT.ACCT
PRINT "      DATA ACCOUNT: ":DATA.ACCT
PRINT
PRINT
PRINTER OFF
INPUT.FLNAME: *
PRINT "FILE: ":; INPUT FLNAME
IF FLNAME = "" THEN STOP
PRINTER ON
PRINT
PRINT
PRINT
PRINT FLNAME:"......"
PRINTER OFF
OPEN "DICT", FLNAME TO FL.FILE ELSE PRINT "Can't open DICT ":FLNAME; GOTO INPUT.FLNAME
DATA.EXISTS = 0
READ DATA.PTR FROM FL.FILE, FLNAME THEN
IF DATA.PTR<1>[1,1] = "D" THEN
FL.MOD = DATA.PTR<3>
FL.SEP = DATA.PTR<4>
EXLN = "DELETE-FILE DATA ":FLNAME
GOSUB EXECUTE.LINE
EXLN = "CREATE-FILE DICT ":DATA.ACCT:".":FLNAME:" ":FL.MOD:",":FL.SEP
GOSUB EXECUTE.LINE
DATA.EXISTS = 1
END
END
EXLN = "DELETE-FILE DICT ":FLNAME
GOSUB EXECUTE.LINE
ITM = "Q":AM:DICT.ACCT:AM:FLNAME
IF DATA.EXISTS THEN ITM = ITM:",":DATA.ACCT:".":FLNAME
WRITE ITM ON MD.FILE, FLNAME
IF DATA.EXISTS THEN
OPEN "DICT", FLNAME TO FL.FILE ELSE PRINT "Can't open DICT ":FLNAME:"*"; GOTO INPUT.FLNAME
ITM = "Q":AM:DATA.ACCT:AM:DATA.ACCT:".":FLNAME
WRITE ITM ON FL.FILE, DATA.ACCT:".":FLNAME
OPEN FLNAME TO FL.FILE ELSE PRINT "Can't open ":FLNAME; GOTO INPUT.FLNAME
DELETE FL.FILE, DATA.ACCT:".":FLNAME
END
GOTO INPUT.FLNAME
EXECUTE.LINE: *
PRINTER ON
OUTLN = ""
PRINT "    ":EXLN
EXECUTE EXLN, //OUT. > OUTLN
FOR I = 1 TO 5
IF OUTLN<I> # "" THEN PRINT "        ":OUTLN<I>
NEXT I
PRINTER OFF
RETURN
!
END
~STANDARD.FUNCTIONS.CALL~
SUBROUTINE STANDARD.FUNCTIONS.CALL(BELL,LF,FF,CR,AM,VM,SVM,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF)
*
PORT = (FIELD(ICONV(0,"U50BB")," ",1)+100)[2,2]
OPEN "DICT","TERMINAL.FILE" TO TERM.TEMP THEN
READV TT FROM TERM.TEMP,"TERMINALS",PORT+1 ELSE TT = "R"
END ELSE
TT = "R"
END
*
INCLUDE STANDARD.FUNCTIONS FROM IBP
*OVERRIDE
*
RETURN
END
~STANDARD.FUNCTIONS.CALL1~
SUBROUTINE STANDARD.FUNCTIONS.CALL1(BELL,LF,FF,CR,AM,VM,SVM,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE)
*
PORT = (FIELD(ICONV(0,"U50BB")," ",1)+100)[2,2]
OPEN "DICT","TERMINAL.FILE" TO TERM.TEMP THEN
READV TERM FROM TERM.TEMP,"TERMINALS",PORT+1 ELSE TERM = "R"
END ELSE
TERM = "R"
END
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
RETURN
END
~STANDARD.FUNCTIONS.CALL2~
SUBROUTINE STANDARD.FUNCTIONS.CALL2
*SUBROUTINE STANDARD.FUNCTIONS.CALL2(BELL,LF,FF,CR,AM,VM,SVM,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE,TT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.READ
*OVERRIDE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
RETURN
END
~STANDARD.FUNCTIONS.CALL3~
SUBROUTINE STANDARD.FUNCTIONS.CALL3
*SUBROUTINE STANDARD.FUNCTIONS.CALL3(BELL,LF,FF,CR,AM,VM,SVM,ESC,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF,REC.ON,REC.OFF,COL.ON,COL.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE,TT,RSP,RSPBUF,TM.MAX,PHANTOM.FLAG,AUTO.RUNNER,RUN.TYPE,CURSOR.KEYS)
*
$INCLUDE IBP STANDARD.FUNCTIONS.READ
*OVERRIDE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
RETURN
END
~STANDARD.FUNCTIONS.CALL4~
SUBROUTINE STANDARD.FUNCTIONS.CALL4
*SUBROUTINE STANDARD.FUNCTIONS.CALL3(BELL,LF,FF,CR,AM,VM,SVM,ESC,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF,REC.ON,REC.OFF,COL.ON,COL.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE,TT,LH,SEC.USER.ID,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,NUMC,REDISP,PHAN.RUN,AUTO.RUN,TYPE.RUN,DISP.ONLY,PROCBUF,CURSOR.KEYS,SEC.USER.ID)
*
$INCLUDE IBP STANDARD.FUNCTIONS.READ
*OVERRIDE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
RETURN
END
~STANDARD.FUNCTIONS.CHARACTERS~
*CODE.SEGMENT: STANDARD.FUNCTIONS.CHARACTERS
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: JUN 85
* Used with permission 1986, 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
* (c) Copyright 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990
* Axion Computer Software Ltd.
*
STB = "|"
STX = "~"
ESC = "`"
PICK.ESC = "<PCK>"
NUL = CHAR(0)
*
!
STANDARD.FUNCTIONS: *
*
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13)
*ESC TO CHAR(27), PICK.ESC TO CHAR(??),NUL TO CHAR(0)
*STB TO "|", STX TO CHAR(2), ETX TO CHAR(3)
*
* SUB-VALUE MARK, VALUE MARK, ATTRIBUTE MARK
*FIELD ATTR MARK, FIELD VALUE MARK, FIELD SUB-VALUE MARK
*KEY SEPARATOR, FIELD SEPARATOR
EQUATE SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254),
FAM TO "@",FVM TO "*",FSVM TO "#",
KSEP TO "@",DSEP TO "*"
*
EQUATE TRUE TO 1, FALSE TO ""
*
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+1000)[2,3]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
T132.ON = ""; T132.OFF = ""
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
* IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
~STMT.INCR.BLOCK~
*PROGRAM: SET.REMOTE
*
* Allows entry of lines into remote procedure proc
* in KBIL-INSTALL-5.MD and SYS
*
* AUTHOR: DAVID G. HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT: (C) 1992 MACROSCOPE DESIGN MATRIX
*            ALL RIGHTS RESERVED
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "LISTS" TO LISTS.FILE ELSE STOP
OPEN "SYS" TO SYS.FILE ELSE STOP
OPEN "CNT" TO CNT.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
* PROC.FL = TRUE
* PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
! MAIN LOOP
*
READ BLEN FROM CNT.FILE,"STMT.BLCK.LEN" ELSE BLEN = ZERO
*
READ BCN FROM CNT.FILE,"STMT.RUN.CN" ELSE BCN = ZERO
BCN = BCN + ONE
IF BCN GT 1000 THEN
ABORT "TOO MANY RUNS DONE"
END
WRITE BCN ON CNT.FILE,"STMT.RUN.CN"
*
BLEN = BLEN + 500
*
IF BLEN GT 31000 THEN BLEN = 500
*
WRITE BLEN ON CNT.FILE,"STMT.BLCK.LEN"
*
STOP
*
END
~SYS.COMM.WAIT.QUIET.SUB~
SUBROUTINE SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,COMM.WAIT.KEY,COMM.WAIT.QUIET,COMM.WAIT.MAX,COMM.WAIT.ERROR,COMM.WAIT.PAUSE,COMM.WAIT.CLEAR)
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Communications Design)
*
*   DATE: 10 FEB 89
*
* VARIABLES:
*        IN: COMM.WAIT.QUIET      -    Number of seconds continuous quiet
*            COMM.WAIT.MAX        -    Max length of wait
*            COMM.WAIT.ERROR      -    Max length error flag (null/1)
*            COMM.WAIT.PAUSE      -    # of RQMs to pause each loop
*            COMM.WAIT.CLEAR      -    max # of char's before clearing the
*                                        input buffer (null if don't clear)
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
COMM.PARAM = EMPTY; TRANS.PARAM = EMPTY
*
$INCLUDE IBP SYS.INCL.COMM.WAIT.QUIET
*
RETURN
*
END
~SYS.DEL.VALUE~
*PROGRAM: SYS.DEL.VALUE 
*
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#
PRINT "ENTER FILE: ":; INPUT FILE.NAME
OPEN FILE.NAME TO INP.FILE ELSE STOP
*#
LOOP
*#
LOOP
*#
ITEM.CONT = TRUE
*#
PRINT
PRINT "ENTER ITEM: ":; INPUT ITEM.NAME
PRINT
ITEM.NOT.ON.FILE = FALSE
*#
READ ITEM FROM INP.FILE,ITEM.NAME ELSE ITEM.NOT.ON.FILE = TRUE
*#
IF ITEM.NAME EQ "END" THEN 
ITEM.NOT.ON.FILE = FALSE
ITEM.CONT = FALSE
END
*#
WHILE ITEM.NOT.ON.FILE DO REPEAT
*#
WHILE ITEM.CONT DO
*#
LOOP
PRINT
PRINT "ENTER MULTI-VALUE #: ":; INPUT MULTI.VALUE
*#
IF NOT(NUM(MULTI.VALUE)) THEN MULIT.VALUE = 100
*#
IF MULTI.VALUE LT 1 THEN MULTI.VALUE = 0
*#
IF MULTI.VALUE GE 1 THEN
AM.CN.MAX = DCOUNT(ITEM,AM)
AM.CN.VM = DCOUNT(ITEM,VM) / AM.CN.MAX
FOR AM.CN = 1 TO AM.CN.MAX
PRINT AM.CN "R#3":") ":ITEM<AM.CN,MULTI.VALUE>
NEXT AM.CN
*#
PRINT "DELETE THIS MULTIVALUE: ":; INPUT YES.NO
PRINT
IF YES.NO EQ "Y" THEN
PRINT BELL
FOR AM.CN = 1 TO AM.CN.MAX
ITEM = DELETE(ITEM,AM.CN,MULTI.VALUE)
NEXT AM.CN
PRINT BELL
END
*#
END; *# OF MULIT.VALUE GT 0
*#
WHILE MULTI.VALUE NE 0 DO REPEAT
*#
WRITE ITEM ON INP.FILE,ITEM.NAME
*#
REPEAT
*#
END
~SYS.DIAL.USER~
*PROGRAM: SYS.DIAL.USER
*
*
PRINT
*
*
END
~SYS.ITM.LCK~
SUBROUTINE SYS.ITM.LCK(FILE.NAME,ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSVD,OPER,EXP.TM,LCK.CSEG,LCK.CSEG.LOC,TMPC,LCK.STAT)
* VERSION: 951108 1.0
*
* PROGRAM:           SYS.ITM.LCK
* AUTHOR:            DAVID HORSMAN - AXION
* DESCRIPTION:       CONTROL LOCKS
*
* PASSED TO CALLING PROGRAM:
*     LCK.STAT      MEANING
*     ____      __________________________________
*        0      SUCCESSFULLY LOCKED
*      nnn      ALREADY LOCKED AT TERMINAL nnn - 1
*      900      SYSTEM LEVEL LOCK PRESENT
*      999      OPERATOR 'KILL' REQUEST
*
* IF RSP EQ 'OVERRIDE'    -   OPERATOR 'OVERRIDE' REQUEST
* 'RETRY' MEANS RETRYING TO LOCK *** WITHIN THIS PROGRAM ***
* 'T/O' MEANS A THREE SECOND TIMEOUT BEFORE RETRYING
*
* PASSED TO THIS PROGRAM BY LCK.STAT: 
*       ZERO = Normal: RETRY, MSG, INPUT (T/O)
*       -ONE = No RETRY if already locked, MSG, INPUT (IMMED)
*       -TWO = No RETRY, MSG, INPUT <cr> if locked (IMMED)
*       -3   = RETRY, MSG, No INPUT if already locked (T/O)
*       -4   = No RETRY, MSG, No INPUT if already locked (IMMED)
*       -5   = No RETRY, No MSG, No INPUT if already locked (IMMED)
*       -6   = No RETRY, No MSG, No INPUT, OVERRIDE if locked (IMMED) ** DANGEROUS **
*       -7   = RETRY, No MSG, No INPUT, OVERRIDE if locked (T/O) ** DANGEROUS **
*       -8   = RETRY, Short Msg, No INPUT if locked (T/O)
*       -9   = RETRY, Short Msg, No INPUT if locked (IMMED)
*
* LCK.LEVEL
*       0    = GLOBAL LEVEL LOCK
*       1    = WAN
*       2    = LAN
*       3    = SYSTEM
*       4    = ACCOUNT
*
* LCK.CLASS
*       0    = LOCK item normally
*       1    = Lock item normally, owned by this program
*
* LCK.PROG   = Program Placing Lock (any valid if empty)
*
* LCK.RSVD
*       0    = STANDARD
*       1    = RESERVE IF LOCKED
*
* OPER = Operator
*
* EXP.TM = Time until expires (TM + EXP.TM = Time lock expirts)
*
* STAT = as explaned above
*
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LCK.VAR.EQUATES
*
VS = "1.0s"
*
LCK.TRACE = TRUE
LCK.STAT = FALSE
LCK.LOG = FALSE
IF COUNT(FILE.NAME,"#") THEN
LCK.PROG = FIELD(FILE.NAME,"#",TWO)
FILE.NAME = FIELD(FILE.NAME,"#",ONE)
END
LCK.ID = FILE.NAME:"*":ITM.ID
!
READ.IT: * ATTEMPT TO READ THE LOCK ITEM
*
MSG = EMPTY; TRY.CN = 1
*
LOOP
*
IF MSG NE EMPTY THEN IF LCK.TYPE GE -4 THEN
PRINT CLB2:MSG:; * of TYPE
PRINT CLB1:"Lock attempt no. ":TRY.CN-ONE:; * of TYPE
END; * of TYPE
IF MSG NE EMPTY AND (LCK.TYPE EQ -8 OR LCK.TYPE EQ -9) THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
*
LCK.LOCKED = FALSE
*
* LOCK ITM.FILE, ITM.ID THEN; * REV ONLY
* GOTO LCK.IT; * REV ONLY
* END ELSE; * REV ONLY
* MSG = FILE.NAME:" ":ITM.ID:" in use."; * REV ONLY
* LCK.LOG = ONE
* GOSUB LCK.IT; * REV ONLY
* IF STATUS() NE ONE THEN; * REV ONLY
* LCK<LCK$ACCT,LOC> = "UNKNOWN"; * REV ONLY
* LCK<LCK$PORT,LOC> = 999; * REV ONLY
* END; * REV ONLY
* END; * REV ONLY
*
* ULT ONLY
READU LCK FROM LCK.FILE,LCK.ID LOCKED LCK.LOCKED = TRUE ELSE
LCK = ""
GOTO LCK.IT
END
*
IF LCK.LOCKED THEN LCK = EMPTY 
*
IF LCK<LCK$PORT,ONE> EQ PORT THEN
MSG = "Lock is already present for this port!"
LCK.LOG = TWO
* IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
* IF (LCK.TYPE EQ -8 OR LCK.TYPE EQ -9) THEN PRINT @(ZERO,23):RVB:"[????]":RVE:
GOTO LCK.IT
END
*
* ULT ONLY
IF NOT(LCK.LOCKED) THEN RELEASE LCK.FILE,LCK.ID
*
IF LCK.LOCKED THEN
*
MSG = "LCK control information is not available yet . . . "
LCK.LOG = 3
LCK.STAT = 900
*
END ELSE
*
IF OPSYS NE "R" THEN
*
PORT.NUM = LCK<LCK$PORT,ONE>
ACCT.NUM = LCK<LCK$ACCT,ONE>
LCK.DT = LCK<LCK$DT,ONE>
LCK.TM = LCK<LCK$TM,ONE,ONE>
LCK.ELP = ((DATE() - LCK.DT) * 86400) + (TIME() - LCK.TM)
IF LCK.ELP GT 7200 THEN
MSG = "Lock item is ":OCONV(LCK.ELP,"MTS"):" hours old and has expired."
LCK.LOG = 4
IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
IF (LCK.TYPE EQ -8 OR LCK.TYPE EQ -9) THEN PRINT @(ZERO,23):RVB:"[EXPR]":RVE:
GOTO LCK.IT
END
*
LCK.DT = OCONV(LCK.DT,"D2")
LCK.DT = FIELD(LCK.DT," ",ONE):" ":FIELD(LCK.DT," ",2)
*
LCK.TM.DISP = OCONV(LCK.TM,"MTS")
*
MSG = FILE.NAME:" ":ITM.ID:" in use by ":PORT.NUM:" ":ACCT.NUM:" (":LCK.DT:" ":LCK.TM.DISP:" for ":OCONV(LCK.ELP,"MTS"):")"
LCK.LOG = 5
*
END; * OF OPSYS NOT 'R'
*
LCK.STAT = PORT.NUM + ONE
*
IF LCK.TYPE EQ -ONE OR LCK.TYPE EQ -TWO OR LCK.TYPE EQ -9 OR (LCK.TYPE LE -4 AND LCK.TYPE GE -6) THEN TRY.CN = 999
*
END; * of lock not locked
*
NEXT.TRY: *
*
* WHILE TRY.CN LT 5 DO; * REV ONLY
* ULT ONLY
WHILE TRY.CN LT 5 AND NOT(SYSTEM(11)) DO
IF LCK.TYPE GE -4 THEN PRINT CLB2:MSG:
IF (LCK.TYPE EQ -8 OR LCK.TYPE EQ -9) THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
TRY.CN = TRY.CN + ONE
FOR COUNTER = ONE TO 3
RQM
NEXT COUNTER
REPEAT
*
IF LCK.TYPE LE -6 AND LCK.TYPE GE -7 AND OPSYS NE "R" THEN
MSG = "Lock OVERRIDE in effect. Now locked by your port"; * of TYPE
LCK.LOG = 6
GOTO LCK.IT; * of TYPE
END; * of TYPE
*
IF LCK.TYPE GE -4 THEN
PRINT CLB1:MSG:; * of TYPE
PRINT CLB2:"Can't lock this information.":; * of TYPE
END; * of TYPE
IF (LCK.TYPE EQ -8 OR LCK.TYPE EQ -9) THEN PRINT @(ZERO,23):RVB:"[FAIL]":RVE:
IF LCK.TYPE EQ -TWO THEN
PRINT BELL:" Enter <cr>: ":
END
*
IF LCK.TYPE LE -TWO THEN GOTO RELEASE.IT
*
RQM; RQM
PRINT BELL:CLB1:MSG:
* ULT ONLY
PRINT CLB2:"Try to lock it again (<cr>/N/OVERRIDE)? ":
* PRINT CLB2:"Try to lock it again (<cr>/N)? ":; * REV ONLY
* ULT ONLY
INPUTCLEAR
IF LCK.TYPE GE -2 THEN INPUT RSP:; IF RSP EQ "KILL" THEN LCK.STAT = 999; GOTO RELEASE.IT
IF RSP EQ "OVERRIDE" AND OPSYS NE "R" THEN
* ULT ONLY
DELETE LCK.FILE,LCK.ID
* ULT ONLY
LCK.LOG = 6
* ULT ONLY
PRINT CLB1:CLB2:; GOTO READ.IT
END
IF RSP NE "N" THEN
IF MSG NE EMPTY AND LCK.TYPE GE -4 THEN PRINT CLB1:CLB2:
IF MSG NE EMPTY AND (LCK.TYPE EQ -8 OR LCK.TYPE EQ -9) THEN PRINT @(ZERO,23):RVB:"[WAIT]":RVE:
GOTO READ.IT
END
*
GOTO RELEASE.IT
*
!
*
LCK.IT: * LOCK THE ITEM
*
IF MSG NE EMPTY AND LCK.TYPE GE -4 THEN
RQM; * of TYPE
PRINT CLB1:CLB2:; * of TYPE
END; * of TYPE
IF MSG NE EMPTY AND (LCK.TYPE EQ -8 OR LCK.TYPE EQ -9) THEN PRINT @(ZERO,23):RVB:"[LOCK]":RVE:
*
**LCK    = EMPTY
IF LCK.LOG EQ 4 OR LCK.LOG EQ 6 THEN
LOC = ONE
TMP = DCOUNT(LCK,AM)
FOR TMP1 = ONE TO TMP
INS "" BEFORE LCK<TMP1,ONE>
NEXT TMP1
LCK<LCK$MSG,TWO,-ONE> = "Lock overriden by port ":PORT
END ELSE
LOCATE PORT IN LCK<LCK$PORT> SETTING LOC ELSE NULL
END
*
LCK<LCK$PORT,LOC> = PORT
LCK<LCK$ACCT,LOC>  = ACCT
LCK<LCK$DT,LOC>   = DATE()
LCK<LCK$TM,LOC,-ONE>   = TIME()
LCK<LCK$TYPE,LOC,-ONE> = LCK.TYPE
LCK<LCK$CLASS,LOC,-ONE> = LCK.CLASS
LCK<LCK$MSG,LOC,-ONE>  = MSG
LCK<LCK$PROG,LOC,-ONE> = LCK.PROG
LCK<LCK$CSEG,LOC,-ONE> = LCK.CSEG:"+":LCK.CSEG.LOC
**LCK<LCK$RSVD,LOC,-ONE> = LCK.RSVD
IF LCK.RSVD THEN
IF LCK<LCK$PORT,ONE> NE PORT THEN
IF LCK<LCK$RSVD,ONE> THEN
MSG = "RSVD"
LCK.LOG = 8
END
*GOSUB RSV.IT; * : *
END
END
LCK<LCK$STAT,LOC,-ONE> = LCK.STAT
*
* ULT ONLY
WRITE LCK ON LCK.FILE,LCK.ID
*
IF LCK.TRACE THEN
TMP = LCK<LCK$DT,ONE,ONE>
READU LCK.STATS FROM LCK.FILE,PORT:"*":TMP ELSE LCK.STATS = EMPTY
HR = INT(LCK<LCK$TM,ONE,ONE> / 3600)
HR = ("00":HR) "R#2"
LOCATE FILE.NAME IN LCK.STATS<ONE> SETTING LOC ELSE
INS FILE.NAME BEFORE LCK.STATS<ONE,LOC>
INS "" BEFORE LCK.STATS<TWO,LOC>
INS "" BEFORE LCK.STATS<3,LOC>
END
LOCATE HR IN LCK.STATS<TWO,LOC> SETTING LOC1 ELSE
INS HR BEFORE LCK.STATS<TWO,LOC,LOC1>
INS "" BEFORE LCK.STATS<3,LOC,LOC1>
END
LCK.STATS<3,LOC,LOC1> = LCK.STATS<3,LOC,LOC1> + 1
WRITE LCK.STATS ON LCK.FILE,PORT:"*":TMP
END
*
IF LCK.LOG THEN
TMP = FIELD("*LOCKED*DUPE*BUSY*EXPIRED*LOCKED*OVERRIDE*GONE*RSVD*","*",LCK.LOG + ONE)
READU LOG.ITM FROM LCK.FILE,"LCK_LOG_":TMP ELSE LOG.ITM = EMPTY
IF LEN(LOG.ITM) GT 1000 THEN
WRITE LOG.ITM ON LCK.FILE,"LCK_LOG_":TMP:"@":("00000":DATE()) "R#5":"@":("000000":TIME()) "R#5":"@":PORT:"@":ACCT:"@":OPER
LOG.ITM = EMPTY
END
** PLACE TO CHECK SIZE AND COPY ??? (D) TO DATE*TIME*???
LOG.ITM<-ONE> = "~LCK ":LCK.ID:"~"
LOG.ITM<-ONE> = LCK
LOG.ITM<-ONE> = "~END~"
WRITE LOG.ITM ON LCK.FILE,"LCK_LOG_":TMP
END
LCK.STAT = FALSE
*
RETURN
*
!
*
RSV.IT: *
*
*@@@@@@@@@@@@2
IF LCK.RSVD THEN
LCK<LCK$RSVD,-ONE> = PORT
END
*
RETURN
*
!
*
RELEASE.IT: *
*
* ULT ONLY
RELEASE LCK.FILE,LCK.ID
*
RETURN
*
END
~SYS.ITM.RLS~
SUBROUTINE SYS.ITM.RLS(FILE.NAME,ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,LCK.CSEG,LCK.CSEG.LOC,TMPC,LCK.STAT)
* PROGRAM:           SYS.ITM.RLS
* AUTHOR:            DAVID HORSMAN - AXION
* DESCRIPTION:       UNLOCK AN ITEM
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
$INCLUDE IBP LCK.VAR.EQUATES
*
VS = "1.0s"
*
LCK.TRACE = TRUE
*
! ATTEMPT TO READ THE LOCK ITEM
*
LCK.ID = FILE.NAME:"*":ITM.ID
READU LCK FROM LCK.FILE,LCK.ID ELSE 
MSG = "was missing!"
LCK.LOG = 7
GOSUB REPORT.ERROR
RETURN
END
*
! Check the port number
*
IF LCK<LCK$PORT,ONE> NE PORT THEN 
MSG = "was not locked by you!"
LCK.LOG = 8
GOSUB REPORT.ERROR
RETURN
END
*
! Remove the lock
*
*IF LCK.TRACE THEN
*TMP = LCK<LCK$DT>:"*":LCK<LCK$TM>
*WRITE LCK ON LCK.FILE,TMP:"*":LCK.ID
*END
DELETE LCK.FILE,LCK.ID
*
RETURN
*
!
*
REPORT.ERROR: *
*
**PRINTER ON
**PRINT STR("*",70)
TMP1 = "~RLS.ERROR ":LCK.ID:"~"
TMP1<-ONE> = "The lock for file ":FILE.NAME:", item ":ITM.ID:" ":MSG
TMP1<-ONE> = SPACE(10):"Account: ":ACCT "L#15":" Port: ":PORT:" Oper: ":OPER
TMP1<-ONE> = SPACE(10):"Date ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
TMP1<-ONE> = " "
**TMP1<-ONE> = STR("*",70)
**TMP1<-ONE> = "~RLS.END MSG~"
**PRINTER OFF
***
**RETURN
***
**!
***
**WRITE.LOG: *
***
IF LCK.LOG THEN
LCK<LCK$RELS> = DATE():"*":TIME():"*":LCK.PROG:"+":LCK.CSEG:"+":LCK.CSEG.LOC
*WRITE LCK ON LCK.FILE,LCK.ID
TMP = FIELD("*LOCKED*DUPE*BUSY*EXPIRED*LOCKED*OVERRIDE*GONE*NOTI*","*",LCK.LOG + ONE)
READU LOG.ITM FROM LCK.FILE,"LCK_LOG_":TMP ELSE LOG.ITM = EMPTY
IF LEN(LOG.ITM) GT 1000 THEN
WRITE LOG.ITM ON LCK.FILE,"LCK_LOG_":TMP:"@":("00000":DATE()) "R#5":"@":("000000":TIME()) "R#5":"@":PORT:"@":ACCT:"@":OPER
LOG.ITM = EMPTY
END
*
LOG.ITM<-ONE> = TMP1
LOG.ITM<-ONE> = "~LCK ":LCK.ID:"~"
LOG.ITM<-ONE> = LCK
LOG.ITM<-ONE> = "~END~"
LOG.ITM<-ONE> = "~RLS.END MSG~"
WRITE LOG.ITM ON LCK.FILE,"LCK_LOG_":TMP
END
LCK.STAT = FALSE
*
RETURN
*
END
~SYS.LOCK.ID~
*PROGRAM: SYS.LCK.ID
*
*      Place a lock on an item
*
*     to be used to lock a job stream (SINLGE, INSTALL, OV, XTR, WO, PPV)
*
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
ECHO OFF
INPUT AUTO.RUN:
IF NOT(NUM(AUTO.RUN)) THEN AUTO.RUN = TRUE
ECHO ON
*
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT "Enter file name (COM): ":
END
INPUT FILE.NAME:
IF FILE.NAME EQ "KILL" THEN STOP
IF FILE.NAME EQ EMPTY THEN
FILE.NAME = "COM"
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN PRINT FILE.NAME:
END
*
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT "Enter item name (ALL): ":
END
INPUT ITEM.NAME:
IF ITEM.NAME EQ "KILL" THEN STOP
IF ITEM.NAME EQ EMPTY THEN
ITEM.NAME = "ALL"
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN PRINT ITEM.NAME:
END
*
*960520*DGH*IF NOT(AUTO.RUN OR SYSTEM(11)) THEN PRINT; PRINT; PRINT; PRINT
*
*
!
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS"; INPUT RSP:; STOP
LCK.TYPE = -3; LCK.ITM = TRUE; LCK.RELS = FALSE
* LCK.FILE = ZERO; * REV ONLY
*
OPEN FILE.NAME TO TMP.FILE ELSE
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT BELL:"File ":FILE.NAME:" is missing!"
END
STOP
END
*
!
*
IF AUTO.RUN THEN
LCK.TYPE = -3
END ELSE
LCK.TYPE = ZERO
END
LCK.FIRST = TRUE
LCK.TRY.CN = ZERO
*
LOOP
LCK.TRY.CN = LCK.TRY.CN + ONE
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(LCK.FILE,FILE.NAME,ITEM.NAME,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN ABORT
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
IF LCK.STAT AND AUTO.RUN AND NOT(SYSTE(11)) THEN
IF LCK.TRY.CN GT 5 THEN
IF LCK.FIRST THEN
EXEC.VERB = "SYS.MSG.SEND"
EXEC.IN = "1":AM:"PROGRAMS":AM:PORT:" ":FILE.NAME:" ":ITEM.NAME:" is locked!!"
EXECUTE EXEC.VERB, //IN. < EXEC.IN
END
LCK.FIRST = FALSE
END
EXECUTE "SLEEP 10"
END
WHILE LCK.STAT DO
IF NOT(AUTO.RUN) THEN PRINT BELL:
IF SYSTEM(11) THEN LCK.TYPE = ZERO
REPEAT
*
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT SPACE(10):"File ":FILE.NAME:", item ":ITEM.NAME:" is now locked."
PRINT SPACE(10):"Remember to unlock it . . . "
***IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
***PRINT "Enter <cr>: ":
***INPUT TMP
***END ELSE PRINT
****960520*DGH*PRINT
***END
*
END
~SYS.LOCK.ITEM~
*PROGRAM: CASH.LCK.XTR
*
*      Clear Payments Tape XTR file
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CNT.XTRIND.DIM
*
$INCLUDE IBP CNT.XTRIND.EQUATES
*
ECHO OFF
INPUT AUTO.RUN,ONE:
IF NOT(NUM(AUTO.RUN)) THEN AUTO.RUN = TRUE
ECHO ON
*
*
!
*
OPEN "FC.XTR" TO XTR.FILE ELSE PRINT "Can't open XTR"; INPUT RSP:; STOP
OPEN "FC.PAR" TO PAR.FILE ELSE PRINT "Can't open PAR"; INPUT RSP:; STOP
OPEN "FC.CNT" TO CNT.FILE ELSE PRINT "Can't open CNT"; INPUT RSP:; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS"; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
*
*
LOOP
IF AUTO.RUN THEN
LCK.STAT = -5
END ELSE
LCK.STAT = ZERO
END
CALL LOCK.ITEM(XTR.FILE,"CNT","XTR.CTL",LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
IF LCK.STAT AND AUTO.RUN THEN
EXECUTE "SLEEP 10"
END
WHILE LCK.STAT DO REPEAT
*
IF NOT(AUTO.RUN) THEN
* IF NOT(SYSTEM(11)) THEN
PRINT CLB:"Item now locked, remember to unlock it. Enter <cr> . . . ":; INPUT TMP:
* END
*
END
~SYS.OPSYS.PROCWRITE~
*PROGRAM: SYS.OPSYS.PROCWRITE
*
INCLUDE STANDARD.FUNCTIONS FROM OUT.IBP
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "SYS File is missing!"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY; STOP
*
IF LEN(PROC.BUFFER) THEN
*
IF PROC.BUFFER<ONE> EQ "CALL-PL" OR PROC.BUFFER<ONE> EQ "CALL-DH.PL" THEN
DEL PROC.BUFFER<ONE>
IF TERM.DISP THEN PRINT PROC.BUFFER
END
*
BEGIN CASE
CASE OPSYS EQ "?"
* TMP = FIELD(PROC.BUFFER," ",ONE)
* PROC.BUFFER = OPSYS:PROC.BUFFER[COL2(),9999]
PROC.BUFFER<ONE> = OPSYS
CASE TRUE
PROC.BUFFER<ONE> = OPSYS
END CASE
*
END ELSE
*
PROC.BUFFER = OPSYS
*
END
*
* ULT ONLY
PROCWRITE PROC.BUFFER
*
IF TERM.DISP THEN PRINT PROC.BUFFER
*
*
STOP
*
END
~SYS.SPOOLER~
*PROGRAM: SYS.SPOOLER
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
LOOP
*
PRINT
PRINT "Spooler functions: "
PRINT "   1 QUE STATUS"
PRINT "   2 QUE JOBS"
PRINT "   3 CURRENT ASSIGNMENT if account is 1"
PRINT
PRINT "Enter spooler number: ":; INPUT SPOOLER.FUNC
IF SPOOLER.FUNC EQ "KILL" THEN STOP
IF NOT(NUM(SPOOLER.FUNC)) THEN SPOOLER.FUNC = ONE
PRINT
PRINT
PRINT "Enter account name: ":; INPUT ACCT.NAME
IF ACCT.NAME EQ "KILL" THEN STOP
PRINT
*
WHILE ACCT.NAME NE EMPTY DO
*
*
SP.LIST = SPOOLER(SPOOLER.FUNC,ACCT.NAME)
*
IF SP.LIST EQ EMPTY THEN PRINT BELL ELSE
*
SP.CN.MAX = DCOUNT(SP.LIST,AM)
*
FOR SP.CN = ONE TO SP.CN.MAX
*
PRINT SP.LIST<SP.CN>
*
* 1 IS FORM QUEUE
* 2 IS JOB FUNCBER
SP.DATE = SP.LIST<SP.CN,5>    ;* DAY JOB WAS CREATED (INTERNAL FORMAT)
SP.TIME = SP.LIST<SP.CN,6> "R%5"  ;* TIME JOB WAS CREATED (INTERNAL FORMAT)
* 7 IS JOB STATUS
*
NEXT SP.CN
*
END; * OF SP.LIST NOT EMPTY
*
REPEAT
*
*
END
~SYS.SUBR.ENTER.STD.SUBR~
SUBROUTINE SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP STD.DIM
*
CLS.ROW = 3; CLS.COL = ZERO
*
!
*
$INCLUDE IBP SYS.INCL.ENTER.STD.SUBR
*
RETURN; * to calling program
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
RETURN; * To calling program
*
END
~SYS.SUBR.ERROR~
SUBROUTINE SYS.SUBR.ERROR(TEXT,ERR.LN.MIN,ERR.LN.MAX,ERR.LN.HI,ERR.CL,ERR.LN,ERR.LEN,ERR.CLS,ERR.CLB,ERR.HDR,ERR.FMT,ERR.CR,ERR.BELL,ERR.DISP.ONLY,STAT)
* VERSION: 940605 1.0 SUBROUTINE TO CALL WITH OLD INCLUDE
*
* COPYRIGHT          AXION COMPUTER SYSTEMS LTD.
*   1994                ALL RIGHTS RESERVED
*
* DESCRIPTION: DISPLAYS TEXT AND ERRORS
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VS TO " (R:1.0)"
*
* PRINT "+++":; INPUT TMP:
*
!
*
ERROR: *
*
VERSION = VS
*
$INCLUDE IBP SYS.INCL.ERROR
*
*
RETURN
*
*
END
~SYS.SUBR.EXEC.STD.FUNC~
SUBROUTINE SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP STD.DIM
*
! Set ACC file settings
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
!
*
$INCLUDE IBP SYS.INCL.EXEC.STD.FUNC
*
!
*
UNLOCK: *
*
!
*
FINISH: *
*
!
*
RETURN; * To calling program
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
END
~SYS.SUBR.EXEC.STD.FUNC.13MAR94~
SUBROUTINE SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP STD.DIM
*
! Set ACC file settings
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
!
*
$INCLUDE IBP SYS.INCL.EXEC.STD.FUNC
*
!
*
UNLOCK: *
*
!
*
FINISH: *
*
!
*
RETURN; * To calling program
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
END
~SYS.SUBR.FILE.STAT~
SUBROUTINE SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,OPTION,FILE.NAME,FILE.BASE,STAT,PROG.DEBUG)
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
EQU TRUE TO 1, FALSE TO 0
EQU EMPTY TO ""
*
EQU ONE   TO 1
EQU TWO   TO 2
*
*# STAT settings
EQU DICT.FILE.MISSING     TO 1; *# STAT
EQU DICT.OPEN.ERROR       TO 2; *# STAT
EQU NOT.A.FILE            TO 3; *# STAT
EQU MD.FILE.MISSING       TO 4; *# STAT
EQU DATA.OPEN.ERROR       TO 5; *# STAT
EQU DATA.FILE.MISSING     TO 6; *# STAT
*
EQU D.POINTER     TO "D"
EQU Q.POINTER     TO "Q"
*
EQU FILE.QACCT     TO DICT.BASE
EQU FILE.QNAME     TO DICT.MOD
*
*
* OPTION settings
EQU FILE.CREATE.OPT   TO "FC"
EQU DICT.CREATE.OPT   TO "DC"
EQU DATA.CREATE.OPT   TO "DAC"
EQU MD.CREATE.OPT     TO "MC"
EQU SEEK.OPT          TO "S"
EQU PROMPT.OPT        TO "?"
*
IF PROG.DEBUG THEN PRINT; *# @@@#
*
STAT = FALSE
EXEC.VERB = "CREATE-FILE"
*
IF PROG.DEBUG THEN PRINT "oM":; *# @@@#
*
OPEN MD.FILE.NAME TO MD.FILE ELSE
STAT = MD.FILE.MISSING
IF PROG.DEBUG THEN PRINT "- ":; *# @@@#
IF PROG.DEBUG THEN PRINT "Mme ":; *# @@@#
RETURN
END
IF PROG.DEBUG THEN PRINT "+ ":; *# @@@#
*
LOOP
*
DICT.FILE.RELOOP = FALSE
*
IF PROG.DEBUG THEN PRINT "rD":; *# @@@#
*
READ DICT.FILE.ITEM FROM MD.FILE, DICT.NAME THEN
IF PROG.DEBUG THEN PRINT "+ ":; *# @@@#
DICT.ON.FILE = TRUE
DICT.TYPE = DICT.FILE.ITEM<ONE>
DICT.BASE = DICT.FILE.ITEM<TWO>
DICT.MOD  = DICT.FILE.ITEM<3>
DICT.SEP  = DICT.FILE.ITEM<4>
*
IF DICT.TYPE[ONE,ONE] EQ D.POINTER AND LEN(DICT.TYPE) EQ TWO THEN
TC = DICT.TYPE[TWO,ONE]
IF TC EQ "X" OR TC EQ "Y" OR TC EQ "W" OR TC EQ "C" THEN DICT.TYPE = DICT.TYPE[ONE,ONE]
END; *# of D.POINTER[ONE,ONE]
*
IF DICT.TYPE NE D.POINTER AND DICT.TYPE NE Q.POINTER THEN
*
IF PROG.DEBUG THEN PRINT "Fpe ":; *# @@@#
STAT = NOT.A.FILE
*
END ELSE IF DICT.TYPE EQ Q.POINTER THEN
*
IF PROG.DEBUG THEN PRINT "Qp ":; *# @@@#
*
IF INDEX(OPTION,SEEK.OPT,ONE) THEN
*
IF FILE.QACCT NE ACCT THEN
*
LOOP
*
IF PROG.DEBUG THEN PRINT "rM":; *# @@@#
*
MD.FILE.NAME = FILE.QACCT:".MD"
READ MD.ITEM FROM MD.FILE, MD.FILE.NAME THEN
*
IF PROG.DEBUG THEN PRINT "+ ":; *# @@@#
*
MD.RELOOP = FALSE
*
* IF MD.ITEM<ONE> EQ Q.POINTER AND INDEX(OPTION,SEEK.OPT,ONE) THEN
IF PROG.DEBUG THEN PRINT "oM":; *# @@@#
OPEN MD.FILE.NAME TO MD.FILE THEN
IF PROG.DEBUG THEN PRINT "+ ":; *# @@@#
DICT.FILE.RELOOP = TRUE
END ELSE
IF PROG.DEBUG THEN PRINT "- ":; *# @@@#
STAT = MD.FILE.MISSING
IF PROG.DEBUG THEN PRINT "Mme ":; *# @@@#
END
* END; *# of MD.ITEM is a Q.POINTER
*
END ELSE
*# MD.ITEM is missing
*
IF PROG.DEBUG THEN PRINT "- ":; *# @@@#
*
IF INDEX(OPTION,FILE.CREATE.OPT,ONE) OR INDEX(OPTION,MD.CREATE.OPT,ONE) THEN
IF PROG.DEBUG THEN PRINT "cM ":; *# @@@#
WRITE "Q":AM:FILE.QACCT ON MD.FILE, MD.FILE.NAME
MD.RELOOP = TRUE
END ELSE
MD.RELOOP = FALSE
MD.ITEM = EMPTY
END
*
END; *# of MD.ITEM present/missing
*
WHILE MD.RELOOP AND NOT(STAT) DO REPEAT
*
END ELSE
* Same Account
*
IF FILE.QNAME NE FILE.NAME THEN
FILE.NAME = FILE.QNAME
DICT.NAME = FILE.QNAME
DICT.FILE.RELOOP = TRUE
END
*
END; *# of file is a q-pointer in same account
*
END; *# of SEEK.OPT  / not Seek
*
END ELSE
*
IF PROG.DEBUG THEN PRINT "Dp ":; *# @@@#
*
END; *# of POINTER type
*
END ELSE
IF PROG.DEBUG THEN PRINT "- ":; *# @@@#
*
DICT.TYPE = ""
DICT.FILE.ITEM = EMPTY
DICT.ON.FILE = FALSE
END
*
IF NOT(STAT) AND NOT(DICT.ON.FILE) THEN
*
IF INDEX(OPTION,FILE.CREATE.OPT,ONE) OR INDEX(OPTION,DICT.CREATE.OPT,ONE) THEN
*
IF PROG.DEBUG THEN PRINT "cD ":; *# @@@#
*
EXEC.FILE = "DICT ":DICT.NAME
IF NOT(DICT.MOD) THEN DICT.MOD = ONE
IF NOT(DICT.SEP) THEN DICT.SEP = ONE
EXEC.DATA = DICT.MOD:",":DICT.SEP
*
EXECUTE EXEC.VERB:" ":EXEC.FILE:" ":EXEC.DATA, //OUT. > EXEC.RSP
*
DICT.FILE.RELOOP = TRUE
*
END ELSE
* DICT NOT ON FILE
STAT = DICT.FILE.MISSING
IF PROG.DEBUG THEN PRINT "Dme ":; *# @@@#
*
END
*
END; *# of NOT(DICT.ON.FLIE)
*
WHILE DICT.FILE.RELOOP AND NOT(STAT) DO REPEAT
*
IF NOT(STAT) THEN
*
IF PROG.DEBUG THEN PRINT "oD":; *# @@@#
*
OPEN "DICT ":DICT.NAME TO DICT.FILE THEN
*
IF PROG.DEBUG THEN PRINT "+ ":; *# @@@#
*
LOOP
*
DATA.FILE.RELOOP = FALSE
*
IF PROG.DEBUG THEN PRINT "rF":; *# @@@#
*
READ FILE.ITEM FROM DICT.FILE, FILE.NAME THEN
*
IF PROG.DEBUG THEN PRINT "+ ":; *# @@@#
*
DATA.ON.FILE = TRUE
FILE.TYPE = FILE.ITEM<ONE>
FILE.BASE = FILE.ITEM<TWO>
FILE.MOD  = FILE.ITEM<3>
FILE.SEP  = FILE.ITEM<4>
*
END ELSE
*# DATA FILE missing
*
IF PROG.DEBUG THEN PRINT "- ":; *# @@@#
*
DATA.ON.FILE = FALSE
*
IF INDEX(OPTION,FILE.CREATE.OPT,ONE) OR INDEX(OPTION,DATA.CREATE.OPT,ONE) THEN
*
IF PROG.DEBUG THEN PRINT "cF ":; *# @@@#
*
IF FILE.NAME NE DICT.NAME THEN
EXEC.FILE = "DATA ":DICT.NAME:",":FILE.NAME
END ELSE
EXEC.FILE = "DATA ":FILE.NAME
END
IF NOT(FILE.MOD) THEN FILE.MOD = 17
IF NOT(FILE.SEP) THEN FILE.SEP = ONE
EXEC.DATA = FILE.MOD:",":FILE.SEP
*
EXECUTE EXEC.VERB:" ":EXEC.FILE:" ":EXEC.DATA, //OUT. > EXEC.RSP
*
DATA.FILE.RELOOP = TRUE
*
END ELSE
*
STAT = DATA.FILE.MISSING
*
END; * of FILE.CRE option
*
END; *# of FILE ITEM on file/missing
*
WHILE DATA.FILE.RELOOP AND NOT(DATA.ON.FILE) AND NOT(STAT) DO REPEAT
*
END ELSE
*# DICT file missing
*
STAT = DICT.OPEN.ERROR
IF PROG.DEBUG THEN PRINT "oDe ":; *# @@@#
*
END; *# of DICT file ok/missing
*
END; * of NOT(STAT)
*
IF NOT(STAT) THEN
*
IF PROG.DEBUG THEN PRINT "oF":; *# @@@#
*
FILE.NAME.TEMP = FILE.NAME
IF FILE.NAME NE DICT.NAME THEN FILE.NAME.TEMP = DICT.NAME:",":FILE.NAME.TEMP
*
OPEN FILE.NAME.TEMP TO DATA.FILE THEN
IF PROG.DEBUG THEN PRINT "+ ":; *# @@@#
END ELSE
STAT = DATA.OPEN.ERROR
IF PROG.DEBUG THEN PRINT "oFe ":; *# @@@#
END
*
END; * of NOT(STAT)
*
*
RETURN
*
END
~SYS.SUBR.LOAD.STD.DATA~
SUBROUTINE SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP STD.DIM
*
*
*
$INCLUDE IBP SYS.INCL.LOAD.STD.DATA
*
RETURN; * To calling program
*
END
~SYS.SUBR.LOAD.TST~
SUBROUTINE SYS.SUBR.LOAD.TST(CNT.FILE,TST.ID,TEST.FL,LIST.NAME,DIS.SUB,DIS.ITEM,DIS.PROG,TIMING,BREAK.ON,WKO.TEST,TST.FLAG,TST.DISP.CR,LBL.DISP,ID.DISP,FILE.UPD)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
*$INCLUDE IBP SYS.SUBR.LOAD.TST
*
*CNT.FILE,TST.ID
*TEST.FL,LIST.NAME,DIS.SUB,DIS.ITEM,DIS.PROG,TIMING,BREAK.ON,WKO.TEST
*TST.FLAG,TST.DISP.CR,LBL.DISP,ID.DISP,FILE.UPD
!
*
EQU VERSION TO "?"
*
* AUTHOR: DAVID HORSMAN
*
* COMPANY: MACRO / AXION
*
!
*
*
$INCLUDE IBP SYS.INCL.LOAD.TST
*
RETURN; * to calling program
*
END
~SYS.SUBR.OPEN.ERR~
SUBROUTINE SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
*
* CNTRL.FL  - 0/1 SET STAT TO 995 AND RETURN
*           -  2  STOP
*           -  3  ABORT
*           -  4  CYCLE PORT
*           -  5  CYCLE PORT UNTIL SYS11 & STAT to 996
*           -  6  FREEZE PORT
*           - <10 DISPLAY
*           - 10  DISPLAY
*           - 90  NO DISPLAY
*           - <100 INPUT TCL
*           -  100 INPUT RSP
*           -  200 WAIT for RSP for ? SEC.S & STAT to 997
*           -  900 NO RSP
*
* Load Input Fl
IF LEN(CNTRL.FL) GT ONE THEN
RSP.FL = CNTRL.FL[ONE,ONE]
CNTRL.FL = CNTRL.FL[TWO,99]
END ELSE
RSP.FL = ONE
END
*
* Load Display
IF LEN(CNTRL.FL) GT ONE THEN
DSP.FL = CNTRL.FL[ONE,ONE]
CNTRL.FL = CNTRL.FL[TWO,99]
END ELSE
DSP.FL = ONE
END
*
BEGIN CASE
CASE DSP.FL EQ 9
CASE DSP.FL
PRINT CLB:SYS.SYST:" Can't open file ":FILE.NAME:".":
CASE CNTRL.FL EQ 5 OR (RSP.FL AND RSP.FL LT 9)
PRINT CLB:
CASE TRUE
END CASE
*
BEGIN CASE
CASE RSP.FL EQ 9
CASE RSP.FL EQ 2
STAT = 997
CASE RSP.FL
PRINT " Enter <cr>... ":
INPUT RSP:
CASE TRUE
END CASE
*
BEGIN CASE
*
CASE CNTRL.FL EQ ONE
NULL
*
CASE CNTRL.FL EQ TWO
STOP
*
CASE CNTRL.FL EQ 3
ABORT
*
CASE CNTRL.FL EQ 4 OR CNTRL.FL EQ 5
CONT = TRUE
**IF CNTRL.FL EQ 5 THEN
**PRINT " Enter any key... ":
**END
LOOP
IF CNTRL.FL EQ 5 THEN
PRINT " Enter any key... ":
IF SYSTEM(11) THEN CONT = FALSE
END
WHILE CONT DO
EXECUTE "SLEEP 15"
FOR TMP = ONE TO 3
PRINT CLB:SYS.SYST:" Can't open file ":FILE.NAME:".":BELL:
**EXECUTE "SLEEP 2"
NEXT TMP
REPEAT
STAT = 996
*
CASE CNTRL.FL EQ 6
CHAIN "FREEZE.PORT"
*
CASE TRUE
LOOP WHILE TRUE DO
PRINT CLB:SYS.SYST:" Can't open file ":FILE.NAME:".":BELL:
RQM
REPEAT
*
*
END CASE
*
*
RETURN
END
~SYS.SUBR.RUN.INS~
SUBROUTINE SYS.SUBR.RUN.INS(CNT.FILE,LCK.FILE,RSTAT.ID,RSTAT.RUN,RSTAT.MAX,START.DT,START.TM,END.DT,END.TM,C.CN,C.TM,U.CN,U.TM,P.CN,P.TM,S.CN,S.TM,RSTAT.MISC1,RSTAT.MISC2,RSTAT.MISC3,RSTAT.MISC4,MAT CNT.TST,LCK.TYPE,STAT)
*PROGRAM: SYS.SUBR.RUN.INS
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    20 NOV 91
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
$INCLUDE IBP CNT.RSTAT.DIM
$INCLUDE IBP CNT.RSTAT.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
LOOP LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CNT.FILE,"CNT",RSTAT.ID,LCK.FILE,LCK.STAT) WHILE LCK.STAT DO REPEAT
MATREAD CNT.RSTAT FROM CNT.FILE,RSTAT.ID ELSE MAT CNT.RSTAT = EMPTY
RSTAT.MAX = CNT.RSTAT$CN.MAX
*
$INCLUDE IBP SYS.INCL.RUN.INS
*
CALL UNLOCK.ITEM(CNT.FILE,"CNT",RSTAT.ID,LCK.FILE)
*
IF CNT.TST$CR THEN PRINT "SYS.SUBR.RUN.INS <cr> ":; INPUT TMP:
*
RETURN
*
END
~SYS.SUBR.SYSTEM.NAME~
SUBROUTINE SYS.SUBR.SYSTEM.NAME(INP.FILE,SYSTEM.NAME,STAT)
*
*DAVID HORSMAN 03 OCT 89
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
READV SYSTEM.NAME FROM INP.FILE,"SYSTEM.NAME",1 THEN
STAT = 0
END ELSE
SYSTEM.NAME = "UNKNOWN"
STAT = 1
END
*
RETURN
*
END
~SYS.SUBR.SYSTEM.TYPE~
SUBROUTINE SYS.SUBR.SYSTEM.TYPE(INP.FILE,SYSTEM.TYPE,STAT)
*
*DAVID HORSMAN 06 OCT 89
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
*
READV SYSTEM.TYPE FROM INP.FILE,"SYSTEM.TYPE",1 THEN
STAT = 0
END ELSE
SYSTEM.TYPE = "UNKNOWN"
STAT = 1
END
*
RETURN
*
END
~SYS.TEST.LASTWORD~
*PROGRAM: SYS.TEST.LASTWORD 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "BP.UTL" TO ITEM.FILE ELSE STOP
*
*
TERM.DISP = TRUE
*
FOR A = ONE TO 100
*
PRINT @(ZERO,5):CLS:
PRINT
PRINT "Enter the routine to examine:"
INPUT ITEM.ID
PRINT
PRINT
IF ITEM.ID EQ "KILL" OR ITEM.ID EQ EMPTY THEN STOP
*
READ ITEM FROM ITEM.FILE,ITEM.ID THEN
*
*
PRINT "Enter starting line: ":; INPUT AM.START
IF NOT(NUM(AM.START)) THEN AM.START = ONE
IF AM.START LE ZERO THEN AM.START = ONE
*
PRINT "Enter the number of pauses: ":; INPUT AM.PAUSE
IF NOT(NUM(AM.PAUSE)) THEN AM.PAUSE = ONE
IF AM.PAUSE LE ZERO THEN AM.PAUSE = ONE
*
AM.CN.MAX = DCOUNT(ITEM,AM)
FOR AM.CN = AM.START TO AM.CN.MAX UNTIL SYSTEM(11)
*
PRINT @(20,7):AM.CN "R#4":
LINE = ITEM<AM.CN>
*
$INCLUDE IBP SYS.INCL.LASTWORD
*
FOR A = ONE TO AM.PAUSE
EXECUTE "SLEEP 1"
NEXT A
*
NEXT AM.CN
*
*
END ELSE PRINT "NOT ON FILE!"
*
NEXT A
*
*
STOP
*
END
~SYS.TYPEAHEAD.ABORT~
*PROGRAM: SYS.TYPEAHEAD.ABORT 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
! Check if from proc
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
*
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = FALSE
*
! Check type ahead buffer
*
CONT = SYSTEM(11)
*
IF CONT THEN
*
BEGIN CASE
*
CASE PROC.FL
PROC.BUFFER<ONE> = "ABORT"
PROCWRITE PROC.BUFFER
STOP
*
CASE OPSYS EQ "M"
*
ABORT
*
CASE OPSYS EQ "U"
*
ABORT
*
CASE TRUE
STOP
*
END CASE
*
*
END
*
*
END
~SYS.UNLOCK.ID~
*PROGRAM: SYS.UNLCK.ID
*
*      Remove a lock from an item
*
*     to be used to unlock a job stream (SINLGE, INSTALL, OV, XTR, WO, PPV)
*
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
ECHO OFF
INPUT AUTO.RUN:
IF NOT(NUM(AUTO.RUN)) THEN AUTO.RUN = TRUE
ECHO ON
*
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT "Enter file name (COM): ":
END
INPUT FILE.NAME:
IF FILE.NAME EQ "KILL" THEN STOP
IF FILE.NAME EQ EMPTY THEN
FILE.NAME = "COM"
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN PRINT FILE.NAME:
END
*
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT "Enter item name (ALL): ":
END
INPUT ITEM.NAME:
IF ITEM.NAME EQ "KILL" THEN STOP
IF ITEM.NAME EQ EMPTY THEN
ITEM.NAME = "ALL"
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN PRINT ITEM.NAME:
END
*
*960520*DGH*IF NOT(AUTO.RUN OR SYSTEM(11)) THEN PRINT; PRINT; PRINT; PRINT
*
*
!
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS"; INPUT RSP:; STOP
LCK.TYPE = -3; LCK.ITM = TRUE; LCK.RELS = FALSE
* LCK.FILE = ZERO; * REV ONLY
*
OPEN FILE.NAME TO TMP.FILE ELSE
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT BELL:"File ":FILE.NAME:" is missing!"
END
STOP
END
*
!
*
IF AUTO.RUN THEN
LCK.TYPE = -5
END ELSE
LCK.TYPE = ZERO
END
*
* LOOP
* LCK.STAT = LCK.TYPE
* CALL LOCK.ITEM(LCK.FILE,FILE.NAME,ITEM.NAME,LCK.FILE,LCK.STAT)
* IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN STOP
* IF LCK.STAT AND AUTO.RUN THEN
* EXECUTE "SLEEP 10"
* END
CALL UNLOCK.ITEM(LCK.FILE,FILE.NAME,ITEM.NAME,LCK.FILE)
* WHILE LCK.STAT DO
* IF NOT(AUTO.RUN OR SYSTEM(11)) THEN PRINT BELL:
* REPEAT
*
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT
PRINT SPACE(100):"File ":FILE.NAME:", item ":ITEM.NAME:" is now unlocked."
END
*
END
~SYSTEM.TEST~
SUBROUTINE SYSTEM.TEST(TEST.FL,DIS.PROG,DIS.SUB,DIS.ITEM,LIST.NAME,TIMING,BREAKON,WKO.TEST,PROG.TEST)
* PROGRAM:  SYSTEM.TEST
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
* 'SYSTEM.TEST' IN GENERAL.CMMN.AREA SHOULD BE LOADED WHERE APPLICABLE
*
* ATR   PURPOSE
*   1   ON/OFF
*   2   DISPLAY 'ENTERING' PROGRAM OR CALLED SUBROUTINE
*   3   DISPLAY 'ENTERING' A SUBROUTINE
*   4   1 - DISPLAY ITEM ID BEING PROCESSED
*       2 - DISPLAY ITEM AND MSG IF ERROR/REJECTED, ETC.
*   5   LIST.NAME TO BE PROCESSED
*   6   TEST.DATE TO BE USED (EXTERNAL FORMAT)
*   7   BREAK IS ON
*   8   TIMING DISPLAY IS ON
*   9   PROGRAM SPECIFIC
*  10   NOT USED
!
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
READ SYS.TST FROM CNT.FILE,"SYSTEM.TEST" ELSE SYS.TST = ""
TEST.FL = 0; LIST.NAME = ""; DIS.SUB = 0; DIS.ITEM = 0; DIS.PROG = 0
TIMING = 0; BREAKON = 0; WKO.TEST = 0; PROG.TEST = 0
IF SYS.TST<1> NE "" THEN
TEST.FL   = 1
DIS.PROG  = SYS.TST<2>
DIS.SUB   = SYS.TST<3>
DIS.ITEM  = SYS.TST<4>
LIST.NAME = SYS.TST<5>
TIMING    = SYS.TST<6>
BREAKON   = SYS.TST<7>
WKO.TEST  = SYS.TST<8>
PROG.TEST = SYS.TST<9>
END
RETURN
!
END
~T.DET~
*PROGRAM: T.DET 
*
EXECUTE "T-DET", //OUT. > EXEC.RESULT
PRINT EXEC.RESULT
RQM
END
~TEMP~
*PROGRAM: TEMP
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "MD" TO MD.FILE ELSE STOP
*
*
DT = OCONV(DATE(),"D2")
*
IF DT NE "24 JUN 92" THEN STOP
*
REC = "D":AM:"597475":AM:"1":AM:"1":AM:AM:AM:AM:AM:"L":AM:"20"
*
WRITE REC ON MD.FILE,"DEMO.CNT"
*
PRINT "DONE"
*
END
~TEST.DCOUNT~
*PROGRAM: TEST.COUNT 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
TEMP = "HELLO"
*
AMC = DCOUNT(TEMP,AM)
VMC = DCOUNT(TEMP,VM)
SVC = DCOUNT(TEMP,SVM)
PRINT AMC
PRINT VMC
PRINT SVC
*
END
~TEST.ESC~
*PROGRAM: TEST.ESC 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
*
FOR TMP3 = ONE TO TWO
*
*
*FOR TMP = ONE TO 26
FOR TMP = 26 TO ONE STEP -ONE
*
IF TMP3 EQ ONE THEN
PRINT
PRINT "<CNTRL>+":ALPHA[TMP,ONE]
PRINT
PRINT
PRINT CHAR(TMP):
RQM
PRINT
PRINT
END ELSE
PRINT
PRINT "<ESC>+":ALPHA[TMP,ONE]
PRINT
PRINT
PRINT CHAR(27):ALPHA[TMP,ONE]:
RQM
PRINT
PRINT
END
*
RQM
*
FOR TMP1 = 1 TO 100
PRINT "A":
NEXT TMP1
PRINT
*
RQM; RQM; RQM; RQM; RQM
NEXT TMP
*
NEXT TMP3
*
STOP
*
END
~TEST.EXEC~
*PROGRAM: TEST.EXEC
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
EXEC.VERB = "LIST.CAJ.DEL"
*
EXEC.IN = "S":AM:"S":AM:"Y"
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
PRINT "!!! END !!!"
*
END
~TIME.CONVERT~
*PROGRAM: DATE.CONVERT 
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
LOOP
PRINT "Time to convert or <cr> to end: ":
INPUT TM
UNTIL TM EQ EMPTY DO
IF TM MATCHES "0N" THEN
CALL SECONDS.SUBR.CONV(TM,RSLT)
PRINT "Sec's: ":RSLT
CALL MINUTES.SUBR.CONV(TM,RSLT)
PRINT "Min's: ":RSLT
CALL HOURS.SUBR.CONV(TM,RSLT)
PRINT "Hours: ":RSLT
CALL DAYS.SUBR.CONV(TM,RSLT)
PRINT "Days:  ":RSLT
PRINT
TM = OCONV(TM,"MTS")
END ELSE
CALL GET.ICONV(TM,"MTS")
END
PRINT TM
PRINT
REPEAT
*
*
DT = DATE(); TM = TIME()
PRINT DT:" ":TM
PRINT OCONV(DT,"D2"):" ":OCONV(DT,"D2/"):" ":OCONV(TM,"MTS")
END
~TMP.DATE.DAY~
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
DT = DATE(); DISP.DT = OCONV(DT,"D-")
YYYY = DISP.DT[7,4]
* DAYS = YYYY * 365 + INT(YYYY / 4)
* DAYS = YYYY * 365.25
DAYS = INT(1967 * 365.25) + DT
DAY = REM(DAYS,7)
PRINT DAYS
PRINT DAY
*
*
END
~TST.SUBR.LOAD~
SUBROUTINE TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.TST.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,RUN.TYPE,PHANTOM.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP STD.DIM
*
*
*
TYPE.RUN = RUN.TYPE
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN; * To calling program
*
END
~UNLOCK.ITEM~
SUBROUTINE UNLOCK.ITEM(ITEM.FILE,FILE.NAME,ITEM.NAME,LCK.FILE)
* PROGRAM:           UNLOCK.ITEM
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       UNLOCK AN ITEM
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*SETTERM
*
! ATTEMPT TO READ THE LOCK ITEM
*
* ULT ONLY
READ LOCK.ITEM FROM LCK.FILE,FILE.NAME:"*":ITEM.NAME ELSE 
* ULT ONLY
MSG = "was missing!"
* ULT ONLY
GOSUB REPORT.ERROR
* ULT ONLY
RETURN
* ULT ONLY
END
*
! Check the port number
*
* ULT ONLY
IF LOCK.ITEM<ONE> NE PORT THEN 
* ULT ONLY
MSG = "was not locked by you!"
* ULT ONLY
RETURN
* ULT ONLY
END
*
! Remove the lock
*
* ULT ONLY
DELETE LCK.FILE,FILE.NAME:"*":ITEM.NAME
*
! Revelation version
*
* UNLOCK ITEM.FILE, ITEM.NAME; * REV ONLY
*
*
RETURN
*
!
*
REPORT.ERROR: *
*
PRINTER ON
PRINT STR("*",70)
PRINT
PRINT "The lock for file ":FILE.NAME:", item ":ITEM.NAME:" ":MSG
PRINT SPACE(10):"Account: ":ACCT "L#15":" Port: ":PORT
PRINT SPACE(10):"Date ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
PRINT
PRINT STR("*",70)
PRINTER OFF
*
RETURN
*
END
~UNPACK.NUMBER~
SUBROUTINE UNPACK.NUMBER(NUM.IN,NUM.OUT)
* PROGRAM:           UNPACK.NUMBER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       UNPACK A NUMBER IN HEX
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*SETTERM
!
*
$INCLUDE IBP SYS.INCL.UNPACK.NUMBER
*
*
RETURN
*
*
END
~UPDATE.LOCK~
SUBROUTINE UPDATE.LOCK(NUM.FILE)
* PROGRAM:           UPDATE.LOCK
* VERSION: 901022 2.4  CHANGE.TO.GENERAL.CMMN.AREA
* AUTHOR:            DAVID STERN  -  AXION
* DESCRIPTION:       LOCK ITEM AND RECORD IN 'UPDATED' FIELD
*
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
** LCK.ITM = TRUE; LCK.TYPE = ZERO
TMP = INDEX(REF,"*",ONE)
FILE.NAME = REF[ONE,TMP - ONE]
ITEM.NAME = REF[TMP + ONE,9999]
*
IF ITEM.NAME NE EMPTY THEN
*
LOCATE REF IN UPDATED SETTING LOC THEN
IF DISP.ONLY THEN
PRINT CLB:BELL:"Changes will not be allowed. Inquiries only.":
END
END ELSE
*
UPDATED<LOC> = REF
*
LOOP
*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(NUM.FILE,FILE.NAME,ITEM.NAME,LCK.FILE,LCK.STAT)
END ELSE LCK.STAT = TRUE
*
IF LCK.STAT EQ 900 OR LCK.STAT EQ 999 THEN
IF NOT(STAT) THEN STAT = LCK.STAT
*
END ELSE IF LCK.STAT THEN
PRINT CLB:BELL:"Changes will not be allowed. Inquiries only.":
IF NOT(DISP.ONLY) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE
PRINT BELL:
END
DISP.ONLY = TRUE; LCK.STAT = FALSE
*
END; * of lock stat
*
WHILE NOT(STAT) AND LCK.STAT DO REPEAT
*
IF STAT GT ZERO THEN STAT = 999
*
END; * Of ref not found and disp only
*
END; * of item not empty
*
REF = EMPTY
*
RETURN
*
*
END
~UPDATE.PASSWORDS~
*PROGRAM: UPDATE.PASSWORDS 
* AUTHOR:            BOB CONARROE
* DESCRIPTION:       UPDATE PASSWORDS FROM 'PENDING.PASSWORD.CHANGES' OF
*                    SYSPROG MD -- THIS ITEM IS CREATED BY PROGRAMS
*                    MAINT.ADMIN.AREAS AND MAINT.PASSWORDS.
* DATE WRITTEN:      04 APR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "MD" TO MD.FILE ELSE PRINT "Can't open MD":; INPUT RSP:; STOP
SYSPROG.QPTR = "Q":AM:"SYSPROG":AM:"MD":AM:AM:AM:AM:AM:AM:"L":AM:"10"
SYSTEM.QPTR = "Q":AM:"SYSPROG":AM:"SYSTEM":AM:AM:AM:AM:AM:AM:"L":AM:"10"
WRITE SYSPROG.QPTR ON MD.FILE, "SYSPROG.MD"
WRITE SYSTEM.QPTR ON MD.FILE, "SYSPROG.SYSTEM"
OPEN "SYSPROG.MD" TO SYSPROG.MD.FILE ELSE PRINT "Can't open SYSPROG.MD":; INPUT RSP:; STOP
OPEN "SYSPROG.SYSTEM" TO SYSPROG.SYSTEM.FILE ELSE PRINT "Can't open SYSPROG.SYSTEM":; INPUT RSP:; STOP
*
SYSPROG.MD.ID = "PENDING.PASSWORD.CHANGES"
READ SYSPROG.MD FROM SYSPROG.MD.FILE,SYSPROG.MD.ID ELSE SYSPROG.MD = ""
VC = 0
LOOP VC = VC+1 UNTIL SYSPROG.MD<1,VC> = "" DO
IF SYSPROG.MD<3,VC>[1,10] = "&&PENDING:" OR SYSPROG.MD<4,VC> # "" THEN
READ SYST FROM SYSPROG.SYSTEM.FILE, SYSPROG.MD<1,VC> THEN
IF SYSPROG.MD<3,VC> = "&&PENDING:A" THEN
IF SYST<1> = "Q" THEN
SYST<2> = SYSPROG.MD<2,VC>
SYST<7> = SYSPROG.MD<4,VC>
WRITE SYST ON SYSPROG.SYSTEM.FILE, SYSPROG.MD<1,VC>; * change of administrative area
END
END ELSE IF SYSPROG.MD<3,VC> = "&&PENDING:D" THEN
IF SYST<1> = "Q" THEN DELETE SYSPROG.SYSTEM.FILE, SYSPROG.MD<1,VC>; * delete a synonym
END ELSE IF (SYSPROG.MD<2,VC> = "" AND SYST<1> = "D") OR (SYSPROG.MD<2,VC> = SYST<2> AND SYST<1> = "Q") THEN
IF SYSPROG.MD<4,VC> # "" THEN
SYST<7> = SYSPROG.MD<4,VC>
WRITE SYST ON SYSPROG.SYSTEM.FILE, SYSPROG.MD<1,VC>; * password change
END
END
END ELSE IF SYSPROG.MD<3,VC> = "&&PENDING:A" THEN
SYST = "Q"
SYST<2> = SYSPROG.MD<2,VC>
SYST<7> = SYSPROG.MD<4,VC>
SYST<8> = "SYS2(127)"
SYST<9> = "L"
SYST<10> = "10"
WRITE SYST ON SYSPROG.SYSTEM.FILE, SYSPROG.MD<1,VC>; * add a synonym
END
END
REPEAT
SYSPROG.MD = ""
WRITE SYSPROG.MD ON SYSPROG.MD.FILE, SYSPROG.MD.ID
STOP
END
~UPL~
*PROGRAM: UPLOADER 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       TRANSMITS DATA TO ULTIMATE FROM OTHER MACHINE
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
PROMPT ""; AM = CHAR(254)
PRINT "UPLOADER - Receives data from you"
*
!
*
NEXT.FILE: *
*
PRINT "Enter file name: ":
INPUT FL.NAME:; IF FL.NAME = "" THEN STOP
IF FL.NAME[1,4] = "ULT." THEN FL.NAME = FL.NAME[4,99]
DICT.NAME = ""
IF FL.NAME[1,5] = "DICT." OR FL.NAME[1,5] = "DICT " THEN
DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
END
DISP.NAME = TRIM(DICT.NAME:" ":FL.NAME)
PRINT
OPEN DICT.NAME,FL.NAME ELSE PRINT "Can't open ":DISP.NAME; GOTO NEXT.FILE
!
NEXT.ITEM: *
PRINT "Enter item name: ":
INPUT ITEM.NAME:; IF ITEM.NAME = "" THEN GOTO NEXT.FILE
PRINT
READ ITEM FROM ITEM.NAME THEN
PRINT "Item exists - overwrite (Y/<cr>? ":
INPUT RSP:; IF NOT(RSP = "Y" OR RSP = "y") THEN PRINT; GOTO NEXT.ITEM
END
*
PRINT; PRINT; PRINT "Use '-' to abort"; PRINT "Waiting to receive ":DISP.NAME:" ":ITEM.NAME
ECHO OFF
*
ITEM = ""; AC = 1
*
LOOP
INPUT RSP:; GOSUB VALIDATE.LINE
UNTIL RSP = "=" DO AC = AC+1; PRINT "*": REPEAT
*
WRITE ITEM ON ITEM.NAME
*
ECHO ON
PRINT; PRINT "Load of ":DISP.NAME:" ":ITEM.NAME:" complete"
STOP
!
VALIDATE.LINE: *
IF RSP = "=" THEN RETURN ELSE IF RSP = "-" THEN STOP
IF AC = 1 THEN IF RSP[1,3] MATCHES "3N" THEN VALIDATE = 1 ELSE VALIDATE = ""
IF NOT(VALIDATE) THEN ITEM<AC> = RSP; RETURN
LINE = RSP[4,999]
CSUM = 0; POS = 1; MULT = 5
LOOP CHR = LINE[POS,1] UNTIL CHR = "" DO
CSUM = (CSUM+(SEQ(CHR)*MULT)+10000)[3,3]
POS = POS+1; MULT = MULT-1; IF MULT = 0 THEN MULT = 5
REPEAT
IF CSUM # RSP[1,3] THEN LINE = "###ERROR### ":RSP
ITEM<AC> = LINE
*
RETURN
*
*
END
~UPL.ALL~
*PROGRAM: UPL.ALL 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       TRANSMITS DATA TO ULTIMATE FROM XTALK
* DATE WRITTEN:      25 SEP 85
* DATE RELEASED:     25 SEP 85
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
PROMPT ""
PRINT "UPL.ALL - Receives data from you"
PRINT "Enter SE REVTFR to start the ball rolling..."
ECHO OFF
*
!
*
TEXT = ""; ENDER = ""; START.FILE = 1; ITM = ""; AC = 0; ITEM.IDENT = ""
LOOP UNTIL ENDER DO
INPUT RSP:
LOOP UNTIL RSP[1,1] # CHAR(0) DO RSP = RSP[2,999] REPEAT
BEGIN CASE
CASE RSP = "==="
ENDER = 1
GOSUB WRITE.ITM
CASE RSP = "\\\":"\\\"
START.FILE = 1
GOSUB WRITE.ITM
CASE RSP = "\\\%%%"
START.FILE = -1
GOSUB WRITE.ITM
CASE (START.FILE)
START.FILE = START.FILE+1
IF NOT(START.FILE) THEN
FL.NAME = FIELD(RSP," ",1)
IF FL.NAME[1,4] = "ULT." THEN FL.NAME = FL.NAME[4,99]
DICT.NAME = ""
IF FL.NAME[1,5] = "DICT." OR FL.NAME[1,5] = "DICT " THEN
DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
END
DISP.NAME = TRIM(DICT.NAME:" ":FL.NAME)
ITM.ID = FIELD(RSP," ",2)
OPEN DICT.NAME,FL.NAME ELSE TEXT = "CAN'T FIND ":DISP.NAME; GOTO ENDIT
PRINT RSP
END ELSE
IF START.FILE > 5 THEN TEXT = "NO \\\%%% FOUND"; GOTO ENDIT
END
CASE 1
IF RSP[1,1] = "+" THEN RSP = RSP[2,999]
IF RSP = "%%%" THEN ITEM.IDENT = -1 ELSE
IF ITEM.IDENT THEN ITEM.IDENT = ""; PRINT "      ":RSP
END
AC = AC+1
ITM<AC> = RSP
END CASE
REPEAT
!
ENDIT: *
PRINT @(0,0):CLS:
PRINT @(20,5):TEXT:
PRINT @(20,10):"Press <cr> to go back to menu...":
INPUT RSP:
ECHO ON
*
STOP
*
!
*
WRITE.ITM: *
*
IF ITM # "" THEN WRITE ITM ON ITM.ID
ITM = ""
AC = 0
ITEM.IDENT = ""
*
RETURN
*
!
*
END
~UPLOADER~
*PROGRAM: UPLOADER 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       TRANSMITS DATA TO ULTIMATE FROM OTHER MACHINE
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
*
PROMPT ""; AM = CHAR(254)
PRINT "UPLOADER - Receives data from you"
*
!
*
NEXT.FILE: *
*
PRINT "Enter file name: ":
INPUT FL.NAME:; IF FL.NAME = "" THEN STOP
IF FL.NAME[1,4] = "ULT." THEN FL.NAME = FL.NAME[4,99]
DICT.NAME = ""
IF FL.NAME[1,5] = "DICT." OR FL.NAME[1,5] = "DICT " THEN
DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
END
DISP.NAME = TRIM(DICT.NAME:" ":FL.NAME)
PRINT
OPEN DICT.NAME,FL.NAME ELSE PRINT "Can't open ":DISP.NAME; GOTO NEXT.FILE
!
NEXT.ITEM: *
PRINT "Enter item name: ":
INPUT ITEM.NAME:; IF ITEM.NAME = "" THEN GOTO NEXT.FILE
PRINT
READ ITEM FROM ITEM.NAME THEN
PRINT "Item exists - overwrite (Y/<cr>? ":
INPUT RSP:; IF NOT(RSP = "Y" OR RSP = "y") THEN PRINT; GOTO NEXT.ITEM
END
*
PRINT
PRINT "Waiting to load ":DISP.NAME:" ":ITEM.NAME
ECHO OFF
*
ITEM = ""; FILL = -1; AC = 1
*
LOOP
LOOP INPUT RSP:; GOSUB VALIDATE.LINE WHILE ERROR DO PRINT "-": REPEAT
UNTIL RSP = "=" DO AC = AC+1; PRINT "+": REPEAT
PRINT "=":
*
WRITE ITEM ON ITEM.NAME
*
ECHO ON
PRINT
PRINT "Load of ":DISP.NAME:" ":ITEM.NAME:" complete"
*
STOP
*
!
*
VALIDATE.LINE: *
*
IF FILL < 0 THEN POS = INDEX(RSP,"@@",1); IF POS THEN FILL = 1 ELSE FILL = 0
IF FILL THEN
POS = INDEX(RSP,"@@",1)
IF NOT(POS) THEN ERROR = 1; RETURN
LOOP CHR = RSP[POS,1] WHILE CHR = "@" DO POS = POS+1 REPEAT
RSP = RSP[POS,999]
END
IF RSP = "=" THEN ERROR = ""; RETURN
LINE = RSP[4,999]
CSUM = 0; POS = 1; MULT = 5
LOOP CHR = LINE[POS,1] UNTIL CHR = "" DO
CSUM = (CSUM+(SEQ(CHR)*MULT)+10000)[3,3]
POS = POS+1; MULT = MULT-1; IF MULT = 0 THEN MULT = 5
REPEAT
IF CSUM = RSP[1,3] THEN ERROR = ""; ITEM<AC> = LINE ELSE ERROR = 1
*
RETURN
*
*
END
~USERS~
*PROGRAM: USERS 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       DISPLAYS USER STATUS
* DATE RELEASED:     22 OCT 82
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
OPEN "DICT","ACC" TO D.AC.FILE ELSE STOP
OPEN "ACC" TO AC.FILE ELSE STOP
PRINT @(0,0):CLS:"Port Account      Location             Date    Time   Activity":CR:LF
EXECUTE 'SSELECT ACC LT "A" WITH NAME.'
*
!
*
NEXT.LINE: *
*
READNEXT ACC.ID ELSE
PDATE = OCONV(DATE(),"D2"); PDATE = PDATE[1,2]:PDATE[4,3]:PDATE[8,2]
PRINT CR:LF:"Current date and time:" "L#39":PDATE "L#8":OCONV(TIME(),"MT"); STOP
END
KEY = ACC.ID
READV ACCT FROM AC.FILE,KEY,1 ELSE GO NEXT.LINE
PORT = OCONV(KEY,"U3079"); KEY = ("00":PORT) "R#2"; KEY1 = "0":KEY
READ ITEM FROM AC.FILE,"MENU.":KEY ELSE ITEM = ""
PDATE = OCONV(ITEM<3>[1,5],"D2"); PDATE = PDATE[1,2]:PDATE[4,3]:PDATE[8,2]
READV LOC FROM D.AC.FILE,KEY1,1 ELSE LOC = ""
PRINT PORT "L#5":ACCT "L#12":" ":LOC "L#20":" ":PDATE "L#8":OCONV(ITEM<3>[6,5],"MT") "L#7":ITEM<2> "L#25"
GOTO NEXT.LINE
*
*
END
~XTALK.CHANGES~
*PROGRAM: XTALK.CHANGES 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       TRANSMITS CHANGE FILES OF FORM $CHANGES.DDMMMYY.X
*                    FROM ULTIMATE TO REVELATION USING XTALK.
*                    LIST OF FILES IS IN LIST "COMPARE-LIST".
* DATE WRITTEN:      25 SEP 85
* DATE RELEASED:     25 SEP 85
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
PRINT "XTALK.CHANGES - Dumps change files to a Crosstalk XVI personal"
LOOP
PRINT "Enter change date: ":
INPUT CH.DATE; IF CH.DATE = "" OR CH.DATE = "KILL" THEN STOP
CALL GET.ICONV(CH.DATE,"D")
UNTIL CH.DATE # "" DO PRINT BELL: REPEAT
CH.DATE = OCONV(CH.DATE,"D2")
CH.DATE = FIELD(CH.DATE," ",1):FIELD(CH.DATE," ",2):FIELD(CH.DATE," ",3)
READ FILE.LIST FROM CNT.FILE,"FILE.LIST" ELSE PRINT "Can't find FILE.LIST in CNT":; INPUT RSP; STOP
FILE.NUM = 0
PRINT "\\\":"\\\"
*
!
*
LOOP
*
FILE.NUM = FILE.NUM+1
FILE.NAME = FILE.LIST<FILE.NUM>
*
UNTIL FILE.NAME = "" DO
*
FILE.NAME = FILE.NAME:".CHANGES"
IF FILE.NAME[1,4] = "ULT." THEN FILE.NAME = FILE.NAME[5,99]
IN.NAME = FILE.NAME
DICT.NAME = ""
IF IN.NAME[1,5] = "DICT." OR IN.NAME[1,5] = "DICT " THEN
DICT.NAME = "DICT"; IN.NAME = IN.NAME[6,99]
END
DISP.NAME = TRIM(DICT.NAME:" ":IN.NAME)
OPEN DICT.NAME,IN.NAME ELSE PRINT "Can't open ":DISP.NAME; STOP
IN.ITM = 64
LOOP
IN.ITM = IN.ITM+1
ITM.ID = "$CHANGES.":CH.DATE:".":CHAR(IN.ITM)
READ ITEM FROM ITM.ID ELSE ITEM = "@"
UNTIL ITEM = "@" DO
PRINT "\\\%%%"
PRINT FILE.NAME:" ":ITM.ID
MAX.AC = COUNT(ITEM,AM)+1
FOR AC = 1 TO MAX.AC
PRINT "+":ITEM<AC>
*
NEXT AC
*
REPEAT
*
REPEAT
*
PRINT "==="
PRINT "==="
*
STOP
*
*
END
