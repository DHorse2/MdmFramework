~AAX.DIM~
*CODE.SEGMENT: ?
DIM AAX(1)
~AAX.EQUATES~
*CODE.SEGMENT: ?
* FILE "AAX" EQUATES - CREATED 11 APR 88
EQU AAX$ACT.ID TO AAX(1);                * NEW ACCOUNT NUMBER
~ACCS.DIM~
*CODE.SEGMENT: ?
DIM ACCS(10)
~ACCS.EQUATES~
*CODE.SEGMENT: ?
* FILE 'ACCS' EQUATES - GENERATED 14:43:51  09 JUL 1984
EQU ACCS$SIZE TO ACCS(1);               * SIZE (BYTES) OF ACCOUNT
EQU ACCS$PER.SZ TO ACCS(2);             * PERCENT OF DISK - PRIMARY
EQU ACCS$PAD TO ACCS(3);                * SIZE OF PADDING IN BYTES
EQU ACCS$PER.PAD TO ACCS(4);            * PERCENT OF DISK - PADDING
EQU ACCS$TOTAL TO ACCS(5);              * TOTAL SIZE IN BYTES
EQU ACCS$PER.TOT TO ACCS(6);            * PERCENT OF DISK - TOTAL
~ACG.DIM~
*CODE.SEGMENT: ?
DIM ACG(10)
~ACG.EQUATES~
*CODE.SEGMENT: ?
* FILE 'ACG' EQUATES - GENERATED 08:42:08  09 APR 1984
EQU ACG$SOURCES TO ACG(1);              * SOURCE OF TRANSACTION
EQU ACG$TRANS.TYPES TO ACG(2);          * TRANSACTION TYPE
EQU ACG$AMOUNTS TO ACG(3);              * TRANSACTION AMOUNT
EQU ACG$COUNTS TO ACG(4);               * TRANSACTION COUNT
EQU ACG$POSTING.DATE TO ACG(5);         * DATE OF POSTING TO MONTHLY TOTALS
~ACM.DIM~
*CODE.SEGMENT: ?
DIM ACM(10)
~ACM.EQUATES~
*CODE.SEGMENT: ?
* FILE 'ACM' EQUATES - GENERATED 09:16:36  15 JUN 1984
EQU ACM$SOURCES TO ACM(1);              * SOURCE OF TRANSACTION
EQU ACM$TRANS.TYPES TO ACM(2);          * TRANSACTION TYPE
EQU ACM$AMOUNTS TO ACM(3);              * TRANSACTION AMOUNT
EQU ACM$COUNTS TO ACM(4);               * TRANSACTION COUNT
~ACT.DIM~
*CODE.SEGMENT: ?
DIM ACT(50)
~ACT.EQUATES~
*CODE.SEGMENT: ACT.EQUATES
*
* FILE 'ACT' EQUATES - GENERATED 14:05:51  30 DEC 1991
EQU ACT$ADD.ID TO ACT(1);               * ADDRESS.PTR
EQU ACT$STAT TO ACT(2);                 * B.STAT
EQU ACT$PEND.ADD.ID TO ACT(3);          * PEND.ADDR
EQU ACT$PEND.STAT TO ACT(4);            * P.ST
EQU ACT$CUS.NAME TO ACT(5);             * CUSTOMER.NAME
EQU ACT$ALT.NAME TO ACT(6);             * ALTERNATE.NAME
EQU ACT$BILL.NAME TO ACT(7);            * BILL.TO.NAME
EQU ACT$BILL.ADDR TO ACT(8);            * BILL.TO.ADDRESS
EQU ACT$BILL.EFF.DATE TO ACT(9);        * B.EFF.DATE
EQU ACT$TEL.NUMS TO ACT(10);            * PHONE.NUMS
EQU ACT$ADDTL.DATA TO ACT(11);          * ADDITIONAL.DATA
EQU ACT$LAST.NOTICE.DATE TO ACT(12);    * DATE OF LAST ANNUAL NOTICE
EQU ACT$LAST.LATE.DATE TO ACT(13);      * Last date for apply late charges
EQU ACT$SOLICITATION TO ACT(14);        * SOLICITATION ALLOWED OR NOT ALLOWED
EQU ACT$RATE.TYPE TO ACT(15);           * RATE
EQU ACT$PAY.METHOD TO ACT(16);          * PMT
EQU ACT$BILL.DAY TO ACT(17);            * DAY
EQU ACT$AGED.AMTS TO ACT(18);           * AGED AMOUNTS
EQU ACT$BALANCE TO ACT(19);             * BALANCE.
EQU ACT$LAST.BILL.DATE TO ACT(20);      * LAST BILG
EQU ACT$LAST.STMT.DATE TO ACT(21);      * LAST STMT
EQU ACT$LAST.AGING.DATE TO ACT(22);     * LAST AGED
EQU ACT$CONNECT.DATE TO ACT(23);        * STMT RUN
EQU ACT$CREDIT.STATUS TO ACT(24);       * CR
EQU ACT$DISC.DATE TO ACT(25);           * DISC DATE
EQU ACT$DISC.REASON TO ACT(26);         * D.R
EQU ACT$DEPOSIT.AMT TO ACT(27);         * DEP.AMT
EQU ACT$DEPOSIT.TAX TO ACT(28);         * DEP.TAX
EQU ACT$EFT.BILLING TO ACT(29);         * IS SERVICE PAYABLE BY EFT?
EQU ACT$SERVICES TO ACT(30);            * 10
EQU ACT$QNTYS TO ACT(31);               * QTY
EQU ACT$BILL.FREQS TO ACT(32);          * BF
EQU ACT$BILL.FROM.DATES TO ACT(33);     * BILL.FROM
EQU ACT$BILL.TO.DATES TO ACT(34);       * BILL.TO
EQU ACT$DVC.NUMS TO ACT(35);            * SERIAL.NUMBER
EQU ACT$SVC.LOCATIONS TO ACT(36);       * LOC
EQU ACT$SVC.START.DATES TO ACT(37);     * SERV START
EQU ACT$SALESMAN TO ACT(38);            * SALESMAN WHO SOLD THE SERVICE
EQU ACT$SVC.CHG.DATES TO ACT(39);       * SERV CHANGE
EQU ACT$RATE.QNTYS TO ACT(40);          * OUTLETS
EQU ACT$MTHLY.RATES TO ACT(41);         * OUTLET RATE
EQU ACT$TAX.NAMES TO ACT(42);           * TAX
EQU ACT$TAX.AMTS TO ACT(43);            * TAX AMT.
EQU ACT$EARNED.REV TO ACT(44);          * EARNED REV FOR MONTH AT MONTH-END
EQU ACT$PRIOR.PER.REV.AMTS TO ACT(45);  * PRIOR.REV
EQU ACT$BILLING.RUNS TO ACT(46);        * BILL.RUN
EQU ACT$PEND.WO.NUMS TO ACT(47);        * PEND.WO
EQU ACT$PO.BOX TO ACT(48);              * PO BOX
EQU ACT$STMT.MSG.NUM TO ACT(49);        * MSG
EQU ACT$MESSAGE TO ACT(50);             * ACCOUNT.MESSAGE
~ACT.VAR.EQUATES~
*CODE.SEGMENT: ACT.VAR.EQUATES
*
* FILE 'ACT' EQUATES - GENERATED 14:05:52  30 DEC 1991
EQU ACT$ADD.ID TO 1;                    * ADDRESS.PTR
EQU ACT$STAT TO 2;                      * B.STAT
EQU ACT$PEND.ADD.ID TO 3;               * PEND.ADDR
EQU ACT$PEND.STAT TO 4;                 * P.ST
EQU ACT$CUS.NAME TO 5;                  * CUSTOMER.NAME
EQU ACT$ALT.NAME TO 6;                  * ALTERNATE.NAME
EQU ACT$BILL.NAME TO 7;                 * BILL.TO.NAME
EQU ACT$BILL.ADDR TO 8;                 * BILL.TO.ADDRESS
EQU ACT$BILL.EFF.DATE TO 9;             * B.EFF.DATE
EQU ACT$TEL.NUMS TO 10;                 * PHONE.NUMS
EQU ACT$ADDTL.DATA TO 11;               * ADDITIONAL.DATA
EQU ACT$LAST.NOTICE.DATE TO 12;         * DATE OF LAST ANNUAL NOTICE
EQU ACT$LAST.LATE.DATE TO 13;           * Last date for apply late charges
EQU ACT$SOLICITATION TO 14;             * SOLICITATION ALLOWED OR NOT ALLOWED
EQU ACT$RATE.TYPE TO 15;                * RATE
EQU ACT$PAY.METHOD TO 16;               * PMT
EQU ACT$BILL.DAY TO 17;                 * DAY
EQU ACT$AGED.AMTS TO 18;                * AGED AMOUNTS
EQU ACT$BALANCE TO 19;                  * BALANCE.
EQU ACT$LAST.BILL.DATE TO 20;           * LAST BILG
EQU ACT$LAST.STMT.DATE TO 21;           * LAST STMT
EQU ACT$LAST.AGING.DATE TO 22;          * LAST AGED
EQU ACT$CONNECT.DATE TO 23;             * STMT RUN
EQU ACT$CREDIT.STATUS TO 24;            * CR
EQU ACT$DISC.DATE TO 25;                * DISC DATE
EQU ACT$DISC.REASON TO 26;              * D.R
EQU ACT$DEPOSIT.AMT TO 27;              * DEP.AMT
EQU ACT$DEPOSIT.TAX TO 28;              * DEP.TAX
EQU ACT$EFT.BILLING TO 29;              * IS SERVICE PAYABLE BY EFT?
EQU ACT$SERVICES TO 30;                 * 10
EQU ACT$QNTYS TO 31;                    * QTY
EQU ACT$BILL.FREQS TO 32;               * BF
EQU ACT$BILL.FROM.DATES TO 33;          * BILL.FROM
EQU ACT$BILL.TO.DATES TO 34;            * BILL.TO
EQU ACT$DVC.NUMS TO 35;                 * SERIAL.NUMBER
EQU ACT$SVC.LOCATIONS TO 36;            * LOC
EQU ACT$SVC.START.DATES TO 37;          * SERV START
EQU ACT$SALESMAN TO 38;                 * SALESMAN WHO SOLD THE SERVICE
EQU ACT$SVC.CHG.DATES TO 39;            * SERV CHANGE
EQU ACT$RATE.QNTYS TO 40;               * OUTLETS
EQU ACT$MTHLY.RATES TO 41;              * OUTLET RATE
EQU ACT$TAX.NAMES TO 42;                * TAX
EQU ACT$TAX.AMTS TO 43;                 * TAX AMT.
EQU ACT$EARNED.REV TO 44;               * EARNED REV FOR MONTH AT MONTH-END
EQU ACT$PRIOR.PER.REV.AMTS TO 45;       * PRIOR.REV
EQU ACT$BILLING.RUNS TO 46;             * BILL.RUN
EQU ACT$PEND.WO.NUMS TO 47;             * PEND.WO
EQU ACT$PO.BOX TO 48;                   * PO BOX
EQU ACT$STMT.MSG.NUM TO 49;             * MSG
EQU ACT$MESSAGE TO 50;                  * ACCOUNT.MESSAGE
~ACX.DIM~
*CODE.SEGMENT: ?
DIM ACX(10)
~ACX.EQUATES~
*CODE.SEGMENT: ?
* FILE 'ACX' EQUATES - GENERATED 09:33:44  09 NOV 1983
EQU ACX$SCAN.NAMES TO ACX(1);           * BALANCE OF NAME
EQU ACX$ACT.IDS TO ACX(2);              * CUSTOMER ACCOUNT NO.
~ADD.AIX.DIM~
*CODE.SEGMENT: ?
DIM ADD.AIX(25)
~ADD.DIM~
*CODE.SEGMENT: ADD.DIM
*
DIM ADD(25)
~ADD.EQUATES~
*CODE.SEGMENT: ADD.EQUATES
*
* FILE 'ADD' EQUATES - GENERATED 20:05:32  02 JAN 1996
EQU ADD$MULT.APT.NUMS TO ADD(1);        * STRING OF APT. NOS. AT THIS ADDRESS
EQU ADD$ACT.IDS TO ADD(2);              * CUSTOMER ACCOUNT NO.
EQU ADD$ACT.FROM.DATES TO ADD(3);       * ACCOUNT CONNECT DATE
EQU ADD$ACT.TO.DATES TO ADD(4);         * ACCOUNT DISCONNECT DATE
EQU ADD$STAT TO ADD(5);                 * ADDRESS SERVICE STATUS
EQU ADD$POST.CODE TO ADD(6);            * POSTAL/ZIP CODE OF ADDRESS
EQU ADD$DWELLING.TYPE TO ADD(7);        * TYPE OF DWELLING
EQU ADD$DROP.TYPE TO ADD(8);            * TYPE OF DROP
EQU ADD$HOT.OUTLETS TO ADD(9);          * NUMBER OF HOT OUTLETS AT ADDRESS
EQU ADD$WIRED.OUTLETS TO ADD(10);       * NUMBER OF OUTLETS WIRED AT ADDRESS
EQU ADD$MESSAGE TO ADD(11);             * ADDRESS MESSAGE
EQU ADD$GEOGRAPHIC.DATA TO ADD(12);     * GEOGRAPHIC DATA
EQU ADD$WALK.CODE TO ADD(13);           * POSTAL WALK NUMBER
EQU ADD$CONF.WO.NUMS TO ADD(14);        * CONFIRMED WORK ORDER NO.
EQU ADD$WKO.TYPE TO ADD(15);            * TYPE OF WORK ORDER
EQU ADD$WKO.ACT.ID TO ADD(16);          * ACCOUNT TO WHICH WORK ORDER APPLIED
EQU ADD$WKO.EFF.DATE TO ADD(17);        * EFFECTIVE DATE OF WORK ORDER
EQU ADD$WKO.COMPL.DATE TO ADD(18);      * COMPLETION DATE OF WORK ORDER
EQU ADD$OUTLET.LOCATIONS TO ADD(19);    * LOCATION OF OUTLET WITHIN ADDRESS
EQU ADD$TECH.INFO TO ADD(20);           * TECHNICAL INFORMATION FOR ADDRESS
EQU ADD$DROP TO ADD(21);                * DROP NUMBER
EQU ADD$LINE TO ADD(22);                * 
EQU ADD$AIX.ID TO ADD(23);              * 
EQU ADD$AIX.LOCATION TO ADD(24);        * 
EQU ADD$TRAPS TO ADD(25);               * TRAP TEXT
~ADD.VAR.EQUATES~
*CODE.SEGMENT: ADD.VAR.EQUATES
*
* FILE 'ADD' EQUATES - GENERATED 20:05:32  02 JAN 1996
EQU ADD$MULT.APT.NUMS TO 1;             * STRING OF APT. NOS. AT THIS ADDRESS
EQU ADD$ACT.IDS TO 2;                   * CUSTOMER ACCOUNT NO.
EQU ADD$ACT.FROM.DATES TO 3;            * ACCOUNT CONNECT DATE
EQU ADD$ACT.TO.DATES TO 4;              * ACCOUNT DISCONNECT DATE
EQU ADD$STAT TO 5;                      * ADDRESS SERVICE STATUS
EQU ADD$POST.CODE TO 6;                 * POSTAL/ZIP CODE OF ADDRESS
EQU ADD$DWELLING.TYPE TO 7;             * TYPE OF DWELLING
EQU ADD$DROP.TYPE TO 8;                 * TYPE OF DROP
EQU ADD$HOT.OUTLETS TO 9;               * NUMBER OF HOT OUTLETS AT ADDRESS
EQU ADD$WIRED.OUTLETS TO 10;            * NUMBER OF OUTLETS WIRED AT ADDRESS
EQU ADD$TECH.INFO TO 11;                * TECHNICAL INFORMATION FOR ADDRESS
EQU ADD$GEOGRAPHIC.DATA TO 12;          * GEOGRAPHIC DATA
EQU ADD$WALK.CODE TO 13;                * POSTAL WALK NUMBER
EQU ADD$CONF.WO.NUMS TO 14;             * CONFIRMED WORK ORDER NO.
EQU ADD$WKO.TYPE TO 15;                 * TYPE OF WORK ORDER
EQU ADD$WKO.ACT.ID TO 16;               * ACCOUNT TO WHICH WORK ORDER APPLIED
EQU ADD$WKO.EFF.DATE TO 17;             * EFFECTIVE DATE OF WORK ORDER
EQU ADD$WKO.COMPL.DATE TO 18;           * COMPLETION DATE OF WORK ORDER
EQU ADD$OUTLET.LOCATIONS TO 19;         * LOCATION OF OUTLET WITHIN ADDRESS
EQU ADD$MESSAGE TO 20;                  * ADDRESS MESSAGE
EQU ADD$DROP TO 21;                     * DROP NUMBER
EQU ADD$LINE TO 22;                     * 
EQU ADD$AIX.ID TO 23;                   * 
EQU ADD$AIX.LOCATION TO 24;             * 
EQU ADD$TRAPS TO 25;                    * TRAP TEXT
~AI.CHANNEL.CNTRL~
*CODE.SEGMENT: AI.CHANNEL.CNTRL
*
*
DOWN.CHANNELS: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Down Channels" "L#19":
*
LOOP
*
GOSUB DISPLAY.STATUS; * :
ERR.TEXT = "Enter channel number(s) to down (<cr> to end): "
PRINT @(0,22):CLL:@(10,22):ERR.TEXT:
OVC = ONE; COLM = LEN(ERR.TEXT) + 10 + TWO
ERR.TEXT = "Enter the reason: "
PRINT @(ZERO,23):CLL:@(COLM - LEN(ERR.TEXT) - 3,23):ERR.TEXT:
*
LOOP
PRINT @(COLM,22):CLL:
INPUT CHANNEL:
IF CHANNEL = "KILL" THEN STAT = TRUE; RETURN
IF CHANNEL NE EMPTY THEN
LOCATE CHANNEL IN CHANNEL.MLES<ONE> BY "AR" SETTING LOC THEN CHANNEL.FOUND = TRUE ELSE CHANNEL.FOUND = FALSE
IF NOT(CHANNEL.FOUND) THEN
TEXT<-ONE> = CHANNEL:" is not a valid channel number."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END ELSE
LOCATE CHANNEL IN STL<STATUS.CHANNEL> BY "AR" SETTING LOC THEN CHANNEL.FOUND = TRUE ELSE CHANNEL.FOUND = FALSE
IF CHANNEL.FOUND THEN
IF STL<STATUS.CHAN.STAT,LOC> NE EMPTY THEN
TEXT<-ONE> = CHANNEL:" is already down."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
PRINT @(COLM,23):; INPUT REASON:
* AIW$MLE.NUM<ONE,OVC> = CHANNEL
STL<STATUS.CHAN.STAT,LOC> = REASON
STL<STATUS.CHECKED,LOC> = DATE():"*":TIME()
DOWNED.CHANNELS.CHANGED = ONE
OVC = OVC + ONE
* HANDLER.COMMAND<-ONE> = FUNC
COLM = COLM + 3
END; * found
END; * found
END; * not empty
UNTIL CHANNEL = EMPTY OR COLM GT 78 DO
REPEAT
UNTIL CHANNEL = EMPTY DO
REPEAT
*
WRITE STL ON COM.FILE,"AI.STATUS.CHAN.":HEADEND
*
RETURN
*
*
UP.CHANNELS: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Up Channels" "L#19":RVE:; RQM
*
LOOP
*
GOSUB DISPLAY.STATUS; * :
ERR.TEXT = EMPTY
IF NOT(UP.ALL.CHANNELS) THEN
ERR.TEXT = "Enter channel number(s) to up (<cr> to end): "
PRINT @(11,22):CLL:ERR.TEXT:
END
OVC = ONE; COLM = LEN(ERR.TEXT) + 11 + TWO
LOOP
IF UP.ALL.CHANNELS THEN
LOOP
CHANNEL = STL<STATUS.CHANNEL,UP.ALL.CHANNELS>
TMP = STL<STATUS.CHAN.STAT,UP.ALL.CHANNELS>
UP.ALL.CHANNELS = UP.ALL.CHANNELS + ONE
UNTIL (CHANNEL = EMPTY) OR (TMP) DO
REPEAT
END ELSE
PRINT @(COLM,22):CLL:
INPUT CHANNEL:
IF CHANNEL = "KILL" THEN STAT = TRUE; RETURN
END
IF CHANNEL NE EMPTY THEN
LOCATE CHANNEL IN STL<STATUS.CHANNEL> BY "AR" SETTING LOC THEN CHANNEL.FOUND = TRUE ELSE CHANNEL.FOUND = FALSE
IF CHANNEL.FOUND THEN
IF NOT(UP.ALL.CHANNELS) AND STL<STATUS.CHAN.STAT,LOC> EQ EMPTY THEN
TEXT<-ONE> = CHANNEL:" is not down."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END ELSE
STL<STATUS.CHAN.STAT,LOC> = EMPTY
COLM = COLM + 3
STL<STATUS.CHECKED,LOC> = DATE():"*":TIME()
* HANDLER.COMMAND<-ONE> = FUNC
DOWNED.CHANNELS.CHANGED = ONE
OVC = OVC + ONE
* AIW$MLE.NUM<ONE,OVC> = CHANNEL
END
END ELSE
TEXT<-ONE> = CHANNEL:" is not in system."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
END
UNTIL CHANNEL = EMPTY OR COLM GT 78 DO
REPEAT
UNTIL CHANNEL = EMPTY DO
REPEAT
WRITE STL ON COM.FILE,"AI.STATUS.CHAN.":HEADEND
*
RETURN
*
~AI.CNTRL.CLEAR~
*CODE.SEGMENT: AI.CNTRL.CLEAR
*
* DAVID HORSMAN
*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
PORT.NUM = PORT.KEY
PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORT.LIST.BUILD = 9
PORT.CONT = FALSE; PORT.TYPE = EMPTY; PORT.ON = FALSE
PORT.LOC = ONE; PORT.VC = ONE
*
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
TMP = EMPTY; TMP0 = EMPTY; TPM1 = EMPTY; TMP2 = EMPTY
*
AI.STATUS = FALSE; SEND.STATUS = FALSE
TEXT = EMPTY; OUTPUTS = EMPTY
FAST.DISPLAY = FALSE; STATUS.CYCLE = FALSE
MSG.DISP = FALSE; MSG = EMPTY; MSG.N = ZERO
*
COM.ID = EMPTY; COM.ID.LIST = EMPTY
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY; COM.AI.ERR.TYPE = EMPTY
COM.AI.ERR.FUNC = EMPTY; COM.AI.ERR.DISP = ONE
COM.AI.RUN.ELP = ZERO; COM.AI.ON = EMPTY; COM.AI.UP = EMPTY
*
COM.AI.ID = EMPTY; MAT COM.AI = EMPTY
LCK.COM.AI = FALSE; COM.AI.ON.FILE = FALSE
COM.AI.PORT = EMPTY; COM.AI.ELP = ZERO; NEXT.COM.AI.ID = EMPTY
*
COM.AIP.ID = EMPTY; MAT COM.AIP = EMPTY
LCK.COM.AIP = FALSE; COM.AIP.ON.FILE = FALSE
COM.AIP.PORT = EMPTY; COM.AIP.ELP = ZERO; NEXT.COM.AIP.ID = EMPTY
*
~AI.CNTRL.UTIL.DISP.HDR~
*CODE.SEGMENT: AI.CNTRL.UTIL.DISP.HDR
* USED BY: AI.CONTROL.UTILITY
*
LOAD.TITLE: *
*
* : * Init DISPlay settings
BEGIN CASE
CASE FUNC EQ "DI"; TITLE = "Display handler status"; DISP.ONLY = TRUE
CASE FUNC EQ AI.ON; TITLE = "Turn ON the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ AI.OFF; TITLE = "Turn OFF the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ AI.DN; TITLE = "Down the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ AI.UP; TITLE = "Up the handler"; DISP.ONLY = ZERO 
CASE FUNC EQ "DC"; TITLE = "Down channel(s)"; DISP.ONLY = ZERO 
CASE FUNC EQ "UC"; TITLE = "Up channel(s)"; DISP.ONLY = ZERO 
CASE TRUE; TITLE = "Unknown function"; DISP.ONLY = ZERO 
END CASE
*
TITLE = "Addressable Interface - ":TITLE
*
RETURN
*
*
DISPLAY.TITLE: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Display Title" "L#19":RVE:; RQM
IF NOT(ERR.DISP.ONLY) THEN
PRINT @(ZERO,ZERO):CLS:
END ELSE
* PRINT @(ZERO,ZERO):CLL:@(ZERO,ONE):CLL:@(ZERO,TWO):CLL:@(ZERO,3):CLL:@(ZERO,4):CLL:@(ZERO,22):CLL:@(ZERO,23):CLL:
PRINT @(ZERO,TWO):CLL:@(ZERO,3):CLL:@(ZERO,4):CLL:@(ZERO,22):CLL:@(ZERO,23):CLL:
END
ALREADY.DISPLAYED = EMPTY
PRINT @(ZERO,ZERO):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE) / TWO))):CO.NAME) "L#56":("Who: ":WHO) "L#12":
PRINT @(ZERO,ONE):OCONV(TIME(),"MTS") "L#12":(SPACE(28-LEN(TITLE) / TWO):TITLE) "L#56":("Oper: ":OPER) "L#12":RVE:
*
RETURN
*
*
~AI.CNTRL.UTIL.DOC.SCNDRY~
*CODE.SEGMENT: AI.CNTRL.UTIL.DOC.SCNDRY
* USED BY: AI.CONTROL.UTILITY
*
*: end of Main LOOP (function stack exausted) * Main 1
*
*: End of primary function * Main 1
*
*: Start of secondary cyclic DISPLAY function * Main 2
*:     note: quits on any keyboard character
*
*
~AI.CNTRL.UTIL.DOC.START~
*CODE.SEGMENT: AI.CNTRL.UTIL.DOC.START
* USED BY AI.CONTROL.UTILITY
*: end of INIT
*
!
*
*: Program Mainline -  MAIN Section
*
*: *Consists of two functions:
*
*:  Primary - Process requested and resultant command functions
*:   (Stacked functions and error analysis)
*
*: *Secondary - Display Handler Status in a Monitor Mode
*: Includes : Handler Queue, Channel Status
*:     Error Messages, Handler Log
*:     Handler Status
*
SYS.LOCT = "START"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
*: LOOP BACK ON ERROR
*
~AI.CNTRL.UTIL.DOC.TOP~
*CODE.SEGMENT: AI.CNTRL.UTIL.DOC.TOP
* USED BY: AI.CONTROL.UTILITY
*
*
*:  Multifunction utility program...
*
*: The function performed is input through the menu handler
*: parameter:
*
*: DI     Display handler status
*: START  Start the handler
*:    ON    "    "     "
*: STOP   Stop the handler at the head end
*:  OFF     "   "    "     "   "    "   "
*: DN     Down the handler
*: UP     Up the handler
*: DC     Down channel(s)
*: UC     Up channel(s)
*
~AI.COM.AIP.UPD~
*CODE.SEGMENT: AI.COM.AIP.UPD*
*
*
*
*
SYS.LOCT = "AI.COM.AIP.UPD"
** AI.SRCE = "U"
** HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
** *
COM.AI.ID = "AI.TYPE.":AI.CODE
* MAT COM.AI S/D ALREADY PRESENT
** READV COMMPORT FROM COM.FILE,COM.AI.ID,12 ELSE COMMPORT = 999
COMMPORT = COM.AI$COMMPORT
*
COM.AIP.PORT = PORT
LOOP WHILE LEN(COM.AIP.PORT) LT 3 DO COM.AIP.PORT = ZERO:COM.AIP.PORT REPEAT
AI.DVC.NEXT.FOUND = TRUE
*
!
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND)
*
*
COM.AIP.ID = "AI*":AI.CODE:"*":COM.AIP.PORT:"*":AI.DVC.NEXT.CN
DT = DATE(); TM = TIME(); ELP = ZERO
*
LOOP
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LT LCK.ELP.MAX DO REPEAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
*
* SEND.STATUS = FALSE
AI.COM.FLAG = FALSE
DT = DATE(); TM = TIME()
*
IF CNT.TST$ID THEN
PRINT CLB:"Updating COM.AIP$INTFC.STAT. Enter <cr>: ":; INPUT TMP:
END
*
!
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
*
OK = TRUE
IF INDEX("#AIDVC#PVI#PVD#IVI#IVD#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE) THEN
IF WKO$STAT NE "C" AND WKO$STAT NE "D" THEN OK = FALSE
END ELSE
IF NOT(INDEX("#SEQ#UPB#DLE#SET#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE)) THEN OK = FALSE
END
*
IF NOT(OK) AND COM.AIP$RVRS.FL THEN
*
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 605
*
END ELSE
*
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
END; * OF NOT OK
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
* "TOUT" BEFORE COM.AIP$ERR.TYPE<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
SEND.STATUS = 601
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
IF NOT(COM.AIP$RVRS.FL) THEN
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
SEND.STATUS = 602
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP" AND NOT(COM.AIP$RVRS.FL)
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
SEND.STATUS = 607
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP" AND COM.AIP$RVRS.FL
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 603
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
SEND.STATUS = 604
*
CASE TRUE
* PRINT CLB:">>":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"<<":; INPUT TMP:
SEND.STATUS = 606
*
END CASE
*
*
!
*
IF SEND.STATUS THEN
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
*
IF COM.AIP$LOG.REQD OR SEND.STATUS THEN
OPEN "AIL" TO AIL.FILE THEN
AIL.SEQ.ID = "AI.LOG*":AI.CODE
* $INCLUDE IBP AI.LOG.WRITE
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.AIP.ID,AI.CODE,AI.SRCE,LOG.REQUIRED,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PROG,STAT)
END ELSE PRINT CLB:"AIL file missing! Enter <cr> . . . "; INPUT RSP; STAT = 999
END
*
*
NEXT SEND.COMM.CN
*
!
*
SEND.COMM.CN = ONE
*
*
***IF AI.COM.FLAG THEN
***MAT COM.AI = EMPTY
***HANDLER.COMMAND = COM.AIP$COMM; AI.TMP.STAT = EMPTY; SEND.TMP.STAT = EMPTY
**** CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
****CALL SYS.ITM.RLS(FILE.NAME,ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
***CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.TMP.STAT,SEND.TMP.STAT,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,SYS.PROG,STAT)
***TMP.STAT = AI.TMP.STAT
**** IF TMP.STAT THEN
**** PRINT BELL:CLB:"Addressable interface error (":TMP.STAT:") - Press <cr>":
**** INPUT TMP.RSP:; IF TMP.RSP = "KILL" THEN STAT = 999
**** END
***END ELSE
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
* CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
* CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"C","",LCK.STAT)
*
***END
*
END ELSE
*
* CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
* CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"D","",LCK.STAT)
AI.DVC.NEXT.FOUND = FALSE
*
END; * OF READ
*
*
IF AI.DVC.NEXT.FOUND THEN
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"E","",LCK.STAT)
*
*
NEXT AI.DVC.NEXT.CN
*
!
*
* IF SEND.STATUS AND NOT(AUTO.RUN) THEN
* PRINT BELL:CLB:"Addressable interface error (":SEND.STATUS:") - Press <cr>":
* INPUT TMP.RSP:; * IF TMP.RSP = "KILL" THEN STAT = 999; RETURN
* END
*
~AI.CU.TOP~
*CODE.SEGMENT: AI.CU.TOP
* USED BY: AI.CONTROL.UTILITY
*
* DAVID HORSMAN (C) 1992
*
*
!: * Input Parameters
*
INPUT FUNC:
INPUT RUN.TYPE:
INPUT FAST.DISPLAY:
*
*
!: * System Control
*
*: * System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CONTROL.UTILITY"; SYS.LOCT = EMPTY
SYS.APPL.LOC = ONE
PORT.KEY = ("000":PORT) "R#3"
AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE; DISP.ONLY = FALSE
*
*
LCK.TYPE = -8
LCK.ELP = ZERO; LCK.ELP.MAX = 60; * CHECK.ELP.MAX = 5
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.STAT = LCK.TYPE
*
!: * System Files
SYS.LOCT = "SF"; * IF CNT.TST$LBL THEN PRINT @(60,20):"System Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "CNT" TO CNT.FILE ELSE TEXT<-ONE> = "Can't open CNT"; GOSUB ERROR; STOP
READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.DATA<ONE,ONE> ELSE CO.NAME = EMPTY; CO.DATA = EMPTY
OPEN "PAR" TO PAR.FILE ELSE TEXT<-ONE> = "Can't open PAR"; GOSUB ERROR; STOP
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE TEXT<-ONE> = "Can't open LOCKS"; GOSUB ERROR; STOP
* LCK.FILE = ZERO; * REV ONLY
*
COMPONENTS.DFLT = EMPTY
*
~AI.CU.TOP.A~
*CODE.SEGMENT: AI.CU.TOP.A
* VERSION: 940117 1.1  CHANGED 'Comm Port' to 'AI Code' to FUNC.
* USED BY: AI.CONTROL.UTILITY
*
* DAVID HORSMAN (C) 1992
*
*
COMPONENTS = EMPTY; CHANNEL.MLES = EMPTY; CHAN.ALL = FALSE
STATUS.LOC = ONE; STATUS.CYCLE = FALSE
DVC.LOC = ONE
STVC = ZERO; BVC = ZERO; ACTIONS = EMPTY; PRIOR.CHANNEL.MLES = EMPTY
STL = EMPTY; MVC = ZERO; MLE.NUM = ZERO; STL.LOC = ZERO; ST.VC = ZERO
DOWNED.CHANNELS.CHANGED = EMPTY
*
!: * System Files
SYS.LOCT = "SF"; IF CNT.TST$LBL THEN PRINT @(60,20):"System Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "COM" TO COM.FILE ELSE TEXT<-ONE> = "Can't open COM"; GOSUB ERROR; STOP
*
*
!: * Application Files
SYS.LOCT = "AF"; IF CNT.TST$LBL THEN PRINT @(60,20):"Appl Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "AIX" TO AIX.FILE ELSE TEXT<-ONE> = "Can't open AIX"; GOSUB ERROR; STOP
*
OPEN "ACT" TO ACT.FILE ELSE TEXT<-ONE> = "Can't open ACT"; GOSUB ERROR; STOP
*
*: * Init INternal VARiables
SYS.LOCT = "VAR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Variables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
AI.SRCE = "C"
PORTS.LIST.BUILD = 9; AI.SCAN = TRUE
AI.SCAN.DT = DATE(); AI.SCAN.TM = TIME(); STAT = FALSE
MSG.DISP = FALSE; FUNC.CHNG = EMPTY
STATUS.CYCLE = FALSE
*
******
*
ERR.CL = 31; ERR.LN = 5; ERR.LEN = 48
ERR.LN.MIN = ERR.LN; ERR.LN.MAX = 9
ERR.HDR = "Handler Messages "; ERR.BELL = TRUE
*
IF ERR.CLB THEN ERR.CL = ZERO; ERR.LEN = 68
*
******
*
CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 18
CHECK.LEN = 35; CHECK.LN.HI = ZERO
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
CHECK.ELP.MAX = 5
*
******
*
*: * Func
IF FUNC EQ "START" THEN FUNC = AI.ON
IF FUNC EQ "STOP" THEN  FUNC = AI.OFF
IF FUNC EQ "DC" OR FUNC EQ "UC" THEN CHAN.ALL = TRUE
*
*: * Run Type
IF RUN.TYPE NE "1" AND RUN.TYPE NE "2" THEN RUN.TYPE = "1"
IF RUN.TYPE EQ TWO THEN ERR.DISP.ONLY = 3
*
*: * Fast.Display
* IF FAST.DISPLAY NE "0" AND FAST.DISPLAY NE "1" THEN FAST.DISPLAY = "0"
*
*: * Control
OLD.FUNC = EMPTY; SAVE.FUNC = EMPTY; ORIG.FUNC = FUNC
UP.ALL.CHANNELS = FALSE; HANDLER.COMMAND = EMPTY
ON.TRIED = ZERO; OFF.TRIED = ZERO; UP.TRIED = ZERO; DN.TRIED = ZERO
*
*: * Operator
OPER = EMPTY; OPER.LN = 10; OPER.CL = 10; OPER.DESC.LN = 10
OPER.DESC.CL = 40; OPER.DESC.FMT = "L#20"; OPER.STAT = FALSE
OPER.DISP = FALSE; OPER.RVB = TRUE; OPER.TEXT = "Your operator ID is: "
IF RUN.TYPE EQ TWO THEN OPER.DISP = TRUE
*
*
!: * Init Tables
SYS.LOCT = "TBL"; IF CNT.TST$LBL THEN PRINT @(60,20):"Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
*
** ** ** READV OFF.FLAG FROM COM.FILE,"AI.OFF.":PORT.KEY,ONE THEN
** ** ** DELETE COM.FILE,"AI.OFF.":PORT.KEY
** ** ** END
** ** ** READV OFF.FLAG FROM COM.FILE,"AI.OFF.ALL",ONE THEN
** ** ** DELETE COM.FILE,"AI.OFF.ALL"
** ** ** END
EXEC.VERB = 'EQ "AI.OFF.]"'
TMP = EMPTY
EXECUTE "SELECT COM ":EXEC.VERB, //SELECT. > COM.ID.LIST, //OUT. > TMP
TMP = EMPTY
CONT = TRUE
LOOP
READNEXT COM.ID FROM COM.ID.LIST ELSE CONT = FALSE
WHILE CONT DO
DELETE COM.FILE,COM.ID
* PRINT "Off Flag ":COM.ID:" Cleared!"
REPEAT
OFF.FLAG = FALSE
*
COMPONENTS = EMPTY
*
PRINT @(ZERO,3):CLS:
*
*: * Init CALLs
*
*CALL INPUT.OPERATOR: *
CALL INPUT.OPERATOR(OPER,OPER.POSN,OPER.LN,OPER.CL,OPER.TEXT,OPER.DESC.LN,OPER.DESC.CL,OPER.DESC.FMT,OPER.RVB,RUN.TYPE,OPER.DISP,OPER.STAT)
*
IF OPER.STAT THEN STOP
OPER.DISP = TRUE
OPER.LN = 3; OPER.CL = 31; OPER.DESC.LN = 3; OPER.DESC.CL = 49
OPER.DESC.FMT = "L#15"; OPER.STAT = EMPTY; OPER.DISP = TRUE
OPER.RVB = TRUE; OPER.TEXT = "Operator: "
OPER.POSN = EMPTY
*
~AI.CU.TOP.B~
*CODE.SEGMENT: BI.CU.TOP.A
* VERSION: 940117 1.1  CHANGED 'Comm Port' to 'AI Code' to FUNC.
* USED BY: AI.CONTROL.UTILITY
*
* DAVID HORSMAN (C) 1992
*
*
*
IF LCK.STAT THEN AI.RESET = TRUE
*
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE AI.ERRORS = EMPTY
DVC.LOC = ONE
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE MAT COM.AIIERR = EMPTY
*
GOSUB READ.STL; * : *
*
* repeat until valid subject
*
IF FUNC EQ AI.OFF AND COM.AI$UP.DN.STAT EQ AI.UP THEN
INS 391 BEFORE COM.AI.ERR<ONE>
INS "Requested OFF needs a DN first" BEFORE COM.AI.ERR.TEXT<ONE>
INS "FUNC" BEFORE COM.AI.ERR.TYPE<ONE>
INS AI.DN BEFORE COM.AI.ERR.FUNC<ONE>
INS AI.DN BEFORE FUNC.CHNG<ONE>
END
*
IF FUNC EQ AI.UP AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
INS 491 BEFORE COM.AI.ERR<ONE>
INS "Requested UP needs a ON first" BEFORE COM.AI.ERR.TEXT<ONE>
INS "FUNC" BEFORE COM.AI.ERR.TYPE<ONE>
INS AI.ON BEFORE COM.AI.ERR.FUNC<ONE>
INS AI.ON BEFORE FUNC.CHNG<ONE>
END
*
IF FUNC EQ AI.DN OR FUNC EQ AI.UP THEN
IF FUNC EQ COM.AI$UP.DN.STAT THEN INS "DI" BEFORE FUNC.CHNG<ONE>
END
*
~AI.ERR.INIT~
*CODE.SEGMENT: AI.ERR.INIT
* USED BY: AI.HANDLER
*          AI.TALKER
*
* DAVID HORSMAN
*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
PORT.NUM = PORT.KEY
PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORTS.LIST.BUILD = 9
PORT.CONT = FALSE; PORT.TYPE = EMPTY; PORT.ON = FALSE
PORT.LOC = ONE; PORT.VC = ONE
*
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
TMP = EMPTY; TMP0 = EMPTY; TPM1 = EMPTY; TMP2 = EMPTY
*
AI.STATUS = FALSE; SEND.STATUS = FALSE
COMMPORT = EMPTY; HEADEND = EMPTY
AI.CODE = EMPTY; INTFC.CODE = EMPTY; INTFC.TYPE = EMPTY
AI.DOWN = FALSE; AI.RESET = FALSE; AI.SRCE = "?"
AI.SCAN = TRUE; AI.SCAN.DT = DATE(); AI.SCAN.TM = TIME()
AI.SLEEP = EMPTY; AI.ERRORS = EMPTY; AI.CHK.ERR = EMPTY
TEXT = EMPTY; OUTPUTS = EMPTY
STATUS.CYCLE = FALSE; OFF.FLAG = FALSE
MSG.DISP = FALSE; MSG = EMPTY; MSG.N = ZERO
* FAST.DISPLAY = FALSE
*
COM.ID = EMPTY; COM.ID.LIST = EMPTY
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY; COM.AI.ERR.TYPE = EMPTY
COM.AI.ERR.FUNC = EMPTY; COM.AI.ERR.DISP = ONE
COM.AI.RUN.ELP = ZERO; COM.AI.ON = EMPTY; COM.AI.UP = EMPTY
*
COM.AI.ID = EMPTY; LCK.COM.AI = FALSE; COM.AI.ON.FILE = FALSE
COM.AI.PORT = EMPTY; COM.AI.ELP = ZERO; NEXT.COM.AI.ID = EMPTY
COM.AI.ON = FALSE; COM.AI.UP = FALSE
*
COM.AIP.ID = EMPTY; LCK.COM.AIP = FALSE; COM.AIP.ON.FILE = FALSE
COM.AIP.PORT = EMPTY; COM.AIP.PORT.FIRST = TRUE
COM.AIP.ELP = ZERO; NEXT.COM.AIP.ID = EMPTY
*
ERR.DISP.ONLY = FALSE; ERR.CLB = FALSE
ERR.CL = 31; ERR.LN = 5; ERR.LEN = 48; ERR.FMT = EMPTY
ERR.LN.MIN = 5; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CLS = FALSE; ERR.BELL = FALSE; ERR.CR = FALSE
ERR.HDR = "Error Messages "; ERR.TEXT = EMPTY
ERR.LAST = EMPTY; ERR.TMP = EMPTY
*
CHECK.CL = ZERO; CHECK.LN = 11; CHECK.LEN = 33; CHECK.FMT = EMPTY
CHECK.LN.MIN = 11; CHECK.LN.MAX = 18; CHECK.LN.HI = ZERO
CHECK.ELP.MAX = 60
*
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
MAT COM.AI = EMPTY; MAT COM.AIP = EMPTY
*
LCK.ELP.MAX = 60
*
~AI.ERR.VAR.EQUATES~
*CODE.SEGMENT: AI.ERR.VAR.EQUATES
*
*
* ERRORS
*
EQU ERR$OK           TO 0
EQU ERR$TRANS.NEXT   TO 701
EQU ERR$SYSTEM.BAD   TO 702
EQU ERR$PCK.END      TO 703
EQU ERR$COMMPORT.BAD TO 704
EQU ERR$CMD.FUTR     TO 705
EQU ERR$PPV.DATA.BAD TO 706
EQU ERR$DVC.MISSING  TO 707
EQU ERR$TABLE.FULL   TO 708
EQU ERR$DVC.EXISTS   TO 709
EQU ERR$NO.UNIT      TO 711
EQU ERR$NO.CMD       TO 718
EQU ERR$CMD.BAD      TO 719
EQU ERR$EVNT.BAD     TO 722
EQU ERR$EVNT.EXISTS  TO 723
EQU ERR$SEND.LRC     TO 731
EQU ERR$RECV.PCK.STX TO 732
EQU ERR$RECV.LRC     TO 733
EQU ERR$COLL         TO 734; * Collection Status Error
EQU ERR$TRANS.NEXT.RECV TO 740; * MISMATCH ON PKT TRANS SEQ VS FILE
EQU ERR$BUF.OVFL     TO 760
EQU ERR$ENBL.BAD     TO 771
EQU ERR$RSP.LEN      TO 777
EQU ERR$CMD.LEN      TO 778
EQU ERR$SEND.PCK.STX TO 779
EQU ERR$HE.BUSY      TO 785
EQU ERR$POC.BUSY     TO 786
EQU ERR$CHAN.DN      TO 100
EQU ERR$CHAN.UP      TO 200
EQU ERR$NOT.SENT     TO 300
EQU ERR$NO.DVC.TYPE  TO 301
EQU ERR$TYPE.NOT.POC TO 302
EQU ERR$CHECK.TOUT   TO 371
EQU ERR$TOUT         TO 201
EQU ERR$TOUT.AI      TO 101
EQU ERR$DATA.BAD     TO 361
EQU ERR$RETRY.MAX    TO 400
EQU ERR$NO.RSP       TO 500
EQU ERR$HANDLER.ERR  TO 800
EQU ERR$HANDLER.MSG  TO 801
EQU ERR$FAILED       TO 900
EQU ERR$LOCKED       TO 909
EQU ERR$BAD.RSP      TO 910
EQU ERR$UNKNOWN      TO 991
EQU ERR$OPER.KILL    TO 999
*
~AI.HERROR.XREF~
*CODE.SEGMENT: AI.HERROR.XREF
* USED.BY: AI.HANDLER
*          AI.CHECK.HANDLER - 29 MAR 94
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
*
!
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
*
LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
*
COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
*
TMP2 = COM.AIHERR$DESC<ONE,ERR.LOC>
LOOP WHILE INDEX(TMP2,"@",ONE) DO
TMP = FIELD(TMP2,"@",ONE)
TMP0 = FIELD(TMP2,"@",TWO)
TMP1 = FIELD(TMP2,"@",3)
TMP1 = TMP2[COL1()+ONE,9999]
TMP.VAR = EMPTY
BEGIN CASE
CASE TMP0 EQ "COM.AI.RUN.ELP"
TMP.VAR = COM.AI.RUN.ELP
CASE TMP0 EQ "COM.AI$ON.OFF"
TMP.VAR = COM.AI$ON.OFF
CASE TMP0 EQ "COM.AI.ON.OFF.ELP"
TMP.VAR = COM.AI.ON.OFF.ELP
CASE TMP0 EQ "COM.AI$UP.DN"
TMP.VAR = COM.AI$UP.DN
CASE TMP0 EQ "COM.AI.UP.DN.ELP"
TMP.VAR = COM.AI.UP.DN.ELP
CASE TMP0 EQ "COM.AIP.ELP"
TMP.VAR = COM.AIP.ELP
CASE TMP0 EQ "COM.AIP.PORT"
TMP.VAR = COM.AIP.PORT
CASE TMP0 EQ "COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>"
TMP.VAR = COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
END CASE
TMP2 = TMP:TMP.VAR:TMP1
REPEAT
COM.AI.ERR.TEXT<-ONE> = TMP2
*
COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP
END
*
DEL AI.CHK.ERR<ONE>
REPEAT
*
END
*
**** ##### ***** End of AI.HERROR.XREF
~AI.INCL.DISP.AIP.STAT~
*CODE.SEGMENT: AI.INCL.DISP.AIP.STAT
* VERSION: 960513 1.2 SPLIT OFF FROM AI.INCL.WAITFOR.COMMAND
* PRIOR: 940130 1.1  COM.AI.ID CHANGED.
* USED BY: AI.TALKER
*          AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* INCL CREATED: MAY 96
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*   1990        ALL RIGHTS RESERVED
*
!
*
SYS.LOCT = "AI.INCL.DISP.AIP.STAT"
*
IF DISP.ONLY THEN RETURN
*
***NUM.TRIES = ZERO; MAX.PAUSE = 120; STD.PAUSE = 5
NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = COM.AI$MAX.PAUSE; STD.PAUSE = COM.AI$STD.PAUSE
***NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = 30; STD.PAUSE = ONE
IF NOT(MAX.PAUSE) THEN MAX.PAUSE = 30
IF NOT(STD.PAUSE) THEN STD.PAUSE = ONE
INTFC.PAUSE = ZERO
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF ELP.MAX LT 60 THEN ELP.MAX = 60
ELP.MAX = 15
WF.DT = DT; WF.TM = TM
* WF.C.LOC = HANDLER.COMMAND<ONE,ONE> (FUNC OR COMMAND) ( NOT USED )
* STAT = 0;  WF.C.FUNC = PORT NUMBER
WF.C.FUNC = PORT.KEY
COM.AI.ON.FILE = FALSE; HANDLER.DONE = FALSE
COM.AI.ID = "AI.TYPE.":AI.CODE; COM.ID = COM.AI.ID
*
!
*
DISPLAY.AIP.STATUS: *
*
**SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
***
**FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
***
*** PRINT @(0,20):CLL:@(0,21):CLL:@(20,21):
**PRINT @(0,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):CLL:@(15,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):
**TMP = REM(NUM.TRIES,TWO)
**IF NOT(TMP) THEN PRINT RVB:
**PRINT "waiting on the handler . . . ":
**HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
**IF NOT(TMP) THEN PRINT RVE: ELSE PRINT RVB:
***@*PRINT @(46,23):(" [":COM.AIP$COMM.PORT<ONE,SEND.COMM.CN>:"]") "L#8":(" (":MAX.PAUSE - HANDLER.ELP:")") "L#10":RVE:@(ZERO,ONE):
**PRINT @(46,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):(" [":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:"]") "L#22":(" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":RVE:@(ZERO,ONE):
***
**NEXT SEND.COMM.CN
*
*
* TMP = REM(NUM.TRIES,3)
TMP = FALSE
IF NOT(TMP) THEN
IF FAST.DISPLAY OR COM.AI.ERR.DISP THEN
TEXT = EMPTY; OUTPUTS = EMPTY
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
LCK.ELP.MAX = 3
IF COM.AI$GENIE.WINDOW EQ "Y" AND AI.SRCE EQ "T" THEN PORTS.LIST.BUILD = 7
GOSUB INTFC.CHECK
GOSUB INTFC.MESSAGES
IF LEN(OUTPUTS) THEN TEXT = OUTPUTS:AM:TEXT
ERR.DISP.ONLY = TWO
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE
END
END
*
!
*
AI.DVC.NEXT.FOUND = TRUE; AI.DVC.DONE = TRUE
MAX.PAUSE = COM.AI$MAX.PAUSE
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND) OR HANDLER.DONE
***AI.DVC.NEXT.CN = ONE
*
*
*
DT = DATE(); TM = TIME(); ELP = ZERO
COM.AIP.ID = "AI*":AI.CODE:"*":PORT:"*":AI.DVC.NEXT.CN
*#*LOOP
LCK.STAT = LCK.TYPE
**CALL LCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"C","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
** HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
** IF HANDLER.ELP GT MAX.PAUSE + COM.AIP$MAX.PAUSE THEN
** TEXT<-ONE> = "Can't wait longer than ":MAX.PAUSE + COM.AIP$MAX.PAUSE:" seconds."
** AI.STATUS = 201
*****INS  "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
*****INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
** * COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
** END
*#*UNTIL NOT(LCK.STAT) OR ELP GT ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
*#*IF LCK.COM.AIP THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; AI.DVC.NEXT.FOUND = FALSE
*
*
*#*IF LCK.COM.AIP THEN
*
*
IF AI.DVC.NEXT.FOUND THEN
*
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
IF COM.AIP$MAX.PAUSE GT INTFC.PAUSE THEN INTFC.PAUSE = COM.AIP$MAX.PAUSE
IF AI.DVC.NEXT.CN GT ONE THEN
MAX.PAUSE = MAX.PAUSE + INT(COM.AI$MAX.PAUSE / TWO)
END
*
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
* PRINT @(0,20):CLL:@(0,21):CLL:@(20,21):
* - ((AI.DVC.NEXT.CN-1) * 2)
*PRINT @(0,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN - ((AI.DVC.NEXT.CN-1) * 2))):CLL:@(15,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN - ((AI.DVC.NEXT.CN-1) * 2))):
TMP = REM(NUM.TRIES,TWO)
*
IF SEND.COMM.CN GT ONE THEN
MAX.PAUSE = MAX.PAUSE + INT(COM.AI$MAX.PAUSE / TWO)
END
IF SEND.COMM.CN EQ ONE THEN
*PRINT @(0,(23 - 1 - ((AI.DVC.NEXT.CN - 1) * 2))):CLL:
***PRINT @(0,(23 - AI.DVC.NEXT.CN - 1)):CLL:SPACE(6):
PRINT @(CHECK.LEN + 1,CHECK.LN.MIN - 1):
IF NOT(TMP) THEN PRINT RVB:
***PRINT "waiting on the handler . . . ":
PRINT "Waiting on the Interface . . . " "L#30":
*IF NOT(TMP) THEN PRINT RVE: ELSE PRINT RVB:
IF NOT(TMP) THEN PRINT RVE:
***PRINT @(0,(23 - AI.DVC.NEXT.CN)):CLL:
END
*
HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
*PRINT @(0,(23 - SEND.COMM.CN - ((AI.DVC.NEXT.CN - 1) * 2) + 1)):CLL:
*@*PRINT @(46,23):(" [":COM.AIP$COMM.PORT<ONE,SEND.COMM.CN>:"]") "L#8":(" (":MAX.PAUSE - HANDLER.ELP:")") "L#10":RVE:@(ZERO,ONE):
*@*PRINT @(46,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):(" [":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:"]") "L#22":(" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":RVE:@(ZERO,ONE):
*
***PRINT @(((SEND.COMM.CN - 1) * 30) + 6,(23 - AI.DVC.NEXT.CN)):
TMP9 = CHECK.LN.MIN + ((AI.DVC.NEXT.CN - 1) * 2) + ((SEND.COMM.CN - 1))
PRINT @(CHECK.LEN + 1,TMP9):
IF TMP THEN PRINT RVB:
PRINT ("[":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:": ":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"]") "L#30":
* (" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":
IF TMP THEN PRINT RVE:
PRINT @(CHECK.LEN + 1,TMP9 + 1):
*@@@*PRINT (" (":MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#30":
* PRINT (" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#30":
PRINT (" (":MAX.PAUSE:"+":INTFC.PAUSE:"=":MAX.PAUSE+INTFC.PAUSE:"-":HANDLER.ELP:"=":MAX.PAUSE+INTFC.PAUSE-HANDLER.ELP:",":COM.AI.LOC:")") "L#30":
*
*
NEXT SEND.COMM.CN
*
*
END; * of ON.FILE
*
*#*END; * of LCK.COM.AIP
*
!
*
IF LCK.COM.AIP THEN
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
IF COM.AIP$RETRY LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY
*
IF COM.AI.LOC GT ONE AND AI.DVC.NEXT.FOUND THEN
WF.DT = DATE(); WF.TM = TIME()
COM.AIP$COMM.DT = WF.DT; COM.AIP$COMM.TM = WF.TM
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
*
**CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"D","",LCK.STAT)
LCK.COM.AIP = FALSE
*
END; * OF LOCKED
*
*
NEXT AI.DVC.NEXT.CN
***
**!
***
AI.DVC.NEXT.CN = ONE
SEND.COMM.CN = ONE
NUM.TRIES = NUM.TRIES + ONE
COM.AIP.ID = "AI*":AI.CODE:"*":PORT:"*":AI.DVC.NEXT.CN
*
REPEAT
*
* PRINT @(20,23):CLL:
LOCATE WF.C.FUNC IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
HANDLER.DONE = FALSE
IF COM.AI.ERR.DISP OR CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Not Done" "L#19":RVE:
END ELSE
HANDLER.DONE = TRUE
PORT.LOC = ONE
IF COM.AI.ERR.DISP OR CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Done" "L#19":RVE:
END
*
IF NOT(STAT) AND LCK.STAT GT 900 THEN STAT = LCK.STAT
IF STAT THEN
IF STAT GT AI.STATUS THEN AI.STATUS = STAT
TEXT<-ONE> = "Status ":STAT:" error in wait routine."
END
*
DT = DATE(); TM = TIME(); ELP = ZERO
*#*LOOP
LCK.STAT = LCK.TYPE
**CALL LCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"E","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*#*UNTIL NOT(LCK.STAT) OR ELP GT ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
IF COM.AIP$RETRY LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY
*
IF LCK.COM.AIP THEN
**CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"F","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
* IF NOT(AI.STATUS) THEN
IF COM.AIP$ERR<ONE,ONE,ONE> LT 299 THEN
IF NOT(COM.AIP$ERR<ONE,ONE,ONE> LT 100 OR COM.AIP$ERR<ONE,ONE,ONE> GE 600) THEN
IF COM.AIP$ERR<ONE,ONE,ONE> GT AI.STATUS THEN AI.STATUS = COM.AIP$ERR<ONE,ONE,ONE>
IF AI.STATUS = ERR$NOT.SENT THEN AI.STATUS = FALSE
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
END
END
* END
*
* IF NOT(SEND.STATUS) THEN
** IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> THEN
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> NE EMPTY THEN
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> LT 800 OR COM.AIP$INTFC.ERR<ONE,ONE,ONE> GT 899 THEN
SEND.STATUS = COM.AIP$INTFC.ERR<ONE,ONE,ONE>
IF SEND.STATUS = ERR$NOT.SENT THEN SEND.STATUS = FALSE
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
END
END
* END
*
IF LEN(TEXT) AND (SEND.STATUS OR AI.STATUS OR NOT(ERR.CLB)) THEN GOSUB ERROR
*
IF INDEX("UDS",AI.SRCE,ONE) THEN PORT.LIST.BUILD = 7
*
RETURN; * : *
*
~AI.INCL.DISP.COM.AIP.STAT~
*CODE.SEGMENT: AI.INCL.DISP.COM.AIP.STAT
* VERSION: 960513 1.2 SPLIT OFF FROM AI.INCL.WAITFOR.COMMAND
* PRIOR: 940130 1.1  COM.AI.ID CHANGED.
* USED BY: AI.TALKER
*          AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* INCL CREATED: MAY 96
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*   1990        ALL RIGHTS RESERVED
*
!
*
SYS.LOCT = "AI.INCL.DISP.COM.AIP.STAT"
*
*960513*DGH*IF DISP.ONLY THEN RETURN
*960513*DGH**
*960513*DGH****NUM.TRIES = ZERO; MAX.PAUSE = 120; STD.PAUSE = 5
*960513*DGH*NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = COM.AI$MAX.PAUSE; STD.PAUSE = COM.AI$STD.PAUSE
*960513*DGH****NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = 30; STD.PAUSE = ONE
*960513*DGH*IF NOT(MAX.PAUSE) THEN MAX.PAUSE = 30
*960513*DGH*IF NOT(STD.PAUSE) THEN STD.PAUSE = ONE
*960513*DGH*INTFC.PAUSE = ZERO
*960513*DGH*DT = DATE(); TM = TIME(); ELP = ZERO
*960513*DGH***ELP.MAX = COM.AI$MAX.PAUSE
*960513*DGH***IF ELP.MAX LT 60 THEN ELP.MAX = 60
*960513*DGH*ELP.MAX = 15
*960513*DGH*WF.DT = DT; WF.TM = TM
*960513*DGH** WF.C.LOC = HANDLER.COMMAND<ONE,ONE> (FUNC OR COMMAND) ( NOT USED )
*960513*DGH** STAT = 0;  WF.C.FUNC = PORT NUMBER
*960513*DGH*WF.C.FUNC = PORT.KEY
*960513*DGH*COM.AI.ON.FILE = FALSE; HANDLER.DONE = FALSE
*960513*DGH*COM.AI.ID = "AI.TYPE.":AI.CODE; COM.ID = COM.AI.ID
*
!
*
*DISP.COM.AIP.STAT: *
*
**SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
***
**FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
***
*** PRINT @(0,20):CLL:@(0,21):CLL:@(20,21):
**PRINT @(0,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):CLL:@(15,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):
**TMP = REM(NUM.TRIES,TWO)
**IF NOT(TMP) THEN PRINT RVB:
**PRINT "waiting on the handler . . . ":
**HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
**IF NOT(TMP) THEN PRINT RVE: ELSE PRINT RVB:
***@*PRINT @(46,23):(" [":COM.AIP$COMM.PORT<ONE,SEND.COMM.CN>:"]") "L#8":(" (":MAX.PAUSE - HANDLER.ELP:")") "L#10":RVE:@(ZERO,ONE):
**PRINT @(46,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):(" [":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:"]") "L#22":(" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":RVE:@(ZERO,ONE):
***
**NEXT SEND.COMM.CN
*
*
* TMP = REM(NUM.TRIES,3)
TMP = FALSE
IF NOT(TMP) THEN
IF FAST.DISPLAY OR COM.AI.ERR.DISP THEN
TEXT = EMPTY; OUTPUTS = EMPTY
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
LCK.ELP.MAX = 3
IF COM.AI$GENIE.WINDOW EQ "Y" AND AI.SRCE EQ "T" THEN PORTS.LIST.BUILD = 7
GOSUB INTFC.CHECK
GOSUB INTFC.MESSAGES
IF LEN(OUTPUTS) THEN TEXT = OUTPUTS:AM:TEXT
ERR.DISP.ONLY = TWO
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE
END
END
*
!
*
AI.DVC.NEXT.FOUND = TRUE; AI.DVC.DONE = TRUE
MAX.PAUSE = COM.AI$MAX.PAUSE
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND) OR HANDLER.DONE
***AI.DVC.NEXT.CN = ONE
*
*
*
DT = DATE(); TM = TIME(); ELP = ZERO
COM.AIP.ID = "AI*":AI.CODE:"*":PORT:"*":AI.DVC.NEXT.CN
*#*LOOP
LCK.STAT = LCK.TYPE
**CALL LCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"C","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
** HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
** IF HANDLER.ELP GT MAX.PAUSE + COM.AIP$MAX.PAUSE THEN
** TEXT<-ONE> = "Can't wait longer than ":MAX.PAUSE + COM.AIP$MAX.PAUSE:" seconds."
** AI.STATUS = 201
*****INS  "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
*****INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
** * COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
** END
*#*UNTIL NOT(LCK.STAT) OR ELP GT ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
*#*IF LCK.COM.AIP THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; AI.DVC.NEXT.FOUND = FALSE
*
*
*#*IF LCK.COM.AIP THEN
*
*
IF AI.DVC.NEXT.FOUND THEN
*
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
IF COM.AIP$MAX.PAUSE GT INTFC.PAUSE THEN INTFC.PAUSE = COM.AIP$MAX.PAUSE
IF AI.DVC.NEXT.CN GT ONE THEN
MAX.PAUSE = MAX.PAUSE + INT(COM.AI$MAX.PAUSE / TWO)
END
*
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
* PRINT @(0,20):CLL:@(0,21):CLL:@(20,21):
* - ((AI.DVC.NEXT.CN-1) * 2)
*PRINT @(0,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN - ((AI.DVC.NEXT.CN-1) * 2))):CLL:@(15,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN - ((AI.DVC.NEXT.CN-1) * 2))):
TMP = REM(NUM.TRIES,TWO)
*
IF SEND.COMM.CN GT ONE THEN
MAX.PAUSE = MAX.PAUSE + INT(COM.AI$MAX.PAUSE / TWO)
END
IF SEND.COMM.CN EQ ONE THEN
*PRINT @(0,(23 - 1 - ((AI.DVC.NEXT.CN - 1) * 2))):CLL:
***PRINT @(0,(23 - AI.DVC.NEXT.CN - 1)):CLL:SPACE(6):
PRINT @(CHECK.LEN + 1,CHECK.LN.MIN - 1):
IF NOT(TMP) THEN PRINT RVB:
***PRINT "waiting on the handler . . . ":
PRINT "Waiting on the Interface . . . " "L#30":
*IF NOT(TMP) THEN PRINT RVE: ELSE PRINT RVB:
IF NOT(TMP) THEN PRINT RVE:
***PRINT @(0,(23 - AI.DVC.NEXT.CN)):CLL:
END
*
HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
*PRINT @(0,(23 - SEND.COMM.CN - ((AI.DVC.NEXT.CN - 1) * 2) + 1)):CLL:
*@*PRINT @(46,23):(" [":COM.AIP$COMM.PORT<ONE,SEND.COMM.CN>:"]") "L#8":(" (":MAX.PAUSE - HANDLER.ELP:")") "L#10":RVE:@(ZERO,ONE):
*@*PRINT @(46,(23 - SEND.COMM.CN.MAX + SEND.COMM.CN)):(" [":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:"]") "L#22":(" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":RVE:@(ZERO,ONE):
*
***PRINT @(((SEND.COMM.CN - 1) * 30) + 6,(23 - AI.DVC.NEXT.CN)):
TMP9 = CHECK.LN.MIN + ((AI.DVC.NEXT.CN - 1) * 2) + ((SEND.COMM.CN - 1))
PRINT @(CHECK.LEN,TMP9):
IF TMP THEN PRINT RVB:
PRINT ("[":FIELD(COM.AIP.ID,"*",4):"-":COM.AIP$DVC.ID:" +":SEND.COMM.CN:" ":COM.AIP$COMM<ONE,SEND.COMM.CN>:": ":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"]") "L#30":
* (" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":
IF TMP THEN PRINT RVE:
PRINT @(CHECK.LEN,TMP9 + 1):
*@@@*PRINT (" (":MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#30":
* PRINT (" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#30":
PRINT (" (":MAX.PAUSE:"+":INTFC.PAUSE:"=":MAX.PAUSE+INTFC.PAUSE:"-":HANDLER.ELP:"=":MAX.PAUSE+INTFC.PAUSE-HANDLER.ELP:",":COM.AI.LOC:")") "L#30":
*
*
NEXT SEND.COMM.CN
*
*
END; * of ON.FILE
*
*#*END; * of LCK.COM.AIP
*
!
*
IF LCK.COM.AIP THEN
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
IF COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE>
*
IF COM.AI.LOC GT ONE AND AI.DVC.NEXT.FOUND THEN
WF.DT = DATE(); WF.TM = TIME()
COM.AIP$COMM.DT = WF.DT; COM.AIP$COMM.TM = WF.TM
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
*
**CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"D","",LCK.STAT)
LCK.COM.AIP = FALSE
*
END; * OF LOCKED
*
*
NEXT AI.DVC.NEXT.CN
***
**!
***
*960513*DGH**
*960513*DGH*RETURN; * : *
*
~AI.INCL.GET.CODE~
*CODE.SEGMENT: AI.INCL.GET.CODE
* VERSION: 940117 1.1  CHANGED 'Comm Port' to 'AI Code' to FUNC.
* USED BY: AI.CONTROL.UTILITY
*
* DAVID HORSMAN (C) 1992 (SPLIT OFF JUNE 1996)
*
*: * Init SUBject INPut loop
*
DT = DATE(); TM = TIME()
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
LCK.COM.AI = FALSE; COM.AI.ON.FILE = FALSE; LCK.STAT = FALSE
LCK.COM.AIP = FALSE; COM.AIP.ON.FILE = FALSE
*
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
AI.TYPES.CTR = (COUNT(AI.TYPES,VM))
*
LOOP
*
IF NOT(AI.TYPES.CTR) THEN
AI.CODE = AI.TYPES<1>
TMP.LOC = 1
END ELSE
*
LOOP
PRINT @(10,11):BELL:"Enter the Code of the Interface to ":FUNC:": ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP
LOCATE AI.CODE IN AI.TYPES<1> SETTING TMP.LOC ELSE AI.CODE = ""
UNTIL AI.CODE NE "" DO PRINT BELL REPEAT
*
END
*
* LOOP
* IF NOT(LCK.STAT) THEN
* PRINT CLB:"Enter the AI Code to ":FUNC:": ":
* INPUT COMMPORT:
* END
* IF NUM(COMMPORT) THEN
* LOOP WHILE LEN(COMMPORT) LT 3 DO COMMPORT = "0":COMMPORT REPEAT
* END
* *
*: * Init READ subject
LCK.ITM = FALSE; LCK.RELS = TRUE; LCK.STAT = LCK.TYPE; WRITE.FLAG = FALSE
*
LCK.ITM = TRUE; LCK.RELS = TRUE; GOSUB READ.COM.AI; * : *
*
TMP.DESC = AI.TYPES<2,TMP.LOC>
TMP.MODEL = AI.TYPES<3,TMP.LOC>
HEADENDS = AI.TYPES<4,TMP.LOC>
HEADEND  = HEADENDS<ONE,ONE,ONE>
IF COM.AI$MONITOR.PORT = "" THEN TMP.PORT = "<NONE>" ELSE TMP.PORT = COM.AI$MONITOR.PORT
*
PRINT @(27,12):" AI Description:  ":TMP.DESC:
PRINT @(27,13):"    Equipment:    ":TMP.MODEL:
PRINT @(27,14):"    Handler Port: ":COM.AI$COMMPORT:
PRINT @(27,15):"    Monitor Port: ":TMP.PORT:
EXECUTE "SLEEP 3"
*
WHILE LCK.STAT OR NOT(COM.AI.ON.FILE) DO
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF ELP GT 90 THEN STOP
REPEAT
*
~AI.INCL.INP.RSP~
*CODE.SEGMENT: AI.INCL.INP.RSP
*
*CODE.SEGMENT: AI.RESP.INPUT(PAUSE.CHAR,PAUSE.RESP,PAUSE.TOUT,PAUSE.LINE,INPUT.PACKET,TC.LAST.FL,TC.LAST,OPER,EXP.TM,SYS.PRNT,STAT)
*SUBROUTINE: AI.RESP.INPUT
* VERSION 940828 1.0
* USED BY AI.COMMAND.SENDER
*
* AUTHOR:    DAVID G. HORSMAN
* COMPANY:   WRITTEN FOR AXION COMPUTER SYSTEMS LTD.
*
* DATE RELEASED: ?? DEC 94
***
**!
***
**$INCLUDE IBP STANDARD.FUNCTIONS.DVC
***
**EQU VERSION TO "(1.0)"
**VS = "(1.0)"
**SYS.APPL.SUB = "AI"; SYS.PROG = "AI.RESP.INPUT"; SYS.LOCT = EMPTY
SYS.LOCT = "AI.INCL.INP.RSP"
*
**!
*
* $INCLUDE IBP COM.AIP.DIM
* $INCLUDE IBP COM.AI.DIM
* PAUSE.CHAR   (INCR'S)
* PAUSE.LINE   (INCR'S)
* PAUSE.RESP   (SEC.S)
**!
* $INCLUDE IBP COM.AIP.EQUATES
* $INCLUDE IBP COM.AI.EQUATES
*
* $INCLUDE IBP AI.ERR.VAR.EQUATES
*
* $INCLUDE IBP AI.STATUS.VAR.EQUATES
*
* $INCLUDE IBP CNT.TST.DIM
* $INCLUDE IBP CNT.TST.EQUATES
*
*
* IF CNT.TST$LBL THEN PRINT @(ZERO,23):RVB:" * Subroutine AI.RESP.INPUT * ":RVE
*
**!
*
* DT = DATE(); TM = TIME()
* PAUSE.CN.MAX = COM.AI$PAUSE.CHAR
PAUSE.CN.MAX = PAUSE.CHAR
* TC.LAST.FL = FALSE; TC.LAST = EMPTY
* SEND.STATUS = FALSE; SEND.CN = ZERO
COM.AI.MIN.PKT = 6
* PAUSE.RESP.MAX = COM.AI$PAUSE.RESP
PAUSE.RESP.MAX = PAUSE.RESP
COM.AI.MAX.BUF = 10
*
*
* RECEIVE RESPONSE FROM COM.AI$DB.PREFIX DEVICE
*
* IF CNT.TST$LBL THEN PRINT CLL:RVB:"Receiving Response From Headend . . . ":RVE
* ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY; TC.CHAR = EMPTY
*
*
* Process any characters that are available
*
* LOOP
*
* IF CNT.TST$LBL THEN PRINT CLL:RVB:"Wait for characters in buffer":RVE
*
* WAIT FOR CHARACTERS IN THE BUFFER
** ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY; TC.CHAR = EMPTY
PAUSE.CN1 = 0
* PAUSE.CN.MAX1 = COM.AI$PAUSE.LINE
PAUSE.CN.MAX1 = PAUSE.LINE
IF PAUSE.CN.MAX1 LT 100 THEN PAUSE.CN.MAX1 = 100
TC.CONT = TRUE; TC.CONT1 = FALSE
STM = TIME(); QSTM = STM; ETM = ZERO; QTM = ZERO
WSTM = STM; WTM = ZERO
ECHO OFF
IF TC.LAST.FL THEN
PRINT TC.LAST:; TC.LAST.FL = FALSE
END
*
*
LOOP
*
TC.END.SYS11 = SYSTEM(11)
*
IF TC.END.SYS11 THEN
*
* Input characters that are waiting
*
TC.CHAR = EMPTY
LOOP
* ULT ONLY
FOR A = ONE TO TC.END.SYS11 UNTIL TC.CHAR EQ CR
* REV ONLY
* FOR A = ONE TO 200 UNTIL TC.CHAR EQ EMPTY OR TC.CHAR EQ CR
TC.CHAR = EMPTY
* ULT ONLY
TC.CHAR = OCONV(TC.CHAR,"U51EA")
* REV ONLY
* INPUT TC.ONE:
* * REV ONLY
* * INPUT TC,ONE:-
IF TC.CHAR NE CR THEN
INPUT.PACKET = INPUT.PACKET:TC.CHAR
END
NEXT A
TC.END.SYS11 = SYSTEM(11)
* ULT ONLY
UNTIL NOT(TC.END.SYS11) OR TC.CHAR EQ CR DO REPEAT
* REV ONLY
* UNTIL TC.CHAR EQ EMPTY OR TC.CHAR EQ CR DO REPEAT
*
*
*
QSTM = ZERO; QTM = ZERO; ETM = ZERO
*
*
END ELSE
*
* No character waiting
*
*
CTM = TIME()
IF NOT(QSTM) THEN QSTM = CTM
ETM = ABS(CTM - STM)
QTM = ABS(CTM - QSTM)
WTM = ABS(CTM - WSTM)
*
*
END; * of SYS11
*
*
*
*
WHILE TC.END.SYS11 OR (INPUT.PACKET EQ EMPTY AND ETM LE PAUSE.RESP.MAX) OR (INPUT.PACKET NE EMPTY AND QTM LE PAUSE.RESP.MAX / 4) DO
*
PAUSE.CN1 = PAUSE.CN1 + ONE
* IF CNT.TST$LBL THEN PRINT CLL:RVB:"Process more buffered response/characters":RVE
*
REPEAT
*
ECHO ON
* TC.CONT means packet CR has been received
****
***RETURN
****
***END
~AI.INCL.INTFC.CHECK~
*CODE.SEGMENT: AI.INCL.INTFC.CHECK
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
SYS.LOCT = "AI.INCL.INTFC.CHECK"
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* * COM.AI.ERR.TEXT<-ONE> = "The AI Handler is ok."
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
DT = DATE(); TM = TIME(); LCK.ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF CHECK.ELP.MAX LT 60 THEN CHECK.ELP.MAX = 60
*@@@@*CHECK.ELP.MAX = 15
IF ERR.DISP.ONLY THEN STATUS.CYCLE = ERR.DISP.ONLY
*
!
*
AI.COM.AI.CHECK: *
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
*   8640 86200     8641 01000  CURR DT/TM
*   8640 86000     8640 86200  FUNC DT/TM
*   ---- -----     ---- -----
*      0   200        1 85200-
*                 86400
*                 85200-
*                  1200
*
AI.CHK.ERR = EMPTY; COM.AI.ON = FALSE; COM.AI.UP = FALSE
* LCK.COM.AIP = FALSE; LCK.COM.AI = FALSE
COM.ID = EMPTY
*
BEGIN CASE
*
CASE COM.AI$ON.OFF.STAT EQ AI.ON
COM.AI.ON = TRUE
!
*
*960119*DGH*IF COM.AI$MAX.PAUSE + 4 * COM.AI$STD.PAUSE LE COM.AI.RUN.ELP THEN
IF (3 * COM.AI$MAX.PAUSE) LE COM.AI.RUN.ELP THEN
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, AI hung for ":OCONV(COM.AI.RUN.ELP,"MTS"):" hours!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT EQ AI.UP THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* *COM.AI.ON = FALSE
* END
COM.AI.UP = FALSE
END ELSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.UP = TRUE
AI.CHK.ERR<-ONE> = ZERO
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and UP."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 3
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 191
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END CASE
*
END
*
!
*
CASE COM.AI$ON.OFF.STAT EQ AI.OFF
COM.AI.ON = FALSE
COM.AI.UP = FALSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
AI.CHK.ERR<-ONE> = 102
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and UP!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
AI.CHK.ERR<-ONE> = TWO
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
AI.CHK.ERR<-ONE> = 192
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
*
CASE TRUE
AI.CHK.ERR<-ONE> = 181
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither ON nor OFF!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$ON.OFF.STAT NE AI.OFF THEN COM.AI.ERR.FUNC<-ONE> = AI.OFF ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
BEGIN CASE
*
*960119*DGH*CASE COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
CASE (3 * COM.AI$MAX.PAUSE) LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, No (":COM.AI.RUN.ELP:") Acknowledgment!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
!
*
CASE COM.AI$ON.OFF.STAT NE COM.AI$ON.OFF
COM.AI.ON.OFF.ELP = ((DT - COM.AI$ON.OFF.DT) * 86400) + (TM - COM.AI$ON.OFF.TM)
IF COM.AI.ON.OFF.ELP GT COM.AI$MAX.PAUSE + 3 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 111
* COM.AI.ERR.TEXT<-ONE> = "Failure logging ":COM.AI$ON.OFF:"! (":COM.AI.ON.OFF.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* COM.AI.ERR.FUNC<-ONE> = COM.AI$ON.OFF
END ELSE
AI.CHK.ERR<-ONE> = 11
* COM.AI.ERR.TEXT<-ONE> = "The AI is logging ":COM.AI$ON.OFF:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$UP.DN.STAT NE COM.AI$UP.DN
COM.AI.UP.DN.ELP = ((DT - COM.AI$UP.DN.DT) * 86400) + (TM - COM.AI$UP.DN.TM)
IF COM.AI.UP.DN.ELP GT COM.AI$MAX.PAUSE + 2 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 121
* COM.AI.ERR.TEXT<-ONE> = "Failure going ":COM.AI$UP.DN:"! (":COM.AI.UP.DN.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* * COM.AI.ERR.FUNC<-ONE> = COM.AI$UP.DN
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END ELSE
AI.CHK.ERR<-ONE> = 12
* COM.AI.ERR.TEXT<-ONE> = "The AI is going ":COM.AI$UP.DN:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
READV OFF.FLAG FROM COM.FILE,"AI.OFF.":PORT.KEY,ONE ELSE
READV OFF.FLAG FROM COM.FILE,"AI.OFF.ALL",ONE ELSE OFF.FLAG = FALSE
END
*
IF OFF.FLAG THEN
WRITE FALSE:AM:"Done ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS") ON COM.FILE,"AI.OFF.":PORT.KEY
AI.CHK.ERR<-ONE> = 131
* COM.AI.ERR.TEXT<-ONE> = "Interface Off Flag is set!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
IF AI.CHK.ERR<TMP.CN> GT AI.STATUS THEN AI.STATUS = AI.CHK.ERR<TMP.CN>
** COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
** LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
** COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
** COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
** TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
** IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE
** COM.AI.ERR.FUNC<-ONE> = TMP
** END
** DEL AI.CHK.ERR<ONE>
REPEAT
*
END; * of AI.CHK.ERR ne empty
*
!
*
*
*  IF NOT(LEN(COM.AI.ERR)) THEN
*
CHECK.FMT = "L#":CHECK.LEN - TWO
*
*
EXEC.IN = EMPTY; EXEC.OUT = EMPTY; EXEC.VERB = EMPTY
CHECK.DVC.NEXT.FOUND = FALSE; COM.ID = "###"
*
IF (FAST.DISPLAY EQ TWO OR PORTS.LIST.BUILD EQ 9) AND AI.SCAN THEN
*
PORTS.LIST = EMPTY
EXEC.VERB = 'SSELECT COM EQ "AI*]" BY COMM.DT BY COMM.TM'
*
IF COM.AI.ERR.DISP THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"!":"Selecting Active Ports" CHECK.FMT:"!":RVE
END
*
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > COM.ID.LIST, //OUT. > EXEC.OUT
*
* REV ONLY
* PERFORM EXEC.VERB
*
END ELSE IF PORTS.LIST.BUILD EQ 8 THEN
*
COM.ID.LIST = PORT.KEY
CHECK.DVC.NEXT.FOUND = TRUE; CHECK.DVC.NEXT.CN = ZERO
*
END ELSE
*
COM.ID.LIST = COM.AI$FUNC.PORT
CHECK.DVC.NEXT.FOUND = TRUE; CHECK.DVC.NEXT.CN = ZERO
IF COM.ID.LIST EQ EMPTY THEN COM.ID.LIST = PORTS.LIST
IF COM.ID.LIST EQ EMPTY THEN COM.ID.LIST = PORT.KEY
*
END; * of ports list build
*
IF COM.AI.ERR.DISP THEN
*
CHECK.LN = CHECK.LN.MIN
*
IF (PORTS.LIST.BUILD) AND AI.SCAN THEN
PRINT RVB:"!":RVE:STR("-",CHECK.LEN - TWO) CHECK.FMT:RVB:"!":RVE; CHECK.LN = CHECK.LN + ONE
PRINT RVB:"!":RVE:EXEC.VERB CHECK.FMT:RVB:"!":RVE; CHECK.LN = CHECK.LN + ONE
IF LEN(EXEC.OUT) THEN
IF NOT(FAST.DISPLAY) THEN
LOOP WHILE LEN(EXEC.OUT) DO
PRINT RVB:"!":RVE:EXEC.OUT<ONE> CHECK.FMT:RVB:"!":RVE; CHECK.LN = CHECK.LN + ONE
DEL EXEC.OUT<ONE>
REPEAT
PRINT RVB:"!":RVE:" " CHECK.FMT:RVB:"!":RVE; CHECK.LN = CHECK.LN + ONE
PRINT RVB:"!":RVE:" " CHECK.FMT:RVB:"!":RVE; CHECK.LN = CHECK.LN + ONE
END ELSE EXEC.OUT = EMPTY
END
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END; * of ports list build
*
IF NOT(FAST.DISPLAY) THEN
IF CHECK.LN.HI GT CHECK.LN THEN
IF CHECK.LN.HI GT CHECK.LN.MAX THEN CHECK.LN.HI = CHECK.LN.MAX
FOR TMP = CHECK.LN TO CHECK.LN.HI + 1 UNTIL CHECK.LN GT CHECK.LN.MAX
PRINT @(ZERO,TMP):RVB:"!":RVE:" " CHECK.FMT:RVB:"!":RVE
NEXT TMP
END
END
*
CHECK.LN.HI = CHECK.LN; CHECK.LN = CHECK.LN.MIN
*
* EXECUTE "SLEEP 1"
*
END; * OF COM.AI.ERR.DISP
*
*
COM.AI.PORT.REC = EMPTY
COM.AIP.PORT.FIRST = TRUE; PORT.CONT = TRUE
* PORTS.LIST = EMPTY
CHECK.DVC.NEXT.FOUND = FALSE; COM.ID = "###"
*
LOOP
*
IF (FAST.DISPLAY EQ TWO OR PORTS.LIST.BUILD) AND AI.SCAN THEN
*
COM.ID = EMPTY
* ULT ONLY
READNEXT COM.ID FROM COM.ID.LIST ELSE COM.ID = "@@@"
*
* REV ONLY
* READNEXT COM.ID ELSE COM.ID = "@@@"
*
* COM.AIP.ID = COM.ID
COM.AIP.PORT = FIELD(COM.ID,"*",3)
*
*
END ELSE
*
IF NOT(COM.AIP.PORT.FIRST) AND COM.ID.LIST EQ EMPTY AND COM.ID EQ "###" THEN COM.ID = "@@@" ELSE
IF COM.ID NE "###" THEN
CHECK.DVC.NEXT.CN = CHECK.DVC.NEXT.CN + ONE
END ELSE
* COM.AIP.ID = COM.ID
COM.AIP.PORT = COM.ID.LIST<ONE,ONE>
DEL COM.ID.LIST<ONE,ONE>
CHECK.DVC.NEXT.CN = ONE
CHECK.DVC.NEXT.FOUND = TRUE
END
COM.ID = "AI*":AI.CODE:"*":COM.AIP.PORT:"*":CHECK.DVC.NEXT.CN
* COM.AIP.ID = COM.ID
*LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
*PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
*IF COM.AI.ERR.DISP THEN PRINT BELL:
*END
END
*
END; * of ports list build
*
!
*
AI.COM.AIP.CHECK: *
*
IF COM.AIP.PORT NE EMPTY THEN
LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
* IF COM.AI.ERR.DISP THEN PRINT BELL:
END
END
*
IF COM.AIP.PORT.FIRST THEN
CHECK.LN = CHECK.LN.MAX
COM.AIP.PORT.FIRST = FALSE
END
*
!
**
*WHILE COM.ID NE "@@@" DO
**
IF COM.ID NE "@@@" THEN
*
** ** ** IF COM.ID MATCHES '"AI*"3N"*"3N' THEN
IF FIELD(COM.ID,"*",ONE) EQ "AI" AND FIELD(COM.ID,"*",TWO) EQ AI.CODE AND NUM(FIELD(COM.ID,"*",3)) THEN
*
IF AI.SCAN THEN
*
DT = DATE(); TM = TIME(); LCK.ELP = ZERO
IF CNT.TST$ID THEN PRINT @(50,20):("Lock Aip ":COM.ID) "L#28":
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
LCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
UNTIL NOT(LCK.STAT) OR LCK.ELP GT CHECK.ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
* LCK.COM.AIP = TRUE
* END ELSE LCK.COM.AIP = FALSE
END
* END ELSE LCK.COM.AIP = FALSE
END
END; * of not @@@
*
*
IF COM.ID NE "@@@" THEN
IF CNT.TST$ID THEN PRINT @(50,20):("Read Aip ":COM.ID) "L#28":
MATREAD COM.AIP FROM COM.FILE,COM.ID THEN
*
COM.AIP.ON.FILE = TRUE
CHECK.DVC.NEXT.FOUND = TRUE
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
* READ COM.AI.COMMANDS FROM COM.FILE,"AI.COMMANDS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE COM.AI.COMMANDS = EMPTY
*
IF CNT.TST$ID THEN PRINT @(50,20):("Anal Aip ":COM.ID) "L#28":
*
*@@@ LOOP FOR MULTI COMMANDS
*
LP0.FLG = ""; LP1.FLG = ""; SEND.COMM.CN.TMP.MAX = DCOUNT(COM.AIP$COMM<ONE>,VM)
*
*@@*FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL CHECK.LN GE CHECK.LN.MAX OR SYSTEM(11) GE 3
FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL SYSTEM(11) GE 3
*
*
IF CNT.TST$ID THEN PRINT @(50,20):("Loop Aip ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*@@@ BUILD PORT RECORD
*
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
LP0.FLG = FALSE
IF (PORTS.LIST.BUILD OR FIELD(COM.ID,"*",3) EQ PORT) AND COM.AI.ERR.DISP THEN LP0.FLG = TRUE
IF (FAST.DISPLAY OR PORTS.LIST.BUILD OR COM.AI.ERR.DISP) AND AI.SCAN THEN
LP0.FLG = TRUE
END
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE)) THEN LP0.FLG = TRUE
IF ((COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND COM.AIP.ELP LT 300) THEN LP0.FLG = TRUE
*
!
*
IF CNT.TST$ID THEN PRINT @(50,20):("Chck 1 Aip (":LP0.FLG:") ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*
IF LP0.FLG THEN
**IF CNT.TST$ID THEN PRINT @(50,20):("Disp Aip ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*
IF PORT.CONT THEN
*
IF COM.AI.ERR.DISP THEN
*
IF COM.AIP.PORT.FIRST OR CHECK.LN GE CHECK.LN.MAX THEN
COM.AIP.PORT.FIRST = FALSE
IF SYSTEM(11) LT 3 THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"!":"Opr Po n Dvc/Ev Comm. Stat AIt Dvc. Fnc .Elp." CHECK.FMT:"!":RVE:
END
END
*
!
*
IF CHECK.LN GE CHECK.LN.MAX THEN
*
IF SYSTEM(11) LT 3 THEN
*
CHECK.LN = CHECK.LN.MIN
IF STATUS.CYCLE THEN
*
EXECUTE "SLEEP 3"
RSP = "Y"
END ELSE
LOOP
PRINT @(ZERO,23):CLL:"!Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(ZERO,23):RVB:"!":RVE:" " CHECK.FMT:RVB:"!":RVE:
IF RSP EQ EMPTY THEN PORT.CONT = FALSE ELSE ALREADY.DISPLAYED = TRUE
*
END; * of STATUS CYCLE
END; * of SYS11
END; * of CHECK.LN GE CHECK.LN.MAX
*
END; * OF COM.AI.ERR.DISP
*
!
*
IF PORT.CONT THEN
*
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE MAT COM.AIIERR = EMPTY
END
*
*
**TMP1 = ""; VC.CN.MAX = DCOUNT(COM.AIP$COMM<ONE>,VM)
***
**FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL CHECK.LN GE CHECK.LN.MAX OR SYSTEM(11) GE 3
TMP1 = ""
*
*
IF COM.AI.ERR.DISP THEN
IF SYSTEM(11) LT 3 THEN
TMP1 = OCONV(COM.AIP.ELP,"MTS")
TMP = COM.AIP$OPER "L#3":" ":FIELD(COM.ID,"*",3) "R#2":" ":FIELD(COM.ID,"*",4)
TMP2 = COM.AIP$COMM<ONE,SEND.COMM.CN.TMP,ONE> 
IF TMP2 EQ "DLE" THEN
TMP = TMP:" ":COM.AIP$EVENT<ONE,ONE,ONE> "L#6"
END ELSE IF TMP2 EQ "UPL" THEN
TMP = TMP:" ":COM.AIP$EVENT<ONE,ONE,ONE> "L#6"
END ELSE
TMP = TMP:" ":COM.AIP$DVC.ID "L#6"
END
TMP = TMP:" ":TMP2 "L#5":" ":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> "L#4"
TMP = TMP:" ":COM.AIP$INTFC.CODE "L#2":COM.AIP$INTFC.TYPE "L#1"
TMP = TMP:" ":COM.AIP$DVC.TYPE "L#4":" ":COM.AIP$SVC.FUNC "L#3":" ":TMP1 "R#5"
PRINT @(ZERO,CHECK.LN):RVB:"!":RVE:TMP CHECK.FMT:RVB:"!":RVE:
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
END
*
!
*
IF COM.AIP$INTFC.ERR<ONE> NE EMPTY THEN
***
**IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
**INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
**MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE MAT COM.AIIERR = EMPTY
**END
***
***
**TMP1 = ""; SEND.COMM.CN.TMP.MAX = DCOUNT(COM.AIP$INTFC.ERR<ONE>,VM)
***
**FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX UNTIL CHECK.LN GE CHECK.LN.MAX OR SYSTEM(11) GE 3
*
SVC.CN = ZERO
SVC.CN.MAX = DCOUNT(COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN.TMP>,SVM)
*
LOOP
*
SVC.CN = SVC.CN + ONE
IF CNT.TST$ID THEN PRINT @(50,20):("Loop Aip ":COM.ID:"+":SEND.COMM.CN.TMP:"+":SVC.CN) "L#28":
TMP1 = COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN.TMP,SVC.CN>
* TMP1 = COM.AIP$ERR<ONE,SEND.COMM.CN.TMP,ONE>
*
*@*WHILE TMP1 NE EMPTY AND CHECK.LN LT CHECK.LN.MAX DO
***WHILE TMP1 AND NOT(SYSTEM(11) GE 3) DO
*960517*DGH*WHILE TMP1 NE EMPTY AND NOT(SYSTEM(11) GE 3) DO
**WHILE TMP1 NE EMPTY AND NOT(SYSTEM(11) GE 3) AND CHECK.LN LE CHECK.LN.MAX DO
*
WHILE SVC.CN LE SVC.CN.MAX AND NOT(SYSTEM(11) GE 3) DO
*
IF SVC.CN EQ ONE THEN
IF COM.AIP.PORT EQ PORT THEN
IF INDEX("*COMP*DONE*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,SVC.CN>:"*",ONE) THEN
IF TMP1 GT SEND.STATUS THEN SEND.STATUS = TMP1
END
END
END
*
*
LOCATE TMP1 IN COM.AIIERR$STD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
*
*TMP = ("[":TMP1:"]") "R#5":" ":COM.AIIERR$DESC<ONE,ERR.LOC> "L#17":" (":COM.AIIERR$TYPE<ONE,ERR.LOC>:")"
TMP = "[":COM.AIIERR$TYPE<ONE,ERR.LOC>:" ":TMP1:"]":" ":COM.AIIERR$DESC<ONE,ERR.LOC>
* TMP = ("[":TMP1:"]") "R#5":" ":COM.AIP$COMM<ONE,SEND.COMM.CN.TMP> "L#5":" ":COM.AIIERR$DESC<ONE,ERR.LOC> "L#17":" (":COM.AIIERR$TYPE<ONE,ERR.LOC>:")"
*
* COM.AI.ERR<-ONE> = COM.AIIERR$STD<ONE,ERR.LOC>
COM.AI.ERR<-ONE> = TMP1
COM.AI.ERR.TEXT<-ONE> = "p":FIELD(COM.ID,"*",3):" c":COM.AIP$COMM<ONE,SEND.COMM.CN.TMP>:" ":COM.AIIERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIIERR$TYPE<ONE,ERR.LOC>
TMP4 = COM.AIIERR$FUNC<ONE,ERR.LOC>
IF TMP4 EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP4 EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP4
END
* DEL AI.CHK.ERR<ONE>
*
IF COM.AI.ERR.DISP THEN
IF SVC.CN LT 20 THEN
IF SYSTEM(11) LT 3 THEN
PRINT @(ZERO,CHECK.LN):RVB:"!":RVE:TMP CHECK.FMT:RVB:"!":RVE:
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
IF CHECK.LN GT CHECK.LN.MAX THEN CHECK.LN = CHECK.LN.MIN
END
END
END
*
** for locate END ELSE NULL
*
REPEAT
*
**NEXT SEND.COMM.CN.TMP
*
END; * OF ERR NOT EMPTY
*
**NEXT SEND.COMM.CN.TMP
***
*
END; * OF PORT.CONT
*
END; * OF PORT.CONT AND ERR.DISP
*
!
*
LP1.FLG = FALSE
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*XCEL*RVRS*DONE*WAIT*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE)) THEN LP1.FLG = ONE
IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND INDEX("*RVRS*DONE*WAIT*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE) THEN LP1.FLG = TWO
**IF INDEX("*RVRS*DONE*WAIT*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE) THEN LP1.FLG = 3
**IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE)) THEN
**IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> NE EMPTY AND INDEX("*COMP*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE) THEN
IF SYSTEM(11) LT 3 AND COM.AIP.PORT NE PORT THEN LP1.FLAG = FALSE
*
IF LP1.FLG THEN
*
IF CNT.TST$ID THEN PRINT @(50,20):("Chck 1 Aip (":LP1.FLG:") ":COM.ID:"+":SEND.COMM.CN.TMP) "L#28":
*
DT = DATE(); TM = TIME()
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + ABS(TM - COM.AIP$COMM.TM)
*
*960118*DGH*IF COM.AIP.ELP GT 5 * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
TMP9 = COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE
IF NUM(COM.AIP$MAX.PAUSE) THEN
TMP9 = TMP9 + COM.AIP$MAX.PAUSE
END
*960119*DGH*IF COM.AIP.ELP GT (COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE + TMP9) THEN
IF COM.AIP.ELP GT ((TWO * COM.AI$MAX.PAUSE) + TMP9) THEN
*
IF AI.SCAN THEN
*
CALL SYS.ITM.LCK("ACT",COM.AIP$ACCT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
*
IF NOT(LCK.STAT) THEN
*
* AI.CHK.ERR<-ONE> = 371
* COM.AI.ERR<-ONE> = 371
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "DONE"
FOR TMP = ONE TO SEND.COMM.CN.TMP.MAX 
IF COM.AIP$INTFC.STAT<ONE,TMP,ONE> EQ "DONE" THEN
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
END
NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "WAIT"
FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
COM.AIP$COMM.PORT<ONE,TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "RVRS"
* FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
* INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
*INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
* COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
* COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"
* NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "COMP"
* FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
* Should never happen
* INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
* INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
* COM.AIP$COMM.PORT<ONE,TMP> = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.PORT<ONE,TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
* NEXT TMP
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "XCEL"
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE TRUE
FOR TMP = SEND.COMM.CN.TMP TO SEND.COMM.CN.TMP.MAX 
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,TMP,ONE>
COM.AIP$COMM.PORT<ONE,TMP> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
NEXT TMP
*
END CASE
*
IF COM.AIP.PORT EQ PORT THEN
TMP0 = 201
TMP1 = 801
SEND.STATUS = 201
END ELSE
TMP0 = 371
TMP1 = ERR$HANDLER.ERR
END
*
IF LEN(AI.CHK.ERR) THEN
AI.CHK.ERR = TMP0:AM:AI.CHK.ERR
END ELSE AI.CHK.ERR = TMP0
*
* COM.AI.ERR.TEXT<-ONE> = "Failure at (@COM.AIP.ELP@) Port @COM.AIP.PORT@ @COM.AIP$INTFC.STAT@!"
*
* COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP,ONE> = EMPTY
* COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
**COM.AIP$ERR = TMP1:SVM:COM.AIP$ERR
**COM.AIP$INTFC.ERR = TMP0:SVM:COM.AIP$INTFC.ERR
INS TMP0 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN.TMP,ONE>
INS TMP1 BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN.TMP,ONE>
*
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.ID,AI.CODE,AI.SRCE,11001,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PROG,STAT)
*
IF LCK.COM.AIP THEN
MATWRITE COM.AIP ON COM.FILE,COM.ID
END
*
CALL SYS.ITM.RLS("ACT",COM.AIP$ACCT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"C","",LCK.STAT)
*
END; * OF LCK.STAT
*
END ; * OF AI.SCAN
*
END; * OF ELP
*
END ELSE IF COM.AIP.ELP GT 7200 AND (COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "COMP" OR COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE> EQ "XCEL") THEN
*
IF LCK.COM.AIP AND AI.SCAN THEN
IF CNT.TST$ID THEN PRINT @(50,20):("Delete Aip ":COM.ID) "L#28":
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.ID,AI.CODE,AI.SRCE,11002,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PROG,STAT)
MATWRITE COM.AIP ON AIL.FILE,COM.ID
DELETE COM.FILE,COM.ID
END
*
END; * OF NO C.DT OR C.TM
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST<ONE> SETTING TMP ELSE
PORTS.LIST<ONE,-ONE> = COM.AIP.PORT
END
*
END; * OF NO C.DT OR C.TM
*
*
NEXT SEND.COMM.CN.TMP
*
!
*
*
END ELSE
CHECK.DVC.NEXT.FOUND = FALSE; * COM.ID = "###"
* NOT ON FILE
COM.AIP.ON.FILE = FALSE
MAT COM.AIP = EMPTY
IF CNT.TST$ID THEN PRINT @(50,20):("Missing Aip ":COM.ID) "L#28":
END
END; * of not @@@
*
** ** ** IF AI.SCAN AND NOT(LCK.STAT) THEN
* * * IF AI.SCAN AND NOT(LCK.COM.AIP) THEN
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"D","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
IF NOT(CHECK.DVC.NEXT.FOUND) AND COM.ID NE "@@@" THEN COM.ID = "###"
*
** ** ** END; * OF MATCHES AI*XX*999
*
*REPEAT
WHILE COM.ID NE "@@@" AND SYSTEM(11) LT 3 DO REPEAT
*
!
*
IF COM.AI.ERR.DISP THEN
IF CHECK.LN.HI GT CHECK.LN THEN
IF SYSTEM(11) LT 3 THEN
IF NOT(FAST.DISPLAY) THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):RVB:"!":RVE:" " CHECK.FMT:RVB:"!":RVE:
NEXT TMP
CHECK.LN.HI = CHECK.LN
IF CHECK.LN LE CHECK.LN.MAX THEN PRINT @(ZERO,CHECK.LN):RVB:STR("-",CHECK.LEN - TWO) CHECK.FMT:RVE:
END
END
END
END
*
*  END; * OF NOT(COM.AI.ERR)
*
PORTS.LIST.BUILD = FALSE
*
*
*** $INCLUDE IBP AI.HERROR.XREF
*CODE.SEGMENT: AI.HERROR.XREF
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
* COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP
END
DEL AI.CHK.ERR<ONE>
REPEAT
*
END; * of AI.CHK.ERR ne empty
*
!
*
IF COM.AI.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(COM.AI.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
*
LOCATE COM.AI.ERR<TMP.CN> IN COM.AIHERR$STD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
* COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
*
*
* TMP2 = COM.AIHERR$DESC<ONE,ERR.LOC>
*
TMP2 = COM.AI.ERR.TEXT<TMP.CN>
*
LOOP WHILE INDEX(TMP2,"@",ONE) DO
TMP = FIELD(TMP2,"@",ONE)
TMP0 = FIELD(TMP2,"@",TWO)
TMP1 = FIELD(TMP2,"@",3)
TMP1 = TMP2[COL1()+ONE,9999]
TMP.VAR = EMPTY
BEGIN CASE
CASE TMP0 EQ "COM.AI.RUN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
* 999.9 Hours
CASE TMP0 EQ "COM.AI$ON.OFF"
TMP.VAR = COM.AI$ON.OFF
CASE TMP0 EQ "COM.AI.ON.OFF.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AI$UP.DN"
TMP.VAR = COM.AI$UP.DN
CASE TMP0 EQ "COM.AI.UP.DN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.PORT"
TMP.VAR = COM.AIP.PORT
CASE TMP0 EQ "COM.AIP$INTFC.STAT"
TMP.VAR = COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>
CASE TMP0 EQ "COM.AIP$ERR"
TMP.VAR = COM.AIP$ERR<ONE,ONE,ONE>
CASE TMP0 EQ "AI.STATUS"
TMP.VAR = AI.STATUS + ZERO
CASE TMP0 EQ "SEND.STATUS"
TMP.VAR = SEND.STATUS + ZERO
END CASE
TMP2 = TMP:TMP.VAR:TMP1
REPEAT
*
COM.AI.ERR.TEXT<TMP.CN> = TMP2
*
* COM.AI.ERR.TYPE<TMP.CN> = COM.AIHERR$TYPE<ONE,ERR.LOC>
* TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
TMP = COM.AI.ERR.TYPE<TMP.CN>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE
* COM.AI.ERR.FUNC<TMP.CN> = TMP
COM.AI.ERR.FUNC<TMP.CN> = COM.AIHERR$FUNC<ONE,ERR.LOC>
END
*
* DEL AI.CHK.ERR<ONE>
*
REPEAT
*
END
*
*
*** @@@
~AI.INCL.INTFC.DISPLAY~
*CODE.SEGMENT: AI.INCL.INTFC.DISPLAY
* VERSION: 940201 1.1  HEADEND TO AI.CODE, COM.AI$PORT TO COM.AI$COMMPORT.
* USED BY: AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS
*   1990        ALL RIGHTS RESERVED
*
!
*
GOSUB DISPLAY.TITLE
*
PRINT @(ZERO,3):CLL:RVB:"   Handler Status":RVE:" ":
IF COM.AI$ON.OFF.STAT NE "ON" THEN PRINT "OFF": ELSE PRINT "ON":
IF COM.AI$UP.DN.STAT NE "UP"  THEN PRINT " DOWN": ELSE PRINT " UP":
*
*
** 23APR94 ** OPER.LN = 3; OPER.CL = 31; OPER.DESC.LN = 3; OPER.DESC.CL = 49
** 23APR94 ** OPER.DESC.FMT = "L#15"; OPER.STAT = EMPTY; OPER.DISP = TRUE
** 23APR94 ** OPER.RVB = TRUE; OPER.TEXT = "Operator: "
** 23APR94 ** OPER.POSN = EMPTY
** 23APR94 ** LN = 9
OPER.DISP = TRUE
CALL INPUT.OPERATOR(OPER,OPER.POSN,OPER.LN,OPER.CL,OPER.TEXT,OPER.DESC.LN,OPER.DESC.CL,OPER.DESC.FMT,OPER.RVB,RUN.TYPE,OPER.DISP,OPER.STAT)
** 23APR94 ** IF OPER.STAT THEN CHAIN "FREEZE.PORT"
*
!
*
PRINT @(ZERO,4):CLL:RVB:"        Test Flag":RVE:" ":COM.AI$TEST.MODE:
PRINT @(31,4):RVB:"Handler Logging and Error Messages" "L#48":RVE:
*
!
*
PRINT @(ZERO,5):CLL:RVB:"  Command Logging":RVE:" ":
IF COM.AI$LOGGING EQ "Y" THEN PRINT "ON": ELSE PRINT "OFF":
*
!
*
PRINT @(ZERO,6):CLL:RVB:"      Port Number":RVE:" ":COM.AI$COMMPORT
*
!
*
PRINT @(ZERO,7):CLL:
*
!
*
PRINT @(ZERO,8):CLL:
*
!
*
PRINT @(ZERO,9):CLL:
*
!
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK
*
IF PORTS.LIST NE PORTS.LIST.PREV THEN
*COM.AI$FUNC.PORT<ONE,-ONE> = PORTS.LIST
PORTS.LIST.PREV = PORTS.LIST
END
*
!
*
IF LEN(COM.AI.ERR.TEXT) THEN
PRINT @(ZERO,7):RVB:COM.AI.ERR.TEXT<ONE> "L#30":RVE:
END
** IF ERR.BELL AND LEN(COM.AI.ERR) AND (COM.AI.ERR.FUNC<ONE> NE OLD.FUNC<ONE> AND COM.AI.ERR.FUNC NE EMPTY) THEN PRINT BELL:; RQM
*
!
*
PRINT @(35,10):RVB:" He*Ch# Srvc. Description..... Last.Change ST       " "L#45":RVE:
LN = 10; VC = ONE
*
LOOP
*
MLE.NUM = STL<STATUS.CHANNEL,VC>
MLE.HE = FIELD(MLE.NUM,"*",ONE)
IF MLE.HE NE HEADEND THEN
HEADEND = MLE.HE
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE NULL
END
*
UNTIL MLE.NUM EQ EMPTY DO
*
REASON = STL<STATUS.CHAN.STAT,VC>
*
IF LEN(REASON) OR CHAN.ALL THEN
*
LN = LN + ONE
*
IF LN GT 20 THEN
PRINT @(35,LN):CLL:
IF STATUS.CYCLE THEN
LN = 11
RQM; RQM
END ELSE
LOOP
PRINT @(35,23):CLL: "Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(35,23):CLL:
IF RSP EQ EMPTY THEN RETURN ELSE LN = 11; ALREADY.DISPLAYED = TRUE
END
END; * of pg
*
* SDATE = OCONV(FIELD(STL<STATUS.DESC,VC>,"*",ONE),"D2")
* STIME = OCONV(FIELD(STL<STATUS.DESC,VC>,"*",TWO),"MT")
SDESC = STL<STATUS.DESC,VC>
RDATE = OCONV(FIELD(STL<STATUS.CHECKED,VC>,"*",ONE),"D2")
*TMP = INDEX(RDATE," ",TWO)
*IF TMP THEN RDATE = RDATE[ONE,TMP - ONE]
RDATE = FIELD(RDATE," ",ONE):FIELD(RDATE," ",TWO)
RTIME = OCONV(FIELD(STL<STATUS.CHECKED,VC>,"*",TWO),"MTH")
RDT = RDATE:" ":RTIME
SSRVC = STL<STATUS.SRVC,VC>
*
IF LEN(REASON) THEN
PRINT @(35,LN):(" ":MLE.NUM "L#6":" ":SSRVC "L#5":" ":SDESC "L#16":" ":RDT "L#11":" ":REASON "L#2") "L#45":
LOCATE REASON IN AI.ERRORS<ONE> BY "AR" SETTING LOC THEN
REASON = AI.ERRORS<3,LOC>
LN = LN + ONE
PRINT @(35,LN):CLL:RVB:(SPACE(12):REASON) "L#45":RVE:
END
END ELSE
PRINT @(35,LN):(" ":MLE.NUM "L#6":" ":SSRVC "L#5":" ":SDESC "L#16":" ":RDT "L#11":" ":REASON "L#2") "L#45":
END; * of reason
*
END; * of reason or all flag
*
VC = VC + ONE
*
REPEAT
*
IF ALREADY.DISPLAYED THEN
LOOP
LN = LN + ONE
UNTIL LN GT 22 DO
PRINT @(35,LN):CLL:
REPEAT
ALREADY.DISPLAYED = EMPTY
END
*
*
~AI.INCL.INTFC.MESSAGES~
*CODE.SEGMENT: AI.INCL.INTFCMESSAGES
* USED BY: AI.CONTROL.UTILITY
*          AI.TALKER
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
!
*
IF LEN(COM.AI.ERR.TEXT) THEN
*
COM.AI.ERR.CN.MAX = DCOUNT(COM.AI.ERR,AM)
COM.AI.ERR.CN = ONE; TMP = FALSE
LOOP WHILE COM.AI.ERR.CN LE COM.AI.ERR.CN.MAX DO
TMP = COM.AI.ERR<COM.AI.ERR.CN>
IF NUM(TMP) THEN
IF TMP THEN
TEXT<-ONE> = "[":COM.AI.ERR.TYPE<COM.AI.ERR.CN>:" ":("000":TMP) "R#3":"] ":COM.AI.ERR.TEXT<COM.AI.ERR.CN>
*960517*DGH*IF (TMP NE 71 AND TMP GT AI.STATUS) AND TMP LT 300 THEN AI.STATUS = TMP
*960517*DGH*IF TMP NE 71 AND TMP GT SEND.STATUS THEN SEND.STATUS = TMP
END
END ELSE TMP = TRUE
IF NOT(TMP) THEN TEXT<-ONE> = COM.AI.ERR.TEXT<COM.AI.ERR.CN>
* DEL COM.AI.ERR<ONE>
* DEL COM.AI.ERR.TEXT<ONE>
COM.AI.ERR.CN = COM.AI.ERR.CN + ONE
REPEAT
*
END
*
~AI.INCL.INTFC.STL~
*CODE.SEGMENT: AI.INCL.INTFC.STL
* VERSION: 940130 1.1  Changed refs of 'COMMPORT' and 'HEADEND' to 'AI.CODE', HEADENDS now in AI.TYPES.
* DESCRIPTION: LOAD CHANNEL STATUSES FOR THE AI.TYPE.
* USED BY: AI.HANDLER
*          AI.CHANNEL.UP
*          AI.CHANNEL.DN
*          AI.CONTROL.UTILITY
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
*
SYS.LOCT = "AI.INCL.INTFC.STL"
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = AI.CODE
LOCATE AI.CODE IN AI.TYPES<1> SETTING COMMPORT.LOC ELSE COMMPORT.LOC = ONE
AI.CODE = AI.TYPES<ONE,COMMPORT.LOC>
HEADENDS = AI.TYPES<4,COMMPORT.LOC>
CHANNEL.MLES = EMPTY; STL.ID = "AI.STATUS.CH.":AI.CODE
*
*22MAR94*IF COMPONENTS.DFLT EQ EMPTY THEN
READ COMPONENTS.DFLT FROM COM.FILE,"COMPONENTS" ELSE NULL
*22MAR94*END
*
HE.CN.MAX = DCOUNT(HEADENDS,SVM)
*
IF LCK.ITM THEN
LOOP
CALL SYS.ITM.LCK("COM",STL.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
END ELSE LCK.STAT = FALSE
*
READ STL FROM COM.FILE,STL.ID ELSE STL = EMPTY
*
* READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE AI.ERRORS = EMPTY
*
STL<STATUS.FLAGGED> = EMPTY; TMP = ONE; WRITE.FLAG = FALSE
SAVE.HEADEND = HEADEND
*
FOR HE.CN = ONE TO HE.CN.MAX
*
**IF HEADENDS<ONE,ONE,HE.CN> NE HEADEND THEN
READ COMPONENTS FROM COM.FILE,"COMPONENTS.":HEADENDS<ONE,ONE,HE.CN> ELSE COMPONENTS = EMPTY
**END
*
HEADEND = HEADENDS<ONE,ONE,HE.CN>
*
CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PROG,STAT)
*
MVC = ONE
LOOP MLE.NUM = CHANNEL.MLES<ONE,MVC> UNTIL MLE.NUM EQ EMPTY DO
*
MLE.NUM = ("000":MLE.NUM) "R#3"; TMP = HEADEND:"*":MLE.NUM
LOCATE TMP IN STL<STATUS.CHANNEL> BY "AL" SETTING STL.LOC ELSE
INS TMP BEFORE STL<STATUS.CHANNEL,STL.LOC>
INS EMPTY BEFORE STL<STATUS.CHAN.STAT,STL.LOC>
INS CHANNEL.MLES<TWO,MVC> BEFORE STL<STATUS.DESC,STL.LOC>
INS EMPTY BEFORE STL<STATUS.CHECKED,STL.LOC>
INS CHANNEL.MLES<3,MVC> BEFORE STL<STATUS.SRVC,STL.LOC>
INS EMPTY BEFORE STL<STATUS.FLAGGED,STL.LOC>
WRITE.FLAG = TRUE
END
*
IF STL<STATUS.DESC,STL.LOC> EQ EMPTY THEN
LOCATE STL<STATUS.SRVC,STL.LOC> IN COMPONENTS.DFLT<ONE> SETTING TMP.LOC THEN
STL<STATUS.DESC,STL.LOC> = COMPONENTS.DFLT<TWO,TMP.LOC>
WRITE.FLAG = TRUE
END ELSE NULL
END
*
STL<STATUS.FLAGGED,STL.LOC> = ONE
MVC = MVC + ONE
*
REPEAT
*
NEXT HE.CN
*
HEADEND = SAVE.HEADEND
COMPONENTS = COMPONENTS.DFLT
*
!
*
ST.VC = ONE
*
LOOP UNTIL STL<STATUS.CHANNEL,ST.VC> EQ EMPTY DO
IF STL<STATUS.FLAGGED,ST.VC> THEN ST.VC = ST.VC + ONE ELSE
DEL STL<STATUS.CHANNEL,ST.VC>
DEL STL<STATUS.CHAN.STAT,ST.VC>
DEL STL<STATUS.DESC,ST.VC>
DEL STL<STATUS.CHECKED,ST.VC>
DEL STL<STATUS.SRVC,ST.VC>
DEL STL<STATUS.FLAGGED,ST.VC>
WRITE.FLAG = TRUE
END
REPEAT
*
DEL STL<STATUS.FLAGGED>
*
*
IF WRITE.FLAG AND LCK.ITM AND NOT(LCK.STAT) THEN
WRITE STL ON COM.FILE,STL.ID
END
*
IF LCK.ITM AND LCK.RELS THEN
CALL SYS.ITM.RLS("COM",STL.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
END
*
*
~AI.INCL.LCK.XPV~
*CODE.SEGMENT: AI.INCL.LCK.XPV
*
*
IF LCK.ITM THEN
LCK.DT = DATE(); LCK.TM = TIME()
LOOP
IF NOT(STAT) THEN
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("CNT","XPV.CTL",LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
IF LCK.STAT THEN
EXECUTE "SLEEP 5"
IF LCK.STAT GT 900 THEN STAT = 999
END
END
WHILE NOT(STAT) AND LCK.STAT DO
DT = DATE(); TM = TIME()
IF ((DT - LCK.DT) * 86400) + (TM - LCK.TM) GT 15 THEN
EXEC.VERB = "BLOCK-PRINT CASH IN ":ACCT:" XPV LOCKED AT ":LCK.STAT:" (P)"
STAT = 999
END
REPEAT
END
*
*
~AI.INCL.LOAD.CODE~
*CODE.SEGMENT: AI.INCL.LOAD.CODE
*
*
IF CNT.TST$LBL THEN PRINT CLB:"Load Ai Code":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
* HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
TMP = ONE; TMP1 = FALSE
LOOP
AI.CODE = AI.TYPES<ONE,TMP>
LOCATE HEADEND IN AI.TYPES<4,TMP> SETTING TMP2 THEN TMP1 = TRUE 
UNTIL AI.CODE EQ EMPTY OR TMP1 DO TMP = TMP + ONE REPEAT
IF AI.CODE EQ EMPTY THEN AI.CODE = AI.TYPES<ONE,ONE>
*
~AI.INCL.LOCK.XPV~
*CODE.SEGMENT: AI.INCL.LCK.XPV
*
*
SYS.LOCT = "AI.INCL.LOCK.XPV"
*
IF LCK.ITM THEN
LCK.DT = DATE(); LCK.TM = TIME()
LOOP
IF NOT(STAT) THEN
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("CNT","XPV.CTL",LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT THEN
EXECUTE "SLEEP 5"
IF LCK.STAT GT 900 THEN STAT = 999
END
END
WHILE NOT(STAT) AND LCK.STAT DO
DT = DATE(); TM = TIME()
IF ((DT - LCK.DT) * 86400) + (TM - LCK.TM) GT 15 THEN
EXEC.VERB = "BLOCK-PRINT CASH IN ":ACCT:" XPV LOCKED AT ":LCK.STAT:" (P)"
STAT = 999
END
REPEAT
END
*
*
~AI.INCL.RELS.XPV~
*CODE.SEGMENT: CASH.INCL.RELS.XPV
*
*
SYS.LOCT = "AI.INCL.RELS.XPV"
*
IF LCK.ITM THEN
***CALL UNLCK.ITEM(LCK.FILE,"CNT","XPV.CTL",LCK.FILE)
CALL SYS.ITM.RLS("CNT","XPV.CTL",LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
END
*
*
~AI.INCL.TALKER.INIT~
*CODE.SEGMENT: AI.INCL.TALKER.INIT
*
*
AUTO.RUN = FALSE; DISP.ONLY = FALSE; MSG.DISP = FALSE
TYPE.RUN = ONE
LCK.ELP = ZERO; LCK.ELP.MAX = 60
LCK.TYPE = -8; LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.STAT = FALSE
*
****COM.AI.ERR.DISP = TWO
COM.AI.ERR.DISP = ZERO
FUNC.CHNG = EMPTY; AIL.NEXT.ID = AIL.ID
*
ERR.LN.MIN = TWO; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CL = 43; ERR.LN = ERR.LN.MIN; ERR.LEN = 36; ERR.CLB = FALSE
ERR.DISP.ONLY = 3; ERR.HDR = "Interface Messages"
*
CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
CHECK.LEN = 48; CHECK.LN.HI = ZERO
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
CHECK.ELP.MAX = 15
*
CHAN.ALL = FALSE
OPER = ""; HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
EQUIP.TYPE = ""
*
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "T"; LOG.REQUIRED = FALSE
SEND.STATUS = FALSE
OFF.FLAG = FALSE
CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
!
*
GOSUB LOAD.TST
*
*
FAST.DISPLAY = FALSE; PORTS.LIST.BUILD = ZERO; AI.SCAN = TRUE
AI.SCAN = FALSE; ************
IF AI.TALK<OP.MULTI> THEN SINGLE = 0 ELSE SINGLE = 1
*
*
IF CNT.TST$RTN THEN PRINT CLB:"Entering AI.TALKER for ":AI.ACTN:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
LCK.ITM = FALSE; LCK.RELS = FALSE
GOSUB READ.COM.AI
IF COM.AI.NOT.ON.FILE THEN RETURN
*
*
IF NOT(AI.TALK<INTERFACE.MSG>) THEN AI.ACTN = FN$CHECK.INTFC:AM:AI.ACTN
*
IF NOT(AI.TALK<DISPATCHER.MSG>) THEN AI.ACTN = FN$CHECK.DISPATCHER:AM:AI.ACTN
*
IF AIX.ID NE EMPTY OR (AI.TALK<AI.DVC.NEXT> AND AI.TALK<AI.DVC.IDS> NE EMPTY) THEN DVC.ON.FILE = TRUE ELSE DVC.ON.FILE = FALSE
*
!
*
~AI.INCL.UPD.COM.AIP.UTL~
SUBROUTINE AI.SUBR.UPDT.COM.AIP.UTL(LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,SEND.COMM.CN,SYS.PRNT,STAT)
*
*
* CALLED BY AI.CONTROL.UTILITY
*              Eagle addressable interface HANDLER.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU TST$AM TO 12, TST$VM TO 9
EQU VERSION TO "901028 NEW (1.0)"
VS = "901028 NEW (1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.UPDT.COM.AIP.UTL"; SYS.LOCT = EMPTY
OPER = ""
*
!
*
$INCLUDE IBP TST.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
*
AIX.UPDATE: * Update addressable interface file - AIX
*
LCK.ITM = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
IF NUM(COM.AIP.PORT) THEN COM.AIP.PORT = COM.AIP.PORT + 0
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LT 300 DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
*
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
BEGIN CASE
*
CASE LCK.STAT OR ELP GE 300
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
IF COM.AIP$RVRS.FL THEN
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = PORT
END ELSE
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
*COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS 604 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> EQ EMPTY OR NOT(COM.AIP$RVRS.FL) THEN
* IF I AM THE HANDLER PORT THEN
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
NULL
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
NULL
*
CASE TRUE
INS 606 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
*
END CASE
*
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> THEN
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE ERR$NOT.SENT THEN
IF NOT(COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> LT 100 OR COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> GE 600) THEN
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> GT AI.STATUS THEN
AI.STATUS = COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
IF AI.STATUS EQ ERR$NOT.SENT THEN AI.STATUS = FALSE
END
END
END
*
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> NE EMPTY THEN
SEND.STATUS = COM.AIP$INTFC.ERR<ONE,ONE,ONE>
IF SEND.STATUS EQ ERR$NOT.SENT THEN SEND.STATUS = FALSE
IF PORT EQ COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$CHECK.TOUT THEN SEND.STATUS = FALSE
END
IF PORT NE COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$TOUT THEN SEND.STATUS = FALSE
END
END
*
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
END ELSE NULL
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
*
*
RETURN
*
END
~AI.INCL.UPDT.COM.AIP~
*CODE.SEGMENT: AI.INCL.UPDT.COM.AIP*
*
*
*
*
SYS.LOCT = "AI.INCL.UPDT.COM.AIP"
** AI.SRCE = "U"
** HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
** *
COM.AI.ID = "AI.TYPE.":AI.CODE
* MAT COM.AI S/D ALREADY PRESENT
** READV COMMPORT FROM COM.FILE,COM.AI.ID,12 ELSE COMMPORT = 999
COMMPORT = COM.AI$COMMPORT
*
COM.AIP.PORT = PORT
LOOP WHILE LEN(COM.AIP.PORT) LT 3 DO COM.AIP.PORT = ZERO:COM.AIP.PORT REPEAT
AI.DVC.NEXT.FOUND = TRUE
*
!
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND)
*
*
COM.AIP.ID = "AI*":AI.CODE:"*":COM.AIP.PORT:"*":AI.DVC.NEXT.CN
DT = DATE(); TM = TIME(); ELP = ZERO
*
LOOP
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LT LCK.ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
*
* SEND.STATUS = FALSE
AI.COM.FLAG = FALSE
DT = DATE(); TM = TIME()
*
IF CNT.TST$ID THEN
PRINT CLB:"Updating COM.AIP$INTFC.STAT. Enter <cr>: ":; INPUT TMP:
END
*
!
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
*
OK = TRUE
IF INDEX("#AIDVC#PVI#PVD#IVI#IVD#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE) THEN
IF WKO$STAT NE "C" AND WKO$STAT NE "D" THEN OK = FALSE
END ELSE
IF NOT(INDEX("#SEQ#UPB#DLE#SET#","#":COM.AIP$COMM<ONE,SEND.COMM.CN>:"#",ONE)) THEN OK = FALSE
END
*
*960621*DGH*IF NOT(OK) AND COM.AIP$RVRS.FL THEN
IF NOT(OK) THEN
*
IF COM.AIP$REVS.FL THEN
*
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 605
*
END ELSE
*
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
SEND.STATUS = 608
*
END
*
END ELSE
*
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*SEND.STATUS = 609
*
END; * OF NOT OK
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
* "TOUT" BEFORE COM.AIP$ERR.TYPE<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
SEND.STATUS = 601
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
IF NOT(COM.AIP$RVRS.FL) THEN
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
SEND.STATUS = 602
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP" AND NOT(COM.AIP$RVRS.FL)
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
SEND.STATUS = 607
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
AI.COM.FLAG = TRUE
SEND.STATUS = 603
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
SEND.STATUS = 604
*
CASE TRUE
* PRINT CLB:">>":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"<<":; INPUT TMP:
SEND.STATUS = 606
*
END CASE
*
*
!
*
IF SEND.STATUS THEN
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
*
IF COM.AIP$LOG.REQD OR SEND.STATUS THEN
OPEN "AIL" TO AIL.FILE THEN
AIL.SEQ.ID = "AI.LOG*":AI.CODE
* $INCLUDE IBP AI.LOG.WRITE
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.AIP.ID,AI.CODE,AI.SRCE,LOG.REQUIRED,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PROG,STAT)
END ELSE PRINT CLB:"AIL file missing! Enter <cr> . . . "; INPUT RSP; STAT = 999
END
*
*
NEXT SEND.COMM.CN
*
!
*
SEND.COMM.CN = ONE
*
*
***IF AI.COM.FLAG THEN
***MAT COM.AI = EMPTY
***HANDLER.COMMAND = COM.AIP$COMM; AI.TMP.STAT = EMPTY; SEND.TMP.STAT = EMPTY
**** CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
**** CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"E","",LCK.STAT)
***CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.TMP.STAT,SEND.TMP.STAT,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,SYS.PROG,STAT)
***TMP.STAT = AI.TMP.STAT
**** IF TMP.STAT THEN
**** PRINT BELL:CLB:"Addressable interface error (":TMP.STAT:") - Press <cr>":
**** INPUT TMP.RSP:; IF TMP.RSP = "KILL" THEN STAT = 999
**** END
***END ELSE
IF LCK.COM.AIP THEN
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
* CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
* CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"F","",LCK.STAT)
END
*
***END
*
END ELSE
*
* CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
* CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"G","",LCK.STAT)
AI.DVC.NEXT.FOUND = FALSE
*
END; * OF READ
*
*
IF LCK.COM.AIP THEN
IF AI.DVC.NEXT.FOUND THEN
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
*
NEXT AI.DVC.NEXT.CN
*
!
*
IF SEND.STATUS AND NOT(AUTO.RUN) THEN
IF CNT.TST$LBL THEN
PRINT BELL:CLB:"Addressable interface error (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
*PRINT " - Press <cr> ":
* INPUT TMP.RSP:; * IF TMP.RSP = "KILL" THEN STAT = 999; RETURN
END
END
*
~AI.INCL.UPDT.COM.AIP.UTL~
*CODE.SEGMENT: AI.INCL.UPDT.COM.AIP.UTL
*
*
* AI.SUBR.UPDT.COM.AIP.UTL(LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,SEND.COMM.CN,SYS.PRNT,STAT)
*
*
* CALLED BY AI.CONTROL.UTILITY
*              Eagle addressable interface HANDLER.
*
*
SYS.LOCT = "AI.INCL.UPDT.COM.AIP.UTL"
*
* LCK.ITM = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
IF NUM(COM.AIP.PORT) THEN COM.AIP.PORT = COM.AIP.PORT + 0
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LT 300 DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
*
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
BEGIN CASE
*
CASE LCK.STAT OR ELP GE 300
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
IF COM.AIP$RVRS.FL THEN
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = PORT
END ELSE
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
*COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS 604 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> EQ EMPTY OR NOT(COM.AIP$RVRS.FL) THEN
* IF I AM THE HANDLER PORT THEN
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
NULL
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
NULL
*
CASE TRUE
INS 606 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
*
END CASE
*
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> THEN
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE ERR$NOT.SENT THEN
IF NOT(COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> LT 100 OR COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> GE 600) THEN
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> GT AI.STATUS THEN
AI.STATUS = COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
IF AI.STATUS EQ ERR$NOT.SENT THEN AI.STATUS = FALSE
END
END
END
*
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> NE EMPTY THEN
SEND.STATUS = COM.AIP$INTFC.ERR<ONE,ONE,ONE>
IF SEND.STATUS EQ ERR$NOT.SENT THEN SEND.STATUS = FALSE
IF PORT EQ COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$CHECK.TOUT THEN SEND.STATUS = FALSE
END
IF PORT NE COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$TOUT THEN SEND.STATUS = FALSE
END
END
*
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
END ELSE NULL
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
*
~AI.INCL.WAITFOR.COMMAND~
*CODE.SEGMENT: AI.INCL.WAITFOR.COMMAND
* VERSION: 940130 1.1  COM.AI.ID CHANGED.
* USED BY: AI.TALKER
*          AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*   1990        ALL RIGHTS RESERVED
*
!
*
SYS.LOCT = "AI.INCL.WAITFOR.COMMAND"
*
IF DISP.ONLY THEN RETURN
*
***NUM.TRIES = ZERO; MAX.PAUSE = 120; STD.PAUSE = 5
NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = COM.AI$MAX.PAUSE; STD.PAUSE = COM.AI$STD.PAUSE
***NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = 30; STD.PAUSE = ONE
IF NOT(MAX.PAUSE) THEN MAX.PAUSE = 30
IF NOT(STD.PAUSE) THEN STD.PAUSE = ONE
INTFC.PAUSE = ZERO
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF ELP.MAX LT 60 THEN ELP.MAX = 60
ELP.MAX = 15
WF.DT = DT; WF.TM = TM
* WF.C.LOC = HANDLER.COMMAND<ONE,ONE> (FUNC OR COMMAND) ( NOT USED )
* STAT = 0;  WF.C.FUNC = PORT NUMBER
WF.C.FUNC = PORT.KEY
COM.AI.ON.FILE = FALSE; HANDLER.DONE = FALSE
COM.AI.ID = "AI.TYPE.":AI.CODE; COM.ID = COM.AI.ID
*
LOOP
*
EXEC.VERB = "SLEEP ":STD.PAUSE
IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:EXEC.VERB "L#19":RVE:
IF NOT(SYSTEM(11)) THEN
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
END
*
*@*LOOP
*
LCK.STAT = LCK.TYPE
**CALL LCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE,LCK.STAT)
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
IF COM.AIP$MAX.PAUSE GT INTFC.PAUSE THEN INTFC.PAUSE = COM.AIP$MAX.PAUSE
IF HANDLER.ELP GT MAX.PAUSE + INTFC.PAUSE THEN
*@@@*IF HANDLER.ELP GT MAX.PAUSE AND HANDLER.ELP GT COM.AIP$MAX.PAUSE THEN
TEXT<-ONE> = "Can't wait longer than ":MAX.PAUSE + INTFC.PAUSE:" seconds."
AI.STATUS = 201
IF CNT.TST$LBL THEN PRINT @(15,23):CLL:"[Set Intfc Status] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:"): ":COM.AIP$ERR "L#20":
****INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
****INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
END
*
*@*WHILE (LCK.STAT AND LCK.STAT LT 900) AND AI.STATUS NE 201 DO REPEAT
*
*
* IF NOT(LCK.STAT) THEN
*@*IF LCK.COM.AI THEN
* IF AI.STATUS NE 201 THEN
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN
COM.AI.ON.FILE = TRUE
IF COM.AI$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AI$MAX.PAUSE
*@@@*IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
STD.PAUSE = COM.AI$STD.PAUSE
END ELSE
COM.AI.ON.FILE = FALSE; STAT = 998; MAT COM.AI = EMPTY
END
*
LOOP WHILE LEN(COM.AI$FUNC.PORT) AND COM.AI$FUNC.PORT<ONE,ONE> EQ EMPTY DO
DEL COM.AI$FUNC.PORT<ONE,ONE>
REPEAT
*
IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:COM.AI$FUNC.PORT<ONE> "L#19":RVE:
LOCATE WF.C.FUNC IN COM.AI$FUNC.PORT<ONE> SETTING COM.AI.LOC THEN
*
HANDLER.DONE = FALSE
*
IF AI.STATUS EQ 201 THEN
IF LCK.COM.AI THEN
DEL COM.AI$FUNC.PORT<ONE,COM.AI.LOC>
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
END
END
*
IF COM.AI.LOC GT ONE THEN
WF.DT = DATE(); WF.TM = TIME()
END
*
*@*IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Not Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,ONE):RVB:"Comm. Not Done" "L#19":RVE:
*
END ELSE
*
HANDLER.DONE = TRUE; **** ???? *****
COM.AI.LOC = ONE
*@*IF CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,ONE):RVB:"Comm. Done" "L#19":RVE:
*
END
*
PORT.LOC = COM.AI.LOC
*
IF LCK.COM.AI THEN
**CALL UNLCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE)
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
* END ELSE
* HANDLER.DONE = FALSE
* END
*
UNTIL AI.STATUS EQ 201 OR HANDLER.DONE OR SYSTEM(11) GT 3 DO
*
GOSUB DISP.COM.AIP.STAT; * : *
*
REPEAT
*
!
*
* PRINT @(20,23):CLL:
LOCATE WF.C.FUNC IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
HANDLER.DONE = FALSE
IF COM.AI.ERR.DISP OR CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Not Done" "L#19":RVE:
END ELSE
HANDLER.DONE = TRUE
PORT.LOC = ONE
IF COM.AI.ERR.DISP OR CNT.TST$LBL THEN PRINT @(60,ONE):RVB:"Comm. Done" "L#19":RVE:
END
*
IF NOT(STAT) AND LCK.STAT GT 900 THEN STAT = LCK.STAT
IF STAT THEN
IF STAT GT AI.STATUS THEN AI.STATUS = STAT
IF CNT.TST$LBL THEN PRINT @(15,23):CLL:"[Set Intfc Status] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:"): ":COM.AIP$ERR "L#20":
TEXT<-ONE> = "Status ":STAT:" error in wait routine."
END
*
!
*
DT = DATE(); TM = TIME(); ELP = ZERO
*#*LOOP
LCK.STAT = LCK.TYPE
**CALL LCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"E","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*#*UNTIL NOT(LCK.STAT) OR ELP GT ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
*960624*DGH*IF COM.AIP$RETRY<ONE,ONE,ONE> LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY<ONE,ONE,ONE>
*
IF LCK.COM.AIP THEN
**CALL UNLCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"F","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
!
*
SEND.COMM.CN.TMP.MAX = DCOUNT(COM.AIP$COMM<ONE>,VM)
*
FOR SEND.COMM.CN.TMP = ONE TO SEND.COMM.CN.TMP.MAX
*
IF COM.AIP$RETRY<ONE,SEND.COMM.CN.TMP,ONE> LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY<ONE,SEND.COMM.CN.TMP,ONE>
*
TMP = COM.AIP$ERR<ONE,SEND.COMM.CN.TMP,ONE>
IF TMP LT 299 THEN
IF NOT(TMP LT 100 OR TMP GE 600) THEN
IF TMP EQ ERR$NOT.SENT THEN TEMP = FALSE
IF TMP GT AI.STATUS THEN
AI.STATUS = TMP
IF CNT.TST$LBL THEN PRINT @(15,23):CLL:"[Set Intfc Status] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:"): ":COM.AIP$ERR "L#20":
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
END
END
END
*
TMP1 = COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN.TMP,ONE>
IF COM.AIP.PORT EQ PORT THEN
IF INDEX("*COMP*DONE*XCEL*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>:"*",ONE) THEN
IF TMP1 NE EMPTY THEN
IF TMP1 LT ERR$HANDLER.ERR OR TMP1 GT 899 THEN
IF TMP1 = ERR$NOT.SENT THEN TMP1 = FALSE
IF TMP1 GT SEND.STATUS THEN
SEND.STATUS = TMP1
IF CNT.TST$LBL THEN PRINT @(15,23):CLL:"[Set Send Status] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:"): ":COM.AIP$INTFC.ERR "L#20":
END
END
END
END
END
*
NEXT SEND.COMM.CN.TMP
*
*
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
IF LEN(TEXT) AND (SEND.STATUS OR AI.STATUS OR NOT(ERR.CLB)) THEN GOSUB ERROR
*
IF INDEX("UDS",AI.SRCE,ONE) THEN PORT.LIST.BUILD = 7
*
*
~AI.INCL.WRITE.COMMAND~
*CODE.SEGMENT: AI.INCL.WRITE.COMMAND
*
*
* VERSION: 940130 1.1  COM.AI.ID CHANGED TO 'AI.TYPE':AI.CODE
*SUBROUTINE: AI.WRITE.COMMAND
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   1990         ALL RIGHTS RESERVED
*
* AUTHOR: DAVID G. HORSMAN
*
* DATE RELEASED: ?? DEC 90
*
*      Write a command onto the port's work file record for transmission...
*
* TO IMPLEMENT TESTING MAT CNT.TST SHOULD BE PASSED IN THE CALL.
!
*
*$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*!
*$INCLUDE IBP COM.AIP.DIM
*$INCLUDE IBP COM.AIP.EQUATES
*$INCLUDE IBP SAVE.COM.AIP.DIM
*!
*$INCLUDE IBP COM.AI.DIM
*$INCLUDE IBP COM.AI.EQUATES
**
*$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
!
OPEN "COM" TO COM.FILE ELSE PRINT @(0,23):CLL:"Can't open COM":; INPUT RSP:; STOP
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT @(0,23):CLL:"Can't open LOCKS":; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
* LCK.ITM = TRUE; LCK.TYPE = -1; LCK.RELS = TRUE
LCK.ITM = TRUE; LCK.RELS = TRUE
LCK.ELP = ZERO; LCK.ELP.MAX = 30
OPT.COMM = HANDLER.COMMAND
SEND.COMM.CN = ONE
*
!
*
*IF NOT(NUM(HANDLER.COMMAND<ONE,ONE>)) THEN
*IF HANDLER.COMMAND<ONE,ONE> EQ AI.UP THEN AI.STATUS = FALSE ELSE AI.STATUS = TRUE
*END
*
PREV.DT = DATE(); PREV.TM = TIME()
MAT SAVE.COM.AIP = ""; PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
COM.AI.ID = "AI.TYPE.":AI.CODE
*
*IF HANDLER.COMMAND NE EMPTY THEN AI.STATUS = HANDLER.COMMAND; RETURN
*
IF COM.AIP.ID EQ EMPTY THEN AI.STATUS = 21; RETURN
*
MAT SAVE.COM.AIP = MAT COM.AIP; RETRY = 0
*** LCK.ITM = FALSE; LCK.RELS = TRUE
LCK.ITM = TRUE; LCK.RELS = FALSE
GOSUB READ.COM.AI
LCK.ITM = TRUE; LCK.RELS = TRUE
*
PRINT @(0,23):CLL:@(ZERO):
*
IF COM.AI$UP.DN.STAT NE AI.UP THEN
PRINT @(31,22):BELL:RVB:"The Addressable Interface Handler is down" "L#73":RVE:
IF NOT(INDEX("#":AI.ON:"#":AI.UP:"#":AI.OFF:"#","#":HANDLER.COMMAND<ONE,ONE>:"#",ONE)) THEN
PRINT @(6,23):" -- press <cr>...":
**** DON'T WANT TO ALWAYS TAKE INPUT
INPUT RSP:; PRINT @(6,23):SPACE(73):
*HANDLER.COMMAND = 1; 
*** AI.STATUS = 11; RETURN
AI.STATUS = 11
END
END
*
!
*
* Main program loop
*
RETRY.CONT = TRUE
WRITEN.FLAG = FALSE; OVERWRITE.FLAG = FALSE
*
IF NOT(AI.STATUS) AND LCK.COM.AI THEN
*
!
*
LOOP
*
*
* LOCK ITEM
*
IF NOT(LCK.COM.AI) THEN
DT = DATE(); TM = TIME(); ELP = ZERO
TMP1 = COM.AI$MAX.PAUSE
IF NOT(TMP1) THEN TMP1 = 300
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE,LCK.STAT); * lock out the COM.AI file
IF LCK.STAT GE 900 THEN AI.STATUS = LCK.STAT
IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
UNTIL LCK.COM.AIP OR ELP GT TMP1 DO REPEAT
*
END; * OF LCK.COM.AI
*
** IF LCK.COM.AI THEN
*
!
*
* LOCK ITEM
*
DT = DATE(); TM = TIME(); ELP = ZERO
TMP1 = COM.AI$MAX.PAUSE
IF NOT(TMP1) THEN TMP1 = 300
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT); * lock out the COM.AIP file
IF LCK.STAT GE 900 THEN AI.STATUS = LCK.STAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
UNTIL LCK.COM.AIP OR ELP GT TMP1 DO REPEAT
*
*
IF LCK.COM.AIP THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
*
**IF LCK.COM.AI AND COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> EQ EMPTY THEN OVERWRITE.FLAG = TRUE
IF LCK.COM.AI THEN
TMP = DCOUNT(COM.AIP$COMM.PORT,VM)
OVERWRITE.FLAG = TRUE
FOR SEND.COMM.CN = ONE TO TMP
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> NE EMPTY THEN OVERWRITE.FLAG = FALSE
NEXT SEND.COMM.CN
END
*
END
*
!
*
UNTIL OVERWRITE.FLAG OR WRITEN.FLAG OR NOT(RETRY.CONT) DO
*
*
RETRY = RETRY + ONE
CURR.ELP = ((DATE() - PREV.DT) * 86400) + (TIME() - PREV.TM)
*
TEMP.MAX.PAUSE = COM.AI$MAX.PAUSE
* HH - THIS IS WHERE WE VARY THE TIME WE WILL WAIT BASED ON 5B OR 7B
** IF COM.AIP$MAX.PAUSE NE "" THEN TEMP.MAX.PAUSE = COM.AIP$MAX.PAUSE
*
IF (CURR.ELP LE TEMP.MAX.PAUSE AND COM.AI$UP.DN.STAT EQ AI.UP) AND SYSTEM(11) LE 3 THEN
*
PRINT @(6,23):RVB:("Handler Command attempt #":RETRY:" at time ":CURR.ELP) "L#73":RVE:
*
IF LCK.COM.AIP THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
LCK.COM.AIP = FALSE
END
*
* EXECUTE "SLEEP ":COM.AI$STD.PAUSE
* PRINT @(6,23):SPACE(73):
*
END ELSE
*
*
PREV.DT = DATE(); PREV.TM = TIME()
PRINT BELL:
*
IF COM.AI$UP.DN.STAT EQ AI.UP THEN
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command has not been sent -- wait longer? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
END ELSE RSP = "N"
*
IF RSP EQ "Y" THEN
RETRY.CONT = TRUE
PREV.DT = DATE(); PREV.TM = TIME()
END ELSE
*
PRINT BELL:
*
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command will be lost -- overwrite it? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
*
IF RSP EQ "Y" THEN
* Yes, overwrite item
*
OVW.TYPE = FIELD(COM.AIP.ID,"*",ONE)
OVW.CODE = FIELD(COM.AIP.ID,"*",TWO)
OVW.PORT = FIELD(COM.AIP.ID,"*",3)
OVW.DVC.CN = FIELD(COM.AIP.ID,"*",4)
IF NOT(NUM(OVW.DVC.CN)) THEN OVW.DVC.CN = ONE
IF OVW.DVC.CN LT ONE THEN OVW.DVC.CN = ONE
OVW.DVC.NEXT.FOUND = TRUE
FOR TMP = OVW.DVC.CN TO 10 UNTIL NOT(OVW.DVC.NEXT.FOUND)
OVW.ID = OVW.TYPE:"*":OVW.CODE:"*":OVW.PORT:"*":TMP
MATREAD COM.AIP FROM COM.FILE,OVW.ID THEN
* Loop to save old exceptions
MATWRITE COM.AIP ON AIL.FILE,OVW.ID:"@":DATE():"@":TIME()
DELETE COM.FILE,OVW.ID
PRINT @(6,23):CLL:BELL:RVB:("Handler Command over-ride delete for ":OVW.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
END ELSE OVW.DVC.NEXT.FOUND = FALSE
NEXT OVW
*
* write new command
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
RETRY.CONT = TRUE
WRITEN.FLAG = TRUE; OVERWRITE.FLAG = TRUE
PRINT @(6,23):CLL:BELL:RVB:("Handler Command over-ride placed for ":COM.AIP.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
*
END ELSE
*
* No, do not overwrite item
*
RETRY.CONT = FALSE
OVERWRITE.FLAG = FALSE
PRINT @(6,23):CLL:BELL:RVB:("Handler Command Request for ":COM.AIP.ID:" denied at ":CURR.ELP) "L#73":RVE:
*
END; * of Y/N to overwrite
*
*
END; * of do not continue to wait for prior command
*
!
*
END; * of more than six waits for the command
*
REPEAT
* for repeated attempts to send the command
*
!
*
IF (OVERWRITE.FLAG AND LCK.COM.AIP) THEN
*
*
*** LOOP
*** LCK.ITM = TRUE; LCK.RELS = FALSE
*** COM.AI.ID = "AI.TYPE.":AI.CODE
*** GOSUB READ.COM.AI
*** WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
*** *
*** IF LCK.STAT NE 999 THEN
** IF LCK.COM.AI THEN
*
LCK.ITM = TRUE; LCK.RELS = TRUE
IF COM.AI$FUNC.PORT NE EMPTY THEN
IF INDEX("#":AI.ON:"#":AI.OFF:"#":AI.UP:"#":AI.DN:"#","#":COM.AIP$COMM:"#",ONE) THEN
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
END ELSE NULL
INS PORT.KEY BEFORE COM.AI$FUNC.PORT<ONE,ONE>
END ELSE
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:PORT.KEY
END; * of locate else
END; * of on/off/up/dn
END ELSE
COM.AI$FUNC.PORT = PORT.KEY
END
*
LOOP WHILE LEN(COM.AI$FUNC.PORT) AND COM.AI$FUNC.PORT<ONE,ONE> EQ EMPTY DO
DEL COM.AI$FUNC.PORT<ONE,ONE>
REPEAT
IF LCK.COM.AI THEN
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
END
*
IF NOT(WRITEN.FLAG) THEN
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
WRITEN.FLAG = TRUE; *
PRINT @(6,23):RVB:"The Handler Command has been submitted." "L#73":RVE:
* EXECUTE "SLEEP ":COM.AI$STD.PAUSE
END; * of WRITEN
*
END; * of overwrite or lock flag
*
!
*
END; * OF AI.STATUS 11 AND LCK.COM.AI
*
IF LCK.COM.AI THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE)
LCK.COM.AI = FALSE
END
*
IF LCK.COM.AIP THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
LCK.COM.AIP = FALSE
END
*
~AI.INCL.WRITE.LOG~
*CODE.SEGMENT: AI.INCL.WRITE.LOG
* USED BY: AI.SUBR.WRITE.LOG
*          AI.HANDLER
*          AI.TALKER
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
SYS.LOCT = "AI.INCL.WRITE.LOG"
AIL.SEQ.ID = "AI.LOG*":AI.CODE
*
LOOP
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("COM",AIL.SEQ.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
*
***READ AIL.SEQ FROM COM.FILE,AIL.SEQ.ID ELSE AIL.SEQ = ZERO
READ AIL.CNTRL FROM COM.FILE,AIL.SEQ.ID ELSE
AIL.CNTRL<ONE> = ZERO
AIL.CNTRL<TWO> = 999
END
*
AIL.SEQ = AIL.CNTRL<ONE>
AIL.SEQ.MAX = AIL.CNTRL<TWO>
IF AIL.SEQ.MAX LT 10 THEN AIL.SEQ.MAX = 100
*
AIL.SEQ = AIL.SEQ + ONE
IF AIL.SEQ GT AIL.SEQ.MAX THEN AIL.SEQ = ONE
*
AIL.CNTRL<ONE> = AIL.SEQ
WRITE AIL.CNTRL ON COM.FILE,AIL.SEQ.ID
*
CALL SYS.ITM.RLS("COM",AIL.SEQ.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
*
!
*
AIL.ID = "AI*":AI.CODE:"*":("0000":AIL.SEQ) "R#4":"*LOG"
* COM.AIP$WKO.ID = AIL.NEXT.ID
IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
COM.AIP$LOG.TRAN.AIL = AIL.SEQ
AIL.NEXT.ID = AIL.SEQ
END
*
MAT AIL = MAT COM.AIP
*
* IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
* AIL$COMM.SRCE = AI.SRCE
* END
IF AIL$COMM.SRCE EQ EMPTY THEN AIL$COMM.SRCE = AIL$LOG.SRCE<ONE,ONE,ONE>
*
IF AIL$PORT EQ EMPTY THEN AIL$PORT = PORT
IF AIL$ACCT.ID EQ EMPTY THEN AIL$ACCT.ID = ACCT
IF AIL$COMM.SRCE EQ EMPTY THEN AIL$COMM.SRCE = AI.SRCE
*
INS COM.AIP.ID BEFORE AIL$LOG.PORT<ONE,ONE,ONE>
INS WHO BEFORE AIL$LOG.ACCT<ONE,ONE,ONE>
INS SYS.PROG BEFORE AIL$LOG.PROG<ONE,ONE,ONE>
INS AI.SRCE BEFORE AIL$LOG.SRCE<ONE,ONE,ONE>
INS LOG.REQUIRED BEFORE AIL$LOG.LOC<ONE,ONE,ONE>
*
COM.AIP$LOG.REQD = TRUE
*
MATWRITE AIL ON AIL.FILE,AIL.ID
*
~AI.INCL.WRITE.XPV~
*CODE.SEGMENT: AI.INCL.WRITE.XPV
* NODATA.CTR = ZERO; NOCALL.CTR = ZERO; OTHER.CTR = ZERO; OKCOLL.CTR = ZERO; UPLOADED.CTR = ZERO
* EMPEV.CTR = ZERO; DUMP.CTR = ZERO
* PREV.DVC.ID = EMPTY; TMP.ID = EMPTY
* AI.STATUS = ZERO; SEND.STATUS = ZERO; COLL.STATUS = ZERO
* VALID.CTR = ZERO; EVENT.CTR = ZERO
* ERROR.CTR = ZERO; ERROR.EVENT.CTR = ZERO
* COMM.CTR = ZERO
* OVER = EMPTY; OVER.SKIP = EMPTY
* AI.COS = EMPTY
*
*
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*
IF COM.AIP$END.UPL NE "z" THEN
*
MAT XPV = ""
* not last terminal
*
EVENT.NUMS =     COM.AIP$EVENT
EVENT.DUR =      COM.AIP$EVENT.DUR
DVC.ID =         COM.AIP$DVC.ID
COLL.STATUS =    COM.AIP$GROUP.RSLT
*9503*DGH** IF EVENT.NUMS = "" THEN COLL.STATUS = "0D"
*
* validate the terminal id
*
MATREAD AIX FROM AIX.FILE,DVC.ID THEN INVALID.DVC = 0 ELSE INVALID.DVC =1; MAT AIX = ""
IF COUNT(AIX$ACT.ID,VM) THEN TMP.ID = "MULT" ELSE TMP.ID = AIX$ACT.ID
* prepare next terminal id'
NEXT.DVC.ID = "XXXXXX"
*
*@@@**** MOVE ABOVE READ
IF DVC.ID EQ PREV.DVC.ID THEN
DUPE.CTR = DUPE.CTR + 1
END ELSE
*
**IF DVC.ID NE "XXXXXX" AND DVC.ID NE "000000" THEN
**PRINT CLB:DVC.ID:"#":PREV.DVC.ID:
PREV.DVC.ID = DVC.ID
**END
*
IF INVALID.DVC THEN
*
* Unknown Device Serial Number
*
XPV$ACT.ID = "000000"
XPV$ACC=     ""
XPV$ERROR = 1
*
END ELSE
*
*
* Validate Company
*
CO.PREFIX =  TMP.ID[1,1]
LOCATE CO.PREFIX IN AI.COS<1> BY "AR" SETTING LOC THEN
*
* Good Company
*
XPV$ACC = AI.COS<2,LOC>
*
END ELSE
*
* Bad Company Number
*
XPV$ACC = ""
XPV$ERROR = 2
*
END; * of locate
END; * of valid dvc
*
*950322*DGH*IF COLL.STATUS EQ "00" OR XPV$EVENT.NUMS NE "" THEN   *v
IF EVENT.NUMS NE "" THEN
*
IF COLL.STATUS NE "00" THEN ERREV.CTR = ERREV.CTR + 1
*950322*DGH*^
*
IF XPV$ERROR THEN
ERROR.CTR = ERROR.CTR + 1
ERROR.EVENT.CTR = ERROR.EVENT.CTR+(COUNT(EVENT.NUMS,VM)+1)
END ELSE
VALID.CTR = VALID.CTR + 1
EVENT.CTR = EVENT.CTR+(COUNT(EVENT.NUMS,VM)+1)
END
*
TRANS.NUM = COM.AIP$TRAN.SEQ
*
XPV.ID = DATE():"*":TRANS.NUM:"*":DVC.ID
XPV$AI.CODE =    AI.CODE
XPV$EVENT.NUMS = EVENT.NUMS
XPV$DUR    =     EVENT.DUR
XPV$ACCOUNT    = TMP.ID
XPV$GROUP      = GROUP
XPV(10)        = TIME()
*
MATWRITE XPV ON XPV.FILE,XPV.ID
*
*
END ELSE
EMPEV.CTR = EMPEV.CTR + 1
*950322*DGH*END ELSE   *v
END; * OF EVENT NUMS PRESENT
*
IF COLL.STATUS NE "00" THEN
*950322*DGH*^
*
*950322*DGH*IF COLL.STATUS = "0E" AND EVENT.NUMS = "" THEN NOCALL.CTR = NOCALL.CTR + 1   *v
*950322*DGH*IF COLL.STATUS = "0D" THEN NODATA.CTR = NODATA.CTR + 1
IF COLL.STATUS = "0E" THEN NOCALL.CTR = NOCALL.CTR + 1 ELSE
IF COLL.STATUS = "0D" THEN NODATA.CTR = NODATA.CTR + 1 ELSE
OTHER.CTR = OTHER.CTR + 1
END
END
*950322*DGH*^
*
END ELSE
OKCOLL.CTR = OKCOLL.CTR + 1
END; * of collection status not "00"
*
UPLOADED.CTR =   UPLOADED.CTR + 1
FIRST.SEND = FALSE
*
END; * of duplicate device
*
!
*
*950106*END ELSE OVER = TRUE; * Last terminal has been received
END ELSE
*
IF UPLOADED.CTR GT ZERO OR OVER.SKIP GT 2 THEN
OVER = TRUE
PRINT CLB:"Finished.":BELL:
END ELSE
OVER.SKIP = OVER.SKIP + ONE
PRINT CLB:"POC says we are finished.  Double checking.":BELL:
END
*
COMM.CTR = COMM.CTR + 1
*
END; * Last terminal has been received
*
*
END ELSE
PRINT CLB:"Trans error (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")!!!":BELL:
COMM.CTR = COMM.CTR + 1
END; * of transmission error
~AI.INCL.XCEL.COM.AIP~
*CODE.SEGMENT: AI.INCL.XCEL.COM.AIP
*
*
*
IF (AIX.ID:AI.TALK<ADDRESSABLE>:AI.TALK<PAY.PER.VIEW>:AI.TALK<IMPULSE.PPV>) NE EMPTY THEN
*
**LCK.TYPE = -8
**AI.SRCE = "A"
**HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
**READ AI.TYPES FROM COM.FILE,"AI.TYPE.":HEADEND ELSE AI.TYPES = "10":AM:"UNKNOWN"
**AI.CODE     = AI.TYPES<ONE>
***
**$INCLUDE IBP AI.INCL.LOAD.CODE
***
**COM.AIP.PORT = PORT
**LOOP WHILE LEN(COM.AIP.PORT) LT 3 DO COM.AIP.PORT = ZERO:COM.AIP.PORT REPEAT
**COM.AI.ID = "AI.TYPE.":AI.CODE
*
!
*
AI.DVC.NEXT.CN = 0
LOOP
AI.DVC.NEXT.CN = AI.DVC.NEXT.CN + ONE
*
*
SYS.LOCT = "XCEL"
COM.AIP.ID = "AI*":AI.CODE:"*":COM.AIP.PORT:"*":AI.DVC.NEXT.CN
LCK.ITM = TRUE; LCK.RELS = FALSE
LCK.FIL.ID = "COM"; LCK.ITM.ID = COM.AIP.ID
*
LOOP
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT DO REPEAT
** WHILE LCK.STAT AND ELP LT LCK.ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
*
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
FOR SEND.COMM.CN = ONE TO SEND.COMM.CN.MAX
*
COM.AI.FLAG = EMPTY
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE" AND COM.AIP$RVRS.FL
**COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AI.FLAG = ONE; SEND.STATUS = 605
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE" AND NOT(COM.AIP$RVRS.FL)
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
COM.AI.FLAG = TWO; SEND.STATUS = 609
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
**COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
COM.AI.FLAG = TWO; SEND.STATUS = 601
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = ZERO
COM.AIP$COMM.PORT = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AI.FLAG = ONE; SEND.STATUS = 602
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
* Should never happen
**COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AI.FLAG = ONE; SEND.STATUS = 603
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
COM.AI.FLAG = TWO; SEND.STATUS = 604
*
CASE TRUE
COM.AI.FLAG = TWO; SEND.STATUS = 606
*
END CASE
*
*
NEXT SEND.COMM.CN
*
*
*
IF COM.AIP$LOG.REQD THEN
LOG.REQUIRED = 76001
**OPEN "AIL" TO AIL.FILE ELSE PRINT CLB:"AIL file missing!"; INPUT RSP; STAT = 999; RETURN
**AIL.SEQ.ID = "AI.":AI.CODE:".STATUS.LOG"
**$INCLUDE IBP AI.LOG.WRITE
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.AIP.ID,AI.CODE,AI.SRCE,LOG.REQUIRED,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PRNT,STAT)
END
*
IF COM.AI.FLAG THEN
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
*
IF COM.AI.FLAG EQ ONE THEN
INS EMPTY BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS EMPTY BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
HANDLER.COMMAND = COM.AIP$COMM; OPT.COM = HANDLER.COMMAND
CALL AI.SUBR.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,LCK.RELS,SYS.PRNT,STAT)
COM.AI.FLAG = FALSE
END ELSE
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
*
**END ELSE
AI.DVC.NEXT.FOUND = TRUE
END ELSE
AI.DVC.NEXT.FOUND = FALSE
END; * of READ
*
*
IF LCK.COM.AIP THEN
LCK.FIL.ID = "COM"; LCK.ITM.ID = COM.AIP.ID
CALL SYS.ITM.RLS(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
**END
*
WHILE AI.DVC.NEXT.FOUND DO REPEAT
*
END; * of AIX.ID
*
~AI.INTFC.CHECK~
*CODE.SEGMENT: AI.INTFC.CHECK
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* * COM.AI.ERR.TEXT<-ONE> = "The AI Handler is ok."
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
DT = DATE(); TM = TIME()
IF ERR.DISP.ONLY THEN STATUS.CYCLE = ERR.DISP.ONLY
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
*   8640 86200     8641 01000  CURR DT/TM
*   8640 86000     8640 86200  FUNC DT/TM
*   ---- -----     ---- -----
*      0   200        1 85200-
*                 86400
*                 85200-
*                  1200
*
AI.CHK.ERR = EMPTY
*
BEGIN CASE
*
CASE COM.AI$ON.OFF.STAT EQ AI.ON
COM.AI.ON = TRUE
!
*
IF COM.AI$MAX.PAUSE + 4 * COM.AI$STD.PAUSE LE COM.AI.RUN.ELP THEN
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, AI hung for ":OCONV(COM.AI.RUN.ELP,"MTS"):" hours!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT EQ AI.UP THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* *COM.AI.ON = FALSE
* END
COM.AI.UP = FALSE
END ELSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.UP = TRUE
AI.CHK.ERR<-ONE> = ZERO
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and UP."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 3
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 191
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END CASE
*
END
*
!
*
CASE COM.AI$ON.OFF.STAT EQ AI.OFF
COM.AI.ON = FALSE
COM.AI.UP = FALSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
AI.CHK.ERR<-ONE> = 102
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and UP!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
AI.CHK.ERR<-ONE> = TWO
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
AI.CHK.ERR<-ONE> = 192
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
*
CASE TRUE
AI.CHK.ERR<-ONE> = 181
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither ON nor OFF!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$ON.OFF.STAT NE AI.OFF THEN COM.AI.ERR.FUNC<-ONE> = AI.OFF ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
BEGIN CASE
*
CASE COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, No (":COM.AI.RUN.ELP:") Acknowledgment!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
!
*
CASE COM.AI$ON.OFF.STAT NE COM.AI$ON.OFF
COM.AI.ON.OFF.ELP = ((DT - COM.AI$ON.OFF.DT) * 86400) + (TM - COM.AI$ON.OFF.TM)
IF COM.AI.ON.OFF.ELP GT COM.AI$MAX.PAUSE + 3 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 111
* COM.AI.ERR.TEXT<-ONE> = "Failure logging ":COM.AI$ON.OFF:"! (":COM.AI.ON.OFF.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* COM.AI.ERR.FUNC<-ONE> = COM.AI$ON.OFF
END ELSE
AI.CHK.ERR<-ONE> = 11
* COM.AI.ERR.TEXT<-ONE> = "The AI is logging ":COM.AI$ON.OFF:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$UP.DN.STAT NE COM.AI$UP.DN
COM.AI.UP.DN.ELP = ((DT - COM.AI$UP.DN.DT) * 86400) + (TM - COM.AI$UP.DN.TM)
IF COM.AI.UP.DN.ELP GT COM.AI$MAX.PAUSE + 2 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 121
* COM.AI.ERR.TEXT<-ONE> = "Failure going ":COM.AI$UP.DN:"! (":COM.AI.UP.DN.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* * COM.AI.ERR.FUNC<-ONE> = COM.AI$UP.DN
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END ELSE
AI.CHK.ERR<-ONE> = 12
* COM.AI.ERR.TEXT<-ONE> = "The AI is going ":COM.AI$UP.DN:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
READV OFF.FLAG FROM COM.FILE,"AI.OFF.":PORT.KEY,ONE ELSE
READV OFF.FLAG FROM COM.FILE,"AI.OFF.ALL",ONE ELSE OFF.FLAG = FALSE
END
*
IF OFF.FLAG THEN
WRITEV FALSE:AM:"Done ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS") ON COM.FILE,"AI.OFF.":PORT.KEY
AI.CHK.ERR<-ONE> = 131
* COM.AI.ERR.TEXT<-ONE> = "Interface Off Flag is set!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
** IF AI.CHK.ERR NE EMPTY THEN
** *
** TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
** *
** LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
** COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
** LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
** COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
** COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
** TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
** IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE
** COM.AI.ERR.FUNC<-ONE> = TMP
** END
** DEL AI.CHK.ERR<ONE>
** REPEAT
** *
** END; * of AI.CHK.ERR ne empty
*
!
*
*
*  IF NOT(LEN(COM.AI.ERR)) THEN
*
CHECK.FMT = "L#":CHECK.LEN
*
*
EXEC.IN = EMPTY; EXEC.OUT = EMPTY; EXEC.VERB = EMPTY
*
IF (FAST.DISPLAY OR PORTS.LIST.BUILD OR AI.RESET) AND AI.SCAN THEN
*
EXEC.VERB = 'SSELECT COM EQ "AI*]" BY COMM.DT BY COMM.TM'
*
IF COM.AI.ERR.DISP THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Selecting Active Ports" CHECK.FMT:RVE
END
*
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > COM.ID.LIST, //OUT. > EXEC.OUT
*
* REV ONLY
* PERFORM EXEC.VERB
*
END ELSE
*
COM.ID.LIST = COM.AI$FUNC.PORT
IF COM.ID.LIST EQ EMPTY THEN COM.ID.LIST = PORTS.LIST
*
END; * of fast disp
*
IF COM.AI.ERR.DISP THEN
*
CHECK.LN = CHECK.LN.MIN
*
IF (FAST.DISPLAY OR PORTS.LIST.BUILD) AND AI.SCAN THEN
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT EXEC.VERB CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF LEN(EXEC.OUT) THEN
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE> CHECK.FMT; CHECK.LN = CHECK.LN + ONE
DEL EXEC.OUT<ONE>
REPEAT
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
END
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END; * of fast disp
*
IF CHECK.LN.HI GT CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT
NEXT TMP
END
*
CHECK.LN.HI = CHECK.LN; CHECK.LN = CHECK.LN.MIN
*
* EXECUTE "SLEEP 1"
*
END; * OF COM.AI.ERR.DISP
*
*
COM.AI.PORT.REC = EMPTY
COM.AIP.PORT.FIRST = TRUE; PORT.CONT = TRUE
* PORTS.LIST = EMPTY
*
LOOP
*
IF (FAST.DISPLAY OR PORTS.LIST.BUILD) AND AI.SCAN THEN
*
* ULT ONLY
READNEXT COM.ID FROM COM.ID.LIST ELSE COM.ID = "@@@"
*
* REV ONLY
* READNEXT COM.ID ELSE COM.ID = "@@@"
*
COM.AIP.ID = COM.ID
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
*
*
END ELSE
*
IF COM.ID.LIST EQ EMPTY THEN COM.ID = "@@@" ELSE
COM.ID = "AI*":AI.CODE:"*":COM.ID.LIST<ONE,ONE>
COM.AIP.ID = COM.ID
COM.AIP.PORT = COM.ID.LIST<ONE,ONE>
DEL COM.ID.LIST<ONE,ONE>
LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
IF COM.AI.ERR.DISP THEN PRINT BELL:
END
END
*
END; * of fast disp
*
WHILE COM.ID NE "@@@" DO
*
** ** ** IF COM.AIP.ID MATCHES '"AI*"3N"*"3N' THEN
IF FIELD(COM.AIP.ID,"*",ONE) EQ "AI" AND FIELD(COM.AIP.ID,"*",TWO) EQ AI.CODE AND NUM(FIELD(COM.AIP.ID,"*",3)) THEN
*
IF AI.SCAN THEN
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
UNTIL NOT(LCK.STAT) DO REPEAT
LCK.COM.AIP = TRUE
END ELSE LCK.COM.AIP = FALSE
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
COM.AIP.ON.FILE = TRUE
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
* READ COM.AI.COMMANDS FROM COM.FILE,"AI.COMMANDS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE COM.AI.COMMANDS = EMPTY
*
IF CNT.TST$ID THEN PRINT @(60,20):"Cnt Aip ":COM.AIP.ID "L#18":
*
*@@@ BUILD PORT RECORD
*
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
TMP = FALSE
IF (FAST.DISPLAY OR PORTS.LIST.BUILD) AND AI.SCAN THEN
TMP = TRUE
END
IF COM.AIP$COMM.PORT NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN TMP = TRUE
IF ((COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND COM.AIP.ELP LT 300) THEN TMP = TRUE
IF TMP THEN
*
IF PORT.CONT THEN
*
IF COM.AI.ERR.DISP THEN
*
IF COM.AIP.PORT.FIRST OR CHECK.LN GE CHECK.LN.MAX THEN
COM.AIP.PORT.FIRST = FALSE
IF SYSTEM(11) LT 3 THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Oper. Po Typ Stat A/I Dvc. Fnc" CHECK.FMT:RVE:
END
END
*
*
IF CHECK.LN GE CHECK.LN.MAX THEN
CHECK.LN = CHECK.LN.MIN
IF STATUS.CYCLE THEN
IF SYSTEM(11) LT 3 THEN
EXECUTE "SLEEP 3"
END
RSP = "Y"
END ELSE
LOOP
PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(ZERO,23):" " CHECK.FMT:
IF RSP EQ EMPTY THEN PORT.CONT = FALSE ELSE ALREADY.DISPLAYED = TRUE
END; * OF STATUS CYCLE
END; * OF CHECK.LN GE CHECK.LN.MAX
*
END; * OF COM.AI.ERR.DISP
*
!
*
IF PORT.CONT THEN
*
IF COM.AI.ERR.DISP THEN
IF SYSTEM(11) LT 3 THEN
TMP = COM.AIP$OPER "R#5":" ":FIELD(COM.AIP.ID,"*",3) "R#2":" ":COM.AIP$COMM "R#3":" ":COM.AIP$INTFC.STAT<ONE,ONE> "L#4":" ":COM.AIP$INTFC.CODE "L#2":COM.AIP$INTFC.TYPE "L#1":" ":COM.AIP$DVC.TYPE "L#4":" ":COM.AIP$SVC.FUNC "L#3"
PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
END
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
*
!
*
IF COM.AIP$INTFC.ERR<ONE> NE EMPTY THEN
*
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE NULL
END
*
*
TMP1 = ""; VC.CN.MAX = DCOUNT(COM.AIP$INTFC.ERR<ONE>,VM)
*
FOR VC.CN = ONE TO VC.CN.MAX UNTIL CHECK.LN GE CHECK.LN.MAX OR SYSTEM(11) GE 3
*
SVC.CN = ZERO
*
LOOP
*
SVC.CN = SVC.CN + ONE
TMP1 = COM.AIP$INTFC.ERR<ONE,VC.CN,SVC.CN>
* TMP1 = COM.AIP$ERR<ONE,VC.CN,ONE>
*
WHILE TMP1 NE EMPTY AND CHECK.LN LT CHECK.LN.MAX DO
*
LOCATE TMP1 IN COM.AIIERR$STD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
*
TMP = ("[":TMP1:"]") "R#5":" ":COM.AIIERR$DESC<ONE,ERR.LOC> "L#17":" (":COM.AIIERR$TYPE<ONE,ERR.LOC>:")"
*
* COM.AI.ERR<-ONE> = COM.AIIERR$STD<ONE,ERR.LOC>
COM.AI.ERR<-ONE> = TMP1
COM.AI.ERR.TEXT<-ONE> = "Port ":FIELD(COM.AIP.ID,"*",3):" ":COM.AIIERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIIERR$TYPE<ONE,ERR.LOC>
TMP4 = COM.AIIERR$FUNC<ONE,ERR.LOC>
IF TMP4 EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP4 EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP4
END
* DEL AI.CHK.ERR<ONE>
*
IF COM.AI.ERR.DISP THEN
IF SYSTEM(11) LT 3 THEN
PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
END
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
*
** for locate END ELSE NULL
*
REPEAT
*
NEXT VC.CN
*
END; * OF ERR NOT EMPTY
*
END; * OF PORT.CONT
*
END; * OF PORT.CONT AND ERR.DISP
*
*
IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN
*
IF COM.AIP.ELP GT 5 * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
*
IF AI.SCAN THEN
*
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE,LCK.STAT)
*
IF NOT(LCK.STAT) THEN
*
* AI.CHK.ERR<-ONE> = 371
* COM.AI.ERR<-ONE> = 371
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "DONE"
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "WAIT"
COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "RVRS"
COM.AIP$COMM.PORT = "RVRS"
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "COMP"
* Should never happen
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "XCEL"
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE TRUE
*
END CASE
*
IF LEN(AI.CHK.ERR) THEN
AI.CHK.ERR = 371:AM:AI.CHK.ERR
END ELSE AI.CHK.ERR = 371
*
* COM.AI.ERR.TEXT<-ONE> = "Failure at (@COM.AIP.ELP@) Port @COM.AIP.PORT@ @COM.AIP$INTFC.STAT<ONE,ONE>@!"
*
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AIP$ERR = "800":SVM:COM.AIP$ERR
COM.AIP$INTFC.ERR = "371":SVM:COM.AIP$INTFC.ERR
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LCK.FILE,LCK.TYPE)
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE)
*
END; * OF LCK.STAT
*
END ; * OF AI.SCAN
*
END; * OF ELP
*
END ELSE IF COM.AIP.ELP GT 7200 AND COM.AIP$INTFC.STAT<ONE,ONE> NE "RVRS" THEN
*
IF LCK.COM.AIP AND AI.SCAN THEN
IF CNT.TST$ID THEN PRINT @(60,20):"Delete Aip ":COM.AIP.ID "L#18":
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LCK.FILE,LCK.TYPE)
DELETE COM.FILE,COM.AIP.ID
END
*
END; * OF NO C.DT OR C.TM
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST<ONE> SETTING TMP ELSE
PORTS.LIST<ONE,-ONE> = COM.AIP.PORT
END
*
END; * OF NO C.DT OR C.TM
*
*
END ELSE
* NOT ON FILE
COM.AIP.ON.FILE = FALSE
MAT COM.AIP = EMPTY
END
*
** ** ** IF AI.SCAN AND NOT(LCK.STAT) THEN
* * * IF AI.SCAN AND NOT(LCK.COM.AIP) THEN
IF LCK.COM.AIP THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
LCK.COM.AIP = FALSE
END
*
END; * OF MATCHES AI*XX*999
*
REPEAT
*
IF COM.AI.ERR.DISP THEN
IF CHECK.LN.HI GT CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT:
NEXT TMP
CHECK.LN.HI = CHECK.LN
END
END
*
*  END; * OF NOT(COM.AI.ERR)
*
PORTS.LIST.BUILD = FALSE
*
*
*** $INCLUDE IBP AI.HERROR.XREF
*CODE.SEGMENT: AI.HERROR.XREF
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
* COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP
END
DEL AI.CHK.ERR<ONE>
REPEAT
*
END; * of AI.CHK.ERR ne empty
*
!
*
IF COM.AI.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(COM.AI.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
*
LOCATE COM.AI.ERR<TMP.CN> IN COM.AIHERR$STD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
* COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
*
*
* TMP2 = COM.AIHERR$DESC<ONE,ERR.LOC>
*
TMP2 = COM.AI.ERR.TEXT<TMP.CN>
*
LOOP WHILE INDEX(TMP2,"@",ONE) DO
TMP = FIELD(TMP2,"@",ONE)
TMP0 = FIELD(TMP2,"@",TWO)
TMP1 = FIELD(TMP2,"@",3)
TMP1 = TMP2[COL1()+ONE,9999]
TMP.VAR = EMPTY
BEGIN CASE
CASE TMP0 EQ "COM.AI.RUN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
* 999.9 Hours
CASE TMP0 EQ "COM.AI$ON.OFF"
TMP.VAR = COM.AI$ON.OFF
CASE TMP0 EQ "COM.AI.ON.OFF.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AI$UP.DN"
TMP.VAR = COM.AI$UP.DN
CASE TMP0 EQ "COM.AI.UP.DN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.PORT"
TMP.VAR = COM.AIP.PORT
CASE TMP0 EQ "COM.AIP$INTFC.STAT<ONE,ONE>"
TMP.VAR = COM.AIP$INTFC.STAT<ONE,ONE>
CASE TMP0 EQ "AI.STATUS"
TMP.VAR = AI.STATUS
CASE TMP0 EQ "SEND.STATUS"
TMP.VAR = SEND.STATUS
END CASE
TMP2 = TMP:TMP.VAR:TMP1
REPEAT
*
COM.AI.ERR.TEXT<TMP.CN> = TMP2
*
* COM.AI.ERR.TYPE<TMP.CN> = COM.AIHERR$TYPE<ONE,ERR.LOC>
* TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
TMP = COM.AI.ERR.TYPE<TMP.CN>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE
* COM.AI.ERR.FUNC<TMP.CN> = TMP
COM.AI.ERR.FUNC<TMP.CN> = COM.AIHERR$FUNC<ONE,ERR.LOC>
END
*
* DEL AI.CHK.ERR<ONE>
*
REPEAT
*
END
*
*
*** @@@
~AI.INTFC.CHECK.QUIET~
*CODE.SEGMENT: AI.INTFC.CHECK
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* * COM.AI.ERR.TEXT<-ONE> = "The AI Handler is ok."
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
DT = DATE(); TM = TIME()
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
*   8640 86200     8641 01000  CURR DT/TM
*   8640 86000     8640 86200  FUNC DT/TM
*   ---- -----     ---- -----
*      0   200        1 85200-
*                 86400
*                 85200-
*                  1200
*
AI.CHK.ERR = EMPTY
*
BEGIN CASE
*
CASE COM.AI$ON.OFF.STAT EQ AI.ON
COM.AI.ON = TRUE
!
*
IF COM.AI$MAX.PAUSE + 4 * COM.AI$STD.PAUSE LE COM.AI.RUN.ELP THEN
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, AI hung for ":OCONV(COM.AI.RUN.ELP,"MTS"):" hours!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT EQ AI.UP THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* *COM.AI.ON = FALSE
* END
COM.AI.UP = FALSE
END ELSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.UP = TRUE
AI.CHK.ERR<-ONE> = ZERO
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and UP."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 3
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 191
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END CASE
*
END
*
!
*
CASE COM.AI$ON.OFF.STAT EQ AI.OFF
COM.AI.ON = FALSE
COM.AI.UP = FALSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
AI.CHK.ERR<-ONE> = 102
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and UP!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
AI.CHK.ERR<-ONE> = TWO
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
AI.CHK.ERR<-ONE> = 192
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
*
CASE TRUE
AI.CHK.ERR<-ONE> = 181
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither ON nor OFF!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$ON.OFF.STAT NE AI.OFF THEN COM.AI.ERR.FUNC<-ONE> = AI.OFF ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
BEGIN CASE
*
CASE COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, No (":COM.AI.RUN.ELP:") Acknowledgment!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
!
*
CASE COM.AI$ON.OFF.STAT NE COM.AI$ON.OFF
COM.AI.ON.OFF.ELP = ((DT - COM.AI$ON.OFF.DT) * 86400) + (TM - COM.AI$ON.OFF.TM)
IF COM.AI.ON.OFF.ELP GT COM.AI$MAX.PAUSE + 3 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 111
* COM.AI.ERR.TEXT<-ONE> = "Failure logging ":COM.AI$ON.OFF:"! (":COM.AI.ON.OFF.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* COM.AI.ERR.FUNC<-ONE> = COM.AI$ON.OFF
END ELSE
AI.CHK.ERR<-ONE> = 11
* COM.AI.ERR.TEXT<-ONE> = "The AI is logging ":COM.AI$ON.OFF:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$UP.DN.STAT NE COM.AI$UP.DN
COM.AI.UP.DN.ELP = ((DT - COM.AI$UP.DN.DT) * 86400) + (TM - COM.AI$UP.DN.TM)
IF COM.AI.UP.DN.ELP GT COM.AI$MAX.PAUSE + 2 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 121
* COM.AI.ERR.TEXT<-ONE> = "Failure going ":COM.AI$UP.DN:"! (":COM.AI.UP.DN.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* * COM.AI.ERR.FUNC<-ONE> = COM.AI$UP.DN
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END ELSE
AI.CHK.ERR<-ONE> = 12
* COM.AI.ERR.TEXT<-ONE> = "The AI is going ":COM.AI$UP.DN:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
TMP = "AI.OFF.":PORT.KEY
READV OFF.FLAG FROM COM.FILE,TMP,ONE ELSE
TMP = "AI.OFF.ALL"
READV OFF.FLAG FROM COM.FILE,TMP,ONE ELSE OFF.FLAG = FALSE
END
*
IF OFF.FLAG THEN
WRITEV "Done ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS") ON COM.FILE,TMP,TWO
AI.CHK.ERR<-ONE> = 131
* COM.AI.ERR.TEXT<-ONE> = "Interface Off Flag is set!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
** IF AI.CHK.ERR NE EMPTY THEN
** *
** TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
** *
** LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
** COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
** LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
** COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
** COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
** TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
** IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
** COM.AI.ERR.FUNC<-ONE> = EMPTY
** END ELSE
** COM.AI.ERR.FUNC<-ONE> = TMP
** END
** DEL AI.CHK.ERR<ONE>
** REPEAT
** *
** END; * of AI.CHK.ERR ne empty
*
!
*
*
*  IF NOT(LEN(COM.AI.ERR)) THEN
*
CHECK.FMT = "L#":CHECK.LEN
*
*
EXEC.IN = EMPTY; EXEC.OUT = EMPTY; EXEC.VERB = EMPTY
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
EXEC.VERB = 'SSELECT COM EQ "AI*]" BY COMM.DT BY COMM.TM'
*
IF COM.AI.ERR.DISP THEN
** QUIET ** PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Selecting Active Ports" CHECK.FMT:RVE
END
*
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > COM.ID.LIST, //OUT. > EXEC.OUT
*
* REV ONLY
* PERFORM EXEC.VERB
*
END ELSE
*
COM.ID.LIST = COM.AI$FUNC.PORT
IF COM.ID.LIST EQ EMPTY THEN COM.ID.LIST = PORTS.LIST
*
END; * of fast disp
*
IF COM.AI.ERR.DISP THEN
*
CHECK.LN = CHECK.LN.MIN
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
** QUIET ** PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
** QUIET ** PRINT EXEC.VERB CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF LEN(EXEC.OUT) THEN
LOOP WHILE LEN(EXEC.OUT) DO
** QUIET ** PRINT EXEC.OUT<ONE> CHECK.FMT; CHECK.LN = CHECK.LN + ONE
DEL EXEC.OUT<ONE>
REPEAT
** QUIET ** PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
** QUIET ** PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
END; * of fast disp
*
IF CHECK.LN.HI GT CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
** QUIET ** PRINT @(ZERO,TMP):" " CHECK.FMT
NEXT TMP
END
*
CHECK.LN.HI = CHECK.LN; CHECK.LN = CHECK.LN.MIN
*
EXECUTE "SLEEP 1"
*
END; * cnt.ai.err.disp
*
*
COM.AI.PORT.REC = EMPTY
COM.AIP.PORT.FIRST = TRUE; PORT.CONT = TRUE
* PORTS.LIST = EMPTY
*
LOOP
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
* ULT ONLY
READNEXT COM.ID FROM COM.ID.LIST ELSE COM.ID = "@@@"
*
* REV ONLY
* READNEXT COM.ID ELSE COM.ID = "@@@"
*
COM.AIP.ID = COM.ID
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
*
*
END ELSE
*
IF COM.ID.LIST EQ EMPTY THEN COM.ID = "@@@" ELSE
COM.ID = "AI*":AI.CODE:"*":COM.ID.LIST<ONE,ONE>
COM.AIP.ID = COM.ID
COM.AIP.PORT = COM.ID.LIST<ONE,ONE>
DEL COM.ID.LIST<ONE,ONE>
LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
** QUIET ** IF COM.AI.ERR.DISP THEN PRINT BELL:
END
END
*
END; * of fast disp
*
WHILE COM.ID NE "@@@" DO
*
** ** ** IF COM.AIP.ID MATCHES '"AI*"3N"*"3N' THEN
IF FIELD(COM.AIP.ID,"*",ONE) EQ "AI" AND FIELD(COM.AIP.ID,"*",TWO) EQ AI.CODE AND NUM(FIELD(COM.AIP.ID,"*",3)) THEN
*
IF AI.SCAN THEN
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
UNTIL NOT(LCK.STAT) DO REPEAT
LCK.COM.AIP = TRUE
END ELSE LCK.COM.AIP = FALSE
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
COM.AIP.ON.FILE = TRUE
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
* READ COM.AI.COMMANDS FROM COM.FILE,"AI.COMMANDS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE COM.AI.COMMANDS = EMPTY
*
IF CNT.TST$ID THEN PRINT @(60,20):"Cnt Aip ":COM.AIP.ID "L#18":
*
*@@@ BUILD PORT RECORD
*
TMP = FALSE
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN TMP = TRUE
IF COM.AIP$COMM.PORT NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN TMP = TRUE
IF ((COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND ((((DT - COM.AIP$COMM.C.DT) * 86400) + (TM - COM.AIP$COMM.C.TM)) LT 300)) THEN TMP = TRUE
IF TMP THEN
*
IF PORT.CONT AND COM.AI.ERR.DISP THEN
*
IF COM.AIP.PORT.FIRST OR CHECK.LN GE CHECK.LN.MAX THEN
COM.AIP.PORT.FIRST = FALSE
IF SYSTEM(11) LT 3 THEN
** QUIET ** PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Oper. Po Typ Stat A/I Dvc. Fnc" CHECK.FMT:RVE:
END
END
*
*
IF CHECK.LN GE CHECK.LN.MAX THEN
CHECK.LN = CHECK.LN.MIN
IF STATUS.CYCLE THEN
IF SYSTEM(11) LT 3 THEN
EXECUTE "SLEEP 3"
END
RSP = "Y"
END ELSE
LOOP
** QUIET ** PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
** QUIET ** PRINT @(ZERO,23):" " CHECK.FMT:
IF RSP EQ EMPTY THEN PORT.CONT = FALSE ELSE ALREADY.DISPLAYED = TRUE
END; * OF STATUS CYCLE
END; * OF CHECK.LN GT CHECK.LN.MAX
*
!
*
IF PORT.CONT THEN
*
IF SYSTEM(11) LT 3 THEN
TMP = COM.AIP$OPER "R#5":" ":FIELD(COM.AIP.ID,"*",3) "R#2":" ":COM.AIP$COMM "R#3":" ":COM.AIP$INTFC.STAT<ONE,ONE> "L#4":" ":COM.AIP$INTFC.CODE "L#2":COM.AIP$INTFC.TYPE "L#1":" ":COM.AIP$DVC.TYPE "L#4":" ":COM.AIP$SVC.FUNC "L#3"
** QUIET ** PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
END
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
*
!
*
IF COM.AIP$ERR<ONE,ONE,ONE> NE EMPTY THEN
*
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE NULL
END
*
*
TMP1 = ""; TMP.CN = ZERO
*
LOOP
*
TMP.CN = TMP.CN + ONE
TMP1 = COM.AIP$INTFC.ERR<ONE,ONE,TMP.CN>
*
WHILE TMP1 NE EMPTY DO
*
LOCATE TMP1 IN COM.AIIERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
*
TMP = ("[":TMP1:"]") "R#5":" ":COM.AIIERR$DESC<ONE,ERR.LOC> "L#17":" (":COM.AIIERR$TYPE<ONE,ERR.LOC>:")"
*
COM.AI.ERR<-ONE> = COM.AIIERR$STD<ONE,ERR.LOC>
COM.AI.ERR.TEXT<-ONE> = "Port ":FIELD(COM.AIP.ID,"*",3):" ":COM.AIIERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIIERR$TYPE<ONE,ERR.LOC>
TMP4 = COM.AIIERR$FUNC<ONE,ERR.LOC>
IF TMP4 EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP4 EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP4
END
* DEL AI.CHK.ERR<ONE>
*
IF SYSTEM(11) LT 3 THEN
** QUIET ** PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
END
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
*
** for locate END ELSE NULL
*
REPEAT
*
END; * OF ERR NOT EMPTY
*
END; * OF PORT.CONT
*
END; * OF PORT.CONT AND ERR.DISP
*
*
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
*
IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN
*
IF COM.AIP.ELP GT 5 * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
*
IF AI.SCAN THEN
*
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE,LCK.STAT)
*
IF NOT(LCK.STAT) THEN
*
* AI.CHK.ERR<-ONE> = 371
* COM.AI.ERR<-ONE> = 371
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "DONE"
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "WAIT"
COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "RVRS"
COM.AIP$COMM.PORT = "RVRS"
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "COMP"
* Should never happen
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "XCEL"
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE TRUE
*
END CASE
*
IF LEN(AI.CHK.ERR) THEN
AI.CHK.ERR = 371:AM:AI.CHK.ERR
END ELSE AI.CHK.ERR = 371
*
* COM.AI.ERR.TEXT<-ONE> = "Failure at (@COM.AIP.ELP@) Port @COM.AIP.PORT@ @COM.AIP$INTFC.STAT<ONE,ONE>@!"
*
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AIP$ERR = "371":VM:COM.AIP$ERR
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LCK.FILE,LCK.TYPE)
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE)
*
END; * OF LCK.STAT
*
END ; * OF AI.SCAN
*
END; * OF ELP
END; * OF NO C.DT OR C.TM
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST<ONE> SETTING TMP ELSE
PORTS.LIST<ONE,-ONE> = COM.AIP.PORT
END
*
END; * OF NO C.DT OR C.TM
*
*
END ELSE
* NOT ON FILE
COM.AIP.ON.FILE = FALSE
MAT COM.AIP = EMPTY
END
*
** ** ** IF AI.SCAN AND NOT(LCK.STAT) THEN
* * * IF AI.SCAN AND NOT(LCK.COM.AIP) THEN
IF LCK.COM.AIP THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
END
*
END; * OF MATCHES AI*XX*999
*
REPEAT
*
IF COM.AI.ERR.DISP THEN
IF CHECK.LN.HI GE CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
*** 24APR94 ** PRINT @(ZERO,TMP):" " CHECK.FMT:
NEXT TMP
CHECK.LN.HI = CHECK.LN
END
END
*
*  END; * OF NOT(COM.AI.ERR)
*
PORTS.LIST.BUILD = FALSE
*
*
*** $INCLUDE IBP AI.HERROR.XREF
*CODE.SEGMENT: AI.HERROR.XREF
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
* COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP
END
DEL AI.CHK.ERR<ONE>
REPEAT
*
END; * of AI.CHK.ERR ne empty
*
!
*
IF COM.AI.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(COM.AI.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
*
LOCATE COM.AI.ERR<TMP.CN> IN COM.AIHERR$STD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
* COM.AI.ERR<-ONE> = COM.AIHERR$STD<ONE,ERR.LOC>
*
*
* TMP2 = COM.AIHERR$DESC<ONE,ERR.LOC>
*
TMP2 = COM.AI.ERR.TEXT<TMP.CN>
*
LOOP WHILE INDEX(TMP2,"@",ONE) DO
TMP = FIELD(TMP2,"@",ONE)
TMP0 = FIELD(TMP2,"@",TWO)
TMP1 = FIELD(TMP2,"@",3)
TMP1 = TMP2[COL1()+ONE,9999]
TMP.VAR = EMPTY
BEGIN CASE
CASE TMP0 EQ "COM.AI.RUN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
* 999.9 Hours
CASE TMP0 EQ "COM.AI$ON.OFF"
TMP.VAR = COM.AI$ON.OFF
CASE TMP0 EQ "COM.AI.ON.OFF.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AI$UP.DN"
TMP.VAR = COM.AI$UP.DN
CASE TMP0 EQ "COM.AI.UP.DN.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.ELP"
TMP.VAR = INT(COM.AI.RUN.ELP / 60 / 60 * 100) / 100
CASE TMP0 EQ "COM.AIP.PORT"
TMP.VAR = COM.AIP.PORT
CASE TMP0 EQ "COM.AIP$INTFC.STAT<ONE,ONE>"
TMP.VAR = COM.AIP$INTFC.STAT<ONE,ONE>
END CASE
TMP2 = TMP:TMP.VAR:TMP1
REPEAT
*
COM.AI.ERR.TEXT<TMP.CN> = TMP2
*
* COM.AI.ERR.TYPE<TMP.CN> = COM.AIHERR$TYPE<ONE,ERR.LOC>
* TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
TMP = COM.AI.ERR.TYPE<TMP.CN>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<TMP.CN> = EMPTY
END ELSE
* COM.AI.ERR.FUNC<TMP.CN> = TMP
COM.AI.ERR.FUNC<TMP.CN> = COM.AIHERR$FUNC<ONE,ERR.LOC>
END
*
* DEL AI.CHK.ERR<ONE>
*
REPEAT
*
END
*
*
*** @@@
~AI.INTFC.DISPLAY~
*CODE.SEGMENT: AI.INTFC.DISPLAY
* VERSION: 940201 1.1  HEADEND TO AI.CODE, COM.AI$PORT TO COM.AI$COMMPORT.
* USED BY: AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS
*   1990        ALL RIGHTS RESERVED
*
!
*
GOSUB DISPLAY.TITLE
*
PRINT @(ZERO,3):CLL:RVB:"   Handler Status":RVE:" ":
IF COM.AI$ON.OFF.STAT NE "ON" THEN PRINT "OFF": ELSE PRINT "ON":
IF COM.AI$UP.DN.STAT NE "UP"  THEN PRINT " DOWN": ELSE PRINT " UP":
*
*
** 23APR94 ** OPER.LN = 3; OPER.CL = 31; OPER.DESC.LN = 3; OPER.DESC.CL = 49
** 23APR94 ** OPER.DESC.FMT = "L#15"; OPER.STAT = EMPTY; OPER.DISP = TRUE
** 23APR94 ** OPER.RVB = TRUE; OPER.TEXT = "Operator: "
** 23APR94 ** OPER.POSN = EMPTY
** 23APR94 ** LN = 9
OPER.DISP = TRUE
CALL INPUT.OPERATOR(OPER,OPER.POSN,OPER.LN,OPER.CL,OPER.TEXT,OPER.DESC.LN,OPER.DESC.CL,OPER.DESC.FMT,OPER.RVB,RUN.TYPE,OPER.DISP,OPER.STAT)
** 23APR94 ** IF OPER.STAT THEN CHAIN "FREEZE.PORT"
*
!
*
PRINT @(ZERO,4):CLL:RVB:"        Test Flag":RVE:" ":COM.AI$TEST.MODE:
PRINT @(31,4):RVB:"Handler Logging and Error Messages" "L#48":RVE:
*
PRINT @(ZERO,5):CLL:RVB:"  Command Logging":RVE:" ":
IF COM.AI$LOGGING EQ "Y" THEN PRINT "ON": ELSE PRINT "OFF":
*
PRINT @(ZERO,6):CLL:RVB:"      Port Number":RVE:" ":COM.AI$COMMPORT
*
!
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK
*
IF PORTS.LIST NE PORTS.LIST.PREV THEN
*COM.AI$FUNC.PORT<ONE,-ONE> = PORTS.LIST
PORTS.LIST.PREV = PORTS.LIST
END
*
!
*
IF LEN(COM.AI.ERR.TEXT) THEN
PRINT @(ZERO,7):CLL:RVB:COM.AI.ERR.TEXT<ONE> "L#30":RVE:
END
IF ERR.BELL AND LEN(COM.AI.ERR) AND (COM.AI.ERR.FUNC<ONE> NE OLD.FUNC<ONE> AND COM.AI.ERR.FUNC NE EMPTY) THEN PRINT BELL:; RQM
*
PRINT @(35,10):RVB:" He*Ch# Srvc. Description..... Last.Change ST       " "L#45":RVE:
LN = 10; VC = ONE
*
LOOP
*
MLE.NUM = STL<STATUS.CHANNEL,VC>
MLE.HE = FIELD(MLE.NUM,"*",ONE)
IF MLE.HE NE HEADEND THEN
HEADEND = MLE.HE
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE NULL
END
*
UNTIL MLE.NUM EQ EMPTY DO
*
REASON = STL<STATUS.CHAN.STAT,VC>
*
IF LEN(REASON) OR CHAN.ALL THEN
*
LN = LN + ONE
*
IF LN GT 20 THEN
PRINT @(ZERO,LN):CLL:
IF STATUS.CYCLE THEN
LN = 11
RQM; RQM
END ELSE
LOOP
PRINT @(35,23):CLL: "Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(35,23):CLL:
IF RSP EQ EMPTY THEN RETURN ELSE LN = 11; ALREADY.DISPLAYED = TRUE
END
END; * of pg
*
* SDATE = OCONV(FIELD(STL<STATUS.DESC,VC>,"*",ONE),"D2")
* STIME = OCONV(FIELD(STL<STATUS.DESC,VC>,"*",TWO),"MT")
SDESC = STL<STATUS.DESC,VC>
RDATE = OCONV(FIELD(STL<STATUS.CHECKED,VC>,"*",ONE),"D2")
*TMP = INDEX(RDATE," ",TWO)
*IF TMP THEN RDATE = RDATE[ONE,TMP - ONE]
RDATE = FIELD(RDATE," ",ONE):FIELD(RDATE," ",TWO)
RTIME = OCONV(FIELD(STL<STATUS.CHECKED,VC>,"*",TWO),"MTH")
RDT = RDATE:" ":RTIME
SSRVC = STL<STATUS.SRVC,VC>
*
IF LEN(REASON) THEN
PRINT @(35,LN):(" ":MLE.NUM "L#6":" ":SSRVC "L#5":" ":SDESC "L#17":" ":RDT "L#11":" ":REASON "L#2") "L#44":
LOCATE REASON IN AI.ERRORS<ONE> BY "AR" SETTING LOC THEN
REASON = AI.ERRORS<3,LOC>
LN = LN + ONE
PRINT @(35,LN):CLL:RVB:(SPACE(12):REASON) "L#44":RVE:
END
END ELSE
PRINT @(35,LN):(" ":MLE.NUM "L#6":" ":SSRVC "L#5":" ":SDESC "L#17":" ":RDT "L#11":" ":REASON "L#2") "L#44":
END; * of reason
*
END; * of reason or all flag
*
VC = VC + ONE
*
REPEAT
*
IF ALREADY.DISPLAYED THEN
LOOP
LN = LN + ONE
UNTIL LN GT 22 DO
PRINT @(35,LN):CLL:
REPEAT
ALREADY.DISPLAYED = EMPTY
END
*
*
~AI.INTFC.MESSAGES~
*CODE.SEGMENT: AI.INTFC.MESSAGES
* USED BY: AI.CONTROL.UTILITY
*          AI.TALKER
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
!
*
IF LEN(COM.AI.ERR.TEXT) THEN
*
COM.AI.ERR.CN.MAX = DCOUNT(COM.AI.ERR,AM)
COM.AI.ERR.CN = ONE; TMP = FALSE
LOOP WHILE COM.AI.ERR.CN LE COM.AI.ERR.CN.MAX DO
TMP = COM.AI.ERR<COM.AI.ERR.CN>
IF NUM(TMP) THEN
IF TMP THEN
TEXT<-ONE> = "[":COM.AI.ERR.TYPE<COM.AI.ERR.CN>:" ":("000":TMP) "R#3":"] ":COM.AI.ERR.TEXT<COM.AI.ERR.CN>
IF (TMP NE 71 AND TMP GT AI.STATUS) AND TMP LT 300 THEN AI.STATUS = TMP
IF TMP NE 71 AND TMP GT SEND.STATUS THEN SEND.STATUS = TMP
END
END ELSE TMP = TRUE
IF NOT(TMP) THEN TEXT<-ONE> = COM.AI.ERR.TEXT<COM.AI.ERR.CN>
* DEL COM.AI.ERR<ONE>
* DEL COM.AI.ERR.TEXT<ONE>
COM.AI.ERR.CN = COM.AI.ERR.CN + ONE
REPEAT
*
END
*
~AI.INTFC.READ~
*CODE.SEGMENT: AI.INTFC.READ
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
SYS.LOCT = "AI.INTFC.READ"
*
READ.COM.AI: *
*
COM.ID = "AI.TYPE.":AI.CODE
COM.AI.ID = COM.ID
LCK.STAT = FALSE
*
IF LCK.ITM THEN
LOOP
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
IF LCK.STAT EQ 999 THEN STAT = LCK.STAT
IF LCK.STAT THEN RETURN
LCK.COM.AI = TRUE
END ELSE LCK.STAT = FALSE
*
MATREAD COM.AI FROM COM.FILE,COM.ID THEN COM.ID.ON.FILE = TRUE ELSE COM.ID.ON.FILE = FALSE; STAT = 998; MAT COM.AI = ""; GOTO READ.COM.AI.UNLOCK
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = AI.CODE
LOCATE AI.CODE IN AI.TYPES<ONE> SETTING AI.CODE.LOC ELSE AI.CODE.LOC = ONE
HEADENDS = AI.TYPES<4,AI.CODE.LOC>
*
HEADEND = HEADENDS<ONE,ONE,ONE>
HE.CN.MAX = DCOUNT(HEADENDS,SVM)
*
STL.ID = "AI.STATUS.CH.":AI.CODE
READ STL FROM COM.FILE,STL.ID ELSE STL = ""
*
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = ""
*
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE AI.ERRORS = ""
*
FOR HE.CN = ONE TO HE.CN.MAX
HEADEND = HEADENDS<ONE,ONE,HE.CN>
READ COMPONENTS FROM COM.FILE,"COMPONENTS.":HEADEND ELSE COMPONENTS = EMPTY
CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PROG,STAT)
STL<STATUS.FLAGGED> = ""; TMP = 1
MVC = 1
LOOP MLE.NUM = CHANNEL.MLES<1,MVC> UNTIL MLE.NUM EQ "" DO
TMP = HEADEND:"*":MLE.NUM
LOCATE TMP IN STL<STATUS.CHANNEL> BY "AR" SETTING LOC ELSE
INS TMP BEFORE STL<STATUS.CHANNEL,LOC>
INS "" BEFORE STL<STATUS.CHAN.STAT,LOC>
INS "" BEFORE STL<STATUS.DESC,LOC>
INS "" BEFORE STL<STATUS.CHECKED,LOC>
INS "" BEFORE STL<STATUS.SRVC,LOC>
INS "" BEFORE STL<STATUS.FLAGGED,LOC>
END
STL<STATUS.DESC,LOC> = CHANNEL.MLES<2,MVC>
STL<STATUS.SRVC,LOC> = CHANNEL.MLES<3,MVC>
STL<STATUS.FLAGGED,LOC> = 1; * ?????
MVC = MVC + 1
REPEAT
ST.VC = 1
LOOP UNTIL STL<STATUS.CHANNEL,ST.VC> EQ "" DO
IF STL<STATUS.FLAGGED,ST.VC> THEN ST.VC = ST.VC + 1 ELSE
DEL STL<STATUS.CHANNEL,ST.VC>
DEL STL<STATUS.CHAN.STAT,ST.VC>
DEL STL<STATUS.DESC,ST.VC>
DEL STL<STATUS.CHECKED,ST.VC>
DEL STL<STATUS.SRVC,ST.VC>
DEL STL<STATUS.FLAGGED,ST.VC>
END
REPEAT
DEL STL<STATUS.FLAGGED>
NEXT HE.CN
*
READ.COM.AI.UNLOCK: *
IF LCK.RELS THEN
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
~AI.INTFC.STL~
*CODE.SEGMENT: AI.INTFC.STL
* VERSION: 940130 1.1  Changed refs of 'COMMPORT' and 'HEADEND' to 'AI.CODE', HEADENDS now in AI.TYPES.
* DESCRIPTION: LOAD CHANNEL STATUSES FOR THE AI.TYPE.
* USED BY: AI.HANDLER
*          AI.CHANNEL.UP
*          AI.CHANNEL.DN
*          AI.CONTROL.UTILITY
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
*
SYS.LOCT = "AI.INTFC.STL"
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = AI.CODE
LOCATE AI.CODE IN AI.TYPES<1> SETTING COMMPORT.LOC ELSE COMMPORT.LOC = ONE
HEADENDS = AI.TYPES<4,COMMPORT.LOC>
CHANNEL.MLES = EMPTY; STL.ID = "AI.STATUS.CH.":AI.CODE
*
*22MAR94*IF COMPONENTS.DFLT EQ EMPTY THEN
READ COMPONENTS.DFLT FROM COM.FILE,"COMPONENTS" ELSE NULL
*22MAR94*END
*
HE.CN.MAX = DCOUNT(HEADENDS,SVM)
*
IF LCK.ITM THEN
LOOP
CALL SYS.ITM.LCK("COM",STL.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
END ELSE LCK.STAT = FALSE
*
READ STL FROM COM.FILE,STL.ID ELSE STL = EMPTY
*
* READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
READ AI.ERRORS FROM COM.FILE,"AI.CH.ERRORS.":AI.CODE ELSE AI.ERRORS = EMPTY
*
STL<STATUS.FLAGGED> = EMPTY; TMP = ONE; WRITE.FLAG = FALSE
SAVE.HEADEND = HEADEND
*
FOR HE.CN = ONE TO HE.CN.MAX
*
**IF HEADENDS<ONE,ONE,HE.CN> NE HEADEND THEN
READ COMPONENTS FROM COM.FILE,"COMPONENTS.":HEADENDS<ONE,ONE,HE.CN> ELSE COMPONENTS = EMPTY
**END
*
HEADEND = HEADENDS<ONE,ONE,HE.CN>
*
CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PROG,STAT)
*
MVC = ONE
LOOP MLE.NUM = CHANNEL.MLES<ONE,MVC> UNTIL MLE.NUM EQ EMPTY DO
*
MLE.NUM = ("000":MLE.NUM) "R#3"; TMP = HEADEND:"*":MLE.NUM
LOCATE TMP IN STL<STATUS.CHANNEL> BY "AL" SETTING STL.LOC ELSE
INS TMP BEFORE STL<STATUS.CHANNEL,STL.LOC>
INS EMPTY BEFORE STL<STATUS.CHAN.STAT,STL.LOC>
INS CHANNEL.MLES<TWO,MVC> BEFORE STL<STATUS.DESC,STL.LOC>
INS EMPTY BEFORE STL<STATUS.CHECKED,STL.LOC>
INS CHANNEL.MLES<3,MVC> BEFORE STL<STATUS.SRVC,STL.LOC>
INS EMPTY BEFORE STL<STATUS.FLAGGED,STL.LOC>
WRITE.FLAG = TRUE
END
*
IF STL<STATUS.DESC,STL.LOC> EQ EMPTY THEN
LOCATE STL<STATUS.SRVC,STL.LOC> IN COMPONENTS.DFLT<ONE> SETTING TMP.LOC THEN
STL<STATUS.DESC,STL.LOC> = COMPONENTS.DFLT<TWO,TMP.LOC>
WRITE.FLAG = TRUE
END ELSE NULL
END
*
STL<STATUS.FLAGGED,STL.LOC> = ONE
MVC = MVC + ONE
*
REPEAT
*
NEXT HE.CN
*
HEADEND = SAVE.HEADEND
COMPONENTS = COMPONENTS.DFLT
*
!
*
ST.VC = ONE
*
LOOP UNTIL STL<STATUS.CHANNEL,ST.VC> EQ EMPTY DO
IF STL<STATUS.FLAGGED,ST.VC> THEN ST.VC = ST.VC + ONE ELSE
DEL STL<STATUS.CHANNEL,ST.VC>
DEL STL<STATUS.CHAN.STAT,ST.VC>
DEL STL<STATUS.DESC,ST.VC>
DEL STL<STATUS.CHECKED,ST.VC>
DEL STL<STATUS.SRVC,ST.VC>
DEL STL<STATUS.FLAGGED,ST.VC>
WRITE.FLAG = TRUE
END
REPEAT
*
DEL STL<STATUS.FLAGGED>
*
*
IF WRITE.FLAG AND LCK.ITM AND NOT(LCK.STAT) THEN
WRITE STL ON COM.FILE,STL.ID
END
*
IF LCK.ITM AND LCK.RELS THEN
CALL SYS.ITM.RLS("COM",STL.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
END
*
*
~AI.INTFC.WAITFOR.COMMAND~
X*CODE.SEGMENT: AI.INTFC.WAITFOR.COMMAND
* VERSION: 940130 1.1  COM.AI.ID CHANGED.
* USED BY: AI.TALKER
*          AI.CONTROL.UTILITY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: NOV 90
*
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*   1990        ALL RIGHTS RESERVED
*
!
*
IF DISP.ONLY THEN RETURN
*
***NUM.TRIES = ZERO; MAX.PAUSE = 120; STD.PAUSE = 5
NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = COM.AI$MAX.PAUSE; STD.PAUSE = COM.AI$STD.PAUSE
***NUM.TRIES = ZERO; MAX.TRIES = 5; MAX.PAUSE = 30; STD.PAUSE = ONE
IF NOT(MAX.PAUSE) THEN MAX.PAUSE = 30
IF NOT(STD.PAUSE) THEN STD.PAUSE = ONE
WF.DT = DATE(); WF.TM = TIME()
* WF.C.LOC = HANDLER.COMMAND<ONE,ONE> (FUNC OR COMMAND) ( NOT USED )
* STAT = 0;  WF.C.FUNC = PORT NUMBER
COM.AI.ON.FILE = FALSE; HANDLER.DONE = FALSE
COM.AI.ID = "AI.TYPE.":AI.CODE; COM.ID = COM.AI.ID
*
LOOP
*
EXEC.VERB = "SLEEP ":STD.PAUSE
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:EXEC.VERB "L#19":RVE:
IF NOT(SYSTEM(11)) THEN
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
END
*
*@*LOOP
*
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE,LCK.STAT)
IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
IF HANDLER.ELP GT MAX.PAUSE + COM.AIP$MAX.PAUSE THEN
TEXT<-ONE> = "Can't wait longer than ":MAX.PAUSE + COM.AIP$MAX.PAUSE:" seconds."
AI.STATUS = 201
* COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
* COM.AIP$COMM.PORT = EMPTY
END
*
*@*WHILE (LCK.STAT AND LCK.STAT LT 900) AND AI.STATUS NE 201 DO REPEAT
*
*
* IF NOT(LCK.STAT) THEN
*@*IF LCK.COM.AI THEN
* IF AI.STATUS NE 201 THEN
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN
COM.AI.ON.FILE = TRUE
IF COM.AI$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AI$MAX.PAUSE
STD.PAUSE = COM.AI$STD.PAUSE
END ELSE
COM.AI.ON.FILE = FALSE; STAT = 998; MAT COM.AI = EMPTY
END
*
LOOP WHILE LEN(COM.AI$FUNC.PORT) AND COM.AI$FUNC.PORT<ONE,ONE> EQ EMPTY DO
DEL COM.AI$FUNC.PORT<ONE,ONE>
REPEAT
*
LOCATE WF.C.FUNC IN COM.AI$FUNC.PORT<ONE> SETTING COM.AI.LOC THEN
*
HANDLER.DONE = FALSE
*
IF AI.STATUS EQ 201 THEN
IF LCK.COM.AI THEN
DEL COM.AI$FUNC.PORT<ONE,COM.AI.LOC>
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
END
END
*
IF COM.AI.LOC GT ONE THEN
WF.DT = DATE(); WF.TM = TIME()
END
*
*@*IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Comm. Not Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,TWO):RVB:"Comm. Not Done" "L#19":RVE:
*
END ELSE
*
HANDLER.DONE = TRUE
COM.AI.LOC = ONE
*@*IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Comm. Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,TWO):RVB:"Comm. Done" "L#19":RVE:
*
END
*
PORT.LOC = COM.AI.LOC
*
IF LCK.COM.AI THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE)
LCK.COM.AI = FALSE
END
*
* END ELSE
* HANDLER.DONE = FALSE
* END
*
UNTIL AI.STATUS EQ 201 OR HANDLER.DONE OR SYSTEM(11) GT 3 DO
*
* PRINT @(0,20):CLL:@(0,21):CLL:@(20,21):
PRINT @(0,23):CLL:@(15,23):
TMP = REM(NUM.TRIES,TWO)
IF NOT(TMP) THEN PRINT RVB:
PRINT "waiting on the handler . . . ":
HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
IF NOT(TMP) THEN PRINT RVE: ELSE PRINT RVB:
*@*PRINT @(46,23):(" [":COM.AIP$COMM.PORT:"]") "L#8":(" (":MAX.PAUSE - HANDLER.ELP:")") "L#10":RVE:@(ZERO,ONE):
PRINT @(46,23):(" [":COM.AIP$COMM.PORT:"]") "L#8":(" (":MAX.PAUSE + COM.AIP$MAX.PAUSE - HANDLER.ELP:",":COM.AI.LOC:")") "L#10":RVE:@(ZERO,ONE):
*
* TMP = REM(NUM.TRIES,3)
TMP = FALSE
IF NOT(TMP) THEN
IF FAST.DISPLAY OR COM.AI.ERR.DISP THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
*** LCK.ITM = TRUE; LCK.RELS = TRUE
*** GOSUB READ.COM.AI
GOSUB INTFC.CHECK
GOSUB INTFC.MESSAGES
IF LEN(OUTPUTS) THEN TEXT = OUTPUTS:AM:TEXT
ERR.DISP.ONLY = TWO
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE
END
END
*
*#*LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
*
** HANDLER.ELP = ((DATE() - WF.DT) * 86400) + (TIME() - WF.TM)
** IF HANDLER.ELP GT MAX.PAUSE + COM.AIP$MAX.PAUSE THEN
** TEXT<-ONE> = "Can't wait longer than ":MAX.PAUSE + COM.AIP$MAX.PAUSE:" seconds."
** AI.STATUS = 201
** * COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
** * COM.AIP$COMM.PORT = EMPTY
** END
*#*UNTIL NOT(LCK.STAT) DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
*#*IF LCK.COM.AIP THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT = EMPTY
*
IF LCK.COM.AIP THEN
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
IF COM.AIP$RETRY LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY
*
IF COM.AI.LOC GT ONE THEN
WF.DT = DATE(); WF.TM = TIME()
COM.AIP$COMM.DT = WF.DT; COM.AIP$COMM.TM = WF.TM
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
*
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
LCK.COM.AIP = FALSE
*
END; * OF LOCKED
*
*
NUM.TRIES = NUM.TRIES + ONE
*
REPEAT
*
PRINT @(20,23):CLL:
LOCATE WF.C.FUNC IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
HANDLER.DONE = FALSE
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Comm. Not Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,TWO):RVB:"Comm. Not Done" "L#19":RVE:
END ELSE
HANDLER.DONE = TRUE
PORT.LOC = ONE
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Comm. Done" "L#19":RVE:
IF COM.AI.ERR.DISP THEN PRINT @(60,TWO):RVB:"Comm. Done" "L#19":RVE:
END
*
IF NOT(STAT) AND LCK.STAT GT 900 THEN STAT = LCK.STAT
IF STAT THEN
IF STAT GT AI.STATUS THEN AI.STATUS = STAT
TEXT<-ONE> = "Status ":STAT:" error in wait routine."
END
*
*#*LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
*#*UNTIL NOT(LCK.STAT) DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
IF LCK.STAT GT 900 AND NOT(STAT) THEN STAT = LCK.STAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT = EMPTY
*
* IF COM.AIP$MAX.PAUSE GT MAX.PAUSE THEN MAX.PAUSE = COM.AIP$MAX.PAUSE
IF COM.AIP$RETRY LT MAX.TRIES THEN MAX.TRIES = COM.AIP$RETRY
*
IF LCK.COM.AIP THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
LCK.COM.AIP = FALSE
END
*
IF NOT(AI.STATUS) THEN
IF COM.AIP$ERR<ONE,ONE,ONE> LT 299 THEN
AI.STATUS = COM.AIP$ERR<ONE,ONE,ONE>
IF AI.STATUS = ERR$NOT.SENT THEN AI.STATUS = FALSE
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
END
END
*
* IF NOT(SEND.STATUS) THEN
** IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> THEN
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> NE EMPTY THEN
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> LT 800 OR COM.AIP$INTFC.ERR<ONE,ONE,ONE> GT 899 THEN
SEND.STATUS = COM.AIP$INTFC.ERR<ONE,ONE,ONE>
IF SEND.STATUS = ERR$NOT.SENT THEN SEND.STATUS = FALSE
WF.DT = COM.AIP$COMM.DT; WF.TM = COM.AIP$COMM.TM
END
END
* END
*
IF LEN(TEXT) AND (SEND.STATUS OR AI.STATUS OR NOT(ERR.CLB)) THEN GOSUB ERROR
*
~AI.LOAD.CNT.AIP~
*CODE.SEGMENT: AI.LOAD.COM.AIP
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
!
*
COM.AIP.PORT = PORT.KEY
*
LOCATE COM.AIP.PORT IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:COM.AIP.PORT
END
*
!
*
* COM.AIP$SVC.ID      = AIX$SVC.ID
* COM.AIP$TIERS       = AIX$TIERS
* COM.AIP$TSTAT       = AIX$TSTAT
COM.AIP$SVC.CHAN    = "?"
IF OPT.COMM<ONE> EQ "OPDVC" THEN
COM.AIP$SVC.FUNC = WOF
COM.AIP$DVC.TYPE = AIX$TYPE
END ELSE
COM.AIP$SVC.FUNC = "SYS"
COM.AIP$DVC.TYPE = "AI"
END
*
COM.AIP$HE.PORT     = COM.AI$COMMPORT
COM.AIP$OPER        = WKO$OPERATOR
COM.AIP$COMM        = OPT.COMM<ONE>
COM.AIP$ACCT.ID     = WKO$ACT.ID
COM.AIP$ADD.ID      = WKO$ADD.ID
COM.AIP$DVC.ID      = AIX$DVC.ID
COM.AIP$AIX.ID      = AIX.ID
COM.AIP$AIX.LOCATION = ADD$AIX.LOCATION 
IF NOT(COM.AIP$AIX.LOCATION) THEN COM.AIP$AIX.LOCATION = ONE
*
COM.AIP$WKO.ID      = WKO.ID
COM.AIP$WKO.TYPE    = WKO$TYPE
COM.AIP$WKO.STAT    = WKO$STAT
COM.AIP$WKO.SCHED   = WKO$SCH.DATE
COM.AIP$WKO.INST    = WKO$INSTALLER
* WKO$SCH.TIME
* WKO$SCH.TYPE
*
COM.AIP$INTFC.CODE  = COM.AI$DB.PREFIX
COM.AIP$INTFC.TYPE  = COM.AI$TYPE
COM.AIP$INTFC.STAT  = "WAIT":VM:COM.AIP$INTFC.STAT
*
COM.AIP$COMM.DT     = OPT.DT
COM.AIP$COMM.TM     = OPT.TM
COM.AIP$COMM.C.DT   = OPT.DT
COM.AIP$COMM.C.TM   = OPT.TM
COM.AIP$COMM.PORT   = PORT.KEY
COM.AIP$PORT        = PORT.KEY
*
COM.AIP$HEX.COMM    = EMPTY
COM.AIP$HEX.RSLT    = EMPTY
COM.AIP$COMM.RSLT   = EMPTY
COM.AIP$ERR         = EMPTY
COM.AIP$GROUP       = AIX$INSTALLED.ADD.ID
COM.AIP$GROUP.RSLT  = EMPTY
*
*COM.AIP$LOG.DISPL = FALSE
*COM.AIP$LOG.PRINT = FALSE
*COM.AIP$LOG.ACK.DISP = FALSE
*COM.AIP$LOG.ACK.BRMNGR = FALSE
COM.AIP$LOG.REQD   = LOG.REQUIRED
COM.AIP$LOG.SRCE   = AI.SRCE
*
~AI.LOAD.CNT.AIP.TIERS~
*CODE.SEGMENT: AI.LOAD.COM.AIP.TIERS
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
*
* FILE 'COM.AIP' EQUATES
*
*  Note that this algorythm assumes that a omitted service will autom-
*     matically be turned off if not sent
*
*  Also note that (BASIC) is not properly provided for as a special case
*
*
!
*
AIX.RESET = FALSE; IF WKO.ID EQ EMPTY THEN AIX.RESET = TRUE
MAT COM.AIP = EMPTY
*
IF OPT.COMM<ONE> EQ "OPDVC" THEN
*
* Locate the device type to load # of addrs/unit & # of tiers/addr
LOCATE AIX$TYPE IN COM.AI$DVC.UNIT SETTING DVC.LOC ELSE DVC.LOC = ONE
*
COM.AIP$SVC.ID.FUTR = EMPTY
* Set the current service levels on the port control record
COM.AIP$SVC.ID      = AIX$SVC.ID
COM.AIP$TIERS       = AIX$TIERS
COM.AIP$TSTAT       = AIX$TSTAT
COM.AIP$TINDEX      = EMPTY
ACT.SVC.CN.MAX = DCOUNT(ACT$SERVICES,VM)
AIX.LOC = ADD$AIX.LOCATION
IF NOT(AIX.LOC) THEN AIX.LOC = ONE
*
* This loop happens # of addr/unit times (1 or 8)
*       note the # of Connected OUTlets is ignored on the AIP rec.
* Services are subvalued within this location
*   they are in alphabetical order.
FOR AIX.VC = ONE TO COM.AI$ADDR.PER.UNIT<ONE,DVC.LOC>
*
COM.AIP$SVC.ID.FUTR<ONE,AIX.VC> = AIX$SVC.ID<ONE,AIX.VC>
COM.AIP$TIERS.FUTR<ONE,AIX.VC>   = AIX$TIERS<ONE,AIX.VC>
COM.AIP$TSTAT.FUTR<ONE,AIX.VC>   = AIX$TIERS<ONE,AIX.VC>
*
IF AIX.VC EQ AIX.LOC THEN
*
AIX.SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID.FUTR<ONE,AIX.VC>,SVM)
*
FOR SVC.CN = ONE TO AIX.SVC.CN.MAX
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,SVC.CN> = ZERO
NEXT SVC.CN
*
FOR SVC.CN = ONE TO ACT.SVC.CN.MAX
* The service from the act is located in cnt.aip and added if missing
TMP = ACT$SERVICES<ONE,SVC.CN>
LOCATE TMP IN COM.AIP$SVC.ID.FUTR<ONE,AIX.VC> SETTING AIX.SC ELSE
INS TMP BEFORE COM.AIP$SVC.ID.FUTR<ONE,AIX.VC,AIX.SC>
INS "0" BEFORE COM.AIP$TIERS.FUTR<ONE,AIX.VC,AIX.SC>
INS "0" BEFORE COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC>
AIX.SVC.CN.MAX = AIX.SVC.CN.MAX + ONE
END
* The tier is unknown and is set below
* The tier status is on if the qnty is not zero
IF ACT$QNTYS<ONE,SVC.CN> THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ONE
END
*
NEXT SVC.CN
*
END
*
NEXT AIX.VC
*
* Do not remove this code, it is for future use. These variables can be
*  used to validate tier #'s.
* IF AI.TALK<OP.MULTI> THEN
* AIX.CN.MIN = (AIX.LOC - ONE) * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC> + ONE
* AIX.CN.MAX = AIX.CN.MIN - ONE  + COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* END ELSE
* AIX.CN.MIN = ONE
* AIX.CN.MAX = COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* END
*
* AIX.TIER.HI = COM.AI$ADDR.PER.UNIT<ONE,DVC.LOC> * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* (LOC - 1) * TIERS.PER.UNIT + TIER
*
* Load the default settings (note that in future these sub-values
*  should be multivalued by being tied directly to the device type).
IF AI.TALK<OP.MULTI> THEN
COM.AI.DF.SVCS = COM.AI$DF.SVCS.EIGHT
COM.AI.DF.TIER = COM.AI$DF.TIER.EIGHT
COM.AI.DF.XREF = COM.AI$DF.XREF.EIGHT
END ELSE
COM.AI.DF.SVCS = COM.AI$DF.SVCS.ONE
COM.AI.DF.TIER = COM.AI$DF.TIER.ONE
COM.AI.DF.XREF = COM.AI$DF.XREF.ONE
END
*
* Loop through the future services setting tier number
AIX.SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID.FUTR<ONE,AIX.LOC>,SVM)
FOR AIX.CN = ONE TO AIX.SVC.CN.MAX
*
SVC.ID = COM.AIP$SVC.ID.FUTR<ONE,AIX.LOC,AIX.CN>
*
* The AIX service tier location is used first
LOCATE SVC.ID IN AIX$SVC.ID<ONE,AIX.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = AIX$TIERS<ONE,AIX.LOC,SVC.LOC>
END ELSE
*
* Otherwise the default service tier location is used
*LOCATE SVC.ID IN COM.AI$DFLTS<ONE,DVC.LOC> SETTING SVC.LOC THEN
*COM.AI.TIER = COM.AI$DF.TIER<ONE,DVC.LOC,SVC.LOC>
LOCATE SVC.ID IN COM.AI.DF.SVCS<ONE,ONE> SETTING SVC.LOC THEN
COM.AI.TIER = COM.AI.DF.TIER<ONE,ONE,SVC.LOC>
COM.AI.TIER = (AIX.LOC - ONE) * COM.AI$TIERS.PER.UNIT<ONE,DVC.LOC> + COM.AI.TIER
END ELSE
*
* Otherwise the location of (BASIC) will be used
*   this would normally be the wrong thing to do but would test
*   wether the device works
LOCATE "(BASIC)" IN AIX$SVC.ID<ONE,AIX.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = AIX$TIERS<ONE,AIX.LOC,SVC.LOC>
END ELSE
*
* we can't turn on an unknown tier number
SVC.LOC = ZERO
COM.AI.TIER = ZERO
END
*
END
*
END
*
* Only turn on known tiers
IF COM.AI.TIER THEN
*
*
* This is the provision for indexed or labelled tiers
* COM.AI$INDEXED
*
* X - Service name is sent to device.
* R - Use then relative (numbered) location as the tier number.
* N - Use the tier number off of the AIX as the tier (spiggot) number.
* Y - Use the ONE/EIGHT default svcs as an index.
*
IF COM.AI$INDEXED EQ "N" THEN
*
* This is the normal condition (used by Eagle)
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = COM.AI.TIER
*
END ELSE IF COM.AI$INDEXED EQ "X" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = SVC.ID
*
END ELSE IF COM.AI$INDEXED EQ "Y" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = COM.AI.DF.XREF<ONE,COM.AI.TIER>
*
END ELSE IF COM.AI$INDEXED EQ "R" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = AIX.CN
*
END; * of indexing
*
END; * of tier found
*
NEXT AIX.CN
*
END; * of OPDVC
*
* End of tier processing
*
~AI.LOAD.COM.AIP~
*CODE.SEGMENT: AI.LOAD.COM.AIP
* VERSION: 940221 1.1  NEXT.AI.TRAN CHANGED TO NEXT.AIL.TRAN
* PRIOR: 940219 1.1  ADDED TEST OF AI.TALK NE "", RE WKOs and DVCs.
* USED BY: AI.TALKER
*          DOWNLOAD.PPV.EVENTS.PA
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT AXION COMPUTER SYSTEMS LTD
*   1990       ALL RIGHTS RESERVED
*
!
*
COM.AIP.PORT = PORT.KEY
*
LOCATE COM.AIP.PORT IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
IF COM.AI$FUNC.PORT NE EMPTY THEN COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:COM.AIP.PORT
END
COM.AIP$RETRY         = EMPTY
COM.AIP$MAX.PAUSE     = EMPTY
*
!
*
* COM.AIP$SVC.ID      = DVC$SERVICE
* COM.AIP$TIERS       = DVC$TIERS
* COM.AIP$TSTAT       = DVC$TSTAT
COM.AIP$SVC.CHAN      = "?"
*
TMP = OPT.COMM<ONE,ONE>[ONE,TWO]
IF INDEX("#AI#PV#IV#","#":TMP:"#",ONE) THEN
*
COM.AIP$SVC.FUNC      = WOF
COM.AIP$DVC.TYPE      = DVC$TYPE
COM.AIP$GROUP         = DVC$INSTALLED.ADD.ID
COM.AIP$HEADEND       = HEADEND
COM.AIP$OPER          = WKO$OPERATOR
IF COM.AIP$OPER EQ EMPTY THEN COM.AIP$OPER = OPER
*
COM.AIP$ACCT.ID       = WKO$ACT.ID
COM.AIP$ADD.ID        = WKO$ADD.ID
COM.AIP$DVC.ID        = AIX.ID
*@*IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = AI.TALK<ADDRESSABLE>
IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>>
IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = DVC.ID
IF COM.AIP$DVC.ID EQ EMPTY THEN COM.AIP$DVC.ID = DVC$SERIAL.NUM
COM.AIP$AIX.ID        = AIX.ID
COM.AIP$AIX.LOCATION  = ADD$AIX.LOCATION 
IF NOT(COM.AIP$AIX.LOCATION) THEN COM.AIP$AIX.LOCATION = ONE
*
COM.AIP$WKO.ID        = WKO.ID
* IF COM.AIP$WKO.ID EQ EMPTY THEN COM.AIP$WKO.ID = AIL.NEXT.ID 
COM.AIP$WKO.TYPE      = WKO$TYPE
COM.AIP$WKO.STAT      = WKO$STAT
COM.AIP$WKO.SCH.DT    = WKO$SCH.DATE
COM.AIP$WKO.SCH.TM    = WKO$SCH.TIME
COM.AIP$WKO.SCH.TYPE  = WKO$SCH.TYPE
COM.AIP$WKO.INST      = WKO$INSTALLER
COM.AIP$WKO.FUNC      = WOF
*
END ELSE
COM.AIP$SVC.FUNC       = "SYS"
COM.AIP$DVC.TYPE       = ""
COM.AIP$HEADEND        = "ALL"
COM.AIP$GROUP           = EMPTY
COM.AIP$OPER          = OPER
END; * of not AIDVC
*
* COM.AIP$INTFC.CODE  = COM.AI$DB.PREFIX
COM.AIP$INTFC.TYPE    = COM.AI$TYPE
COM.AIP$CTLR.PORT     = COM.AI$CTLR.PORT
COM.AIP$RVRS.FL       = AI.TALK<RVRS.FL>
*
*
COM.AIP$COMM          = OPT.COMM
TMP = DCOUNT(COM.AIP$COMM,VM)
IF NOT(TMP) THEN TMP = ONE
*
* INS "WAIT" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
* INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>
FOR SEND.COMM.CN.TMP = ONE TO TMP
INS "WAIT" BEFORE     COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN.TMP,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN.TMP,ONE>
INS ZERO     BEFORE COM.AIP$COMM.CN<ONE,SEND.COMM.CN.TMP,ONE>
INS ZERO     BEFORE COM.AIP$RETRY<ONE,SEND.COMM.CN.TMP,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN.TMP,ONE> = OPT.COMM<ONE,SEND.COMM.CN.TMP,ONE>
COM.AIP$COMM.CN<ONE,SEND.COMM.CN.TMP,ONE> = ZERO
NEXT SEND.COMM.CN.TMP
*
*
COM.AIP$COMM.DT       = OPT.DT
COM.AIP$COMM.TM       = OPT.TM
COM.AIP$COMM.C.DT     = EMPTY
COM.AIP$COMM.C.TM     = EMPTY
COM.AIP$COMM.PORT     = OPT.COMM<ONE,ONE>
**COM.AIP$COMM.CN       = ZERO
COM.AIP$PORT          = PORT.KEY
*
COM.AIP$HEX.COMM      = EMPTY
COM.AIP$HEX.RSLT      = EMPTY
COM.AIP$COMM.RSLT     = EMPTY
COM.AIP$ERR           = EMPTY
COM.AIP$GROUP.RSLT    = EMPTY
*
* COM.AIP$LOG.DISPL     = FALSE
* COM.AIP$LOG.PRINT     = FALSE
* COM.AIP$LOG.ACK.DISP  = FALSE
* COM.AIP$LOG.ACK.BRMNGR = FALSE
COM.AIP$LOG.REQD      = LOG.REQUIRED
COM.AIP$LOG.SRCE      = AI.SRCE
COM.AIP$COMM.SRCE     = AI.SRCE
* COM.AIP$LOG.TRAN.AIL  = AIL.NEXT.ID
AIL.NEXT.ID = COM.AIP$LOG.TRAN.AIL
COM.AIP$TRAN.SEQ  = EMPTY; * This is set by AI.PARSE.OUTPUT
*
~AI.LOAD.COM.AIP.TIERS~
*CODE.SEGMENT: AI.LOAD.COM.AIP.TIERS
* USED BY: AI.TALKER
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT AXION COMPUTER SYSTEMS LTD.
*   1990       ALL RIGHTS RESERVED
*
*
* FILE 'COM.AIP' EQUATES
*
*  Note that this algorythm assumes that an omitted service will autom-
*     matically be turned off if not sent
*
*  Also note that (BASIC) is not properly provided for as a special case
*
*
!
*
SYS.LOCT = "TIERS"; IF CNT.TST$LBL THEN PRINT @(60,20):"Load Device Tiers in AIPs" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
AIX.RESET = FALSE; IF WKO.ID EQ EMPTY THEN AIX.RESET = TRUE
MAT COM.AIP = EMPTY
*
*5APR94* IF OPT.COMM<ONE,ONE> EQ "AIDVC" THEN
LOCATE "AIDVC" IN OPT.COMM<ONE> SETTING TMP3 THEN
*
* Locate the device type to load # of addrs/unit & # of tiers/addr
LOCATE DVC$TYPE IN COM.AI$DVC.UNIT SETTING DVC.LOC ELSE DVC.LOC = ONE
*
AIX.LOC = ADD$AIX.LOCATION
IF NOT(AIX.LOC) THEN AIX.LOC = ONE
IF AI.TALK<ADDRESSABLE> NE EMPTY THEN AIX.LOC = ONE
*
COM.AIP$INTFC.CODE  = COM.AI$DB.PREFIX<ONE,DVC.LOC>
COM.AIP$SVC.ID.FUTR = EMPTY
*
* Set the current service levels on the port control record
IF AIX.ID NE EMPTY THEN
*
COM.AIP$SVC.ID      = DVC$TSVCS
COM.AIP$TIERS       = DVC$TIERS
COM.AIP$TSTAT       = DVC$TSTAT
*
END ELSE
*
COM.AIP$SVC.ID      = COM.AI$DF.SVCS.ONE<ONE,DVC.LOC>
COM.AIP$SVC.ID.FUTR = COM.AI$DF.SVCS.ONE<ONE,DVC.LOC>
COM.AIP$TIERS       = COM.AI$DF.TIER.ONE<ONE,DVC.LOC>
COM.AIP$TIERS.FUTR  = COM.AI$DF.TIER.ONE<ONE,DVC.LOC>
COM.AIP$TSTAT       = EMPTY
COM.AIP$TSTAT.FUTR  = EMPTY
*
SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID,SVM)
*
FOR SVC.CN = ONE TO SVC.CN.MAX
*
TMP = COM.AIP$SVC.ID<ONE,ONE,SVC.CN>
*
LOCATE TMP IN SAVE.ACT$SERVICES<ONE> SETTING SVC.VC THEN
IF SAVE.ACT$QNTYS<ONE,SVC.VC> GT 0 THEN
COM.AIP$TSTAT<ONE,ONE,SVC.CN> = "1"
END ELSE
COM.AIP$TSTAT<ONE,ONE,SVC.CN> = "0"
END
END ELSE
COM.AIP$TSTAT<ONE,ONE,SVC.CN> = "0"
SVC.VC = ZERO
END
*
* IF NOT(SVC.VC) OR (WOF EQ "D" AND WKO$STAT NE "X") THEN
IF (WKO$STAT NE "X" AND WKO$STAT NE "C") OR (WOF EQ "D" AND WKO$STAT NE "X") THEN
TMP1 = WKO$ACTIV.SERVICES
TMP2 = WKO$ACTIV.QNTYS
END ELSE
TMP1 = ACT$SERVICES
TMP2 = ACT$QNTYS
END
*
LOCATE TMP IN TMP1<ONE> SETTING FUTR.VC THEN
*
IF SVC.VC THEN
*
IF SAVE.ACT$QNTYS<ONE,SVC.VC> + TMP2<ONE,FUTR.VC> GT ZERO THEN
* IF TMP2<ONE,FUTR.VC> GT ZERO THEN
* IF ABS(TMP2<ONE,FUTR.VC>) NE 0 THEN
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "1"
END ELSE
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "0"
END
*
END ELSE
*
IF TMP2<ONE,FUTR.VC> GT ZERO THEN
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "1"
END ELSE
COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "0"
END
*
END; * OF SVC.VC
*
* END ELSE COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = "0"
END ELSE COM.AIP$TSTAT.FUTR<ONE,ONE,SVC.CN> = COM.AIP$TSTAT<ONE,ONE,SVC.CN>
*
NEXT SVC.CN
*
END; * OF AI.TALK<ADDRESSABLE>
*
!
*
COM.AIP$TINDEX      = EMPTY
*
IF AIX.ID NE EMPTY THEN
*
ACT.SVC.CN.MAX = DCOUNT(ACT$SERVICES,VM)
WKO.SVC.CN.MAX = DCOUNT(WKO$ACTIV.SERVICES,VM)
*
* This loop happens # of addr/unit times (1 or 8)
*       note the # of Connected OUTlets is ignored on the AIP rec.
* Services are subvalued within this location
*   they are in alphabetical order.
FOR AIX.VC = ONE TO COM.AI$ADDR.PER.UNIT<ONE,DVC.LOC>
*
COM.AIP$SVC.ID.FUTR<ONE,AIX.VC> = DVC$TSVCS<ONE,AIX.VC>
COM.AIP$TIERS.FUTR<ONE,AIX.VC>  = DVC$TIERS<ONE,AIX.VC>
COM.AIP$TSTAT.FUTR<ONE,AIX.VC>  = DVC$TSTAT<ONE,AIX.VC>
*
IF AIX.VC EQ AIX.LOC THEN
*
AIX.SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID.FUTR<ONE,AIX.VC>,SVM)
*
FOR SVC.CN = ONE TO AIX.SVC.CN.MAX
IF WOF EQ "D" AND WKO$STAT NE "X" THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,SVC.CN> = ZERO
END ELSE
LOCATE COM.AIP$SVC.ID.FUTR<ONE,AIX.VC,SVC.CN> IN ACT$SERVICES<ONE> SETTING ACT.LOC THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,SVC.CN> = ONE
END ELSE
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,SVC.CN> = ZERO
END
END; * Of WKO is "D" & -"X"
NEXT SVC.CN
*
FOR SVC.CN = ONE TO WKO.SVC.CN.MAX
* The service from the act is located in cnt.aip and added if missing
*
*27MAR94*IF INDEX("#H#S#A#","#":WKO$ACTIVS<ONE,SVC.CN>:"#",ONE) THEN
IF WKO$ACTIVS<ONE,SVC.CN> EQ "S" THEN
*
*27MAR94*TMP = ACT$SERVICES<ONE,SVC.CN>
TMP = WKO$ACTIV.SERVICES<ONE,SVC.CN>
TMP1 = WKO$ACTIV.QNTYS<ONE,SVC.CN>
LOCATE TMP IN ACT$SERVICES<ONE> SETTING ACT.LOC THEN
TMP1 = TMP1 + ACT$QNTYS<ONE,ACT.LOC>
END
*
LOCATE TMP IN COM.AIP$SVC.ID.FUTR<ONE,AIX.VC> SETTING AIX.SC ELSE
INS TMP BEFORE COM.AIP$SVC.ID.FUTR<ONE,AIX.VC,AIX.SC>
INS "0" BEFORE COM.AIP$TIERS.FUTR<ONE,AIX.VC,AIX.SC>
INS "0" BEFORE COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC>
AIX.SVC.CN.MAX = AIX.SVC.CN.MAX + ONE
END
*
* The tier is unknown and is set below
* The tier status is on if the qnty is not zero
*27MAR94*IF ACT$QNTYS<ONE,SVC.CN> THEN
*27MAR94*COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ONE
*27MAR94*END
IF WOF EQ "D" AND WKO$STAT NE "X" THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ZERO
END ELSE
IF TMP1 GT ZERO THEN
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ONE
END ELSE
COM.AIP$TSTAT.FUTR<ONE,AIX.VC,AIX.SC> = ZERO
END
END; * of "D" & -"X"
*
END; * Of WKO is AHS
*
NEXT SVC.CN
*
END
*
NEXT AIX.VC
*
!
*
* Do not remove this code, it is for future use. These variables can be
*  used to validate tier #'s.
* IF AI.TALK<OP.MULTI> THEN
* AIX.CN.MIN = (AIX.LOC - ONE) * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC> + ONE
* AIX.CN.MAX = AIX.CN.MIN - ONE  + COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* END ELSE
* AIX.CN.MIN = ONE
* AIX.CN.MAX = COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* END
*
* AIX.TIER.HI = COM.AI$ADDR.PER.UNIT<ONE,DVC.LOC> * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC>
* (LOC - 1) * TIERS.PER.UNIT + TIER
*
* Load the default settings (note that in future these sub-values
*  should be multivalued by being tied directly to the device type).
* IF AI.TALK<OP.MULTI> THEN
* COM.AI.DF.SVCS = COM.AI$DF.SVCS.EIGHT
* COM.AI.DF.TIER = COM.AI$DF.TIER.EIGHT
* COM.AI.DF.XREF = COM.AI$DF.XREF.EIGHT
* END ELSE
COM.AI.DF.SVCS = COM.AI$DF.SVCS.ONE
COM.AI.DF.TIER = COM.AI$DF.TIER.ONE
COM.AI.DF.XREF = COM.AI$DF.XREF.ONE
* END
*
* Loop through the future services setting tier number
AIX.SVC.CN.MAX = DCOUNT(COM.AIP$SVC.ID.FUTR<ONE,AIX.LOC>,SVM)
FOR AIX.CN = ONE TO AIX.SVC.CN.MAX
*
SVC.ID = COM.AIP$SVC.ID.FUTR<ONE,AIX.LOC,AIX.CN>
*
* The AIX service tier location is used first
LOCATE SVC.ID IN DVC$TSVCS<ONE,AIX.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = DVC$TIERS<ONE,AIX.LOC,SVC.LOC>
END ELSE
*
* Otherwise the default service tier location is used
*LOCATE SVC.ID IN COM.AI$DFLTS<ONE,DVC.LOC> SETTING SVC.LOC THEN
*COM.AI.TIER = COM.AI$DF.TIER<ONE,DVC.LOC,SVC.LOC>
LOCATE SVC.ID IN COM.AI.DF.SVCS<ONE,DVC.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = COM.AI.DF.TIER<ONE,DVC.LOC,SVC.LOC>
COM.AI.TIER = (AIX.LOC - ONE) * COM.AI$TIER.PER.UNIT<ONE,DVC.LOC> + COM.AI.TIER
END ELSE
*
* Otherwise the location of (BASIC) will be used
*   this would normally be the wrong thing to do but would test
*   wether the device works
LOCATE "(BASIC)" IN DVC$TSVCS<ONE,AIX.LOC> SETTING SVC.LOC THEN
COM.AI.TIER = DVC$TIERS<ONE,AIX.LOC,SVC.LOC>
END ELSE
*
* we can't turn on an unknown tier number
SVC.LOC = ZERO
COM.AI.TIER = ZERO
END
*
END
*
END
*
* Only turn on known tiers
IF COM.AI.TIER THEN
*
*
* This is the provision for indexed or labelled tiers
* COM.AI$INDEXED
*
* X - Service name is sent to device.
* R - Use then relative (numbered) location as the tier number.
* N - Use the tier number off of the AIX as the tier (spiggot) number.
* Y - Use the ONE/EIGHT default svcs as an index.
*
IF COM.AI$INDEXED EQ "N" THEN
*
* This is the normal condition (used by Eagle)
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = COM.AI.TIER
*
END ELSE IF COM.AI$INDEXED EQ "X" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = SVC.ID
*
END ELSE IF COM.AI$INDEXED EQ "Y" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = COM.AI.DF.XREF<ONE,COM.AI.TIER>
*
END ELSE IF COM.AI$INDEXED EQ "R" THEN
*
COM.AIP$TINDEX<ONE,AIX.LOC,AIX.CN> = AIX.CN
*
END; * of indexing
*
END; * of tier found
*
NEXT AIX.CN
*
END; * OF AIX.ID NE EMPTY
*
END ELSE
* LOCATE "AIDVC"
NULL
END; * of AIDVC
*
* End of tier processing
*
~AI.LOG.KEY.SET~
*CODE.SEGMENT: AI.LOG.KEY.SET
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITEN: FEB 91
*
* COMPANY: AXION COMPUTER SYSTEMS
*
* REQUIRED: AIL.DISP.TYPE
*           AIL.SEQ.DISP.MAX
*           AIL.SEQ.DISP.MIN
*           AIL.SEQ
*           AI.CODE
*
!
*
BEGIN CASE
*
CASE AIL.DISP.TYPE EQ ONE; * FULL HISTORY DISPLAY
*
AIL.SEQ.END = AIL.SEQ - ((AIL.SEQ.CN.MAX - AIL.SEQ.CN.MIN) * 3)
AIL.SEQ.DISP = AIL.SEQ - 5
*
LOOP
AIL.ID = "AI*":AI.CODE:"*":AIL.SEQ.DISP:"*LOG"
MATREAD AIL FROM AIL.FILE,AIL.ID THEN
AIL.ON.FILE = TRUE
END ELSE
AIL.ON.FILE = FALSE
END
WHILE AIL.ON.FILE AND AIL.SEQ.DISP GT AIL.SEQ.END DO
AIL.SEQ.DISP = AIL.SEQ.DISP - 5
REPEAT
*
*
CASE AIL.DISP.TYPE EQ TWO; * UNDISPLAYED LINES DISPLAY
*
LOOP
*
AIL.ID = "AI*":AI.CODE:"*":AIL.SEQ.DISP:"*LOG"
*
MATREAD AIL FROM AIL.FILE,AIL.ID THEN
AIL.ON.FILE = TRUE
END ELSE
MAT AIL = EMPTY
AIL.ON.FILE = FALSE
END
*
WHILE NOT(AIL$LOG.DISPL) AND AIL.ON.FILE DO
AIL.SEQ.DISP = AIL.SEQ.DISP - 5
IF AIL.SEQ.DISP LE ZERO THEN AIL.SEQ.DISP = AIL.SEQ.DISP + 999
REPEAT
*
*
END CASE
*
!
*
AIL.SEQ.CONT = 6
*
LOOP
*
AIL.ID = "AI*":AI.CODE:"*":AIL.SEQ.DISP:"*LOG"
*
MATREAD AIL FROM AIL.FILE,AIL.ID THEN
AIL.ON.FILE = TRUE
END ELSE
MAT AIL = EMPTY
AIL.ON.FILE = FALSE
AIL.SEQ.CONT = AIL.SEQ.CONT - ONE
END
*
WHILE (NOT(AIL.ON.FILE) AND (AIL.SEQ.CONT AND AIL.DISP.TYPE EQ ONE)) OR (AIL.ON.FILE AND NOT(AIL$LOG.DISPL) AND AIL.DISP.TYPE EQ TWO) DO
AIL.SEQ.DISP = AIL.SEQ.DISP + ONE
IF AIL.SEQ.DISP GT 999 THEN AIL.SEQ.DISP = ONE
REPEAT
*
~AI.LOG.WRITE~
*CODE.SEGMENT: AI.LOG.WRITE
* USED BY: AI.WRITE.LOG
*          AI.HANDLER
*          AI.TALKER
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
SYS.LOCT = "AI.LOC.WRITE"
*
AIL.SEQ.ID = "AI.LOG*":AI.CODE
*
LOOP
CALL SYS.ITM.LCK("COM",AIL.SEQ.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
*
READ AIL.SEQ FROM COM.FILE,AIL.SEQ.ID ELSE AIL.SEQ = ZERO
*
AIL.SEQ = AIL.SEQ + ONE
IF AIL.SEQ GT 999 THEN AIL.SEQ = ONE
*
WRITE AIL.SEQ ON COM.FILE,AIL.SEQ.ID
*
CALL SYS.ITM.RLS("COM",AIL.SEQ.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
*
AIL.ID = "AI*":AI.CODE:"*":("0000":AIL.SEQ) "R#4":"*LOG"
* COM.AIP$WKO.ID = AIL.NEXT.ID
IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
COM.AIP$LOG.TRAN.AIL = AIL.SEQ
AIL.NEXT.ID = AIL.SEQ
END
MAT AIL = MAT COM.AIP
IF AI.SRCE[ONE,ONE] NE "H" AND AI.SRCE[ONE,ONE] NE "C" THEN
AIL$COMM.SRCE = AI.SRCE
END
IF AIL$PORT EQ EMPTY THEN AIL$PORT = PORT
IF AIL$ACCT.ID EQ EMPTY THEN AIL$ACCT.ID = ACCT
IF AIL$COMM.SRCE EQ EMPTY THEN AIL$COMM.SRCE = AI.SRCE
INS PORT BEFORE AIL$LOG.PORT<ONE,ONE>
INS ACCT BEFORE AIL$LOG.ACCT<ONE,ONE>
INS SYS.PROG BEFORE AIL$LOG.PROG<ONE,ONE>
INS AI.SRCE BEFORE AIL$LOG.SRCE<ONE,ONE>
INS LOG.REQUIRED BEFORE AIL$LOG.LOC<ONE,ONE>
*
COM.AIP$LOG.REQD = TRUE
*
MATWRITE AIL ON AIL.FILE,AIL.ID
*
~AI.READ.CNT.AI~
*CODE.SEGMENT: AI.READ.CNT.AI
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
COM.AI.ID = "AI.TYPE.":COMMPORT
LCK.STAT = FALSE
*
LOOP
*
IF LCK.ITM THEN LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE,LCK.STAT)
*
UNTIL NOT(LCK.STAT) DO REPEAT
*
IF NOT(LCK.STAT) THEN
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN
*
COM.AI.ON.FILE = TRUE
*
*
!
*
END ELSE
* Not on file
COM.AI.ON.FILE = FALSE
STAT = 998
MAT COM.AI = EMPTY
END; * of on file/ not on file
*
*
END ELSE
COM.AI.ON.FILE = FALSE
LCK.STAT = 997
END; * of not stat
*
!
*
READ.COM.AI.UNLOCK: *
*
IF NOT(LCK.STAT) AND LCK.ITM AND LCK.RELS THEN CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE)
*
~AI.READ.CNT.AIP~
*CODE.SEGMENT: AI.READ.CNT.AIP
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS LTD.
*
COM.AIP.ID = "AI*":COMMPORT:"*":PORT.KEY
LCK.STAT = FALSE
*
IF NOT(DISP.ONLY) AND LOCK.ITEM THEN LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
*
IF NOT(LCK.STAT) THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN COM.AIP.ID.ON.FILE = TRUE ELSE COM.AIP.ID.ON.FILE = FALSE; LCK.STAT = 998; MAT COM.AIP = ""
*
END; * of not stat
*
!
*
READ.COM.AIP.UNLOCK: *
*
IF NOT(DISP.ONLY OR LCK.STAT) AND LOCK.ITEM AND LCK.RELS THEN CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
*
~AI.READ.COM.AI~
*CODE.SEGMENT: AI.READ.COM.AI
* VERSION: 940130 1.1  COM.AI.ID CHANGED.
* USED BY: AI.HANDLER
*          AI.TALKER
*          AI.CONTROL.UTILITY
*          AI.WRITE.COMMAND
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT: AXION COMPUTER SYSTEMS LTD.
*               ALL RIGHTS RESERVED
*
SYS.LOCT = "AI.READ.COM.AI"
*
COM.AI.ID = "AI.TYPE.":AI.CODE
LCK.STAT = FALSE
*
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF NOT(ELP.MAX) THEN ELP.MAX = 60
***ELP.MAX = 30
TMP2 = LCK.TYPE
*
IF LCK.ITM THEN
IF NOT(LCK.COM.AI) THEN
LOOP
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,TMP2,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF LCK.STAT AND ELP GT LCK.ELP.MAX - 5 AND (AI.SRCE EQ "C" OR AI.SRCE EQ "H") THEN
TMP2 = -6
END
UNTIL NOT(LCK.STAT) OR ELP GT LCK.ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
END
END ELSE LCK.STAT = FALSE
*
*** IF NOT(LCK.STAT) THEN
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN
*
COMMPORT = COM.AI$COMMPORT
COM.AI.ON.FILE = TRUE
*
*
!
*
END ELSE
* Not on file
COM.AI.ON.FILE = FALSE
STAT = 998
MAT COM.AI = EMPTY
END; * of on file/ not on file
*
*
*** END ELSE
*** COM.AI.ON.FILE = FALSE
*** LCK.STAT = 997
*** END; * of not stat
IF LCK.STAT THEN AI.STATUS = 101; COM.AI.RUN.ELP = ELP
*
!
*
READ.COM.AI.UNLOCK: *
*
IF LCK.COM.AI AND LCK.RELS THEN
**CALL UNLCK.ITEM(COM.FILE,"COM",COM.AI.ID,LCK.FILE)
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
~AI.READ.COM.AIP~
*CODE.SEGMENT: AI.READ.COM.AIP
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS LTD.
*
SYS.LOCT = "AI.READ.COM.AIP"
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
LCK.STAT = FALSE
*
IF LCK.ITM THEN
IF NOT(LCK.COM.AIP) THEN
DT = DATE(); TM = TIME(); ELP = ZERO
**ELP.MAX = COM.AI$MAX.PAUSE
**IF NOT(ELP.MAX) THEN ELP.MAX = 60
ELP.MAX = 30
LOOP
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LT ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
END
END
*
** IF NOT(LCK.STAT) THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN COM.AIP.ID.ON.FILE = TRUE ELSE COM.AIP.ID.ON.FILE = FALSE; LCK.STAT = 998; MAT COM.AIP = ""
*
** END ELSE
** LCK.STAT = 997
** IF NOT(STAT) THEN STAT = LCK.STAT
** END; * of not stat
*
!
*
READ.COM.AIP.UNLOCK: *
*
IF LCK.COM.AIP AND LCK.RELS THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.LOCT,"B","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
~AI.STATUS.VAR.EQUATES~
*CODE.SEGMENT: AI.STATUS.VAR.EQUATES
*
* FILE: STL      ID: STATUS.LOG
EQU STATUS.CHANNEL     TO 1; * CHANNEL #
EQU STATUS.CHAN.STAT   TO 2; * CHANNEL STATUS
EQU STATUS.DESC        TO 3; * CHANNEL DESCRIPTION
EQU STATUS.CHECKED     TO 4; * DT*TM OF LAST STATUS CHECK
EQU STATUS.SRVC        TO 5; * SERVICE ASSOC'T W THIS CHANNEL
EQU STATUS.FLAGGED     TO 6; * FLAG
*
*
EQU AI.UP TO "UP"
EQU AI.DN TO "DN"
EQU AI.ON TO "ON"
EQU AI.OFF TO "OFF"
*
~AI.TALK.VAR.EQUATES~
*CODE.SEGMENT: AI.TALK.VAR.EQUATES
*
*
*
EQU OP.MULTI TO 1;           * ADDRESS IS SERVED BY A MULTI ADDRESS DEVICE
EQU TALKING TO 2;            * CSR IS TALKING TO SOMEONE ON SITE
EQU DO.SEND TO 3;            * DO SEND TO ACTIVATE/DEACTIVATE SERVICES
EQU DISPATCHER.MSG TO 4;     * DISPATCHER MESSAGE HAS BEEN DISPLAYED
EQU INTERFACE.MSG TO 5;      * INTERFACE MESSAGE HAS BEEN DISPLAYED
EQU OP.STAT TO 6;            * THE INTERFACE IS ACTIVE
EQU OP.UP TO 7;              * THE INTERFACE IS UP
EQU VERIFIED.HOT TO 8;       * SERVICES HAVE BEEN VERIFIED AS ACTIVE
EQU VERIFIED.COLD TO 9;      * SERVICES HAVE BEEN VERIFIED AS INACTIVE
EQU VERIFIED.CHANGED TO 10;  * SERVICES HAVE BEEN VERIFIED AS CHANGED
EQU SENT TO 11;              * SEND HAS BEEN DONE
EQU PRIOR.TNT.ADD TO 12;     * ADDRESS IS PRIOR TENANT
EQU STOP.PRIOR.TNT TO 13;    * STOP SERVICE OF PRIOR TENANT
EQU PRIOR.ADD TO 14;         * ADDR IS THE PRIOR ADDR OF THE CURRENT TENANT
EQU PRIOR.ADD.HOT TO 15;     * PRIOR ADDRESS IS HOT
EQU PRINT.WO TO 16;          * WORK ORDER TO BE PRINTED (CHANGES BEING MADE)
EQU BUILD.WO TO 17;          * BUILD A WKO
EQU NOT.SCHEDULED TO 18;     * ON.PREMISE WO HAS BEEN UNSCHEDULED
EQU WKO.STAT TO 19;          * WKO STATUS PASSED BACK TO MAINT.WORK.ORDER
EQU TRAN.LOG TO 20;          * RECORD LOG FLAG
EQU ADDRESSABLE TO 21;       * THE ACCOUNT HAS AN ADDRESSABLE DEVICE
EQU PAY.PER.VIEW TO 22;      * THERE IS A DEVICE WITH PAY PER VIEW
EQU IMPULSE.PPV  TO 23;      * THERE IS A DEVICE WITH IMPULSE PAY PER VIEW
EQU AI.PRESENT   TO 24;      * FUTR FUNCTION OF GENERAL.OPEN (IN PAR)
EQU AI.DVC.IDS   TO 25;      * ITEM IDS OF ADDRESSABLE DEVICES
EQU AI.DVC.LOCS  TO 26;      * LOCATION OF DEVICE
EQU AI.DVC.ADDR  TO 28;      * ADDR ON DVC
EQU AI.DVC.PPV   TO 28;      * PPV  ON DEVICE
EQU AI.DVC.IPPV  TO 29;      * IPPV ON DEVCE
EQU AI.DVC.DIR   TO 30;      * DIRECTION (1 IS ACTIV / -1 IS DEACTIV)
EQU AI.DVC.SRCE  TO 31;      * DEVICE FOUND BY ACT/WKO/DVC
EQU AI.DVC.WKO   TO 32;      * WORK ORDER FOR DEVCIE
EQU AI.DVC.NEXT  TO 33;      * NEXT DVC TO BE ACTIVATED BY AI
EQU DO.COLL      TO 34;      * DO COLLECTION (0=ASK,1=YES,2=NO)
EQU RVRS.FL      TO 35;      * REVERSE THE TRANS ON FAIL/XCEL
EQU OP.PERM      TO 36;      * ADDRESS HAS AN OUTSIDE/ON PREM/PERMANENT DVC
EQU AI.GROUP     TO 37;      * DEVICE(S) WILL UPDATE THE GROUP INDEX
~AI.TALKER.TOP~
*CODE.SEGMENT: AI.TALKER.TOP
*PROGRAM:           AI.TALKER
* VERSION: 940301 1.2  SET AI.TYPE IN COMMN.AREA TO COM.AI$(AI.CODE:VM:DB.PREFIX).
* PRIOR: 940216 1.1  CHANGE COM.AI.ID FROM HEADEND TO AI.CODE.
* EQU VS TO "901018 NEW"
* DESCRIPTION:  INTERFACE BETWEEN CSR AND AI SYSTEMS
*
* COPYRIGHT      AXION COMPUTER SYSTEMS LTD.
* 1990                 ALL RIGHTS RESERVED
*
* AI.RSLT IS EQUIVALENT TO STAT
* 99 - NOT A VALID ACTION TYPE
* 1  - SERVICES MISMATCH
* 2  - SERVICE QUANTITIES MISMATCH
* 3  - CONNECTED OUTLETS MISMATCH (EQUIVALENT TO 2)
*
* CHECK THAT THE INSTALLER & INTERFACE MESSAGES HAVE BEEN DISPLAYED
*
* AI.ACTN IS A MULTI-VALUED STRING OF NUMBERED FUNCTIONS TO BE PERFORMED
*
~AIL.DIM~
*CODE.SEGMENT: AIL.DIM
*
DIM AIL(75)
~AIL.EQUATES~
*CODE.SEGMENT: AIL.EQUATES
*
* FILE 'AIL' EQUATES - GENERATED 08:48:49  05 FEB 1996
EQU AIL$TIERS TO AIL(1);                * String of tiers to be sent to Headend
EQU AIL$TIERS.FUTR TO AIL(2);           * Tiers to be sent to Headend (Temporary)
EQU AIL$HE.PORT TO AIL(3);              * Headend port # on billing computer
EQU AIL$COMM TO AIL(4);                 * Command/function to be done by interface
EQU AIL$ACCT.ID TO AIL(5);              * Account id effected by command
EQU AIL$ADD.ID TO AIL(6);               * Address id effected by command
EQU AIL$WKO.ID TO AIL(7);               * Work Order ID requiring command
EQU AIL$WKO.TYPE TO AIL(8);             * Work Order Type
EQU AIL$WKO.STAT TO AIL(9);             * Work Order Status
EQU AIL$INTFC.CODE TO AIL(10);          * Interface Code (ie EA=Eagle)
EQU AIL$DVC.ID TO AIL(11);              * Device Id of on premise device
EQU AIL$DVC.TYPE TO AIL(12);            * Type of on premise device (1/8)
EQU AIL$INTFC.STAT TO AIL(13);          * Status of interface when finished
EQU AIL$WKO.INST TO AIL(14);            * Work Order Installer
EQU AIL$COMM.DT TO AIL(15);             * Date command was issued
EQU AIL$COMM.TM TO AIL(16);             * Time command was issued
EQU AIL$COMM.C.DT TO AIL(17);           * Date command was completed
EQU AIL$COMM.C.TM TO AIL(18);           * Time command was completed
EQU AIL$COMM.PORT TO AIL(19);           * Port command was issued by
EQU AIL$HEX.COMM TO AIL(20);            * Hexadecimal format of command
EQU AIL$HEX.RSLT TO AIL(21);            * Hexadecimal result code of command
EQU AIL$COMM.RSLT TO AIL(22);           * Result code of command
EQU AIL$ERR TO AIL(23);                 * Error code from sending of command
EQU AIL$SVC.ID TO AIL(24);              * Services effected by command
EQU AIL$SVC.FUNC TO AIL(25);            * Function being done to service
EQU AIL$SVC.CHAN TO AIL(26);            * Channels belonging to service
EQU AIL$GROUP TO AIL(27);               * Address ID of AI device where installed
EQU AIL$GROUP.RSLT TO AIL(28);          * Result effecting Address ID or AI
EQU AIL$WKO.SCHED TO AIL(29);           * Schedule information from work order
EQU AIL$OPER TO AIL(30);                * Operator requesting interface action
EQU AIL$SVC.ID.FUTR TO AIL(31);         * Future Services for this device
EQU AIL$LOG.DISPL TO AIL(32);           * Log has been display by Display Monitor
EQU AIL$LOG.PRINT TO AIL(33);           * Has transaction been printed on the Log
EQU AIL$LOG.ACK.DI TO AIL(34);          * Has the Dispatched Acknowledged this
EQU AIL$LOG.ACK.BR TO AIL(35);          * Has the Branch Mngr Acknowledged this
EQU AIL$INTFC.TYPE TO AIL(36);          * Type of Interface - On-prem or In-prem
EQU AIL$TSTAT TO AIL(37);               * Tier status (0/1) off/on
EQU AIL$TSTAT.FUTR TO AIL(38);          * Tier status future (0/1)
EQU AIL$AIX.LOCATION TO AIL(39);        * Address number from ADD to AIX svrcs
EQU AIL$AIX.ID TO AIL(40);              * Item ID of the AIX id
EQU AIL$LOG.REQD TO AIL(41);            * Log transactions in update/abort
EQU AIL$TINDEX TO AIL(42);              * String of tiers to be transmitted to HE
EQU AIL$COMM.SRCE TO AIL(43);           * Source of tranaction log
EQU AIL$PORT TO AIL(44);                * Port number command issued from
EQU AIL$SVC.EXTR TO AIL(45);            * Extra Services / Features
EQU AIL$HEADEND TO AIL(46);             * Headend command issued for
EQU AIL$EVENT TO AIL(47);               * Events to be downloaded/uploaded
EQU AIL$EVENT.FUNC TO AIL(48);          * Event function to be done
EQU AIL$DVC.FUNC TO AIL(49);            * Function  Available on device
EQU AIL$DVC.FUNC.STAT TO AIL(50);       * Status of device function
EQU AIL$WKO.SCH.TM TO AIL(51);          * Sched time of WO, POC Encoder Group
EQU AIL$WKO.SCH.TYPE TO AIL(52);        * Sched type of WO, POC Encoder Member
EQU AIL$LOG.TRAN.AIL TO AIL(53);        * AI Logging Transaction #
EQU AIL$TRAN.SEQ TO AIL(54);            * AI Control Computer Tran Seq #
EQU AIL$WKO.FUNC TO AIL(55);            * Work Order Primary Function
EQU AIL$EVENT.CH TO AIL(56);            * Event Channel # to download
EQU AIL$EVENT.DT TO AIL(57);            * Event Date to download to POC
EQU AIL$EVENT.TM TO AIL(58);            * Start time to download to POC
EQU AIL$EVENT.DUR TO AIL(59);           * The event duration HH:MM
EQU AIL$END.UPL TO AIL(60);             * 'z' is end of upload from POC
EQU AIL$INTFC.ERR TO AIL(61);           * Error code or sending hardware
EQU AIL$MAX.PAUSE TO AIL(62);           * Maximum pause between progress updates
EQU AIL$RETRY TO AIL(63);               * Number of retries
EQU AIL$COL.STATUS TO AIL(64);          * Collection status returned
EQU AIL$COMM.CN TO AIL(65);             * Packet number (try #)
EQU AIL$LOG.SRCE TO AIL(66);            * Source of Log entry
EQU AIL$LOG.LOC TO AIL(67);             * Location of Log entry
EQU AIL$LOG.ACCT TO AIL(68);            * Account of Log entry
EQU AIL$LOG.PROG TO AIL(69);            * Subroutine of Log entry
EQU AIL$LOG.PORT TO AIL(70);            * Port of Log entry
EQU AIL$INTFC.SET.BY TO AIL(71);        * Interface action by routine
~AIL.VAR.EQUATES~
*CODE.SEGMENT: AIL.VAR.EQUATES
*
* FILE 'AIL' EQUATES - GENERATED 08:48:49  05 FEB 1996
EQU AIL$TIERS TO 1;                     * String of tiers to be sent to Headend
EQU AIL$TIERS.FUTR TO 2;                * Tiers to be sent to Headend (Temporary)
EQU AIL$HE.PORT TO 3;                   * Headend port # on billing computer
EQU AIL$COMM TO 4;                      * Command/function to be done by interface
EQU AIL$ACCT.ID TO 5;                   * Account id effected by command
EQU AIL$ADD.ID TO 6;                    * Address id effected by command
EQU AIL$WKO.ID TO 7;                    * Work Order ID requiring command
EQU AIL$WKO.TYPE TO 8;                  * Work Order Type
EQU AIL$WKO.STAT TO 9;                  * Work Order Status
EQU AIL$INTFC.CODE TO 10;               * Interface Code (ie EA=Eagle)
EQU AIL$DVC.ID TO 11;                   * Device Id of on premise device
EQU AIL$DVC.TYPE TO 12;                 * Type of on premise device (1/8)
EQU AIL$INTFC.STAT TO 13;               * Status of interface when finished
EQU AIL$WKO.INST TO 14;                 * Work Order Installer
EQU AIL$COMM.DT TO 15;                  * Date command was issued
EQU AIL$COMM.TM TO 16;                  * Time command was issued
EQU AIL$COMM.C.DT TO 17;                * Date command was completed
EQU AIL$COMM.C.TM TO 18;                * Time command was completed
EQU AIL$COMM.PORT TO 19;                * Port command was issued by
EQU AIL$HEX.COMM TO 20;                 * Hexadecimal format of command
EQU AIL$HEX.RSLT TO 21;                 * Hexadecimal result code of command
EQU AIL$COMM.RSLT TO 22;                * Result code of command
EQU AIL$ERR TO 23;                      * Error code from sending of command
EQU AIL$SVC.ID TO 24;                   * Services effected by command
EQU AIL$SVC.FUNC TO 25;                 * Function being done to service
EQU AIL$SVC.CHAN TO 26;                 * Channels belonging to service
EQU AIL$GROUP TO 27;                    * Address ID of AI device where installed
EQU AIL$GROUP.RSLT TO 28;               * Result effecting Address ID or AI
EQU AIL$WKO.SCHED TO 29;                * Schedule information from work order
EQU AIL$OPER TO 30;                     * Operator requesting interface action
EQU AIL$SVC.ID.FUTR TO 31;              * Future Services for this device
EQU AIL$LOG.DISPL TO 32;                * Log has been display by Display Monitor
EQU AIL$LOG.PRINT TO 33;                * Has transaction been printed on the Log
EQU AIL$LOG.ACK.DI TO 34;               * Has the Dispatched Acknowledged this
EQU AIL$LOG.ACK.BR TO 35;               * Has the Branch Mngr Acknowledged this
EQU AIL$INTFC.TYPE TO 36;               * Type of Interface - On-prem or In-prem
EQU AIL$TSTAT TO 37;                    * Tier status (0/1) off/on
EQU AIL$TSTAT.FUTR TO 38;               * Tier status future (0/1)
EQU AIL$AIX.LOCATION TO 39;             * Address number from ADD to AIX svrcs
EQU AIL$AIX.ID TO 40;                   * Item ID of the AIX id
EQU AIL$LOG.REQD TO 41;                 * Log transactions in update/abort
EQU AIL$TINDEX TO 42;                   * String of tiers to be transmitted to HE
EQU AIL$LOG.SRCE TO 43;                 * Source of tranaction log
EQU AIL$PORT TO 44;                     * Port number command issued from
EQU AIL$SVC.EXTR TO 45;                 * Extra Services / Features
EQU AIL$HEADEND TO 46;                  * Headend command issued for
EQU AIL$EVENT TO 47;                    * Events to be downloaded/uploaded
EQU AIL$EVENT.FUNC TO 48;               * Event function to be done
EQU AIL$DVC.FUNC TO 49;                 * Function  Available on device
EQU AIL$DVC.FUNC.STAT TO 50;            * Status of device function
EQU AIL$WKO.SCH.TM TO 51;               * Sched time of WO, POC Encoder Group
EQU AIL$WKO.SCH.TYPE TO 52;             * Sched type of WO, POC Encoder Member
EQU AIL$LOG.TRAN.AIL TO 53;             * AI Logging Transaction #
EQU AIL$TRAN.SEQ TO 54;                 * AI Control Computer Tran Seq #
EQU AIL$WKO.FUNC TO 55;                 * Work Order Primary Function
EQU AIL$EVENT.CH TO 56;                 * Event Channel # to download
EQU AIL$EVENT.DT TO 57;                 * Event Date to download to POC
EQU AIL$EVENT.TM TO 58;                 * Start time to download to POC
EQU AIL$EVENT.DUR TO 59;                * The event duration HH:MM
EQU AIL$END.UPL TO 60;                  * 'z' is end of upload from POC
EQU AIL$INTFC.ERR TO 61;                * Error code or sending hardware
EQU AIL$MAX.PAUSE TO 62;                * Maximum pause between progress updates
EQU AIL$RETRY TO 63;                    * Number of retries
EQU AIL$COL.STATUS TO 64;               * Collection status returned
EQU AIL$COMM.CN TO 65;                  * Packet number (try #)
EQU AIL$LOG.SRCE TO 66;                 * Source of Log entry
EQU AIL$LOG.LOC TO 67;                  * Location of Log entry
EQU AIL$LOC.ACCT TO 68;                 * Account of Log entry
EQU AIL$LOC.PROG TO 69;                 * Subroutine of Log entry
EQU AIL$LOC.PORT TO 70;                 * Port of Log entry
EQU AIL$INTFC.SET.BY TO 71;             * Interface action by routine
~AILIST.IBP~
*CODE.SEGMENT: ?
AI.INTFC.CHECK
SOURCEGEN.START
COM.AI.DIM
AIW.DIM
AIX.DIM
COM.AIP.DIM
ADD.DIM
COM.AI.EQUATES
AIW.EQUATES
AIX.EQUATES
COM.AIP.EQUATES
ADD.EQUATES
COM.AI.VAR.EQUATES
AIW.VAR.EQUATES
AIX.VAR.EQUATES
COM.AIP.VAR.EQUATES
ADD.VAR.EQUATES
AILIST.IBP
~AIW.DIM~
*CODE.SEGMENT: ?
DIM AIW(20)
~AIW.EQUATES~
*CODE.SEGMENT: ?
* FILE 'AIW' EQUATES - GENERATED 09:28:52  09 MAY 1986
EQU AIW$MLE.NUM TO AIW(1);              * MLE (CHANNEL) NUMBER
EQU AIW$MLE.COMM TO AIW(2);             * MLE COMMAND CODE
EQU AIW$BOX.COMM TO AIW(3);             * BOX COMMAND CODE
EQU AIW$CYPH TO AIW(4);                 * CYPHER KEY
EQU AIW$SYS.ID TO AIW(5);               * SYSTEM ID CODE
EQU AIW$GROUP TO AIW(6);                * GROUP ADDRESS
EQU AIW$BOX TO AIW(7);                  * BOX NUMBERS LIST
EQU AIW$DVC.ID TO AIW(8);               * DEVICE SERIAL NUMBER
EQU AIW$ACT.ID TO AIW(9);               * CURRENT ACCOUNT NUMBER
EQU AIW$SVC.ID TO AIW(10);              * CURRENT SERVICE LEVEL
EQU AIW$HEX.COMM TO AIW(11);            * HEXADECIMAL DISPLAY OF COMMAND
EQU AIW$HEX.RESULT TO AIW(12);          * HEXADECIMAL DISPLAY OF RESULT
EQU AIW$MLE.STAT TO AIW(13);            * MLE STATUS
EQU AIW$SYS.ID.RES TO AIW(14);          * SYSTEM ID FROM RESULT
EQU AIW$GROUP.RES TO AIW(15);           * GROUP ADDRESS OF RESULT
EQU AIW$ERR TO AIW(16);                 * ERROR CODE OF RESULT
EQU AIW$FLAG TO AIW(17);                * RECORD PRINTED FLAG (Y/NULL)
~AIW.VAR.EQUATES~
*CODE.SEGMENT: ?
~AIX.DIM~
DIM AIX(10)
~AIX.EQUATES~
*CODE.SEGMENT: AIX.EQUATES
*
* FILE 'AIX' EQUATES - GENERATED 16:00:31  03 MAR 1994
EQU AIX$ACT.ID TO AIX(1);               * ACCOUNT NUMBER OF ADDRESSABLE DEVICE
EQU AIX$CO TO AIX(2);                   * THE COMPANY TO WHICH THE ACT.ID BELONGS
EQU AIX$START.DATE TO AIX(3);           * THE EFFECTIVE DATE OF CONNECTION
EQU AIX$STOP.DATE TO AIX(4);            * THE EFFECTIVE DATE OF DISCONNECTION
EQU AIX$AI.CODE TO AIX(5);              * The AI the device is assigned to.
EQU AIX$GROUP TO AIX(6);                * AI control computer port number
EQU AIX$ERROR TO AIX(7);                * Duplicate device id
~AIX.VAR.EQUATES~
*CODE.SEGMENT: AIX.VAR.EQUATES
*
* FILE 'AIX' EQUATES - GENERATED 16:00:31  03 MAR 1994
EQU AIX$ACT.ID TO 1;                    * ACCOUNT NUMBER OF ADDRESSABLE DEVICE
EQU AIX$CO TO 2;                        * THE COMPANY TO WHICH THE ACT.ID BELONGS
EQU AIX$START.DATE TO 3;                * THE EFFECTIVE DATE OF CONNECTION
EQU AIX$STOP.DATE TO 4;                 * THE EFFECTIVE DATE OF DISCONNECTION
EQU AIX$AI.CODE TO 5;                   * The AI the device is assigned to.
EQU AIX$GROUP TO 6;                     * AI control computer port number
EQU AIX$ERROR TO 7;                     * Duplicate device id
~APVND.DIM~
*CODE.SEGMENT: ?
DIM APVND(20)
~APVND.EQUATES~
*CODE.SEGMENT: ?
* FILE 'APVND' EQUATES - GENERATED 15:47:16  25 JUL 1984
EQU APVND$VENDOR.NAME TO APVND(1);      * VENDOR NAME - LINE 1
EQU APVND$VENDOR.NAME2 TO APVND(2);     * VENDOR NAME - LINE 2
EQU APVND$ADDRESS TO APVND(3);          * STREET ADDRESS
EQU APVND$CITY TO APVND(4);             * CITY NAME
EQU APVND$POSTAL TO APVND(5);           * POSTAL CODE
EQU APVND$PHONE TO APVND(6);            * PHONE NUMBER
EQU APVND$COMMENT TO APVND(7);          * VENDOR COMMENT
EQU APVND$DEFER TO APVND(8);            * DEFER PAYMENT FLAG
EQU APVND$MTD TO APVND(9);              * MONTH.TO.DATE INVOICES
EQU APVND$YTD TO APVND(10);             * YEAR.TO.DATE INVOICES
EQU APVND$TRX.DATE TO APVND(11);        * LAST TRANSACTION DATE
~AREA.DESC.LOAD~
*CODE.SEGMENT: AREA.DESC.LOAD
*
*
PAR.ID = AREA.SELECTION<1,1,1>
READ AREA.DESCRIPTIONS FROM PAR.FILE,PAR.ID ELSE
PRINT "Can't read PAR ":PAR.ID:
IF NOT(AUTO.RUN) THEN
PRINT ". Enter <cr> . . . ":; INPUT RSP
END ELSE
EXECUTE "BLOCK-PRINT ":SYS.APPL.LOC:" NO PAR ":PAR.ID:" (P)"
END
STOP
END
*
~ASH.DIM~
*CODE.SEGMENT: ?
DIM ASH(20)
~ASH.EQUATES~
*CODE.SEGMENT: ?
* FILE 'ASH' EQUATES - GENERATED 15:55:28  11 JAN 1985
EQU ASH$SERVICES TO ASH(1);             * TYPE OF SERVICE PROVIDED
EQU ASH$QNTYS TO ASH(2);                * QUANTITY OF SERVICE
EQU ASH$BILL.FREQS TO ASH(3);           * FREQUENCY OF BILLING
EQU ASH$BILL.FROM.DATES TO ASH(4);      * SERVICE BILLED FROM DATE
EQU ASH$BILL.TO.DATES TO ASH(5);        * SERVICE BILLED TO DATE
EQU ASH$DVC.NUMS TO ASH(6);             * POINTER TO DEVICE.ID IN FILE 'DVC'
EQU ASH$SVC.LOCATIONS TO ASH(7);        * LOCATION OF SERVICE
EQU ASH$SVC.START.DATES TO ASH(8);      * START DATE OF SERVICE
EQU ASH$SVC.END.DATES TO ASH(9);        * SERVICE END DATE
EQU ASH$SVC.CHG.DATES TO ASH(10);       * DATE OF CHANGE IN SERVICE OR RATE
EQU ASH$RATE.QNTYS TO ASH(11);          * NO. OF OUTLETS AT RATE
EQU ASH$MTHLY.RATES TO ASH(12);         * RATE PER OUTLET PER MONTH
EQU ASH$TAX.NAMES TO ASH(13);           * NAME OF TAX
EQU ASH$TAX.AMTS TO ASH(14);            * AMOUNT OF TAX
EQU ASH$EARNED.REV TO ASH(15);          * ME E-REV.
EQU ASH$PRIOR.PER.REV.AMTS TO ASH(16);  * PRIOR REV.
EQU ASH$BILLING.RUNS TO ASH(17);        * BILL.RUN
EQU ASH$EFT.BILLING TO ASH(18);         * Bill service on EFT
~ATH.DIM~
*CODE.SEGMENT: ?
DIM ATH(20)
~ATH.EQUATES~
*CODE.SEGMENT: ?
* FILE 'ATH' EQUATES - GENERATED 16:17:19  07 SEP 1984
EQU ATH$EFF.DATES TO ATH(1);            * EFFECTIVE DATE OF TRANSACTION
EQU ATH$ENTRY.DATES TO ATH(2);          * SYSTEM ENTRY DATE OF TRANSACTION
EQU ATH$ENTRY.PERIODS TO ATH(3);        * ACCOUNTING PERIOD WHEN ENTERED (YYMM)
EQU ATH$TYPES TO ATH(4);                * TRANSACTION TYPE
EQU ATH$REFS TO ATH(5);                 * TRANSACTION REFERENCE
EQU ATH$TOTAL.AMTS TO ATH(6);           * TOTAL AMOUNT OF TRANSACTION
EQU ATH$DESCS TO ATH(7);                * TRANSACTION DESCRIPTION
EQU ATH$SVC.TYPES TO ATH(8);            * TYPE OF SERVICE PROVIDED
EQU ATH$SVC.QNTYS TO ATH(9);            * QUANTITY OF SERVICE
EQU ATH$SVC.AMTS TO ATH(10);            * AMOUNT BILLED FOR SERVICE
EQU ATH$SVC.FROM.DATES TO ATH(11);      * START DATE FOR SERVICE BILLED
EQU ATH$SVC.TO.DATES TO ATH(12);        * END DATE FOR SERVICE BILLED
~ATR.DIM~
*CODE.SEGMENT: ?
DIM ATR(20)
~ATR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'ATR' EQUATES - GENERATED 16:17:19  07 SEP 1984
EQU ATR$EFF.DATES TO ATR(1);            * EFFECTIVE DATE OF TRANSACTION
EQU ATR$ENTRY.DATES TO ATR(2);          * SYSTEM ENTRY DATE OF TRANSACTION
EQU ATR$ENTRY.PERIODS TO ATR(3);        * ACCOUNTING PERIOD WHEN ENTERED (YYMM)
EQU ATR$TYPES TO ATR(4);                * TRANSACTION TYPE
EQU ATR$REFS TO ATR(5);                 * TRANSACTION REFERENCE
EQU ATR$TOTAL.AMTS TO ATR(6);           * TOTAL AMOUNT OF TRANSACTION
EQU ATR$DESCS TO ATR(7);                * TRANSACTION DESCRIPTION
EQU ATR$SVC.TYPES TO ATR(8);            * TYPE OF SERVICE PROVIDED
EQU ATR$SVC.QNTYS TO ATR(9);            * QUANTITY OF SERVICE
EQU ATR$SVC.AMTS TO ATR(10);            * AMOUNT BILLED FOR SERVICE
EQU ATR$SVC.FROM.DATES TO ATR(11);      * START DATE FOR SERVICE BILLED
EQU ATR$SVC.TO.DATES TO ATR(12);        * END DATE FOR SERVICE BILLED
~AUX.INCL.OFF~
*CODE.SEGMENT:           AUX.INCL.OFF
* AUTHOR:    David Horsman/Macroscope Design Matrix
*            Axion Computer Systems Ltd.
*
* DESCRIPTION:       TURNS Terminal Auxillary Port or PC Com Port OFF
*
PRINT AUX.OFF:
AUX.STAT = FALSE
*
~AUX.INCL.ON~
*CODE.SEGMENT:           AUX.INCL.ON
* AUTHOR:    David Horsman/Macroscope Design Matrix
*            Axion Computer Systems Ltd.
*
* DESCRIPTION:       TURNS Terminal Auxillary Port or PC Com Port ON
*
PRINT AUX.ON:
AUX.STAT = FALSE
*
~AX.STANDARD.FUNCTIONS~
*CODE.SEGMENT: AX.STANDARD.FUNCTIONS
*
!
*
STANDARD.FUNCTIONS: *
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13),
SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~AXION.STANDARD.FUNCTIONS~
*CODE.SEGMENT: AXION.STANDARD.FUNCTIONS
*
!
*
STANDARD.FUNCTIONS: *
*
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13),
SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~BIL.DIM~
*CODE.SEGMENT: ?
DIM BIL(20)
~BIL.EQUATES~
*CODE.SEGMENT: ?
* FILE 'BIL' EQUATES - GENERATED 10:40:12  10 NOV 1986
EQU BIL$RUNS TO BIL(1);                 * BILLING RUN NUMBERS
EQU BIL$DESC TO BIL(2);                 * BILLING RUN DESCRIPTION
EQU BIL$CYCLES TO BIL(3);               * BILLING CYCLE NUMBERS
EQU BIL$BILL.DATE TO BIL(4);            * LATEST BILL DATE
EQU BIL$ACTION.DATE TO BIL(5);          * ACTION DATE
EQU BIL$ACTION.DESC TO BIL(6);          * ACTION DESC
EQU BIL$ACTION.FORMAT TO BIL(7);        * ACTION FORMAT
EQU BIL$ACTION.CR.STAT TO BIL(8);       * ACTION CREDIT STATUS
EQU BIL$ACTION.CTR TO BIL(9);           * ACTION COUNTER
EQU BIL$EFT.DATE TO BIL(10);            * EFT PAYMENT DATE
EQU BIL$DISC.DATE TO BIL(11);           * DISCONNECT DATE
EQU BIL$SELECTIONS TO BIL(12);          * SELECTION CRITERIA
EQU BIL$BILL.CTR TO BIL(13);            * ACCOUNTS BILLED
EQU BIL$DISC.CTR TO BIL(14);            * DISCONNECTS UPDATED
EQU BIL$ACTIV.CTR TO BIL(15);           * ACTIVES UPDATED
EQU BIL$BILL.TOT TO BIL(16);            * TOTAL AMOUNT BILLED
~BU.AI.INTFC.CHECK~
*CODE.SEGMENT: AI.INTFC.CHECK
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* * COM.AI.ERR.TEXT<-ONE> = "The AI Handler is ok."
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
DT = DATE(); TM = TIME()
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
*   8640 86200     8641 01000  CURR DT/TM
*   8640 86000     8640 86200  FUNC DT/TM
*   ---- -----     ---- -----
*      0   200        1 85200-
*                 86400
*                 85200-
*                  1200
*
*
BEGIN CASE
*
CASE COM.AI$ON.OFF.STAT EQ AI.ON
COM.AI.ON = TRUE
!
*
IF COM.AI$MAX.PAUSE + 4 * COM.AI$STD.PAUSE LE COM.AI.RUN.ELP THEN
COM.AI.ERR<-ONE> = 101
COM.AI.ERR.TEXT<-ONE> = "Failure, AI hung for ":OCONV(COM.AI.RUN.ELP,"MTS"):" hours!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
IF COM.AI$UP.DN.STAT EQ AI.UP THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
*COM.AI.ON = FALSE
END
COM.AI.UP = FALSE
END ELSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.UP = TRUE
COM.AI.ERR<-ONE> = ZERO
COM.AI.ERR.TEXT<-ONE> = "The AI is ON and UP."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.UP = FALSE
COM.AI.ERR<-ONE> = 3
COM.AI.ERR.TEXT<-ONE> = "The AI is ON and DN."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.ERR<-ONE> = 191
COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
COM.AI.ERR.TYPE<-ONE> = "DATA"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
END CASE
*
END
*
!
*
CASE COM.AI$ON.OFF.STAT EQ AI.OFF
COM.AI.ON = FALSE
COM.AI.UP = FALSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.ERR<-ONE> = 102
COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and UP!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.ERR<-ONE> = TWO
COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and DN."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.ERR<-ONE> = 192
COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
COM.AI.ERR.TYPE<-ONE> = "DATA"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
CASE TRUE
COM.AI.ERR<-ONE> = 181
COM.AI.ERR.TEXT<-ONE> = "The AI is neither ON nor OFF!"
COM.AI.ERR.TYPE<-ONE> = "DATA"
IF COM.AI$ON.OFF.STAT NE AI.OFF THEN COM.AI.ERR.FUNC<-ONE> = AI.OFF ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
BEGIN CASE
*
CASE COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
COM.AI.ERR<-ONE> = 101
COM.AI.ERR.TEXT<-ONE> = "Failure, No (":COM.AI.RUN.ELP:") Acknowledgment!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$ON.OFF.STAT NE COM.AI$ON.OFF
COM.AI.ON.OFF.ELP = ((DT - COM.AI$ON.OFF.DT) * 86400) + (TM - COM.AI$ON.OFF.TM)
IF COM.AI.ON.OFF.ELP GT COM.AI$MAX.PAUSE + 3 * COM.AI$STD.PAUSE THEN
COM.AI.ERR<-ONE> = 111
COM.AI.ERR.TEXT<-ONE> = "Failure logging ":COM.AI$ON.OFF:"! (":COM.AI.ON.OFF.ELP:")"
COM.AI.ERR.TYPE<-ONE> = "TOUT"
COM.AI.ERR.FUNC<-ONE> = COM.AI$ON.OFF
END ELSE
COM.AI.ERR<-ONE> = 11
COM.AI.ERR.TEXT<-ONE> = "The AI is logging ":COM.AI$ON.OFF:"."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$UP.DN.STAT NE COM.AI$UP.DN
COM.AI.UP.DN.ELP = ((DT - COM.AI$UP.DN.DT) * 86400) + (TM - COM.AI$UP.DN.TM)
IF COM.AI.UP.DN.ELP GT COM.AI$MAX.PAUSE + 2 * COM.AI$STD.PAUSE THEN
COM.AI.ERR<-ONE> = 121
COM.AI.ERR.TEXT<-ONE> = "Failure going ":COM.AI$UP.DN:"! (":COM.AI.UP.DN.ELP:")"
COM.AI.ERR.TYPE<-ONE> = "TOUT"
* COM.AI.ERR.FUNC<-ONE> = COM.AI$UP.DN
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
END ELSE
COM.AI.ERR<-ONE> = 12
COM.AI.ERR.TEXT<-ONE> = "The AI is going ":COM.AI$UP.DN:"."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
TMP = "AI.OFF.":PORT.KEY
READV OFF.FLAG FROM CNT.FILE,TMP,ONE ELSE
TMP = "AI.OFF.ALL"
READV OFF.FLAG FROM CNT.FILE,TMP,ONE ELSE OFF.FLAG = FALSE
END
*
IF OFF.FLAG THEN
WRITEV "Done ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS") ON CNT.FILE,TMP,TWO
COM.AI.ERR<-ONE> = 131
COM.AI.ERR.TEXT<-ONE> = "Interface Off Flag is set!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
*  IF NOT(LEN(COM.AI.ERR)) THEN
*
CHECK.FMT = "L#":CHECK.LEN
*
*
EXEC.IN = EMPTY; EXEC.OUT = EMPTY; EXEC.VERB = EMPTY
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
EXEC.VERB = 'SSELECT CNT EQ "AI*]" BY COMM.DT BY COMM.TM'
*
IF COM.AI.ERR.DISP THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Selecting Active Ports" CHECK.FMT:RVE
END
*
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > CNT.ID.LIST, //OUT. > EXEC.OUT
*
* REV ONLY
* PERFORM EXEC.VERB
*
END ELSE
*
CNT.ID.LIST = COM.AI$FUNC.PORT
IF CNT.ID.LIST EQ EMPTY THEN CNT.ID.LIST = PORTS.LIST
*
END; * of fast disp
*
IF COM.AI.ERR.DISP THEN
*
CHECK.LN = CHECK.LN.MIN
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT EXEC.VERB CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF LEN(EXEC.OUT) THEN
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE> CHECK.FMT; CHECK.LN = CHECK.LN + ONE
DEL EXEC.OUT<ONE>
REPEAT
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
END; * of fast disp
*
IF CHECK.LN.HI GT CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT
NEXT TMP
END
*
CHECK.LN.HI = CHECK.LN; CHECK.LN = CHECK.LN.MIN
*
RQM
*
END; * cnt.ai.err.disp
*
*
COM.AI.PORT.REC = EMPTY
COM.AIP.PORT.FIRST = TRUE; PORT.CONT = TRUE
* PORTS.LIST = EMPTY
*
LOOP
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
* ULT ONLY
READNEXT CNT.ID FROM CNT.ID.LIST ELSE CNT.ID = "@@@"
*
* REV ONLY
* READNEXT CNT.ID ELSE CNT.ID = "@@@"
*
COM.AIP.ID = CNT.ID
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
*
*
END ELSE
*
IF CNT.ID.LIST EQ EMPTY THEN CNT.ID = "@@@" ELSE
CNT.ID = "AI*":HEADEND:"*":CNT.ID.LIST<ONE,ONE>
COM.AIP.ID = CNT.ID
COM.AIP.PORT = CNT.ID.LIST<ONE,ONE>
DEL CNT.ID.LIST<ONE,ONE>
LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
IF COM.AI.ERR.DISP THEN PRINT BELL:
END
END
*
END; * of fast disp
*
WHILE CNT.ID NE "@@@" DO
*
IF COM.AIP.ID MATCHES '"AI*"2X"*"3N' THEN
*
IF AI.SCAN THEN
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CNT.FILE,"CNT",COM.AIP.ID,LCK.FILE,LCK.STAT)
UNTIL NOT(LCK.STAT) DO REPEAT
END ELSE LCK.STAT = FALSE
*
MATREAD COM.AIP FROM CNT.FILE,COM.AIP.ID THEN
*
COM.AIP.ON.FILE = TRUE
*
IF TF THEN PRINT @(60,20):"Cnt Aip ":COM.AIP.ID "L#18":
*
*@@@ BUILD PORT RECORD
*
TMP = FALSE
IF FAST.DISPLAY OR COM.AIP$COMM.PORT NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN TMP = TRUE
IF ((COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND ((((DT - COM.AIP$COMM.C.DT) * 86400) + (TM - COM.AIP$COMM.C.TM)) LT 300)) THEN TMP = TRUE
IF TMP THEN
*
IF PORT.CONT AND COM.AI.ERR.DISP THEN
*
IF PORTS.LIST.BUILD OR COM.AIP.PORT.FIRST OR CHECK.LN GE CHECK.LN.MAX THEN
COM.AIP.PORT.FIRST = FALSE
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Oper. Po Typ Stat A/I Dvc. Fnc" CHECK.FMT:RVE:
END
*
*
IF CHECK.LN GE CHECK.LN.MAX THEN
CHECK.LN = CHECK.LN.MIN
IF STATUS.CYCLE THEN
RQM; RQM; RQM
END ELSE
LOOP
PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(ZERO,23):" " CHECK.FMT:
IF RSP EQ EMPTY THEN PORT.CONT = FALSE ELSE ALREADY.DISPLAYED = TRUE
END; * OF STATUS CYCLE
END; * OF CHECK.LN GT CHECK.LN.MAX
*
*
IF PORT.CONT THEN
TMP = COM.AIP$OPER "R#5":" ":FIELD(COM.AIP.ID,"*",3) "R#2":" ":COM.AIP$COMM "R#3":" ":COM.AIP$INTFC.STAT<ONE,ONE> "L#4":" ":COM.AIP$INTFC.CODE "L#2":COM.AIP$INTFC.TYPE "L#1":" ":COM.AIP$DVC.TYPE "L#4":" ":COM.AIP$SVC.FUNC "L#3"
PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END; * OF PORT.CONT
*
END; * OF PORT.CONT AND ERR.DISP
*
*
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
*
IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN
*
IF COM.AIP.ELP GT TWO * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
*
IF AI.SCAN THEN
*
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE,LCK.STAT)
*
IF NOT(LCK.STAT) THEN
*
COM.AI.ERR<-ONE> = 371
COM.AI.ERR.TYPE<-ONE> = "TOUT"
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "DONE"
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "WAIT"
COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "RVRS"
COM.AIP$COMM.PORT = COM.AIP.PORT
*
CASE COM.AIP$INTFC.STAT EQ "COMP":VM:COM.AIP$INTFC.STAT
* Should never happen
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "XCEL"
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE TRUE
*
END CASE
*
COM.AI.ERR.TEXT<-ONE> = "Failure at (":COM.AIP.ELP:") Port ":COM.AIP.PORT:" ":COM.AIP$INTFC.STAT<ONE,ONE>:"!"
*
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AIP$ERR = "371":VM:COM.AIP$ERR
CALL AI.WRITE.LOG(CNT.FILE,MAT COM.AIP,HEADEND,AI.SRCE)
MATWRITE COM.AIP ON CNT.FILE,COM.AIP.ID
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE)
*
END; * OF LCK.STAT
*
END ; * OF AI.SCAN
*
END; * OF ELP
END; * OF NO C.DT OR C.TM
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST<ONE> SETTING TMP ELSE
PORTS.LIST<ONE,-ONE> = COM.AIP.PORT
END
*
END; * OF NO C.DT OR C.TM
*
*
END ELSE
* NOT ON FILE
COM.AIP.ON.FILE = FALSE
MAT COM.AIP = EMPTY
END
*
IF AI.SCAN AND NOT(LCK.STAT) THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",COM.AIP.ID,LCK.FILE)
END
*
END; * OF MATCHES AI*XX*999
*
REPEAT
*
IF COM.AI.ERR.DISP THEN
IF CHECK.LN.HI GE CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT:
NEXT TMP
CHECK.LN.HI = CHECK.LN
END
END
*
*  END; * OF NOT(COM.AI.ERR)
*
PORTS.LIST.BUILD = FALSE
*
*
~BU.AIX.EQUATES~
*CODE.SEGMENT: ?
* FILE 'AIX' EQUATES - GENERATED 10:02:23  05 DEC 1990
EQU AIX$BOX TO AIX(1);                  * BOX NUMBERS LIST
EQU AIX$DVC.ID TO AIX(2);               * DEVICE SERIAL NUMBER
EQU AIX$SVC.ID TO AIX(3);               * CURRENT SERVICE LEVEL
EQU AIX$BOX.FLAG TO AIX(4);             * BOX ON/OFF FLAG (1 or 0)
EQU AIX$CHAN.FLAG TO AIX(5);            * LIST OF CHANNELS (MLE'S) ENABLED
EQU AIX$PC.FLAG TO AIX(6);              * LIST OF CHANNELS FOR PARENTAL CONTROL
EQU AIX$EVENT.FLAG TO AIX(7);           * LIST OF CHANNELS WITH SPEC EVENT ON
EQU AIX$REMOTE.FLAG TO AIX(8);          * REMOTE CONTROL ON/OFF FLAG (1 or 0)
EQU AIX$STEREO.FLAG TO AIX(9);          * STEREO ON/OFF FLAG (1 or 0)
EQU AIX$RESERVED.FLAG TO AIX(10);       * RESERVED ON/OFF FLAG (0 or 1)
EQU AIX$TYPE TO AIX(11);                * 
EQU AIX$STAT TO AIX(12);                * 
EQU AIX$INSTALLED.ADD.ID TO AIX(13);    * 
EQU AIX$FUNCS TO AIX(14);               * 
EQU AIX$SERIAL.NUM TO AIX(15);          * 
EQU AIX$SVC.ADD.ID TO AIX(16);          * 
EQU AIX$SVC.ADD.STAT TO AIX(17);        * 
EQU AIX$ACT.ID TO AIX(18);              * 
EQU AIX$CONN.OUTLETS TO AIX(19);        * 
EQU AIX$COMMENTS TO AIX(20);            * 
~BU.COM.AI.EQUATES~
*CODE.SEGMENT: COM.AI.EQUATES
*
* FILE 'COM.AI' EQUATES - REVISED 22:48:23  16 JAN 1993
EQU COM.AI$DB.PREFIX TO COM.AI(1);      * Interface code or BP ID Prefix for call
EQU COM.AI$RSVD.2 TO COM.AI(2);         * See COM AI.TYPES for AI description.
EQU COM.AI$TYPE TO COM.AI(3);           *  AI Type
EQU COM.AI$NAME TO COM.AI(4);         * See AI.TYPES for NAME of this AI
EQU COM.AI$CTLR.PORT TO COM.AI(5);      * The AI controller's port number
EQU COM.AI$BILL.CUTOFF.TM TO COM.AI(6); * cutoff time for current day's Billing
EQU COM.AI$RSVD.7 TO COM.AI(7);         * See COM AI.TYPES for Mfg's model no, serial no, or site desc.
EQU COM.AI$DF.SVCS.ONE TO COM.AI(8);    * Default Services, One address / device
EQU COM.AI$DF.COUT.ONE TO COM.AI(9);    * Default Conn Outlets, One address / device
EQU COM.AI$DF.SVCS.EIGHT TO COM.AI(10); * Default Services, Eight addresses / device
EQU COM.AI$DF.COUT.EIGHT TO COM.AI(11); * Default Conn Outlets, Eight addresses / device
EQU COM.AI$COMMPORT TO COM.AI(12);      * Billing Computer Handler Port
EQU COM.AI$UP.DN TO COM.AI(13);         * Program will execute commands or not
EQU COM.AI$UP.DN.DT TO COM.AI(14);      * Date U/D command issued
EQU COM.AI$UP.DN.TM TO COM.AI(15);      * Time U/D command issued
EQU COM.AI$ON.OFF TO COM.AI(16);        * Port is to log on or log off
EQU COM.AI$ON.OFF.DT TO COM.AI(17);     * Date On/Off command was issued
EQU COM.AI$ON.OFF.TM TO COM.AI(18);     * Time On/Off command was issued
EQU COM.AI$LOGGING TO COM.AI(19);       * Is command logging done (Y/N)
EQU COM.AI$TEST.MODE TO COM.AI(20);     * Test flag for this interface device
EQU COM.AI$UP.DN.C.DT TO COM.AI(21);    * Date UP/DN command completed
EQU COM.AI$UP.DN.C.TM TO COM.AI(22);    * Time UP/DN command completed
EQU COM.AI$ON.OFF.C.DT TO COM.AI(23);   * Date ON/OFF command completed
EQU COM.AI$ON.OFF.C.TM TO COM.AI(24);   * Time ON/OFF command completed
EQU COM.AI$OPER TO COM.AI(25);          * Operator who last updated control record
EQU COM.AI$UP.DN.STAT TO COM.AI(26);    * True interface UP/DN status
EQU COM.AI$ON.OFF.STAT TO COM.AI(27);   * True interface ON/OFF status
EQU COM.AI$FUNC.DT TO COM.AI(28);       * Date last function was completed
EQU COM.AI$FUNC.TM TO COM.AI(29);       * Time last functions was completed
EQU COM.AI$COMMAND.DT TO COM.AI(30);    * Date last command was completed (SUBSCR)
EQU COM.AI$COMMAND.TM TO COM.AI(31);    * Time last command was completed (SUBSCR)
EQU COM.AI$FUNC TO COM.AI(32);          * Last function completed
EQU COM.AI$COMMAND TO COM.AI(33);       * Command last completed
EQU COM.AI$ON.OFF.BY TO COM.AI(34);     * Operator who issued ON/OFF function
EQU COM.AI$UP.DN.BY TO COM.AI(35);      * Operator who issued UP/DN function
EQU COM.AI$STD.PAUSE TO COM.AI(36);     * Standard Pause when handler idling
EQU COM.AI$MAX.PAUSE TO COM.AI(37);     * Maximum time before handler time out
EQU COM.AI$FUNC.PORT TO COM.AI(38);     * Priority command from port # 999
EQU COM.AI$RESET.FREQ TO COM.AI(39);    * Number of seconds between handler resets
EQU COM.AI$SCAN.FREQ TO COM.AI(40);     * number of secs between checking CSR's
EQU COM.AI$SCAN.SLICE TO COM.AI(41);    * No of secs to spend checking CSR's
EQU COM.AI$PORT.ID TO COM.AI(42);       * The port id (DICT ACC) of this port #
EQU COM.AI$DF.XREF.ONE TO COM.AI(43);   * Service to Labeled Tier cross-reference
EQU COM.AI$DF.XREF.EIGHT TO COM.AI(44); * Service to Labeled Tier Xref
EQU COM.AI$INDEXED TO COM.AI(45);       * Service to Tier Indexing Method
EQU COM.AI$DISC.ROLL TO COM.AI(46);     * Roll a truck on a Disconnect W/O
EQU COM.AI$CONN.ROLL TO COM.AI(47);     * Roll a truck on a Connect W/O
EQU COM.AI$CHNG.ROLL TO COM.AI(48);     * Roll a truch on a Service Change W/O
EQU COM.AI$CHAN.DN.BRDCST TO COM.AI(49);* Broadcast Downed Channels to Control sys
EQU COM.AI$SINGLE TO COM.AI(50);        * Single Address vs Multiple Addr's.
EQU COM.AI$ADDR.PER.UNIT TO COM.AI(51); * # of addr. per multi address device
EQU COM.AI$TIER.PER.UNIT TO COM.AI(52); * # of tiers per each on-premise unit
EQU COM.AI$PORT.PASS TO COM.AI(53);     * Password for this account or port.
EQU COM.AI$PAUSE.CHAR TO COM.AI(54);    * Cycle to pause for between characters
EQU COM.AI$PAUSE.LINE TO COM.AI(55);    * Cycles to pause for between lines
EQU COM.AI$PAUSE.RESP TO COM.AI(56);    * Time-out value waiting for a response
EQU COM.AI$MONITOR.PORT TO COM.AI(57);  * Billing computer Monitor Port
EQU COM.AI$GENIE.WINDOW TO COM.AI(58);  * Is the services window avail. for msgs
EQU COM.AI$SEND.ON TO COM.AI(59);       * Send ON packet to interface
EQU COM.AI$SEND.OFF TO COM.AI(60);      * Send OFF packet to interface
EQU COM.AI$DF.TIER.ONE TO COM.AI(61);   * Spigott number of service (1 * 8sp)
EQU COM.AI$DF.TIER.EIGHT TO COM.AI(62); * Spigott of eight addr dvc (or 4 * 2 sp)
EQU COM.AI$DVC.UNIT TO COM.AI(63);      * Devices used by the AI
EQU COM.AI$ERR TO COM.AI(64);           * Last error recorded by monitor
EQU COM.AI$RSVD.65 TO COM.AI(65);       * See COM AI.TYPES for Headends services by this AI. 
~BU.COM.AIP.DIM~
*CODE.SEGMENT: COM.AIP.DIM
*
DIM COM.AIP(75)
~BU.COM.AIP.EQUATES~
*CODE.SEGMENT: COM.AIP.EQUATES
*
* FILE 'COM.AIP' EQUATES - GENERATED 11:21:11  28 MAR 1992
EQU COM.AIP$TIERS TO COM.AIP(1);        * String of tiers to be sent to Headend
EQU COM.AIP$TIERS.FUTR TO COM.AIP(2);   * Tiers to be sent to Headend (Temporary)
EQU COM.AIP$CTLR.PORT TO COM.AIP(3);    * The AI controller's port number
EQU COM.AIP$COMM TO COM.AIP(4);         * Command/function to be done by interface
EQU COM.AIP$ACCT.ID TO COM.AIP(5);      * Account id effected by command
EQU COM.AIP$ADD.ID TO COM.AIP(6);       * Address id effected by command
EQU COM.AIP$WKO.ID TO COM.AIP(7);       * Work Order ID requiring command
EQU COM.AIP$WKO.TYPE TO COM.AIP(8);     * Work Order Type
EQU COM.AIP$WKO.STAT TO COM.AIP(9);     * Work Order Status
EQU COM.AIP$INTFC.CODE TO COM.AIP(10);  * Interface Code (ie EA=Eagle)
EQU COM.AIP$DVC.ID TO COM.AIP(11);      * Device Id of on premise device
EQU COM.AIP$DVC.TYPE TO COM.AIP(12);    * Type of on premise device (1/8)
EQU COM.AIP$INTFC.STAT TO COM.AIP(13);  * Status of interface when finished
EQU COM.AIP$WKO.INST TO COM.AIP(14);    * Work Order Installer
EQU COM.AIP$COMM.DT TO COM.AIP(15);     * Date command was issued
EQU COM.AIP$COMM.TM TO COM.AIP(16);     * Time command was issued
EQU COM.AIP$COMM.C.DT TO COM.AIP(17);   * Date command was completed
EQU COM.AIP$COMM.C.TM TO COM.AIP(18);   * Time command was completed
EQU COM.AIP$COMM.PORT TO COM.AIP(19);   * Hander Port command was issued by
EQU COM.AIP$HEX.COMM TO COM.AIP(20);    * Hexadecimal format of command
EQU COM.AIP$HEX.RSLT TO COM.AIP(21);    * Hexadecimal result code of command
EQU COM.AIP$COMM.RSLT TO COM.AIP(22);   * Result code of command
EQU COM.AIP$ERR TO COM.AIP(23);         * Error code from sending of command
EQU COM.AIP$SVC.ID TO COM.AIP(24);      * Services effected by command
EQU COM.AIP$SVC.FUNC TO COM.AIP(25);    * Function being done to service
EQU COM.AIP$SVC.CHAN TO COM.AIP(26);    * Channels belonging to service
EQU COM.AIP$GROUP TO COM.AIP(27);       * Address ID of AI device where installed
EQU COM.AIP$GROUP.RSLT TO COM.AIP(28);  * Result effecting Address ID or AI
EQU COM.AIP$WKO.SCH.DT TO COM.AIP(29);  * Schedule information from work order
EQU COM.AIP$OPER TO COM.AIP(30);        * Operator requesting interface action
EQU COM.AIP$SVC.ID.FUTR TO COM.AIP(31); * Future Services for this device
EQU COM.AIP$LOG.DISPL TO COM.AIP(32);   * Log has been display by Display Monitor
EQU COM.AIP$LOG.PRINT TO COM.AIP(33);   * Has transaction been printed on the Log
EQU COM.AIP$LOG.ACK.DI TO COM.AIP(34);  * Has the Dispatched Acknowledged this
EQU COM.AIP$LOG.ACK.BR TO COM.AIP(35);  * Has the Branch Mngr Acknowledged this
EQU COM.AIP$INTFC.TYPE TO COM.AIP(36);  * Type of Interface - On-prem or In-prem
EQU COM.AIP$TSTAT TO COM.AIP(37);       * Tier status (0/1) off/on
EQU COM.AIP$TSTAT.FUTR TO COM.AIP(38);  * Tier status future (0/1)
EQU COM.AIP$AIX.LOCATION TO COM.AIP(39);* Address number from ADD to AIX svrcs
EQU COM.AIP$AIX.ID TO COM.AIP(40);      * Item ID of the AIX id
EQU COM.AIP$LOG.REQD TO COM.AIP(41);    * Log transactions in update/abort
EQU COM.AIP$TINDEX TO COM.AIP(42);      * String of tiers to be transmitted to HE
EQU COM.AIP$COMM.SRCE TO COM.AIP(43);    * Source of transaction log
EQU COM.AIP$PORT TO COM.AIP(44);        * Terminal Port number command issued from
EQU COM.AIP$SVC.EXTR TO COM.AIP(45);    * Extra Services / Features
EQU COM.AIP$HEADEND  TO COM.AIP(46);    * Headend command issued for
EQU COM.AIP$EVENT   TO COM.AIP(47);      * Events to be downloaded/uploaded
EQU COM.AIP$EVENT.FUNC TO COM.AIP(48);   * Event function to be done
EQU COM.AIP$DVC.FUNC   TO COM.AIP(49);   * Function  Available on device
EQU COM.AIP$DVC.FUNC.STAT TO COM.AIP(50);* Status of device function
EQU COM.AIP$WKO.SCH.TM TO COM.AIP(51);   * Sched time of WO, POC Encoder Group
EQU COM.AIP$WKO.SCH.TYPE TO COM.AIP(52); * Sched type of WO, POC Encoder Member
EQU COM.AIP$LOG.TRAN.AIL TO COM.AIP(53); * AI Logging Transaction #
EQU COM.AIP$TRAN.SEQ TO COM.AIP(54);     * AI Control Computer Tran Seq #
EQU COM.AIP$WKO.FUNC     TO COM.AIP(55); * Work Order Primary Function
EQU COM.AIP$EVENT.CH TO COM.AIP(56);     * Event Channel # to download
EQU COM.AIP$EVENT.DT TO COM.AIP(57);     * Event Date to download to POC
EQU COM.AIP$EVENT.TM TO COM.AIP(58);     * Start time to download to POC
EQU COM.AIP$EVENT.DUR TO COM.AIP(59);    * The event duration HH:MM
EQU COM.AIP$END.OF.UPLOAD TO COM.AIP(60);* 'z' is end of upload from POC
EQU COM.AIP$INTFC.ERR TO COM.AIP(61);    * Error code or sending hardware
EQU COM.AIP$MAX.PAUSE TO COM.AIP(62); *
EQU COM.AIP$RETRY     TO COM.AIP(63); *
EQU COM.AIP$COL.STATUS TO COM.AIP(64); *
EQU COM.AIP$COMM.CN    TO COM.AIP(65); *
EQU COM.AIP$LOG.SRCE   TO COM.AIP(66); *
EQU COM.AIP$LOG.LOC    TO COM.AIP(67); *
EQU COM.AIP$LOG.ACCT   TO COM.AIP(68); *
EQU COM.AIP$LOG.PROG   TO COM.AIP(69); *
EQU COM.AIP$LOG.PORT   TO COM.AIP(70); *
EQU COM.AIP$INTFC.SET.BY TO COM.AIP(71); *
~BU.CURSOR.POS~
*CODE.SEGMENT: CURSOR.POS
*
*
BEGIN CASE
*
! Select Key
*
CASE TC.FUNC EQ "5"
*
LOOP
POS.RSP = POS.REF<LN + ONE,CL.LOC>
RSP = FIELD(POS.RSP,"|",ONE)
LN.LOC = FIELD(POS.RSP,"|",TWO)
SUB.REF.LOC = FIELD(POS.RSP,"|",3)
WHILE RSP EQ '"' AND CL.LOC GT ONE DO CL.LOC = CL.LOC - ONE REPEAT
PRINT @(RSP.CL,RSP.LN):RVB:RSP:RVE:
CL = POS.LOC<LN + ONE,CL.LOC>
*
! Cursor Positioning
*
CASE INDEX("0123456789",TC.FUNC,ONE)
*
RSP = EMPTY
*
BEGIN CASE
*
! Prev Page
*
CASE TC.FUNC EQ "9"
*
TC.FUNC = EMPTY
*
! Next Page
*
CASE TC.FUNC EQ "3"
*
TC.FUNC = EMPTY
*
! Begining
*
CASE TC.FUNC EQ "7"
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; LN = ZERO; ORIG.LN = -ONE
LOOP UNTIL (POS.LOC<LN + ONE> NE EMPTY AND POS.REF<LN + ONE> NE EMPTY) OR LN EQ ORIG.LN DO
IF ORIG.LN EQ -ONE THEN ORIG.LN = LN
LN = LN + ONE
IF LN GT LN.MAX THEN LN = ZERO
REPEAT
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.LOC = ONE; CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
*
! End
*
CASE TC.FUNC EQ "1"
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; LN = LN.MAX; ORIG.LN = -ONE
LOOP UNTIL (POS.LOC<LN + ONE> NE EMPTY AND POS.REF<LN + ONE> NE EMPTY) OR LN EQ ORIG.LN DO
IF ORIG.LN EQ -ONE THEN ORIG.LN = LN.MAX
LN = LN - ONE
IF LN LT ZERO THEN LN = LN.MAX
REPEAT
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.LOC = CL.MAX; CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
*
! Not Used
*
CASE TC.FUNC EQ "0"
*
!     Up     Down     Left     Right          
*
CASE TRUE
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; CL.CONT = TRUE
ORIG.LN = -LN; ORIG.CL = CL; ORIG.DIR = TC.FUNC
IF NOT(ORIG.LN) THEN ORIG.LN = -1
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
*
IF (TC.FUNC EQ "6" AND CL.LOC GE CL.MAX) OR (TC.FUNC EQ "4" AND CL.LOC LE ONE) THEN
IF TC.FUNC EQ "6" THEN
TC.FUNC = "2"
END ELSE
TC.FUNC = "8"
END
END
*
LOOP
*
! Up or Down
*
IF TC.FUNC EQ "8" OR TC.FUNC EQ "2" THEN
*
TMP = TRUE
*
LOOP
*
LN = LN + (TC.FUNC EQ "2") - (TC.FUNC EQ "8")
IF LN LT ZERO THEN LN = LN.MAX
IF LN GT LN.MAX THEN LN = ZERO
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
*
IF NOT(INDEX("**hdr*bg*fg*key*","*":POS.REF<LN + ONE,CL.MAX>:"*",ONE)) THEN
LOCATE CL IN POS.LOC<LN + ONE> BY "AR" SETTING TMP1 THEN
TMP = FALSE
CL.LOC = TMP1
IF INDEX("**hdr*bg*fg*key*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE) THEN
IF TC.FUNC EQ "2" THEN
TC.FUNC = "6"
END ELSE TC.FUNC = "4"
END
END ELSE
IF ORIG.DIR NE "4" AND ORIG.DIR NE "6" THEN
IF ABS(CL - POS.LOC<LN + ONE,TMP1>) LE 5 THEN TMP = FALSE; CL.LOC = TMP1
END ELSE
TMP = FALSE; CL.LOC = TMP1
END
END
END
*
IF LN EQ ORIG.LN THEN TMP = FALSE
IF (ORIG.DIR EQ "4" OR ORIG.DIR EQ "6") OR ORIG.LN GE ZERO THEN
IF POS.LOC<LN + ONE> NE EMPTY THEN TMP = FALSE
END
*
IF LN EQ ABS(ORIG.LN) THEN ORIG.LN = ABS(ORIG.LN) 
*
WHILE TMP DO REPEAT
*
*
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
IF CL.LOC GT CL.MAX THEN CL.LOC = CL.MAX
CL = POS.LOC<LN + ONE,CL.LOC>
CL.CONT = FALSE
*
END; * of dir is up/dn
*
! Left or Right
*
IF TC.FUNC EQ "4" OR TC.FUNC EQ "6" THEN
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
ORIG.CL = CL
ORIG.CL.LOC = CL.LOC
LOOP
CL.LOC = CL.LOC + (TC.FUNC EQ "6") - (TC.FUNC EQ "4")
* IF NOT(CL.LOC) THEN CL.LOC = CL.MAX
* IF CL.LOC GT CL.MAX THEN CL.LOC = ONE
IF CL.LOC GT CL.MAX THEN CL.LOC = ZERO
* IF NOT(CL.LOC) THEN
IF CL.LOC EQ ORIG.CL.LOC THEN
IF TC.FUNC EQ "4" THEN
TC.FUNC = "8"
* CL.LOC = ONE
END ELSE
TC.FUNC = "2"
* CL.LOC = CL.MAX
END
CL.CONT = FALSE
END ELSE
IF CL.LOC GT CL.MAX THEN CL.LOC = ONE
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
END
CL = POS.LOC<LN + ONE,CL.LOC>
WHILE CL.CONT AND CL NE ORIG.CL DO REPEAT
* IF CL EQ ORIG.CL THEN PRINT BELL:
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
IF TC.FUNC NE "4" AND TC.FUNC NE "6" THEN CL.CONT = TRUE
END
*
IF LN EQ ABS(ORIG.LN) AND CL EQ ORIG.CL THEN PRINT BELL:; CL.CONT = FALSE
*
WHILE CL.CONT DO REPEAT
*
*
CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
PRINT @(CL,LN):
*
END CASE
*
! Special Call
*
CASE TC.FUNC EQ "@"
*
STD.FUNC = "PERFORM"
* SEC.USER$FUNC.NAME = STD.SUBR.NAME
GOSUB LOAD.STD.DATA
GOSUB ENTER.STD.SUBR
RSP = MENU.NAME
*
! Function Key Execute
*
CASE TC.FUNC EQ "E" OR TC.FUNC EQ "C"
*
IF TC.FUNC EQ "C" THEN TC.FUNC = EMPTY
*
! Error
*
CASE TRUE
*
RSP = MENU.NAME
*
*
END CASE
*
~BU.CURSOR.STD~
*CODE.SEGMENT: CURSOR.STD
*
* DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* DATE RELEASED: 01 DEC 90
* DATE REVISED: 9 NOV 92
*
*
* DATE REVISED:  5 JUN 92
*
*        STAT    MEANING
*           0    GOOD RESPONSE
*          -1    REQUEST BACKUP
*          -2    POSITION CHANGE IN INPUT.DATA.SG (RETURN)
*           1    (RSP<1>=??what??) BAD RESPONSE (Format error message in RSP<2>)
*         998    <ESC> WAS PRESSED
*         999    REQUEST KILL
*
* Fields: DEF Default (Original field value)
*         FLD Current field value
*       FIXED Fixed Field Position (Not floating window)
*          CL Column     OLD.CL Old Column
*          LN Line       OLD.LN Old Line
*      CL.LOC Column Location
*  OLD.CL.LOC Old Column Location
*          LH Length     LHM Maximum Length
*     GENERIC Generic Keyboard Entry Mode
*        NUMC Numbers on / off
*          MS Mask for display
*          ML Maximum display length
*   NO.PROMPT Don't prompt (DISP.ONLY)
*        CONV Conversion
*
*   <ALT>+nnn Ascii (PC Numeric Keyboard) Alt key convert [CHAR(x)]
*   <ESC>+n   Function key request
*   <INS> <DEL>
*   <pgUP> <PGdn>
*   <Home> <End>
*   <Num> <Generic>
*   <Caps> <Ctrl> <Tab> <Bs> <Shift> <func99>
*   <Esc> <Del> <Nul>
*   <Push KeyBoard>
*   <STanDard System Call>
*   <SHELL> TCL DOS UNIX OPSYS
*   <DeViCe> or Peripheral Function
*   <SYStem> Call
*   <PrtSc> <Scroll-lock> <Pause> <Break>
*
!!
*
* INPUT TMP:
RSP = EMPTY; DEF = FLD; FLD.LEN = LEN(FLD)
ORIG.LN = RSP.LN; ORIG.CL = RSP.CL
IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO; NUMC = TRUE ELSE NON.NUMERIC.CONV = ONE
*
! Default Handling
*
IF DEF NE EMPTY THEN
IF CONV NE EMPTY THEN
IF NUM(DEF) OR NOT(NON.NUMERIC.CONV) THEN
NUMC = TRUE
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
DEF = OCONV(DEF,MOD.CONV)
IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
END
END
END; * Of DEF
*
! Field Window Control - Column,Line,Length,Mask,Maximum Length
*
IF TC.FILL EQ EMPTY THEN TC.FILL = " "
TC.FUNC = EMPTY
IF RSP.CL EQ CL AND RSP.LN EQ LN THEN
MARK.CL = CL - ONE
IF MARK.CL LT ZERO THEN MARK.CL = ONE
END ELSE MARK.CL = CL
*
TMP = EMPTY
IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,9999]
IF LH[ONE,ONE] MATCHES "1A" THEN TMP = LH[ONE,ONE]; LH = LH[TWO,9999]
IF LHM GT 4 THEN ML = LHM ELSE ML = 4
IF TMP EQ EMPTY THEN TMP = "L#":LH ELSE TMP = TMP:"#":LH
IF MS EQ EMPTY THEN MS = TMP
CAPS = FALSE; EXTK = TRUE
*
! Status Line Processing
*
IF RSP.LN EQ 23 OR LN EQ 23 THEN STAT.LN = 5 ELSE STAT.LN = 23
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
IF EXTK THEN
* 2 Char SEQ
* 3 Char.cn
PRINT @(75,STAT.LN - 4):".":LHM "R#3":
PRINT @(75,STAT.LN - 5):".":MS  "R#3":
IF CONV NE EMPTY THEN PRINT @(71,STAT.LN - ONE):CONV "L#4"
PRINT @(74,STAT.LN - ONE):OCONV(TIME(),"MTS") "R#5":
END
*
IF CAPS THEN PRINT @(75,STAT.LN):RVB:"CAPS":RVE:
IF NUMC OR GENERIC THEN
PRINT @(71,STAT.LN):RVB:"NUM":RVE:
IF GENERIC THEN PRINT @(67,STAT.LN):RVB:"GEN":RVE:
END
*
* ULT ONLY
END
*
!! Process Response
*
!    Display Field Window
*
DISP.DEF = DEF:STR(TC.FILL,LH-LEN(DEF))
*
*
TC.CN = ONE; TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
IF NOT(DEF.SUPP) THEN
IF GENERIC THEN
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):
END ELSE
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
END
END
*
! Load Response
*
*
RSP = EMPTY; CLEAR.BOTTOM.LINE = FALSE
*
*
BEGIN CASE
*
! Don't prompt, use default
*
CASE NO.PROMPT
RSP = DEF
PRINT @(63,STAT.LN):RVB:"DEF":RVE:
*
! Input is in Response Buffer
*
CASE RSPBUF<ONE,ONE> NE EMPTY
RSP = RSPBUF<ONE,ONE,ONE>
DEL RSPBUF<ONE,ONE,ONE>
*
! Generic Terminal Type
*
CASE GENERIC
INPUT RSP,ML:_
IF RSP EQ EMPTY THEN DEFAULT.USED = TRUE; RSP = DEF
*
! Character input loop
*
CASE TRUE
*
! Field Window Control
*
TC.CL = RSP.CL; TC.CONT = TRUE; TC.MOVE = TRUE
TC.STOP = RSP.CL + LH; TC.START = ONE; TC.ADJ = FALSE
CLEAR.BOTTOM.LINE = FALSE
; TC.INS = FALSE
*
! Get next Character
*
LOOP
*
IF TC.CONT THEN
*
TC = EMPTY
*
IF EXTK THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
PRINT @(75,STAT.LN - 3):".":TC.CN "R#3":
* ULT ONLY
END
END
TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
PRINT @(TC.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
*
BEGIN CASE
CASE OPSYS EQ "M"
ECHO OFF
INPUT TC,ONE:
ECHO ON
IF TC EQ EMPTY THEN TC = CHAR(13)
CASE OPSYS EQ "U"
ECHO OFF
TC = OCONV(TC,"U51EA")
ECHO ON
CASE TRUE
INPUT TC,ONE:
END CASE
*
! Process Character
*
TC.SEQ = ("000":SEQ(TC)) "R#3"
*
! Keyboard Conversion/Control
*
* Table look-up
*
LOCATE TC.SEQ IN CURSOR.KEYS<TWO> SETTING TC.LOC THEN
TC.OUT = CURSOR.KEYS<3,TC.LOC>
IF (TC.OUT EQ "G" OR TC.OUT EQ "C") OR NOT(GENERIC) THEN
IF NUM(TC.OUT) THEN
IF NUMC THEN
TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE
TC.CONT = FALSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
END
END ELSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
IF TC.OUT EQ "C" THEN TC.CONT = FALSE
END
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
*
* End of Table look-up
END; * of TC.CONT
*
! Exit for character Input LOOP (WHILE TC.CONT)
*
WHILE TC.CONT DO
*
! System Character
*
IF TC.LOC THEN
*
BEGIN CASE
*
CASE TC.FUNC EQ "|"
*
IF LEN(FLD) GT TC.CN - ONE THEN
*
TC = FLD[TC.CN,ONE]
TC.SEQ = SEQ(TC)
TC.LOC = FALSE; TC.OUT = EMPTY
IF TC.INS THEN
TC.INS = FALSE
PRINT @(60,STAT.LN):SPACE(3):@(MARK.CL,LN):
END
*
END ELSE PRINT BELL:; TC = EMPTY; TC.SEQ = EMPTY
*
CASE TC.FUNC EQ "<"
*
IF TC.CN GT ONE THEN
PRINT @(TC.CL,RSP.LN):TCO:
TC.CN = TC.CN - ONE
TC.CL = TC.CL - ONE
RSP = RSP[ONE,TC.CN - ONE]
IF TC.INS THEN
TC.INS = FALSE
PRINT @(60,STAT.LN):SPACE(3):@(MARK.CL,LN):
END
***IF TC.CL LT RSP.CL OR TC.CN LT TC.START THEN TC.ADJ = TRUE
IF (TC.CL LT RSP.CL) OR (TC.START GT ONE AND TC.CL LT RSP.CL + TWO) THEN TC.ADJ = TRUE
END ELSE
PRINT BELL:
* TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
END
*
CASE TC.FUNC EQ "\"
*
RSP = EMPTY; FLD = EMPTY; CLEAR.FLAG = TRUE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ONE
*
CASE TC.FUNC EQ "R"
FLD = DEF; RSP = EMPTY; CLEAR.FLAG = FALSE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ONE
*
CASE TC.FUNC EQ "I"
*
IF TC.INS THEN
TC.INS = FALSE
PRINT @(60,STAT.LN):SPACE(3):@(MARK.CL,LN):
END ELSE
TC.INS = TRUE
PRINT @(60,STAT.LN):RVB:"INS":RVE:@(MARK.CL,LN):
END
*
CASE TC.FUNC EQ "D"
*
IF LEN(FLD) GT TC.CN - ONE THEN
FLD = FLD[ONE,TC.CN - ONE]:FLD[TC.CN + ONE,9999]
END
TC.ADJ = TRUE; TC.MOVE = FALSE
*
CASE TC.FUNC EQ "S"
*
GOSUB SYS.DEBUG
*
CASE TC.FUNC EQ "A"
*
PRINT @(48,STAT.LN):RVB:"Alt":RVE:"   ":@(51):
INPUT TMP1,3:_
IF NUM(TMP1) THEN
IF TMP1 GE ZERO AND TMP1 LE 255 THEN
TC = CHAR(TMP1); TC.SEQ = SEQ(TC); TC.LOC = FALSE
END ELSE PRINT BELL:
END ELSE PRINT BELL:
PRINT @(48,STAT.LN):SPACE(3):@(MARK.CL,LN):
*
CASE TC.FUNC EQ "N"
*
IF NOT(NUMC) THEN
PRINT @(71,STAT.LN):RVB:"NUM":RVE:@(MARK.CL,LN):
NUMC = TRUE
END ELSE
PRINT @(71,STAT.LN):SPACE(3):@(MARK.CL,LN):
NUMC = FALSE
END
*
CASE TC.FUNC EQ "G"
*
IF NOT(GENERIC) THEN
PRINT @(67,STAT.LN):RVB:"GEN":RVE:@(MARK.CL,LN):
GENERIC = TRUE
END ELSE
PRINT @(67,STAT.LN):SPACE(3):@(MARK.CL,LN):
GENERIC = FALSE
END
*
CASE TC.FUNC EQ "E"
*
TMP1 = DCOUNT(CURSOR.KEYS<5>,VM)
PRINT @(ZERO,STAT.LN):RVB:"Enter function number (0 to continue): " "L#40":RVE:
LOOP
PRINT @(40,STAT.LN):
INPUT TC.FUNC.NUM,ONE:
IF NUM(TC.FUNC.NUM) THEN
IF TC.FUNC.NUM LT ZERO OR TC.FUNC.NUM GT TMP1 THEN TC.FUNC.NUM = "?"
END
WHILE NOT(NUM(TC.FUNC.NUM)) DO PRINT BELL: REPEAT
PRINT @(ZERO,STAT.LN):SPACE(40):@(MARK.CL,LN):
IF TC.FUNC.NUM THEN
RSP = CURSOR.KEYS<5,TC.FUNC.NUM>; TC.CONT = FALSE
EXEC.DESC = "F":TC.FUNC.NUM:" - ":CURSOR.KEYS<4,TC.FUNC.NUM>
EXEC.VERB = CURSOR.KEYS<5,TC.FUNC.NUM>
END
*
CASE TC.FUNC EQ "@"
*
PRINT @(ZERO,STAT.LN):CLL:RVB:"Enter the function name: ":RVE:BELL:
INPUT STD.SUBR.NAME:
IF STD.SUBR.NAME EQ EMPTY THEN STD.SUBR.NAME = SEC.USER$FUNC.NAME
IF STD.SUBR.NAME NE EMPTY THEN
* STD.FUNC = "PERFORM"
SEC.USER$FUNC.NAME = STD.SUBR.NAME; TC.CONT = FALSE
* GOSUB LOAD.STD.DATA
* GOSUB ENTER.STD.SUBR
END ELSE
TC.ADJ = TRUE
* PRINT @(ZERO,STAT.LN):CLL:
END; * Of routine name
*
CASE TRUE
*
TC.FUNC = EMPTY
*
END CASE
*
END; * Of TC.FUNC
*
! Not a system character
*
IF NOT(TC.LOC) AND LEN(TC) THEN
*
IF TC.SEQ GE 28 THEN
*
IF TC.SEQ LE 30 THEN
TC.SEQ = TC.SEQ + 224
TC = CHAR(TC.SEQ)
IF TT EQ "D" OR TT EQ "R" THEN PRINT TC:
END
*
IF TC.INS THEN
TMP = LEN(FLD)
IF TMP LT TC.CN - ONE THEN
FLD = FLD:RSP[TMP + ONE,9999]
END
FLD = FLD[ONE,TC.CN - ONE]:TC:FLD[TC.CN,9999]
TC.ADJ = TRUE; TC.MOVE = FALSE
END
*
RSP = RSP:TC
TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
PRINT @(TC.CL,RSP.LN):TC:@(MARK.CL,LN):
TC.CN = TC.CN + ONE
TC.CL = TC.CL + ONE
*
END; * Of ge 28
*
END; * Of no TC.OUT
*
IF TC.CL GE TC.STOP OR TC.ADJ THEN
IF FIXED THEN
TC.START = ONE; RSP.LN = 23; RSP.CL = ONE; TMP = TC.CN - ONE
CLEAR.BOTTOM.LINE = 23
IF STAT.LN EQ 23 THEN STAT.LN = 5
PRINT @(ZERO,RSP.LN):CLL:RVB:">":RVE:
END ELSE
IF NOT(TC.MOVE) AND TC.CL LT TC.STOP THEN
TC.MOVE = TRUE
TMP = TC.CN - TC.START
END ELSE IF TC.CL GE TC.STOP OR TC.START NE ONE THEN
TMP = INT(LH / TWO)
END ELSE TMP = ZERO
IF TMP GT TC.CN - ONE THEN TMP = TC.CN - ONE
TC.START = TC.CN - TMP
* INPUT TMP.RSP:
END
TC.CL = RSP.CL + TMP
TMP1 = FLD[TC.CN,LH - TMP]
TMP1 = TMP1:STR(TC.FILL,LH - TMP - LEN(TMP1))
PRINT @(RSP.CL,RSP.LN):RSP[TC.START,LH]:TMP1:@(TC.CL,RSP.LN):
TC.ADJ = FALSE
TC.MOVE = TRUE
END
*
IF TC.CN - TWO EQ LHM OR TC.CN - TWO EQ LHM + ONE THEN 
TEXT = "No more than ":LHM:" characters please"
PRINT @(ZERO,STAT.LN):TEXT "L#40":BELL:@(MARK.CL,LN):
CLEAR.BOTTOM.LINE = STAT.LN
END
*
! End of system / non-system character
*
IF EXTK THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
PRINT @(75,STAT.LN - 3):".":TC.CN "R#3":
PRINT @(75,STAT.LN - TWO):".":TC.SEQ "R#3":
PRINT @(74,STAT.LN - ONE):OCONV(TIME(),"MTS") "R#5":
* ULT ONLY
END
END
*
! Repeat for Character Input LOOP (WHILE TC.CONT)
*
REPEAT
*
IF (TC.CN EQ ONE AND (TC.FUNC EQ "C" OR TC.FUNC EQ EMPTY)) AND NOT(CLEAR.FLAG) THEN DEFAULT.USED = TRUE; RSP = DEF
IF CLEAR.BOTTOM.LINE THEN PRINT @(ZERO,CLEAR.BOTTOM.LINE):CLL:; CLEAR.BOTTOM.LINE = FALSE
* IF TC.START NE ONE THEN PRINT @(RSP.CL,RSP.LN):RSP[ONE,LH]:
*
END CASE
*
! End of CASES  NO.PROMPT,RSPBUF,GENERIC,Character.Input.LOOP
*
*   END; * Of NO.PROMPT
*
IF TC.FUNC EQ EMPTY OR FIXED THEN
PRINT @(ORIG.CL,ORIG.LN):RSP MS:
END
RSP.CL = ORIG.CL; RSP.LN = ORIG.LN
FLD = RSP
*
*
~BU.EFT.EQUATES~
*CODE.SEGMENT: ?
* FILE 'EFT' EQUATES - GENERATED 10:51:41  04 JUL 1985
EQU EFT$STAT TO EFT(1);                 * EFT Status
EQU EFT$LAST.CALC.DATE TO EFT(2);       * Last EFT calculation date
EQU EFT$LAST.CALC.AMT TO EFT(3);        * Amount of last EFT calculation
EQU EFT$DRAW.DATES TO EFT(4);           * Date of EFT drawing
EQU EFT$DRAW.AMTS TO EFT(5);            * Amount of EFT drawing
EQU EFT$LAST.RETRY.DATE TO EFT(6);      * Date of last EFT retry
EQU EFT$ERROR.FLAG TO EFT(7);           * Error flag or retry count
EQU EFT$START.DATE TO EFT(8);           * Start date for EFT
EQU EFT$BANK.ACCT.NUM TO EFT(9);        * Bank account number
EQU EFT$BANK.ACCT.NAME TO EFT(10);      * Name of bank account (if diff. to sub.)
EQU EFT$DRAW.DUE.DATES TO EFT(11);      * Due dates of EFT drawing
~BU.GENERAL.COMMON.AREA~
*CODE.SEGMENT: ?
COMMON ACG(10),ACT(50),ADD(30),ASH(20),ATR(20),DLQ(10),DVC(20),EFT(10),RTE(10),STT(10),SVC(10),SVS(20),TAX(10),TPL(10),WKO(50),WKP(10),SAVE.ACG(10),SAVE.ACT(50),SAVE.ADD(30),SAVE.ATR(20),SAVE.WKO(50)
COMMON ACG.ID,ACT.ID,ADD.ID,STT.ID,TPL.ID,WKO.ID,SAVE.ACG.ID,SAVE.ACT.ID,SAVE.ADD.ID,SAVE.WKO.ID
COMMON ACG.FILE,ACT.FILE,ACX.FILE,ADD.FILE,ASH.FILE,ATH.FILE,ATR.FILE,CNT.FILE,DLQ.FILE,DVC.FILE,EFT.FILE,PAR.FILE,RTE.FILE,STT.FILE,STX.FILE,SVC.FILE,SVS.FILE,TAX.FILE,TPL.FILE,WKH.FILE,WKO.FILE,WKP.FILE,LCK.FILE
COMMON CO.DATA,RSP,REF,NEXT.CALL,ALLOWED,ALLOW.MSG,PREV.ID,PRIOR.TNT.ID,PRIOR.ADD.ID,PEND.WO.NUMS,NEW.ADD,SERVICE.TOP,UPDATED,STAT
~BU.INTFC.CHECK~
*CODE.SEGMENT: AI.INTFC.CHECK
* USED BY: AI.HANDLER
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* * COM.AI.ERR.TEXT<-ONE> = "The AI Handler is ok."
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
DT = DATE(); TM = TIME()
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
*   8640 86200     8641 01000  CURR DT/TM
*   8640 86000     8640 86200  FUNC DT/TM
*   ---- -----     ---- -----
*      0   200        1 85200-
*                 86400
*                 85200-
*                  1200
*
AI.CHK.ERR = EMPTY
*
BEGIN CASE
*
CASE COM.AI$ON.OFF.STAT EQ AI.ON
COM.AI.ON = TRUE
!
*
IF COM.AI$MAX.PAUSE + 4 * COM.AI$STD.PAUSE LE COM.AI.RUN.ELP THEN
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, AI hung for ":OCONV(COM.AI.RUN.ELP,"MTS"):" hours!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT EQ AI.UP THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* *COM.AI.ON = FALSE
* END
COM.AI.UP = FALSE
END ELSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.UP = TRUE
AI.CHK.ERR<-ONE> = ZERO
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and UP."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.UP = FALSE
AI.CHK.ERR<-ONE> = 3
* COM.AI.ERR.TEXT<-ONE> = "The AI is ON and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
AI.CHK.ERR<-ONE> = 191
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END CASE
*
END
*
!
*
CASE COM.AI$ON.OFF.STAT EQ AI.OFF
COM.AI.ON = FALSE
COM.AI.UP = FALSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
AI.CHK.ERR<-ONE> = 102
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and UP!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
AI.CHK.ERR<-ONE> = TWO
* COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and DN."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
AI.CHK.ERR<-ONE> = 191
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
*
CASE TRUE
AI.CHK.ERR<-ONE> = 181
* COM.AI.ERR.TEXT<-ONE> = "The AI is neither ON nor OFF!"
* COM.AI.ERR.TYPE<-ONE> = "DATA"
* IF COM.AI$ON.OFF.STAT NE AI.OFF THEN COM.AI.ERR.FUNC<-ONE> = AI.OFF ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
END CASE
*
!
BEGIN CASE
*
CASE COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
AI.CHK.ERR<-ONE> = 101
* COM.AI.ERR.TEXT<-ONE> = "Failure, No (":COM.AI.RUN.ELP:") Acknowledgment!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
*
!
*
CASE COM.AI$ON.OFF.STAT NE COM.AI$ON.OFF
COM.AI.ON.OFF.ELP = ((DT - COM.AI$ON.OFF.DT) * 86400) + (TM - COM.AI$ON.OFF.TM)
IF COM.AI.ON.OFF.ELP GT COM.AI$MAX.PAUSE + 3 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 111
* COM.AI.ERR.TEXT<-ONE> = "Failure logging ":COM.AI$ON.OFF:"! (":COM.AI.ON.OFF.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* COM.AI.ERR.FUNC<-ONE> = COM.AI$ON.OFF
END ELSE
AI.CHK.ERR<-ONE> = 11
* COM.AI.ERR.TEXT<-ONE> = "The AI is logging ":COM.AI$ON.OFF:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$UP.DN.STAT NE COM.AI$UP.DN
COM.AI.UP.DN.ELP = ((DT - COM.AI$UP.DN.DT) * 86400) + (TM - COM.AI$UP.DN.TM)
IF COM.AI.UP.DN.ELP GT COM.AI$MAX.PAUSE + 2 * COM.AI$STD.PAUSE THEN
AI.CHK.ERR<-ONE> = 121
* COM.AI.ERR.TEXT<-ONE> = "Failure going ":COM.AI$UP.DN:"! (":COM.AI.UP.DN.ELP:")"
* COM.AI.ERR.TYPE<-ONE> = "TOUT"
* * COM.AI.ERR.FUNC<-ONE> = COM.AI$UP.DN
* IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
* COM.AI.ERR.FUNC<-ONE> = EMPTY
* END
END ELSE
AI.CHK.ERR<-ONE> = 12
* COM.AI.ERR.TEXT<-ONE> = "The AI is going ":COM.AI$UP.DN:"."
* COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
TMP = "AI.OFF.":PORT.KEY
READV OFF.FLAG FROM COM.FILE,TMP,ONE ELSE
TMP = "AI.OFF.ALL"
READV OFF.FLAG FROM COM.FILE,TMP,ONE ELSE OFF.FLAG = FALSE
END
*
IF OFF.FLAG THEN
WRITEV "Done ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS") ON COM.FILE,TMP,TWO
AI.CHK.ERR<-ONE> = 131
* COM.AI.ERR.TEXT<-ONE> = "Interface Off Flag is set!"
* COM.AI.ERR.TYPE<-ONE> = "PORT"
* COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
IF AI.CHK.ERR NE EMPTY THEN
*
TMP.CN = ZERO; TMP.CN.MAX = DCOUNT(AI.CHK.ERR,AM)
*
LOOP TMP.CN = TMP.CN + ONE WHILE TMP.CN LE TMP.CN.MAX DO
COM.AI.ERR<-ONE> = AI.CHK.ERR<ONE>
LOCATE AI.CHK.ERR<ONE> IN COM.AIHERR$RCVD<ONE> SETTING ERR.LOC ELSE ERR.LOC = ONE
COM.AI.ERR.TEXT<-ONE> = COM.AIHERR$DESC<ONE,ERR.LOC>
COM.AI.ERR.TYPE<-ONE> = COM.AIHERR$TYPE<ONE,ERR.LOC>
TMP = COM.AIHERR$FUNC<ONE,ERR.LOC>
IF TMP EQ AI.DN AND COM.AI$UP.DN.STAT EQ AI.DN THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE IF TMP EQ AI.OFF AND COM.AI$ON.OFF.STAT EQ AI.OFF THEN
COM.AI.ERR.FUNC<-ONE> = EMPTY
END ELSE
COM.AI.ERR.FUNC<-ONE> = TMP
END
DEL AI.CHK.ERR<ONE>
REPEAT
*
END
*
!
*
*
*  IF NOT(LEN(COM.AI.ERR)) THEN
*
CHECK.FMT = "L#":CHECK.LEN
*
*
EXEC.IN = EMPTY; EXEC.OUT = EMPTY; EXEC.VERB = EMPTY
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
EXEC.VERB = 'SSELECT COM EQ "AI*]" BY COMM.DT BY COMM.TM'
*
IF COM.AI.ERR.DISP THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Selecting Active Ports" CHECK.FMT:RVE
END
*
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > COM.ID.LIST, //OUT. > EXEC.OUT
*
* REV ONLY
* PERFORM EXEC.VERB
*
END ELSE
*
COM.ID.LIST = COM.AI$FUNC.PORT
IF COM.ID.LIST EQ EMPTY THEN COM.ID.LIST = PORTS.LIST
*
END; * of fast disp
*
IF COM.AI.ERR.DISP THEN
*
CHECK.LN = CHECK.LN.MIN
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT EXEC.VERB CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF LEN(EXEC.OUT) THEN
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE> CHECK.FMT; CHECK.LN = CHECK.LN + ONE
DEL EXEC.OUT<ONE>
REPEAT
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
END; * of fast disp
*
IF CHECK.LN.HI GT CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT
NEXT TMP
END
*
CHECK.LN.HI = CHECK.LN; CHECK.LN = CHECK.LN.MIN
*
RQM
*
END; * cnt.ai.err.disp
*
*
COM.AI.PORT.REC = EMPTY
COM.AIP.PORT.FIRST = TRUE; PORT.CONT = TRUE
* PORTS.LIST = EMPTY
*
LOOP
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
* ULT ONLY
READNEXT COM.ID FROM COM.ID.LIST ELSE COM.ID = "@@@"
*
* REV ONLY
* READNEXT COM.ID ELSE COM.ID = "@@@"
*
COM.AIP.ID = COM.ID
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
*
*
END ELSE
*
IF COM.ID.LIST EQ EMPTY THEN COM.ID = "@@@" ELSE
COM.ID = "AI*":AI.CODE:"*":COM.ID.LIST<ONE,ONE>
COM.AIP.ID = COM.ID
COM.AIP.PORT = COM.ID.LIST<ONE,ONE>
DEL COM.ID.LIST<ONE,ONE>
LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
IF COM.AI.ERR.DISP THEN PRINT BELL:
END
END
*
END; * of fast disp
*
WHILE COM.ID NE "@@@" DO
*
** ** ** IF COM.AIP.ID MATCHES '"AI*"3N"*"3N' THEN
IF FIELD(COM.AIP.ID,"*",ONE) EQ "AI" AND FIELD(COM.AIP.ID,"*",TWO) EQ AI.CODE AND NUM(FIELD(COM.AIP.ID,"*",3)) THEN
*
IF AI.SCAN THEN
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE,LCK.STAT)
UNTIL NOT(LCK.STAT) DO REPEAT
END ELSE LCK.STAT = FALSE
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
COM.AIP.ON.FILE = TRUE
*
IF CNT.TST$ID THEN PRINT @(60,20):"Cnt Aip ":COM.AIP.ID "L#18":
*
*@@@ BUILD PORT RECORD
*
TMP = FALSE
IF FAST.DISPLAY OR COM.AIP$COMM.PORT NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN TMP = TRUE
IF ((COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND ((((DT - COM.AIP$COMM.C.DT) * 86400) + (TM - COM.AIP$COMM.C.TM)) LT 300)) THEN TMP = TRUE
IF TMP THEN
*
IF PORT.CONT AND COM.AI.ERR.DISP THEN
*
IF PORTS.LIST.BUILD OR COM.AIP.PORT.FIRST OR CHECK.LN GE CHECK.LN.MAX THEN
COM.AIP.PORT.FIRST = FALSE
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Oper. Po Typ Stat A/I Dvc. Fnc" CHECK.FMT:RVE:
END
*
*
IF CHECK.LN GE CHECK.LN.MAX THEN
CHECK.LN = CHECK.LN.MIN
IF STATUS.CYCLE THEN
RQM; RQM; RQM
END ELSE
LOOP
PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(ZERO,23):" " CHECK.FMT:
IF RSP EQ EMPTY THEN PORT.CONT = FALSE ELSE ALREADY.DISPLAYED = TRUE
END; * OF STATUS CYCLE
END; * OF CHECK.LN GT CHECK.LN.MAX
*
*
IF PORT.CONT THEN
TMP = COM.AIP$OPER "R#5":" ":FIELD(COM.AIP.ID,"*",3) "R#2":" ":COM.AIP$COMM "R#3":" ":COM.AIP$INTFC.STAT<ONE,ONE> "L#4":" ":COM.AIP$INTFC.CODE "L#2":COM.AIP$INTFC.TYPE "L#1":" ":COM.AIP$DVC.TYPE "L#4":" ":COM.AIP$SVC.FUNC "L#3"
PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END; * OF PORT.CONT
*
END; * OF PORT.CONT AND ERR.DISP
*
*
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
*
IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN
*
IF COM.AIP.ELP GT TWO * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
*
IF AI.SCAN THEN
*
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE,LCK.STAT)
*
IF NOT(LCK.STAT) THEN
*
COM.AI.ERR<-ONE> = 371
COM.AI.ERR.TYPE<-ONE> = "TOUT"
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "DONE"
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "WAIT"
COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "RVRS"
COM.AIP$COMM.PORT = "RVRS"
*
CASE COM.AIP$INTFC.STAT EQ "COMP"
* Should never happen
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = "RVRS"; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "XCEL"
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE TRUE
*
END CASE
*
IF LEN(AI.CHK.ERR) THEN
AI.CHK.ERR = 371:AM:AI.CHK.ERR
END ELSE AI.CHK.ERR = 371
*
COM.AI.ERR.TEXT<-ONE> = "Failure at (":COM.AIP.ELP:") Port ":COM.AIP.PORT:" ":COM.AIP$INTFC.STAT<ONE,ONE>:"!"
*
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AIP$ERR = "371":VM:COM.AIP$ERR
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,COMMPORT,AI.SRCE,LCK.FILE,LCK.TYPE)
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE)
*
END; * OF LCK.STAT
*
END ; * OF AI.SCAN
*
END; * OF ELP
END; * OF NO C.DT OR C.TM
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST<ONE> SETTING TMP ELSE
PORTS.LIST<ONE,-ONE> = COM.AIP.PORT
END
*
END; * OF NO C.DT OR C.TM
*
*
END ELSE
* NOT ON FILE
COM.AIP.ON.FILE = FALSE
MAT COM.AIP = EMPTY
END
*
IF AI.SCAN AND NOT(LCK.STAT) THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LCK.FILE)
END
*
END; * OF MATCHES AI*999*999
*
REPEAT
*
IF COM.AI.ERR.DISP THEN
IF CHECK.LN.HI GE CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT:
NEXT TMP
CHECK.LN.HI = CHECK.LN
END
END
*
*  END; * OF NOT(COM.AI.ERR)
*
PORTS.LIST.BUILD = FALSE
*
*
~BU.SH.COMMON.AREA~
*CODE.SEGMENT: ?
COMMON PNUM,REF.NUM,PMPT.REFS,PMPT.LOCS,FL,AC,VC,SC,ED.VC
COMMON PMPT(5,50),FILE(10),ID(5),ATTR(10,100),SCR.LINES(23),ITEM(100)
COMMON FLD,RSP,TEXT,MODE,STAT,CO.NAME,CO.NUM,SUBDATA,FILE.NAMES
COMMON ADD.OK,CHG.OK,DEL.OK,WORK(10)
~BU.STANDARD.FUNCTIONS~
*CODE.SEGMENT: ?
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13),
SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~BU.STD~
*CODE.SEGMENT: STANDARD.FUNCTIONS
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13),
ESC TO CHAR(27),SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254),
STXC TO CHAR(2),
TRUE TO 1, FALSE TO 0,TWO TO 2, ONE TO 1, ZERO TO 0, EMPTY TO ""
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
RUN.TYPE = "S"; PHANTOM.RUN = FALSE; GENERIC = FALSE
TT = SYSTEM(7); CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN
CLB = @(0,23); CLB0 = @(0,21); CLB1 = @(0,22); CLB2 = @(0,23)
END ELSE
CLB = @(0,23):CLL; CLB0 = @(0,21):CLL; CLB1 = @(0,22):CLL; CLB2 = @(0,23):CLL
END
*
BEGIN CASE
CASE TT EQ "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE TT EQ "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE TT EQ "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~BU.STD.DVC~
*CODE.SEGMENT: STANDARD.FUNCTIONS.DVC
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13),
ESC TO CHAR(27),SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254),
STXC TO CHAR(2),
TRUE TO 1, FALSE TO 0,TWO TO 2, ONE TO 1, ZERO TO 0, EMPTY TO ""
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
RUN.TYPE = "S"; PHANTOM.RUN = FALSE; GENERIC = FALSE
TT = SYSTEM(7); CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN
CLB = @(0,23); CLB0 = @(0,21); CLB1 = @(0,22); CLB2 = @(0,23)
END ELSE
CLB = @(0,23):CLL; CLB0 = @(0,21):CLL; CLB1 = @(0,22):CLL; CLB2 = @(0,23):CLL
END
*
BEGIN CASE
CASE TT EQ "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE TT EQ "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
* IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE TT EQ "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~BU.SYS.INCL.LOAD.TST~
*CODE.SEGMENT: SYS.INCL.LOAD.TEST.ITEM
*
* AUTHOR: David Horsman
*
*
* REMOVE THESE VARIABLES
TEST.FL = ZERO; LIST.NAME = EMPTY; DIS.SUB = ZERO; DIS.ITEM = ZERO
*  TF         ; TST<TST$LIST.NAME>; LBL.DISP     ; ID.DISP
DIS.PROG = ZERO; TIMING = ZERO; BREAK.ON = ZERO
*TST<TST$RTN>  ; TST<TST$TIMING>; TST<TST$BREAK>
*
* These variable are handled here or s/b replaced
* TST<TST$TA>
BREAK.ON = ZERO;   WKO.TEST = ZERO
*TST<TST$BREAK>;   TST$AM = 12 & TST$VM = 1
*
*
TST.ID = "SYSTEM.TEST"
READ TST FROM CNT.FILE,TST.ID ELSE TST = EMPTY
*
LBL.DISP = FALSE; TST.CR = FALSE; ID.DISP = FALSE; FILE.UPD = FALSE
TF = EMPTY
IF LEN(TST<TST$AM,TST$VM>) THEN TF = TST<TST$AM,TST$VM>
IF TF EQ 9 THEN TF = EMPTY
*
*
IF TF EQ EMPTY THEN
TF = FALSE
IF TST<TST$SYS> GT TF THEN TF = TST<TST$SYS>
IF TST<TST$APPL> GT TF THEN TF = TST<TST$APPL>
IF TF THEN
LBL.DISP = TST<TST$LBL>
IF LBL.DISP GE 3 THEN TST.CR = TRUE ELSE TST.CR = FALSE
IF LBL.DISP GE 5 THEN ID.DISP = TRUE
FILE.UPD = TST<TST$FILE>
IF FILE.UPD THEN ID.DISP = TRUE
END
END ELSE
IF TF GE 3 THEN TST.CR = TRUE
IF TF GE 1 THEN LBL.DISP = TRUE
IF TF GE 5 THEN ID.DISP = TRUE
IF TF GE 6 AND TF LE 8 THEN FILE.UPD = TF
END
*
!
*
IF TST<TST$BREAK> THEN
* BREAK IS ON
END ELSE
* BREAK IS OFF
END
IF TST<TST$TA> THEN
*TYPE AHEAD IS ON
END ELSE
* TYPE AHEAD IS OFF
END
*
IF TF THEN
TEST.FL = 1
DIS.PROG  = TST<TST$RTN>
DIS.SUB   = TST<TST$LBL>
DIS.ITEM  = TST<TST$FILE>
LIST.NAME = TST<TST$LIST.NAME>
TIMING    = TST<6>
BREAK.ON  = TST<7>
WKO.TEST  = TST<8>
PRINT @(0,22):CLL:RVB:("Rtn ":TST<TST$RTN>:" SubRtn ":TST<TST$LBL>:" Item ":TST<TST$FILE>:" List ":TST<TST$LIST.NAME>) "L#75":RVE:
PRINT @(0,23):CLL:RVB:("Tst ":TST<TST$SYS>:"Timing ":TST<6>:" Break ":TST<7>:" WKO ":TST<8>:" Appl ":TST<TST$APPL>) "L#75":RVE:
*
IF TST.CR THEN PRINT CLB:"SYS.INCL.LOAD.TST <cr> ":; INPUT TMP:
*
RQM
END
!
~BU1.CURSOR.STD~
X*CODE.SEGMENT: CURSOR.STD
*
* DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* DATE RELEASED: 01 DEC 90
* DATE REVISED: 9 NOV 92
*
*
* DATE REVISED:  5 JUN 92
*
*        STAT    MEANING
*           0    GOOD RESPONSE
*          -1    REQUEST BACKUP
*          -2    POSITION CHANGE IN INPUT.DATA.SG (RETURN)
*           1    BAD RESPONSE (ERROR MESSAGE IN RSP<2>)
*         998    <ESC> WAS PRESSED
*         999    REQUEST KILL
*
* Fields: DEF Default (Original field value)
*         FLD Current field value
*         DEF Original field value
*          CL Column     OLD.CL Old Column
*          LN Line       OLD.LN Old Line
*      CL.LOC Column Location
*  OLD.CL.LOC Old Column Location
*          LH Length     LHM Maximum Length
*        NUMC Numbers on / off
*          MS Mask for display
*          ML Maximum display length
*   NO.PROMPT Don't prompt (DISP.ONLY)
*        CONV Conversion
*
!
*
INPUT TMP:
RSP = EMPTY; DEF = FLD; FLD.LEN = LEN(FLD)
IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO; NUMC = TRUE ELSE NON.NUMERIC.CONV = ONE
IF DEF NE EMPTY THEN
IF CONV NE EMPTY THEN
IF NUM(DEF) OR NOT(NON.NUMERIC.CONV) THEN
NUMC = TRUE
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
DEF = OCONV(DEF,MOD.CONV)
IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
END
END
END
IF TC.FILL EQ EMPTY THEN TC.FILL = " "
IF RSP.CL EQ CL AND RSP.LN EQ LN THEN
MARK.CL = CL - ONE
IF MARK.CL LT ZERO THEN MARK.CL = ONE
END ELSE MARK.CL = CL
*
IF MS EQ EMPTY THEN
IF LH[ONE,ONE] MATCHES "1A" THEN
MS = LH[ONE,ONE]:"#":LH[TWO,9999]; LH = LH[TWO,9999]
END ELSE MS = "L#":LH
END
*
IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,9999]
IF LH GT 4 THEN ML = LH ELSE ML = 4
*
DISP.DEF = DEF:STR(TC.FILL,LH-LEN(DEF))
*
IF NO.PROMPT THEN
RSP = DEF
END ELSE
*
TC.CN = ZERO; TCO = FLD[TC.CN + ONE,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
IF GENERIC THEN
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):
END ELSE
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
END
*
BEGIN CASE
*
*CASE NOT(OPSYS EQ "U" OR OPSYS EQ "M") OR LH EQ LHM
CASE NOT(OPSYS EQ "U" OR OPSYS EQ "M") OR GENERIC
INPUT RSP,ML:_
IF RSP EQ EMPTY THEN DEFAULT.USED = TRUE; RSP = DEF
*
CASE TRUE
*
! Character input loop
*
RSP = EMPTY; TC.CL = RSP.CL; TC.CONT = TRUE; TC.MOVE = TRUE
TC.STOP = RSP.CL + ML; TC.START = ONE; TC.ADJ = FALSE
CLEAR.BOTTOM.LINE = FALSE; TC.INS = FALSE
IF NUMC OR GENERIC THEN
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF NUMC THEN PRINT @(60,TMP):"   ":RVB:"NUM":RVE:"   ":@(MARK.CL,LN):
IF GENERIC THEN PRINT @(40,TMP):"   ":RVB:"GEN":RVE:"   ":@(MARK.CL,LN):
END
*
LOOP
*
IF TC.CONT THEN
*
TC = EMPTY
TCO = FLD[TC.CN + ONE,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
PRINT @(TC.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
*
BEGIN CASE
CASE OPSYS NE "U"
ECHO OFF
INPUT TC,ONE:
ECHO ON
IF TC EQ EMPTY THEN TC = CHAR(13)
CASE TRUE
ECHO OFF
TC = OCONV(TC,"U51EA")
ECHO ON
END CASE
*
TC.SEQ = ("000":SEQ(TC)) "R#3"
*
LOCATE TC.SEQ IN CURSOR.KEYS<TWO> SETTING TC.LOC THEN
TC.OUT = CURSOR.KEYS<3,TC.LOC>
IF (TC.OUT EQ "G" OR TC.OUT EQ "C") OR NOT(GENERIC) THEN
IF NUM(TC.OUT) THEN
IF NUMC THEN
TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE
TC.CONT = FALSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
END
END ELSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
IF TC.OUT EQ "C" THEN TC.CONT = FALSE
END
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
*
END; * of TC.CONT
*
WHILE TC.CONT DO
*
! System Character
*
IF TC.LOC THEN
*
BEGIN CASE
*
CASE TC.FUNC EQ "|"
*
IF LEN(FLD) GT TC.CN THEN
*
TC = FLD[TC.CN + ONE,ONE]
TC.SEQ = SEQ(TC)
TC.LOC = FALSE; TC.OUT = EMPTY
IF TC.INS THEN
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
TC.INS = FALSE
PRINT @(70,TMP):SPACE(9):@(MARK.CL,LN):
END
*
END ELSE PRINT BELL:; TC = EMPTY; TC.SEQ = EMPTY
*
CASE TC.FUNC EQ "<"
*
IF TC.CN THEN
PRINT @(TC.CL,RSP.LN):TCO:
TC.CN = TC.CN - ONE
TC.CL = TC.CL - ONE
RSP = RSP[ONE,TC.CN]
IF TC.INS THEN
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
TC.INS = FALSE
PRINT @(70,TMP):SPACE(9):@(MARK.CL,LN):
END
IF TC.CL LT RSP.CL OR TC.CN LT TC.START THEN TC.ADJ = TRUE
END ELSE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
END
*
CASE TC.FUNC EQ "\"
*
RSP = EMPTY; FLD = EMPTY; CLEAR.FLAG = TRUE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
*
CASE TC.FUNC EQ "R"
FLD = DEF; RSP = EMPTY; CLEAR.FLAG = FALSE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
*
CASE TC.FUNC EQ "I"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF TC.INS THEN
TC.INS = FALSE
PRINT @(70,TMP):SPACE(9):@(MARK.CL,LN):
END ELSE
TC.INS = TRUE
PRINT @(70,TMP):"   ":RVB:"INS":RVE:"   ":@(MARK.CL,LN):
END
*
CASE TC.FUNC EQ "D"
*
IF LEN(FLD) GT TC.CN THEN
FLD = FLD[ONE,TC.CN]:FLD[TC.CN + TWO,9999]
END
TC.ADJ = TRUE; TC.MOVE = FALSE
*
CASE TC.FUNC EQ "S"
*
GOSUB SYS.DEBUG
*
CASE TC.FUNC EQ "A"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
PRINT @(50,TMP):RVB:"  Alt:   ":RVE:@(56,TMP):
INPUT TMP1,3:_
IF NUM(TMP1) THEN
IF TMP1 GE ZERO AND TMP1 LE 255 THEN
TC = CHAR(TMP1); TC.SEQ = SEQ(TC); TC.LOC = FALSE
END ELSE PRINT BELL:
END ELSE PRINT BELL:
PRINT @(50,TMP):SPACE(9):@(MARK.CL,LN):
*
CASE TC.FUNC EQ "N"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF NOT(NUMC) THEN
PRINT @(60,TMP):"   ":RVB:"NUM":RVE:"   ":@(MARK.CL,LN):
NUMC = TRUE
END ELSE
PRINT @(60,TMP):SPACE(9):@(MARK.CL,LN):
NUMC = FALSE
END
*
CASE TC.FUNC EQ "G"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF NOT(GENERIC) THEN
PRINT @(40,TMP):"   ":RVB:"GEN":RVE:"   ":@(MARK.CL,LN):
GENERIC = TRUE
END ELSE
PRINT @(40,TMP):SPACE(9):@(MARK.CL,LN):
GENERIC = FALSE
END
*
CASE TC.FUNC EQ "E"
*
IF RSP.LN EQ 22 OR LN EQ 22 THEN TMP = ZERO ELSE TMP = 22
TMP1 = DCOUNT(CURSOR.KEYS<5>,VM)
PRINT @(ZERO,TMP):CLL:RVB:"Enter function number (0 to continue): ":RVE:
LOOP
PRINT @(40,TMP):
INPUT TC.FUNC.NUM,ONE:
IF NUM(TC.FUNC.NUM) THEN
IF TC.FUNC.NUM LT ZERO OR TC.FUNC.NUM GT TMP1 THEN TC.FUNC.NUM = "?"
END
WHILE NOT(NUM(TC.FUNC.NUM)) DO PRINT BELL: REPEAT
PRINT @(ZERO,TMP):CLL:@(MARK.CL,LN):
IF TC.FUNC.NUM THEN
RSP = CURSOR.KEYS<5,TC.FUNC.NUM>; TC.CONT = FALSE
EXEC.DESC = "F":TC.FUNC.NUM:" - ":CURSOR.KEYS<4,TC.FUNC.NUM>
EXEC.VERB = CURSOR.KEYS<5,TC.FUNC.NUM>
END
*
CASE TC.FUNC EQ "@"
*
IF RSP.LN EQ 22 OR LN EQ 22 THEN TMP = ZERO ELSE TMP = 22
PRINT @(ZERO,TMP):CLL:RVB:"Enter the function name: ":RVE:BELL:
INPUT STD.SUBR.NAME:
IF STD.SUBR.NAME EQ EMPTY THEN STD.SUBR.NAME = SEC.USER$FUNC.NAME
IF STD.SUBR.NAME NE EMPTY THEN
* STD.FUNC = "PERFORM"
SEC.USER$FUNC.NAME = STD.SUBR.NAME; TC.CONT = FALSE
* GOSUB LOAD.STD.DATA
* GOSUB ENTER.STD.SUBR
END ELSE
TC.ADJ = TRUE
PRINT @(ZERO,TMP):CLL:
END; * Of routine name
*
CASE TRUE
*
TC.FUNC = EMPTY
*
END CASE
*
END; * Of TC.FUNC
*
! Not a system character
*
IF NOT(TC.LOC) AND LEN(TC) THEN
*
IF TC.SEQ GE 28 THEN
*
IF TC.SEQ LE 30 THEN
TC.SEQ = TC.SEQ + 224
TC = CHAR(TC.SEQ)
IF TT EQ "D" OR TT EQ "R" THEN PRINT TC:
END
*
IF TC.INS THEN
TMP = LEN(FLD)
IF TMP LT TC.CN THEN
FLD = FLD:RSP[TMP + ONE,9999]
END
FLD = FLD[ONE,TC.CN]:TC:FLD[TC.CN + ONE,9999]
TC.ADJ = TRUE; TC.MOVE = FALSE
END
*
RSP = RSP:TC
TCO = FLD[TC.CN + ONE,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
PRINT @(TC.CL,RSP.LN):TC:@(MARK.CL,LN):
TC.CN = TC.CN + ONE
TC.CL = TC.CL + ONE
*
END; * Of ge 28
*
END; * Of no TC.OUT
*
IF TC.CL GE TC.STOP OR TC.ADJ THEN
IF NOT(TC.MOVE) AND TC.CL LT TC.STOP THEN
TC.MOVE = TRUE
TMP = TC.CN - TC.START + ONE
END ELSE IF TC.CL GE TC.STOP OR TC.START NE ONE THEN
TMP = INT(LH / TWO)
END ELSE TMP = ZERO
IF TMP GT TC.CN THEN TMP = TC.CN
TC.START = TC.CN - TMP + ONE
* INPUT TMP.RSP:
TC.CL = RSP.CL + TMP
TMP1 = FLD[TC.CN + ONE,LH - TMP]
TMP1 = TMP1:STR(TC.FILL,LH - TMP - LEN(TMP1))
PRINT @(RSP.CL,RSP.LN):RSP[TC.START,LH]:TMP1:@(TC.CL,RSP.LN):
TC.ADJ = FALSE
TC.MOVE = TRUE
END
*
IF TC.CN EQ LHM THEN
TEXT = "No more than ":LHM:" characters please"
IF RSP.LN EQ 23 OR LN EQ 23 THEN TMP = 22 ELSE TMP = 23
PRINT @(ZERO,TMP):CLL:TEXT[ONE,78]:BELL:@(MARK.CL,LN):
CLEAR.BOTTOM.LINE = TMP
END
*
! End of system / non-system character
*
REPEAT
*
IF (TC.CN EQ ZERO AND (TC.FUNC EQ "C" OR TC.FUNC EQ EMPTY)) AND NOT(CLEAR.FLAG) THEN DEFAULT.USED = TRUE; RSP = DEF
IF CLEAR.BOTTOM.LINE THEN PRINT @(ZERO,CLEAR.BOTTOM.LINE):CLL:; CLEAR.BOTTOM.LINE = FALSE
* IF TC.START NE ONE THEN PRINT @(RSP.CL,RSP.LN):RSP[ONE,ML]:
*
END CASE
*
! End of Opsys ? / U or M
*
END; * Of NO.PROMPT
*
PRINT @(RSP.CL,RSP.LN):RSP MS:
FLD = RSP
*
*
~BU1.GENERAL.COMMON.AREA~
*CODE.SEGMENT: ?
COMMON ACG(10),ACT(55),ADD(30),ASH(20),ATR(20),DLQ(10),DVC(20),EFT(20),RTE(10),STT(10),SVC(10),SVS(20),TAX(10),TPL(10),WKO(50),WKP(10),SAVE.ACG(10),SAVE.ACT(55),SAVE.ADD(30),SAVE.ATR(20),SAVE.WKO(50)
COMMON ACG.ID,ACT.ID,ADD.ID,STT.ID,TPL.ID,WKO.ID,SAVE.ACG.ID,SAVE.ACT.ID,SAVE.ADD.ID,SAVE.WKO.ID
COMMON ACG.FILE,ACT.FILE,ACX.FILE,ADD.FILE,ASH.FILE,ATH.FILE,ATR.FILE,CNT.FILE,DLQ.FILE,DVC.FILE,EFT.FILE,PAR.FILE,RTE.FILE,STT.FILE,STX.FILE,SVC.FILE,SVS.FILE,TAX.FILE,TPL.FILE,WKH.FILE,WKO.FILE,WKP.FILE,LCK.FILE
COMMON CO.DATA,RSP,REF,NEXT.CALL,ALLOWED,ALLOW.MSG,PREV.ID,PRIOR.TNT.ID,PRIOR.ADD.ID,PEND.WO.NUMS,NEW.ADD,SERVICE.TOP,UPDATED,STAT
~BU1.STANDARD.FUNCTIONS~
*CODE.SEGMENT: ?
!
STANDARD.FUNCTIONS: *
EQUATE BELL TO CHAR(7)
EQUATE LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13)
EQUATE TRUE TO 1,T TO 1,FALSE TO 0,F TO 0
EQUATE SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~CAJ.DIM~
*CODE.SEGMENT: ?
DIM CAJ(10)
~CAJ.EQUATES~
*CODE.SEGMENT: ?
* FILE 'CAJ' EQUATES - GENERATED 15:13:57  05 MAY 1984
EQU CAJ$BATCH.HEADER TO CAJ(1);         * HEADER TO CASH OR ADJ. BATCH
~CAR.DIM~
*CODE.SEGMENT: ?
DIM CAR(20)
~CAR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'CAR' EQUATES - GENERATED 13:09:30  11 APR 1988
EQU CAR$CO TO CAR(1);                   * C
EQU CAR$FR TO CAR(2);                   * FR
EQU CAR$CUSTNO TO CAR(3);               * CUSTNO
EQU CAR$BAL TO CAR(4);                  * TRANS.BAL
EQU CAR$DESCR TO CAR(5);                * D
EQU CAR$DATE TO CAR(6);                 * TR.DATE
EQU CAR$TRAN TO CAR(7);                 * TRN
EQU CAR$REFER TO CAR(8);                * REFER#
EQU CAR$ORIG TO CAR(9);                 * ORIG.AMT
EQU CAR$NOT.USED TO CAR(10);            * 
EQU CAR$DATE.PAID TO CAR(11);           * DATE.PAID
EQU CAR$CHECK TO CAR(12);               * CHECK#
EQU CAR$AMOUNT TO CAR(13);              * CHECK.AMT
EQU CAR$TAX TO CAR(14);                 * TAX.AMT
EQU CAR$BASIC TO CAR(15);               * BASIC.AMT
EQU CAR$PAY TO CAR(16);                 * PAY.AMTS
EQU CAR$CVR TO CAR(17);             * CVTR.AMTS
EQU CAR$EXP TO CAR(18);            * EXPANDED.BASIC.AMTS
~CFG.DIM~
*CODE.SEGMENT: ?
DIM CFG(10)
~CFG.EQUATES~
*CODE.SEGMENT: ?
* FILE 'CFG' EQUATES - GENERATED 10:42:32  10 JUL 1984
EQU CFG$INDEX TO CFG(1);                * CONFIGURATION INDEX LINES
EQU CFG$DESC TO CFG(2);                 * DESCRIPTION
EQU CFG$MEGS.PER TO CFG(3);             * MEGABYTES REQUIRED PER UNIT
EQU CFG$NUM TO CFG(4);                  * NUMBER OF UNITS
EQU CFG$MEGS.TOT TO CFG(5);             * MEGABYTES REQUIRED
EQU CFG$SYSTEM.TOTAL TO CFG(6);         * MEGABYTES REQUIRED - SYSTEM TOTAL
~CG.COMMON.FUNCTIONS~
*CODE.SEGMENT: CG.COMMON.FUNCTIONS
*
*$INCLUDE DH.IBP CG.COMMON.FUNCTIONS
*
EQU BELL TO CHAR(7), LF TO CHAR(10), FF TO CHAR(12), CR TO CHAR(13)
EQU SVM TO  CHAR(252), VM TO CHAR(253), AM TO CHAR(254)
WHO = ICONV(0,"U50BB")
PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2)
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
EQU YES TO "*YES*Y*Yes*yes*y*OK*", NO TO "*NO*N*No*no*n*NOT OK*"
EQU TRUE TO "*T*t*1*TRUE*True*true*NOT FALSE*not false*YES*Y*Yes*yes*y*OK*"
EQU FALSE TO "*F*f*0*FALSE*False*false*NOT TRUE*not true*NO*N*No*no*n*NOT OK*"
*
TERMINAL = SYSTEM(7); * REVERSE VIDEO BEGIN/END
RVB = CHAR(14); RVE = CHAR(15)
PRINT CHAR(27):"0Q":
BEGIN CASE
CASE TERMINAL = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"
CASE TERMINAL = "R"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
CASE TERMINAL = "V"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
END CASE
*
~CG.COMMON.VARIABLES~
*CODE.SEGMENT: CG.COMMON.VARIABLES
*
*
COMMON KEY.CN,EI.KEY.VL,ENTITY.REC(100),CALL.COMM,SYS.PROG.STATUS
COMMON SYS.PROG,SYS.LOCT,SYS.SLOC,LBL.TO.PRINT,SYS.FORMAT,HORZ.CN
COMMON FINISHED,LBL.PR.CN,LBL.ALPHA
COMMON PRVL(60),LNVL(60),FORM(60)
COMMON CODES.FILE
*
*
~CG@DOC@HDR@CONTACT.GENERATE~
*CODE.SEGMENT: CG@DOC@HDR@CONTACT.GENERATE
*
!
*#
*#
*# Author.......: David Hormsam
*# Company......: Macroscope Systems
*# Application..: Contact Maintenance
*# Short Appl...: CG
*# File.........: DH.BP
*# Program......: CONTACT GENERATE
*# Date Writen..: ?
*#
*# Date Modified: 87/02/16
*# Author.......: David Horsman
*# Modifications: - Contact Master Record Access.
*#                - Standard Program Execution.
*#                - Standard Documentation and Coding
*#
*#
*# Date Modified: ?
*# Author.......: ?
*# Modifications: - ?
*#                - ?
~CLS.ROUTINE~
*CODE.SEGMENT: CLS.ROUTINE
*
!
CLS.ROUTINE: *
PRINT @(CLS.COL,CLS.ROW):CLS:
RETURN
*
~CNT.AI.DIM~
*CODE.SEGMENT: ?
DIM CNT.AI(65)
~CNT.AI.EQUATES~
*CODE.SEGMENT: CNT.AI.EQUATES
*
* FILE 'CNT.AI' EQUATES - GENERATED 06:04:29  27 MAR 1992
*
*  This is the On-Premise Master Record.
*  There is one record for each headend and it
*  represents a control computer. There must be a
*  dedicated port defined by this record.
*  It is used in conjunction with the AIX and CNT.AIP
*  records to manage subscribers and services.
*
*
EQU CNT.AI$DB.PREFIX TO CNT.AI(1);      * Interface code or BP ID Prefix for call
EQU CNT.AI$NAME TO CNT.AI(2);           * Addressable Interface Description
EQU CNT.AI$TYPE TO CNT.AI(3);           * Addressable Interface Type
EQU CNT.AI$RSVD.4 TO CNT.AI(4);         * Reserved
EQU CNT.AI$PORT TO CNT.AI(5);           * Billing Computer Port Number
EQU CNT.AI$BILL.CUTOFF.TM TO CNT.AI(6); * cutoff time for current day's Billing
EQU CNT.AI$MODEL.SERIAL.NO TO CNT.AI(7);* Mfg's model no, serial no, or site desc.
EQU CNT.AI$DF.SVCS.ONE TO CNT.AI(8);    * Default Services, One address / device
EQU CNT.AI$DF.COUT.ONE TO CNT.AI(9);    * Default Conn Outlets, One address / device
EQU CNT.AI$DF.SVCS.EIGHT TO CNT.AI(10); * Default Services, Eight addresses / device
EQU CNT.AI$DF.COUT.EIGHT TO CNT.AI(11); * Default Conn Outlets, Eight addresses / device
EQU CNT.AI$COMMPORT TO CNT.AI(12);      * Two letter code for head end
EQU CNT.AI$UP.DN TO CNT.AI(13);         * Program will execute commands or not
EQU CNT.AI$UP.DN.DT TO CNT.AI(14);      * Date U/D command issued
EQU CNT.AI$UP.DN.TM TO CNT.AI(15);      * Time U/D command issued
EQU CNT.AI$ON.OFF TO CNT.AI(16);        * Port is to log on or log off
EQU CNT.AI$ON.OFF.DT TO CNT.AI(17);     * Date On/Off command was issued
EQU CNT.AI$ON.OFF.TM TO CNT.AI(18);     * Time On/Off command was issued
EQU CNT.AI$LOGGING TO CNT.AI(19);       * Is command logging done (Y/N)
EQU CNT.AI$TEST.MODE TO CNT.AI(20);     * Test flag for this interface device
EQU CNT.AI$UP.DN.C.DT TO CNT.AI(21);    * Date UP/DN command completed
EQU CNT.AI$UP.DN.C.TM TO CNT.AI(22);    * Time UP/DN command completed
EQU CNT.AI$ON.OFF.C.DT TO CNT.AI(23);   * Date ON/OFF command completed
EQU CNT.AI$ON.OFF.C.TM TO CNT.AI(24);   * Time ON/OFF command completed
EQU CNT.AI$OPER TO CNT.AI(25);          * Operator who last updated control record
EQU CNT.AI$UP.DN.STAT TO CNT.AI(26);    * True interface UP/DN status
EQU CNT.AI$ON.OFF.STAT TO CNT.AI(27);   * True interface ON/OFF status
EQU CNT.AI$FUNC.DT TO CNT.AI(28);       * Date last function was completed
EQU CNT.AI$FUNC.TM TO CNT.AI(29);       * Time last functions was completed
EQU CNT.AI$COMMAND.DT TO CNT.AI(30);    * Date last command was completed (SUBSCR)
EQU CNT.AI$COMMAND.TM TO CNT.AI(31);    * Time last command was completed (SUBSCR)
EQU CNT.AI$FUNC TO CNT.AI(32);          * Last function completed
EQU CNT.AI$COMMAND TO CNT.AI(33);       * Command last completed
EQU CNT.AI$ON.OFF.BY TO CNT.AI(34);     * Operator who issued ON/OFF function
EQU CNT.AI$UP.DN.BY TO CNT.AI(35);      * Operator who issued UP/DN function
EQU CNT.AI$STD.PAUSE TO CNT.AI(36);     * Standard Pause when handler idling
EQU CNT.AI$MAX.PAUSE TO CNT.AI(37);     * Maximum time before handler time out
EQU CNT.AI$FUNC.PORT TO CNT.AI(38);     * Priority command from port # 999
EQU CNT.AI$RESET.FREQ TO CNT.AI(39);    * Number of seconds between handler resets
EQU CNT.AI$SCAN.FREQ TO CNT.AI(40);     * number of secs between checking CSR's
EQU CNT.AI$SCAN.SLICE TO CNT.AI(41);    * No of secs to spend checking CSR's
EQU CNT.AI$PORT.ID TO CNT.AI(42);       * The port id (DICT ACC) of this port #
EQU CNT.AI$DF.XREF.ONE TO CNT.AI(43);   * Service to Labeled Tier cross-reference
EQU CNT.AI$DF.XREF.EIGHT TO CNT.AI(44); * Service to Labeled Tier Xref
EQU CNT.AI$INDEXED TO CNT.AI(45);       * Service to Tier Indexing Method
EQU CNT.AI$DISC.ROLL TO CNT.AI(46);     * Roll a truck on a Disconnect W/O
EQU CNT.AI$CONN.ROLL TO CNT.AI(47);     * Roll a truck on a Connect W/O
EQU CNT.AI$CHNG.ROLL TO CNT.AI(48);     * Roll a truch on a Service Change W/O
EQU CNT.AI$CHAN.DN.BRDCST TO CNT.AI(49);* Broadcast Downed Channels to Control sys
EQU CNT.AI$SINGLE TO CNT.AI(50);        * Single Address vs Multiple Addr's.
EQU CNT.AI$ADDR.PER.UNIT TO CNT.AI(51); * # of addr. per multi address device
EQU CNT.AI$TIER.PER.UNIT TO CNT.AI(52); * # of tiers per each on-premise unit
EQU CNT.AI$PORT.PASS TO CNT.AI(53);     * Password for this account or port.
EQU CNT.AI$PAUSE.CHAR TO CNT.AI(54);    * Cycle to pause for between characters
EQU CNT.AI$PAUSE.LINE TO CNT.AI(55);    * Cycles to pause for between lines
EQU CNT.AI$PAUSE.RESP TO CNT.AI(56);    * Time-out value waiting for a response
EQU CNT.AI$MONITOR.PORT TO CNT.AI(57);  * Port number of monitor
EQU CNT.AI$GENIE.WINDOW TO CNT.AI(58);  * Is the services window avail. for msgs
EQU CNT.AI$SEND.ON TO CNT.AI(59);       * Send ON packet to interface
EQU CNT.AI$SEND.OFF TO CNT.AI(60);      * Send OFF packet to interface
EQU CNT.AI$DF.TIER.ONE TO CNT.AI(61);   * Spigott number of service (1 * 8sp)
EQU CNT.AI$DF.TIER.EIGHT TO CNT.AI(62); * Spigott of eight addr dvc (or 4 * 2 sp)
EQU CNT.AI$DVC.UNIT TO CNT.AI(63);      * Devices used by then AI
EQU CNT.AI$ERR TO CNT.AI(64);           * Last error recorded by monitor
~CNT.AI.VAR.EQUATES~
*CODE.SEGMENT: CNT.AI.VAR.EQUATES
*
* FILE 'CNT.AI' EQUATES - GENERATED 06:04:30  27 MAR 1992
*
*  This is the On-Premise Master Record.
*  There is one record for each headend and it
*  represents a control computer. There must be a
*  dedicated port defined by this record.
*  It is used in conjunction with the AIX and CNT.AIP
*  records to manage subscribers and services.
*
*
EQU CNT.AI$DB.PREFIX TO 1;              * Interface code or BP ID Prefix for call
EQU CNT.AI$NAME TO 2;                   * Addressable Interface Description
EQU CNT.AI$TYPE TO 3;                   * Addressable Interface Type
EQU CNT.AI$RSVD.4 TO 4;                 * Reserved
EQU CNT.AI$PORT TO 5;                   * Billing Computer Port Number
EQU CNT.AI$BILL.CUTOFF.TM TO 6;         * cutoff time for current day's Billing
EQU CNT.AI$MODEL.SERIAL.NO TO 7;        * Mfg's model no, serial no, or site desc.
EQU CNT.AI$DF.SVCS.ONE TO 8;            * Default Services, One address / device
EQU CNT.AI$DF.COUT.ONE TO 9;            * Default Conn Outlets, One address / device
EQU CNT.AI$DF.SVCS.EIGHT TO 10;         * Default Services, Eight addresses / device
EQU CNT.AI$DF.COUT.EIGHT TO 11;         * Default Conn Outlets, Eight addresses / device
EQU CNT.AI$COMMPORT TO 12;              * Two letter code for head end
EQU CNT.AI$UP.DN TO 13;                 * Program will execute commands or not
EQU CNT.AI$UP.DN.DT TO 14;              * Date U/D command issued
EQU CNT.AI$UP.DN.TM TO 15;              * Time U/D command issued
EQU CNT.AI$ON.OFF TO 16;                * Port is to log on or log off
EQU CNT.AI$ON.OFF.DT TO 17;             * Date On/Off command was issued
EQU CNT.AI$ON.OFF.TM TO 18;             * Time On/Off command was issued
EQU CNT.AI$LOGGING TO 19;               * Is command logging done (Y/N)
EQU CNT.AI$TEST.MODE TO 20;             * Test flag for this interface device
EQU CNT.AI$UP.DN.C.DT TO 21;            * Date UP/DN command completed
EQU CNT.AI$UP.DN.C.TM TO 22;            * Time UP/DN command completed
EQU CNT.AI$ON.OFF.C.DT TO 23;           * Date ON/OFF command completed
EQU CNT.AI$ON.OFF.C.TM TO 24;           * Time ON/OFF command completed
EQU CNT.AI$OPER TO 25;                  * Operator who last updated control record
EQU CNT.AI$UP.DN.STAT TO 26;            * True interface UP/DN status
EQU CNT.AI$ON.OFF.STAT TO 27;           * True interface ON/OFF status
EQU CNT.AI$FUNC.DT TO 28;               * Date last function was completed
EQU CNT.AI$FUNC.TM TO 29;               * Time last functions was completed
EQU CNT.AI$COMMAND.DT TO 30;            * Date last command was completed (SUBSCR)
EQU CNT.AI$COMMAND.TM TO 31;            * Time last command was completed (SUBSCR)
EQU CNT.AI$FUNC TO 32;                  * Last function completed
EQU CNT.AI$COMMAND TO 33;               * Command last completed
EQU CNT.AI$ON.OFF.BY TO 34;             * Operator who issued ON/OFF function
EQU CNT.AI$UP.DN.BY TO 35;              * Operator who issued UP/DN function
EQU CNT.AI$STD.PAUSE TO 36;             * Standard Pause when handler idling
EQU CNT.AI$MAX.PAUSE TO 37;             * Maximum time before handler time out
EQU CNT.AI$FUNC.PORT TO 38;             * Priority command from port # 999
EQU CNT.AI$RESET.FREQ TO 39;            * Number of seconds between handler resets
EQU CNT.AI$SCAN.FREQ TO 40;             * number of secs between checking CSR's
EQU CNT.AI$SCAN.SLICE TO 41;            * No of secs to spend checking CSR's
EQU CNT.AI$PORT.ID TO 42;               * The port id (DICT ACC) of this port #
EQU CNT.AI$DF.XREF.ONE TO 43;           * Service to Labeled Tier cross-reference
EQU CNT.AI$DF.XREF.EIGHT TO 44;         * Service to Labeled Tier Xref
EQU CNT.AI$INDEXED TO 45;               * Service to Tier Indexing Method
EQU CNT.AI$DISC.ROLL TO 46;             * Roll a truck on a Disconnect W/O
EQU CNT.AI$CONN.ROLL TO 47;             * Roll a truck on a Connect W/O
EQU CNT.AI$CHNG.ROLL TO 48;             * Roll a truch on a Service Change W/O
EQU CNT.AI$CHAN.DN.BRDCST TO 49;        * Broadcast Downed Channels to Control sys
EQU CNT.AI$SINGLE TO 50;                * Single Address vs Multiple Addr's.
EQU CNT.AI$ADDR.PER.UNIT TO 51;         * # of addr. per multi address device
EQU CNT.AI$TIER.PER.UNIT TO 52;         * # of tiers per each on-premise unit
EQU CNT.AI$PORT.PASS TO 53;             * Password for this account or port.
EQU CNT.AI$PAUSE.CHAR TO 54;            * Cycle to pause for between characters
EQU CNT.AI$PAUSE.LINE TO 55;            * Cycles to pause for between lines
EQU CNT.AI$PAUSE.RESP TO 56;            * Time-out value waiting for a response
EQU CNT.AI$MONITOR.PORT TO 57;          * Port number of monitor
EQU CNT.AI$GENIE.WINDOW TO 58;          * Is the services window avail. for msgs
EQU CNT.AI$SEND.ON TO 59;               * Send ON packet to interface
EQU CNT.AI$SEND.OFF TO 60;              * Send OFF packet to interface
EQU CNT.AI$DF.TIER.ONE TO 61;           * Spigott number of service (1 * 8sp)
EQU CNT.AI$DF.TIER.EIGHT TO 62;         * Spigott of eight addr dvc (or 4 * 2 sp)
EQU CNT.AI$DVC.UNIT TO 63;              * Devices used by then AI
EQU CNT.AI$ERR TO 64;                   * Last error recorded by monitor
~CNT.AIL.DIM~
*CODE.SEGMENT: ?
DIM AIL(30)
~CNT.AIP.DIM~
*CODE.SEGMENT: ?
DIM CNT.AIP(45)
~CNT.AIP.EQUATES~
*CODE.SEGMENT: CNT.AIP.EQUATES
*
* FILE 'CNT.AIP' EQUATES - GENERATED 04:48:32  24 JUL 1991
*
*  This is the port control record for accessing the
*  on-premise control computer. For each Genie or
*  Update process that requires services from the
*  control computer. This record is written by the
*  process and updated by the Handler that talks to
*  the control computer upon completion of the
*  request.
*
*
EQU CNT.AIP$TIERS TO CNT.AIP(1);        * String of tiers to be sent to Headend
EQU CNT.AIP$TIERS.FUTR TO CNT.AIP(2);   * Tiers to be sent to Headend (Temporary)
EQU CNT.AIP$HE.PORT TO CNT.AIP(3);      * Headend port # on billing computer
EQU CNT.AIP$COMM TO CNT.AIP(4);         * Command/function to be done by interface
EQU CNT.AIP$ACCT.ID TO CNT.AIP(5);      * Account id effected by command
EQU CNT.AIP$ADD.ID TO CNT.AIP(6);       * Address id effected by command
EQU CNT.AIP$WKO.ID TO CNT.AIP(7);       * Work Order ID requiring command
EQU CNT.AIP$WKO.TYPE TO CNT.AIP(8);     * Work Order Type
EQU CNT.AIP$WKO.STAT TO CNT.AIP(9);     * Work Order Status
EQU CNT.AIP$INTFC.CODE TO CNT.AIP(10);  * Interface Code (ie EA=Eagle)
EQU CNT.AIP$DVC.ID TO CNT.AIP(11);      * Device Id of on premise device
EQU CNT.AIP$DVC.TYPE TO CNT.AIP(12);    * Type of on premise device (1/8)
EQU CNT.AIP$INTFC.STAT TO CNT.AIP(13);  * Status of interface when finished
EQU CNT.AIP$WKO.INST TO CNT.AIP(14);    * Work Order Installer
EQU CNT.AIP$COMM.DT TO CNT.AIP(15);     * Date command was issued
EQU CNT.AIP$COMM.TM TO CNT.AIP(16);     * Time command was issued
EQU CNT.AIP$COMM.C.DT TO CNT.AIP(17);   * Date command was completed
EQU CNT.AIP$COMM.C.TM TO CNT.AIP(18);   * Time command was completed
EQU CNT.AIP$COMM.PORT TO CNT.AIP(19);   * Port command was issued by
EQU CNT.AIP$HEX.COMM TO CNT.AIP(20);    * Hexadecimal format of command
EQU CNT.AIP$HEX.RSLT TO CNT.AIP(21);    * Hexadecimal result code of command
EQU CNT.AIP$COMM.RSLT TO CNT.AIP(22);   * Result code of command
EQU CNT.AIP$ERR TO CNT.AIP(23);         * Error code from sending of command
EQU CNT.AIP$SVC.ID TO CNT.AIP(24);      * Services effected by command
EQU CNT.AIP$SVC.FUNC TO CNT.AIP(25);    * Function being done to service
EQU CNT.AIP$SVC.CHAN TO CNT.AIP(26);    * Channels belonging to service
EQU CNT.AIP$GROUP TO CNT.AIP(27);       * Address ID of AI device where installed
EQU CNT.AIP$GROUP.RSLT TO CNT.AIP(28);  * Result effecting Address ID or AI
EQU CNT.AIP$WKO.SCHED TO CNT.AIP(29);   * Schedule information from work order
EQU CNT.AIP$OPER TO CNT.AIP(30);        * Operator requesting interface action
EQU CNT.AIP$SVC.ID.FUTR TO CNT.AIP(31); * Future Services for this device
EQU CNT.AIP$LOG.DISPL TO CNT.AIP(32);   * Log has been display by Display Monitor
EQU CNT.AIP$LOG.PRINT TO CNT.AIP(33);   * Has transaction been printed on the Log
EQU CNT.AIP$LOG.ACK.DI TO CNT.AIP(34);  * Has the Dispatched Acknowledged this
EQU CNT.AIP$LOG.ACK.BR TO CNT.AIP(35);  * Has the Branch Mngr Acknowledged this
EQU CNT.AIP$INTFC.TYPE TO CNT.AIP(36);  * Type of Interface - On-prem or In-prem
EQU CNT.AIP$TSTAT TO CNT.AIP(37);       * Tier status (0/1) off/on
EQU CNT.AIP$TSTAT.FUTR TO CNT.AIP(38);  * Tier status future (0/1)
EQU CNT.AIP$AIX.LOCATION TO CNT.AIP(39);* Address number from ADD to AIX svrcs
EQU CNT.AIP$AIX.ID TO CNT.AIP(40);      * Item ID of the AIX id
EQU CNT.AIP$LOG.REQD TO CNT.AIP(41);    * Log transactions in update/abort
EQU CNT.AIP$TINDEX TO CNT.AIP(42);      * String of tiers to be transmitted to HE
EQU CNT.AIP$LOG.SRCE TO CNT.AIP(43);    * Source of tranaction log
EQU CNT.AIP$PORT TO CNT.AIP(44);        * Port number command issued from
~CNT.AIP.VAR.EQUATES~
*CODE.SEGMENT: CNT.AIP.VAR.EQUATES
*
* FILE 'CNT.AIP' EQUATES - GENERATED 04:48:32  24 JUL 1991
*
*  This is the port control record for accessing the
*  on-premise control computer. For each Genie or
*  Update process that requires services from the
*  control computer. This record is written by the
*  process and updated by the Handler that talks to
*  the control computer upon completion of the
*  request.
*
*
EQU CNT.AIP$TIERS TO 1;                 * String of tiers to be sent to Headend
EQU CNT.AIP$TIERS.FUTR TO 2;            * Tiers to be sent to Headend (Temporary)
EQU CNT.AIP$HE.PORT TO 3;               * Headend port # on billing computer
EQU CNT.AIP$COMM TO 4;                  * Command/function to be done by interface
EQU CNT.AIP$ACCT.ID TO 5;               * Account id effected by command
EQU CNT.AIP$ADD.ID TO 6;                * Address id effected by command
EQU CNT.AIP$WKO.ID TO 7;                * Work Order ID requiring command
EQU CNT.AIP$WKO.TYPE TO 8;              * Work Order Type
EQU CNT.AIP$WKO.STAT TO 9;              * Work Order Status
EQU CNT.AIP$INTFC.CODE TO 10;           * Interface Code (ie EA=Eagle)
EQU CNT.AIP$DVC.ID TO 11;               * Device Id of on premise device
EQU CNT.AIP$DVC.TYPE TO 12;             * Type of on premise device (1/8)
EQU CNT.AIP$INTFC.STAT TO 13;           * Status of interface when finished
EQU CNT.AIP$WKO.INST TO 14;             * Work Order Installer
EQU CNT.AIP$COMM.DT TO 15;              * Date command was issued
EQU CNT.AIP$COMM.TM TO 16;              * Time command was issued
EQU CNT.AIP$COMM.C.DT TO 17;            * Date command was completed
EQU CNT.AIP$COMM.C.TM TO 18;            * Time command was completed
EQU CNT.AIP$COMM.PORT TO 19;            * Port command was issued by
EQU CNT.AIP$HEX.COMM TO 20;             * Hexadecimal format of command
EQU CNT.AIP$HEX.RSLT TO 21;             * Hexadecimal result code of command
EQU CNT.AIP$COMM.RSLT TO 22;            * Result code of command
EQU CNT.AIP$ERR TO 23;                  * Error code from sending of command
EQU CNT.AIP$SVC.ID TO 24;               * Services effected by command
EQU CNT.AIP$SVC.FUNC TO 25;             * Function being done to service
EQU CNT.AIP$SVC.CHAN TO 26;             * Channels belonging to service
EQU CNT.AIP$GROUP TO 27;                * Address ID of AI device where installed
EQU CNT.AIP$GROUP.RSLT TO 28;           * Result effecting Address ID or AI
EQU CNT.AIP$WKO.SCHED TO 29;            * Schedule information from work order
EQU CNT.AIP$OPER TO 30;                 * Operator requesting interface action
EQU CNT.AIP$SVC.ID.FUTR TO 31;          * Future Services for this device
EQU CNT.AIP$LOG.DISPL TO 32;            * Log has been display by Display Monitor
EQU CNT.AIP$LOG.PRINT TO 33;            * Has transaction been printed on the Log
EQU CNT.AIP$LOG.ACK.DI TO 34;           * Has the Dispatched Acknowledged this
EQU CNT.AIP$LOG.ACK.BR TO 35;           * Has the Branch Mngr Acknowledged this
EQU CNT.AIP$INTFC.TYPE TO 36;           * Type of Interface - On-prem or In-prem
EQU CNT.AIP$TSTAT TO 37;                * Tier status (0/1) off/on
EQU CNT.AIP$TSTAT.FUTR TO 38;           * Tier status future (0/1)
EQU CNT.AIP$AIX.LOCATION TO 39;         * Address number from ADD to AIX svrcs
EQU CNT.AIP$AIX.ID TO 40;               * Item ID of the AIX id
EQU CNT.AIP$LOG.REQD TO 41;             * Log transactions in update/abort
EQU CNT.AIP$TINDEX TO 42;               * String of tiers to be transmitted to HE
EQU CNT.AIP$LOG.SRCE TO 43;             * Source of tranaction log
EQU CNT.AIP$PORT TO 44;                 * Port number command issued from
~CNT.CSH.DIM~
DIM CNT.CSH(20)
~CNT.CSH.EQUATES~
*CODE.SEGMENT: CNT.CSH.EQUATES
*
* FILE 'CNT.CSH' EQUATES - GENERATED 12:50:40  07 JUN 1993
EQU CNT.CSH$PORT TO CNT.CSH(1);         * m i) Port Allowed
EQU CNT.CSH$TILL.TYPE TO CNT.CSH(2);    * m i) Till Type
EQU CNT.CSH$USER.VALID TO CNT.CSH(3);   * m ii) Users Allowed
EQU CNT.CSH$USER.PROMPT TO CNT.CSH(4);  * Prompt for User
EQU CNT.CSH$DT.OPEN TO CNT.CSH(5);      * m iii) Open Dates
EQU CNT.CSH$USER.CURR TO CNT.CSH(6);    * m i) Current User for this Port
EQU CNT.CSH$EOD.COPIES.DRFT TO CNT.CSH(7);   * End of Day  # of draft copies
EQU CNT.CSH$EOD.COPIES.FNL TO CNT.CSH(8);    * End of Day  # of final copies (posted)
EQU CNT.CSH$DT.CLOSED TO CNT.CSH(9);         * m iii) Open Dates OK to Print/Post
EQU CNT.CSH$TILL.LPT.TYPE TO CNT.CSH(10);    * m i) Printer Type
EQU CNT.CSH$TILL.RECP.IMPRT TO CNT.CSH(11);  * M i) Print a Receipt, Imprint, or None
EQU CNT.CSH$USER.DECIMAL TO CNT.CSH(12);     * m ii) Key Decimal Point Y/N
EQU CNT.CSH$ITEM.CN.MAX TO CNT.CSH(13);      * Max # of entries in a batch
EQU CNT.CSH$EOD.SOURCES.FNL TO CNT.CSH(14);  * Sources to be posted at end of day
EQU CNT.CSH$EOD.CLASSES.FNL TO CNT.CSH(15);  * End of day classes to post
EQU CNT.CSH$EOD.LISTS.FNL TO CNT.CSH(16);    * List types to print at end of day
EQU CNT.CSH$DAYS.TO.RETAIN TO CNT.CSH(17);   * # of days to keep batches around for
EQU CNT.CSH$LPT.PROMPT TO CNT.CSH(18);       * Prompt for printing
~CNT.CSH.VAR.EQUATES~
*CODE.SEGMENT: CNT.CSH.VAR.EQUATES
*
* FILE 'CNT.CSH' EQUATES - GENERATED 12:50:41  07 JUN 1993
EQU CNT.CSH$PORT TO 1;                  * m i) Port Allowed
EQU CNT.CSH$TILL.TYPE TO 2;             * m i) Till Type
EQU CNT.CSH$USER.VALID TO 3;            * m ii) Users Allowed
EQU CNT.CSH$USER.PROMPT TO 4;           * Prompt for User
EQU CNT.CSH$DT.OPEN TO 5;               * m iii) Open Dates
EQU CNT.CSH$USER.CURR TO 6;             * m i) Current User for this Port
EQU CNT.CSH$EOD.COPIES.DRFT TO 7;       * End of Day  # of draft copies
EQU CNT.CSH$EOD.COPIES.FNL TO 8;        * End of Day  # of final copies (posted)
EQU CNT.CSH$DT.CLOSED TO 9;             * m iii) Open Dates OK to Print/Post
EQU CNT.CSH$TILL.LPT.TYPE TO 10;        * m i) Printer Type
EQU CNT.CSH$TILL.RECP.IMPRT TO 11;      * M i) Print a Receipt, Imprint, or None
EQU CNT.CSH$USER.DECIMAL TO 12;         * m ii) Key Decimal Point Y/N
EQU CNT.CSH$ITEM.CN.MAX TO 13;          * Max # of entries in a batch
EQU CNT.CSH$EOD.SOURCES.FNL TO 14;      * Sources to be posted at end of day
EQU CNT.CSH$EOD.CLASSES.FNL TO 15;      * End of day classes to post
EQU CNT.CSH$EOD.LISTS.FNL TO 16;        * List types to print at end of day
EQU CNT.CSH$DAYS.TO.RETAIN TO 17;       * # of days to keep batches around for
EQU CNT.CSH$LPT.PROMPT TO 18;           * Prompt for printing
~CNT.DIM~
*FOR MAINT.NEXT.XXX.NUM PROGS ONLY
DIM CNT(10)
~CNT.EQUATES~
*CODE.SEGMENT: CNT.EQUATES
*
* FILE 'CNT' EQUATES - GENERATED 16:33:28  04 JUN 1993
~CNT.LATE.DIM~
*CODE.SEGMENT: ?
DIM CNT.LATE(10)
~CNT.LATE.EQUATES~
*CODE.SEGMENT: CNT.LATE.EQUATES
*
* FILE 'CNT.LATE' EQUATES - GENERATED 21:21:01  06 DEC 1991
EQU CNT.LATE$CREDIT.STATUS TO CNT.LATE(1);   * Apply charges at this credit status
EQU CNT.LATE$EXEMPT.RATE.TYPES TO CNT.LATE(2);    * Exempt rate types
EQU CNT.LATE$EXEMPT.PAY.METHODS TO CNT.LATE(3);   * Exempt payment methods
EQU CNT.LATE$CHARGE.TYPE TO CNT.LATE(4);          * Charge is Fixed or % of past due amt
EQU CNT.LATE$AMT.OR.PER TO CNT.LATE(5);           * Amount or percent to be used
EQU CNT.LATE$APPL.METHOD TO CNT.LATE(6);          * Apply monthly or compound (mths * amt)
EQU CNT.LATE$EXCLD.MIN.BAL TO CNT.LATE(7);        * Exclude amt lt min. bal. amt (Y/N)
EQU CNT.LATE$CHRG.PER.BTCH TO CNT.LATE(8);        * Number of charges per batch
~CNT.LATE.VAR.EQUATES~
*CODE.SEGMENT: CNT.LATE.VAR.EQUATES
*
* FILE 'CNT.LATE' EQUATES - GENERATED 21:21:01  06 DEC 1991
EQU CNT.LATE$CREDIT.STATUS TO 1;        * Apply charges at this credit status
EQU CNT.LATE$EXEMPT.RATE.TYPES TO 2;    * Exempt rate types
EQU CNT.LATE$EXEMPT.PAY.METHODS TO 3;   * Exempt payment methods
EQU CNT.LATE$CHARGE.TYPE TO 4;          * Charge is Fixed or % of past due amt
EQU CNT.LATE$AMT.OR.PER TO 5;           * Amount or percent to be used
EQU CNT.LATE$APPL.METHOD TO 6;          * Apply monthly or compound (mths * amt)
EQU CNT.LATE$EXCLD.MIN.BAL TO 7;        * Exclude amt lt min. bal. amt (Y/N)
EQU CNT.LATE$CHRG.PER.BTCH TO 8;        * Number of charges per batch
~CNT.MWS.DIM~
*CODE.SEGMENT: CNT.MWS.DIM
*
DIM CNT.MWS(5)
~CNT.MWS.EQUATES~
*CODE.SEGMENT: CNT.MWS.EQUATES
*
* FILE 'CNT.MWS' EQUATES - GENERATED 10:48:25  09 MAR 1992
EQU CNT.MWS$SEL.STMT TO CNT.MWS(1);     * 
EQU CNT.MWS$LI.NAME TO CNT.MWS(2);      * 
EQU CNT.MWS$PKH.STMT TO CNT.MWS(3);     * 
~CNT.MWS.VAR.EQUATES~
*CODE.SEGMENT: CNT.MWS.VAR.EQUATES
*
* FILE 'CNT.MWS' EQUATES - GENERATED 10:48:25  09 MAR 1992
EQU CNT.MWS$SEL.STMT TO 1;              * 
EQU CNT.MWS$LI.NAME TO 2;               * 
EQU CNT.MWS$PKH.STMT TO 3;              * 
~CNT.RSTAT.DIM~
*CODE.SEGMENT: ?
DIM CNT.RSTAT(25)
~CNT.RSTAT.EQUATES~
*CODE.SEGMENT: CNT.RSTAT.EQUATES
*
* FILE 'CNT.RSTAT' EQUATES - GENERATED 21:22:33  06 DEC 1991
EQU CNT.RSTAT$RUN.NO TO CNT.RSTAT(1);   * Sequential run no
EQU CNT.RSTAT$DT TO CNT.RSTAT(2);       * System date of run
EQU CNT.RSTAT$CN.MAX TO CNT.RSTAT(3);   * Maximum avail items
EQU CNT.RSTAT$CN TO CNT.RSTAT(4);       * Current count in this run
EQU CNT.RSTAT$SKIP.CN TO CNT.RSTAT(5);  * Number of skipped items
EQU CNT.RSTAT$UPD.CN TO CNT.RSTAT(6);   * Number of items updated
EQU CNT.RSTAT$PUPD.CN TO CNT.RSTAT(7);  * Number of items partially updated
EQU CNT.RSTAT$ELP TO CNT.RSTAT(8);      * Total elapsed time
EQU CNT.RSTAT$SKIP.TM TO CNT.RSTAT(9);  * Amount of time of skipped items
EQU CNT.RSTAT$UPD.TM TO CNT.RSTAT(10);  * Amount of time for updated items
EQU CNT.RSTAT$PUPD.TM TO CNT.RSTAT(11); * Total time on partial updates
EQU CNT.RSTAT$LN TO CNT.RSTAT(12);      * Line to display bar on
EQU CNT.RSTAT$CL TO CNT.RSTAT(13);      * Columm to display bar
EQU CNT.RSTAT$LH TO CNT.RSTAT(14);      * Length of completion bar
EQU CNT.RSTAT$PERCENT TO CNT.RSTAT(15); * Percentage interval between bar update
EQU CNT.RSTAT$UNITS TO CNT.RSTAT(16);   * Number of units to update compl. bar
EQU CNT.RSTAT$MISC1 TO CNT.RSTAT(17);   * Miscellaneous field one
EQU CNT.RSTAT$MISC2 TO CNT.RSTAT(18);   * Misc. field 2
EQU CNT.RSTAT$MISC3 TO CNT.RSTAT(19);   * Misc field 3
EQU CNT.RSTAT$MISC4 TO CNT.RSTAT(20);   * Misc field 4
EQU CNT.RSTAT$TM TO CNT.RSTAT(21);      * Sytem Time of run
EQU CNT.RSTAT$END.DT TO CNT.RSTAT(22);  * System time at run end
EQU CNT.RSTAT$END.TM TO CNT.RSTAT(23);  * System time at run end
~CNT.RSTAT.VAR.EQUATES~
*CODE.SEGMENT: CNT.RSTAT.VAR.EQUATES
*
* FILE 'CNT.RSTAT' EQUATES - GENERATED 21:22:34  06 DEC 1991
EQU CNT.RSTAT$RUN.NO TO 1;              * Sequential run no
EQU CNT.RSTAT$DT TO 2;                  * System date of run
EQU CNT.RSTAT$CN.MAX TO 3;              * Maximum avail items
EQU CNT.RSTAT$CN TO 4;                  * Current count in this run
EQU CNT.RSTAT$SKIP.CN TO 5;             * Number of skipped items
EQU CNT.RSTAT$UPD.CN TO 6;              * Number of items updated
EQU CNT.RSTAT$PUPD.CN TO 7;             * Number of items partially updated
EQU CNT.RSTAT$ELP TO 8;                 * Total elapsed time
EQU CNT.RSTAT$SKIP.TM TO 9;             * Amount of time of skipped items
EQU CNT.RSTAT$UPD.TM TO 10;             * Amount of time for updated items
EQU CNT.RSTAT$PUPD.TM TO 11;            * Total time on partial updates
EQU CNT.RSTAT$LN TO 12;                 * Line to display bar on
EQU CNT.RSTAT$CL TO 13;                 * Columm to display bar
EQU CNT.RSTAT$LH TO 14;                 * Length of completion bar
EQU CNT.RSTAT$PERCENT TO 15;            * Percentage interval between bar update
EQU CNT.RSTAT$UNITS TO 16;              * Number of units to update compl. bar
EQU CNT.RSTAT$MISC1 TO 17;              * Miscellaneous field one
EQU CNT.RSTAT$MISC2 TO 18;              * Misc. field 2
EQU CNT.RSTAT$MISC3 TO 19;              * Misc field 3
EQU CNT.RSTAT$MISC4 TO 20;              * Misc field 4
EQU CNT.RSTAT$TM TO 21;                 * Sytem Time of run
EQU CNT.RSTAT$END.DT TO 22;             * System time at run end
EQU CNT.RSTAT$END.TM TO 23;             * System time at run end
~CNT.TST.DIM~
*CODE.SEGMENT: ?
DIM CNT.TST(25)
~CNT.TST.EQUATES~
*CODE.SEGMENT: CNT.TST.EQUATES
*
* FILE 'CNT.TST' EQUATES - GENERATED 12:26:03  14 JAN 1992
EQU CNT.TST$SYS TO CNT.TST(1);          * 
EQU CNT.TST$RTN TO CNT.TST(2);          * 
EQU CNT.TST$LBL TO CNT.TST(3);          * 
EQU CNT.TST$FILE TO CNT.TST(4);         * 
EQU CNT.TST$LIST.NAME TO CNT.TST(5);    * 
EQU CNT.TST$TEST.DT TO CNT.TST(6);      * 
EQU CNT.TST$BREAK TO CNT.TST(7);        * 
EQU CNT.TST$TIMING TO CNT.TST(8);       * 
EQU CNT.TST$TA TO CNT.TST(9);           * 
EQU CNT.TST$APPL TO CNT.TST(10);        * 
EQU CNT.TST$PARAMS TO CNT.TST(11);      * 
EQU CNT.TST$PAUSE TO CNT.TST(12);       * 
EQU CNT.TST$CR TO CNT.TST(13);          * 
EQU CNT.TST$LISTS TO CNT.TST(14);       * 
EQU CNT.TST$ID TO CNT.TST(15);          * 
EQU CNT.TST$ON TO CNT.TST(16);          * Test mode is on
EQU CNT.TST$X TO CNT.TST(17);           * 
EQU CNT.TST$Y TO CNT.TST(18);           * 
EQU CNT.TST$Z TO CNT.TST(19);           * 
EQU CNT.TST$MAINT TO CNT.TST(20);       * Activate Maintenance subroutine
~CNT.TST.VAR.EQUATES~
*CODE.SEGMENT: CNT.TST.VAR.EQUATES
*
* FILE 'CNT.TST' EQUATES - GENERATED 12:26:04  14 JAN 1992
EQU CNT.TST$SYS TO 1;                   * 
EQU CNT.TST$RTN TO 2;                   * 
EQU CNT.TST$LBL TO 3;                   * 
EQU CNT.TST$FILE TO 4;                  * 
EQU CNT.TST$LIST.NAME TO 5;             * 
EQU CNT.TST$TEST.DT TO 6;               * 
EQU CNT.TST$BREAK TO 7;                 * 
EQU CNT.TST$TIMING TO 8;                * 
EQU CNT.TST$TA TO 9;                    * 
EQU CNT.TST$APPL TO 10;                 * 
EQU CNT.TST$PARAMS TO 11;               * 
EQU CNT.TST$PAUSE TO 12;                * 
EQU CNT.TST$CR TO 13;                   * 
EQU CNT.TST$LISTS TO 14;                * 
EQU CNT.TST$ID TO 15;                   * 
EQU CNT.TST$ON TO 16;                   * Call to test flag mntc is on
EQU CNT.TST$X TO 17;                    * 
EQU CNT.TST$Y TO 18;                    * 
EQU CNT.TST$Z TO 19;                    * 
~CNT.VAR.EQUATES~
*CODE.SEGMENT: CNT.VAR.EQUATES
*
* FILE 'CNT' EQUATES - GENERATED 16:33:28  04 JUN 1993
~CNT.XPVCTL.DIM~
*CODE.SEGMENT: ?
* INCREASED 07-MAY-95 FROM 10.
DIM CNT.XPVCTL(15)
~CNT.XPVCTL.EQUATES~
*CODE.SEGMENT: CNT.XPVCTL.EQUATES
*
* FILE 'CNT.XPVCTL' EQUATES - GENERATED 21:23:52  20 DEC 1993
* REVISED 07-MAY-95 (ADDED 10 TO 13).
EQU CNT.XPVCTL$CO.NO.IND TO CNT.XPVCTL(1);    * Companies using Impulse PPV
EQU CNT.XPVCTL$CO.NO.PRE TO CNT.XPVCTL(2);    * Company number prefixes
EQUCNT.XPVCTL$SPLIT.DT TO CNT.XPVCTL(3);      * Index of validation/split dates
EQU CNT.XPVCTL$REC.VAL.CN TO CNT.XPVCTL(4);   * Index of Split valid record counts
EQU CNT.XPVCTL$REC.ERR.CN TO CNT.XPVCTL(5);   * Index of Split error record counts
EQU CNT.XPVCTL$REC.TOT.CN TO CNT.XPVCTL(6);   * Index of Split total record counts
EQU CNT.XPVCTL$EVENT.VAL.CN TO CNT.XPVCTL(7); * Index of Split valid event counts
EQU CNT.XPVCTL$EVENT.ERR.CN TO CNT.XPVCTL(8); * Index of Split error event counts
EQU CNT.XPVCTL$EVENT.TOT.CN TO CNT.XPVCTL(9); * Index of Split total event counts
EQU CNT.XPVCTL$EVENT.MAN.CN TO CNT.XPVCTL(10); * Index of Split manual event price counts
EQU CNT.XPVCTL$VAL.VAL.CN TO CNT.XPVCTL(11);  * Index of Validation valid Terminal counts
EQU CNT.XPVCTL$VAL.ERR.CN TO CNT.XPVCTL(12);  * Index of Validation invalid Terminal counts
EQU CNT.XPVCTL$VAL.TOT.CN TO CNT.XPVCTL(13);  * Index of Validation total Terminal counts
~CNT.XTRIND.DIM~
*CODE.SEGMENT: ?
DIM CNT.XTRIND(10)
~CNT.XTRIND.EQUATES~
*CODE.SEGMENT: CNT.XTRIND.EQUATES
*
* FILE 'CNT.XTRIND' EQUATES - GENERATED 21:23:52  06 DEC 1991
EQU CNT.XTRIND$CO.NO.IND TO CNT.XTRIND(1);   * Index of Co Prefixes using Lock Box
EQU CNT.XTRIND$INDEX TO CNT.XTRIND(2);       * Index of transmission dates
EQU CNT.XTRIND$REC.CN TO CNT.XTRIND(3);      * Record counter
EQU CNT.XTRIND$REMT.CN TO CNT.XTRIND(4);     * Remitance counter for trans.
EQU CNT.XTRIND$TOT.REMT TO CNT.XTRIND(5);    * Total remitances
EQU CNT.XTRIND$ERR.CN TO CNT.XTRIND(6);      * Count of errors for ea trans.
EQU CNT.XTRIND$FAILED TO CNT.XTRIND(7);      * Transmission failed flag
EQU CNT.XTRIND$ERR TO CNT.XTRIND(8);         * Transmission error tables
EQU CNT.XTRIND$CO.NO.PRE TO CNT.XTRIND(9);   * Companies (Pick Accounts)
EQU CNT.XTRIND$SPLIT TO CNT.XTRIND(10);      * Transmission has been split
~CNT.XTRIND.VAR.EQUATES~
*CODE.SEGMENT: CNT.XTRIND.VAR.EQUATES
*
* FILE 'CNT.XTRIND' EQUATES - GENERATED 21:23:52  06 DEC 1991
EQU CNT.XTRIND$CO.NO.IND TO 1;          * Index of companies using Lock Box
EQU CNT.XTRIND$INDEX TO 2;              * Index of transmission dates
EQU CNT.XTRIND$REC.CN TO 3;             * Record counter
EQU CNT.XTRIND$REMT.CN TO 4;            * Remitance counter for trans.
EQU CNT.XTRIND$TOT.REMT TO 5;           * Total remitances
EQU CNT.XTRIND$ERR.CN TO 6;             * Count of errors for ea trans.
EQU CNT.XTRIND$FAILED TO 7;             * Transmission failed flag
EQU CNT.XTRIND$ERR TO 8;                * Transmission error tables
EQU CNT.XTRIND$CO.NO.PRE TO 9;          * Company number prefix
EQU CNT.XTRIND$SPLIT TO 10;             * Transmission has been split
~CNTR.EQUATES~
*CODE.SEGMENT: CNTR.EQUATES
*
* AUTHOR: DAVID G. HORSMAN
*
* FILE 'CNTR.REC' EQUATES - GENERATED 15:53:29  15 AUG 1984
EQU EI.IA.V.S TO CNTR.REC(1); * VALID STANDARD INFO. AREAS
EQU EI.IA.A TO CNTR.REC(2);     * ADDITIONAL VALID IA'S AND VALID ACTIONS
EQU EI.IA.V.A TO CNTR.REC(3);   * VALID ACTIONS ON STANDARD IA'S
EQU EI.IA.P.S TO CNTR.REC(4);       * INFO-AREA PREFIX/SUFFIX FLAG
EQU EI.U.P.S TO CNTR.REC(5);     * USER FILE/KEY PREFIX/SUFFIX FLAG
EQU EI.V.F TO CNTR.REC(6);      * DATA PROCESSING VERIFICATION ACTION FLAG
EQU EI.A.M TO CNTR.REC(7);      * ENTITY KEY INPUT METHOD FLAG
EQU EI.P.F TO CNTR.REC(8);       * The root of the information file.
EQU EI.S.F TO CNTR.REC(9);     * The name of the secondary info file.
EQU EI.P.C TO CNTR.REC(10);  * A series of commands and screen input.
~COM.AI.DIM~
*CODE.SEGMENT: COM.AI.DIM
*
DIM COM.AI(70)
~COM.AI.EQUATES~
*CODE.SEGMENT: COM.AI.EQUATES
*
* FILE 'COM.AI' EQUATES - GENERATED 04:01:53  06 JUN 1994
EQU COM.AI$DB.PREFIX TO COM.AI(1);      * Interface code or BP ID Prefix for call
EQU COM.AI$NAME TO COM.AI(2);           * Addressable Interface Description
EQU COM.AI$TYPE TO COM.AI(3);           * Addressable Interface Type
EQU COM.AI$RSVD.4 TO COM.AI(4);         * Reserved
EQU COM.AI$CTLR.PORT TO COM.AI(5);      * Billing Computer Port Number
EQU COM.AI$BILL.CUTOFF.TM TO COM.AI(6); * cutoff time for current day's Billing
EQU COM.AI$MODEL.SERIAL.NO TO COM.AI(7);* Mfg's model no, serial no, or site desc.
EQU COM.AI$DF.SVCS.ONE TO COM.AI(8);    * Default Services, One address / device
EQU COM.AI$DF.COUT.ONE TO COM.AI(9);    * Default Conn Outlets, One address / device
EQU COM.AI$DF.SVCS.EIGHT TO COM.AI(10); * Default Services, Eight addresses / device
EQU COM.AI$DF.COUT.EIGHT TO COM.AI(11); * Default Conn Outlets, Eight addresses / device
EQU COM.AI$COMMPORT TO COM.AI(12);      * Two letter code for head end
EQU COM.AI$UP.DN TO COM.AI(13);         * Program will execute commands or not
EQU COM.AI$UP.DN.DT TO COM.AI(14);      * Date U/D command issued
EQU COM.AI$UP.DN.TM TO COM.AI(15);      * Time U/D command issued
EQU COM.AI$ON.OFF TO COM.AI(16);        * Port is to log on or log off
EQU COM.AI$ON.OFF.DT TO COM.AI(17);     * Date On/Off command was issued
EQU COM.AI$ON.OFF.TM TO COM.AI(18);     * Time On/Off command was issued
EQU COM.AI$LOGGING TO COM.AI(19);       * Is command logging done (Y/N)
EQU COM.AI$TEST.MODE TO COM.AI(20);     * Test flag for this interface device
EQU COM.AI$UP.DN.C.DT TO COM.AI(21);    * Date UP/DN command completed
EQU COM.AI$UP.DN.C.TM TO COM.AI(22);    * Time UP/DN command completed
EQU COM.AI$ON.OFF.C.DT TO COM.AI(23);   * Date ON/OFF command completed
EQU COM.AI$ON.OFF.C.TM TO COM.AI(24);   * Time ON/OFF command completed
EQU COM.AI$OPER TO COM.AI(25);          * Operator who last updated control record
EQU COM.AI$UP.DN.STAT TO COM.AI(26);    * True interface UP/DN status
EQU COM.AI$ON.OFF.STAT TO COM.AI(27);   * True interface ON/OFF status
EQU COM.AI$FUNC.DT TO COM.AI(28);       * Date last function was completed
EQU COM.AI$FUNC.TM TO COM.AI(29);       * Time last functions was completed
EQU COM.AI$COMMAND.DT TO COM.AI(30);    * Date last command was completed (SUBSCR)
EQU COM.AI$COMMAND.TM TO COM.AI(31);    * Time last command was completed (SUBSCR)
EQU COM.AI$FUNC TO COM.AI(32);          * Last function completed
EQU COM.AI$COMMAND TO COM.AI(33);       * Command last completed
EQU COM.AI$ON.OFF.BY TO COM.AI(34);     * Operator who issued ON/OFF function
EQU COM.AI$UP.DN.BY TO COM.AI(35);      * Operator who issued UP/DN function
EQU COM.AI$STD.PAUSE TO COM.AI(36);     * Standard Pause when handler idling
EQU COM.AI$MAX.PAUSE TO COM.AI(37);     * Maximum time before handler time out
EQU COM.AI$FUNC.PORT TO COM.AI(38);     * Priority command from port # 999
EQU COM.AI$RESET.FREQ TO COM.AI(39);    * Number of seconds between handler resets
EQU COM.AI$SCAN.FREQ TO COM.AI(40);     * number of secs between checking CSR's
EQU COM.AI$SCAN.SLICE TO COM.AI(41);    * No of secs to spend checking CSR's
EQU COM.AI$PORT.ID TO COM.AI(42);       * The port id (DICT ACC) of this port #
EQU COM.AI$DF.XREF.ONE TO COM.AI(43);   * Service to Labeled Tier cross-reference
EQU COM.AI$DF.XREF.EIGHT TO COM.AI(44); * Service to Labeled Tier Xref
EQU COM.AI$INDEXED TO COM.AI(45);       * Service to Tier Indexing Method
EQU COM.AI$DISC.ROLL TO COM.AI(46);     * Roll a truck on a Disconnect W/O
EQU COM.AI$CONN.ROLL TO COM.AI(47);     * Roll a truck on a Connect W/O
EQU COM.AI$CHNG.ROLL TO COM.AI(48);     * Roll a truch on a Service Change W/O
EQU COM.AI$CHAN.DN.BRDCST TO COM.AI(49);* Broadcast Downed Channels to Control sys
EQU COM.AI$SINGLE TO COM.AI(50);        * Single Address vs Multiple Addr's.
EQU COM.AI$ADDR.PER.UNIT TO COM.AI(51); * # of addr. per multi address device
EQU COM.AI$TIER.PER.UNIT TO COM.AI(52); * # of tiers per each on-premise unit
EQU COM.AI$PORT.PASS TO COM.AI(53);     * Password for this account or port.
EQU COM.AI$PAUSE.CHAR TO COM.AI(54);    * Cycle to pause for between characters
EQU COM.AI$PAUSE.LINE TO COM.AI(55);    * Cycles to pause for between lines
EQU COM.AI$PAUSE.RESP TO COM.AI(56);    * Time-out value waiting for a response
EQU COM.AI$MONITOR.PORT TO COM.AI(57);  * Port number of monitor
EQU COM.AI$GENIE.WINDOW TO COM.AI(58);  * Is the services window avail. for msgs
EQU COM.AI$SEND.ON TO COM.AI(59);       * Send ON packet to interface
EQU COM.AI$SEND.OFF TO COM.AI(60);      * Send OFF packet to interface
EQU COM.AI$DF.TIER.ONE TO COM.AI(61);   * Spigott number of service (1 * 8sp)
EQU COM.AI$DF.TIER.EIGHT TO COM.AI(62); * Spigott of eight addr dvc (or 4 * 2 sp)
EQU COM.AI$DVC.UNIT TO COM.AI(63);      * Devices used by then AI
EQU COM.AI$ERR TO COM.AI(64);           * Last error recorded by monitor
EQU COM.AI$HEADEND TO COM.AI(65);       * Headends serviced by this control port
EQU COM.AI$MONITOR.CURR TO COM.AI(66);  * Current monitor port
EQU COM.AI$MONITOR.DT TO COM.AI(67);    * Last date monitor active
EQU COM.AI$MONITOR.TM TO COM.AI(68);    * Last time monitor was active
EQU COM.AI$PAUSE.TS   TO COM.AI(69);    * Timeslice while idling
EQU COM.AI$FUNC.TS    TO COM.AI(70);    * Timeslice while active
~COM.AI.VAR.EQUATES~
*CODE.SEGMENT: COM.AI.VAR.EQUATES
*
* FILE 'COM.AI' EQUATES - GENERATED 04:01:54  06 JUN 1994
EQU COM.AI$DB.PREFIX TO 1;              * Interface code or BP ID Prefix for call
EQU COM.AI$NAME TO 2;                   * Addressable Interface Description
EQU COM.AI$TYPE TO 3;                   * Addressable Interface Type
EQU COM.AI$RSVD.4 TO 4;                 * Reserved
EQU COM.AI$CTLR.PORT TO 5;              * Billing Computer Port Number
EQU COM.AI$BILL.CUTOFF.TM TO 6;         * cutoff time for current day's Billing
EQU COM.AI$MODEL.SERIAL.NO TO 7;        * Mfg's model no, serial no, or site desc.
EQU COM.AI$DF.SVCS.ONE TO 8;            * Default Services, One address / device
EQU COM.AI$DF.COUT.ONE TO 9;            * Default Conn Outlets, One address / device
EQU COM.AI$DF.SVCS.EIGHT TO 10;         * Default Services, Eight addresses / device
EQU COM.AI$DF.COUT.EIGHT TO 11;         * Default Conn Outlets, Eight addresses / device
EQU COM.AI$COMMPORT TO 12;              * Two letter code for head end
EQU COM.AI$UP.DN TO 13;                 * Program will execute commands or not
EQU COM.AI$UP.DN.DT TO 14;              * Date U/D command issued
EQU COM.AI$UP.DN.TM TO 15;              * Time U/D command issued
EQU COM.AI$ON.OFF TO 16;                * Port is to log on or log off
EQU COM.AI$ON.OFF.DT TO 17;             * Date On/Off command was issued
EQU COM.AI$ON.OFF.TM TO 18;             * Time On/Off command was issued
EQU COM.AI$LOGGING TO 19;               * Is command logging done (Y/N)
EQU COM.AI$TEST.MODE TO 20;             * Test flag for this interface device
EQU COM.AI$UP.DN.C.DT TO 21;            * Date UP/DN command completed
EQU COM.AI$UP.DN.C.TM TO 22;            * Time UP/DN command completed
EQU COM.AI$ON.OFF.C.DT TO 23;           * Date ON/OFF command completed
EQU COM.AI$ON.OFF.C.TM TO 24;           * Time ON/OFF command completed
EQU COM.AI$OPER TO 25;                  * Operator who last updated control record
EQU COM.AI$UP.DN.STAT TO 26;            * True interface UP/DN status
EQU COM.AI$ON.OFF.STAT TO 27;           * True interface ON/OFF status
EQU COM.AI$FUNC.DT TO 28;               * Date last function was completed
EQU COM.AI$FUNC.TM TO 29;               * Time last functions was completed
EQU COM.AI$COMMAND.DT TO 30;            * Date last command was completed (SUBSCR)
EQU COM.AI$COMMAND.TM TO 31;            * Time last command was completed (SUBSCR)
EQU COM.AI$FUNC TO 32;                  * Last function completed
EQU COM.AI$COMMAND TO 33;               * Command last completed
EQU COM.AI$ON.OFF.BY TO 34;             * Operator who issued ON/OFF function
EQU COM.AI$UP.DN.BY TO 35;              * Operator who issued UP/DN function
EQU COM.AI$STD.PAUSE TO 36;             * Standard Pause when handler idling
EQU COM.AI$MAX.PAUSE TO 37;             * Maximum time before handler time out
EQU COM.AI$FUNC.PORT TO 38;             * Priority command from port # 999
EQU COM.AI$RESET.FREQ TO 39;            * Number of seconds between handler resets
EQU COM.AI$SCAN.FREQ TO 40;             * number of secs between checking CSR's
EQU COM.AI$SCAN.SLICE TO 41;            * No of secs to spend checking CSR's
EQU COM.AI$PORT.ID TO 42;               * The port id (DICT ACC) of this port #
EQU COM.AI$DF.XREF.ONE TO 43;           * Service to Labeled Tier cross-reference
EQU COM.AI$DF.XREF.EIGHT TO 44;         * Service to Labeled Tier Xref
EQU COM.AI$INDEXED TO 45;               * Service to Tier Indexing Method
EQU COM.AI$DISC.ROLL TO 46;             * Roll a truck on a Disconnect W/O
EQU COM.AI$CONN.ROLL TO 47;             * Roll a truck on a Connect W/O
EQU COM.AI$CHNG.ROLL TO 48;             * Roll a truch on a Service Change W/O
EQU COM.AI$CHAN.DN.BRDCST TO 49;        * Broadcast Downed Channels to Control sys
EQU COM.AI$SINGLE TO 50;                * Single Address vs Multiple Addr's.
EQU COM.AI$ADDR.PER.UNIT TO 51;         * # of addr. per multi address device
EQU COM.AI$TIER.PER.UNIT TO 52;         * # of tiers per each on-premise unit
EQU COM.AI$PORT.PASS TO 53;             * Password for this account or port.
EQU COM.AI$PAUSE.CHAR TO 54;            * Cycle to pause for between characters
EQU COM.AI$PAUSE.LINE TO 55;            * Cycles to pause for between lines
EQU COM.AI$PAUSE.RESP TO 56;            * Time-out value waiting for a response
EQU COM.AI$MONITOR.PORT TO 57;          * Port number of monitor
EQU COM.AI$GENIE.WINDOW TO 58;          * Is the services window avail. for msgs
EQU COM.AI$SEND.ON TO 59;               * Send ON packet to interface
EQU COM.AI$SEND.OFF TO 60;              * Send OFF packet to interface
EQU COM.AI$DF.TIER.ONE TO 61;           * Spigott number of service (1 * 8sp)
EQU COM.AI$DF.TIER.EIGHT TO 62;         * Spigott of eight addr dvc (or 4 * 2 sp)
EQU COM.AI$DVC.UNIT TO 63;              * Devices used by then AI
EQU COM.AI$ERR TO 64;                   * Last error recorded by monitor
EQU COM.AI$HEADEND TO 65;               * Headends serviced by this control port
EQU COM.AI$MONITOR.CURR TO 66;          * Current monitor port
EQU COM.AI$MONITOR.DT TO 67;            * Last date monitor active
EQU COM.AI$MONITOR.TM TO 68;            * Last time monitor was active
~COM.AIHERR.DIM~
*CODE.SEGMENT: COM.AIHERR.DIM
*
DIM COM.AIHERR(15)
~COM.AIHERR.EQUATES~
*CODE.SEGMENT: COM.AIHERR.EQUATES
*
* FILE 'COM.AIHERR' EQUATES - GENERATED 22:07:56  28 MAR 1992
EQU COM.AIHERR$STD TO COM.AIHERR(1);    * Standard Handler Error Code
EQU COM.AIHERR$RCVD TO COM.AIHERR(2);   * Error received from Head End
EQU COM.AIHERR$DESC TO COM.AIHERR(3);   * Description / Error text
EQU COM.AIHERR$RETRY TO COM.AIHERR(4);  * Number of retries
EQU COM.AIHERR$PAUSE TO COM.AIHERR(5);  * No of sec before Retry
EQU COM.AIHERR$LOG TO COM.AIHERR(6);    * Log this type of error
EQU COM.AIHERR$FUNC TO COM.AIHERR(7);   * Function to perform to fix error
EQU COM.AIHERR$DISP TO COM.AIHERR(8);   * Message to be sent to dispatcher
EQU COM.AIHERR$MNGR TO COM.AIHERR(9);   * Message to be sent office manager
EQU COM.AIHERR$TYPE TO COM.AIHERR(10);  * Type of error
EQU COM.AIHERR$VAR TO COM.AIHERR(11);   * Variable to be set with this value
~COM.AIHERR.VAR.EQUATES~
*CODE.SEGMENT: COM.AIHERR.VAR.EQUATES
*
* FILE 'COM.AIHERR' EQUATES - GENERATED 22:07:56  28 MAR 1992
EQU COM.AIHERR$STD TO 1;                * Standard Handler Error Code
EQU COM.AIHERR$RCVD TO 2;               * Error received from Head End
EQU COM.AIHERR$DESC TO 3;               * Description / Error text
EQU COM.AIHERR$RETRY TO 4;              * Number of retries
EQU COM.AIHERR$PAUSE TO 5;              * No of sec before Retry
EQU COM.AIHERR$LOG TO 6;                * Log this type of error
EQU COM.AIHERR$FUNC TO 7;               * Function to perform to fix error
EQU COM.AIHERR$DISP TO 8;               * Message to be sent to dispatcher
EQU COM.AIHERR$MNGR TO 9;               * Message to be sent office manager
EQU COM.AIHERR$TYPE TO 10;              * Type of error
EQU COM.AIHERR$VAR TO 11;               * Variable to be set with this value
~COM.AIICMD.DIM~
*CODE.SEGMENT: COM.AIICMD.DIM
DIM COM.AIICMD(15)
~COM.AIICMD.EQUATES~
*CODE.SEGMENT: COM.AIICMD.EQUATES
*
* FILE 'COM.AIICMD' EQUATES - GENERATED 00:48:10  22 APR 1994
EQU COM.AIICMD$STD TO COM.AIICMD(1);    * Standard Handler Error Code
EQU COM.AIICMD$RCVD TO COM.AIICMD(2);   * Error received from Head End
EQU COM.AIICMD$DESC TO COM.AIICMD(3);   * Description / Error text
EQU COM.AIICMD$RETRY TO COM.AIICMD(4);  * Number of retries
EQU COM.AIICMD$PAUSE TO COM.AIICMD(5);  * No of sec before Retry
EQU COM.AIICMD$LOG TO COM.AIICMD(6);    * Log this type of error
EQU COM.AIICMD$FUNC TO COM.AIICMD(7);   * Function to perform to fix error
EQU COM.AIICMD$DISP TO COM.AIICMD(8);   * Message to be sent to dispatcher
EQU COM.AIICMD$MNGR TO COM.AIICMD(9);   * Message to be sent office manager
EQU COM.AIICMD$TYPE TO COM.AIICMD(10);  * Type of error
EQU COM.AIICMD$VAR TO COM.AIICMD(11);   * Variable to be set with this value
EQU COM.AIICMD$CMD.ACTV TO COM.AIICMD(12);   * 
EQU COM.AIICMD$BOX.SEL TO COM.AIICMD(13);    * 
EQU COM.AIICMD$BOX.CMD TO COM.AIICMD(14);    * 
~COM.AIICMD.VAR.EQUATES~
*CODE.SEGMENT: COM.AIICMD.VAR.EQUATES
*
* FILE 'COM.AIICMD' EQUATES - GENERATED 00:48:10  22 APR 1994
EQU COM.AIICMD$STD TO 1;                * Standard Handler Error Code
EQU COM.AIICMD$RCVD TO 2;               * Error received from Head End
EQU COM.AIICMD$DESC TO 3;               * Description / Error text
EQU COM.AIICMD$RETRY TO 4;              * Number of retries
EQU COM.AIICMD$PAUSE TO 5;              * No of sec before Retry
EQU COM.AIICMD$LOG TO 6;                * Log this type of error
EQU COM.AIICMD$FUNC TO 7;               * Function to perform to fix error
EQU COM.AIICMD$DISP TO 8;               * Message to be sent to dispatcher
EQU COM.AIICMD$MNGR TO 9;               * Message to be sent office manager
EQU COM.AIICMD$TYPE TO 10;              * Type of error
EQU COM.AIICMD$VAR TO 11;               * Variable to be set with this value
EQU COM.AIICMD$CMD.ACTV TO 12;          * 
EQU COM.AIICMD$BOX.SEL TO 13;           * 
EQU COM.AIICMD$BOX.CMD TO 14;           * 
~COM.AIIERR.DIM~
*CODE.SEGMENT: COM.AIIERR.DIM
*
DIM COM.AIIERR(15)
~COM.AIIERR.EQUATES~
*CODE.SEGMENT: COM.AIIERR.EQUATES
*
* FILE 'COM.AIIERR' EQUATES - GENERATED 22:10:40  28 MAR 1992
EQU COM.AIIERR$STD TO COM.AIIERR(1);    * Standard Handler Error Code
EQU COM.AIIERR$RCVD TO COM.AIIERR(2);   * Error received from Head End
EQU COM.AIIERR$DESC TO COM.AIIERR(3);   * Description / Error text
EQU COM.AIIERR$RETRY TO COM.AIIERR(4);  * Number of retries
EQU COM.AIIERR$PAUSE TO COM.AIIERR(5);  * No of sec before Retry
EQU COM.AIIERR$LOG TO COM.AIIERR(6);    * Log this type of error
EQU COM.AIIERR$FUNC TO COM.AIIERR(7);   * Function to perform to fix error
EQU COM.AIIERR$DISP TO COM.AIIERR(8);   * Message to be sent to dispatcher
EQU COM.AIIERR$MNGR TO COM.AIIERR(9);   * Message to be sent office manager
EQU COM.AIIERR$TYPE TO COM.AIIERR(10);  * Type of error
EQU COM.AIIERR$VAR TO COM.AIIERR(11);   * Variable to be set with this value
~COM.AIIERR.VAR.EQUATES~
*CODE.SEGMENT: COM.AIIERR.VAR.EQUATES
*
* FILE 'COM.AIIERR' EQUATES - GENERATED 22:10:40  28 MAR 1992
EQU COM.AIIERR$STD TO 1;                * Standard Handler Error Code
EQU COM.AIIERR$RCVD TO 2;               * Error received from Head End
EQU COM.AIIERR$DESC TO 3;               * Description / Error text
EQU COM.AIIERR$RETRY TO 4;              * Number of retries
EQU COM.AIIERR$PAUSE TO 5;              * No of sec before Retry
EQU COM.AIIERR$LOG TO 6;                * Log this type of error
EQU COM.AIIERR$FUNC TO 7;               * Function to perform to fix error
EQU COM.AIIERR$DISP TO 8;               * Message to be sent to dispatcher
EQU COM.AIIERR$MNGR TO 9;               * Message to be sent office manager
EQU COM.AIIERR$TYPE TO 10;              * Type of error
EQU COM.AIIERR$VAR TO 11;               * Variable to be set with this value
~COM.AIL.DIM~
*CODE.SEGMENT: COM.AIL.DIM
*
DIM AIL(50)
~COM.AIL.EQUATES~
*CODE.SEGMENT: COM.AIP.EQUATES
*
* FILE 'COM.AIP' EQUATES - GENERATED 11:21:11  28 MAR 1992
EQU COM.AIP$TIERS TO COM.AIP(1);        * String of tiers to be sent to Headend
EQU COM.AIP$TIERS.FUTR TO COM.AIP(2);   * Tiers to be sent to Headend (Temporary)
EQU COM.AIP$HE.PORT TO COM.AIP(3);      * Headend port # on billing computer
EQU COM.AIP$COMM TO COM.AIP(4);         * Command/function to be done by interface
EQU COM.AIP$ACCT.ID TO COM.AIP(5);      * Account id effected by command
EQU COM.AIP$ADD.ID TO COM.AIP(6);       * Address id effected by command
EQU COM.AIP$WKO.ID TO COM.AIP(7);       * Work Order ID requiring command
EQU COM.AIP$WKO.TYPE TO COM.AIP(8);     * Work Order Type
EQU COM.AIP$WKO.STAT TO COM.AIP(9);     * Work Order Status
EQU COM.AIP$INTFC.CODE TO COM.AIP(10);  * Interface Code (ie EA=Eagle)
EQU COM.AIP$DVC.ID TO COM.AIP(11);      * Device Id of on premise device
EQU COM.AIP$DVC.TYPE TO COM.AIP(12);    * Type of on premise device (1/8)
EQU COM.AIP$INTFC.STAT TO COM.AIP(13);  * Status of interface when finished
EQU COM.AIP$WKO.INST TO COM.AIP(14);    * Work Order Installer
EQU COM.AIP$COMM.DT TO COM.AIP(15);     * Date command was issued
EQU COM.AIP$COMM.TM TO COM.AIP(16);     * Time command was issued
EQU COM.AIP$COMM.C.DT TO COM.AIP(17);   * Date command was completed
EQU COM.AIP$COMM.C.TM TO COM.AIP(18);   * Time command was completed
EQU COM.AIP$COMM.PORT TO COM.AIP(19);   * Port command was issued by
EQU COM.AIP$HEX.COMM TO COM.AIP(20);    * Hexadecimal format of command
EQU COM.AIP$HEX.RSLT TO COM.AIP(21);    * Hexadecimal result code of command
EQU COM.AIP$COMM.RSLT TO COM.AIP(22);   * Result code of command
EQU COM.AIP$ERR TO COM.AIP(23);         * Error code from sending of command
EQU COM.AIP$SVC.ID TO COM.AIP(24);      * Services effected by command
EQU COM.AIP$SVC.FUNC TO COM.AIP(25);    * Function being done to service
EQU COM.AIP$SVC.CHAN TO COM.AIP(26);    * Channels belonging to service
EQU COM.AIP$GROUP TO COM.AIP(27);       * Address ID of AI device where installed
EQU COM.AIP$GROUP.RSLT TO COM.AIP(28);  * Result effecting Address ID or AI
EQU COM.AIP$WKO.SCHED TO COM.AIP(29);   * Schedule information from work order
EQU COM.AIP$OPER TO COM.AIP(30);        * Operator requesting interface action
EQU COM.AIP$SVC.ID.FUTR TO COM.AIP(31); * Future Services for this device
EQU COM.AIP$LOG.DISPL TO COM.AIP(32);   * Log has been display by Display Monitor
EQU COM.AIP$LOG.PRINT TO COM.AIP(33);   * Has transaction been printed on the Log
EQU COM.AIP$LOG.ACK.DI TO COM.AIP(34);  * Has the Dispatched Acknowledged this
EQU COM.AIP$LOG.ACK.BR TO COM.AIP(35);  * Has the Branch Mngr Acknowledged this
EQU COM.AIP$INTFC.TYPE TO COM.AIP(36);  * Type of Interface - On-prem or In-prem
EQU COM.AIP$TSTAT TO COM.AIP(37);       * Tier status (0/1) off/on
EQU COM.AIP$TSTAT.FUTR TO COM.AIP(38);  * Tier status future (0/1)
EQU COM.AIP$AIX.LOCATION TO COM.AIP(39);* Address number from ADD to AIX svrcs
EQU COM.AIP$AIX.ID TO COM.AIP(40);      * Item ID of the AIX id
EQU COM.AIP$LOG.REQD TO COM.AIP(41);    * Log transactions in update/abort
EQU COM.AIP$TINDEX TO COM.AIP(42);      * String of tiers to be transmitted to HE
EQU COM.AIP$LOG.SRCE TO COM.AIP(43);    * Source of tranaction log
EQU COM.AIP$PORT TO COM.AIP(44);        * Port number command issued from
EQU COM.AIP$SVC.EXTR TO COM.AIP(45);    * Extra Services / Features
EQU COM.AIP$HEADEND  TO COM.AIP(46);    * Headend command issued for
EQU COM.AIP$EVENT    TO COM.AIP(47);    * Events to be accessed
EQU COM.AIP$EVENT.FUNC TO COM.AIP(48);  * Event function to be done
EQU COM.AIP$DVC.FUNC   TO COM.AIP(49);  * Function  Available on device
EQU COM.AIP$DVC.FUNC.STAT TO COM.AIP(50); * Status of device function
~COM.AIP.DIM~
*CODE.SEGMENT: COM.AIP.DIM
*
DIM COM.AIP(75)
~COM.AIP.EQUATES~
*CODE.SEGMENT: COM.AIP.EQUATES
*
* FILE 'COM.AIP' EQUATES - GENERATED 18:45:15  29 JUN 1996
EQU COM.AIP$TIERS TO COM.AIP(1);        * String of tiers to be sent to Headend
EQU COM.AIP$TIERS.FUTR TO COM.AIP(2);   * Tiers to be sent to Headend (Temporary)
EQU COM.AIP$HE.PORT TO COM.AIP(3);      * Headend port # on billing computer
EQU COM.AIP$COMM TO COM.AIP(4);         * Command/function to be done by interface
EQU COM.AIP$ACCT.ID TO COM.AIP(5);      * Account id effected by command
EQU COM.AIP$ADD.ID TO COM.AIP(6);       * Address id effected by command
EQU COM.AIP$WKO.ID TO COM.AIP(7);       * Work Order ID requiring command
EQU COM.AIP$WKO.TYPE TO COM.AIP(8);     * Work Order Type
EQU COM.AIP$WKO.STAT TO COM.AIP(9);     * Work Order Status
EQU COM.AIP$INTFC.CODE TO COM.AIP(10);  * Interface Code (ie EA=Eagle)
EQU COM.AIP$DVC.ID TO COM.AIP(11);      * Device Id of on premise device
EQU COM.AIP$DVC.TYPE TO COM.AIP(12);    * Type of on premise device (1/8)
EQU COM.AIP$INTFC.STAT TO COM.AIP(13);  * Status of interface when finished
EQU COM.AIP$WKO.INST TO COM.AIP(14);    * Work Order Installer
EQU COM.AIP$COMM.DT TO COM.AIP(15);     * Date command was issued
EQU COM.AIP$COMM.TM TO COM.AIP(16);     * Time command was issued
EQU COM.AIP$COMM.C.DT TO COM.AIP(17);   * Date command was completed
EQU COM.AIP$COMM.C.TM TO COM.AIP(18);   * Time command was completed
EQU COM.AIP$COMM.PORT TO COM.AIP(19);   * Port command was issued by
EQU COM.AIP$HEX.COMM TO COM.AIP(20);    * Hexadecimal format of command
EQU COM.AIP$HEX.RSLT TO COM.AIP(21);    * Hexadecimal result code of command
EQU COM.AIP$COMM.RSLT TO COM.AIP(22);   * Result code of command
EQU COM.AIP$ERR TO COM.AIP(23);         * Error code from sending of command
EQU COM.AIP$SVC.ID TO COM.AIP(24);      * Services effected by command
EQU COM.AIP$SVC.FUNC TO COM.AIP(25);    * Function being done to service
EQU COM.AIP$SVC.CHAN TO COM.AIP(26);    * Channels belonging to service
EQU COM.AIP$GROUP TO COM.AIP(27);       * Address ID of AI device where installed
EQU COM.AIP$GROUP.RSLT TO COM.AIP(28);  * Result effecting Address ID or AI
EQU COM.AIP$WKO.SCHED TO COM.AIP(29);   * Schedule information from work order
EQU COM.AIP$OPER TO COM.AIP(30);        * Operator requesting interface action
EQU COM.AIP$SVC.ID.FUTR TO COM.AIP(31); * Future Services for this device
EQU COM.AIP$LOG.DISPL TO COM.AIP(32);   * Log has been display by Display Monitor
EQU COM.AIP$LOG.PRINT TO COM.AIP(33);   * Has transaction been printed on the Log
EQU COM.AIP$LOG.ACK.DI TO COM.AIP(34);  * Has the Dispatched Acknowledged this
EQU COM.AIP$LOG.ACK.BR TO COM.AIP(35);  * Has the Branch Mngr Acknowledged this
EQU COM.AIP$INTFC.TYPE TO COM.AIP(36);  * Type of Interface - On-prem or In-prem
EQU COM.AIP$TSTAT TO COM.AIP(37);       * Tier status (0/1) off/on
EQU COM.AIP$TSTAT.FUTR TO COM.AIP(38);  * Tier status future (0/1)
EQU COM.AIP$AIX.LOCATION TO COM.AIP(39);* Address number from ADD to AIX svrcs
EQU COM.AIP$AIX.ID TO COM.AIP(40);      * Item ID of the AIX id
EQU COM.AIP$LOG.REQD TO COM.AIP(41);    * Log transactions in update/abort
EQU COM.AIP$TINDEX TO COM.AIP(42);      * String of tiers to be transmitted to HE
EQU COM.AIP$COMM.SRCE TO COM.AIP(43);   * Source of command
EQU COM.AIP$PORT TO COM.AIP(44);        * Port number command issued from
EQU COM.AIP$SVC.EXTR TO COM.AIP(45);    * Extra Services / Features
EQU COM.AIP$HEADEND TO COM.AIP(46);     * Headend command issued for
EQU COM.AIP$EVENT TO COM.AIP(47);       * Events to be downloaded/uploaded
EQU COM.AIP$EVENT.FUNC TO COM.AIP(48);  * Event function to be done
EQU COM.AIP$DVC.FUNC TO COM.AIP(49);    * Function  Available on device
EQU COM.AIP$DVC.FUNC.STAT TO COM.AIP(50);    * Status of device function
EQU COM.AIP$WKO.SCH.TM TO COM.AIP(51);       * Sched time of WO, POC Encoder Group
EQU COM.AIP$WKO.SCH.TYPE TO COM.AIP(52);     * Sched type of WO, POC Encoder Member
EQU COM.AIP$LOG.TRAN.AIL TO COM.AIP(53);     * AI Logging Transaction #
EQU COM.AIP$TRAN.SEQ TO COM.AIP(54);         * AI Control Computer Tran Seq #
EQU COM.AIP$WKO.FUNC TO COM.AIP(55);         * Work Order Primary Function
EQU COM.AIP$EVENT.CH TO COM.AIP(56);         * Event Channel # to download
EQU COM.AIP$EVENT.DT TO COM.AIP(57);         * Event Date to download to POC
EQU COM.AIP$EVENT.TM TO COM.AIP(58);         * Start time to download to POC
EQU COM.AIP$EVENT.DUR TO COM.AIP(59);        * The event duration HH:MM
EQU COM.AIP$END.UPL TO COM.AIP(60);          * 'z' is end of upload from POC
EQU COM.AIP$INTFC.ERR TO COM.AIP(61);        * Error code or sending hardware
EQU COM.AIP$MAX.PAUSE TO COM.AIP(62);        * Maximum pause between progress updates
EQU COM.AIP$RETRY TO COM.AIP(63);            * Number of retries
EQU COM.AIP$COL.STATUS TO COM.AIP(64);       * Collection status returned
EQU COM.AIP$COMM.CN TO COM.AIP(65);          * Packet number (try #)
EQU COM.AIP$LOG.SRCE TO COM.AIP(66);         * Source of Log entry
EQU COM.AIP$LOG.LOC TO COM.AIP(67);          * Location of Log entry
EQU COM.AIP$LOG.ACCT TO COM.AIP(68);         * Account of Log entry
EQU COM.AIP$LOG.PROG TO COM.AIP(69);         * Subroutine of Log entry
EQU COM.AIP$LOG.PORT TO COM.AIP(70);         * Port of Log entry
EQU COM.AIP$INTFC.SET.BY TO COM.AIP(71);     * Interface action by routine
EQU COM.AIP$RVRS.FL TO COM.AIP(72);          * Interface to reverse on XCEL/TOUT
EQU COM.AIP$WKO.SCH.DT TO COM.AIP(73);       * Schedule date of work order
~COM.AIP.VAR.EQUATES~
*CODE.SEGMENT: COM.AIP.VAR.EQUATES
*
* FILE 'COM.AIP' EQUATES - GENERATED 18:45:15  29 JUN 1996
EQU COM.AIP$TIERS TO 1;                 * String of tiers to be sent to Headend
EQU COM.AIP$TIERS.FUTR TO 2;            * Tiers to be sent to Headend (Temporary)
EQU COM.AIP$HE.PORT TO 3;               * Headend port # on billing computer
EQU COM.AIP$COMM TO 4;                  * Command/function to be done by interface
EQU COM.AIP$ACCT.ID TO 5;               * Account id effected by command
EQU COM.AIP$ADD.ID TO 6;                * Address id effected by command
EQU COM.AIP$WKO.ID TO 7;                * Work Order ID requiring command
EQU COM.AIP$WKO.TYPE TO 8;              * Work Order Type
EQU COM.AIP$WKO.STAT TO 9;              * Work Order Status
EQU COM.AIP$INTFC.CODE TO 10;           * Interface Code (ie EA=Eagle)
EQU COM.AIP$DVC.ID TO 11;               * Device Id of on premise device
EQU COM.AIP$DVC.TYPE TO 12;             * Type of on premise device (1/8)
EQU COM.AIP$INTFC.STAT TO 13;           * Status of interface when finished
EQU COM.AIP$WKO.INST TO 14;             * Work Order Installer
EQU COM.AIP$COMM.DT TO 15;              * Date command was issued
EQU COM.AIP$COMM.TM TO 16;              * Time command was issued
EQU COM.AIP$COMM.C.DT TO 17;            * Date command was completed
EQU COM.AIP$COMM.C.TM TO 18;            * Time command was completed
EQU COM.AIP$COMM.PORT TO 19;            * Port command was issued by
EQU COM.AIP$HEX.COMM TO 20;             * Hexadecimal format of command
EQU COM.AIP$HEX.RSLT TO 21;             * Hexadecimal result code of command
EQU COM.AIP$COMM.RSLT TO 22;            * Result code of command
EQU COM.AIP$ERR TO 23;                  * Error code from sending of command
EQU COM.AIP$SVC.ID TO 24;               * Services effected by command
EQU COM.AIP$SVC.FUNC TO 25;             * Function being done to service
EQU COM.AIP$SVC.CHAN TO 26;             * Channels belonging to service
EQU COM.AIP$GROUP TO 27;                * Address ID of AI device where installed
EQU COM.AIP$GROUP.RSLT TO 28;           * Result effecting Address ID or AI
EQU COM.AIP$WKO.SCHED TO 29;            * Schedule information from work order
EQU COM.AIP$OPER TO 30;                 * Operator requesting interface action
EQU COM.AIP$SVC.ID.FUTR TO 31;          * Future Services for this device
EQU COM.AIP$LOG.DISPL TO 32;            * Log has been display by Display Monitor
EQU COM.AIP$LOG.PRINT TO 33;            * Has transaction been printed on the Log
EQU COM.AIP$LOG.ACK.DI TO 34;           * Has the Dispatched Acknowledged this
EQU COM.AIP$LOG.ACK.BR TO 35;           * Has the Branch Mngr Acknowledged this
EQU COM.AIP$INTFC.TYPE TO 36;           * Type of Interface - On-prem or In-prem
EQU COM.AIP$TSTAT TO 37;                * Tier status (0/1) off/on
EQU COM.AIP$TSTAT.FUTR TO 38;           * Tier status future (0/1)
EQU COM.AIP$AIX.LOCATION TO 39;         * Address number from ADD to AIX svrcs
EQU COM.AIP$AIX.ID TO 40;               * Item ID of the AIX id
EQU COM.AIP$LOG.REQD TO 41;             * Log transactions in update/abort
EQU COM.AIP$TINDEX TO 42;               * String of tiers to be transmitted to HE
EQU COM.AIP$COMM.SRCE TO 43;            * Source of command
EQU COM.AIP$PORT TO 44;                 * Port number command issued from
EQU COM.AIP$SVC.EXTR TO 45;             * Extra Services / Features
EQU COM.AIP$HEADEND TO 46;              * Headend command issued for
EQU COM.AIP$EVENT TO 47;                * Events to be downloaded/uploaded
EQU COM.AIP$EVENT.FUNC TO 48;           * Event function to be done
EQU COM.AIP$DVC.FUNC TO 49;             * Function  Available on device
EQU COM.AIP$DVC.FUNC.STAT TO 50;        * Status of device function
EQU COM.AIP$WKO.SCH.TM TO 51;           * Sched time of WO, POC Encoder Group
EQU COM.AIP$WKO.SCH.TYPE TO 52;         * Sched type of WO, POC Encoder Member
EQU COM.AIP$LOG.TRAN.AIL TO 53;         * AI Logging Transaction #
EQU COM.AIP$TRAN.SEQ TO 54;             * AI Control Computer Tran Seq #
EQU COM.AIP$WKO.FUNC TO 55;             * Work Order Primary Function
EQU COM.AIP$EVENT.CH TO 56;             * Event Channel # to download
EQU COM.AIP$EVENT.DT TO 57;             * Event Date to download to POC
EQU COM.AIP$EVENT.TM TO 58;             * Start time to download to POC
EQU COM.AIP$EVENT.DUR TO 59;            * The event duration HH:MM
EQU COM.AIP$END.UPL TO 60;              * 'z' is end of upload from POC
EQU COM.AIP$INTFC.ERR TO 61;            * Error code or sending hardware
EQU COM.AIP$MAX.PAUSE TO 62;            * Maximum pause between progress updates
EQU COM.AIP$RETRY TO 63;                * Number of retries
EQU COM.AIP$COL.STATUS TO 64;           * Collection status returned
EQU COM.AIP$COMM.CN TO 65;              * Packet number (try #)
EQU COM.AIP$LOG.SRCE TO 66;             * Source of Log entry
EQU COM.AIP$LOG.LOC TO 67;              * Location of Log entry
EQU COM.AIP$LOG.ACCT TO 68;             * Account of Log entry
EQU COM.AIP$LOG.PROG TO 69;             * Subroutine of Log entry
EQU COM.AIP$LOG.PORT TO 70;             * Port of Log entry
EQU COM.AIP$INTFC.SET.BY TO 71;         * Interface action by routine
EQU COM.AIP$RVRS.FL TO 72;              * Interface to reverse on XCEL/TOUT
EQU COM.AIP$WKO.SCH.DT TO 73;           * Schedule date of work order
~COM.AIPOC.DIM~
*CODE.SEGMENT: COM.AIPOC.DIM
*
DIM COM.AIPOC(40)
~COM.AIPOC.EQUATES~
*CODE.SEGMENT: COM.AIPOC.EQUATES
*
* FILE 'COM.AIPOC' EQUATES - GENERATED 19:31:16  27 JUN 1996
EQU COM.AIPOC$CH.ALL.MODE TO COM.AIPOC(1);   * All Channel mode or 14-99 (AC)
EQU COM.AIPOC$CH.AUTH TO COM.AIPOC(2);       * Authorization Channel (AH)
EQU COM.AIPOC$CH.BARK TO COM.AIPOC(3);       * Barker Channel (BH)
EQU COM.AIPOC$CBL.DFLT TO COM.AIPOC(4);      * Default cable to use A or B (CA)
EQU COM.AIPOC$COL.GR TO COM.AIPOC(5);        * Default collection group to use (CG)
EQU COM.AIPOC$COL.MODE TO COM.AIPOC(6);      * Default collection mode (CO)
EQU COM.AIPOC$COL.WIN TO COM.AIPOC(7);       * Default window for collections
EQU COM.AIPOC$CD.MAX TO COM.AIPOC(8);        * Default credit limit (CD)
EQU COM.AIPOC$CH.DISABLE TO COM.AIPOC(9);    * Channel to tune to on error (DC)
EQU COM.AIPOC$CBL.TYPE TO COM.AIPOC(10);     * Type of cable service - dual/single (DS)
EQU COM.AIPOC$ENC.MODE TO COM.AIPOC(11);     * Encoder control mode (CM)
EQU COM.AIPOC$ENC.GR TO COM.AIPOC(12);       * Encoder group number (G#)
EQU COM.AIPOC$ENC.MEM TO COM.AIPOC(13);      * Encoder member number (M#)
EQU COM.AIPOC$FSK.PORT TO COM.AIPOC(14);     * Return module FSK line (CL)
EQU COM.AIPOC$FSK.FREQ TO COM.AIPOC(15);     * FSK Frequency for return module
EQU COM.AIPOC$FSK.CMD.MAX.ONE TO COM.AIPOC(16);   * FSK failure time 1 (T1)
EQU COM.AIPOC$FSK.CMD.MAX.TWO TO COM.AIPOC(17);   * FSK failure timer 2 (T2)
EQU COM.AIPOC$FSK.FREQ.IDLE TO COM.AIPOC(18);     * FSK idle frequency for ret. module (IF)
EQU COM.AIPOC$FSK.OUT.LEVEL TO COM.AIPOC(19);     * FSK output level for retmodule (OL)
EQU COM.AIPOC$FUNC.CD.DFLT TO COM.AIPOC(20);      * Default action on norm/quick poll (FU)
EQU COM.AIPOC$POC.EM.MODE TO COM.AIPOC(21);       * Emulation mode to use (HM)
EQU COM.AIPOC$POC.SCRAM.MODE TO COM.AIPOC(22);    * Scramling mode used (MM)
EQU COM.AIPOC$POC.SCRAM.TM TO COM.AIPOC(23);      * Scrambling timing (MT)
EQU COM.AIPOC$OCI.STAT TO COM.AIPOC(24);          * OCI Status (OS)
EQU COM.AIPOC$CH.SCRAM.OUT TO COM.AIPOC(25);      * outband scramblin channel (SC)
EQU COM.AIPOC$CH.SCRAM.LVL TO COM.AIPOC(26);      * Outband scrambling channel level (SL)
EQU COM.AIPOC$CH.SCRAM TO COM.AIPOC(27);          * Sytem output channel (OC)
EQU COM.AIPOC$PHONE.MASK TO COM.AIPOC(28);        * Phone access mask (PAM
EQU COM.AIPOC$POC.STD.FL TO COM.AIPOC(29);        * Use the Pioneer Tag Option (PT)
EQU COM.AIPOC$POC.TYPE TO COM.AIPOC(30);          * POC type (T)
EQU COM.AIPOC$MOD.PORT TO COM.AIPOC(31);          * Modulator port # (PO)
EQU COM.AIPOC$HOST.RSP.MODE TO COM.AIPOC(32);     * Response mode - ack or upload (RM)
EQU COM.AIPOC$SPEC.CNTRL TO COM.AIPOC(33);        * Polling special control -1,2,3,4,5 (SP)
EQU COM.AIPOC$POC.SUB.PORT TO COM.AIPOC(34);      * POC communication line (SN)
EQU COM.AIPOC$POC.SUB.SYS TO COM.AIPOC(35);       * POC sub.system POC number (PN)
EQU COM.AIPOC$POC.TAG.CH.MODE TO COM.AIPOC(36);   * System uses 0 CH or 1 TAG MODE (TC)
EQU COM.AIPOC$POC.DVC.TYPES TO COM.AIPOC(37);     * Valid devices types for POC (TY)
EQU COM.AIPOC$UPL.MODE TO COM.AIPOC(38);          * Default type of upload to do (UM)
~COM.AIPOC.VAR.EQUATES~
*CODE.SEGMENT: COM.AIPOC.VAR.EQUATES
*
* FILE 'COM.AIPOC' EQUATES - GENERATED 19:31:16  27 JUN 1996
EQU COM.AIPOC$CH.ALL.MODE TO 1;         * All Channel mode or 14-99 (AC)
EQU COM.AIPOC$CH.AUTH TO 2;             * Authorization Channel (AH)
EQU COM.AIPOC$CH.BARK TO 3;             * Barker Channel (BH)
EQU COM.AIPOC$CBL.DFLT TO 4;            * Default cable to use A or B (CA)
EQU COM.AIPOC$COL.GR TO 5;              * Default collection group to use (CG)
EQU COM.AIPOC$COL.MODE TO 6;            * Default collection mode (CO)
EQU COM.AIPOC$COL.WIN TO 7;             * Default window for collections
EQU COM.AIPOC$CD.MAX TO 8;              * Default credit limit (CD)
EQU COM.AIPOC$CH.DISABLE TO 9;          * Channel to tune to on error (DC)
EQU COM.AIPOC$CBL.TYPE TO 10;           * Type of cable service - dual/single (DS)
EQU COM.AIPOC$ENC.MODE TO 11;           * Encoder control mode (CM)
EQU COM.AIPOC$ENC.GR TO 12;             * Encoder group number (G#)
EQU COM.AIPOC$ENC.MEM TO 13;            * Encoder member number (M#)
EQU COM.AIPOC$FSK.PORT TO 14;           * Return module FSK line (CL)
EQU COM.AIPOC$FSK.FREQ TO 15;           * FSK Frequency for return module
EQU COM.AIPOC$FSK.CMD.MAX.ONE TO 16;    * FSK failure time 1 (T1)
EQU COM.AIPOC$FSK.CMD.MAX.TWO TO 17;    * FSK failure timer 2 (T2)
EQU COM.AIPOC$FSK.FREQ.IDLE TO 18;      * FSK idle frequency for ret. module (IF)
EQU COM.AIPOC$FSK.OUT.LEVEL TO 19;      * FSK output level for retmodule (OL)
EQU COM.AIPOC$FUNC.CD.DFLT TO 20;       * Default action on norm/quick poll (FU)
EQU COM.AIPOC$POC.EM.MODE TO 21;        * Emulation mode to use (HM)
EQU COM.AIPOC$POC.SCRAM.MODE TO 22;     * Scramling mode used (MM)
EQU COM.AIPOC$POC.SCRAM.TM TO 23;       * Scrambling timing (MT)
EQU COM.AIPOC$OCI.STAT TO 24;           * OCI Status (OS)
EQU COM.AIPOC$CH.SCRAM.OUT TO 25;       * outband scramblin channel (SC)
EQU COM.AIPOC$CH.SCRAM.LVL TO 26;       * Outband scrambling channel level (SL)
EQU COM.AIPOC$CH.SCRAM TO 27;           * Sytem output channel (OC)
EQU COM.AIPOC$PHONE.MASK TO 28;         * Phone access mask (PAM
EQU COM.AIPOC$POC.STD.FL TO 29;         * Use the Pioneer Tag Option (PT)
EQU COM.AIPOC$POC.TYPE TO 30;           * POC type (T)
EQU COM.AIPOC$MOD.PORT TO 31;           * Modulator port # (PO)
EQU COM.AIPOC$HOST.RSP.MODE TO 32;      * Response mode - ack or upload (RM)
EQU COM.AIPOC$SPEC.CNTRL TO 33;         * Polling special control -1,2,3,4,5 (SP)
EQU COM.AIPOC$POC.SUB.PORT TO 34;       * POC communication line (SN)
EQU COM.AIPOC$POC.SUB.SYS TO 35;        * POC sub.system POC number (PN)
EQU COM.AIPOC$POC.TAG.CH.MODE TO 36;    * System uses 0 CH or 1 TAG MODE (TC)
EQU COM.AIPOC$POC.DVC.TYPES TO 37;      * Valid devices types for POC (TY)
EQU COM.AIPOC$UPL.MODE TO 38;           * Default type of upload to do (UM)
~COPYRIGHT~
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   19XX         ALL RIGHTS RESERVED
*
~CSH.DIM~
*CODE.SEGEMENT: CSH.DIM
*
DIM CSH(15)
*
~CSH.EQUATES~
*CODE.SEGEMENT: CSH.EQUATES
*
*
*
* Load Till Info
*
EQU CNT.CSH$PORT            TO CSH(1); * m i) Ports Allowed
EQU CNT.CSH$TILL.TYPE       TO CSH(2); * m i) Till Type
EQU CNT.CSH$USER.VALID      TO CSH(3); * m ii) Users Allowed
EQU CNT.CSH$USER.DECIMAL    TO CSH(12); *m ii) Key Decimal Point Y/N
EQU CNT.CSH$USER.PROMPT     TO CSH(4); * Prompt For User
EQU CNT.CSH$DT.OPEN         TO CSH(5); * m iii) Open Dates
EQU CNT.CSH$USER.CURR       TO CSH(6); * m i) Current User for this Port
EQU CNT.CSH$OED.COPIES.DRFT TO CSH(7); * End Of Day  # of draft copies
EQU CNT.CSH$OED.COPIES.FNL  TO CSH(8); * End Of Day  # of final copies (posted)
EQU CNT.CSH$DT.CLOSED       TO CSH(9); * m iii) Open Dates OK to Print/Post
EQU CNT.CSH$TILL.LPT.TYPE   TO CSH(10); *m i) Printer Type
EQU CNT.CSH$TILL.RECP.IMPRT TO CSH(11); *m i) Print a Receipt or Imprint Tape
*
~CTC.DIM~
*CODE.SEGMENT: CTC.DIM
*
DIM CTC(20)
*
~CTC.EQUATES~
*CODE.SEGMENT: CTC.EQUATES
*
* FILE 'CTC' EQUATES - GENERATED 20:18:31  06 MAY 1984
EQU CTC$DATE TO CTC(1);                 * DATE OF CONTACT
EQU CTC$TIME TO CTC(2);                 * TIME OF CONTACT
EQU CTC$CONTACT.TYPE TO CTC(3);         * TYPE OF CONTACT TRANSACTION
EQU CTC$CONTACT.DOCUMENT TO CTC(4);     * CONTACT DOCUMENT ACCT.FILE.PRIMARY-KEY.SECONDARY-KEY
EQU CTC$CONTACT.TEXT TO CTC(5);         * CONTACT DESCRIPTIVE TEXT INFORMATION
*
~CURSOR.EQUATES~
*CODE.SEGMENT: CURSOR.EQUATES
*
* DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* DATE RELEASED: 01 DEC 90
*
* CURSOR.UP.......^    8          * CURSOR.DOWN.....v    2
* CURSOR.LEFT.....<    4          * CURSOR.RIGHT....>    6
* CURSOR.RSP......home 5          * CURSOR.DONE.....<cr> <cr>
* CURSOR.CLEAR....\    clear      * CURSOR.???......?    ?
* CURSOR.PG.UP....?    9 (pgup)   * CURSOR.PG.DOWN..?    3 (pgdn)
* CURSOR.???......?    7 (home)   * CURSOR.???......?    1 (end)
* CURSOR.???......?    0          * CURSOR.???......?    .
* CURSOR.???......?   <F1>        * CURSOR.???......?    <F2>
* CURSOR.???......?   <F3>        * CURSOR.???......?    <F4>
*
* CURSOR.POS = *UP*DOWN*LEFT*RIGHT*
*
!
*
EQU CURSOR.UP    TO 8
EQU CURSOR.DOWN  TO 2
EQU CURSOR.LEFT  TO 4
EQU CURSOR.RIGHT TO 6
EQU CURSOR.RSP   TO 5
EQU CURSOR.DONE  TO "done"
EQU CURSOR.CHAR  TO "char"
EQU CURSOR.CLEAR TO "clear"
EQU CURSOR.CCLEAR TO "cclear"
*
~CURSOR.POS~
*CODE.SEGMENT: CURSOR.POS
*
*
BEGIN CASE
*
! Select Key
*
CASE TC.FUNC EQ "5"
*
LOOP
POS.RSP = POS.REF<LN + ONE,CL.LOC>
RSP = FIELD(POS.RSP,"|",ONE)
LN.LOC = FIELD(POS.RSP,"|",TWO)
SUB.REF.LOC = FIELD(POS.RSP,"|",3)
WHILE RSP EQ '"' AND CL.LOC GT ONE DO CL.LOC = CL.LOC - ONE REPEAT
PRINT @(RSP.CL,RSP.LN):RVB:RSP:RVE:
CL = POS.LOC<LN + ONE,CL.LOC>
*
! Cursor Positioning
*
CASE INDEX("0123456789",TC.FUNC,ONE)
*
RSP = EMPTY
*
BEGIN CASE
*
! Prev Page
*
CASE TC.FUNC EQ "9"
*
TC.FUNC = EMPTY
*
! Next Page
*
CASE TC.FUNC EQ "3"
*
TC.FUNC = EMPTY
*
! Begining
*
CASE TC.FUNC EQ "7"
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; LN = ZERO; ORIG.LN = -ONE
LOOP UNTIL (POS.LOC<LN + ONE> NE EMPTY AND POS.REF<LN + ONE> NE EMPTY) OR LN EQ ORIG.LN DO
IF ORIG.LN EQ -ONE THEN ORIG.LN = LN
LN = LN + ONE
IF LN GT LN.MAX THEN LN = ZERO
REPEAT
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.LOC = ONE; CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
*
! End
*
CASE TC.FUNC EQ "1"
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; LN = LN.MAX; ORIG.LN = -ONE
LOOP UNTIL (POS.LOC<LN + ONE> NE EMPTY AND POS.REF<LN + ONE> NE EMPTY) OR LN EQ ORIG.LN DO
IF ORIG.LN EQ -ONE THEN ORIG.LN = LN.MAX
LN = LN - ONE
IF LN LT ZERO THEN LN = LN.MAX
REPEAT
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.LOC = CL.MAX; CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
*
! Not Used
*
CASE TC.FUNC EQ "0"
*
!     Up     Down     Left     Right          
*
CASE TRUE
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; CL.CONT = TRUE
ORIG.LN = -LN; ORIG.CL = CL; ORIG.DIR = TC.FUNC
IF NOT(ORIG.LN) THEN ORIG.LN = -1
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
*
*
LOOP
*
! Up or Down
*
IF TC.FUNC EQ "8" OR TC.FUNC EQ "2" THEN
*
UP.DN.CONT = TRUE
*
LOOP
*
LN = LN + (TC.FUNC EQ "2") - (TC.FUNC EQ "8")
IF LN LT ZERO THEN LN = LN.MAX
IF LN GT LN.MAX THEN LN = ZERO
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
CL.CONT = TWO; CL.NEW = ZERO
* IF TC.FUNC EQ "2" THEN CL.STEP = ONE ELSE CL.STEP = -ONE
*
POS.INX = CL - (5 * (CL GE 5))
LOCATE POS.INX IN POS.LOC<LN + ONE> BY "AR" SETTING CL.MIN ELSE NULL
*
FOR CL.CN = CL.MIN TO CL.MAX UNTIL CL.CONT LE ZERO
*
* STEP CL.STEP
IF NOT(INDEX("**hdr*bg*fg*key*","*":POS.REF<LN + ONE,CL.CN>:"*",ONE)) THEN
*
IF POS.LOC<LN + ONE,CL.CN> + 5 GE CL THEN
IF NOT(CL.NEW) THEN CL.NEW = CL.CN
* CL.CONT = FALSE
CL.CONT = FALSE
* CL.CN = CL.CN - ONE
END
*
IF POS.LOC<LN + ONE,CL.CN> EQ CL THEN CL.NEW = CL.CN; CL.CONT = FALSE; CL.CN = CL.CN - ONE
*
*960606*DGH*END ELSE
END
*
IF CL.CN EQ CL.MAX THEN CL.CN = ZERO; CL.CONT = CL.CONT - ONE
*960606*DGH*END
*
IF CL.CN EQ CL.MIN THEN CL.CONT = CL.CONT - ONE
*
NEXT CL.CN
*
UP.DN.CONT = CL.CONT
IF CL.NEW THEN CL.CN = CL.NEW
IF POS.REF<LN + ONE,CL.CN> NE EMPTY THEN
CL.LOC = CL.CN
IF INDEX("**hdr*bg*fg*key*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE) THEN
IF TC.FUNC EQ "2" THEN
*960607*DGH*TC.FUNC = "6"
TC.FUNC = "2"
*960607*DGH*END ELSE TC.FUNC = "4"
END ELSE
TC.FUNC = "8"
END
END
END
*
IF LN EQ ORIG.LN THEN UP.DN.CONT = FALSE
IF (ORIG.DIR EQ "4" OR ORIG.DIR EQ "6") OR ORIG.LN GE ZERO THEN
IF POS.LOC<LN + ONE> NE EMPTY THEN UP.DN.CONT = FALSE
END
*
* IF LN EQ ABS(ORIG.LN) THEN ORIG.LN = ABS(ORIG.LN)
IF LN EQ -ORIG.LN THEN ORIG.LN = ABS(ORIG.LN); UP.DN.CONT = TRUE
*
WHILE UP.DN.CONT DO REPEAT
*
*
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
IF CL.LOC GT CL.MAX THEN CL.LOC = CL.MAX
IF NOT(CL.LOC) THEN CL.LOC = ONE
CL = POS.LOC<LN + ONE,CL.LOC>
CL.CONT = FALSE
*
END; * of dir is up/dn
*
! Left or Right
*
IF TC.FUNC EQ "4" OR TC.FUNC EQ "6" THEN
*
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
ORIG.CL = CL
ORIG.CL.LOC = CL.LOC
*
!
*
LOOP
*
CL.LOC = CL.LOC + (TC.FUNC EQ "6") - (TC.FUNC EQ "4")
IF NOT(CL.LOC) THEN CL.LOC = CL.MAX
IF CL.LOC GT CL.MAX THEN CL.LOC = ONE
* IF NOT(CL.LOC) THEN
*
IF CL.LOC EQ ORIG.CL.LOC AND (LN EQ ORIG.LN OR ORIG.LN EQ -ONE) THEN
*
IF TC.FUNC EQ "4" THEN
TC.FUNC = "8"
* CL.LOC = ONE
*TC.FUNC = "4"
*LN = LN - ONE
IF LN LT ZERO THEN LN = LN.MAX
CL.CONT = TRUE
END ELSE
*
TC.FUNC = "2"
* CL.LOC = CL.MAX
CL.CONT = FALSE
END
*
*960607*DGH*CL.CONT = FALSE
*
END ELSE
IF CL.LOC GT CL.MAX THEN CL.LOC = ONE
IF NOT(CL.LOC) THEN CL.LOC = CL.MAX
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
END
*
CL = POS.LOC<LN + ONE,CL.LOC>
*
WHILE CL.CONT AND CL NE ORIG.CL DO REPEAT
*
!
*
* IF CL EQ ORIG.CL THEN PRINT BELL:
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
IF TC.FUNC NE "4" AND TC.FUNC NE "6" THEN CL.CONT = TRUE
*
END
*
IF LN EQ ABS(ORIG.LN) AND CL EQ ORIG.CL THEN PRINT BELL:; CL.CONT = FALSE
*
WHILE CL.CONT DO REPEAT
*
*
CL = POS.LOC<LN + ONE,CL.LOC>
OLD.CL.LOC = CL.LOC; OLD.CL = CL; OLD.LN = LN
* * PRINT @(CL,LN):
*
END CASE
*
* * PRINT @(CL,LN):RVB:">":RVE:
MARK.CL = OLD.CL - ONE
IF MARK.CL LT ZERO THEN MARK.CL = ZERO
PRINT @(MARK.CL,OLD.LN):" ":
*
! Special Call
*
CASE TC.FUNC EQ "@"
*
STD.FUNC = "PERFORM"
* SEC.USER$FUNC.NAME = STD.SUBR.NAME
GOSUB LOAD.STD.DATA
GOSUB ENTER.STD.SUBR
RSP = MENU.NAME
*
! Function Key Execute
*
CASE TC.FUNC EQ "E" OR TC.FUNC EQ "C"
*
IF TC.FUNC EQ "C" THEN TC.FUNC = EMPTY
*
! Error
*
CASE TRUE
*
RSP = MENU.NAME
*
*
END CASE
*
~CURSOR.POS.LOC~
*CODE.SEGMENT: CURSOR.POS.LOC
*
* DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* DATE RELEASED: 01 DEC 90
*
* CURSOR.UP.......^    8          * CURSOR.DOWN.....v    2
* CURSOR.LEFT.....<    4          * CURSOR.RIGHT....>    6
* CURSOR.RSP......home 5          * CURSOR.RSP......null <cr>
* CURSOR.PG.UP....?    9 (pgup)   * CURSOR.PG.DOWN..?    3 (pgdn)
* CURSOR.???......?    7 (home)   * CURSOR.???......?    1 (end)
* CURSOR.???......?    0          * CURSOR.???......?    .
* CURSOR.???......?   <F1>        * CURSOR.???......?    <F2>
* CURSOR.???......?   <F3>        * CURSOR.???......?    <F4>
*
* CURSOR.POS = *UP*DOWN*LEFT*RIGHT*
*
!
*
CURSOR.POS = "*":CURSOR.UP:"*":CURSOR.DOWN:"*":CURSOR.LEFT:"*":CURSOR.RIGHT:"*"
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
RSP = EMPTY; TC.CN = ONE
*
LOOP
*
!
*
ECHO OFF
LOOP
*
PRINT @(CL,LN):
IF CL.FIRST THEN TC = TWO; CL.FIRST = FALSE ELSE INPUT TC,ONE:
*
IF TC NE CR AND TC NE EMPTY THEN
*
LOCATE TC IN POS.STR<ONE> SETTING CURSOR.LOC THEN
CURSOR.DIR = POS.STR<2,CURSOR.LOC>
END ELSE
CURSOR.DIR = CURSOR.CHAR
END
*
IF CURSOR.DIR EQ CURSOR.CHAR THEN
RSP = RSP:TC
TC.CN = TC.CN + ONE
END ELSE IF CURSOR.DIR EQ CURSOR.CCLEAR THEN
PRINT @(RSP.CL,RSP.LN):STR(" ",LEN(RSP)):
RSP = RSP[ONE,LEN(RSP) - ONE]
IF TC.CN GT ZERO THEN TC.CN = TC.CN - ONE
END ELSE IF CURSOR.DIR EQ CURSOR.CLEAR THEN
RSP = EMPTY
PRINT @(RSP.CL,RSP.LN):STR(" ",LEN(RSP)):
RSP = EMPTY
TC.CN = ZERO
END
IF CURSOR.DIR EQ CURSOR.CHAR OR CURSOR.DIR EQ CURSOR.CCLEAR THEN
PRINT @(RSP.CL,RSP.LN):RSP:
* PRINT @(LN,CL):
END
*
END ELSE
CURSOR.DIR = CURSOR.DONE
END
*
WHILE CURSOR.DIR EQ CURSOR.CHAR OR CURSOR.DIR EQ CURSOR.CLEAR OR CURSOR.DIR EQ CURSOR.CCLEAR DO REPEAT
ECHO ON
*
IF CURSOR.DIR EQ CURSOR.RSP AND RSP EQ EMPTY THEN
* PRINT @(RSP.CL,RSP.LN):STR(" ",LEN(RSP)):
LOOP
* RSP = POS.REF<LN + ONE,CL.LOC>
POS.RSP = POS.REF<LN + ONE,CL.LOC>
RSP = FIELD(POS.RSP,"|",ONE)
LN.LOC = FIELD(POS.RSP,"|",TWO)
SUB.REF.LOC = FIELD(POS.RSP,"|",3)
WHILE RSP EQ '"' AND CL.LOC GT ONE DO CL.LOC = CL.LOC - ONE REPEAT
PRINT @(RSP.CL,RSP.LN):RVB:RSP:RVE:
CL = POS.LOC<LN + ONE,CL.LOC>
END
!
*
BEGIN CASE
*
CASE INDEX(CURSOR.POS,"*":CURSOR.DIR:"*",ONE)
*
!
*
LN.MAX = DCOUNT(POS.LOC,AM) - ONE; CL.CONT = TRUE
ORIG.LN = LN; ORIG.CL = CL; ORIG.DIR = CURSOR.DIR
*
LOOP
*
*
IF ORIG.DIR EQ CURSOR.UP OR ORIG.DIR EQ CURSOR.DOWN THEN
LOOP
LN = LN + (ORIG.DIR EQ CURSOR.DOWN) - (ORIG.DIR EQ CURSOR.UP)
IF LN LT ZERO THEN LN = LN.MAX
IF LN GT LN.MAX THEN LN = ZERO
WHILE POS.LOC<LN + ONE> EQ EMPTY AND LN NE ORIG.LN DO REPEAT
*
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
IF CL.MAX EQ ONE THEN CL.LOC = ONE ELSE
LOCATE CL IN POS.LOC<LN + ONE> BY "AR" SETTING CL.LOC ELSE
IF CL.LOC GT CL.MAX THEN
CL.LOC = CL.LOC - ONE
END ELSE IF CL.LOC GT ONE THEN
IF CL - POS.LOC<LN + ONE,CL.LOC - ONE> - 4 LT POS.LOC<LN + ONE,CL.LOC> - CL THEN
CL.LOC = CL.LOC - ONE
END
END
END; * of LOCATE
END; * of ONE COLUMN
CL.LOC = CL.LOC - ONE; IF NOT(CL.LOC) THEN CL.LOC = CL.MAX
CL = POS.LOC<LN + ONE,CL.LOC>; CURSOR.DIR = CURSOR.RIGHT
END; * of dir is up/dn
*
*
IF CURSOR.DIR EQ CURSOR.LEFT OR CURSOR.DIR EQ CURSOR.RIGHT THEN
CL.MAX = DCOUNT(POS.LOC<LN + ONE>,VM)
ORIG.CL = CL
LOOP
CL.LOC = CL.LOC + (CURSOR.DIR EQ CURSOR.RIGHT) - (CURSOR.DIR EQ CURSOR.LEFT)
IF NOT(CL.LOC) THEN CL.LOC = CL.MAX
IF CL.LOC GT CL.MAX THEN CL.LOC = ONE
CL = POS.LOC<LN + ONE,CL.LOC>
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
WHILE CL.CONT AND CL NE ORIG.CL DO REPEAT
* IF CL EQ ORIG.CL THEN PRINT BELL:
CL.CONT = INDEX("**hdr*key*bg*","*":POS.REF<LN + ONE,CL.LOC>:"*",ONE)
END
*
IF LN EQ ORIG.LN AND CL EQ ORIG.CL THEN PRINT BELL:; CL.CONT = FALSE
*
WHILE CL.CONT DO REPEAT
*
* CASE TRUE
*
* END CASE
*
CL = POS.LOC<LN + ONE,CL.LOC>
PRINT @(CL,LN):
*
!
*
CASE CURSOR.DIR EQ CURSOR.RSP
*
CASE CURSOR.DIR EQ CURSOR.CHAR
*
CASE CURSOR.DIR EQ CURSOR.DONE
IF RSP[ONE,ONE] EQ "." THEN
RSP = RSP[TWO,9999]
EXECUTE RSP
PRINT CLB:"Enter <cr> to continue . . . ":; INPUT RSP:
RSP = EMPTY
CURSOR.DIR = EMPTY
END
*
CASE TRUE
*
!
*
END CASE
*
!
*
WHILE CURSOR.DIR NE CURSOR.RSP AND CURSOR.DIR NE CURSOR.DONE DO REPEAT
*
OLD.CL.LOC = CL.LOC
OLD.LN     = LN
OLD.CL     = CL
*
~CURSOR.STD~
*CODE.SEGMENT: CURSOR.STD
*
* DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* DATE RELEASED: 01 DEC 90
* DATE REVISED: 9 NOV 92
*
*
* DATE REVISED:  5 JUN 92
*
*        STAT    MEANING
*           0    GOOD RESPONSE
*          -1    REQUEST BACKUP
*          -2    POSITION CHANGE IN INPUT.DATA.SG (RETURN)
*           1    (RSP<1>=??what??) BAD RESPONSE (Format error message in RSP<2>)
*         998    <ESC> WAS PRESSED
*         999    REQUEST KILL
*
* Fields: DEF Default (Original field value)
*         FLD Current field value
*       FIXED Fixed Field Position (Not floating window)
*          CL Column     OLD.CL Old Column
*          LN Line       OLD.LN Old Line
*      CL.LOC Column Location
*  OLD.CL.LOC Old Column Location
*          LH Length     LHM Maximum Length
*     GENERIC Generic Keyboard Entry Mode
*        NUMC Numbers on / off
*          MS Mask for display
*          ML Maximum display length
*   NO.PROMPT Don't prompt (DISP.ONLY)
*        CONV Conversion
*  ADD TM.MAX Maximum Time (300]OFF)
*
*   <ALT>+nnn Ascii (PC Numieric Keyboard) Alt key convert [CHAR(x)]
*   <ESC>+n   Function key request
*   <INS> <DEL>
*   <pgUP> <PGdn>
*   <Home> <End>
*   <Num> <Generic>
*   <Caps> <Ctrl> <Tab> <Bs> <Shift> <func99>
*   <Esc> <Del> <Nul>
*   <Push KeyBoard>
*   <STanDard System Call>
*   <SHELL> TCL DOS UNIX OPSYS
*   <DeViCe> or Peripheral Function
*   <SYStem> Call
*   <PrtSc> <Scroll-lock> <Pause> <Break>
*
!!
*
* INPUT TMP:
RSP = EMPTY; DEF = FLD; FLD.LEN = LEN(FLD)
ORIG.LN = RSP.LN; ORIG.CL = RSP.CL
IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO; NUMC = TRUE ELSE NON.NUMERIC.CONV = ONE
*
! Default Handling
*
IF DEF NE EMPTY THEN
IF CONV NE EMPTY THEN
IF NUM(DEF) OR NOT(NON.NUMERIC.CONV) THEN
NUMC = TRUE
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
DEF = OCONV(DEF,MOD.CONV)
IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
END
END
END; * Of DEF
*
! Field Window Control - Column,Line,Length,Mask,Maximum Length
*
IF TC.FILL EQ EMPTY THEN TC.FILL = " "
TC.FUNC = EMPTY
IF RSP.CL EQ CL AND RSP.LN EQ LN THEN
MARK.CL = CL - ONE
IF MARK.CL LT ZERO THEN MARK.CL = ONE
END ELSE MARK.CL = CL
*
TMP = EMPTY
IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,9999]
IF LH[ONE,ONE] MATCHES "1A" THEN TMP = LH[ONE,ONE]; LH = LH[TWO,9999]
IF LHM GT 4 THEN ML = LHM ELSE ML = 4
IF TMP EQ EMPTY THEN TMP = "L#":LH ELSE TMP = TMP:"#":LH
IF MS EQ EMPTY THEN MS = TMP
CAPS = FALSE; EXTK = TRUE
*
! Status Line Processing
*
IF RSP.LN EQ 23 OR LN EQ 23 THEN STAT.LN = 5 ELSE STAT.LN = 23
*
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
*
IF EXTK THEN
* 2 Char SEQ
* 3 Char.cn
* PRINT @(75,STAT.LN - 4):".":LHM "R#3":
* PRINT @(75,STAT.LN - 5):".":MS  "R#3":
* IF CONV NE EMPTY THEN PRINT @(72,STAT.LN - ONE):CONV "L#4"
* PRINT @(74,STAT.LN - ONE):OCONV(TIME(),"MTS") "R#5":
END
*
* IF CAPS THEN PRINT @(75,STAT.LN):RVB:"CAPS":RVE:
*
IF GENERIC THEN
NUMC = 9
PRINT @(67,STAT.LN):RVB:"GEN":RVE:
END
*
IF NUMC THEN
PRINT @(63,STAT.LN):RVB:"NUM":RVE:
END
*
* ULT ONLY
END
*
!! Process Response
*
!    Display Field Window
*
DISP.DEF = DEF:STR(TC.FILL,LH-LEN(DEF))
*
*
TC.CN = ONE; TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
IF NOT(DEF.SUPP) THEN
IF GENERIC THEN
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):
END ELSE
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
END
END
*
! Load Response
*
*
RSP = EMPTY; CLEAR.BOTTOM.LINE = FALSE
*
*
BEGIN CASE
*
! Don't prompt, use default
*
CASE NO.PROMPT
RSP = DEF
PRINT @(69,STAT.LN):RVB:"Def":RVE:
*
! Input is in Response Buffer
*
CASE RSPBUF<ONE,ONE> NE EMPTY
RSP = RSPBUF<ONE,ONE,ONE>
DEL RSPBUF<ONE,ONE,ONE>
PRINT @(69,STAT.LN):RVB:"Buf":RVE:
*
! Generic Terminal Type
*
CASE GENERIC
*
INPUT RSP,ML:_
IF RSP EQ EMPTY THEN DEFAULT.USED = TRUE; RSP = DEF
*
! Character input loop
*
CASE TRUE
*
! Field Window Control
*
TC.CL = RSP.CL; TC.CONT = TRUE; TC.MOVE = TRUE
TC.STOP = RSP.CL + LH; TC.START = ONE; TC.ADJ = FALSE
CLEAR.BOTTOM.LINE = FALSE
*; TC.INS = FALSE
TC.INS = FALSE
*
! Get next Character
*
LOOP
*
IF TC.CONT THEN
*
TC = EMPTY
*
IF EXTK THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
* PRINT @(75,STAT.LN - 3):".":TC.CN "R#3":
* ULT ONLY
END
END
TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
* PRINT @(TC.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
*
BEGIN CASE
CASE OPSYS EQ "M"
IF NOT(SYSTEM(11)) THEN
PRINT @(TC.CL,RSP.LN):RVB:TCO:"{":RVE:@(MARK.CL,LN):
* PRINT @(TC.CL,RSP.LN):TCO:@(TC.CL,RSP.LN + ONE):RVB:"^":RVE:@(MARK.CL,LN):
END ELSE
PRINT @(TC.CL,RSP.LN):
END
ECHO OFF
INPUT TC,ONE:
ECHO ON
IF TC EQ EMPTY THEN TC = CHAR(13)
CASE OPSYS EQ "U"
PRINT @(TC.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
ECHO OFF
TC = OCONV(TC,"U51EA")
ECHO ON
CASE TRUE
PRINT @(TC.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
INPUT TC,ONE:
END CASE
*
! Process Character
*
TC.SEQ = ("000":SEQ(TC)) "R#3"
*
! Keyboard Conversion/Control
*
* Table look-up
*
LOCATE TC.SEQ IN CURSOR.KEYS<TWO> SETTING TC.LOC THEN
TC.OUT = CURSOR.KEYS<3,TC.LOC>
IF (TC.OUT EQ "G" OR TC.OUT EQ "C") OR NOT(GENERIC) THEN
IF NUM(TC.OUT) THEN
IF NUMC THEN
TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE
TC.CONT = FALSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
END
END ELSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
IF TC.OUT EQ "C" THEN TC.CONT = FALSE
END
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
*
* End of Table look-up
END; * of TC.CONT
*
! Exit for character Input LOOP (WHILE TC.CONT)
*
WHILE TC.CONT DO
*
! System Character
*
IF TC.LOC THEN
*
BEGIN CASE
*
CASE TC.FUNC EQ "|"
*
PRINT @(66,STAT.LN):RVB:"Cpy":RVE:@(MARK.CL,LN):
IF LEN(FLD) GT TC.CN - ONE THEN
*
TC = FLD[TC.CN,ONE]
TC.SEQ = SEQ(TC)
TC.LOC = FALSE; TC.OUT = EMPTY
IF TC.INS THEN
TC.INS = FALSE
END
*
END ELSE PRINT BELL:; TC = EMPTY; TC.SEQ = EMPTY
*
CASE TC.FUNC EQ "<"
*
PRINT @(66,STAT.LN):RVB:"BSp":RVE:@(MARK.CL,LN):
PRINT @(TC.CL,RSP.LN):TCO:
IF TC.CN GT ONE THEN
TC.CN = TC.CN - ONE
TC.CL = TC.CL - ONE
RSP = RSP[ONE,TC.CN - ONE]
IF TC.INS THEN
TC.INS = FALSE
END
***IF TC.CL LT RSP.CL OR TC.CN LT TC.START THEN TC.ADJ = TRUE
IF (TC.CL LT RSP.CL) OR (TC.START GT ONE AND TC.CL LT RSP.CL + TWO) THEN TC.ADJ = TRUE
END ELSE
PRINT BELL:
* TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
END
*
CASE TC.FUNC EQ "\"
*
PRINT @(69,STAT.LN):RVB:"Clr":RVE:@(MARK.CL,LN):
RSP = EMPTY; FLD = EMPTY; CLEAR.FLAG = TRUE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ONE
*
CASE TC.FUNC EQ "R"
PRINT @(69,STAT.LN):RVB:"Rst":RVE:@(MARK.CL,LN):
FLD = DEF; RSP = EMPTY; CLEAR.FLAG = FALSE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ONE
*
CASE TC.FUNC EQ "I"
*
IF TC.INS THEN
TC.INS = FALSE
PRINT @(60,STAT.LN):RVB:"Ed ":RVE:@(MARK.CL,LN):
END ELSE
TC.INS = TRUE
PRINT @(60,STAT.LN):RVB:"INS":RVE:@(MARK.CL,LN):
END
*
CASE TC.FUNC EQ "D"
*
PRINT @(66,STAT.LN):RVB:"DEL":RVE:@(MARK.CL,LN):
IF LEN(FLD) GT TC.CN - ONE THEN
FLD = FLD[ONE,TC.CN - ONE]:FLD[TC.CN + ONE,9999]
END
TC.ADJ = TRUE; TC.MOVE = FALSE
*
CASE TC.FUNC EQ "S"
*
PRINT @(72,STAT.LN):RVB:"DBG":RVE:@(MARK.CL,LN):
GOSUB SYS.DEBUG
*
CASE TC.FUNC EQ "A"
*
PRINT @(48,STAT.LN):RVB:"Alt":RVE:"   ":@(51):
INPUT TMP1,3:_
IF NUM(TMP1) THEN
IF TMP1 GE ZERO AND TMP1 LE 255 THEN
TC = CHAR(TMP1); TC.SEQ = SEQ(TC); TC.LOC = FALSE
END ELSE PRINT BELL:
END ELSE PRINT BELL:
PRINT @(48,STAT.LN):SPACE(3):@(MARK.CL,LN):
*
CASE TC.FUNC EQ "N"
*
IF NOT(NUMC) THEN
PRINT @(63,STAT.LN):RVB:"NUM":RVE:@(MARK.CL,LN):
NUMC = TRUE
END ELSE
* PRINT @(72,STAT.LN):SPACE(3):@(MARK.CL,LN):
PRINT @(63,STAT.LN):RVB:"<v>":RVE:@(MARK.CL,LN):
NUMC = FALSE
END
*
CASE TC.FUNC EQ "G"
*
IF NOT(GENERIC) THEN
PRINT @(75,STAT.LN):RVB:"GEN":RVE:@(MARK.CL,LN):
GENERIC = TRUE
END ELSE
PRINT @(75,STAT.LN):RVB:"~GEN":RVE:@(MARK.CL,LN):
GENERIC = FALSE
END
*
CASE TC.FUNC EQ "E"
*
FUNC.VC.MAX = DCOUNT(CURSOR.KEYS<5>,VM)
FUNC.STR = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0><"
IF NOT(SYSTEM(11)) THEN
PRINT @(ZERO,STAT.LN - ONE):RVB:("Function 1...9,A...":FUNC.STR[FUNC.VC.MAX,ONE]:",>,<,0 to exit: ") "R#38":RVE:
END
*
LOOP
*
LOOP
*
PRINT @(40,STAT.LN - ONE):
INPUT FUNC.RSP,ONE:
TC.FUNC.NUM = INDEX(FUNC.STR,FUNC.RSP,ONE)
WHILE NOT(TC.FUNC.NUM) DO
PRINT BELL:
REPEAT
*
WHILE TC.FUNC.NUM GT 36 DO
*
IF FUNC.RSP EQ "<" OR FUNC.RSP EQ ">" THEN
*
IF FUNC.RSP EQ "<" THEN
IF NOT(FUNC.VC.OFFSET) THEN FUNC.VC.OFFSET = 5
FUNC.VC = FUNC.VC - FUNC.VC.OFFSET
END ELSE IF FUNC.RSP EQ ">" THEN
IF NOT(FUNC.VC.OFFSET) THEN FUNC.VC.OFFSET = 5
FUNC.VC = FUNC.VC + FUNC.VC.OFFSET
END
IF FUNC.VC LT ONE THEN FUNC.VC = ONE; PRINT BELL:
IF FUNC.VC GT FUNC.VC.MAX THEN FUNC.VC = ONE
*
*
*CODE.SEGMENT: SYS.INCL.FKEY.DISP
*
FUNC.VC.OFFSET = ZERO; FUNC.CL = ZERO
*
* Display function keys; * : *
IF NOT(GENERIC) AND NOT(SYSTEM(11)) THEN
PRINT @(ZERO,STAT.LN):RVB:FUNC.RSP:RVE:
LOOP
TMP = 5 + LEN(CURSOR.KEYS<4,FUNC.VC + FUNC.VC.OFFSET>)
* ULT ONLY
IF SYSTEM(11) THEN TMP = 999
UNTIL FUNC.VC + FUNC.VC.OFFSET GT FUNC.VC.MAX OR FUNC.CL + TMP GE 78 DO
TMP1 = FUNC.STR[FUNC.VC + FUNC.VC.OFFSET,ONE]
PRINT RVB:("F":TMP1):RVE:" ":CURSOR.KEYS<4,FUNC.VC + FUNC.VC.OFFSET>:"  ":
FUNC.CL = FUNC.CL + TMP
FUNC.VC.OFFSET = FUNC.VC.OFFSET + ONE
REPEAT
END
*
END; * of <>
*
REPEAT
*
IF NOT(SYSTEM(11)) THEN
PRINT @(ZERO,STAT.LN - ONE):SPACE(40):@(MARK.CL,LN):
END
*
IF TC.FUNC.NUM THEN
RSP = CURSOR.KEYS<5,TC.FUNC.NUM>; TC.CONT = FALSE
EXEC.DESC = "F":TC.FUNC.NUM:" - ":CURSOR.KEYS<4,TC.FUNC.NUM>
EXEC.VERB = CURSOR.KEYS<5,TC.FUNC.NUM>
END
*
CASE TC.FUNC EQ "@"
*
PRINT @(ZERO,STAT.LN):CLL:RVB:"Enter the function name: ":RVE:BELL:
INPUT STD.SUBR.NAME:
IF STD.SUBR.NAME EQ EMPTY THEN STD.SUBR.NAME = SEC.USER$FUNC.NAME
IF STD.SUBR.NAME NE EMPTY THEN
* STD.FUNC = "PERFORM"
SEC.USER$FUNC.NAME = STD.SUBR.NAME; TC.CONT = FALSE
* GOSUB LOAD.STD.DATA
* GOSUB ENTER.STD.SUBR
END ELSE
TC.ADJ = TRUE
* PRINT @(ZERO,STAT.LN):CLL:
END; * Of routine name
*
CASE TRUE
*
TC.FUNC = EMPTY
*
END CASE
*
IF TC.FUNC NE EMPTY AND NOT(SYSTEM(11)) THEN
PRINT @(TC.CL,RSP.LN):TCO:
END
*
END; * Of TC.FUNC
*
! Not a system character
*
IF NOT(TC.LOC) AND LEN(TC) THEN
*
IF TC.SEQ GE 28 THEN
*
IF TC.SEQ LE 30 THEN
TC.SEQ = TC.SEQ + 224
TC = CHAR(TC.SEQ)
IF TT EQ "D" OR TT EQ "R" THEN PRINT TC:
END
*
IF TC.INS THEN
TMP = LEN(FLD)
IF TMP LT TC.CN - ONE THEN
FLD = FLD:RSP[TMP + ONE,9999]
END
FLD = FLD[ONE,TC.CN - ONE]:TC:FLD[TC.CN,9999]
TC.ADJ = TRUE; TC.MOVE = FALSE
END
*
RSP = RSP:TC
TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
IF NOT(SYSTEM(11)) THEN
PRINT @(TC.CL,RSP.LN):TC:@(MARK.CL,LN):
END ELSE PRINT TC:
TC.CN = TC.CN + ONE
TC.CL = TC.CL + ONE
*
END; * Of ge 28
*
END; * Of no TC.OUT
*
IF TC.CL GE TC.STOP OR TC.ADJ THEN
IF FIXED THEN
TC.START = ONE; RSP.LN = 23; RSP.CL = ONE; TMP = TC.CN - ONE
CLEAR.BOTTOM.LINE = 23
IF STAT.LN EQ 23 THEN STAT.LN = 5
PRINT @(ZERO,RSP.LN):CLL:RVB:">":RVE:
END ELSE
IF NOT(TC.MOVE) AND TC.CL LT TC.STOP THEN
TC.MOVE = TRUE
TMP = TC.CN - TC.START
END ELSE IF TC.CL GE TC.STOP OR TC.START NE ONE THEN
TMP = INT(LH / TWO)
END ELSE TMP = ZERO
IF TMP GT TC.CN - ONE THEN TMP = TC.CN - ONE
TC.START = TC.CN - TMP
* INPUT TMP.RSP:
END
TC.CL = RSP.CL + TMP
TMP1 = FLD[TC.CN,LH - TMP]
TMP1 = TMP1:STR(TC.FILL,LH - TMP - LEN(TMP1))
PRINT @(RSP.CL,RSP.LN):RSP[TC.START,LH]:TMP1:@(TC.CL,RSP.LN):
TC.ADJ = FALSE
TC.MOVE = TRUE
END
*
IF TC.CN - TWO EQ LHM OR TC.CN - TWO EQ LHM + ONE THEN 
TEXT = "No more than ":LHM:" characters please"
PRINT @(ZERO,STAT.LN):TEXT "L#40":BELL:@(MARK.CL,LN):
CLEAR.BOTTOM.LINE = STAT.LN
END
*
! End of system / non-system character
*
IF EXTK THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
* PRINT @(75,STAT.LN - 3):".":TC.CN "R#3":
* PRINT @(75,STAT.LN - TWO):".":TC.SEQ "R#3":
* PRINT @(74,STAT.LN - ONE):OCONV(TIME(),"MTS") "R#5":
* ULT ONLY
END
END
*
! Repeat for Character Input LOOP (WHILE TC.CONT)
*
REPEAT
*
IF (TC.CN EQ ONE AND (TC.FUNC EQ "C" OR TC.FUNC EQ EMPTY)) AND NOT(CLEAR.FLAG) THEN DEFAULT.USED = TRUE; RSP = DEF
IF CLEAR.BOTTOM.LINE THEN PRINT @(ZERO,CLEAR.BOTTOM.LINE):CLL:; CLEAR.BOTTOM.LINE = FALSE
* IF TC.START NE ONE THEN PRINT @(RSP.CL,RSP.LN):RSP[ONE,LH]:
*
END CASE
*
! End of CASES  NO.PROMPT,RSPBUF,GENERIC,Character.Input.LOOP
*
*   END; * Of NO.PROMPT
*
IF TC.FUNC EQ EMPTY OR FIXED THEN
PRINT @(ORIG.CL,ORIG.LN):RSP MS:
END
RSP.CL = ORIG.CL; RSP.LN = ORIG.LN
FLD = RSP
*
*
~CURSOR.STD.13MAR94~
*CODE.SEGMENT: CURSOR.STD
*
* DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* DATE RELEASED: 01 DEC 90
* DATE REVISED: 9 NOV 92
*
*
* DATE REVISED:  5 JUN 92
*
*        STAT    MEANING
*           0    GOOD RESPONSE
*          -1    REQUEST BACKUP
*          -2    POSITION CHANGE IN INPUT.DATA.SG (RETURN)
*           1    (RSP<1>=??what??) BAD RESPONSE (Format error message in RSP<2>)
*         998    <ESC> WAS PRESSED
*         999    REQUEST KILL
*
* Fields: DEF Default (Original field value)
*         FLD Current field value
*       FIXED Fixed Field Position (Not floating window)
*          CL Column     OLD.CL Old Column
*          LN Line       OLD.LN Old Line
*      CL.LOC Column Location
*  OLD.CL.LOC Old Column Location
*          LH Length     LHM Maximum Length
*     GENERIC Generic Keyboard Entry Mode
*        NUMC Numbers on / off
*          MS Mask for display
*          ML Maximum display length
*   NO.PROMPT Don't prompt (DISP.ONLY)
*        CONV Conversion
*
*   <ALT>+nnn Ascii (PC Numeric Keyboard) Alt key convert [CHAR(x)]
*   <ESC>+n   Function key request
*   <INS> <DEL>
*   <pgUP> <PGdn>
*   <Home> <End>
*   <Num> <Generic>
*   <Caps> <Ctrl> <Tab> <Bs> <Shift> <func99>
*   <Esc> <Del> <Nul>
*   <Push KeyBoard>
*   <STanDard System Call>
*   <SHELL> TCL DOS UNIX OPSYS
*   <DeViCe> or Peripheral Function
*   <SYStem> Call
*   <PrtSc> <Scroll-lock> <Pause> <Break>
*
!!
*
* INPUT TMP:
RSP = EMPTY; DEF = FLD; FLD.LEN = LEN(FLD)
ORIG.LN = RSP.LN; ORIG.CL = RSP.CL
IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO; NUMC = TRUE ELSE NON.NUMERIC.CONV = ONE
*
! Default Handling
*
IF DEF NE EMPTY THEN
IF CONV NE EMPTY THEN
IF NUM(DEF) OR NOT(NON.NUMERIC.CONV) THEN
NUMC = TRUE
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
DEF = OCONV(DEF,MOD.CONV)
IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
END
END
END; * Of DEF
*
! Field Window Control - Column,Line,Length,Mask,Maximum Length
*
IF TC.FILL EQ EMPTY THEN TC.FILL = " "
TC.FUNC = EMPTY
IF RSP.CL EQ CL AND RSP.LN EQ LN THEN
MARK.CL = CL - ONE
IF MARK.CL LT ZERO THEN MARK.CL = ZERO
END ELSE MARK.CL = CL
*
TMP = EMPTY
IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,9999]
IF LH[ONE,ONE] MATCHES "1A" THEN TMP = LH[ONE,ONE]; LH = LH[TWO,9999]
IF LHM GT 4 THEN ML = LHM ELSE ML = 4
IF TMP EQ EMPTY THEN TMP = "L#":LH ELSE TMP = TMP:"#":LH
IF MS EQ EMPTY THEN MS = TMP
CAPS = FALSE; EXTK = TRUE
*
! Status Line Processing
*
IF RSP.LN EQ 23 OR LN EQ 23 THEN STAT.LN = 5 ELSE STAT.LN = 23
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
IF EXTK THEN
* 2 Char SEQ
* 3 Char.cn
* 7JAN94 * PRINT @(75,STAT.LN - 4):".":LHM "R#3":
* 7JAN94 * PRINT @(75,STAT.LN - 5):".":MS  "R#3":
* 7JAN94 * IF CONV NE EMPTY THEN PRINT @(71,STAT.LN - ONE):CONV "L#4"
* 7JAN94 * PRINT @(74,STAT.LN - ONE):OCONV(TIME(),"MTS") "R#5":
END
*
* 7JAN94 * IF CAPS THEN PRINT @(75,STAT.LN):RVB:"CAPS":RVE:
IF NUMC OR GENERIC THEN
* 7JAN94 * PRINT @(71,STAT.LN):RVB:"NUM":RVE:
IF GENERIC THEN PRINT @(67,STAT.LN):RVB:"GEN":RVE:
END
*
* ULT ONLY
END
*
!! Process Response
*
!    Display Field Window
*
DISP.DEF = DEF:STR(TC.FILL,LH-LEN(DEF))
*
*
TC.CN = ONE; TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
IF NOT(DEF.SUPP) THEN
* * IF GENERIC THEN
* * PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):
* * END ELSE
* * PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
* * END
IF NOT(GENERIC) THEN PRINT @(MARK.CL,LN):RVB:"@":RVE:
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):
END
*
! Load Response
*
*
RSP = EMPTY; CLEAR.BOTTOM.LINE = FALSE
*
*
BEGIN CASE
*
! Don't prompt, use default
*
CASE NO.PROMPT
RSP = DEF
PRINT @(63,STAT.LN):RVB:"DEF":RVE:
*
! Input is in Response Buffer
*
CASE RSPBUF<ONE,ONE> NE EMPTY
RSP = RSPBUF<ONE,ONE,ONE>
DEL RSPBUF<ONE,ONE,ONE>
*
! Generic Terminal Type
*
CASE GENERIC
INPUT RSP,ML:_
IF RSP EQ EMPTY THEN DEFAULT.USED = TRUE; RSP = DEF
*
! Character input loop
*
CASE TRUE
*
! Field Window Control
*
TC.CL = RSP.CL; TC.CONT = TRUE; TC.MOVE = TRUE
TC.STOP = RSP.CL + LH; TC.START = ONE; TC.ADJ = FALSE
CLEAR.BOTTOM.LINE = FALSE
TC.INS = FALSE
*
! Get next Character
*
LOOP
*
IF TC.CONT THEN
*
TC = EMPTY
*
IF EXTK THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
* 7JAN94 * PRINT @(75,STAT.LN - 3):".":TC.CN "R#3":
* ULT ONLY
END
END
*
TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
* * PRINT @(TC.CL,RSP.LN):RVB:TCO:RVE:@(MARK.CL,LN):
PRINT @(TC.CL,RSP.LN):
*
BEGIN CASE
CASE OPSYS EQ "M"
ECHO OFF
INPUT TC,ONE:
ECHO ON
IF TC EQ EMPTY THEN TC = CHAR(13)
CASE OPSYS EQ "U"
ECHO OFF
TC = OCONV(TC,"U51EA")
ECHO ON
CASE TRUE
INPUT TC,ONE:
END CASE
*
! Process Character
*
TC.SEQ = ("000":SEQ(TC)) "R#3"
*
! Keyboard Conversion/Control
*
* Table look-up
*
LOCATE TC.SEQ IN CURSOR.KEYS<TWO> SETTING TC.LOC THEN
TC.OUT = CURSOR.KEYS<3,TC.LOC>
IF (TC.OUT EQ "G" OR TC.OUT EQ "C") OR NOT(GENERIC) THEN
IF NUM(TC.OUT) THEN
IF NUMC THEN
TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE
TC.CONT = FALSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
END
END ELSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
IF TC.OUT EQ "C" THEN TC.CONT = FALSE
END
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
*
* End of Table look-up
END; * of TC.CONT
*
! Exit for character Input LOOP (WHILE TC.CONT)
*
WHILE TC.CONT DO
*
! System Character
*
IF TC.LOC THEN
*
BEGIN CASE
*
CASE TC.FUNC EQ "|"
*
IF LEN(FLD) GT TC.CN - ONE THEN
*
TC = FLD[TC.CN,ONE]
TC.SEQ = SEQ(TC)
TC.LOC = FALSE; TC.OUT = EMPTY
IF TC.INS THEN
TC.INS = FALSE
PRINT @(60,STAT.LN):SPACE(3):@(TC.CL,LN):
END
*
END ELSE PRINT BELL:; TC = EMPTY; TC.SEQ = EMPTY
*
CASE TC.FUNC EQ "<"
*
IF TC.CN GT ONE THEN
PRINT @(TC.CL,RSP.LN):TCO:
TC.CN = TC.CN - ONE
TC.CL = TC.CL - ONE
RSP = RSP[ONE,TC.CN - ONE]
IF TC.INS THEN
TC.INS = FALSE
PRINT @(60,STAT.LN):SPACE(3):@(TC.CL,LN):
END
***IF TC.CL LT RSP.CL OR TC.CN LT TC.START THEN TC.ADJ = TRUE
IF (TC.CL LT RSP.CL) OR (TC.START GT ONE AND TC.CL LT RSP.CL + TWO) THEN TC.ADJ = TRUE
END ELSE
PRINT BELL:
* TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
END
*
CASE TC.FUNC EQ "\"
*
RSP = EMPTY; FLD = EMPTY; CLEAR.FLAG = TRUE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ONE
*
CASE TC.FUNC EQ "R"
FLD = DEF; RSP = EMPTY; CLEAR.FLAG = FALSE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ONE
*
CASE TC.FUNC EQ "I"
*
IF TC.INS THEN
TC.INS = FALSE
PRINT @(60,STAT.LN):SPACE(3):@(TC.CL,LN):
END ELSE
TC.INS = TRUE
PRINT @(60,STAT.LN):RVB:"INS":RVE:@(TC.CL,LN):
END
*
CASE TC.FUNC EQ "D"
*
IF LEN(FLD) GT TC.CN - ONE THEN
FLD = FLD[ONE,TC.CN - ONE]:FLD[TC.CN + ONE,9999]
END
TC.ADJ = TRUE; TC.MOVE = FALSE
*
CASE TC.FUNC EQ "S"
*
GOSUB SYS.DEBUG
*
CASE TC.FUNC EQ "A"
*
PRINT @(48,STAT.LN):RVB:"Alt":RVE:"   ":@(51):
INPUT TMP1,3:_
IF NUM(TMP1) THEN
IF TMP1 GE ZERO AND TMP1 LE 255 THEN
TC = CHAR(TMP1); TC.SEQ = SEQ(TC); TC.LOC = FALSE
END ELSE PRINT BELL:
END ELSE PRINT BELL:
PRINT @(48,STAT.LN):SPACE(3):@(TC.CL,LN):
*
CASE TC.FUNC EQ "N"
*
IF NOT(NUMC) THEN
* 7JAN94 * PRINT @(71,STAT.LN):RVB:"NUM":RVE:@(TC.CL,LN):
NUMC = TRUE
END ELSE
* 7JAN94 * PRINT @(71,STAT.LN):SPACE(3):@(TC.CL,LN):
NUMC = FALSE
END
*
CASE TC.FUNC EQ "G"
*
IF NOT(GENERIC) THEN
PRINT @(67,STAT.LN):RVB:"GEN":RVE:@(TC.CL,LN):
GENERIC = TRUE
END ELSE
PRINT @(67,STAT.LN):SPACE(3):@(TC.CL,LN):
GENERIC = FALSE
END
*
CASE TC.FUNC EQ "E"
*
TMP1 = DCOUNT(CURSOR.KEYS<5>,VM)
PRINT @(ZERO,STAT.LN):RVB:"Enter function number (0 to continue): " "L#40":RVE:
LOOP
PRINT @(40,STAT.LN):
INPUT TC.FUNC.NUM,ONE:
IF NUM(TC.FUNC.NUM) THEN
IF TC.FUNC.NUM LT ZERO OR TC.FUNC.NUM GT TMP1 THEN TC.FUNC.NUM = "?"
END
WHILE NOT(NUM(TC.FUNC.NUM)) DO PRINT BELL: REPEAT
PRINT @(ZERO,STAT.LN):SPACE(40):@(TC.CL,LN):
IF TC.FUNC.NUM THEN
RSP = CURSOR.KEYS<5,TC.FUNC.NUM>; TC.CONT = FALSE
EXEC.DESC = "F":TC.FUNC.NUM:" - ":CURSOR.KEYS<4,TC.FUNC.NUM>
EXEC.VERB = CURSOR.KEYS<5,TC.FUNC.NUM>
END
*
CASE TC.FUNC EQ "@"
*
PRINT @(ZERO,STAT.LN):CLL:RVB:"Enter the function name: ":RVE:BELL:
INPUT STD.SUBR.NAME:
IF STD.SUBR.NAME EQ EMPTY THEN STD.SUBR.NAME = SEC.USER$FUNC.NAME
IF STD.SUBR.NAME NE EMPTY THEN
* STD.FUNC = "PERFORM"
SEC.USER$FUNC.NAME = STD.SUBR.NAME; TC.CONT = FALSE
* GOSUB LOAD.STD.DATA
* GOSUB ENTER.STD.SUBR
END ELSE
TC.ADJ = TRUE
* PRINT @(ZERO,STAT.LN):CLL:
END; * Of routine name
*
CASE TRUE
*
TC.FUNC = EMPTY
*
END CASE
*
END; * Of TC.FUNC
*
! Not a system character
*
IF NOT(TC.LOC) AND LEN(TC) THEN
*
IF TC.SEQ GE 28 THEN
*
IF TC.SEQ LE 30 THEN
TC.SEQ = TC.SEQ + 224
TC = CHAR(TC.SEQ)
IF TT EQ "D" OR TT EQ "R" THEN PRINT TC:
END
*
IF TC.INS THEN
TMP = LEN(FLD)
IF TMP LT TC.CN - ONE THEN
FLD = FLD:RSP[TMP + ONE,9999]
END
FLD = FLD[ONE,TC.CN - ONE]:TC:FLD[TC.CN,9999]
TC.ADJ = TRUE; TC.MOVE = FALSE
END
*
RSP = RSP:TC
TCO = FLD[TC.CN,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
* * PRINT @(TC.CL,RSP.LN):TC:@(MARK.CL,LN):
PRINT @(TC.CL,RSP.LN):TC:@(TC.CL):
TC.CN = TC.CN + ONE
TC.CL = TC.CL + ONE
*
END; * Of ge 28
*
END; * Of no TC.OUT
*
IF TC.CL GE TC.STOP OR TC.ADJ THEN
IF FIXED THEN
TC.START = ONE; RSP.LN = 23; RSP.CL = ONE; TMP = TC.CN - ONE
CLEAR.BOTTOM.LINE = 23
IF STAT.LN EQ 23 THEN STAT.LN = 5
PRINT @(ZERO,RSP.LN):CLL:
END ELSE
IF NOT(TC.MOVE) AND TC.CL LT TC.STOP THEN
TC.MOVE = TRUE
TMP = TC.CN - TC.START
END ELSE IF TC.CL GE TC.STOP OR TC.START NE ONE THEN
TMP = INT(LH / TWO)
END ELSE TMP = ZERO
IF TMP GT TC.CN - ONE THEN TMP = TC.CN - ONE
TC.START = TC.CN - TMP
* INPUT TMP.RSP:
END
TC.CL = RSP.CL + TMP
TMP1 = FLD[TC.CN,LH - TMP]
TMP1 = TMP1:STR(TC.FILL,LH - TMP - LEN(TMP1))
PRINT @(RSP.CL,RSP.LN):RSP[TC.START,LH]:TMP1:@(TC.CL,RSP.LN):
TC.ADJ = FALSE
TC.MOVE = TRUE
END
*
IF TC.CN - TWO EQ LHM OR TC.CN - TWO EQ LHM + ONE THEN 
TEXT = "No more than ":LHM:" characters please"
PRINT @(ZERO,STAT.LN):TEXT "L#40":BELL:@(TC.CL,LN):
CLEAR.BOTTOM.LINE = STAT.LN
END
*
! End of system / non-system character
*
IF EXTK THEN
* ULT ONLY
IF NOT(SYSTEM(11)) THEN
* 7JAN94 * PRINT @(75,STAT.LN - 3):".":TC.CN "R#3":
* 7JAN94 * PRINT @(75,STAT.LN - TWO):".":TC.SEQ "R#3":
* 7JAN94 * PRINT @(74,STAT.LN - ONE):OCONV(TIME(),"MTS") "R#5":
* ULT ONLY
END
END
*
! Repeat for Character Input LOOP (WHILE TC.CONT)
*
REPEAT
*
IF (TC.CN EQ ONE AND (TC.FUNC EQ "C" OR TC.FUNC EQ EMPTY)) AND NOT(CLEAR.FLAG) THEN DEFAULT.USED = TRUE; RSP = DEF
IF CLEAR.BOTTOM.LINE THEN PRINT @(ZERO,CLEAR.BOTTOM.LINE):CLL:; CLEAR.BOTTOM.LINE = FALSE
* IF TC.START NE ONE THEN PRINT @(RSP.CL,RSP.LN):RSP[ONE,LH]:
*
END CASE
*
! End of CASES  NO.PROMPT,RSPBUF,GENERIC,Character.Input.LOOP
*
*   END; * Of NO.PROMPT
*
PRINT @(MARK.CL,LN):" ":
IF TC.FUNC EQ EMPTY OR FIXED THEN
PRINT @(ORIG.CL,ORIG.LN):RSP MS:
END
RSP.CL = ORIG.CL; RSP.LN = ORIG.LN
FLD = RSP
*
*
~CUST.DIM~
*CODE.SEGMENT: ?
DIM CUST(50)
~CUST.EQUATES~
*CODE.SEGMENT: ?
* FILE 'CUST' EQUATES - GENERATED 14:07:12  11 APR 1988
EQU CUST$CO TO CUST(1);                 * CO
EQU CUST$FR TO CUST(2);                 * FR
EQU CUST$CUSTNO TO CUST(3);             * CUSTNO
EQU CUST$S TO CUST(4);                  * S
EQU CUST$ST.DATE TO CUST(5);            * ST-DATE
EQU CUST$FIRST.NAME TO CUST(6);         * FIRTS-NAME
EQU CUST$M TO CUST(7);                  * M
EQU CUST$LAST.NAME TO CUST(8);          * LAST-NAME
EQU CUST$STR1 TO CUST(9);               * STR1
EQU CUST$STR2 TO CUST(10);              * STR2
EQU CUST$ADDRESS2 TO CUST(11);          * ADDRESS2
EQU CUST$CITY TO CUST(12);              * CITY
EQU CUST$ST TO CUST(13);                * ST
EQU CUST$ZIP TO CUST(14);               * ZIP
EQU CUST$HOME.WORK TO CUST(15);         * PHONES
EQU CUST$DUM16 TO CUST(16);             * 
EQU CUST$DUM17 TO CUST(17);             * 
EQU CUST$BILL.TO TO CUST(18);           * BILL-TO
EQU CUST$DUM19 TO CUST(19);             * 
EQU CUST$DUM20 TO CUST(20);             * 
EQU CUST$DUM21 TO CUST(21);             * 
EQU CUST$DUM22 TO CUST(22);             * 
EQU CUST$DUM23 TO CUST(23);             * 
EQU CUST$DUM24 TO CUST(24);             * 
EQU CUST$AR.BAL TO CUST(25);            * AR-BAL
EQU CUST$DEP.BAL TO CUST(26);           * DEP-BAL
EQU CUST$IN.DATE TO CUST(27);           * IN-DATE
EQU CUST$B TO CUST(28);                 * B
EQU CUST$B.DATE TO CUST(29);            * B-DATE
EQU CUST$DUM30 TO CUST(30);             * 
EQU CUST$DUM31 TO CUST(31);             * 
EQU CUST$DUM32 TO CUST(32);             * 
EQU CUST$DUM33 TO CUST(33);             * 
EQU CUST$TAG TO CUST(34);               * TAG(MSTR)
EQU CUST$LINE TO CUST(35);              * LINE(DR)
EQU CUST$QTY TO CUST(36);               * Q
EQU CUST$ITM TO CUST(37);               * ITM
EQU CUST$DUM38 TO CUST(38);             * 
EQU CUST$DUM39 TO CUST(39);             * 
EQU CUST$PRIOR TO CUST(40);             * PRIOR.ACT
EQU CUST$PEND.WO TO CUST(41);           * PENDWO
EQU CUST$DIS.DATE TO CUST(42);          * DIS-DATE
EQU CUST$DC TO CUST(43);                * DR
~DACT.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DACT' EQUATES - GENERATED 10:52:03  05 MAR 1984
EQU DACT$NAME TO DACT(1);               * SUBSCRIBER NAME
EQU DACT$HOME.TEL TO DACT(2);           * TELEPHONE NUMBER - HOME
EQU DACT$BUS.TEL TO DACT(3);            *                  - BUSINESS
EQU DACT$AGE.CURR TO DACT(4);           * AGING BUCKETS - CURRENT
EQU DACT$AGE.30 TO DACT(5);             *               - 30 DAYS
EQU DACT$AGE.60 TO DACT(6);             *               - 60 DAYS
EQU DACT$BALANCE TO DACT(7);            * ACCOUNT BALANCE
EQU DACT$NEXT.BILL TO DACT(8);          * 'BILLED TO' DATE
EQU DACT$NEXT.COUP TO DACT(9);          * NEXT COUPON PRINTING DATE
EQU DACT$RATE TO DACT(10);              * MONTHLY RATE (FOR DISPLAY PURPOSES)
EQU DACT$BTYP TO DACT(11);              * BILLING TYPE
EQU DACT$BST TO DACT(12);               * BILLING STATUS
EQU DACT$TV TO DACT(13);                * NUMBER OF TV'S
EQU DACT$FM TO DACT(14);                * NUMBER OF FM'S
EQU DACT$C1 TO DACT(15);                * PAY TV - FIRST OUTLET
EQU DACT$C2 TO DACT(16);                *        - SECOND OUTLET
EQU DACT$C3 TO DACT(17);                *        - THIRD OUTLET
EQU DACT$NEW TO DACT(18);               * NEW WORK FLAG
EQU DACT$RTYP TO DACT(19);              * RATE CATEGORY
EQU DACT$PWO TO DACT(20);               * PENDING DISCONNECT W/O INDICATOR
EQU DACT$OLD TO DACT(21);               * OLD ACCOUNT NUMBER
EQU DACT$CNVRS TO DACT(22);             * CONVERSATION
EQU DACT$MAILAD TO DACT(23);            * MAILING ADDRESS AND PHONE NUMBERS
EQU DACT$PAC.ST TO DACT(24);            * P.A.C. - STATUS
EQU DACT$PAC.EFF TO DACT(25);           *        - EFFECTIVE DATE
EQU DACT$PAC.INST TO DACT(26);          *        - INSTITUTION NUMBER
EQU DACT$PAC.TRNS TO DACT(27);          *        - TRANSIT NUMBER
EQU DACT$PAC.ACCT TO DACT(28);          *        - BANK ACCOUNT NUMBER
EQU DACT$PAC.FILL TO DACT(29);          *        - NOT USED
EQU DACT$PAC.LAST TO DACT(30);          *        - DATE LAST TAKEN
EQU DACT$PAC.ERR TO DACT(31);           *        - RETRY/ERROR FLAG
EQU DACT$PAC.RETR TO DACT(32);          *        - DATE RETRIED
EQU DACT$ML.NEXT TO DACT(33);           * MAIL FILE - NEXT BILLING DATE
EQU DACT$ML.SUGG TO DACT(34);           *           - SUGGESTED ACTION
EQU DACT$ML.CU TO DACT(35);             *           - CURRENT ACTION
EQU DACT$ML.CUDT TO DACT(36);           *           - CURRENT ACTION DATE
EQU DACT$ML.PR TO DACT(37);             *           - PRIOR ACTION
EQU DACT$ML.PRDT TO DACT(38);           *           - PRIOR ACTION DATE
EQU DACT$ML.DBAL TO DACT(39);           *           - BALANCE AT DISC F-UP PRT'G
EQU DACT$ML.LAST TO DACT(40);           *           - LAST BILLING DATE
EQU DACT$ML.DWDT TO DACT(41);           *           - DISCONNECT W/O PRINT DATE
EQU DACT$ML.DFDT TO DACT(42);           *           - DISCONNECT FOLLOWUP PRT DATE
EQU DACT$H.TYP TO DACT(44);             * BILLING HISTORY - TYPE
EQU DACT$H.TR TO DACT(45);              *                 - TRANSACTION CODE
EQU DACT$H.DT TO DACT(46);              *                 - TRANSACTION DATE
EQU DACT$H.AMT TO DACT(47);             *                 - TRANSACTION AMOUNT
~DADR.DIM~
*CODE.SEGMENT: ?
DIM DADR(50)
~DADR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DADR' EQUATES - GENERATED 18:49:23  23 MAR 1984
EQU DADR$POST.CODE TO DADR(1);          * POSTAL CODE OF ADDRESS
EQU DADR$SVC TO DADR(2);                * SERVICE AREA
EQU DADR$TLOCK TO DADR(3);              * TAP LOCK NUMBER (NOT USED)
EQU DADR$CODES TO DADR(4);              * CODES FIELD
EQU DADR$TVI TO DADR(5);                * TV - INSTALLED
EQU DADR$FMI TO DADR(6);                * FM - INSTALLED
EQU DADR$C1I TO DADR(7);                * CATEGORY 1 - INSTALLED
EQU DADR$C2I TO DADR(8);                * CATEGORY 2 - INSTALLED
EQU DADR$C3I TO DADR(9);                * CATEGORY 3 - INSTALLED
EQU DADR$TAPS TO DADR(10);              * ADDRESS TAP STATUS
EQU DADR$TX TO DADR(11);                * TAX AREA
EQU DADR$PWO TO DADR(12);               * PENDING WORK ORDER - NUMBER
EQU DADR$PWO.TYPE TO DADR(13);          * PENDING WORK ORDER - TYPE
EQU DADR$PWO.SCH TO DADR(14);           * PENDING WORK ORDER - SCHEDULE DATE
EQU DADR$PWO.CNC TO DADR(15);           * PENDING WORK ORDER - CANCEL DATE
EQU DADR$PWO.ATV TO DADR(16);           * PENDING WORK ORDER - ADD TV'S
EQU DADR$PWO.AFM TO DADR(17);           *                    - ADD FM'S
EQU DADR$PWO.AC1 TO DADR(18);           *                    - ADD C1'S
EQU DADR$PWO.AC2 TO DADR(19);           *                    - ADD C2'S
EQU DADR$PWO.AC3 TO DADR(20);           *                    - ADD C3'S
EQU DADR$PWO.DTV TO DADR(21);           * PENDING WORK ORDER - DISC TV'S
EQU DADR$PWO.DFM TO DADR(22);           *                    - DISC FM'S
EQU DADR$PWO.DC1 TO DADR(23);           *                    - DISC C1'S
EQU DADR$PWO.DC2 TO DADR(24);           *                    - DISC C2'S
EQU DADR$PWO.DC3 TO DADR(25);           *                    - DISC C3'S
EQU DADR$PWO.UNITS TO DADR(26);         * PENDING WORK ORDER - WORK UNITS
EQU DADR$PWO.CHARGES TO DADR(27);       * PENDING WORK ORDER - CHARGES
EQU DADR$PWO.ADJ TO DADR(28);           * PENDING WORK ORDER - ADJUSTMENT
EQU DADR$PWO.REASON TO DADR(29);        * PENDING WORK ORDER - DISCONNECT REASON
EQU DADR$PWO.SLSMN TO DADR(30);         * PENDING WORK ORDER - SALESMAN
EQU DADR$PWO.INST TO DADR(31);          * PENDING WORK ORDER - INSTALLER
EQU DADR$PWO.INSTR1 TO DADR(32);        * PENDING WORK ORDER - INSTRUCTIONS 1
EQU DADR$PWO.INSTR2 TO DADR(33);        *                    - INSTRUCTIONS 2
EQU DADR$PWO.FLAG TO DADR(34);          * PENDING WORK ORDER - PRINT FLAG
EQU DADR$PWO.ACCT TO DADR(35);          * PENDING WORK ORDER - ACCOUNT NUMBER
EQU DADR$ADR.PTR TO DADR(36);           * ADDRESS FILE ITEM ID
EQU DADR$TCH.CONV TO DADR(40);          * TECHNICAL/ADDRESS CONVERSATION
EQU DADR$WOH TO DADR(41);               * WORK ORDER HISTORY - WORK ORDER NUMBER
EQU DADR$WOH.TYPE TO DADR(42);          *                    - TYPE
EQU DADR$WOH.DATE TO DADR(43);          *                    - DATE
EQU DADR$WOH.TV TO DADR(44);            *                    - TV'S
EQU DADR$WOH.FM TO DADR(45);            *                    - FM'S
EQU DADR$WOH.C1 TO DADR(46);            *                    - C1'S
EQU DADR$WOH.C2 TO DADR(47);            *                    - C2'S
EQU DADR$WOH.C3 TO DADR(48);            *                    - C3'S
~DAYS.INCL.CONV~
*CODE.SEGMENT: DAYS.INCL.CONV 
*
* AUTHOR: DAVID HORSMAN
*
IF NOT(NUM(TMP.TM)) THEN TMP.TM = ZERO
IF TMP.TM LT ZERO THEN TMP.SIGN = "-"; TMP.TM = ABS(TMP.TM) ELSE TMP.SIGN = EMPTY
IF NOT(TMP.TM) THEN ORSLT = EMPTY ELSE
*
ORSLT = INT(TMP.TM / 86400):" ":(OCONV((TMP.TM - (INT(TMP.TM / 86400) * 86400)),"MTS")) "R#8"
ORSLT = TMP.SIGN:ORSLT
*
END
*
~DBASE.DIM~
*CODE.SEGMENT: ?
DIM DBASE(10)
~DBASE.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DBASE' EQUATES - GENERATED 10:28:01  09 NOV 1984
EQU DBASE$DESC TO DBASE(1);             * BRIEF FILE DESCRIPTION
EQU DBASE$ITEMID TO DBASE(2);           * ITEM ID LAYOUT
EQU DBASE$CONTENTS TO DBASE(3);         * CONTENTS OF FILE
EQU DBASE$POINTER TO DBASE(4);          * POINTERS TO OTHER FILES
EQU DBASE$PDESC TO DBASE(5);            * POINTER DESCRIPTION
~DCT.EQUATES~
*CODE.SEGMENT: DCT.EQUATES 
*
*
*   26 APR 91
*
EQU DCT.ATTR     TO 1
EQU DCT.FTYPE    TO 1
EQU DCT.TYPE     TO 2
EQU DCT.MOD      TO 2
EQU DCT.HDR      TO 3
EQU DCT.SEP      TO 3
EQU DCT.C.OR.D   TO 4
EQU DCT.5        TO 5
EQU DCT.6        TO 6
EQU DCT.CONV     TO 7
EQU DCT.CORR     TO 8
EQU DCT.JUST     TO 9
EQU DCT.LEN      TO 10
EQU DCT.DESC     TO 11
EQU DCT.DEFN     TO 12
EQU DCT.13       TO 13
EQU DCT.PROG     TO 14
EQU DCT.15       TO 15
EQU DCT.EDIT     TO 16
EQU DCT.17       TO 17
EQU DCT.18       TO 18
EQU DCT.DBNAME   TO 19
EQU DCT.WRFL     TO 20
*
~DDVC.DIM~
*CODE.SEGMENT: ?
DIM DDVC(50)
~DDVC.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DDVC' EQUATES - GENERATED 10:52:42  05 MAR 1984
EQU DDVC$ACCT TO DDVC(1);               * BILLING ACCOUNT
EQU DDVC$OTLT TO DDVC(2);               * OUTLET NUMBER ATTACHED TO
EQU DDVC$BRCH TO DDVC(3);               * INVENTORY BRANCH NUMBER
EQU DDVC$TYP TO DDVC(4);                * DEVICE TYPE
EQU DDVC$STS TO DDVC(5);                * DEVICE STATUS
EQU DDVC$SVC TO DDVC(6);                * SERVICE AREA
EQU DDVC$CNTR TO DDVC(7);               * CONTRACT CROSS-REFERENCE
EQU DDVC$RCTRF TO DDVC(8);              * RECEIPT REFERENCE
EQU DDVC$PO TO DDVC(9);                 * ORIGINAL P/O NUMBER
EQU DDVC$AST TO DDVC(10);               * ACCOUNT STATUS
EQU DDVC$SLSM TO DDVC(11);              * SALESMAN
EQU DDVC$INST TO DDVC(12);              * INSTALLER
EQU DDVC$SUPCNO TO DDVC(13);            * SUPERCEDE SERIAL NUMBER
EQU DDVC$ADR.ID TO DDVC(14);            * ADDRESS FILE ITEM ID
EQU DDVC$DTINV TO DDVC(15);             * DATE ENTERED INTO INVENTORY
EQU DDVC$WREXP TO DDVC(16);             * DATE OF WARRANTY EXPIRY
EQU DDVC$UCOST TO DDVC(17);             * STANDARD COST
EQU DDVC$DTINS TO DDVC(18);             * DATE INSTALLED
EQU DDVC$DTREM TO DDVC(19);             * DATE REMOVED
EQU DDVC$EXCDT TO DDVC(20);             * DATE EXCHANGED
EQU DDVC$WONUM TO DDVC(21);             * LAST WORK ORDER NUMBER
EQU DDVC$DTWO TO DDVC(22);              * DATE OF LAST WORK ORDER
EQU DDVC$WOTYP TO DDVC(23);             * TYPE OF LAST WORK ORDER
EQU DDVC$DTREP TO DDVC(24);             * DATE OF LAST REPAIR
EQU DDVC$RCVREP TO DDVC(25);            * REPAIR RECEIPT REFERENCE
EQU DDVC$DTRET TO DDVC(26);             * REPAIR RECEIPT DATE
EQU DDVC$LSTRF TO DDVC(27);             * LAST MOVEMENT REFERENCE NUMBER (PO,CV60)
EQU DDVC$LSTDT TO DDVC(28);             * DATE OF LAST ISSUE
EQU DDVC$DTCVBL TO DDVC(29);            * DATE BILLED TO
EQU DDVC$EXRSN TO DDVC(30);             * EXCHANGE REASON
EQU DDVC$DTFUT TO DDVC(31);             * FUTURE ACTION DATE
EQU DDVC$REMCD TO DDVC(32);             * REMOVAL CODE
EQU DDVC$DSCFLG TO DDVC(33);            * SERVICE DISCONNECTION REASON
EQU DDVC$PROM TO DDVC(34);              * PROM ADDRESS
EQU DDVC$DTSVC TO DDVC(35);             * DATE OF SERVICE
EQU DDVC$DTDISC TO DDVC(36);            * DATE OF SERVICE DISCONNECTION
EQU DDVC$ADRSBL TO DDVC(37);            * ADDRESSABLE FLAG
EQU DDVC$RVA TO DDVC(38);               * ACCOUNT REVENUE AREA
EQU DDVC$LANG TO DDVC(39);              * LANGUAGE PREFERENCE (FOR WORLD VIEW)
EQU DDVC$PREV TO DDVC(40);              * PREVIOUS ACCOUNT NUMBER
EQU DDVC$PVCD TO DDVC(41);              * PREVIOUS RATE CODE
EQU DDVC$DTTRST TO DDVC(42);            * DATE OF TIER SERVICE START-UP
EQU DDVC$DTTRBT TO DDVC(43);            * DATE TIER BILLED TO
EQU DDVC$DTTRDS TO DDVC(44);            * DATE TIER DISCONNECTED
EQU DDVC$TRDSCR TO DDVC(45);            * TIER DISCONNECTION REASON
~DISPLAY.SCREEN.HEADER~
*CODE.SEGMENT:   DISPLAY.SCREEN.HEADER
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
~DLQ.DIM~
*CODE.SEGMENT: ?
DIM DLQ(10)
~DLQ.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DLQ' EQUATES - GENERATED 16:37:01  24 JAN 1985
EQU DLQ$SCAN.DATE TO DLQ(1);            * BILLING SCAN DATE OF DLQ ITEM
EQU DLQ$EARLIEST.DISC.DATE TO DLQ(2);   * EARLIEST DISCONNECT DATE
EQU DLQ$CALL.DATE TO DLQ(3);            * DATE OF CALL TO SUBSCRIBER
EQU DLQ$CALL.TYPE TO DLQ(4);            * TYPE OF CALL
EQU DLQ$CALL.OPERATOR TO DLQ(5);        * CALL OPERATOR
EQU DLQ$CALL.RESULT TO DLQ(6);          * RESULT OF CALL
EQU DLQ$CALL.COMMENT TO DLQ(7);         * COMMENT ABOUT CALL
EQU DLQ$CALL.FUP TO DLQ(8)
EQU DLQ$MEMO.DATA TO DLQ(9)
EQU DLQ$GEO.DATA TO DLQ(10)
~DPTR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DPTR' EQUATES - GENERATED 16:38:23  27 OCT 1983
~DSTR.DIM~
*CODE.SEGMENT: ?
DIM DSTR(10)
~DSTR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DSTR' EQUATES - GENERATED 10:52:27  05 MAR 1984
EQU DSTR$RVA TO DSTR(1);                * REVENUE AREA
EQU DSTR$NAME TO DSTR(2);               * STREET NAME
~DVC.CHECK.TYPE~
X*CODE.SEGMENT: DVC.CHECK.TYPE
* SUBROUTINE DVC.CHECK.TYPE(MAT DVT,DVC.CHECK.FUNC,DVC.CN.MAX,AI.TALK,DVC.ID)
*
** EQU VS TO " (R:1.0)"
** *
** *
** $INCLUDE IBP GENERAL.COMMON.AREA
** $INCLUDE IBP STANDARD.FUNCTIONS.DVC
** *
** $INCLUDE IBP ACT.EQUATES
** $INCLUDE IBP DVC.EQUATES
** $INCLUDE IBP DVT.EQUATES; * WHY IS THIS COMMENTED OUT. DVT$ IS REFERENCED BELOW.
** *
** $INCLUDE IBP AI.TALK.VAR.EQUATES
** *
** !
** *
** DVC.TYPE: *
** *
** VERSION = VS
** *
** AI.TALK<ADDRESSABLE> = FALSE
** READ DVC.TYPES FROM PAR.FILE,"DEVICE.TYPES" ELSE DVC.TYPES = EMPTY
** MATREAD DVT                         "
*
** READ DVC.FUNCS FROM PAR.FILE,"DEVICE.FUNCTIONS" ELSE DVC.FUNCS = EMPTY
*
IF DVC.CHECK.FUNC EQ "ACT" THEN
DVC.DVCS = ACT$DVC.NUMS
END ELSE IF DVC.CHECK.FUNC = "WKO" THEN
DVC.DVCS = WKO$DVC.IDS
END ELSE IF DVC.CHECK.FUNC = "DVC" THEN
DVC.DVCS = DVC.ID
END
*
DVC.VC.MAX = DCOUNT(DVC.DVCS,VM)
*22MAR94*FOR DVC.VC = ONE TO DVC.VC.MAX UNTIL AI.TALK<ADDRESSABLE> NE EMPTY
FOR DVC.VC = ONE TO DVC.VC.MAX
*
DVC.SC.MAX = DCOUNT(DVC.DVCS<ONE,DVC.VC>,SVM)
*22MAR94*FOR DVC.SC = ONE TO DVC.SC.MAX UNTIL AI.TALK<ADDRESSABLE> NE EMPTY
FOR DVC.SC = ONE TO DVC.SC.MAX
*
TMP.ID = DVC.DVCS<ONE,DVC.VC,DVC.SC>
*
IF LEN(TMP.ID) THEN
*
MATREAD DVC FROM DVC.FILE,TMP.ID ELSE MAT DVC = EMPTY
*
LOCATE DVC$TYPE IN DVT$DEVICE.TYPE<ONE> SETTING TYPE THEN
*
IF DVT$PROG.ADDR<ONE,TYPE> EQ "A" OR DVT$PROG.ADDR<ONE,TYPE> EQ "I" OR DVT$PROG.ADDR<ONE,TYPE> EQ "O" THEN AI.TALK<ADDRESSABLE> = TMP.ID
*
IF AI.TALK<ADDRESSABLE> EQ EMPTY THEN
*
TMP1 = DVC$FUNCS
TMP.MAX = DCOUNT(TMP1<ONE>,VM)
*
FOR TMP.CN = ONE TO TMP.MAX UNTIL AI.TALK<ADDRESSABLE> NE EMPTY
*
TMP = TMP1<ONE,TMP.CN>
LOCATE TMP IN DVC.FUNCS<ONE> SETTING TMP2 THEN
*
TMP3 = FALSE; TMP4 = FALSE; TMP5 = FALSE
*
IF DVC.FUNCS<3,TMP2> EQ "I" OR DVC.FUNCS<3,TMP2> EQ "O" THEN TMP3 = TRUE
IF TMP3 THEN AI.TALK<ADDRESSABLE> = TMP.ID
*
IF DVC.FUNCS<4,TMP2> EQ "Y" THEN TMP4 = TRUE
IF TMP4 THEN AI.TALK<PAY.PER.VIEW> = TRUE
*
IF DVC.FUNCS<5,TMP2> EQ "Y" THEN TMP5 = TRUE
IF TMP5 THEN AI.TALK<IMPULSE.PPV> = TRUE
*
IF TMP3 OR TMP4 OR TMP5 THEN
LOCATE TMP.ID IN AI.TALK<AI.DVC.IDS> SETTING TMP6 ELSE NULL
AI.TALK<AI.DVC.IDS,TMP6>  = TMP.ID
AI.TALK<AI.DVC.LOCS,TMP6> = DVC$LOCATION
AI.TALK<AI.DVC.ADDR,TMP6> = TMP3
AI.TALK<AI.DVC.PPV,TMP6>  = TMP4
AI.TALK<AI.DVC.IPPV,TMP6> = TMP5
END
*
END ELSE NULL
*
NEXT TMP.CN
*
END
*
END ELSE NULL
*
END
*
NEXT DVC.SC
*
NEXT DVC.VC
*
** *
** RETURN
** *
** *
** END
~DVC.DIM~
*CODE.SEGMENT: DVC.DIM
*
DIM DVC(25)
~DVC.EQUATES~
*CODE.SEGMENT: DVC.EQUATES
*
* FILE 'DVC' EQUATES - GENERATED 14:55:33  30 APR 1992
EQU DVC$TYPE TO DVC(1);                 * DEVICE.TYPE
EQU DVC$ENT.DATE TO DVC(2);             * ENTRY DATE
EQU DVC$EFF.DATE TO DVC(3);             * EFFECTIVE DATE OF WORK ORDER
EQU DVC$STAT TO DVC(4);                 * DEVICE STATUS  (N,B,S,L,I)
EQU DVC$ADD.ID TO DVC(5);               * POINTER TO ADDRESS.ID IN FILE 'ADD'
EQU DVC$ACT.ID TO DVC(6);               * ACCOUNT(S) SERVICED BY THE DEVICE
EQU DVC$WO.NUM TO DVC(7);               * WORK ORDER NUMBER
EQU DVC$LOCATION TO DVC(8);             * INVENTORY LOCATION - BRANCH NUMBER
EQU DVC$REASON TO DVC(9);               * ACTIVITY REASON
EQU DVC$REF TO DVC(10);                 * REFERENCE NUMBER
EQU DVC$COMMENTS TO DVC(11);            * ACTIVITY COMMENTS
EQU DVC$FUNCS TO DVC(12);               * FUNCTIONS PROVIDED BY DEVICE
EQU DVC$SERVICE TO DVC(13);             * SERVICES PROVIDED BY THE DEVICE
EQU DVC$ADDRESS TO DVC(14);             * PROM ADDRESS
EQU DVC$COST TO DVC(15);                * LANDED COST
EQU DVC$WARR.EXP TO DVC(16);            * DATE OF WARRANTY EXPIRY
EQU DVC$INSTALLED.ADD.ID TO DVC(17);    * ID OF INSTALLATION ADDRESS
EQU DVC$SERIAL.NUM TO DVC(18);          * MANUFACTURER'S SERIAL NUMBER
EQU DVC$SVC.ADD.ID TO DVC(19);          * ADDRESS(ES) SERVICED BY THE DEVICE
EQU DVC$SVC.ADD.STAT TO DVC(20);        * STATUS OF THE SERVICE ADDRESS
EQU DVC$CONNECTED.OUTLETS TO DVC(21);   * # OF CONNECTED OUTLETS AT THE ADDRESS
EQU DVC$TIERS TO DVC(22);               * STRING OF TIERS SENT TO THE HEADEND
EQU DVC$TSTAT TO DVC(23);               * TIER STATUS  (ON/OFF) (0/1)
EQU DVC$TSVCS TO DVC(24);               * SERVICES RELATED TO TIERS
~DVC.INCL.DEL.TYPE~
*CODE.SEGMENT: DVC.INCL.SEL.TYPE
*
*
* DISPLAY DEVICE TYPES THEN SELECT ONE
PRINT @(ZERO,ZERO):CLS:
PRINT @(ZERO,ZERO):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28 - ((LEN(CO.NAME) / TWO)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(ZERO,ONE):RVB:"                            Device Type Maintenance                             ":RVE:
TITLE = RVB:"Type":RVE:"  ":RVB:"Description":RVE
PRINT @(5,3):TITLE:@(45,3):TITLE:
IF NEW THEN PAR = EMPTY
VC = ONE; CL = 5; LN = 5
LOOP TYPE = PAR<ONE,VC> UNTIL TYPE = EMPTY DO
PRINT @(CL,LN):RVB:TYPE "L#4":RVE:"  ":PAR<TWO,VC> "L#25":
LN = LN + ONE; IF LN GT 20 THEN IF CL = 5 THEN CL = 45; LN = 5 ELSE VC = 999
VC = VC + ONE
REPEAT
PRINT @(10,22):CLL:"Enter Device Type: ":
INPUT RSP:; IF RSP = "KILL" OR RSP = EMPTY THEN
CALL UNLOCK.ITEM(PAR.FILE,"PAR",PAR.ID,LCK.FILE)
STOP
END
IF RSP MATCHES "1N" THEN RSP = "0":RSP
IF NEW THEN PAR<ONE,ONE> = RSP; WO.VC = ONE; RETURN
LOCATE RSP IN PAR<ONE> BY "AL" SETTING WO.VC THEN RETURN
NEW = ONE
FOR AC = ONE TO 20
INS EMPTY BEFORE PAR<AC,WO.VC>
NEXT AC
PAR<ONE,WO.VC> = RSP
~DVC.INCL.SEL.TYPE~
*CODE.SEGMENT: DVC.INCL.DEL.TYPE
*
*
* DELETE ONLY A SINGLE DEVICE TYPE FROM ITEM
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN STAT = ONE; RETURN
FOR AC = ONE TO 20
DEL PAR<AC,VC>
NEXT AC
WRITE PAR ON PAR.FILE,PAR.ID
~DVC.VAR.EQUATES~
*CODE.SEGMENT: DVC.VAR.EQUATES
*
* FILE 'DVC' EQUATES - GENERATED 14:55:33  30 APR 1992
EQU DVC$TYPE TO 1;                      * DEVICE.TYPE
EQU DVC$ENT.DATE TO 2;                  * ENTRY DATE
EQU DVC$EFF.DATE TO 3;                  * EFFECTIVE DATE OF WORK ORDER
EQU DVC$STAT TO 4;                      * DEVICE STATUS  (N,B,S,L,I)
EQU DVC$ADD.ID TO 5;                    * POINTER TO ADDRESS.ID IN FILE 'ADD'
EQU DVC$ACT.ID TO 6;                    * ACCOUNT(S) SERVICED BY THE DEVICE
EQU DVC$WO.NUM TO 7;                    * WORK ORDER NUMBER
EQU DVC$LOCATION TO 8;                  * INVENTORY LOCATION - BRANCH NUMBER
EQU DVC$REASON TO 9;                    * ACTIVITY REASON
EQU DVC$REF TO 10;                      * REFERENCE NUMBER
EQU DVC$COMMENTS TO 11;                 * ACTIVITY COMMENTS
EQU DVC$FUNCS TO 12;                    * FUNCTIONS PROVIDED BY DEVICE
EQU DVC$SERVICE TO 13;                  * SERVICES PROVIDED BY THE DEVICE
EQU DVC$ADDRESS TO 14;                  * PROM ADDRESS
EQU DVC$COST TO 15;                     * LANDED COST
EQU DVC$WARR.EXP TO 16;                 * DATE OF WARRANTY EXPIRY
EQU DVC$INSTALLED.ADD.ID TO 17;         * ID OF INSTALLATION ADDRESS
EQU DVC$SERIAL.NUM TO 18;               * MANUFACTURER'S SERIAL NUMBER
EQU DVC$SVC.ADD.ID TO 19;               * ADDRESS(ES) SERVICED BY THE DEVICE
EQU DVC$SVC.ADD.STAT TO 20;             * STATUS OF THE SERVICE ADDRESS
EQU DVC$CONNECTED.OUTLETS TO 21;        * # OF CONNECTED OUTLETS AT THE ADDRESS
EQU DVC$TIERS TO 22;                    * STRING OF TIERS SENT TO THE HEADEND
EQU DVC$TSTAT TO 23;                    * TIER STATUS  (ON/OFF) (0/1)
~DVH.DIM~
*CODE.SEGMENT: ?
DIM DVH(10)
~DVH.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DVH' EQUATES - GENERATED 11:17:40  21 FEB 1984
EQU DVH$ACTIVITIES TO DVH(1);           * INVENTORY ACTIVITIES
EQU DVH$REF TO DVH(2);                  * REFERENCE NUMBER
EQU DVH$WO.NUM TO DVH(3);               * WORK ORDER NUMBER
EQU DVH$EFF.DATE TO DVH(4);             * EFFECTIVE DATE
EQU DVH$ENT.DATE TO DVH(5);             * ENTRY DATE
EQU DVH$ACT.ID TO DVH(6);               * ACCOUNT NUMBER
EQU DVH$ADD.ID TO DVH(7);               * POINTER TO ADDRESS.ID IN FILE 'ADD'
EQU DVH$STAT TO DVH(8);                 * BILLING STATUS
EQU DVH$LOCATION TO DVH(9);             * INVENTORY LOCATION
EQU DVH$REASON TO DVH(10);              * ACTIVITY REASON
~DVT.DIM~
*CODE.SEGMENT: ?
DIM DVT(10)
~DVT.EQUATES~
*CODE.SEGMENT: ?
* FILE 'DVT' EQUATES - GENERATED 09:15:19  24 APR 1985
EQU DVT$DEVICE.TYPE TO DVT(1);          * DEVICE TYPE
EQU DVT$DESCRIPTION TO DVT(2);          * DEVICE TYPE DESCRIPTION
EQU DVT$MAND.FUNCS TO DVT(3);           * MANDATORY DEVICE FUNCTIONS
EQU DVT$OPT.FUNCS TO DVT(4);            * OPTIONAL DEVICE FUNCTIONS
EQU DVT$PROG.ADDR TO DVT(5);            * PROGRAMMABLE/ADDRESSABLE (P/A/<null>)
EQU DVT$PART.NUMBER TO DVT(6);          * INVENTORY PART NUMBER
~EFT.DIM~
*CODE.SEGMENT: ?
DIM EFT(20)
~EFT.EQUATES~
*CODE.SEGMENT: ?
* FILE 'EFT' EQUATES - GENERATED 10:51:41  01 NOV 1988
EQU EFT$STAT TO EFT(1);                 * EFT Status
EQU EFT$LAST.CALC.DATE TO EFT(2);       * Last EFT calculation date
EQU EFT$LAST.CALC.AMT TO EFT(3);        * Amount of last EFT calculation
EQU EFT$DRAW.DATES TO EFT(4);           * Date of EFT drawing
EQU EFT$DRAW.AMTS TO EFT(5);            * Amount of EFT drawing
EQU EFT$LAST.RETRY.DATE TO EFT(6);      * Date of last EFT retry
EQU EFT$ERROR.FLAG TO EFT(7);           * Error flag or retry count
EQU EFT$START.DATE TO EFT(8);           * Start date for EFT
EQU EFT$BANK.ACCT.NUM TO EFT(9);        * Bank account number
EQU EFT$BANK.ACCT.NAME TO EFT(10);      * Name of bank account (if diff. to sub.)
EQU EFT$DRAW.DUE.DATES TO EFT(11);      * Due dates of EFT drawing
EQU EFT$PRENOTE.DATE TO EFT(12);        * Date of pre-notification
~ELAPSED.INCL.CONV~
*CODE.SEGMENT: ELAPSED.INCL.CONV 
*
* AUTHOR: DAVID HORSMAN
*
RSLT = ((END.DT - START.DT) * 86400) + (END.TM - START.TM)
*
IF RSLT LT ZERO THEN TMP.SIGN = "-"; RSLT = ABS(RSLT) ELSE TMP.SIGN = EMPTY
IF NOT(RSLT) THEN ORSLT = EMPTY ELSE
ORSLT = INT(RSLT / 86400):" ":(OCONV((RSLT - (INT(RSLT / 86400) * 86400)),"MTS")) "R#8"
ORSLT = TMP.SIGN:ORSLT
RSLT = TMP.SIGN:RSLT
END
*
~EQF.DIM~
*CODE.SEGMENT: EQT.DIM 
*
* AXION/MACROSCOPE DESIGN MATRIX
* DAVID HORSMAN
* APR 91
*
*
DIM EQF(5,75)
*
~EQL.DIM~
*CODE.SEGMENT: ?
DIM EQL(10)
~EQL.EQUATES~
*CODE.SEGMENT: ?
* FILE 'EQL' EQUATES - GENERATED 11:20:40  27 FEB 1984
EQU EQL$AREA.LOC TO EQL(1);             * ADMINISTRATIVE AREA AND LOCATION
EQU EQL$LOC.DESC TO EQL(2);             * EQUIPMENT LOCATION DESCRIPTION
EQU EQL$NUMBER TO EQL(3);               * INVENTORY SUBCATEGORY NUMBER
EQU EQL$DESCRIPTION TO EQL(4);          * INVENTORY SUBCATEGORY DESCRIPTION
~EQR.DIM~
*CODE.SEGMENT: ?
DIM EQR(10)
~EQR.EQUATES~
*FILE 'EQR' EQUATES - GENERATED 14:23:01  01 MAR 1984
EQU EQR$AREA.LOC.NUM TO EQR(1);         * ADMIN.AREA*LOCATION*NUMBER
EQU EQR$TO.ADMIN TO EQR(2);             * 'MOVE TO' ADMIN AREA
EQU EQR$TO.LOCATION TO EQR(3);          * 'MOVE TO' LOCATION
EQU EQR$TO.NUMBER TO EQR(4);            * 'MOVE TO' SUBCATEGORY NUMBER
~EQT.DIM~
*CODE.SEGMENT: EQT.DIM 
*
* AXION/MACROSCOPE DESIGN MATRIX
* DAVID HORSMAN
* APR 91
*
*
DIM EQT(11)
*
~FN.DIM~
*CODE.SEGMENT: ?
DIM FN(30)
~FN.EQUATES~
*CODE.SEGMENT: FN.EQUATES
*
* FILE 'FN' EQUATES - GENERATED 11:40:40  22 JAN 1991
*
*  This is the Routine Mainline Functions Definition.
*  The routine is OP.TALKER. The functions are also
*  directly indexed to routine messages/prompts.
*
*
EQU FN$CHECK.DISPATCHER TO FN(1);       * 
EQU FN$CHECK.INTFC TO FN(2);            * 
EQU FN$INPUT.INSTALLER TO FN(3);        * 
EQU FN$COMPR.SVC TO FN(4);              * 
EQU FN$INPUT.DISC TO FN(5);             * 
EQU FN$INPUT.WO TO FN(6);               * 
EQU FN$VERIFY.SVC TO FN(7);             * 
EQU FN$INPUT.TRY TO FN(8);              * 
EQU FN$DISPL.CONN TO FN(9);             * 
EQU FN$INPUT.CONF TO FN(10);            * 
EQU FN$INPUT.CHNG TO FN(11);            * 
EQU FN$INPUT.TRAN TO FN(12);            * 
EQU FN$WAITFOR TO FN(13);               * 
EQU FN$14.NOT.USED TO FN(14);           * 
EQU FN$VERIFY.DISC TO FN(15);           * 
EQU FN$INPUT.RETRY TO FN(16);           * 
EQU FN$INVALID TO FN(17);               * 
EQU FN$REQRD.WO.DISC TO FN(18);         * 
EQU FN$DISPL.CHNG TO FN(19);            * 
EQU FN$VERIFY.CHNG TO FN(20);           * 
EQU FN$INPUT.PREV.TNT TO FN(21);        * 
EQU FN$INPUT.PREV.ADDR TO FN(22);       * 
EQU FN$VERIFY.CONN TO FN(23);           * 
EQU FN$REQRD.WO.MNTC TO FN(24);         * 
~FN.VAR.EQUATES~
*CODE.SEGMENT: FN.VAR.EQUATES
*
* FILE 'FN' EQUATES - GENERATED 11:40:41  22 JAN 1991
*
*  This is the Routine Mainline Functions Definition.
*  The routine is OP.TALKER. The functions are also
*  directly indexed to routine messages/prompts.
*
*
EQU FN$CHECK.DISPATCHER TO 1;           * 
EQU FN$CHECK.INTFC TO 2;                * 
EQU FN$INPUT.INSTALLER TO 3;            * 
EQU FN$COMPR.SVC TO 4;                  * 
EQU FN$INPUT.DISC TO 5;                 * 
EQU FN$INPUT.WO TO 6;                   * 
EQU FN$VERIFY.SVC TO 7;                 * 
EQU FN$INPUT.TRY TO 8;                  * 
EQU FN$DISPL.CONN TO 9;                 * 
EQU FN$INPUT.CONF TO 10;                * 
EQU FN$INPUT.CHNG TO 11;                * 
EQU FN$INPUT.TRAN TO 12;                * 
EQU FN$WAITFOR TO 13;                   * 
EQU FN$INPUT.COLL TO 14;                * 
EQU FN$VERIFY.DISC TO 15;               * 
EQU FN$INPUT.RETRY TO 16;               * 
EQU FN$INVALID TO 17;                   * 
EQU FN$REQRD.WO.DISC TO 18;             * 
EQU FN$DISPL.CHNG TO 19;                * 
EQU FN$VERIFY.CHNG TO 20;               * 
EQU FN$INPUT.PREV.TNT TO 21;            * 
EQU FN$INPUT.PREV.ADDR TO 22;           * 
EQU FN$VERIFY.CONN TO 23;               * 
EQU FN$REQRD.WO.MNTC TO 24;             * 
EQU FN$REQRD.RESCHED TO 25;             * Rescheduling of W.O is required
EQU FN$NO.UNIT TO 26;                   * Serial Number is not in ASU
EQU FN$TO.REVERSE TO 27;                * WO not confirmed, reverse sends
EQU FN$RETRY.DISC TO 32;                * Not currently used
EQU FN$GENIE.ALL  TO 60;                * Genie 'I' command
EQU FN$WKO.FUNCN  TO 81; *
EQU FN$WKO.FUNCT  TO 82; *
EQU FN$CNCL.CON   TO 90; *
EQU FN$CNCL.DIS   TO 91; *
EQU FN$CNCL.SCH   TO 92; *
~FREQ.CONV~
*CODE.SEGMENT: FREQ.CONV
*
FREQ.CONV = "M":VM:"B":VM:"Q":VM:"Y":AM:"1":VM:"2":VM:"3":VM:"6":VM:"12"
*
~GENERAL.COMMON.AREA~
*CODE.SEGMENT: GENERAL.COMMON.AREA
*
COMMON RSP,STAT,UPDATED,CHANGED
COMMON LCK.FILE,LCK.ITM,LCK.TYPE,LCK.STAT
*
COMMON ACG.ID,ACT.ID,ADD.ID,STT.ID,TPL.ID,WKO.ID,AIX.ID,SAVE.ACG.ID,SAVE.ACT.ID,SAVE.ADD.ID,SAVE.WKO.ID,CO.DATA
*
COMMON ACG.FILE,ACT.FILE,ACX.FILE,ADD.FILE,ASH.FILE,ATH.FILE,ATR.FILE,CNT.FILE,DLQ.FILE,DVC.FILE,EFT.FILE,PAR.FILE,RTE.FILE,STT.FILE,STX.FILE,SVC.FILE,SVS.FILE,TAX.FILE,TPL.FILE,WKH.FILE,WKO.FILE,WKP.FILE,AIX.FILE
*
COMMON REF,NEXT.CALL,ALLOWED,ALLOW.MSG,PREV.ID,PRIOR.TNT.ID,PRIOR.ADD.ID,PEND.WO.NUMS,NEW.ADD,SERVICE.TOP,AI.TYPES,AI.TALK
*
COMMON SEC.USER.ID,HOLD.A,HOLD.B,HOLD.C
COMMON DISP.ONLY,CNT.TST(25)
COMMON RSPBUF,PROCBUF
*
COMMON ACT(50),ADD(25),ATR(20),ASH(20),DLQ(10),DVC(25),ACG(10),EFT(15),RTE(10),STT(10),SVC(15),SVS(20),TAX(10),TPL(10),WKO(60),WKP(10),SAVE.ACG(10),SAVE.ACT(50),SAVE.ADD(25),SAVE.ATR(20),SAVE.WKO(60),AIX(25)
*
*%%MDD%%=COMMON BELL,LF,FF,CR,AM,VM,SVM,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE,TT
*TM.MAX
~GET.TEST.ITEM~
*CODE.SEGMENT: ?
GET.TEST.ITEM: *
*
*
* READS CNT (THE VARIABLE 'TEST.ITEM') WHICH MUST BE LOADED
*
* 'SYSTEM.TEST' IN GENERAL.COMMON.AREA SHOULD BE LOADED WHERE APPLICABLE
*
* ATR   PURPOSE
*   1   ON/OFF
*
*   2   DISPLAY 'ENTERING' PROGRAM OR CALLED SUBROUTINE
*       1 - DISPLAY LOCATION AND PAUSE
*       2 - DISPLAY LOCATION AND INPUT <CR>
*
*   3   DISPLAY 'ENTERING' AN INTERNAL SUBROUTINE
*       1 - DISPLAY LOCATION AND PAUSE
*       2 - DISPLAY LOCATION AND INPUT <CR>
*
*   4   DISPLAY ITEM ID Flag
*       1 - DISPLAY ITEM ID BEING PROCESSED
*       2 - DISPLAY ITEM AND MSG IF ERROR/REJECTED, ETC.
*
*   5   LIST.NAME TO BE PROCESSED
*
*   6   TEST.DATE TO BE USED (EXTERNAL FORMAT)
*
*   7   BREAK IS ON
*
*   8   TIMING DISPLAY IS ON
*
*   9   TYPE-AHEAD IS OFF
*
*  10   NOT USED
*
*  11   W/O Sup-application Flags
*    mv 1 W/O processing in Genie
*    mv 2  "  printing
*    mv 3  "  Type processing Disc
*    mv 4  "   "       "      Connect
*    mv 5  "   "       "      Transfers
*    mv 6  "   "       "      Premium
*    mv 7 Device processing
*
*  12   Billing Sub-application Flags
*    mv 1 Billing
*    mv 2 Statements
*    mv 3 Daily update
*    mv 4 Monthly update
*    mv 5 EFT/PAC processing
*
*  13   System Maintenence Flags
*    mv 1 Parameters
*    mv 2 Purging
*    mv 3 Backup/Restore
*    mv 4 Printer processing
*    mv 5 Input processing
*    mv 6 Numeric/Special conversions
*
*  14   Release Distribution Flags
*
!
TEST.FL = 0; LIST.NAME = ""; DIS.SUB = 0; DIS.ITEM = 0; DIS.PROG = 0
TIMING = 0; BREAK.ON = 0; WKO.TEST = 0
IF TEST.ITEM = "" THEN TEST.ITEM = "SYSTEM.TEST"
READ TEST.ITEM FROM CNT.FILE,TEST.ITEM ELSE TEST.ITEM = ""
IF TEST.ITEM<1> NE "" THEN
TEST.FL =   1
DIS.PROG  = TEST.ITEM<2>
DIS.SUB   = TEST.ITEM<3>
DIS.ITEM  = TEST.ITEM<4>
LIST.NAME = TEST.ITEM<5>
TIMING    = TEST.ITEM<6>
BREAK.ON  = TEST.ITEM<7>
WKO.TEST  = TEST.ITEM<8>
END
RETURN
!
~GLACT.DIM~
*CODE.SEGMENT: ?
DIM GLACT(10)
~GLACT.EQUATES~
*CODE.SEGMENT: ?
* FILE 'GLACT' EQUATES - GENERATED 12:13:35  27 JUL 1984
EQU GLACT$DESCRIPTION TO GLACT(1);      * ACCOUNT DESCRIPTION
EQU GLACT$CODE TO GLACT(2);             * BALANCE CODE (not used)
EQU GLACT$PRO TO GLACT(3);              * PRORATE SCHEDULE NUMBER
EQU GLACT$SUBS TO GLACT(4);             * SUB ACCOUNT USAGE FLAG (Y=SUB MANDATORY)
EQU GLACT$PARENT TO GLACT(5);           * ULTIMATE G/L PARENT ACCOUNT
EQU GLACT$CHILD TO GLACT(6);            * ULTIMATE SYSTEM CHILD ACCOUNTS
~GLFIN.DIM~
*CODE.SEGMENT: ?
DIM GLFIN(20)
~GLFIN.EQUATES~
*CODE.SEGMENT: ?
* FILE 'GLFIN' EQUATES - GENERATED 15:14:42  01 AUG 1984
EQU GLFIN$OPENING TO GLFIN(1);          * BALANCE AT BEGINNING OF YEAR
EQU GLFIN$BALANCE TO GLFIN(2);          * ACCOUNT BALANCE
EQU GLFIN$PERIOD.1 TO GLFIN(3);         * ACTIVITY - PERIOD 1
EQU GLFIN$PERIOD.2 TO GLFIN(4);         * ACTIVITY - PERIOD 2
EQU GLFIN$PERIOD.3 TO GLFIN(5);         * ACTIVITY - PERIOD 3
EQU GLFIN$PERIOD.4 TO GLFIN(6);         * ACTIVITY - PERIOD 4
EQU GLFIN$PERIOD.5 TO GLFIN(7);         * ACTIVITY - PERIOD 5
EQU GLFIN$PERIOD.6 TO GLFIN(8);         * ACTIVITY - PERIOD 6
EQU GLFIN$PERIOD.7 TO GLFIN(9);         * ACTIVITY - PERIOD 7
EQU GLFIN$PERIOD.8 TO GLFIN(10);        * ACTIVITY - PERIOD 8
EQU GLFIN$PERIOD.9 TO GLFIN(11);        * ACTIVITY - PERIOD 9
EQU GLFIN$PERIOD.10 TO GLFIN(12);       * ACTIVITY - PERIOD 10
EQU GLFIN$PERIOD.11 TO GLFIN(13);       * ACTIVITY - PERIOD 11
EQU GLFIN$PERIOD.12 TO GLFIN(14);       * ACTIVITY - PERIOD 12
EQU GLFIN$CALC TO GLFIN(15);            * CALCULATED OPENING BALANCE
EQU GLFIN$DIFF TO GLFIN(16);            * DIFFERENCE BETWEEN OPENINGS
~GLOPN.DIM~
*CODE.SEGMENT: ?
DIM GLOPN(10)
~GLOPN.EQUATES~
*CODE.SEGMENT: ?
* FILE 'GLOPN' EQUATES - GENERATED 16:06:47  25 JUL 1984
EQU GLOPN$BATCH TO GLOPN(1);            * TRANSACTION BATCH NUMBER
EQU GLOPN$DESCRIPTION TO GLOPN(2);      * TRANSACTION DESCRIPTION
EQU GLOPN$ENT.DATE TO GLOPN(3);         * TRANSACTION ENTRY DATE
EQU GLOPN$ENT.PER TO GLOPN(4);          * TRANSACTION ENTRY PERIOD
EQU GLOPN$TRX.DATE TO GLOPN(5);         * TRANSACTION DATE
EQU GLOPN$DEBIT TO GLOPN(6);            * DEBIT AMOUNT
EQU GLOPN$CREDIT TO GLOPN(7);           * CREDIT AMOUNT
EQU GLOPN$SRC TO GLOPN(8);              * TRANSACTION SOURCE
EQU GLOPN$REFERENCE TO GLOPN(9);        * TRANSACTION REFERENCE
~GLRPTC.DIM~
*CODE.SEGMENT: ?
DIM GLRPTC(10)
~GLRPTC.EQUATES~
*CODE.SEGMENT: ?
* FILE 'GLRPTC' EQUATES - GENERATED 16:31:41  25 JUL 1984
EQU GLRPTC$TYP TO GLRPTC(1);            * RECORD TYPE
EQU GLRPTC$BEF TO GLRPTC(2);            * SPACING BEFORE PRINTING
EQU GLRPTC$AFT TO GLRPTC(3);            * SPACING AFTER PRINTING
EQU GLRPTC$FROM TO GLRPTC(4);           * FROM ACCOUNT NUMBER
EQU GLRPTC$TO TO GLRPTC(5);             * TO ACCOUNT NUMBER
EQU GLRPTC$DESCRIPTION TO GLRPTC(6);    * PRINTED DESCRIPTION
EQU GLRPTC$SPECIAL TO GLRPTC(7);        * SPECIAL ACTION CODE
~HOURS.INCL.CONV~
*CODE.SEGMENT: HOURS.INCL.CONV 
*
* AUTHOR: DAVID HORSMAN
*
IF NOT(NUM(TMP.TM)) THEN TMP.TM = ZERO
IF TMP.TM LT ZERO THEN TMP.SIGN = "-"; TMP.TM = ABS(TMP.TM) ELSE TMP.SIGN = EMPTY
IF NOT(TMP.TM) THEN ORSLT = EMPTY ELSE
*
ORSLT = INT(TMP.TM / 3600)
ORSLT = TMP.SIGN:ORSLT
*
END
*
~KBIL.INCL.DVC.CHECK.TYPE~
*CODE.SEGMENT: KBIL.INCL.DVC.CHECK.TYPE
* SUBROUTINE DVC.CHECK.TYPE(MAT DVT,DVC.CHECK.FUNC,DVC.CN.MAX,DVC.ID)
*
** EQU VS TO " (R:1.3)"
** *
** *
* PRINT CLB:"Entering dvc check type!":; INPUT TMP:
*
IF DVC.CHECK.FUNC EQ "ACT" THEN
DVC.DVCS = ACT$DVC.NUMS
DVC.LOCS = ACT$SVC.LOCATIONS
AI.TALK<AI.DVC.NEXT>      = ONE
END ELSE IF DVC.CHECK.FUNC = "WKO" THEN
DVC.DVCS = WKO$DVC.IDS
DVC.LOCS = WKO$SVC.LOCATIONS
AI.TALK<AI.DVC.NEXT>      = ONE
END ELSE IF DVC.CHECK.FUNC = "DVC" THEN
DVC.DVCS = DVC.ID
DVC.LOCS = EMPTY
END
*
DVC.VC.MAX = DCOUNT(DVC.DVCS,VM)
*22MAR94*FOR DVC.VC = ONE TO DVC.VC.MAX UNTIL AI.TALK<ADDRESSABLE> NE EMPTY
FOR DVC.VC = ONE TO DVC.VC.MAX
*
DVC.SC.MAX = DCOUNT(DVC.DVCS<ONE,DVC.VC>,SVM)
*22MAR94*FOR DVC.SC = ONE TO DVC.SC.MAX UNTIL AI.TALK<ADDRESSABLE> NE EMPTY
FOR DVC.SC = ONE TO DVC.SC.MAX
*
TMP.ID = DVC.DVCS<ONE,DVC.VC,DVC.SC>
TMP.LOC = DVC.LOCS<ONE,DVC.VC,DVC.SC>
*
IF LEN(TMP.ID) THEN
*
MATREAD DVC FROM DVC.FILE,TMP.ID ELSE MAT DVC = EMPTY
*
LOCATE DVC$TYPE IN DVT$DEVICE.TYPE<ONE> SETTING TYPE THEN
*
***IF DVT$PROG.ADDR<ONE,TYPE> EQ "A" OR DVT$PROG.ADDR<ONE,TYPE> EQ "I" OR DVT$PROG.ADDR<ONE,TYPE> EQ "O" THEN AI.TALK<ADDRESSABLE> = TMP.ID
*
TMP1 = DVC$FUNCS
TMP.MAX = DCOUNT(TMP1<ONE>,VM)
*
*27MAR94*FOR TMP.CN = ONE TO TMP.MAX UNTIL AI.TALK<ADDRESSABLE> NE EMPTY
FOR TMP.CN = ONE TO TMP.MAX
*
TMP = TMP1<ONE,TMP.CN>
LOCATE TMP IN DVC.FUNCS<ONE> SETTING TMP2 THEN
*
TMP3 = FALSE; TMP4 = FALSE; TMP5 = FALSE; TMP7 = FALSE
*
IF DVC.FUNCS<3,TMP2> EQ "I" OR DVC.FUNCS<3,TMP2> EQ "O" OR DVC.FUNCS<3,TMP2> EQ "Y" THEN TMP3 = TRUE
IF DVC.FUNCS<4,TMP2> EQ "Y" THEN TMP4 = TRUE
IF DVC.FUNCS<5,TMP2> EQ "Y" THEN TMP5 = TRUE
IF DVC.CHECK.FUNC NE "WKO" OR (WKO$ACTIVS<ONE,DVC.VC> EQ "S" AND WKO$ACTIV.QNTYS<ONE,DVC.VC> GT ZERO) THEN TMP7 = ONE ELSE TMP7 = -ONE
*
*
* IF DVC.CHECK.FUNC NE "WKO" OR (WKO$ACTIVS<ONE,DVC.VC> EQ "S" AND WKO$ACTIV.QNTYS<ONE,DVC.VC> GT ZERO) THEN
****IF TMP3 THEN AI.TALK<ADDRESSABLE> = TMP.ID
IF TMP3 OR TMP4 OR TMP5 THEN AI.TALK<ADDRESSABLE> = TMP.ID
* END
*
IF DVC.CHECK.FUNC NE "WKO" OR (WKO$ACTIVS<ONE,DVC.VC> EQ "S" AND WKO$ACTIV.QNTYS<ONE,DVC.VC> GT ZERO) THEN
IF TMP4 THEN AI.TALK<PAY.PER.VIEW> = TRUE
END
*
IF DVC.CHECK.FUNC NE "WKO" OR (WKO$ACTIVS<ONE,DVC.VC> EQ "S" AND WKO$ACTIV.QNTYS<ONE,DVC.VC> GT ZERO) THEN
IF TMP5 THEN AI.TALK<IMPULSE.PPV> = TRUE
END
*
IF TMP3 OR TMP4 OR TMP5 THEN
*
LOCATE TMP.ID IN AI.TALK<AI.DVC.IDS> SETTING TMP6 ELSE
AI.TALK<SENT> = FALSE
AI.TALK<VERIFIED.HOT> = FALSE
AI.TALK<VERIFIED.COLD> = FALSE
AI.TALK<VERIFIED.CHANGED> = FALSE
END
*
AI.TALK<AI.DVC.IDS,TMP6>  = TMP.ID
AI.TALK<AI.DVC.LOCS,TMP6> = TMP.LOC
AI.TALK<AI.DVC.ADDR,TMP6> = TMP3
AI.TALK<AI.DVC.PPV,TMP6>  = TMP4
AI.TALK<AI.DVC.IPPV,TMP6> = TMP5
AI.TALK<AI.DVC.DIR,TMP6>  = TMP7
AI.TALK<AI.DVC.SRCE,TMP6> = DVC.CHECK.FUNC
*
IF DVC.CHECK.FUNC EQ "WKO" THEN
AI.TALK<AI.DVC.WKO,TMP6>  = WKO.ID
AI.TALK<AI.DVC.NEXT>      = TMP6
END
*
END
*
END ELSE NULL
*
NEXT TMP.CN
*
END ELSE NULL
*
END
*
NEXT DVC.SC
*
NEXT DVC.VC
*
~KBIL.INCL.LOAD.ADDR~
*CODE.SEGMENT: KBIL.INCL.LOAD.ADDR
*
*
* MUST HAVE: ACT.ID
*            ACT    with equates
*
SNAD = ""; BNAD = ""; AD.VC = 1; ADB.VC = 1; SNAD.SORTKEY = ""; BNAD.SORTKEY = ""
LAST.NAME = FIELD(ACT$CUS.NAME,"*",1)
FIRST.NAME = FIELD(ACT$CUS.NAME,"*",2)
TITLE = FIELD(ACT$CUS.NAME,"*",3)
SNAD<AD.VC> = TRIM(TITLE:" ":FIRST.NAME:" ":LAST.NAME); AD.VC = AD.VC + ONE
SVC.ADDR = ""; BASE.COMMENT = ""
*
STT.ID = FIELD(ACT$ADD.ID,"*",3)
IF STT.ID THEN
*
UNAM = ""; DW.TYP = ADD$DWELLING.TYPE
IF DW.TYP = "APT" OR DW.TYP = "BLK" THEN UNAM = "APT"
IF DW.TYP = "HOS" OR DW.TYP = "HTL" OR DW.TYP = "OLD" OR DW.TYP = "SCH" THEN UNAM = "RM"
IF DW.TYP = "TPK" THEN UNAM = "LOT"
APNO = FIELD(ACT$ADD.ID,"*",1)
HSNO = FIELD(ACT$ADD.ID,"*",2)
MATREAD STT FROM STT.FILE,STT.ID ELSE MAT STT = ""
*
IF APNO # "" THEN
TMP.ADD.ID = "*":HSNO:"*":STT.ID
READV BASE.COMMENT FROM ADD.FILE,TMP.ADD.ID,11 ELSE BASE.COMMENT = ""
BASE.COMMENT = TRIM(BASE.COMMENT)
END
*
IF STT$NAME # "NO ST" AND STT$NAME NE "ERROR ST" THEN
*
IF APNO # "" THEN
*
IF UNAM # "" THEN
SVC.ADDR = TRIM(HSNO:" ":STT$NAME):"  ":UNAM:" ":APNO
END ELSE
HSNO = APNO:"-":HSNO
SVC.ADDR = TRIM(HSNO:" ":STT$NAME)
END
*
END ELSE SVC.ADDR = TRIM(HSNO:" ":STT$NAME)
*
END ELSE SVC.ADDR = ""
*
BNAD = SNAD; ADB.VC = AD.VC
*
COMMENT = TRIM(ADD$MESSAGE)
* IF (BASE.COMMENT # "" OR COMMENT NE "") THEN
* IF ACT$PO.BOX = "" THEN
IF COMMENT = BASE.COMMENT THEN COMMENT = ""
IF BASE.COMMENT # "" THEN SNAD<AD.VC> = BASE.COMMENT; AD.VC = AD.VC+1
IF COMMENT # "" THEN SNAD<AD.VC> = COMMENT; AD.VC = AD.VC+1
* END
* END
*
SNAD<AD.VC> = SVC.ADDR; AD.VC = AD.VC + ONE
*
*
HEND = FIELD(ADD(12),"*",2); IF HEND = "" THEN HEND = SPACE(2)
LOCATE STT$CITY.NUM IN CITIES<1> SETTING LOC THEN SNAD.CITY = CITIES<2,LOC>:", ":CITIES<3,LOC> ELSE SNAD.CITY = ""
SNAD.PCODE = ADD$POST.CODE
*
IF ACT$PO.BOX # "" THEN
IF ACT$PO.BOX = "GD" THEN BNAD<ADB.VC> = "General Delivery" ELSE BNAD<ADB.VC> = "P.O. Box ":ACT$PO.BOX
ADB.VC = ADB.VC + ONE
BNAD.CITY = SNAD.CITY; BNAD.PCODE = SNAD.PCODE
BNAD.SORTKEY = ZERO
BNAD<ADB.VC> = BNAD.CITY:"  ":BNAD.PCODE; ADB.VC = ADB.VC + ONE
* RETURN
END
*
SNAD.SORTKEY = AD.VC
SNAD<AD.VC> = SNAD.CITY:"  ":SNAD.PCODE; AD.VC = AD.VC + ONE
*
* BLANK STT.ID
END ELSE SNAD<AD.VC> = "Invalid Service Address"; AD.VC = AD.VC + ONE
*
BILL.TO.DTE = ""; BILL.TO.VC = ""
FOR VC = 1 TO 2
IF ACT$BILL.ADDR<1,VC> # "" THEN
BILL.EFF.DATE = ACT$BILL.EFF.DATE<1,VC>
IF BILL.EFF.DATE <= TDY THEN
BILL.TO.VC = VC
END
END
NEXT VC
*
IF BILL.TO.VC THEN
*
ADB.VC = TWO
IF ACT$BILL.NAME<1,BILL.TO.VC> = "" THEN
BNAD = SNAD<ONE>
END ELSE
B.NAME = ACT$BILL.NAME<1,BILL.TO.VC>
BNAD = TRIM(FIELD(B.NAME,"*",3):" ":FIELD(B.NAME,"*",2):" ":FIELD(B.NAME,"*",1))
END
*
BILL.ADDR = ACT$BILL.ADDR<1,BILL.TO.VC>
BNAD<ADB.VC> = FIELD(BILL.ADDR,"*",1); ADB.VC = ADB.VC + ONE
BNAD.CITY = FIELD(BILL.ADDR,"*",2)
BNAD.PCODE = FIELD(BILL.ADDR,"*",4)
BNAD.SORTKEY = ADB.VC
BNAD<ADB.VC> = BNAD.CITY:", ":FIELD(BILL.ADDR,"*",3)
*
IF LEN(BNAD<ADB.VC>) + LEN(BNAD.PCODE) + TWO LE 30 THEN
BNAD<ADB.VC> = BNAD<ADB.VC>:"  ":BNAD.PCODE
END ELSE
ADB.VC = ADB.VC + ONE
BNAD<ADB.VC> = BNAD.PCODE
END
ADB.VC = ADB.VC + ONE
*
END ELSE IF ACT$PO.BOX EQ "" THEN
BNAD = SNAD; ADB.VC = AD.VC; BNAD.SORTKEY = SNAD.SORTKEY
BNAD.CITY = SNAD.CITY; BNAD.PCODE = SNAD.PCODE
END
*
*
~KBIL.INCL.MSGS~
*CODE.SEGMENT: KBIL.INCL.MSGS
*
*
BMSG = ""
MSI = ""
IF ACT$STAT = "A" OR ACT$STAT = "T" THEN MSI = "C" ELSE MSI = "D"
TMP = ACT$CREDIT.STATUS
IF TMP < 1 THEN TMP = 1
IF TMP > 9 THEN TMP = 9
MSI = MSI:TMP
MSI = "MSG.":MSI
LOCATE MSI[5,9] IN MTP<1> SETTING MSGN ELSE NULL
MSGPL = MSG(MSGN); IF (MSGPL # "" AND PG = 1) THEN PL(1) = PL(1): MSI[5,2] "L#2" ELSE PL(1) = PL(1): SPACE(2) "L#2"
IF MSGPL = ""  AND (ACT$STAT = "A" OR ACT$STAT = "T") THEN
MSI = "MSG.P"
LOCATE MSI[5,9] IN MTP<1> SETTING MSGN ELSE NULL
MSGPL = MSG(MSGN)
IF MSGPL # "" THEN
BMSG = MSGPL
IF PG = 1 THEN PL(1) = PL(1):SPACE(2) "L#2"
END ELSE BMSG = ""
END
PL(1) = PL(1)
BMSG.LINES = 0; LOOP BMSG.LINES = BMSG.LINES+1; TMP = BMSG<BMSG.LINES> UNTIL TMP = "" DO REPEAT
*
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MSGN ELSE NULL
ALWAYS.MSG = MSG(MSGN)
FOR TMP = 2 TO 5
IF PG = 1 THEN PL(TMP) = PL(TMP):ALWAYS.MSG<TMP-1>[1,55] "L#55"
IF (PG # 1) THEN PL(TMP) = PL(TMP):SPACE(55) "L#55"
NEXT TMP
*
~KBIL.INCL.NEXT.AIL.ID~
*CODE.SEGMENT: KBIL.INCL.AIL.NEXT.ID
*
* GENERAL.COMMON.AREA
*
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:BELL:"Can't open COM.  Enter <cr> . . . ":; INPUT TMP:; STAT = 999; RETURN
LOOP
LCK.STAT = -3
CALL LOCK.ITEM(COM.FILE,"COM","NEXT.AIL.TRAN",LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN STAT = 999; RETURN
WHILE LCK.STAT DO REPEAT
READV AIL.NEXT.ID FROM COM.FILE,"NEXT.AIL.TRAN",1 ELSE AIL.NEXT.ID = 1
AIL.NEXT.ID = (AIL.NEXT.ID+100000)[2,5]
WRITEV (AIL.NEXT.ID+100001)[2,5] ON COM.FILE,"NEXT.AIL.TRAN",1
CALL UNLOCK.ITEM(COM.FILE,"COM","NEXT.AIL.TRAN",LCK.FILE)
*
~KBIL.INCL.SVC.CHECK.TYPE~
*CODE.SEGMENT: KBIL.INCL.SVC.CHECK.TYPE
* SUBROUTINE SVC.CHECK.TYPE(MAT DVT,SVC.CHECK.FUNC,SVC.CN.MAX,SVC.ID)
*
** EQU VS TO " (R:1.0)"
*
*
IF SVC.CHECK.FUNC EQ "ACT" THEN
SVC.SERVICES = ACT$SERVICES
END ELSE IF SVC.CHECK.FUNC = "WKO" THEN
SVC.SERVICES = WKO$ACTIV.SERVICES
END ELSE IF SVC.CHECK.FUNC = "DVC" THEN
SVC.SERVICES = DVC$SERVICE
END ELSE IF SVC.CHECK.FUNC EQ "SVC" THEN
SVC.SERVICES = SVC.ID
END
*
SVC.VC.MAX = DCOUNT(SVC.SERVICES,VM)
FOR SVC.VC = ONE TO SVC.VC.MAX
*
SVC.SC.MAX = DCOUNT(SVC.SERVICES<ONE,SVC.VC>,SVM)
FOR SVC.SC = ONE TO SVC.SC.MAX
*
TMP.ID = SVC.SERVICES<ONE,SVC.VC,SVC.SC>
*
IF LEN(TMP.ID) THEN
*
MATREAD SVC FROM SVC.FILE,TMP.ID THEN
*
TMP1 = SVC$DVC.FUNCS
TMP.MAX = DCOUNT(TMP1<ONE>,VM)
*
FOR TMP.CN = ONE TO TMP.MAX
*
TMP = TMP1<ONE,TMP.CN>
LOCATE TMP IN DVC.FUNCS<ONE> SETTING TMP2 THEN
*
TMP3 = FALSE; TMP4 = FALSE; TMP5 = FALSE
*
IF DVC.FUNCS<3,TMP2> EQ "I" OR DVC.FUNCS<3,TMP2> EQ "O" OR DVC.FUNCS<3,TMP2> EQ "Y" THEN TMP3 = TRUE
IF TMP3 THEN AI.TALK<ADDRESSABLE> = -ONE
*
IF DVC.FUNCS<4,TMP2> EQ "Y" THEN TMP4 = TRUE
IF TMP4 THEN AI.TALK<PAY.PER.VIEW> = -ONE
*
IF DVC.FUNCS<5,TMP2> EQ "Y" THEN TMP5 = TRUE
IF TMP5 THEN AI.TALK<IMPULSE.PPV> = -ONE
*
** IF TMP3 OR TMP4 OR TMP5 THEN
** LOCATE TMP.ID IN AI.TALK<AI.DVC.IDS> SETTING TMP6 ELSE NULL
** AI.TALK<AI.DVC.IDS,TMP6>  = TMP.ID
** AI.TALK<AI.DVC.LOCS,TMP6> = DVC$LOCATION
** AI.TALK<AI.DVC.ADDR,TMP6> = TMP3
** AI.TALK<AI.DVC.PPV,TMP6>  = TMP4
** AI.TALK<AI.DVC.IPPV,TMP6> = TMP5
** END
*
END ELSE NULL
*
NEXT TMP.CN
*
END
*
END ELSE NULL
*
NEXT SVC.SC
*
NEXT SVC.VC
*
~LBL.DIM~
*CODE.SEGMENT: ?
DIM LBL(10)
~LBL.EQUATES~
*CODE.SEGMENT: ?
* FILE 'LBL' EQUATES - GENERATED 14:44:59  18 MAY 1984
EQU LBL$SERVICES TO LBL(1);             * LIST OF SERVICES ON ACCOUNT
EQU LBL$NAME TO LBL(2);                 * SUBSCRIBER NAME
EQU LBL$ADDRESS TO LBL(3);              * SUBSCRIBER SERVICE ADDRESS
EQU LBL$CITY TO LBL(4);                 * CITY NAME
EQU LBL$POST.CODE TO LBL(5);            * POSTAL CODE
EQU LBL$SORTKEY TO LBL(6);              * SORT KEY (VARIABLE FORMAT)
~LCK.DIM~
*CODE.SEGMENT: ?
DIM LCK(20)
~LCK.EQUATES~
*CODE.SEGMENT: EQUATES
*
* FILE 'LCK' EQUATES - GENERATED 14:41:37  06 MAY 1991
*
*  This file contain lock items for all files for the
*  application programs
*
*
EQU LCK$PORT TO LCK(1);             * 
EQU LCK$ACCT TO LCK(2);        * 
EQU LCK$DT TO LCK(3);          * 
EQU LCK$TM TO LCK(4);          * 
EQU LCK$TYPE TO LCK(5);        * Contains value of Input Stat
EQU LCK$CLASS TO LCK(11);      * Class of lock
EQU LCK$PROG TO LCK(7);        * Program that owns lock
EQU LCK$CSEG TO LCK(15)
EQU LCK$RSVD TO LCK(8);        * Pass lock to (port mv stack)
EQU LCK$OPER TO LCK(9);        * Operator
EQU LCK$TM.EXP TO LCK(10);     * Time lock expires
EQU LCK$LOG.CN TO LCK(12);     * Err & Log Type counter
EQU LCK$RD.CN TO LCK(13);      * Number of requests for this record
EQU LCK$STAT  TO LCK(14);      * STAT
EQU LCK$MSG TO LCK(6);         * Message applicable to locking error
EQU LCK$RELS TO LCK(16);       * Program+Code.Segment+Seg.Loc unlocking
~LCK.VAR.EQUATES~
*CODE.SEGMENT: EQUATES
*
* FILE 'LCK' EQUATES - GENERATED 14:41:37  06 MAY 1991
*
*  This file contain lock items for all files for the
*  application programs
*
*
EQU LCK$PORT TO 1;             * 
EQU LCK$ACCT TO 2;        * 
EQU LCK$DT TO 3;          * 
EQU LCK$TM TO 4;          * 
EQU LCK$TYPE TO 5;        * Contains value of Input Stat
EQU LCK$CLASS TO 11;      * Class of lock
EQU LCK$PROG TO 7;        * Program that owns lock
EQU LCK$CSEG TO 15;       * Code segment calling locks
EQU LCK$RSVD TO 8;        * Pass lock to (port mv stack)
EQU LCK$OPER TO 9;        * Operator
EQU LCK$TM.EXP TO 10;     * Time lock expires
EQU LCK$LOG.CN TO 12;     * Err & Log Type counter
EQU LCK$RD.CN TO 13;      * Number of requests for this record
EQU LCK$STAT  TO 14;      * STAT
EQU LCK$MSG TO 6;         * Message applicable to locking error
EQU LCK$RELS TO 16;       * Program+Code.Segment+Seg.Loc Unlocking
~LOCKS.DIM~
*CODE.SEGMENT: ?
DIM LOCKS(10)
~LOCKS.EQUATES~
*CODE.SEGMENT: LOCKS.EQUATES
*
* FILE 'LOCKS' EQUATES - GENERATED 14:41:37  06 MAY 1991
*
*  This file contain lock items for all files for the
*  application programs
*
*
EQU LOCKS$PORT TO LOCKS(1);             * 
EQU LOCKS$ACCT.NAME TO LOCKS(2);        * 
EQU LOCKS$LCK.DATE TO LOCKS(3);        * 
EQU LOCKS$LCK.TIME TO LOCKS(4);        * 
EQU LOCKS$LCK.TYPE TO LOCKS(5);        * Contains value of Input Stat
EQU LOCKS$MSG TO LOCKS(6);              * Message applicable to locking error
~LOCKS.VAR.EQUATES~
*CODE.SEGMENT: LOCKS.VAR.EQUATES
*
* FILE 'LOCKS' EQUATES - GENERATED 14:41:38  06 MAY 1991
*
*  This file contain lock items for all files for the
*  application programs
*
*
EQU LOCKS$PORT TO 1;                    * 
EQU LOCKS$ACCT.NAME TO 2;               * 
EQU LOCKS$LCK.DATE TO 3;               * 
EQU LOCKS$LCK.TIME TO 4;               * 
EQU LOCKS$LCK.TYPE TO 5;               * Contains value of Input Stat
EQU LOCKS$MSG TO 6;                     * Message applicable to locking error
EQU LOCKS$PROG.NAME TO 7;               * Program creating lock
~LPT.INCL.CLOSE~
*CODE.SEGMENT: LPT.INCL.CLOSE
*
* PROGRAM:           LPT.INCL.CLOSE
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       CLOSES PRINTER
*
* ULT ONLY
PRINTER CLOSE
LPT.STAT = FALSE
*
~LPT.INCL.OFF~
*CODE.SEGMENT: LPT.INCL.OFF
*
* PROGRAM:           LPT.INCL.OFF
* COMPANY:           AXIOFF COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       TURNS PRINTER OFF
*
* ULT ONLY
PRINTER OFF
LPT.STAT = FALSE
*
~LPT.INCL.ON~
*CODE.SEGMENT: LPT.INCL.ON
*
* PROGRAM:           LPT.INCL.ON
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       TURNS PRINTER ON
*
* ULT ONLY
PRINTER ON
LPT.STAT = FALSE
*
~MDD.STANDARD.FUNCTIONS~
*CODE.SEGMENT: ?
*
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+1000)[2,3]; ACCT = FIELD(WHO," ",2); OPSYS = "M"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
*
BEGIN CASE
*
CASE TERM = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
CASE TERM = "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "R"
RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "E"
RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TERM = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
*
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
~MENUS.VM.DIM~
*CODE.SEGMENT: MENUS.VM.DIM
*
DIM MENUS.VM(10)
~MENUS.VM.EQUATES~
*CODE.SEGMENT: MENUS.VM.EQUATES
*
* FILE 'MENUS.VM' EQUATES - GENERATED 09:42:49  03 MAR 1992
EQU MENUS.VM$DESC TO MENUS.VM(1);       * Description of functions
EQU MENUS.VM$VERB TO MENUS.VM(2);       * Verb to be executed by options
EQU MENUS.VM$LABEL TO MENUS.VM(3);      * Two to three character label
EQU MENUS.VM$HELP TO MENUS.VM(4);       * Help document file and name
EQU MENUS.VM$OPSYS TO MENUS.VM(5);      * Operating systems valid for
EQU MENUS.VM$GROUP TO MENUS.VM(6);      * Groups option valid for
EQU MENUS.VM$USER TO MENUS.VM(7);       * Users option valid for
~MENUS.VM.VAR.EQUATES~
*CODE.SEGMENT: MENUS.VM.VAR.EQUATES
*
* FILE 'MENUS.VM' EQUATES - GENERATED 09:42:49  03 MAR 1992
EQU MENUS.VM$DESC TO 1;                 * Description of functions
EQU MENUS.VM$VERB TO 2;                 * Verb to be executed by options
EQU MENUS.VM$LABEL TO 3;                * Two to three character label
EQU MENUS.VM$HELP TO 4;                 * Help document file and name
EQU MENUS.VM$OPSYS TO 5;                * Operating systems valid for
EQU MENUS.VM$GROUP TO 6;                * Groups option valid for
EQU MENUS.VM$USER TO 7;                 * Users option valid for
EQU MENUS.VM$APPL TO 8;                 * Application option belongs to
~MINUTES.INCL.CONV~
*CODE.SEGMENT: MINUTES.INCL.CONV 
*
* AUTHOR: DAVID HORSMAN
*
IF NOT(NUM(TMP.TM)) THEN TMP.TM = ZERO
IF TMP.TM LT ZERO THEN TMP.SIGN = "-"; TMP.TM = ABS(TMP.TM) ELSE TMP.SIGN = EMPTY
IF NOT(TMP.TM) THEN ORSLT = EMPTY ELSE
*
ORSLT = INT(TMP.TM / 3600):((OCONV((TMP.TM - (INT(TMP.TM / 3600) * 3600)),"MTS")) "R#6") "L#3"
ORSLT = TMP.SIGN:ORSLT
*
END
*
~MSG.ROUTINE.DISPLAY~
*CODE.SEGMENT: MSG.ROUTINE.DISPLAY
*
* AUTHOR: DAVID HORSMAN
*
!
*MSG.ROUTINE.DISPLAY: * Routine to display trace for testing.
PRINT @(0,23):CLL:Routine:
IF WAIT.FLAG THEN RQM; RQM
*
*
~MSO.DIM~
*CODE.SEGMENT: ?
DIM MSO(20)
~MSO.EQUATES~
*CODE.SEGMENT: ?
* FILE 'MSO' EQUATES - GENERATED 08:55:54  23 FEB 1984
EQU MSO$NAME TO MSO(2);                 * MSO COMPANY NAME
EQU MSO$XREF TO MSO(3);                 * CROSS REFERENCE TO OWNING MSO
EQU MSO$ADDRESS TO MSO(4);              * ADDRESS OF MSO
EQU MSO$PHONE TO MSO(5);                * CORP. PHONE NO.
EQU MSO$CONTACT.NAMES TO MSO(6);        * CONTACT NAMES
EQU MSO$CONTACT.TITLES TO MSO(7);       * CONTACT TITLE
EQU MSO$CONTACT.PHONES TO MSO(8);       * CONTACT PHONE NO.
EQU MSO$SYSYEM.QNTY TO MSO(9);          * NO. OF SYSTEMS OWNED
EQU MSO$SUB.QNTY TO MSO(10);            * NO. OF SUBSCRIBERS
EQU MSO$PAY.QNTY TO MSO(11);            * NO. OF PAY SUBSCRIBERS
EQU MSO$POTENTIAL TO MSO(12);           * MARKET POTENTIAL CODE
EQU MSO$AFFILIATION TO MSO(13);         * COMPETITOR AFFILIATION
EQU MSO$STATES TO MSO(14);              * SYSTEM LOCATION BY STATE
EQU MSO$SYSTEM.NAMES TO MSO(15);        * NAME OF OWNED SYSTEM
EQU MSO$OWNERSHIP TO MSO(16);           * MSO SYSTEM OWNERSHIP CODE
EQU MSO$COMMENT TO MSO(17);             * MSO COMMENTS
~NARR.DIM~
*CODE.SEGMENT: ?
DIM NARR(10)
~NARR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'NARR' EQUATES - GENERATED 10:16:00  11 SEP 1984
EQU NARR$DESCRIPTION TO NARR(1);        * PROGRAM DESCRIPTION
EQU NARR$FILES TO NARR(2);              * FILES USED BY PROGRAM
EQU NARR$UPD TO NARR(3);                * FILE UPDATED BY THIS PROGRAM? (Y/N)
EQU NARR$NARRATIVE TO NARR(4);          * PROGRAM NARRATIVE
~NEW.CURSOR.STD~
*CODE.SEGMENT: CURSOR.STD
*
* DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* DATE RELEASED: 01 DEC 90
* DATE REVISED: 9 NOV 92
*
*
* DATE REVISED:  5 JUN 92
*
*        STAT    MEANING
*           0    GOOD RESPONSE
*          -1    REQUEST BACKUP
*          -2    POSITION CHANGE IN INPUT.DATA.SG (RETURN)
*           1    BAD RESPONSE (ERROR MESSAGE IN RSP<2>)
*         998    <ESC> WAS PRESSED
*         999    REQUEST KILL
*
* Fields: DEF Default (Original field value)
*         FLD Current field value
*         DEF Original field value
*          CL Column     OLD.CL Old Column
*          LN Line       OLD.LN Old Line
*      CL.LOC Column Location
*  OLD.CL.LOC Old Column Location
*          LH Length     LHM Maximum Length
*        NUMC Numbers on / off
*          MS Mask for display
*          ML Maximum display length
*   NO.PROMPT Don't prompt (DISP.ONLY)
*        CONV Conversion
*
!
*
RSP = EMPTY; DEF = FLD; FLD.LEN = LEN(FLD)
IF CONV[ONE,ONE] EQ "M" OR CONV[ONE,ONE] EQ "D" THEN NON.NUMERIC.CONV = ZERO; NUMC = TRUE ELSE NON.NUMERIC.CONV = ONE
IF DEF NE EMPTY THEN
IF CONV NE EMPTY THEN
IF NUM(DEF) OR NOT(NON.NUMERIC.CONV) THEN
NUMC = TRUE
IF CONV MATCHES "'D'1N'N'" THEN MOD.CONV = CONV[ONE,TWO] ELSE MOD.CONV = CONV
DEF = OCONV(DEF,MOD.CONV)
IF MOD.CONV NE CONV THEN DEF = DEF[ONE,TWO]:DEF[4,3]:DEF[8,TWO]
END
END
END
IF TC.FILL EQ EMPTY THEN TC.FILL = " "
*
IF MS EQ EMPTY THEN
IF LH[ONE,ONE] MATCHES "1A" THEN
MS = LH[ONE,ONE]:"#":LH[TWO,9999]; LH = LH[TWO,9999]
END ELSE MS = "L#":LH
END
*
IF LHM[ONE,ONE] MATCHES "1A" THEN LHM = LHM[TWO,9999]
IF LH GT 4 THEN ML = LH ELSE ML = 4
*
DISP.DEF = DEF:STR(TC.FILL,LH-LEN(DEF))
*
IF NO.PROMPT THEN
RSP = DEF
END ELSE
*
TC.CN = ZERO; TCO = FLD[TC.CN + ONE,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
IF GENERIC THEN
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):
END ELSE
PRINT @(RSP.CL,RSP.LN):DISP.DEF MS:@(RSP.CL,RSP.LN):RVB:TCO:RVE:@(CL,LN):
END
*
BEGIN CASE
*
*CASE NOT(OPSYS EQ "U" OR OPSYS EQ "M") OR LH EQ LHM
CASE NOT(OPSYS EQ "U" OR OPSYS EQ "M") OR GENERIC
INPUT RSP,ML:_
IF RSP EQ EMPTY THEN DEFAULT.USED = TRUE; RSP = DEF
*
CASE TRUE
*
! Character input loop
*
RSP = EMPTY; TC.CL = RSP.CL; TC.CONT = TRUE; TC.MOVE = TRUE
TC.STOP = RSP.CL + ML; TC.START = ONE; TC.ADJ = FALSE
CLEAR.BOTTOM.LINE = FALSE; TC.INS = FALSE
IF NUMC OR GENERIC THEN
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF NUMC THEN PRINT @(60,TMP):"   ":RVB:"NUM":RVE:"   ":@(CL,LN):
IF GENERIC THEN PRINT @(40,TMP):"   ":RVB:"GEN":RVE:"   ":@(CL,LN):
END
*
LOOP
*
IF TC.CONT THEN
*
TC = EMPTY
TCO = FLD[TC.CN + ONE,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
PRINT @(TC.CL,RSP.LN):RVB:TCO:RVE:@(CL,LN):
*
BEGIN CASE
CASE OPSYS NE "U"
ECHO OFF
INPUT TC,ONE:
ECHO ON
IF TC EQ EMPTY THEN TC = CHAR(13)
CASE TRUE
ECHO OFF
TC = OCONV(TC,"U51EA")
ECHO ON
END CASE
*
TC.SEQ = ("000":SEQ(TC)) "R#3"
*
LOCATE TC.SEQ IN CURSOR.KEYS<TWO> SETTING TC.LOC THEN
TC.OUT = CURSOR.KEYS<3,TC.LOC>
IF (TC.OUT EQ "G" OR TC.OUT EQ "C") OR NOT(GENERIC) THEN
IF NUM(TC.OUT) THEN
IF NUMC THEN
TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE
TC.CONT = FALSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
END
END ELSE
TC = EMPTY; TS.SEQ = EMPTY; TC.FUNC = TC.OUT
IF TC.OUT EQ "C" THEN TC.CONT = FALSE
END
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
END ELSE TC.LOC = FALSE; TC.OUT = EMPTY; TC.FUNC = EMPTY
*
END; * of TC.CONT
*
WHILE TC.CONT DO
*
! System Character
*
IF TC.LOC THEN
*
BEGIN CASE
*
CASE TC.FUNC EQ "|"
*
IF LEN(FLD) GT TC.CN THEN
*
TC = FLD[TC.CN + ONE,ONE]
TC.SEQ = SEQ(TC)
TC.LOC = FALSE; TC.OUT = EMPTY
IF TC.INS THEN
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
TC.INS = FALSE
PRINT @(70,TMP):SPACE(9):@(CL,LN):
END
*
END ELSE PRINT BELL:; TC = EMPTY; TC.SEQ = EMPTY
*
CASE TC.FUNC EQ "<"
*
IF TC.CN THEN
PRINT @(TC.CL,RSP.LN):TCO:
TC.CN = TC.CN - ONE
TC.CL = TC.CL - ONE
RSP = RSP[ONE,TC.CN]
IF TC.INS THEN
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
TC.INS = FALSE
PRINT @(70,TMP):SPACE(9):@(CL,LN):
END
IF TC.CL LT RSP.CL OR TC.CN LT TC.START THEN TC.ADJ = TRUE
END ELSE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
END
*
CASE TC.FUNC EQ "\"
*
RSP = EMPTY; FLD = EMPTY; CLEAR.FLAG = TRUE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
*
CASE TC.FUNC EQ "R"
FLD = DEF; RSP = EMPTY; CLEAR.FLAG = FALSE
TC.START = ONE; TC.ADJ = TRUE; TC.CN = ZERO
*
CASE TC.FUNC EQ "I"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF TC.INS THEN
TC.INS = FALSE
PRINT @(70,TMP):SPACE(9):@(CL,LN):
END ELSE
TC.INS = TRUE
PRINT @(70,TMP):"   ":RVB:"INS":RVE:"   ":@(CL,LN):
END
*
CASE TC.FUNC EQ "D"
*
IF LEN(FLD) GT TC.CN THEN
FLD = FLD[ONE,TC.CN]:FLD[TC.CN + TWO,9999]
END
TC.ADJ = TRUE; TC.MOVE = FALSE
*
CASE TC.FUNC EQ "S"
*
GOSUB SYS.DEBUG
*
CASE TC.FUNC EQ "A"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
PRINT @(50,TMP):RVB:"  Alt:   ":RVE:@(56,TMP):
INPUT TMP1,3:_
IF NUM(TMP1) THEN
IF TMP1 GE ZERO AND TMP1 LE 255 THEN
TC = CHAR(TMP1); TC.SEQ = SEQ(TC); TC.LOC = FALSE
END ELSE PRINT BELL:
END ELSE PRINT BELL:
PRINT @(50,TMP):SPACE(9):@(CL,LN):
*
CASE TC.FUNC EQ "N"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF NOT(NUMC) THEN
PRINT @(60,TMP):"   ":RVB:"NUM":RVE:"   ":@(CL,LN):
NUMC = TRUE
END ELSE
PRINT @(60,TMP):SPACE(9):@(CL,LN):
NUMC = FALSE
END
*
CASE TC.FUNC EQ "G"
*
IF RSP.LN EQ TWO OR LN EQ TWO THEN TMP = ZERO ELSE TMP = TWO
IF NOT(GENERIC) THEN
PRINT @(40,TMP):"   ":RVB:"GEN":RVE:"   ":@(CL,LN):
GENERIC = TRUE
END ELSE
PRINT @(40,TMP):SPACE(9):@(CL,LN):
GENERIC = FALSE
END
*
CASE TC.FUNC EQ "E"
*
IF RSP.LN EQ 22 OR LN EQ 22 THEN TMP = ZERO ELSE TMP = 22
TMP1 = DCOUNT(CURSOR.KEYS<5>,VM)
PRINT @(ZERO,TMP):CLL:RVB:"Enter function number (0 to continue): ":RVE:
LOOP
PRINT @(40,TMP):
INPUT TC.FUNC.NUM,ONE:
IF NUM(TC.FUNC.NUM) THEN
IF TC.FUNC.NUM LT ZERO OR TC.FUNC.NUM GT TMP1 THEN TC.FUNC.NUM = "?"
END
WHILE NOT(NUM(TC.FUNC.NUM)) DO PRINT BELL: REPEAT
PRINT @(ZERO,TMP):CLL:@(CL,LN):
IF TC.FUNC.NUM THEN
RSP = CURSOR.KEYS<5,TC.FUNC.NUM>; TC.CONT = FALSE
EXEC.DESC = "F":TC.FUNC.NUM:" - ":CURSOR.KEYS<4,TC.FUNC.NUM>
EXEC.VERB = CURSOR.KEYS<5,TC.FUNC.NUM>
END
*
CASE TC.FUNC EQ "@"
*
IF RSP.LN EQ 22 OR LN EQ 22 THEN TMP = ZERO ELSE TMP = 22
PRINT @(ZERO,TMP):CLL:RVB:"Enter the function name: ":RVE:BELL:
INPUT STD.SUBR.NAME:
IF STD.SUBR.NAME EQ EMPTY THEN STD.SUBR.NAME = SEC.USER$FUNC.NAME
IF STD.SUBR.NAME NE EMPTY THEN
* STD.FUNC = "PERFORM"
SEC.USER$FUNC.NAME = STD.SUBR.NAME; TC.CONT = FALSE
* GOSUB LOAD.STD.DATA
* GOSUB ENTER.STD.SUBR
END ELSE
TC.ADJ = TRUE
PRINT @(ZERO,TMP):CLL:
END; * Of routine name
*
CASE TRUE
*
TC.FUNC = EMPTY
*
END CASE
*
END; * Of TC.FUNC
*
! Not a system character
*
IF NOT(TC.LOC) AND LEN(TC) THEN
*
IF TC.SEQ GE 28 THEN
*
IF TC.SEQ LE 30 THEN
TC.SEQ = TC.SEQ + 224
TC = CHAR(TC.SEQ)
IF TT EQ "D" OR TT EQ "R" THEN PRINT TC:
END
*
IF TC.INS THEN
TMP = LEN(FLD)
IF TMP LT TC.CN THEN
FLD = FLD:RSP[TMP + ONE,9999]
END
FLD = FLD[ONE,TC.CN]:TC:FLD[TC.CN + ONE,9999]
TC.ADJ = TRUE; TC.MOVE = FALSE
END
*
RSP = RSP:TC
TCO = FLD[TC.CN + ONE,ONE]
IF TCO EQ EMPTY THEN TCO = TC.FILL
PRINT @(TC.CL,RSP.LN):TC:@(CL,LN):
TC.CN = TC.CN + ONE
TC.CL = TC.CL + ONE
*
END; * Of ge 28
*
END; * Of no TC.OUT
*
IF TC.CL GE TC.STOP OR TC.ADJ THEN
IF NOT(TC.MOVE) AND TC.CL LT TC.STOP THEN
TC.MOVE = TRUE
TMP = TC.CN - TC.START + ONE
END ELSE IF TC.CL GE TC.STOP OR TC.START NE ONE THEN
TMP = INT(LH / TWO)
END ELSE TMP = ZERO
IF TMP GT TC.CN THEN TMP = TC.CN
TC.START = TC.CN - TMP + ONE
* INPUT TMP.RSP:
TC.CL = RSP.CL + TMP
TMP1 = FLD[TC.CN + ONE,LH - TMP]
TMP1 = TMP1:STR(TC.FILL,LH - TMP - LEN(TMP1))
PRINT @(RSP.CL,RSP.LN):RSP[TC.START,LH]:TMP1:@(TC.CL,RSP.LN):
TC.ADJ = FALSE
TC.MOVE = TRUE
END
*
IF TC.CN EQ LHM THEN
TEXT = "No more than ":LHM:" characters please"
IF RSP.LN EQ 23 OR LN EQ 23 THEN TMP = 22 ELSE TMP = 23
PRINT @(ZERO,TMP):CLL:TEXT[ONE,78]:BELL:@(CL,LN):
CLEAR.BOTTOM.LINE = TMP
END
*
! End of system / non-system character
*
REPEAT
*
IF (TC.CN EQ ZERO AND (TC.FUNC EQ "C" OR TC.FUNC EQ EMPTY)) AND NOT(CLEAR.FLAG) THEN DEFAULT.USED = TRUE; RSP = DEF
IF CLEAR.BOTTOM.LINE THEN PRINT @(ZERO,CLEAR.BOTTOM.LINE):CLL:; CLEAR.BOTTOM.LINE = FALSE
* IF TC.START NE ONE THEN PRINT @(RSP.CL,RSP.LN):RSP[ONE,ML]:
*
END CASE
*
! End of Opsys ? / U or M
*
END; * Of NO.PROMPT
*
PRINT @(RSP.CL,RSP.LN):RSP MS:
FLD = RSP
*
*
~NEW.STANDARD.FUNCTIONS~
*CODE.SEGMENT: ?
*
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+1000)[2,3]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
*
BEGIN CASE
*
CASE TERM = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
CASE TERM = "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "R"
RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "E"
RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TERM = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
*
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
~PAP.DIM~
*CODE.SEGMENT: ?
DIM PAP(8)
~PAP.EQUATES~
*CODE.SEGMENT: ?
* FILE 'PAP' EQUATES - GENERATED 17:58:42  26 NOV 1988
EQU PAP$TRANS.TYPE TO PAP(1);           * 
EQU PAP$BANK.ACCT.TYPE TO PAP(2);       * 
EQU PAP$TRANSIT.NUM TO PAP(3);          * 
EQU PAP$BANK.ACCT.NUM TO PAP(4);        * 
EQU PAP$DRAW.AMT TO PAP(5);             * 
EQU PAP$DRAW.DATE TO PAP(6);            * 
EQU PAP$ACCOUNT.NUM TO PAP(7);          * 
EQU PAP$BANK.ACCT.NAME TO PAP(8);       * 
~PAR.AIHERR.DIM~
*CODE.SEGMENT: PAR.AIHERR.DIM
*
DIM COM.AIHERR(15)
~PAR.AIHERR.EQUATES~
*CODE.SEGMENT: COM.AIHERR.EQUATES
*
* FILE 'COM.AIHERR' EQUATES - GENERATED 19:25:21  07 MAR 1992
EQU COM.AIHERR$STD TO COM.AIHERR(1);    * Standard Handler Error Code
EQU COM.AIHERR$RCVD TO COM.AIHERR(2);   * Error received from Head End
EQU COM.AIHERR$DESC TO COM.AIHERR(3);   * Description / Error text
EQU COM.AIHERR$RETRY TO COM.AIHERR(4);  * Number of retries
EQU COM.AIHERR$PAUSE TO COM.AIHERR(5);  * No of sec before Retry
EQU COM.AIHERR$LOG TO COM.AIHERR(6);    * Log this type of error
EQU COM.AIHERR$FUNC TO COM.AIHERR(7);   * Function to perform to fix error
EQU COM.AIHERR$DISP TO COM.AIHERR(8);   * Message to be sent to dispatcher
EQU COM.AIHERR$MNGR TO COM.AIHERR(9);   * Message to be sent office manager
EQU COM.AIHERR$TYPE TO COM.AIHERR(10);  * Type of error
EQU COM.AIHERR$VAR TO COM.AIHERR(11);   * Variable to be set with this value
~PAR.AIHERR.VAR.EQUATES~
*CODE.SEGMENT: COM.AIHERR.VAR.EQUATES
*
* FILE 'COM.AIHERR' EQUATES - GENERATED 19:25:21  07 MAR 1992
EQU COM.AIHERR$STD TO 1;                * Standard Handler Error Code
EQU COM.AIHERR$RCVD TO 2;               * Error received from Head End
EQU COM.AIHERR$DESC TO 3;               * Description / Error text
EQU COM.AIHERR$RETRY TO 4;              * Number of retries
EQU COM.AIHERR$PAUSE TO 5;              * No of sec before Retry
EQU COM.AIHERR$LOG TO 6;                * Log this type of error
EQU COM.AIHERR$FUNC TO 7;               * Function to perform to fix error
EQU COM.AIHERR$DISP TO 8;               * Message to be sent to dispatcher
EQU COM.AIHERR$MNGR TO 9;               * Message to be sent office manager
EQU COM.AIHERR$TYPE TO 10;              * Type of error
EQU COM.AIHERR$VAR TO 11;               * Variable to be set with this value
~PAR.AIIERR.DIM~
*CODE.SEGMENT: PAR.AIIERR.DIM
*
DIM COM.AIIERR(15)
~PAR.AIIERR.EQUATES~
*CODE.SEGMENT: COM.AIIERR.EQUATES
*
* FILE 'COM.AIIERR' EQUATES - GENERATED 19:30:03  07 MAR 1992
EQU COM.AIIERR$STD TO COM.AIIERR(1);    * Standard Handler Error Code
EQU COM.AIIERR$RCVD TO COM.AIIERR(2);   * Error received from Head End
EQU COM.AIIERR$DESC TO COM.AIIERR(3);   * Description / Error text
EQU COM.AIIERR$RETRY TO COM.AIIERR(4);  * Number of retries
EQU COM.AIIERR$PAUSE TO COM.AIIERR(5);  * No of sec before Retry
EQU COM.AIIERR$LOG TO COM.AIIERR(6);    * Log this type of error
EQU COM.AIIERR$FUNC TO COM.AIIERR(7);   * Function to perform to fix error
EQU COM.AIIERR$DISP TO COM.AIIERR(8);   * Message to be sent to dispatcher
EQU COM.AIIERR$MNGR TO COM.AIIERR(9);   * Message to be sent office manager
EQU COM.AIIERR$TYPE TO COM.AIIERR(10);  * Type of error
EQU COM.AIIERR$VAR TO COM.AIIERR(11);   * Variable to be set with this value
~PAR.AIIERR.VAR.EQUATES~
*CODE.SEGMENT: COM.AIIERR.VAR.EQUATES
*
* FILE 'COM.AIIERR' EQUATES - GENERATED 19:30:03  07 MAR 1992
EQU COM.AIIERR$STD TO 1;                * Standard Handler Error Code
EQU COM.AIIERR$RCVD TO 2;               * Error received from Head End
EQU COM.AIIERR$DESC TO 3;               * Description / Error text
EQU COM.AIIERR$RETRY TO 4;              * Number of retries
EQU COM.AIIERR$PAUSE TO 5;              * No of sec before Retry
EQU COM.AIIERR$LOG TO 6;                * Log this type of error
EQU COM.AIIERR$FUNC TO 7;               * Function to perform to fix error
EQU COM.AIIERR$DISP TO 8;               * Message to be sent to dispatcher
EQU COM.AIIERR$MNGR TO 9;               * Message to be sent office manager
EQU COM.AIIERR$TYPE TO 10;              * Type of error
EQU COM.AIIERR$VAR TO 11;               * Variable to be set with this value
~PAR.HERR.EQUATES~
*CODE.SEGMENT: PAR.HERR.EQUATES
*
* FILE 'PAR.HERR' EQUATES - GENERATED 18:52:27  07 MAR 1992
~PAR.HERR.VAR.EQUATES~
*CODE.SEGMENT: PAR.HERR.VAR.EQUATES
*
* FILE 'PAR.HERR' EQUATES - GENERATED 18:52:27  07 MAR 1992
~PAR.MENU.DIM~
*CODE.SEGMENT: PAR.MENU.DIM
*
DIM PAR.MENU(15)
~PAR.MENU.EQUATES~
*CODE.SEGMENT: PAR.MENU.EQUATES
*
* FILE 'PAR.MENU' EQUATES - GENERATED 06:32:56  15 MAR 1992
EQU PAR.MENU$PORT.KEY TO PAR.MENU(1);   * Port Key for this port record
EQU PAR.MENU$MENU.ID TO PAR.MENU(2);    * Menu usage path
EQU PAR.MENU$LOCN TO PAR.MENU(3);       * Menu Option path
EQU PAR.MENU$DT TO PAR.MENU(4);         * Date this menu was accessed
EQU PAR.MENU$TM TO PAR.MENU(5);         * Time this port was last used
EQU PAR.MENU$DESC TO PAR.MENU(6);       * Title or Run description
EQU PAR.MENU$GROUP TO PAR.MENU(7);      * Not Used
EQU PAR.MENU$USER TO PAR.MENU(8);       * User currently using this port
EQU PAR.MENU$USER.DT TO PAR.MENU(9);    * Date user accessed the system
EQU PAR.MENU$USER.TM TO PAR.MENU(10);   * Time user accessed this port
EQU PAR.MENU$BF      TO PAR.MENU(11);   * Break flag
~PAR.MENU.VAR.EQUATES~
*CODE.SEGMENT: PAR.MENU.VAR.EQUATES
*
* FILE 'PAR.MENU' EQUATES - GENERATED 06:32:56  15 MAR 1992
EQU PAR.MENU$PORT.KEY TO 1;             * Port Key for this port record
EQU PAR.MENU$MENU.ID TO 2;              * Menu usage path
EQU PAR.MENU$LOCN TO 3;                 * Menu Option path
EQU PAR.MENU$DT TO 4;                   * Date this menu was accessed
EQU PAR.MENU$TM TO 5;                   * Time this port was last used
EQU PAR.MENU$DESC TO 6;                 * Title or Run description
EQU PAR.MENU$GROUP TO 7;                * Not Used
EQU PAR.MENU$USER TO 8;                 * User currently using this port
EQU PAR.MENU$USER.DT TO 9;              * Date user accessed the system
EQU PAR.MENU$USER.TM TO 10;             * Time user accessed this port
~PAR.PORT.DIM~
*CODE.SEGMENT: PAR.PORT.DIM
*
DIM PAR.PORT(10)
~PAR.PORT.EQUATES~
*CODE.SEGMENT: PAR.PORT.EQUATES
*
* FILE 'PAR.PORT' EQUATES - GENERATED 09:49:07  03 MAR 1992
EQU PAR.PORT$KEY TO PAR.PORT(1);        * Port Key for this port
EQU PAR.PORT$MENU TO PAR.PORT(2);       * Last menu in use
EQU PAR.PORT$LOCT TO PAR.PORT(3);       * Location on screen
EQU PAR.PORT$DT TO PAR.PORT(4);         * Date of last activity
EQU PAR.PORT$TM TO PAR.PORT(5);         * Time of last activity
EQU PAR.PORT$VERB TO PAR.PORT(6);       * Last Verb or Activity executed
EQU PAR.PORT$USER.GROUP TO PAR.PORT(7); * Groups user allowed
EQU PAR.PORT$USER TO PAR.PORT(8);       * User using this port
EQU PAR.PORT$PASS.DT TO PAR.PORT(9);    * Date of last password verification
EQU PAR.PORT$PASS.TM TO PAR.PORT(10);   * Time of last password validation
~PAR.PORT.VAR.EQUATES~
*CODE.SEGMENT: PAR.PORT.VAR.EQUATES
*
* FILE 'PAR.PORT' EQUATES - GENERATED 09:49:07  03 MAR 1992
EQU PAR.PORT$KEY TO 1;                  * Port Key for this port
EQU PAR.PORT$MENU TO 2;                 * Last menu in use
EQU PAR.PORT$LOCT TO 3;                 * Location on screen
EQU PAR.PORT$DT TO 4;                   * Date of last activity
EQU PAR.PORT$TM TO 5;                   * Time of last activity
EQU PAR.PORT$VERB TO 6;                 * Last Verb or Activity executed
EQU PAR.PORT$USER.GROUP TO 7;           * Groups user allowed
EQU PAR.PORT$USER TO 8;                 * User using this port
EQU PAR.PORT$PASS.DT TO 9;              * Date of last password verification
EQU PAR.PORT$PASS.TM TO 10;             * Time of last password validation
~PAR.SERR.DIM~
*CODE.SEGMENT: ?
DIM PAR.SERR(5)
~PAR.SERR.EQUATES~
*CODE.SEGMENT: PAR.SERR.EQUATES
*
* FILE 'PAR.SERR' EQUATES - GENERATED 10:25:36  19 NOV 1991
EQU PAR.SERR$INTERN.ERR TO PAR.SERR(1); * Internal (Application) Error No
EQU PAR.SERR$EXTERN.ERR TO PAR.SERR(2); * External (Operating System) error no
EQU PAR.SERR$EXTERN.TEXT TO PAR.SERR(3);* External (Operating sys) error text
EQU PAR.SERR$INTERN.TEXT TO PAR.SERR(4);* Internal (System Appl) text message
~PAR.SERR.VAR.EQUATES~
*CODE.SEGMENT: PAR.SERR.VAR.EQUATES
*
* FILE 'PAR.SERR' EQUATES - GENERATED 10:25:36  19 NOV 1991
EQU PAR.SERR$INTERN.ERR TO 1;           * Internal (Application) Error No
EQU PAR.SERR$EXTERN.ERR TO 2;           * External (Operating System) error no
EQU PAR.SERR$EXTERN.TEXT TO 3;          * External (Operating sys) error text
EQU PAR.SERR$INTERN.TEXT TO 4;          * Internal (System Appl) text message
~PKH.STANDARD.FUNCTIONS~
*CODE.SEGMENT: ?
EQU DOWN TO CHAR(10)
EQU FORWARD TO CHAR(6)
EQU NULL.CHARACTER TO CHAR(0)
EQU PICK.ESC TO CHAR(251)
EQU DELIMITER TO CHAR(254)
EQU VAL.STX TO CHAR(2)
EQU VAL.ETX TO CHAR(3)
EQU VAL.ACK TO CHAR(6)
EQU VAL.NAK TO CHAR(21)
EQU VAL.CAN TO CHAR(24)
EQU R5      TO 'R#5'
*EQU FLOW.BUFFER.SIZE TO 3000
EQU FLOW.BUFFER.SIZE TO 300
*
***TERM.TYPE="0"
***CALL HARMONY.GET.VISUALS(VISUALS,TERM.TYPE)
***UNDERLINE = VISUALS<10>
***REVERSE   = VISUALS<7>
***NORMAL    = VISUALS<4>
***EOL       = VISUALS<1>
***EOS       = VISUALS<2>
***CLS       = @(0,0):EOS
***NEW.PAGE=CHAR(12)
****%%PATCH%%vvvv # 18
*DEL 9
*%%PATCH%%^^^^ # 18
*#  
*#    INITIALIZATION
*#  
EQU THROWAWAY.CONNECTIVES TO " ID-SUPP THE FILE A ANY OR "
EQU OPERATORS TO " = EQ # NE <> >< < LT =< <= LE > GT => >= GE "
EQU OPERATOR.EQUIVALENTS TO " = = # # # # < < <= <= <=> > >= >= >="
*#
*#   INIT CAPTURE ESCAPE SEQUENCES
*#
CAPT.ON             = ESC:"Z":"d"
CAPT.OFF            = ESC:CHAR(1)
CAPT.RCRD.ON        = ESC:"Z":"Z"
CAPT.RCRD.OFF       = ESC:"Z":"v"
CAPT.PRNT.ON        = ESC:"Z":"3"
CAPT.PRNT.OFF       = ESC:"Z":"4"
CAPT.BGN.MSG        = ESC:CHAR(2)
CAPT.END.MSG        = ESC:CHAR(3)
CAPT.SUSPEND.MSG    = ESC:CHAR(4)
CAPT.RESTART.MSG    = ESC:CHAR(5)
CAPT.RQST.ACK       = ESC:"n"
CAPT.RQST.FILE      = ESC:"Z"
CAPT.RQST.ABORT     = ESC:"Q"
*#
~PL.DIM~
*CODE.SEGMENT: ?
DIM PL(10)
~PRC.DIM~
*CODE.SEGMENT: ?
DIM PRC(10)
~PRC.EQUATES~
*CODE.SEGMENT: ?
* FILE 'PRC' EQUATES - GENERATED 20:18:31  06 MAY 1984
EQU PRC$DATE TO PRC(1);                 * DATE OF CONTACT
EQU PRC$TIME TO PRC(2);                 * TIME OF CONTACT
EQU PRC$CONTACT.TYPE TO PRC(3);         * TYPE OF CONTACT TRANSACTION
EQU PRC$CONTACT.DOCUMENT TO PRC(4);     * CONTACT DOCUMENT ACCT.FILE.PRIMARY-KEY.SECONDARY-KEY
EQU PRC$CONTACT.TEXT TO PRC(5);         * CONTACT DESCRIPTIVE TEXT INFORMATION
~PRINTER.INCL.CLOSE~
*CODE.SEGMENT: PRINTER.INCL.CLOSE
*
* PROGRAM:           PRINTER.CLOSE
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       CLOSES PRINTER
*
* ULT ONLY
PRINTER CLOSE
LPT.STAT = FALSE
*
~PRINTER.INCL.OFF~
*CODE.SEGMENT: PRINTER.INCL.OFF
*
* PROGRAM:           PRINTER.OFF
* COMPANY:           AXIOFF COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       TURNS PRINTER OFF
*
* ULT ONLY
PRINTER OFF
LPT.STAT = FALSE
*
~PRINTER.INCL.ON~
*CODE.SEGMENT: PRINTER.INCL.ON
*
* PROGRAM:           PRINTER.ON
* COMPANY:           AXION COMPUTER SYSTEMS LTD.
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
* DESCRIPTION:       TURNS PRINTER ON
*
* ULT ONLY
PRINTER ON
LPT.STAT = FALSE
*
~PRJ.DIM~
*CODE.SEGMENT: ?
DIM PRJ(20)
~PRJ.EQUATES~
*CODE.SEGMENT: ?
* FILE 'PRJ' EQUATES - GENERATED 11:50:47  14 SEP 1984
EQU PRJ$DESCRIPTION TO PRJ(1);          * FUNCTION DESCRIPTION
EQU PRJ$COMMENTS, NOTES, CHANGES,  TO PR* COMMENTS, NOTES, CHANGES, ...
EQU PRJ$PH TO PRJ(3);                   * DEVELOPMENT PHASE IDENTIFIER
EQU PRJ$SPEC TO PRJ(4);                 * SPECIFICATIONS REQUIRED? (Y/BLANK)
EQU PRJ$SPEC.DATE TO PRJ(5);            * SPECIFICATIONS COMPLETION DATE
EQU PRJ$DAYS TO PRJ(6);                 * ESTIMATED MAN DAYS TO COMPLETION
EQU PRJ$STATUS TO PRJ(7);               * FUNCTION STATUS
EQU PRJ$ASSIGN TO PRJ(8);               * ASSIGNED TO (INITIALS)
EQU PRJ$START.DATE TO PRJ(9);           * SCHEDULED PROGRAMMING START DATE
EQU PRJ$COMPL.DATE TO PRJ(10);          * PROGRAMMING COMPLETION DATE
EQU PRJ$DOC.DATE TO PRJ(11);            * DOCUMENTATION COMPLETION DATE
~PRN.DIM~
*CODE.SEGMENT: ?
DIM PRN(10)
~PRN.EQUATES~
*CODE.SEGMENT: PRN.EQUATES
*
* FILE 'PRN' EQUATES - GENERATED 01:32:59  22 NOV 1991
*
*  Parnell Family Tree
*
*
EQU PRN$NAME TO PRN(1);                 * 
EQU PRN$MID.NAME TO PRN(2);             * 
EQU PRN$FST.NAME TO PRN(3);             * 
EQU PRN$SEX TO PRN(4);                  * 
EQU PRN$CHILDREN TO PRN(5);             * 
EQU PRN$CHILD.SEX TO PRN(6);            * 
EQU PRN$BIRTH.DAY TO PRN(7);            * 
EQU PRN$CHILD.MNAME TO PRN(8);          * 
EQU PRN$CHILD.NAME TO PRN(9);           * 
EQU PRN$CHILD.BDAY TO PRN(10);          * 
~PRN.VAR.EQUATES~
*CODE.SEGMENT: PRN.VAR.EQUATES
*
* FILE 'PRN' EQUATES - GENERATED 01:32:59  22 NOV 1991
*
*  Parnell Family Tree
*
*
EQU PRN$NAME TO 1;                      * 
EQU PRN$MID.NAME TO 2;                  * 
EQU PRN$FST.NAME TO 3;                  * 
EQU PRN$SEX TO 4;                       * 
EQU PRN$CHILDREN TO 5;                  * 
EQU PRN$CHILD.SEX TO 6;                 * 
EQU PRN$BIRTH.DAY TO 7;                 * 
EQU PRN$CHILD.MNAME TO 8;               * 
EQU PRN$CHILD.NAME TO 9;                * 
EQU PRN$CHILD.BDAY TO 10;               * 
~PROD.DIM~
*CODE.SEGMENT: ?
DIM PROD(20)
~PROD.EQUATES~
*CODE.SEGMENT: ?
* FILE 'PROD' EQUATES - GENERATED 14:45:59  05 JUN 1988
EQU PROD$CO TO PROD(1);                 * 
EQU PROD$FR TO PROD(2);                 * 
EQU PROD$ITM TO PROD(3);                * 
EQU PROD$ITMNO TO PROD(4);              * 
EQU PROD$DESC TO PROD(5);               * 
EQU PROD$CLASS TO PROD(6);              * 
EQU PROD$MONTHLY TO PROD(7);            * 
EQU PROD$QTRLY TO PROD(8);              * 
EQU PROD$SEMI.AN TO PROD(9);            * 
EQU PROD$ANNUAL TO PROD(10);            * 
EQU PROD$INSTALL TO PROD(11);           * 
EQU PROD$DEP TO PROD(12);               * 
EQU PROD$SPRC TO PROD(13);              * 
~PRP.DIM~
*CODE.SEGMENT: ?
DIM PRP(30)
~PRP.EQUATES~
*CODE.SEGMENT: ?
* FILE 'PRP' EQUATES - GENERATED 12:27:47  14 SEP 1984
EQU PRP$STATE.PROV TO PRP(1);           * ST/PRV
EQU PRP$COMPANY TO PRP(2);              * CABLE COMPANY NAME
EQU PRP$ADDRESS TO PRP(3);              * MAILING ADDRESS
EQU PRP$PCODE TO PRP(4);                * PZ.CODE
EQU PRP$COUNTRY TO PRP(5);              * CTY
EQU PRP$CONTACT TO PRP(6);              * CABLE COMPANY CONTACTS
EQU PRP$TITLE TO PRP(7);                * CONTACT TITLES
EQU PRP$SUBS TO PRP(8);                 * SUBS
EQU PRP$HOMES.PASSED TO PRP(9);         * PASSED
EQU PRP$HOMES.IN TO PRP(10);            * HOM.IN
EQU PRP$POP TO PRP(11);                 * POP
EQU PRP$PAY.SUBS TO PRP(12);            * PAYS
EQU PRP$OWNERSHIP TO PRP(13);           * O.C
EQU PRP$MSO TO PRP(14);                 * MSO.ID
EQU PRP$COMPETITOR TO PRP(15);          * CC
EQU PRP$TYPE TO PRP(16);                * CT
EQU PRP$SYSTEM.STATUS TO PRP(17);       * S.STAT
EQU PRP$START.DATE TO PRP(21);          * START.DATE
EQU PRP$COMMENTS TO PRP(22);            * COMMENTS
EQU PRP$PHONE TO PRP(23);               * PHONE NO.
EQU PRP$CONTACT.FLAG TO PRP(24);        * CONTACT FLAG
EQU PRP$COMP.CONTACT.FLAG TO PRP(25);   * COMP. CONTACT FLAG
EQU PRP$INTEREST.RATE TO PRP(26);       * ANNUAL INTEREST RATE FOR COST OF CREDIT
~PTR.DIM~
*CODE.SEGMENT: ?
DIM PTR(20)
~PTR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'PTR' EQUATES - GENERATED 11:14:55  27 APR 1984
EQU PTR$EFF.DATES TO PTR(1);            * EFFECTIVE DATE OF TRANSACTION
EQU PTR$ENTRY.DATES TO PTR(2);          * SYSTEM ENTRY DATE OF TRANSACTION
EQU PTR$ENTRY.PERIODS TO PTR(3);        * ACCOUNTING PERIOD WHEN ENTERED (YYMM)
EQU PTR$TYPES TO PTR(4);                * TRANSACTION TYPE
EQU PTR$REFS TO PTR(5);                 * TRANSACTION REFERENCE
EQU PTR$TOTAL.AMTS TO PTR(6);           * TOTAL AMOUNT OF TRANSACTION
EQU PTR$DESCS TO PTR(7);                * TRANSACTION DESCRIPTION
EQU PTR$SVC.TYPES TO PTR(8);            * TYPE OF SERVICE PROVIDED
EQU PTR$SVC.QNTYS TO PTR(9);            * QUANTITY OF SERVICE
EQU PTR$SVC.AMTS TO PTR(10);            * AMOUNT BILLED FOR SERVICE
EQU PTR$SVC.FROM.DATES TO PTR(11);      * START DATE FOR SERVICE BILLED
EQU PTR$SVC.TO.DATES TO PTR(12);        * END DATE FOR SERVICE BILLED
~PVE.DIM~
*CODE.SEGMENT: PVE.DIM
*
DIM PVE(15)
~PVE.EQUATES~
*CODE.SEGMENT: PVE.EQUATES
*
* FILE 'PVE' EQUATES - GENERATED 19:21:28  03 JUL 1994
EQU PVE$PVM.ID TO PVE(1);               * The Event Master for this Event Number.
EQU PVE$PROGMO TO PVE(2);               * The YY and MM the event is shown in.
EQU PVE$CH.CODE TO PVE(3);              * The Channel Code for cablecasting.
EQU PVE$RATE.CL TO PVE(4);              * The Rate Class for this event
EQU PVE$RATE.CL.SUB TO PVE(5);          * The optional rate sub class.
EQU PVE$DT TO PVE(6);                   * The show date of this event number.
EQU PVE$TM TO PVE(7);                   * The Show Time of this Event Number
EQU PVE$DUR TO PVE(8);                  * The duration includint any filler.
EQU PVE$DOWNLOADED TO PVE(9);           * Y indicates downloaded to the POC.
EQU PVE$DLL.ERR TO PVE(10);             * STD error from AI.HANDLER
EQU PVE$PURGE.DT TO PVE(11);            * THE PURGE DATE OF THE EVENT DETAIL
~PVE.VAR.EQUATES~
*CODE.SEGMENT: PVE.VAR.EQUATES
*
* FILE 'PVE' EQUATES - GENERATED 19:21:28  03 JUL 1994
EQU PVE$PVM.ID TO 1;                    * The Event Master for this Event Number.
EQU PVE$PROGMO TO 2;                    * The YY and MM the event is shown in.
EQU PVE$CH.CODE TO 3;                   * The Channel Code for cablecasting.
EQU PVE$RATE.CL TO 4;                   * The Rate Class for this event
EQU PVE$RATE.CL.SUB TO 5;               * The optional rate sub class.
EQU PVE$DT TO 6;                        * The show date of this event number.
EQU PVE$TM TO 7;                        * The Show Time of this Event Number
EQU PVE$DUR TO 8;                       * The duration includint any filler.
EQU PVE$DOWNLOADED TO 9;                * Y indicates downloaded to the POC.
EQU PVE$DLL.ERR TO 10;                  * STD error from AI.HANDLER
EQU PVE$PURGE.DT TO 11;                 * THE PURGE DATE OF THE EVENT DETAIL
~PVM.DIM~
*CODE.SEGMENT: PVM.DIM
*
DIM PVM(30)
~PVM.EQUATES~
*CODE.SEGMENT: PVM.EQUATES
*
* FILE 'PVM' EQUATES - GENERATED 19:04:04  03 JUL 1994
EQU PVM$PROGMO TO PVM(1);               * The month the event will be shown.
EQU PVM$DESC TO PVM(2);                 * PPV event description
EQU PVM$DISTR TO PVM(3);                * The Distributor/Studio of the Event
EQU PVM$STUDIO TO PVM(4);               * The optional Studio supplying the Event
EQU PVM$DEBUT.DT TO PVM(5);             * The first showing date of the event
EQU PVM$PURGE.DT TO PVM(6);             * The earliest date to purge the Event.
EQU PVM$CL TO PVM(7);                   * The Classification for the event
EQU PVM$PROG.CL TO PVM(8);              * The Program classification code
EQU PVM$MRKT.CL TO PVM(9);              * The Marketing classification code
EQU PVM$RATE.CL TO PVM(10);             * The Rate Classification of the event
EQU PVM$RATE.CL.SUB TO PVM(11);         * The Rate Sub Class of the event
EQU PVM$RUN.TM TO PVM(12);              * The running time of the event
EQU PVM$DUR TO PVM(13);                 * The duration including any filler.
EQU PVM$STARS TO PVM(14);               * The star rating of the event
EQU PVM$RATING TO PVM(15);              * The Industry Rating of the event
EQU PVM$CH.CODE TO PVM(16);             * The Channel Code for cablecasting
EQU PVM$RSVD17 TO PVM(17);              * Reserved
EQU PVM$PVE.DT TO PVM(18);              * The event show dates
EQU PVM$PVE.TM TO PVM(19);              * The show times of the event
EQU PVM$PVE.DUR TO PVM(20);             * DURATION OF THE EVENT
EQU PVM$PVE.AI.CODES TO PVM(21);        * THE AI OF THE CORRESPONDING EVENT NUM.
EQU PVM$EVENT.NUMS TO PVM(22);          * The Event No. of each showing.
EQU PVM$PVE.RATE.CL TO PVM(23);         * The Rate Class for the Event Detail
EQU PVM$PVE.RATE.CL.SUB TO PVM(24);     * Reserved
EQU PVM$VCR.CODE TO PVM(25);            * 
EQU PVM$GUIDE.SHORT TO PVM(26);         * 
EQU PVM$GUIDE.PARA TO PVM(27);          * Long description of the Event Detail
~PVM.VAR.EQUATES~
*CODE.SEGMENT: PVM.VAR.EQUATES
*
* FILE 'PVM' EQUATES - GENERATED 19:04:04  03 JUL 1994
EQU PVM$PROGMO TO 1;                    * The month the event will be shown.
EQU PVM$DESC TO 2;                      * PPV event description
EQU PVM$DISTR TO 3;                     * The Distributor/Studio of the Event
EQU PVM$STUDIO TO 4;                    * The optional Studio supplying the Event
EQU PVM$DEBUT.DT TO 5;                  * The first showing date of the event
EQU PVM$PURGE.DT TO 6;                  * The earliest date to purge the Event.
EQU PVM$CL TO 7;                        * The Classification for the event
EQU PVM$PROG.CL TO 8;                   * The Program classification code
EQU PVM$MRKT.CL TO 9;                   * The Marketing classification code
EQU PVM$RATE.CL TO 10;                  * The Rate Classification of the event
EQU PVM$RATE.CL.SUB TO 11;              * The Rate Sub Class of the event
EQU PVM$RUN.TM TO 12;                   * The running time of the event
EQU PVM$DUR TO 13;                      * The duration including any filler.
EQU PVM$STARS TO 14;                    * The star rating of the event
EQU PVM$RATING TO 15;                   * The Industry Rating of the event
EQU PVM$CH.CODE TO 16;                  * The Channel Code for cablecasting
EQU PVM$RSVD17 TO 17;                   * Reserved
EQU PVM$PVE.DT TO 18;                   * The event show dates
EQU PVM$PVE.TM TO 19;                   * The show times of the event
EQU PVM$PVE.DUR TO 20;                  * DURATION OF THE EVENT
EQU PVM$PVE.AI.CODES TO 21;             * THE AI OF THE CORRESPONDING EVENT NUM.
EQU PVM$EVENT.NUMS TO 22;               * The Event No. of each showing.
EQU PVM$PVE.RATE.CL TO 23;              * The Rate Class for the Event Detail
EQU PVM$PVE.RATE.CL.SUB TO 24;          * Reserved
EQU PVM$VCR.CODE TO 25;                 * 
EQU PVM$GUIDE.SHORT TO 26;              * 
EQU PVM$GUIDE.PARA TO 27;               * Long description of the Event Detail
~REPORT.HEADER~
*CODE.SEGMENT:   REPORT.HEADER
* FOR USE BY RLIST, RECALL AND ENGLISH
*
REPORT.HEADER = ("'D'   ":(SPACE(50-LEN(CO.NAME)/2+.5):CO.NAME) "L#100":"      Page 'P'") "L#130":" 'L' "
REPORT.TITLE = (SPACE(65-LEN(REPORT.TITLE)/2):REPORT.TITLE) "L#130":"'L'"
*
~REV.DIM~
*CODE.SEGMENT: ?
DIM REV(20)
~REV.EQUATES~
*CODE.SEGMENT: ?
* FILE 'REV' EQUATES - GENERATED 10:46:31  29 JUN 1984
EQU REV$SERVICES TO REV(1);             * SERVICE ID
EQU REV$PRIOR.REV.AMTS TO REV(2);       * PRIOR PERIOD REVENUE AMOUNT
EQU REV$CURR.REV.AMTS TO REV(3);        * CURRENT PERIOD REVENUE AMOUNT
EQU REV$FUTURE.REV.AMTS TO REV(4);      * FUTURE PERIOD REVENUE AMOUNTS BY PERIOD
EQU REV$BILL.FREQ.COUNTS TO REV(5);     * COUNT OF BILL FREQ. BY SERVICE
EQU REV$BALANCE TO REV(6);              * BALANCE OF ACCOUNT
EQU REV$AGED.AMTS TO REV(7);            * AGED AMOUNTS
EQU REV$AMTS.BY.TYPE TO REV(8);         * AGED AMOUNTS
EQU REV$COUNTS.BY.TYPE TO REV(9);       * AGED COUNTS
EQU REV$ADVANCE.TRANS.AMT TO REV(10);   * FUTURE PERIODS TRANSACTIONS AMOUNT
EQU REV$DEPOSIT.AMT TO REV(11);         * DEPOSIT AMOUNT
EQU REV$DEPOSIT.TAX TO REV(12);         * DEPOSIT TAX
~RPT.ADD.DIM~
*CODE.SEGMENT: ?
DIM RPT(10)
~RPT.ADD.EQUATES~
*CODE.SEGMENT: ?
EQUATE RPT$ADD.DWELL.TYPE TO RPT(1)
EQUATE RPT$ADD.STATUS TO RPT(2)
EQUATE RPT$ADD.COUNT TO RPT(3)
EQUATE RPT$ADD.HOTS TO RPT(4)
EQUATE RPT$ADD.WIRED TO RPT(5)
EQUATE RPT$ADD.UPDATE.DATE TO RPT(6)
~RPT.DIM~
DIM RPT(10)
~RPT.EQUATES~
*CODE.SEGMENT: ?
EQUATE RTP$ADD.DWELL.TYPE TO RPT(1)
EQUATE RPT$ADD.STATUS TO RPT(2)
EQUATE RPT$COUNT TO RPT(3)
EQUATE RPT$HOTS TO RPT(4)
EQUATE RPT$WIRED TO RPT(5)
EQUATE RPT$UPDATE.DATE(6)
~RPT.PPV.DIM~
DIM RPT(10)
~RPT.PPV.EQUATES~
*CODE SEGMENT: ?
EQUATE RPT$UPDATE.PERIOD TO RPT(1); *        DATE OF LAST REPORTING UPDATE
EQUATE RPT$EVENTS TO RPT(2); *               UPDATED EVENT CODES
EQUATE RPT$PRICES TO RPT(3); *               RETAIL PRICES OF UPDATED BUYS
EQUATE RPT$BUYS TO RPT(4); *                 NUMBER OF UPDATED BUYS
EQUATE RPT$REVERSALS TO RPT(5); *            NUMBER OF UPDATED REVERSALS
EQUATE RPT$CURR.EVENTS TO RPT(6); *          UNREPORTED EVENT CODES
EQUATE RPT$CURR.PRICES TO RPT(7); *          PRICES OF UNREPORTED BUYS
EQUATE RPT$CURR.BUYS TO RPT(8); *            NUMBER "       "      "
EQUATE RPT$CURR.REVERSALS TO RPT(9); *         "    "       "     REVERSALS
~RPT.SVC.DIM~
*CODE.SEGMENT: ?
DIM RPT(10)
~RPT.SVC.EQUATES~
*CODE.SEGMENT: ?
EQUATE RPT$SVC.SERVICE TO RPT(1)
EQUATE RPT$SVC.SERVICE.QNTYS TO RPT(2)
EQUATE RPT$SVC.SERVICE.COUNTS TO RPT(3)
EQUATE RPT$SVC.RATES TO RPT(4)
EQUATE RPT$SVC.RATE.COUNTS TO RPT(5)
EQUATE RPT$SVC.UPDATE.DATE TO RPT(6)
EQUATE RPT$SVC.NO.BASIC TO RPT(7)
~RTE.DIM~
DIM RTE(10)
~RTE.EQUATES~
*CODE.SEGMENT: RTE.EQUATES
*
* FILE 'RTE' EQUATES - GENERATED 12:22:12  18 APR 1993
EQU RTE$EFF.DATES TO RTE(1);            * Effective Date for Rate
EQU RTE$QNTYS TO RTE(2);                * Quantity of Service
EQU RTE$AMTS TO RTE(3);                 * Amount Charged for Service
EQU RTE$TAX.NAMES TO RTE(4);            * Taxes for a Rate
EQU RTE$AREAS TO RTE(5);                * Rate Areas for tax
EQU RTE$AREA.TAX.NAMES TO RTE(6);       * Taxes for this Area
EQU RTE$RSVD.7 TO RTE(7);               * RESERVED
EQU RTE$RSVD.8 TO RTE(8);               * RESERVED
EQU RTE$RSVD.9 TO RTE(9);               * RESERVED
~RTE.VAR.EQUATES~
*CODE.SEGMENT: RTE.VAR.EQUATES
*
* FILE 'RTE' EQUATES - GENERATED 12:22:12  18 APR 1993
EQU RTE$EFF.DATES TO 1;                 * Effective Date for Rate
EQU RTE$QNTYS TO 2;                     * Quantity of Service
EQU RTE$AMTS TO 3;                      * Amount Charged for Service
EQU RTE$TAX.NAMES TO 4;                 * Taxes for a Rate
EQU RTE$AREAS TO 5;                     * Rate Areas for tax
EQU RTE$AREA.TAX.NAMES TO 6;            * Taxes for this Area
EQU RTE$RSVD.7 TO 7;                    * RESERVED
EQU RTE$RSVD.8 TO 8;                    * RESERVED
EQU RTE$RSVD.9 TO 9;                    * RESERVED
~SAVE.ACG.DIM~
*CODE.SEGMENT: ?
DIM SAVE.ACG(10)
~SAVE.ACG.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.ACG' EQUATES - GENERATED 08:42:08  09 APR 1984
EQU SAVE.ACG$SOURCES TO SAVE.ACG(1);              * SOURCE OF TRANSACTION
EQU SAVE.ACG$TRANS.TYPES TO SAVE.ACG(2);          * TRANSACTION TYPE
EQU SAVE.ACG$AMOUNTS TO SAVE.ACG(3);              * TRANSACTION AMOUNT
EQU SAVE.ACG$COUNTS TO SAVE.ACG(4);               * TRANSACTION COUNT
EQU SAVE.ACG$POSTING.DATE TO SAVE.ACG(5);         * DATE OF POSTING TO MONTHLY TOTALS
~SAVE.ACT.DIM~
*CODE.SEGMENT: ?
DIM SAVE.ACT(50)
~SAVE.ACT.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.ACT' EQUATES - GENERATED 14:05:52  30 DEC 1991
EQU SAVE.ACT$ADD.ID TO SAVE.ACT(1);     * ADDRESS.PTR
EQU SAVE.ACT$STAT TO SAVE.ACT(2);       * B.STAT
EQU SAVE.ACT$PEND.ADD.ID TO SAVE.ACT(3);* PEND.ADDR
EQU SAVE.ACT$PEND.STAT TO SAVE.ACT(4);  * P.ST
EQU SAVE.ACT$CUS.NAME TO SAVE.ACT(5);   * CUSTOMER.NAME
EQU SAVE.ACT$ALT.NAME TO SAVE.ACT(6);   * ALTERNATE.NAME
EQU SAVE.ACT$BILL.NAME TO SAVE.ACT(7);  * BILL.TO.NAME
EQU SAVE.ACT$BILL.ADDR TO SAVE.ACT(8);  * BILL.TO.ADDRESS
EQU SAVE.ACT$BILL.EFF.DATE TO SAVE.ACT(9);   * B.EFF.DATE
EQU SAVE.ACT$TEL.NUMS TO SAVE.ACT(10);       * PHONE.NUMS
EQU SAVE.ACT$ADDTL.DATA TO SAVE.ACT(11);     * ADDITIONAL.DATA
EQU SAVE.ACT$LAST.NOTICE.DATE TO SAVE.ACT(12);    * DATE OF LAST ANNUAL NOTICE
EQU SAVE.ACT$LAST.LATE.DATE TO SAVE.ACT(13);      * Last date for apply late charges
EQU SAVE.ACT$SOLICITATION TO SAVE.ACT(14);        * SOLICITATION ALLOWED OR NOT ALLOWED
EQU SAVE.ACT$RATE.TYPE TO SAVE.ACT(15);           * RATE
EQU SAVE.ACT$PAY.METHOD TO SAVE.ACT(16);          * PMT
EQU SAVE.ACT$BILL.DAY TO SAVE.ACT(17);            * DAY
EQU SAVE.ACT$AGED.AMTS TO SAVE.ACT(18);           * AGED AMOUNTS
EQU SAVE.ACT$BALANCE TO SAVE.ACT(19);             * BALANCE.
EQU SAVE.ACT$LAST.BILL.DATE TO SAVE.ACT(20);      * LAST BILG
EQU SAVE.ACT$LAST.STMT.DATE TO SAVE.ACT(21);      * LAST STMT
EQU SAVE.ACT$LAST.AGING.DATE TO SAVE.ACT(22);     * LAST AGED
EQU SAVE.ACT$CONNECT.DATE TO SAVE.ACT(23);        * STMT RUN
EQU SAVE.ACT$CREDIT.STATUS TO SAVE.ACT(24);       * CR
EQU SAVE.ACT$DISC.DATE TO SAVE.ACT(25);           * DISC DATE
EQU SAVE.ACT$DISC.REASON TO SAVE.ACT(26);         * D.R
EQU SAVE.ACT$DEPOSIT.AMT TO SAVE.ACT(27);         * DEP.AMT
EQU SAVE.ACT$DEPOSIT.TAX TO SAVE.ACT(28);         * DEP.TAX
EQU SAVE.ACT$EFT.BILLING TO SAVE.ACT(29);         * IS SERVICE PAYABLE BY EFT?
EQU SAVE.ACT$SERVICES TO SAVE.ACT(30);            * 10
EQU SAVE.ACT$QNTYS TO SAVE.ACT(31);               * QTY
EQU SAVE.ACT$BILL.FREQS TO SAVE.ACT(32);          * BF
EQU SAVE.ACT$BILL.FROM.DATES TO SAVE.ACT(33);     * BILL.FROM
EQU SAVE.ACT$BILL.TO.DATES TO SAVE.ACT(34);       * BILL.TO
EQU SAVE.ACT$DVC.NUMS TO SAVE.ACT(35);            * SERIAL.NUMBER
EQU SAVE.ACT$SVC.LOCATIONS TO SAVE.ACT(36);       * LOC
EQU SAVE.ACT$SVC.START.DATES TO SAVE.ACT(37);     * SERV START
EQU SAVE.ACT$SALESMAN TO SAVE.ACT(38);            * SALESMAN WHO SOLD THE SERVICE
EQU SAVE.ACT$SVC.CHG.DATES TO SAVE.ACT(39);       * SERV CHANGE
EQU SAVE.ACT$RATE.QNTYS TO SAVE.ACT(40);          * OUTLETS
EQU SAVE.ACT$MTHLY.RATES TO SAVE.ACT(41);         * OUTLET RATE
EQU SAVE.ACT$TAX.NAMES TO SAVE.ACT(42);           * TAX
EQU SAVE.ACT$TAX.AMTS TO SAVE.ACT(43);            * TAX AMT.
EQU SAVE.ACT$EARNED.REV TO SAVE.ACT(44);          * EARNED REV FOR MONTH AT MONTH-END
EQU SAVE.ACT$PRIOR.PER.REV.AMTS TO SAVE.ACT(45);  * PRIOR.REV
EQU SAVE.ACT$BILLING.RUNS TO SAVE.ACT(46);        * BILL.RUN
EQU SAVE.ACT$PEND.WO.NUMS TO SAVE.ACT(47);        * PEND.WO
EQU SAVE.ACT$PO.BOX TO SAVE.ACT(48);              * PO BOX
EQU SAVE.ACT$STMT.MSG.NUM TO SAVE.ACT(49);        * MSG
EQU SAVE.ACT$MESSAGE TO SAVE.ACT(50);             * ACCOUNT.MESSAGE
~SAVE.ACT.VAR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.ACT' EQUATES (VARiables) - GENERATED 14:05:52  30 DEC 1991
EQU SAVE.ACT$ADD.ID TO 1;               * ADDRESS.PTR
EQU SAVE.ACT$STAT TO 2;                 * B.STAT
EQU SAVE.ACT$PEND.ADD.ID TO 3;          * PEND.ADDR
EQU SAVE.ACT$PEND.STAT TO 4;            * P.ST
EQU SAVE.ACT$CUS.NAME TO 5;             * CUSTOMER.NAME
EQU SAVE.ACT$ALT.NAME TO 6;             * ALTERNATE.NAME
EQU SAVE.ACT$BILL.NAME TO 7;            * BILL.TO.NAME
EQU SAVE.ACT$BILL.ADDR TO 8;            * BILL.TO.ADDRESS
EQU SAVE.ACT$BILL.EFF.DATE TO 9;        * B.EFF.DATE
EQU SAVE.ACT$TEL.NUMS TO 10;            * PHONE.NUMS
EQU SAVE.ACT$ADDTL.DATA TO 11;          * ADDITIONAL.DATA
EQU SAVE.ACT$LAST.NOTICE.DATE TO 12;    * DATE OF LAST ANNUAL NOTICE
EQU SAVE.ACT$LAST.LATE.DATE TO 13;      * Last date for apply late charges
EQU SAVE.ACT$SOLICITATION TO 14;        * SOLICITATION ALLOWED OR NOT ALLOWED
EQU SAVE.ACT$RATE.TYPE TO 15;           * RATE
EQU SAVE.ACT$PAY.METHOD TO 16;          * PMT
EQU SAVE.ACT$BILL.DAY TO 17;            * DAY
EQU SAVE.ACT$AGED.AMTS TO 18;           * AGED AMOUNTS
EQU SAVE.ACT$BALANCE TO 19;             * BALANCE.
EQU SAVE.ACT$LAST.BILL.DATE TO 20;      * LAST BILG
EQU SAVE.ACT$LAST.STMT.DATE TO 21;      * LAST STMT
EQU SAVE.ACT$LAST.AGING.DATE TO 22;     * LAST AGED
EQU SAVE.ACT$CONNECT.DATE TO 23;        * STMT RUN
EQU SAVE.ACT$CREDIT.STATUS TO 24;       * CR
EQU SAVE.ACT$DISC.DATE TO 25;           * DISC DATE
EQU SAVE.ACT$DISC.REASON TO 26;         * D.R
EQU SAVE.ACT$DEPOSIT.AMT TO 27;         * DEP.AMT
EQU SAVE.ACT$DEPOSIT.TAX TO 28;         * DEP.TAX
EQU SAVE.ACT$EFT.BILLING TO 29;         * IS SERVICE PAYABLE BY EFT?
EQU SAVE.ACT$SERVICES TO 30;            * 10
EQU SAVE.ACT$QNTYS TO 31;               * QTY
EQU SAVE.ACT$BILL.FREQS TO 32;          * BF
EQU SAVE.ACT$BILL.FROM.DATES TO 33;     * BILL.FROM
EQU SAVE.ACT$BILL.TO.DATES TO 34;       * BILL.TO
EQU SAVE.ACT$DVC.NUMS TO 35;            * SERIAL.NUMBER
EQU SAVE.ACT$SVC.LOCATIONS TO 36;       * LOC
EQU SAVE.ACT$SVC.START.DATES TO 37;     * SERV START
EQU SAVE.ACT$SALESMAN TO 38;            * SALESMAN WHO SOLD THE SERVICE
EQU SAVE.ACT$SVC.CHG.DATES TO 39;       * SERV CHANGE
EQU SAVE.ACT$RATE.QNTYS TO 40;          * OUTLETS
EQU SAVE.ACT$MTHLY.RATES TO 41;         * OUTLET RATE
EQU SAVE.ACT$TAX.NAMES TO 42;           * TAX
EQU SAVE.ACT$TAX.AMTS TO 43;            * TAX AMT.
EQU SAVE.ACT$EARNED.REV TO 44;          * EARNED REV FOR MONTH AT MONTH-END
EQU SAVE.ACT$PRIOR.PER.REV.AMTS TO 45;  * PRIOR.REV
EQU SAVE.ACT$BILLING.RUNS TO 46;        * BILL.RUN
EQU SAVE.ACT$PEND.WO.NUMS TO 47;        * PEND.WO
EQU SAVE.ACT$PO.BOX TO 48;              * PO BOX
EQU SAVE.ACT$STMT.MSG.NUM TO 49;        * MSG
EQU SAVE.ACT$MESSAGE TO 50;             * ACCOUNT.MESSAGE
~SAVE.ADD.DIM~
*CODE.SEGMENT: ?
DIM SAVE.ADD(25)
~SAVE.ADD.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.ADD' EQUATES - GENERATED 12:25:56  15 APR 1991
EQU SAVE.ADD$MULT.APT.NUMS TO SAVE.ADD(1);        * STRING OF APT. NOS. AT THIS ADDRESS
EQU SAVE.ADD$ACT.IDS TO SAVE.ADD(2);              * CUSTOMER ACCOUNT NO.
EQU SAVE.ADD$ACT.FROM.DATES TO SAVE.ADD(3);       * ACCOUNT CONNECT DATE
EQU SAVE.ADD$ACT.TO.DATES TO SAVE.ADD(4);         * ACCOUNT DISCONNECT DATE
EQU SAVE.ADD$STAT TO SAVE.ADD(5);                 * ADDRESS SERVICE STATUS
EQU SAVE.ADD$POST.CODE TO SAVE.ADD(6);            * POSTAL/ZIP CODE OF ADDRESS
EQU SAVE.ADD$DWELLING.TYPE TO SAVE.ADD(7);        * TYPE OF DWELLING
EQU SAVE.ADD$DROP.TYPE TO SAVE.ADD(8);            * TYPE OF DROP
EQU SAVE.ADD$HOT.OUTLETS TO SAVE.ADD(9);          * NUMBER OF HOT OUTLETS AT ADDRESS
EQU SAVE.ADD$WIRED.OUTLETS TO SAVE.ADD(10);       * NUMBER OF OUTLETS WIRED AT ADDRESS
EQU SAVE.ADD$MESSAGE TO SAVE.ADD(11);             * DIRECTIONS TO THE ADDRESS
EQU SAVE.ADD$GEOGRAPHIC.DATA TO SAVE.ADD(12);     * GEOGRAPHIC DATA
EQU SAVE.ADD$BULK.ACT.ID TO SAVE.ADD(13);         * POINTER TO BULK ACCOUNT
EQU SAVE.ADD$CONF.WO.NUMS TO SAVE.ADD(14);        * CONFIRMED WORK ORDER NO.
EQU SAVE.ADD$WKO.TYPE TO SAVE.ADD(15);            * TYPE OF WORK ORDER
EQU SAVE.ADD$WKO.ACT.ID TO SAVE.ADD(16);          * ACCOUNT TO WHICH WORK ORDER APPLIED
EQU SAVE.ADD$WKO.EFF.DATE TO SAVE.ADD(17);        * EFFECTIVE DATE OF WORK ORDER
EQU SAVE.ADD$WKO.COMPL.DATE TO SAVE.ADD(18);      * COMPLETION DATE OF WORK ORDER
EQU SAVE.ADD$OUTLET.LOCATIONS TO SAVE.ADD(19);    * LOCATION OF OUTLET WITHIN ADDRESS
EQU SAVE.ADD$TECH.INFO TO SAVE.ADD(20);           * TECHNICAL INFORMATION FOR THE ADDRESS
EQU SAVE.ADD$DROP TO SAVE.ADD(21);                * DROP NUMBER
EQU SAVE.ADD$LINE TO SAVE.ADD(22);                * 
EQU SAVE.ADD$AIX.ID TO SAVE.ADD(23);              * SERIAL NUMBER OF THE DEVICE
EQU SAVE.ADD$AIX.LOCATION TO SAVE.ADD(24);        * LOCATION OF THE ADDRESS
~SAVE.ADD.VAR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.ADD' EQUATES (VARiables) - GENERATED 12:25:56  15 APR 1991
EQU SAVE.ADD$MULT.APT.NUMS TO 1;                  * STRING OF APT. NOS. AT THIS ADDRESS
EQU SAVE.ADD$ACT.IDS TO 2;                        * CUSTOMER ACCOUNT NO.
EQU SAVE.ADD$ACT.FROM.DATES TO 3;                 * ACCOUNT CONNECT DATE
EQU SAVE.ADD$ACT.TO.DATES TO 4;                   * ACCOUNT DISCONNECT DATE
EQU SAVE.ADD$STAT TO 5;                           * ADDRESS SERVICE STATUS
EQU SAVE.ADD$POST.CODE TO 6;                      * POSTAL/ZIP CODE OF ADDRESS
EQU SAVE.ADD$DWELLING.TYPE TO 7;                  * TYPE OF DWELLING
EQU SAVE.ADD$DROP.TYPE TO 8;                      * TYPE OF DROP
EQU SAVE.ADD$HOT.OUTLETS TO 9;                    * NUMBER OF HOT OUTLETS AT ADDRESS
EQU SAVE.ADD$WIRED.OUTLETS TO 10;                 * NUMBER OF OUTLETS WIRED AT ADDRESS
EQU SAVE.ADD$MESSAGE TO 11;                       * DIRECTIONS TO THE ADDRESS
EQU SAVE.ADD$GEOGRAPHIC.DATA TO 12;               * GEOGRAPHIC DATA
EQU SAVE.ADD$BULK.ACT.ID TO 13;                   * POINTER TO BULK ACCOUNT
EQU SAVE.ADD$CONF.WO.NUMS TO 14;                  * CONFIRMED WORK ORDER NO.
EQU SAVE.ADD$WKO.TYPE TO 15;                      * TYPE OF WORK ORDER
EQU SAVE.ADD$WKO.ACT.ID TO 16;                    * ACCOUNT TO WHICH WORK ORDER APPLIED
EQU SAVE.ADD$WKO.EFF.DATE TO 17;                  * EFFECTIVE DATE OF WORK ORDER
EQU SAVE.ADD$WKO.COMPL.DATE TO 18;                * COMPLETION DATE OF WORK ORDER
EQU SAVE.ADD$OUTLET.LOCATIONS TO 19;              * LOCATION OF OUTLET WITHIN ADDRESS
EQU SAVE.ADD$TECH.INFO TO 20;                     * TECHNICAL INFORMATION FOR THE ADDRESS
EQU SAVE.ADD$DROP TO 21;                          * DROP NUMBER
EQU SAVE.ADD$LINE TO 22;                          * 
EQU SAVE.ADD$AIX.ID TO 23;                        * SERIAL NUMBER OF THE DEVICE
EQU SAVE.ADD$AIX.LOCATION TO 24;                  * LOCATION OF THE ADDRESS
~SAVE.AIL.DIM~
*CODE.SEGMENT: ?
DIM SAVE.AIL(55)
~SAVE.AIX.DIM~
*CODE.SEGMENT: ?
DIM SAVE.AIX(30)
~SAVE.ATR.DIM~
*CODE.SEGMENT: ?
DIM SAVE.ATR(20)
~SAVE.ATR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.ATR' EQUATES - GENERATED 16:17:19  07 SEP 1984
EQU SAVE.ATR$EFF.DATES TO SAVE.ATR(1);            * EFFECTIVE DATE OF TRANSACTION
EQU SAVE.ATR$ENTRY.DATES TO SAVE.ATR(2);          * SYSTEM ENTRY DATE OF TRANSACTION
EQU SAVE.ATR$ENTRY.PERIODS TO SAVE.ATR(3);        * ACCOUNTING PERIOD WHEN ENTERED (YYMM)
EQU SAVE.ATR$TYPES TO SAVE.ATR(4);                * TRANSACTION TYPE
EQU SAVE.ATR$REFS TO SAVE.ATR(5);                 * TRANSACTION REFERENCE
EQU SAVE.ATR$TOTAL.AMTS TO SAVE.ATR(6);           * TOTAL AMOUNT OF TRANSACTION
EQU SAVE.ATR$DESCS TO SAVE.ATR(7);                * TRANSACTION DESCRIPTION
EQU SAVE.ATR$SVC.TYPES TO SAVE.ATR(8);            * TYPE OF SERVICE PROVIDED
EQU SAVE.ATR$SVC.QNTYS TO SAVE.ATR(9);            * QUANTITY OF SERVICE
EQU SAVE.ATR$SVC.AMTS TO SAVE.ATR(10);            * AMOUNT BILLED FOR SERVICE
EQU SAVE.ATR$SVC.FROM.DATES TO SAVE.ATR(11);      * START DATE FOR SERVICE BILLED
EQU SAVE.ATR$SVC.TO.DATES TO SAVE.ATR(12);        * END DATE FOR SERVICE BILLED
~SAVE.CNT.AIP.DIM~
*CODE.SEGMENT: ?
DIM SAVE.CNT.AIP(45)
~SAVE.COM.AIP.DIM~
*CODE.SEGMENT: SAVE.COM.AIP.DIM
*
DIM SAVE.COM.AIP(75)
~SAVE.SVC.DIM~
*CODE.SEGMENT: ?
DIM SAVE.SVC(20)
~SAVE.SVC.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.SVC' EQUATES - GENERATED 11:54:09  10 APR 1984
EQU SAVE.SVC$DESC TO SAVE.SVC(1);                 * DESCRIPTION OF SERVICE
EQU SAVE.SVC$BILL.FREQS TO SAVE.SVC(2);           * ALLOWED BILLING FREQUENCY
EQU SAVE.SVC$DVC.FUNCS TO SAVE.SVC(3);            * DEVICE FUNCTIONS REQUIRED FOR SERVICE
EQU SAVE.SVC$COMPONENTS TO SAVE.SVC(4);           * COMPONENT OF SERVICE
EQU SAVE.SVC$REVERTS.TO TO SAVE.SVC(5);           * SERVICE TO WHICH THIS SERVICE REVERTS
EQU SAVE.SVC$RATE.AREAS TO SAVE.SVC(6);           * AREAS FOR RATE AND TAX CALCULATION
EQU SAVE.SVC$TAX.NAMES TO SAVE.SVC(7);            * APPLICABLE TAX TABLES
EQU SAVE.SVC$PRICES TO SAVE.SVC(8);               * SELLING PRICE
EQU SAVE.SVC$BILL.METHOD TO SAVE.SVC(9);          * METHOD AND DAY OF BILLING
EQU SAVE.SVC$MONTH.END.DATES TO SAVE.SVC(10);     * MONTH END DATE FOR SERVICE COUNT
EQU SAVE.SVC$MONTH.END.QNTYS TO SAVE.SVC(11);     * MONTH END QUANTITY FOR SERVICE
EQU SAVE.SVC$MONTH.END.COUNT TO SAVE.SVC(12);     * MONTH END COUNT OF SERVICE
EQU SAVE.SVC$UNREPORTED.DATES TO SAVE.SVC(13);    * UNREPORTED SERVICE CHANGE DATES
EQU SAVE.SVC$UNREPORTED.QNTYS TO SAVE.SVC(14);    * UNREPORTED SERVICE QUANTITY CHANGE
EQU SAVE.SVC$UNREPORTED.STARTS TO SAVE.SVC(15);   * UNREPORTED START COUNT
EQU SAVE.SVC$UNREPORTED.STOPS TO SAVE.SVC(16);    * UNREPORTED STOP COUNT
EQU SAVE.SVC$REPORTED.DATES TO SAVE.SVC(17);      * LAST REPORTED SERVICE CHANGE DATES
EQU SAVE.SVC$REPORTED.QNTYS TO SAVE.SVC(18);      * LAST REPORTED SERVICE QUANTITY CHANGE
EQU SAVE.SVC$REPORTED.STARTS TO SAVE.SVC(19);     * LAST REPORTED START COUNT
EQU SAVE.SVC$REPORTED.STOPS TO SAVE.SVC(20);      * LAST REPORTED STOP COUNT
~SAVE.SVS.DIM~
*CODE.SEGMENT: ?
DIM SAVE.SVS(20)
~SAVE.SVS.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.SVS' EQUATES - GENERATED 10:38:23  23 NOV 1984
EQU SAVE.SVS$MONTH.END.DATES TO SAVE.SVS(1);      * MONTH END DATE FOR SERVICE COUNT
EQU SAVE.SVS$MONTH.END.QNTYS TO SAVE.SVS(2);      * MONTH END QUANTITY FOR SERVICE
EQU SAVE.SVS$MONTH.END.COUNT TO SAVE.SVS(3);      * MONTH END COUNT OF SERVICE
EQU SAVE.SVS$UNREPORTED.DATES TO SAVE.SVS(4);     * UNREPORTED SERVICE CHANGE DATES
EQU SAVE.SVS$UNREPORTED.QNTYS TO SAVE.SVS(5);     * UNREPORTED SERVICE QUANTITY CHANGE
EQU SAVE.SVS$UNREPORTED.STARTS TO SAVE.SVS(6);    * UNREPORTED START COUNT
EQU SAVE.SVS$UNREPORTED.STOPS TO SAVE.SVS(7);     * UNREPORTED STOP COUNT
EQU SAVE.SVS$REPORTED.DATES TO SAVE.SVS(8);       * LAST REPORTED SERVICE CHANGE DATES
EQU SAVE.SVS$REPORTED.QNTYS TO SAVE.SVS(9);       * LAST REPORTED SERVICE QUANTITY CHANGE
EQU SAVE.SVS$REPORTED.STARTS TO SAVE.SVS(10);     * LAST REPORTED START COUNT
EQU SAVE.SVS$REPORTED.STOPS TO SAVE.SVS(11);      * LAST REPORTED STOP COUNT
~SAVE.WKO.DIM~
*CODE.SEGMENT: ?
DIM SAVE.WKO(60)
~SAVE.WKO.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SAVE.WKO' EQUATES - GENERATED 16:14:42  30 DEC 1991
EQU SAVE.WKO$ACT.ID TO SAVE.WKO(1);     * TENANT ACCOUNT NO.
EQU SAVE.WKO$ADD.ID TO SAVE.WKO(2);     * ADDRESS ID
EQU SAVE.WKO$TFR.FROM.ADD.ID TO SAVE.WKO(3); * TFR. FROM ADDRESS ID
EQU SAVE.WKO$TYPE TO SAVE.WKO(4);            * WORK ORDER TYPE
EQU SAVE.WKO$STAT TO SAVE.WKO(5);            * WORK ORDER STATUS
EQU SAVE.WKO$SCH.DATE TO SAVE.WKO(6);        * SCHEDULED DATE
EQU SAVE.WKO$SCH.TIME TO SAVE.WKO(7);        * SCHEDULED TIME
EQU SAVE.WKO$SCH.POINTS TO SAVE.WKO(8);      * SCHEDULE POINTS
EQU SAVE.WKO$SCH.TYPE TO SAVE.WKO(9);        * SCHEDULE TYPE
EQU SAVE.WKO$SCH.OVERBOOK TO SAVE.WKO(10);   * SCHEDULE OVERBOOKED FLAG
EQU SAVE.WKO$COMPL.DATE TO SAVE.WKO(11);     * COMPLETION DATE
EQU SAVE.WKO$OPERATOR TO SAVE.WKO(12);       * OPERATOR ENTERING WORK ORDER
EQU SAVE.WKO$INSTALLER TO SAVE.WKO(13);      * INSTALLER COMPLETING WORK ORDER
EQU SAVE.WKO$SALESMAN TO SAVE.WKO(14);       * SALESMAN WHO SOLD W/O SERVICES
EQU SAVE.WKO$DVC.COLLECT.INFO TO SAVE.WKO(15);    * DEVICE COLLECTION INFORMATION
EQU SAVE.WKO$DVC.PRINT.DATE TO SAVE.WKO(16);      * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU SAVE.WKO$DVC.REPRINT.DATE TO SAVE.WKO(17);    * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU SAVE.WKO$PRINT.DATE TO SAVE.WKO(18);          * DATE WORK ORDER WAS FIRST PRINTED
EQU SAVE.WKO$REPRINT.DATE TO SAVE.WKO(19);        * DATE WORK ORDER WAS LAST REPRINTED
EQU SAVE.WKO$DEPOSIT.TAX TO SAVE.WKO(20);         * TAX ON THE DEPOSIT AMOUNT
EQU SAVE.WKO$ENTRY.DATE TO SAVE.WKO(21);          * DATE WORK ORDER WAS ENTERED
EQU SAVE.WKO$EFF.DATE TO SAVE.WKO(22);            * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU SAVE.WKO$DEPOSIT.AMT TO SAVE.WKO(23);         * AMOUNT OF DEPOSIT ADJUSTMENT
EQU SAVE.WKO$TOTAL.AMT TO SAVE.WKO(24);           * TOTAL AMOUNT BILLED ON WORK ORDER
EQU SAVE.WKO$ACTIVS TO SAVE.WKO(25);              * WORK ORDER ACTIVITY
EQU SAVE.WKO$ACTIV.QNTYS TO SAVE.WKO(26);         * QUANTITY FOR THIS ACTIVITY
EQU SAVE.WKO$ACTIV.AMTS TO SAVE.WKO(27);          * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU SAVE.WKO$ACTIV.SERVICES TO SAVE.WKO(28);      * SERVICE PROVIDED FROM THIS ACTIVITY
EQU SAVE.WKO$SVC.FREQS TO SAVE.WKO(29);           * BILL FREQUENCY OF SERVICE
EQU SAVE.WKO$SVC.LOCATIONS TO SAVE.WKO(30);       * LOCATION OF OUTLET
EQU SAVE.WKO$DVC.IDS TO SAVE.WKO(31);             * DEVICE NO.
EQU SAVE.WKO$DVC.ACTIV.STATS TO SAVE.WKO(32);     * STATUS OF DEVICE ACTIVITY
EQU SAVE.WKO$MAINT.CODES TO SAVE.WKO(33);         * Service Order Maintenance codes
EQU SAVE.WKO$OUTCOME.CODES TO SAVE.WKO(34);       * Service Order Outcome Codes
EQU SAVE.WKO$BILL.SERVICES TO SAVE.WKO(35);       * TYPE OF SERVICE BILLED
EQU SAVE.WKO$BILL.QNTYS TO SAVE.WKO(36);          * QUANTITY OF SERVICE BILLED
EQU SAVE.WKO$BILL.FROM.DATES TO SAVE.WKO(37);     * DATE FROM WHICH SERVICE IS BILLED
EQU SAVE.WKO$BILL.TO.DATES TO SAVE.WKO(38);       * DATE TO WHICH SERVICE IS BILLED
EQU SAVE.WKO$BILL.RENT.AMTS TO SAVE.WKO(39);      * RENTAL AMOUNT
EQU SAVE.WKO$BILL.OTHER.AMTS TO SAVE.WKO(40);     * NON-RENTAL AMOUNT
EQU SAVE.WKO$BILL.FREQS TO SAVE.WKO(41);          * BILL FREQUENCY FOR RATE CALC.
EQU SAVE.WKO$BILL.DVC.NUMS TO SAVE.WKO(42);       * DEVICE NO. FOR BILLING OF SERVICE
EQU SAVE.WKO$BILL.SVC.LOCATIONS TO SAVE.WKO(43);  * LOCATION OF BILLED SERVICE
EQU SAVE.WKO$RATE.EFF.DATES TO SAVE.WKO(44);      * EFF. DATE FOR RATE USED
EQU SAVE.WKO$RATE.QNTYS TO SAVE.WKO(45);          * NO. OF OUTLETS AT RATE
EQU SAVE.WKO$MTHLY.RATES TO SAVE.WKO(46);         * RATE PER OUTLET PER MONTH
EQU SAVE.WKO$TAX.NAMES TO SAVE.WKO(47);           * NAME OF TAX
EQU SAVE.WKO$TAX.AMTS TO SAVE.WKO(48);            * AMOUNT OF TAX
EQU SAVE.WKO$PRINT.SOURCE TO SAVE.WKO(49);        * Printed by System or out of GENIE
EQU SAVE.WKO$MESSAGE TO SAVE.WKO(50);             * WORK ORDER MESSAGE
EQU SAVE.WKO$DISC.REASON TO SAVE.WKO(51);         * Reason the subscriber was disconnected
EQU SAVE.WKO$SCH.REQUEST TO SAVE.WKO(52);         * Scheduled date is at sub's request.
EQU SAVE.WKO$TROUBLE.CLASS TO SAVE.WKO(53);       * Trouble classification code
EQU SAVE.WKO$TRUCK.ROLL TO SAVE.WKO(54);          * WAS A TRUCK ROLLED FOR THE WKO?
EQU SAVE.WKO$CONF.DATE.TM TO SAVE.WKO(55);        * The WKO confirmation date and time.
EQU SAVE.WKO$REQUEST.DATE TO SAVE.WKO(56);        * Date install was requested for.
EQU SAVE.WKO$TAKEN.DATE TO SAVE.WKO(57);          * Date the order was taken.
EQU SAVE.WKO$TAKEN.TM TO SAVE.WKO(58);            * The time the order was taken.
EQU SAVE.WKO$ENTRY.TM TO SAVE.WKO(59);            * The time of day the order was entered.
EQU SAVE.WKO$COMPL.TM TO SAVE.WKO(60);            * The time of day the order was completed.
~SAVE.WKO.VAR.EQUATES~
*CODE.SEGMENT: SAVE.WKO.VAR.EQUATES
*
*FILE 'SAVE.WKO' EQUATES (VARiables) - GENERATED 16:14:42  30 DEC 1991
EQU SAVE.WKO$ACT.ID TO 1;               * TENANT ACCOUNT NO.
EQU SAVE.WKO$ADD.ID TO 2;               * ADDRESS ID
EQU SAVE.WKO$TFR.FROM.ADD.ID TO 3;      * TFR. FROM ADDRESS ID
EQU SAVE.WKO$TYPE TO 4;                 * WORK ORDER TYPE
EQU SAVE.WKO$STAT TO 5;                 * WORK ORDER STATUS
EQU SAVE.WKO$SCH.DATE TO 6;             * SCHEDULED DATE
EQU SAVE.WKO$SCH.TIME TO 7;             * SCHEDULED TIME
EQU SAVE.WKO$SCH.POINTS TO 8;           * SCHEDULE POINTS
EQU SAVE.WKO$SCH.TYPE TO 9;             * SCHEDULE TYPE
EQU SAVE.WKO$SCH.OVERBOOK TO 10;        * SCHEDULE OVERBOOKED FLAG
EQU SAVE.WKO$COMPL.DATE TO 11;          * COMPLETION DATE
EQU SAVE.WKO$OPERATOR TO 12;            * OPERATOR ENTERING WORK ORDER
EQU SAVE.WKO$INSTALLER TO 13;           * INSTALLER COMPLETING WORK ORDER
EQU SAVE.WKO$SALESMAN TO 14;            * SALESMAN WHO SOLD W/O SERVICES
EQU SAVE.WKO$DVC.COLLECT.INFO TO 15;    * DEVICE COLLECTION INFORMATION
EQU SAVE.WKO$DVC.PRINT.DATE TO 16;      * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU SAVE.WKO$DVC.REPRINT.DATE TO 17;    * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU SAVE.WKO$PRINT.DATE TO 18;          * DATE WORK ORDER WAS FIRST PRINTED
EQU SAVE.WKO$REPRINT.DATE TO 19;        * DATE WORK ORDER WAS LAST REPRINTED
EQU SAVE.WKO$DEPOSIT.TAX TO 20;         * TAX ON THE DEPOSIT AMOUNT
EQU SAVE.WKO$ENTRY.DATE TO 21;          * DATE WORK ORDER WAS ENTERED
EQU SAVE.WKO$EFF.DATE TO 22;            * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU SAVE.WKO$DEPOSIT.AMT TO 23;         * AMOUNT OF DEPOSIT ADJUSTMENT
EQU SAVE.WKO$TOTAL.AMT TO 24;           * TOTAL AMOUNT BILLED ON WORK ORDER
EQU SAVE.WKO$ACTIVS TO 25;              * WORK ORDER ACTIVITY
EQU SAVE.WKO$ACTIV.QNTYS TO 26;         * QUANTITY FOR THIS ACTIVITY
EQU SAVE.WKO$ACTIV.AMTS TO 27;          * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU SAVE.WKO$ACTIV.SERVICES TO 28;      * SERVICE PROVIDED FROM THIS ACTIVITY
EQU SAVE.WKO$SVC.FREQS TO 29;           * BILL FREQUENCY OF SERVICE
EQU SAVE.WKO$SVC.LOCATIONS TO 30;       * LOCATION OF OUTLET
EQU SAVE.WKO$DVC.IDS TO 31;             * DEVICE NO.
EQU SAVE.WKO$DVC.ACTIV.STATS TO 32;     * STATUS OF DEVICE ACTIVITY
EQU SAVE.WKO$MAINT.CODES TO 33;         * Service Order Maintenance codes
EQU SAVE.WKO$OUTCOME.CODES TO 34;       * Service Order Outcome Codes
EQU SAVE.WKO$BILL.SERVICES TO 35;       * TYPE OF SERVICE BILLED
EQU SAVE.WKO$BILL.QNTYS TO 36;          * QUANTITY OF SERVICE BILLED
EQU SAVE.WKO$BILL.FROM.DATES TO 37;     * DATE FROM WHICH SERVICE IS BILLED
EQU SAVE.WKO$BILL.TO.DATES TO 38;       * DATE TO WHICH SERVICE IS BILLED
EQU SAVE.WKO$BILL.RENT.AMTS TO 39;      * RENTAL AMOUNT
EQU SAVE.WKO$BILL.OTHER.AMTS TO 40;     * NON-RENTAL AMOUNT
EQU SAVE.WKO$BILL.FREQS TO 41;          * BILL FREQUENCY FOR RATE CALC.
EQU SAVE.WKO$BILL.DVC.NUMS TO 42;       * DEVICE NO. FOR BILLING OF SERVICE
EQU SAVE.WKO$BILL.SVC.LOCATIONS TO 43;  * LOCATION OF BILLED SERVICE
EQU SAVE.WKO$RATE.EFF.DATES TO 44;      * EFF. DATE FOR RATE USED
EQU SAVE.WKO$RATE.QNTYS TO 45;          * NO. OF OUTLETS AT RATE
EQU SAVE.WKO$MTHLY.RATES TO 46;         * RATE PER OUTLET PER MONTH
EQU SAVE.WKO$TAX.NAMES TO 47;           * NAME OF TAX
EQU SAVE.WKO$TAX.AMTS TO 48;            * AMOUNT OF TAX
EQU SAVE.WKO$PRINT.SOURCE TO 49;        * Printed by System or out of GENIE
EQU SAVE.WKO$MESSAGE TO 50;             * WORK ORDER MESSAGE
EQU SAVE.WKO$DISC.REASON TO 51;         * Reason the subscriber was disconnected
EQU SAVE.WKO$SCH.REQUEST TO 52;         * Scheduled date is at sub's request.
EQU SAVE.WKO$TROUBLE.CLASS TO 53;       * Trouble classification code
EQU SAVE.WKO$TRUCK.ROLL TO 54;          * WAS A TRUCK ROLLED FOR THE WKO?
EQU SAVE.WKO$CONF.DATE.TM TO 55;        * The WKO confirmation date and time.
EQU SAVE.WKO$REQUEST.DATE TO 56;        * Date install was requested for.
EQU SAVE.WKO$TAKEN.DATE TO 57;          * Date the order was taken.
EQU SAVE.WKO$TAKEN.TM TO 58;            * The time the order was taken.
EQU SAVE.WKO$ENTRY.TM TO 59;            * The time of day the order was entered.
EQU SAVE.WKO$COMPL.TM TO 60;            * The time of day the order was completed.
~SCR.DIM~
*CODE.SEGMENT: ?
DIM SCR(35)
~SCR.EQUATES~
*CODE.SEGMENT: SCR.EQUATES
*
* FILE 'SCR' EQUATES - GENERATED 16:18:21  27 NOV 1991
EQU SCR$APPL TO SCR(6);                 * Application this screen belongs to
EQU SCR$SUB.APPL TO SCR(7);             * Sub-application this screen belongs to
EQU SCR$RELEASE TO SCR(11);             * 
EQU SCR$13 TO SCR(13);                  * 
EQU SCR$15 TO SCR(15);                  * 
EQU SCR$21 TO SCR(21);                  * 
EQU SCR$34 TO SCR(34);                  * 
~SCR.HDR.DIM~
DIM SCR.HDR(25)
~SCR.HDR.EQUATES~
*CODE.SEGMENT: SCR.HDR.EQUATES
*
* FILE 'SCR.HDR' EQUATES - GENERATED 15:57:22  10 OCT 1993
EQU SCR.HDR$FILE.NAME TO SCR.HDR(1);    * The files that are used in the screen
EQU SCR.HDR$ALLOWED TO SCR.HDR(2);      * Allowed functions are Add Change Delete
EQU SCR.HDR$CALL.NAME TO SCR.HDR(3);    * 
EQU SCR.HDR$CALL.TEXT TO SCR.HDR(4);    * 
EQU SCR.HDR$NO.EQUATES TO SCR.HDR(5);   * Don't use dims and matreads
EQU SCR.HDR$APPL TO SCR.HDR(6);         * Application this screen belongs to
EQU SCR.HDR$SUB.APPL TO SCR.HDR(7);     * Sub-application this screen belongs to
EQU SCR.HDR$ATTR8 TO SCR.HDR(8);        * 
EQU SCR.HDR$SCREEN.TYPE TO SCR.HDR(9);  * 
EQU SCR.HDR$REC.FLAG TO SCR.HDR(10);    * File is a File.Record.type format
EQU SCR.HDR$RELEASE TO SCR.HDR(11);     * 
EQU SCR.HDR$INPUT.TYPE TO SCR.HDR(12);  * 
EQU SCR.HDR$GEN.DT TO SCR.HDR(13);      * DDDDDTTTTT
EQU SCR.HDR$GEN.DESC TO SCR.HDR(14);    * Description of gen/change
EQU SCR.HDR$GEN.FUNC TO SCR.HDR(15);    * Function being done
EQU SCR.HDR$GEN.OPER TO SCR.HDR(16);    * Operator performing functions
EQU SCR.HDR$FILE TO SCR.HDR(17);        * Destination File of Screen
EQU SCR.HDR$ATTR21 TO SCR.HDR(21);      * 
~SCR.HDR.VAR.EQUATES~
*CODE.SEGMENT: SCR.HDR.VAR.EQUATES
*
* FILE 'SCR.HDR' EQUATES - GENERATED 15:57:22  10 OCT 1993
EQU SCR.HDR$FILE.NAME TO 1;             * The files that are used in the screen
EQU SCR.HDR$ALLOWED TO 2;               * Allowed functions are Add Change Delete
EQU SCR.HDR$CALL.NAME TO 3;             * 
EQU SCR.HDR$CALL.TEXT TO 4;             * 
EQU SCR.HDR$NO.EQUATES TO 5;            * Don't use dims and matreads
EQU SCR.HDR$APPL TO 6;                  * Application this screen belongs to
EQU SCR.HDR$SUB.APPL TO 7;              * Sub-application this screen belongs to
EQU SCR.HDR$ATTR8 TO 8;                 * 
EQU SCR.HDR$SCREEN.TYPE TO 9;           * 
EQU SCR.HDR$REC.FLAG TO 10;             * File is a File.Record.type format
EQU SCR.HDR$RELEASE TO 11;              * 
EQU SCR.HDR$INPUT.TYPE TO 12;           * 
EQU SCR.HDR$GEN.DT TO 13;               * DDDDDTTTTT
EQU SCR.HDR$GEN.DESC TO 14;             * Description of gen/change
EQU SCR.HDR$GEN.FUNC TO 15;             * Function being done
EQU SCR.HDR$GEN.OPER TO 16;             * Operator performing functions
EQU SCR.HDR$FILE TO 17;                 * Destination File of Screen
EQU SCR.HDR$ATTR21 TO 21;               * 
~SCR.LNS.DIM~
*CODE.SEGMENT: SCR.LNS.DIM 
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
DIM SCR.LNS(23)
DIM LPT.LNS(23)
*
~SCR.POSN.DIM~
*CODE.SEGMENT: SCR.POSN.DIM
*
DIM SCR.POSN(10)
~SCR.VAR.EQUATES~
*CODE.SEGMENT: SCR.VAR.EQUATES
*
* FILE 'SCR' EQUATES - GENERATED 16:18:22  27 NOV 1991
EQU SCR$APPL TO 6;                      * Application this screen belongs to
EQU SCR$SUB.APPL TO 7;                  * Sub-application this screen belongs to
EQU SCR$RELEASE TO 11;                  * 
EQU SCR$13 TO 13;                       * 
EQU SCR$15 TO 15;                       * 
EQU SCR$21 TO 21;                       * 
EQU SCR$34 TO 34;                       * 
~SCREENS.DIM~
*CODE.SEGMENT: ?
DIM SCREENS(25)
~SCREENS.EQUATES~
*CODE.SEGMENT: SCREENS.EQUATES
*
* FILE 'SCREENS' EQUATES - GENERATED 02:30:30  05 SEP 1991
EQU SCREENS$FILE.NAME TO SCREENS(1);    * 
EQU SCREENS$ALLOWED TO SCREENS(2);      * 
EQU SCREENS$CALL.NAME TO SCREENS(3);    * 
EQU SCREENS$CALL.TEXT TO SCREENS(4);    * 
EQU SCREENS$NO.EQUATES TO SCREENS(5);   * Don't use dims and matreads
EQU SCREENS$SCREEN.TYPE TO SCREENS(9);  * 
EQU SCREENS$RELEASE TO SCREENS(11);     * 
EQU SCREENS$INPUT.TYPE TO SCREENS(12);  * 
EQU SCREENS$13 TO SCREENS(13);          * 
EQU SCREENS$15 TO SCREENS(15);          * 
EQU SCREENS$21 TO SCREENS(21);          * 
~SCREENS.HDR.DIM~
*CODE.SEGMENT: ?
DIM SCREENS.HDR(25)
~SCREENS.HDR.EQUATES~
*CODE.SEGMENT: SCREENS.HDR.EQUATES
*
* FILE 'SCREENS.HDR' EQUATES - GENERATED 03:23:56  12 NOV 1991
EQU SCREENS.HDR$FILE.NAME TO SCREENS.HDR(1); * 
EQU SCREENS.HDR$ALLOWED TO SCREENS.HDR(2);   * 
EQU SCREENS.HDR$CALL.NAME TO SCREENS.HDR(3); * 
EQU SCREENS.HDR$CALL.TEXT TO SCREENS.HDR(4); * 
EQU SCREENS.HDR$NO.EQUATES TO SCREENS.HDR(5);* Don't use dims and matreads
EQU SCREENS.HDR$APPL TO SCREENS.HDR(6);      * Application this screen belongs to
EQU SCREENS.HDR$SUB.APPL TO SCREENS.HDR(7);  * Sub-application this screen belongs to
EQU SCREENS.HDR$ATTR8 TO SCREENS.HDR(8);     * 
EQU SCREENS.HDR$SCREEN.TYPE TO SCREENS.HDR(9);    * 
EQU SCREENS.HDR$ATTR10 TO SCREENS.HDR(10);        * 
EQU SCREENS.HDR$RELEASE TO SCREENS.HDR(11);       * 
EQU SCREENS.HDR$INPUT.TYPE TO SCREENS.HDR(12);    * 
EQU SCREENS.HDR$ATTR13 TO SCREENS.HDR(13);        * 
EQU SCREENS.HDR$ATTR14 TO SCREENS.HDR(14);        * 
EQU SCREENS.HDR$ATTR15 TO SCREENS.HDR(15);        * 
EQU SCREENS.HDR$ATTR21 TO SCREENS.HDR(21);        * 
~SCREENS.HDR.VAR.EQUATES~
*CODE.SEGMENT: SCREENS.HDR.VAR.EQUATES
*
* FILE 'SCREENS.HDR' EQUATES - GENERATED 03:23:56  12 NOV 1991
EQU SCREENS.HDR$FILE.NAME TO 1;         * 
EQU SCREENS.HDR$ALLOWED TO 2;           * 
EQU SCREENS.HDR$CALL.NAME TO 3;         * 
EQU SCREENS.HDR$CALL.TEXT TO 4;         * 
EQU SCREENS.HDR$NO.EQUATES TO 5;        * Don't use dims and matreads
EQU SCREENS.HDR$APPL TO 6;              * Application this screen belongs to
EQU SCREENS.HDR$SUB.APPL TO 7;          * Sub-application this screen belongs to
EQU SCREENS.HDR$ATTR8 TO 8;             * 
EQU SCREENS.HDR$SCREEN.TYPE TO 9;       * 
EQU SCREENS.HDR$ATTR10 TO 10;           * 
EQU SCREENS.HDR$RELEASE TO 11;          * 
EQU SCREENS.HDR$INPUT.TYPE TO 12;       * 
EQU SCREENS.HDR$ATTR13 TO 13;           * 
EQU SCREENS.HDR$ATTR14 TO 14;           * 
EQU SCREENS.HDR$ATTR15 TO 15;           * 
EQU SCREENS.HDR$ATTR21 TO 21;           * 
~SCREENS.VAR.EQUATES~
*CODE.SEGMENT: SCREENS.VAR.EQUATES
*
* FILE 'SCREENS' EQUATES - GENERATED 02:30:30  05 SEP 1991
EQU SCREENS$FILE.NAME TO 1;             * 
EQU SCREENS$ALLOWED TO 2;               * 
EQU SCREENS$CALL.NAME TO 3;             * 
EQU SCREENS$CALL.TEXT TO 4;             * 
EQU SCREENS$NO.EQUATES TO 5;            * Don't use dims and matreads
EQU SCREENS$SCREEN.TYPE TO 9;           * 
EQU SCREENS$RELEASE TO 11;              * 
EQU SCREENS$INPUT.TYPE TO 12;           * 
EQU SCREENS$13 TO 13;                   * 
EQU SCREENS$15 TO 15;                   * 
EQU SCREENS$21 TO 21;                   * 
~SEC.USER.DIM~
*CODE.SEGMENT: SEC.USER.DIM
*
DIM SEC.USER(10)
~SEC.USER.EQUATES~
*CODE.SEGMENT: SEC.USER.EQUATES
*
* FILE 'SEC.USER' EQUATES - GENERATED 00:34:55  16 JAN 1992
EQU SEC.USER$RSVD.1 TO SEC.USER(1);     * reserved
EQU SEC.USER$RSVD.2 TO SEC.USER(2);     * reserved
EQU SEC.USER$SAL TO SEC.USER(3);        * password
EQU SEC.USER$GROUP TO SEC.USER(4);      * User group attributes
EQU SEC.USER$DESC TO SEC.USER(5);       * Description
EQU SEC.USER$VALID.ACCTS TO SEC.USER(6);* Accounts user has access to
EQU SEC.USER$FILE.NAME   TO SEC.USER(7);* File STD Data record is in
EQU SEC.USER$ITEM.ID     TO SEC.USER(8);* Item STD Data record is in
EQU SEC.USER$FUNC.NAME   TO SEC.USER(9);* Last or default function
EQU SEC.USER$BF          TO SEC.USER(10);* Break flag
~SEC.USER.ON~
*CODE.SEGMENT: SEC.USER.ON
*
EQU SEC.USER.ON TO 0
*
~SEC.USER.VAR.EQUATES~
*CODE.SEGMENT: SEC.USER.VAR.EQUATES
*
* FILE 'SEC.USER' EQUATES - GENERATED 00:34:55  16 JAN 1992
EQU SEC.USER$RSVD.1 TO 1;               * reserved
EQU SEC.USER$RSVD.2 TO 2;               * reserved
EQU SEC.USER$SAL TO 3;                  * password
EQU SEC.USER$GROUP TO 4;                * User group attributes
EQU SEC.USER$DESC TO 5;                 * Description
EQU SEC.USER$VALID.ACCTS TO 6;          * Accounts user has access to
~SECONDS.INCL.CONV~
*CODE.SEGMENT: SECONDS.INCL.CONV 
*
* AUTHOR: DAVID HORSMAN
*
IF NOT(NUM(TMP.TM)) THEN TMP.TM = ZERO
IF TMP.TM LT ZERO THEN TMP.SIGN = "-"; TMP.TM = ABS(TMP.TM) ELSE TMP.SIGN = EMPTY
IF NOT(TMP.TM) THEN ORSLT = EMPTY ELSE
*
ORSLT = INT(TMP.TM / 3600):(OCONV((TMP.TM - (INT(TMP.TM / 3600) * 3600)),"MTS")) "R#6"
ORSLT = TMP.SIGN:ORSLT
*
END
*
~SH.COMMON.AREA~
*PROGRAM:           SH.COMMON.AREA
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      17 MAR 94 17:24:31
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
*INPUT.END*
*
*
SCR.ID = "COMMON.AREA"
RELEASE.ID = ""
REF = ONE; REDISP = FALSE; NEW = FALSE
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
*
OPEN "COM" TO COM.FILE ELSE
PRINT CLB:"COM File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "CNT" TO CNT.FILE ELSE
PRINT CLB:"CNT File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "PAR" TO PAR.FILE ELSE
PRINT CLB:"PAR File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:"ACC File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
0
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
*READ.LNS*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*READ.END*
CALL SH.SUBR.SCR.COMMON.AREA(LCK.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
*SCR.END*
*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
*MAIN.LNS*
NEXT.ITEM: *
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
.ID = EMPTY; .ID.SAVE = EMPTY; GOSUB GET.KEY
IF .ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN GOTO FINISH
IF NOT(DISP.ONLY) THEN
LOOP
CALL LOCK.ITEM(.FILE,"",.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
READ  FROM .FILE,.ID THEN NEW = FALSE ELSE NEW = TRUE;  = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ZERO
NEXT REF
NEW = EMPTY
END
*
!
*
CHANGES: *
TEXT = "Enter DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE .FILE,.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*
!
*
UPDATE: *
WRITE  ON .FILE,.ID
UPDATED = TRUE
*
!
*
UNLOCK: *
CALL UNLOCK.ITEM(.FILE,"",.ID,LCK.FILE)
*
!
*
FINISH: *
*
*FIN.LNS*
STOP
*FIN.END*
*MAIN.END*
*
!
*
DISP.BG: *
*
RETURN
*
!
*
DISP.FG: *
*
IF REDISP THEN
REDISP = 99
TEMP = .ID; FOR ID.CN = ONE TO 0; .ID.SAVE<ID.CN> = "!":.ID.SAVE<ID.CN>; NEXT ID.CN; GOSUB GET.KEY; .ID = TEMP
END
*
*
!
*
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 0
ON ID.CN GOSUB 
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 0 AND .ID.SAVE<0> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
FOR ID.CN = ONE TO 0
IF ID.CN EQ ONE THEN .ID = .ID.SAVE<ID.CN> ELSE .ID = .ID:.ID.SAVE<ID.CN>
NEXT ID.CN
*
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+COMMON.AREA: ":.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.COMMON.AREA(LCK.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE
ON REF GOSUB 
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
@@@
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.SUBR.LPT.COMMON.AREA~
SUBROUTINE SH.SUBR.LPT.COMMON.AREA(LCK.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
0
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.COMMON.AREA~
SUBROUTINE SH.SUBR.SCR.COMMON.AREA(LCK.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr"
0
*REF.END*
*
*
!
*
POS.LOC = "0"
*REF.LNS*
*
RETURN; * To calling program
*
!
*
END
~SIDA.DIM~
*CODE.SEGMENT: ?
DIM SIDA(10)
~SLIST.CNTRL.DIM~
*CODE.SEGMENT: ?
*
DIM SLIST.CNTRL(10)
~SLIST.CNTRL.EQUATES~
*CODE.SEGMENT: SLIST.CNTRL.EQUATES
*
* FILE 'SLIST.CNTRL' EQUATES - GENERATED 04:34:28  17 SEP 1991
EQU SLIST.CNTRL$REC.SIZE.MAX TO SLIST.CNTRL(1);   * Max size of each list record
EQU SLIST.CNTRL$REC.CN TO SLIST.CNTRL(2);         * Count of list records
EQU SLIST.CNTRL$REC.SIZE.MIN TO SLIST.CNTRL(3);   * Min size of rec before a merge
EQU SLIST.CNTRL$REORG TO SLIST.CNTRL(4);          * Reorganize this list
EQU SLIST.CNTRL$SEQ TO SLIST.CNTRL(5);            * Sequence of list
EQU SLIST.CNTRL$ITEMS TO SLIST.CNTRL(6);          * List of items containing list
EQU SLIST.CNTRL$STAT.USED TO SLIST.CNTRL(7);      * Are record statuses used with list?
EQU SLIST.CNTRL$DATA.USED TO SLIST.CNTRL(8);      * Is an associated data record used?
EQU SLIST.CNTRL$DISP.USED TO SLIST.CNTRL(9);      * Is any info read and displayed with list
~SLIST.CNTRL.VAR.EQUATES~
*CODE.SEGMENT: SLIST.CNTRL.VAR.EQUATES
*
* FILE 'SLIST.CNTRL' EQUATES - GENERATED 04:34:28  17 SEP 1991
EQU SLIST.CNTRL$REC.SIZE.MAX TO 1;      * Max size of each list record
EQU SLIST.CNTRL$REC.CN TO 2;            * Count of list records
EQU SLIST.CNTRL$REC.SIZE.MIN TO 3;      * Min size of rec before a merge
EQU SLIST.CNTRL$REORG TO 4;             * Reorganize this list
EQU SLIST.CNTRL$SEQ TO 5;               * Sequence of list
EQU SLIST.CNTRL$ITEMS TO 6;             * List of items containing list
EQU SLIST.CNTRL$STAT.USED TO 7;         * Are record statuses used with list?
EQU SLIST.CNTRL$DATA.USED TO 8;         * Is an associated data record used?
EQU SLIST.CNTRL$DISP.USED TO 9;         * Is any info read and displayed with list
~SOURCEGEN.ADJ.COL~
*CODE.SEGMENT: SOURCEGEN.ADJ.COL 
* MACROSCOPE DESIGN MAXTRIX / AXION COMPUTER SYSTEMS
* APRIL 1991
*
IF TF THEN PRINT "a":
ADJ.CL = ONE; CHAR.COUNT = 0
LOOP UNTIL CHAR.COUNT = CL DO
CHAR = SCR.LN[ADJ.CL,ONE]
ADJ.CL = ADJ.CL + ONE
IF NOT(CHAR EQ SO OR CHAR EQ SI) THEN CHAR.COUNT = CHAR.COUNT + ONE
REPEAT
ADJ.CL = ADJ.CL - ONE
*
~SOURCEGEN.DOC.HDR~
*CODE.SEGMENT: SOUCREGEN.DOC.HDR 
*
* NO OPeration performed - DOCumentation
*
* AUTHORS:  DAVID G. HORSMAN - MACROSCOPE DESIGN MATRIX
*           BOB CONARROE     - AXION
*           DAVID STERN      - AXION
*
* DESCRIPTION: Inputs the following parameters:
* ITEM ID
* INPUT FILE (SCREENS)
* OUTPUT FILE (BP)
* TRACE ON (NO)
*
* Loads Screen Description tables
* Generate Data Basic Source Code
* Member of SEARCH & RELease MaNaGment
*
~SOURCEGEN.MAIN~
*CODE.SEGMENT: SOURCEGEN.MAIN 
*
* SPLIT 19 APR 91
* DGH
*
*
*
IF TF THEN PRINT CLB:"< Start : ":; RQM
*
GOSUB PROGRAM.START
*
IF TF THEN PRINT CLB:"< Opens : ":; RQM
GOSUB OPEN.FLS
*
IF TF THEN PRINT CLB:"< Refs  : ":; RQM
ID = FLNMS<ONE,ONE>:".ID"
GOSUB VALID.REFERENCES
*
IF TF THEN PRINT CLB:"< MAIN>"; RQM
GOSUB PROGRAM.MAINLINE
*
IF TF THEN PRINT CLB:"< Back  : ":; RQM
GOSUB BG.DISP
*
IF TF THEN PRINT CLB:"< Fore  : ":; RQM
GOSUB FG.DISP
*
IF TF THEN PRINT CLB:"< Key   : ":; RQM
GOSUB KEY.INPUT
*
IF TF THEN PRINT CLB:"< InputCalls : ":; RQM
GOSUB INPUT.CS
*
IF TF THEN PRINT CLB:"< InputFeild : ":; RQM
GOSUB DT.INPUT
*
IF TF THEN PRINT CLB:"< Errors    : ":; RQM
GOSUB ERROR.ROUTINE
*
IF TF THEN PRINT CLB:"< Reads     : ":; RQM
GOSUB SET.UP.READ.ITEMS
*
IF TF THEN PRINT CLB:"< Custom    : ":; RQM
GOSUB CUSTOM.CS
*
IF TF THEN PRINT CLB:"< SpecialChars : ":; RQM
GOSUB REMOVE.SVM.VM
*
~SOURCEGEN.PMPT.DT~
X*CODE.SEGMENT: SOURCEGEN.PMPT.DT 
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
EXTR.PMPT.DT: *
* PMPT.TYPE, PMPT.TEXT
* PMPT.RSP,  INPUT.REQD
* FLNM, POSN, LOCN, CONV, EDIT
* CONTROLLING, DEPENDANT, FREE
*
DT = SIR<SIR.AC>
*
IF DT EQ EMPTY OR DT[ONE,ONE] EQ '*' THEN RETURN
*
PMPT.TYPE = DT<ONE,ONE,ONE>[ONE,ONE]
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," OR PMPT.TYPE EQ "'" THEN
INPUT.REQD = ZERO; PMPT.TEXT = EMPTY
PMPT.RSP = DT<ONE,ONE,ONE>[TWO,9999]
END ELSE
INPUT.REQD = ONE
IF PMPT.TYPE EQ '"' THEN PMPT.TEXT = EMPTY ELSE PMPT.TYPE = DT<ONE,ONE,ONE>; PMPT.TEXT = DT<ONE,ONE,TWO>
END
*
POSN = DT<ONE,TWO>
LOCN = DT<ONE,3>; OLD.LOCN = LOCN
*
* LOAD COL, LINE, LENGTH, END LINE
CL  = POSN<ONE,ONE,ONE>
LN  = POSN<ONE,ONE,TWO>
LH  = POSN<ONE,ONE,3>
LHM = POSN<ONE,ONE,4>
LM  = FIELD(LN,"-",TWO)
IF LM EQ EMPTY THEN LM = LN ELSE LN = FIELD(LN,"-",ONE)
*
MS = LH[ONE,ONE]; IF MS EQ "L" OR MS EQ "R" THEN LH = LH[TWO,9] ELSE MS = "L"
MS = MS:"#":LH
IF LHM EQ EMPTY THEN LHM = LH
*
* Load File related variables
VF = ZERO; SQ = EMPTY; VTYPE = EMPTY; VTYPE.VC = ZERO; VTYPE.FL = FALSE
FL = LOCN<ONE,ONE,ONE>; * FILE
FLNM = EMPTY; EXTR = EMPTY; LOCN = EMPTY
SPOS = EMPTY; SPOS.MAX = ZERO
CONV = EMPTY; EDIT = EMPTY
*
* File access
IF FL MATCHES '2X0N' AND INDEX('*FI*AL*AR*DL*DR*','*':FL[ONE,TWO]:'*',ONE) AND FL[3,9] GT ZERO THEN
SQ = FL[ONE,TWO]; VF = FL[3,9]; FL = ONE; VTYPE.VC = ONE; VTYPE = 'FL'
FLNM.SUFF = EMPTY
END ELSE IF NOT(NUM(FL)) THEN
TC = FL[ONE,ONE]
IF TC EQ '"' OR TC EQ "'" THEN
FL = FIELD(FL,TC,TWO)
LOCATE FL IN FLNMS SETTING LOC THEN
FL = LOC
END ELSE
FLNMS<ONE,LOC> = FL
SIR<ONE,LOC> = FL
FL = LOC
END
END
END ELSE
IF NOT(FL) THEN FL = ONE
END
*
IF NOT(NUM(FL)) THEN
LOCATE FL IN FLNMS SETTING LOC THEN
INS FL BEFORE FLNMS<ONE,LOC>
FL = LOC
END; * of loc
END; * of num fl name
*
* AM
TRUE.AC = ZERO
AC = FIELD(LOCN<ONE,ONE,TWO>,"-",ONE)
IF AC[ONE,ONE] EQ '"' THEN
AC = FIELD(AC,'"',TWO)
END ELSE IF AC[ONE,ONE] EQ "'" THEN
VF = ZERO; SQ = EMPTY; AC = FLNMS<ONE,FL>:'$':FIELD(AC,"'",TWO)
END ELSE IF NUM(AC) THEN
TRUE.AC = AC
END ELSE
SQ = AC[ONE,TWO]; VF = AC[3,9]; AC = 'AC'; VTYPE.VC = 2; VTYPE = 'AC'
END
*
* VM
VC = FIELD(LOCN<ONE,ONE,3>,"-",ONE)
IF VC[ONE,ONE] EQ '"' THEN
VC = FIELD(VC,'"',TWO)
END ELSE IF NUM(VC) THEN
NULL
END ELSE
SQ = VC[ONE,TWO]; VF = VC[3,9]; VC = 'VC'; VTYPE.VC = 3; VTYPE = 'VC'
END
*
* SVM
SC = FIELD(LOCN<ONE,ONE,4>,"-",ONE)
IF SC[ONE,ONE] EQ '"' THEN
SC = FIELD(SC,'"',TWO)
END ELSE IF NUM(SC) THEN
NULL
END ELSE
SQ = SC[ONE,TWO]; VF = SC[3,9]; SC = 'SC'; VTYPE.VC = 4; VTYPE = 'SC'
END
*
IF VF THEN IF LOCN<ONE,ONE,VTYPE.VC + ONE> NE EMPTY THEN VTYPE.FL = TRUE
SB = LOCN<ONE,ONE,5>
*
GOSUB SET.UP.STRINGS
*
CONV = DT<ONE,4>
* PRINT BELL:; INPUT RSP:
IF NUM(FL) THEN
IF FL EQ ONE THEN
IF TRUE.AC THEN
IF CONV NE EMPTY THEN
IF EQF(TRUE.AC)<DCT.CONV> EQ EMPTY THEN EQF(TRUE.AC)<DCT.CONV> = CONV; EQF(TRUE.AC)<DCT.WRFL> = TRUE
END ELSE IF EQF(TRUE.AC)<DCT.CONV> NE EMPTY THEN
CONV = EQF(TRUE.AC)<DCT.CONV>
END
END; * of true ac gt zero
END; * of file # 1
END; * of num file
*
IF OLD.LOCN EQ EMPTY THEN
PMPT.RSP = DT<ONE,ONE,ONE>
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," OR PMPT.TYPE EQ '"' THEN PMPT.RSP = PMPT.RSP[TWO,999]
IF PMPT.TYPE NE "'" THEN PMPT.RSP = '"':PMPT.RSP:'"'
PMPT.TYPE = EMPTY; INPUT.REQD = ZERO; REDISP = ZERO
END ELSE PMPT.RSP = EMPTY
*
* EDIT, ED1, ED2, EDIT.FILE
* PRINT BELL:; INPUT RSP:
EDIT = INDEX(DT,VM,4)
EDIT.FILE = 'EMPTY'
IF NOT(EDIT) THEN EDIT = EMPTY ELSE
*
IF NUM(FL) THEN
IF FL EQ ONE THEN
IF TRUE.AC THEN
IF EDIT NE EMPTY THEN
IF EQF(TRUE.AC)<DCT.EDIT> EQ EMPTY THEN EQF(TRUE.AC)<DCT.EDIT> = EDIT; EQF(TRUE.AC)<DCT.WRFL> = TRUE
END ELSE IF EQF(TRUE.AC)<DCT.EDIT> NE EMPTY THEN
EDIT = EQF(TRUE.AC)<DCT.EDIT>
END
END; * of true ac gt zero
END; * of file # 1
END; * of num file
*
EDIT = DT[EDIT + ONE,999]
CN = ONE
LOOP ED = EDIT<ONE,CN> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>
IF ED1 EQ "RE" THEN
REDISP = ONE
DEL EDIT<ONE,CN>
CN = CN - ONE
END ELSE
IF ED1 EQ "FI" OR ED1 EQ "DF" OR ED1 EQ "EQ" OR ED1 EQ "MA" THEN
ED2 = ED<ONE,ONE,TWO>
IF ED1 EQ "FI" THEN EDIT<ONE,CN> = ED1; EDIT.FILE = FIELD(FLNMS<ONE,ED2>,".",ONE):'.FILE' ELSE
IF ED2[ONE,ONE] EQ "*" THEN
READ.ITEM = FIELD(FLNMS<ONE,ED2[TWO,TWO]>,".",ONE):'*':ED<ONE,ONE,3>
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
EDIT<ONE,CN> = ED1:SVM:'@":':ED<ONE,ONE,3>:'<ONE>:"@'
END; * of '*'
END; * of not 'FI'
END; * of FI EQ DF MA
END; * of not RE
CN = CN + ONE
REPEAT
END; * of EDIT present
*
RETURN
*
!
*
SET.UP.STRINGS: *
*
EQ.F = FALSE; TRUE.AC = ZERO
*
IF PMPT.TYPE EQ "'" THEN 
FLNM = PMPT.RSP
RETURN
END
*
IF NOT(NUM(FL)) THEN FLNM = FL; FLNM.SUFF = FIELD(FL,".",TWO) ELSE
IF NOT(FL) THEN FLNM = 'EMPTY' ELSE
FLNM = FLNMS<ONE,FL>
END
FLNM.SUFF = FIELD(FLNM,".",TWO)
*
IF AC = 'AC' THEN
NULL
*
END ELSE IF NUM(AC) AND FL EQ ONE THEN
TRUE.AC = AC
IF NOT(TRUE.AC) AND SQ EQ EMPTY THEN
FLNM = FLNM:'.ID'
EXTR = '<':REF.AC - FIRST.AC + ONE:'>'
END ELSE
IF EQT(FL) NE EMPTY AND NOT(NO.DIM<ONE,FL>) THEN
IF EQF(TRUE.AC)<DCT.DBNAME> NE EMPTY THEN
**FLNM = FLNM:'$':EQF(TRUE.AC)<DCT.DBNAME>
* AC = EQF(TRUE.AC)<DCT.DBNAME>
* FLNM = FLNMS<ONE,FL>:'$':AC
FLNM = FLNMS<ONE,FL>:'$':EQF(TRUE.AC)<DCT.DBNAME>
AC = FLNM
IF SIR<SIR.AC,3,TWO> EQ AC THEN SIR<SIR.AC,3,TWO> = "'":FIELD(AC,'$',TWO):"'"
EQ.F = TRUE
END ELSE
FLNM = FLNM:'(':AC:')'
END
END; * of equate item present
END; * of not an ID
*
END ELSE
* AC is a string
FLNM = AC
LOCATE FLNM IN EQF.IND SETTING TRUE.AC ELSE TRUE.AC = ZERO
IF TRUE.AC THEN EQ.F = TRUE
END; * of field name string
END; * of file name not a string
*
TMP.AC = AC
IF NOT(NUM(TMP.AC)) AND AC NE 'AC' THEN TMP.AC = "ONE"
*
BEGIN CASE
*
CASE SC NE EMPTY
EXTR = '<':TMP.AC:',':VC:',':SC:'>'; LOCN = TMP.AC:':",":':VC:':",":':SC
SPOS = TMP.AC:',':VC:',':SC
IF SB NE EMPTY THEN LOCN = LOCN:':",":"':SB:'"'
SPOS.MAX = 3
*
CASE VC NE EMPTY
EXTR = '<':TMP.AC:',':VC:'>'; LOCN = TMP.AC:':",":':VC
SPOS = TMP.AC:',':VC
IF SB NE EMPTY THEN LOCN = LOCN:':",,":"':SB:'"'
SPOS.MAX = TWO
*
CASE AC NE EMPTY
IF EQ.F THEN
EXTR = EMPTY; LOCN = ONE; SPOS = EMPTY
END ELSE
EXTR = '<':TMP.AC:'>'; LOCN = TMP.AC; SPOS = TMP.AC
END
IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
SPOS.MAX = ONE
*
CASE FL NE EMPTY
EXTR = EMPTY; LOCN = ONE; SPOS = EMPTY
IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
SPOS.MAX = ZERO
*
CASE TRUE
VTYPE = EMPTY; EXTR = EMPTY; LOCN = EMPTY; SPOS = EMPTY; SPOS.MAX = ZERO
*
END CASE
*
INST = EXTR; LOCT = EXTR
IF VTYPE.VC THEN
IF VTYPE.VC GT ONE THEN
TMP = INDEX(EXTR,',',VTYPE.VC - ONE)
IF NOT(TMP) THEN TMP = INDEX(EXTR,'>',ONE)
INST = EXTR[ONE,TMP - ONE]:'>'
END ELSE
INST = EMPTY
END
IF VTYPE.VC GT TWO THEN
TMP = INDEX(EXTR,',',VTYPE.VC - TWO)
IF NOT(TMP) THEN TMP = INDEX(EXTR,'>',ONE)
LOCT = EXTR[ONE,TMP - ONE]:'>'
END ELSE
LOCT = EMPTY
END
END
*
RETURN
!
~SOURCEGEN.PMPT.DT1~
*CODE.SEGMENT: SOURCEGEN.PMPT.DT 
*
* DAVID HORSMAN
* MACROSCOPE DESIGN MATRIX
* APRIL 91
*
!
EXTR.PMPT.DT: *
* PMPT.TYPE, PMPT.TEXT, INPUT.REQD
* POSN, LOCN, CONV, EDIT
* CONTROLLING, DEPENDANT, FREE
* IF TF THEN PRINT " <e ":
PMPT.TYPE = DT<ONE,ONE,ONE>[ONE,ONE]
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," THEN INPUT.REQD = ZERO; PMPT.TEXT = EMPTY ELSE
INPUT.REQD = ONE
IF PMPT.TYPE EQ '"' THEN PMPT.TEXT = EMPTY ELSE PMPT.TYPE = DT<ONE,ONE,ONE>; PMPT.TEXT = DT<ONE,ONE,TWO>
END
POSN = DT<ONE,TWO>
LOCN = DT<ONE,3>
CONV = DT<ONE,4>
IF POSN EQ EMPTY AND LOCN EQ EMPTY AND CONV EQ EMPTY THEN
PMPT.TYPE = EMPTY; INPUT.REQD = ZERO; REDISP = ZERO
PMPT.RSP = DT<ONE,ONE,ONE>
IF PMPT.TYPE EQ EMPTY OR PMPT.TYPE EQ "." OR PMPT.TYPE EQ "," OR PMPT.TYPE EQ '"' THEN PMPT.RSP = PMPT.RSP[TWO,999]
PMPT.RSP = '"':PMPT.RSP:'"'
END ELSE PMPT.RSP = EMPTY
*
* EDIT, ED1, ED2, EDIT.FILE
EDIT = INDEX(DT,VM,4)
EDIT.FILE = 'EMPTY'
IF NOT(EDIT) THEN EDIT = EMPTY ELSE
EDIT = DT[EDIT + ONE,999]
VC = ONE
LOOP ED = EDIT<ONE,VC> UNTIL ED EQ EMPTY DO
ED1 = ED<ONE,ONE,ONE>
IF ED1 EQ "RE" THEN
REDISP = ONE
DEL EDIT<ONE,VC>
VC = VC - ONE
END ELSE
IF ED1 EQ "FI" OR ED1 EQ "DF" OR ED1 EQ "EQ" OR ED1 EQ "MA" THEN
ED2 = ED<ONE,ONE,TWO>
IF ED1 EQ "FI" THEN EDIT<ONE,VC> = ED1; EDIT.FILE = FLNMS<ONE,ED2>:'.FILE' ELSE
IF ED2[ONE,ONE] EQ "*" THEN
READ.ITEM = FLNMS<ONE,ED2[TWO,TWO]>:'*':ED<ONE,ONE,3>
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
EDIT<ONE,VC> = ED1:SVM:'@":':ED<ONE,ONE,3>:'<ONE>:"@'
END
END
END
END
VC = VC + ONE
REPEAT
END
*
* LOAD COL, LINE, LENGTH, END LINE
CL = POSN<ONE,ONE,ONE>
LN = POSN<ONE,ONE,TWO>
LH = POSN<ONE,ONE,3>
LM = FIELD(LN,"-",TWO)
IF LM EQ EMPTY THEN LM = LN ELSE LN = FIELD(LN,"-",ONE)
*
MS = LH[ONE,ONE]; IF MS EQ "L" OR MS EQ "R" THEN LH = LH[TWO,9] ELSE MS = "L"
MS = MS:"#":LH
*
FL = LOCN<ONE,ONE,ONE>; * FILE
*IF FL[ONE,ONE] EQ '"' THEN FL = FIELD(FL,'"',TWO)
IF FL[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; FL = FIELD(FL,'"',TWO)
END ELSE IF NUM(FL) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = FL[ONE,TWO]; VF = FL[3,9]; FL = ONE
END
* AM
IF VF THEN AC = EMPTY ELSE
AC = FIELD(LOCN<ONE,ONE,TWO>,"-",ONE)
IF AC[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; AC = FIELD(AC,'"',TWO)
END ELSE IF AC[ONE,ONE] EQ "'" THEN
VF = ZERO; SQ = EMPTY; AC = FLNMS<ONE,FL>:"$":FIELD(AC,"'",TWO)
END ELSE IF NUM(AC) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = AC[ONE,TWO]; VF = AC[3,9]; AC = ONE
END
END; * of VF or AC
* VM
IF VF THEN VC = EMPTY ELSE
VC = FIELD(LOCN<ONE,ONE,3>,"-",ONE)
IF VC[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; VC = FIELD(VC,'"',TWO)
END ELSE IF NUM(VC) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = VC[ONE,TWO]; VF = VC[3,9]; VC = ONE
END
END; * of VF or VC
* SVM
IF VF THEN SC = EMPTY ELSE
SC = FIELD(LOCN<ONE,ONE,4>,"-",ONE)
IF SC[ONE,ONE] EQ '"' THEN
VF = ZERO; SQ = EMPTY; SC = FIELD(SC,'"',TWO)
END ELSE IF NUM(SC) THEN
VF = ZERO; SQ = EMPTY
END ELSE
SQ = SC[ONE,TWO]; VF = SC[3,9]; SC = ONE
END
END; * of VF or SC
SB = LOCN<ONE,ONE,5>
GOSUB SET.UP.STRINGS
RETURN
!
SET.UP.STRINGS: *
* IF TF THEN PRINT "s":
IF NOT(NUM(FL)) THEN FLNM = FL ELSE
IF NOT(FL) THEN FLNM = 'EMPTY' ELSE
FLNM = FLNMS<ONE,FL>
END
IF NUM(AC) THEN
IF NOT(AC) AND SQ EQ EMPTY THEN FLNM = FLNM:'.ID' ELSE
IF EQT(FL) NE EMPTY THEN
EQ.F = EMPTY; FLNM = FLNM:'(':AC:')'; AC = ONE
TMP = INDEX(EQT(FL),"EQU",ONE)
*EQ.AC = TWO
EQ.AC = DCOUNT(EQT(FL)[ONE,TMP+ONE],AM)
LOOP EQ.LN = EQT(FL)<EQ.AC> UNTIL EQ.LN EQ EMPTY OR EQ.F DO
IF FIELD(EQ.LN," ",4) EQ FLNM:";" THEN EQ.F = ONE; FLNM = FIELD(EQ.LN," ",TWO)
EQ.AC = EQ.AC + ONE
REPEAT
END; * of equate item present
END; * of not an ID
END ELSE
* AC is a string
FLNM = AC
END; * of field name string
END; * of file name not a string
*
TMP.AC = AC
IF NOT(NUM(TMP.AC)) THEN TMP.AC = "ONE"
BEGIN CASE
*
CASE SC NE EMPTY
VTYPE = "SC"
IF VF THEN
EXTR = '<':TMP.AC:',':VC:',SC>' ; LOCN = TMP.AC:':",":':VC:':",":SC'
END ELSE EXTR = '<':TMP.AC:',':VC:',':SC:'>'; LOCN = TMP.AC:':",":':VC:':",":':SC; IF SB NE EMPTY THEN LOCN = LOCN:':",":"':SB:'"'
*
CASE VC NE EMPTY
VTYPE = "VC"
IF VF THEN
EXTR = '<':TMP.AC:',VC>' ; LOCN = TMP.AC:':",":VC'
END ELSE EXTR = '<':TMP.AC:',':VC:'>'; LOCN = TMP.AC:':",":':VC; IF SB NE EMPTY THEN LOCN = LOCN:':",,":"':SB:'"'
*
CASE AC NE EMPTY
VTYPE = "AC"
IF VF THEN
EXTR = '<AC>'; LOCN = 'AC'
END ELSE EXTR = '<':TMP.AC:'>'; LOCN = TMP.AC; IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
*
CASE FL NE EMPTY
VTYPE = "FL"
IF VF THEN
EXTR = EMPTY; LOCN = EMPTY
END ELSE EXTR = EMPTY; LOCN = ONE; IF SB NE EMPTY THEN LOCN = LOCN:':",,,":"':SB:'"'
*
CASE TRUE; VTYPE = EMPTY; EXTR = EMPTY; LOCN = EMPTY
*
END CASE
*
RETURN
!
~SOURCEGEN.START~
*CODE.SEGMENT: SOURCEGEN.START
*
* DAVID HORSMAN
LNS<-1> = '* PROGRAM:           SH.':SCREEN.ID
LNS<-1> = '* AUTHOR:            XXX'
LNS<-1> = '* DESCRIPTION:       GEN BY "SOURCEGEN" FROM "SCREEN.HANDLER"'
LNS<-1> = '* DATE WRITTEN:      ':OCONV(DATE(),"D2")
LNS<-1> = '* DATE RELEASED:     DD MMM YY'
LNS<-1> = '* MODIFICATIONS:     DATE       NAME        DESCRIPTION'
LNS<-1> = '*                    DD MMM YY'
LNS<-1> = '!'
LNS<-1> = 'INPUT DISP.ONLY'
LNS<-1> = '*'
LNS<-1> = '$INCLUDE IBP STANDARD.FUNCTIONS'
LNS<-1> = '*'
*
~SOURCEGEN.TRANSL~
*CODE.SEGMENT: SOURCEGEN.TRANSL
*
*
SAVE = AC:AM:VC:AM:SC:AM:REDISP:AM:TRUE.AC:AM:VTYPE:AM:VTYPE.VC:AM:VTYPE.FL:AM:SQ:AM:VF:AM:EXTR:AM:INST:AM:POSN:AM:LOCT:AM:LOCN:AM:OLD.LOCN:AM:FLNM
CURR.AC = CURR.AC + ONE
SIR.AC = CURR.AC; GOSUB EXTR.PMPT.DT
TRN.LNS<-ONE> = 'T':(TRN.NUM + 100)[TWO,TWO]:': *':AM:'*'
TRN.LNS<-ONE> = 'TRN.FLD = ':FLNM:EXTR
*
* Read item is an READV attribute reference
*           with TRN.FLD as the key
*   format: \XX99\AC\VC\SVC
*
IF DT<ONE,ONE,3> MATCHES "0N" THEN
TMP = INDEX(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".FILE",ONE)
IF NOT(TMP) THEN TMP = LEN(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>) + ONE
TMP2 = FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>[ONE,TMP - ONE]
TRN.LNS<-ONE> = 'READV TRN.FLD FROM ':TMP2:'.FILE,TR.FLD,':DT<ONE,ONE,3>:' ELSE TRN.FLD = EMPTY'
*
IF DT<ONE,ONE,5> NE EMPTY THEN
TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:',':DT<ONE,ONE,5>:'>'
END ELSE IF DT<ONE,ONE,4> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = TRN.FLD<ONE,':DT<ONE,ONE,4>:'>'
*
IF DT<ONE,ONE,6> NE EMPTY THEN TRN.LNS<-ONE> = 'TRN.FLD = FIELD(TRN.FLD,"':DT<ONE,ONE,6>[ONE,ONE]:'",':DT<ONE,ONE,6>[TWO,TWO]:')'
*
* Read item is and Item ID
*   format \XX99\Item.ID\locate.AC\display.AC
*       OR \XX99\Item.ID\locate.AC\2
*       OR \XX99\Item.ID\1\2
*
END ELSE
TMP = INDEX(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>,".FILE",ONE)
IF NOT(TMP) THEN TMP = LEN(FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>) + ONE
TMP2 = FLNMS<ONE,DT<ONE,ONE,TWO>[TWO,TWO]>[ONE,TMP - ONE]
READ.ITEM = TMP2:'*':DT<ONE,ONE,3>
LOCATE READ.ITEM IN READ.ITEMS SETTING READ.NUM ELSE READ.ITEMS<READ.NUM> = READ.ITEM
* TRN.LNS<-ONE> = 'LOCATE TRN.FLD IN ':DT<ONE,ONE,3>:'<ONE> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
TMP4 = DT<ONE,ONE,4>
TMP5 = DT<ONE,ONE,5>
TMP6 = 'LOCATE TRN.FLD IN ':DT<ONE,ONE,3>
IF LEN(TMP4) THEN
IF LEN(TMP5) THEN
TMP6 = TMP6:'<':TMP4:'> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<':TMP5:',LOC> ELSE TRN.FLD = EMPTY'
END ELSE
TMP6 = TMP6:'<':TMP4:'> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
END; * Of 5
END ELSE
TMP6 = TMP6:'<ONE> SETTING LOC THEN TRN.FLD = ':DT<ONE,ONE,3>:'<TWO,LOC> ELSE TRN.FLD = EMPTY'
END; * Of 4
TRN.LNS<-ONE> = TMP6
END
*
TRN.LNS<-ONE> = 'PRINT @(':CL:',LN):TRN.FLD "':MS:'":'
TRN.LNS<-ONE> = 'RETURN'
TRN.LNS<-ONE> = '*'
TRN.LNS<-ONE> = 'TC':(TRN.NUM + 100)[TWO,TWO]:': *'
TRN.LNS<-ONE> = 'PRINT @(':CL:',LN):SPACE(':LH:'):'
TRN.LNS<-ONE> = 'RETURN'
*
IF TF AND (LN OR CL) AND LH THEN
FOR TMP = LN TO LM
PRINT @(CL,TMP):RVB:STR("#",LH):RVE:
NEXT TMP
* RQM
END
*
TRN.NUM = TRN.NUM + ONE; TRANSL = EMPTY
AC = SAVE<ONE>; VC = SAVE<TWO>; SC = SAVE<3>; REDISP = SAVE<4>
TRUE.AC = SAVE<5>; VTYPE = SAVE<6>; VTYPE.VC = SAVE<7>; VTYPE.FL = SAVE<8>
SQ = SAVE<9>; VF = SAVE<10>; EXTR = SAVE<11>; INST = SAVE<12>
POSN = SAVE<13>; LOCT = SAVE<14>; LOCN = SAVE<15>; OLD.LOCN = SAVE<16>
FLNM = SAVE<17>
*
~STANDARD.CHARACTERS~
*CODE.SEGMENT: STANDARD.CHARACTERS
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 15 FEB 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
STB = "|"
STX = "~"
ESC = "`"
PICK.ESC = "<PCK>"
NUL = CHAR(0)
*
~STANDARD.COMMON.AREA~
*CODE.SEGMENT: STANDARD.COMMON.AREA
*
*SEC.USER
*SEC.USER.ID
*PAR.MENU
*PAR.MENU.ID
*CNT.TST
*CNT.TST.ID
*
*LOCKS
*
* SYS.SYST,ACCT,WHO,PORT
* OPSYS,TT,PT,AT
* GENERIC,CURSOR.KEYS
*
COMMON SYS,SYS.SYST,SYS.APPL,SYS.APPL.SUB,SYS.PROG,SYS.LOCT,SYS.LOCT.SUB
*
COMMON TYPE.RUN,AUTO.RUN,PHAN.RUN,DISP.RUN
COMMON RSP,RSPBUF
COMMON PROCBUF,TM.MAX
~STANDARD.FUNCTIONS~
*CODE.SEGMENT: STANDARD.FUNCTIONS
*
* WARNING: STANDARD.FUNCTIONS is to be INCLUDED in programs only.
*          Subroutines INCLUDE the code segment STANDARD.FUNCTIONS.SUBR
*          Device Control Subroutines INCLUDE STANDARD.FUNCTIONS.DVC
*
*          The .DVC routine was designed for communications
*           and printer sub-routine calls.
*
*          The .SUBR extension is now used in all called sub-routines.
*
*          One difference between the three code segments
*           being .DVC and .SUBR do not output screen escape
*           sequences. They also expect system controls and
*           screen escape sequences to be passed unchanged
*           either in the CA-LL or thru COM-MON area.
*
*          It is especially important to use the .DVC version when
*          working with programs in Axion's K-bil Sub-Applications such as
*             - Counter Cash
*             - Addressable Interface
*             - Work Order Printing
*             - EFT Communication Programs
*             - Genie (by its open structure)
*
*          And Utility Routines such as
*              -Communications
*              -Auxilary Port Handling/Printing
*              -Menus
*              -Screen Handling
*              -Functions like Unpack Number, Lock.Item, MOD11.DIGIT
*
*
*
! Standard characters
*
*%%MDD%%=**
EMPTY = ""; ZERO = 0; ONE = 1; TWO = 2
FALSE = ""; TRUE = 1; STAT = ""
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254); ESC = CHAR(27)
*
! Screen Escape Sequences
*
RVBW = EMPTY; RVB = EMPTY; RVE = EMPTY; RVH = EMPTY
CLL = EMPTY; CLS = EMPTY; CLB = EMPTY
AUX.ON = EMPTY; AUX.OFF = EMPTY
COL.ON = EMPTY; COL.OFF = EMPTY
CLB0 = EMPTY; CLB1 = EMPTY; CLB2 = EMPTY; CLB3 = EMPTY; * 20,21,22,23
*
! System Information
*
WHO = ICONV(0,"U50BB"); * ULT ONLY
* WHO = @USER0; * REV ONLY
PORT = (FIELD(WHO," ",ONE)+1000)[TWO,3]; ACCT = FIELD(WHO," ",TWO)
OPSYS = "U"; * ULT ONLY
* OPSYS = "P"; PCK ONLY
* OPSYS = "R"; * REV ONLY
*%%MDD%%=OPSYS = "M"; * MDD ONLY
TT = SYSTEM(7); * INST SUPP; * ULT ONLY
* TT = EMPTY; * REV ONLY
PT = EMPTY; AT = EMPTY
*
! Software Control
*
RSP = EMPTY; RSPBUF = EMPTY; * SUBR
* SUBR
GENERIC = FALSE; * ULT ONLY
* SUBR
* GENERIC = FIELD(@USER0," ",3); * REV ONLY
TYPE.RUN = "S"; AUTO.RUN = EMPTY; PHAN.RUN = EMPTY; * SUBR
DISP.ONLY = EMPTY; REDISP = EMPTY; * SUBR
TRC = EMPTY; TM.MAX = 0; * SUBR
PROCBUF = EMPTY; RSPLOG = EMPTY; * SUBR
*
! Screen Attributes
*
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN
CLB = @(ZERO,23); CLB0 = @(ZERO,20); CLB1 = @(ZERO,21); CLB2 = @(ZERO,22); CLB3 = @(ZERO,23)
END ELSE
CLB = @(ZERO,23):CLL; CLB0 = @(ZERO,20):CLL; CLB1 = @(ZERO,21):CLL; CLB2 = @(ZERO,22):CLL; CLB3 = @(ZERO,23):CLL
END
*
BEGIN CASE
*
CASE OPSYS EQ "R"
RVB = CHAR(27):"00"; RVE = CHAR(27):"0A"; RVH = CHAR(27):"01"
AUX.ON = EMPTY; AUX.OFF = EMPTY
*
CASE TT EQ "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
CASE TT EQ "R" AND OPSYS EQ "M"
RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TT EQ "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(18):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):3; AUX.OFF = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(20):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):4
* SUBR
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":; * ULT ONLY
*
CASE TT EQ "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
*
CASE TT EQ "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TT EQ "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TT EQ "E"
RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TT EQ "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TRUE; RVB = EMPTY; RVE = EMPTY; RVH = EMPTY; AUX.ON = EMPTY; AUX.OFF = EMPTY
END CASE
RVBW = RVB
*
! Software Location Information
*
SYS.SYST = EMPTY; SYS.APPL = EMPTY; SYS.APPL.SUB = EMPTY
SYS.PROG = EMPTY; SYS.LOCT = EMPTY; SYS.LOCT.SUB = EMPTY
SYS.ID = EMPTY ; REL.ID = EMPTY ; VER.ID = EMPTY
*
! SUBROUTINE INPUT.DATA.SG1(
*
* FILE.NAME = EMPTY; ITEM.NAME = EMPTY; ITEM = EMPTY
* CL = EMPTY; LN = EMPTY; LH = EMPTY; LHM = EMPTY
* LOCN = EMPTY; CONV = EMPTY; EDITS = EMPTY; EDIT.FILE = EMPTY
* SEC.USER.ID = EMPTY; CURSOR.KEYS = EMPTY
* NUMC = EMPTY; FIXED = EMPTY; DEF.SUPP = EMPTY; TC.FUNC = EMPTY
* RSP.CL = EMPTY; RSP.LN = EMPTY; TC.FILL = EMPTY
* STD.SUBR.NAME = EMPTY
* )
*
! Temporary & Other
*
* PG = EMPTY; LINE = EMPTY; TEXT = EMPTY; TMP = EMPTY
* DT = EMPTY; TM = EMPTY
* CN = EMPTY; LOC = EMPTY
* MAX = EMPTY
*
~STANDARD.FUNCTIONS.CHARACTERS~
*CODE.SEGMENT: STANDARD.FUNCTIONS.CHARACTERS
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: JUN 85
* Used with permission 1986, 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
* (c) Copyright 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990
* Axion Computer Software Ltd.
*
STB = "|"
STX = "~"
ESC = "`"
PICK.ESC = "<PCK>"
NUL = CHAR(0)
*
!
STANDARD.FUNCTIONS: *
*
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13)
*ESC TO CHAR(27), PICK.ESC TO CHAR(??),NUL TO CHAR(0)
*STB TO "|", STX TO CHAR(2), ETX TO CHAR(3)
*
* SUB-VALUE MARK, VALUE MARK, ATTRIBUTE MARK
*FIELD ATTR MARK, FIELD VALUE MARK, FIELD SUB-VALUE MARK
*KEY SEPARATOR, FIELD SEPARATOR
EQUATE SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254),
FAM TO "@",FVM TO "*",FSVM TO "#",
KSEP TO "@",DSEP TO "*"
*
EQUATE TRUE TO 1, FALSE TO ""
*
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+1000)[2,3]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
T132.ON = ""; T132.OFF = ""
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
* IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
~STANDARD.FUNCTIONS.CLB~
*CODE.SEGMENT: STANDARD.FUNCTIONS.CLB
*
*
IF GENERIC THEN
CLB = @(ZERO,23); CLB0 = @(ZERO,20); CLB1 = @(ZERO,21); CLB2 = @(ZERO,22); CLB3 = @(ZERO,23)
END ELSE
CLB = @(ZERO,23):CLL; CLB0 = @(ZERO,20):CLL; CLB1 = @(ZERO,21):CLL; CLB2 = @(ZERO,22):CLL; CLB3 = @(ZERO,23):CLL
END
*
~STANDARD.FUNCTIONS.DVC~
*CODE.SEGMENT: STANDARD.FUNCTIONS.SUBR
*
* WARNING: STANDARD.FUNCTIONS is to be INCLUDED in programs only.
*          Subroutines INCLUDE the code segment STANDARD.FUNCTIONS.SUBR
*          Device Control Subroutines INCLUDE STANDARD.FUNCTIONS.DVC
*
*          The .DVC routine was designed for communications
*           and printer sub-routine calls.
*
*          The .SUBR extension is now used in all called sub-routines.
*
*          One difference between the three code segments
*           being .DVC and .SUBR do not output screen escape
*           sequences. They also expect system controls and
*           screen escape sequences to be passed unchanged
*           either in the CALL or thru COMMON area.
*
*          It is especially important to use the .DVC version when
*          working with programs in Axion's K-bil Sub-Applications such as
*             - Counter Cash
*             - Addressable Interface
*             - Work Order Printing
*             - EFT Communication Programs
*             - Genie (by its open structure)
*
*          And Utility Routines such as
*              -Communications
*              -Auxilary Port Handling/Printing
*              -Menus
*              -Screen Handling
*              -Functions like Unpack Number, Lock.Item, MOD11.DIGIT
*
*
*
! Standard characters
*
*%%MDD%%=**
EMPTY = ""; ZERO = 0; ONE = 1; TWO = 2
FALSE = ""; TRUE = 1; STAT = ""
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254); ESC = CHAR(27)
*
! Screen Escape Sequences
*
RVBW = EMPTY; RVB = EMPTY; RVE = EMPTY; RVH = EMPTY
CLL = EMPTY; CLS = EMPTY; CLB = EMPTY
AUX.ON = EMPTY; AUX.OFF = EMPTY
COL.ON = EMPTY; COL.OFF = EMPTY
CLB0 = EMPTY; CLB1 = EMPTY; CLB2 = EMPTY; CLB3 = EMPTY; * 20,21,22,23
*
! System Information
*
WHO = ICONV(0,"U50BB"); * ULT ONLY
* WHO = @USER0; * REV ONLY
PORT = (FIELD(WHO," ",ONE)+1000)[TWO,3]; ACCT = FIELD(WHO," ",TWO)
OPSYS = "U"; * ULT ONLY
* OPSYS = "P"; PCK ONLY
* OPSYS = "R"; * REV ONLY
*%%MDD%%=OPSYS = "M"; * MDD ONLY
TT = SYSTEM(7); * ULT ONLY
* TT = EMPTY; * REV ONLY
PT = EMPTY; AT = EMPTY
*
! Software Control
*
* RSP = EMPTY; RSPBUF = EMPTY; * SUBR
* SUBR
GENERIC = FALSE; * ULT ONLY
* SUBR
* GENERIC = FIELD(@USER0," ",3); * REV ONLY
* TYPE.RUN = "S"; AUTO.RUN = EMPTY; PHAN.RUN = EMPTY; * SUBR
* DISP.ONLY = EMPTY; REDISP = EMPTY; * SUBR
* TRC = EMPTY; TM.MAX = 0; * SUBR
* PROCBUF = EMPTY; RSPLOG = EMPTY; * SUBR
*
! Screen Attributes
*
CLS = @(-3); CLL = @(-4)
** ; PROMPT CHAR(0)
IF GENERIC THEN
CLB = @(ZERO,23); CLB0 = @(ZERO,20); CLB1 = @(ZERO,21); CLB2 = @(ZERO,22); CLB3 = @(ZERO,23)
END ELSE
CLB = @(ZERO,23):CLL; CLB0 = @(ZERO,20):CLL; CLB1 = @(ZERO,21):CLL; CLB2 = @(ZERO,22):CLL; CLB3 = @(ZERO,23):CLL
END
*
** BEGIN CASE
** *
** CASE OPSYS EQ "R"
** RVB = CHAR(27):"00"; RVE = CHAR(27):"0A"; RVH = CHAR(27):"01"
** AUX.ON = EMPTY; AUX.OFF = EMPTY
** *
** CASE TT EQ "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
** *
** CASE TT EQ "R" AND OPSYS EQ "M"
** RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
** CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
** *
** CASE TT EQ "R"
** RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(18):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):3; AUX.OFF = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(20):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):4
** * SUBR
** * IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":; * ULT ONLY
** *
** CASE TT EQ "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
** *
** CASE TT EQ "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
** CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
** *
** CASE TT EQ "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
** CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
** *
** CASE TT EQ "E"
** RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
** CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
** *
** CASE TT EQ "H"
** RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
** AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
** CLL = CHAR(15); CLS = CHAR(23)
** *
** CASE TRUE; RVB = EMPTY; RVE = EMPTY; RVH = EMPTY; AUX.ON = EMPTY; AUX.OFF = EMPTY
** END CASE
** *
! Software Location Information
*
SYS.SYST = EMPTY; SYS.APPL = EMPTY; SYS.APPL.SUB = EMPTY
* SYS.PROG = EMPTY; SYS.LOCT = EMPTY; SYS.LOCT.SUB = EMPTY
SYS.ID = EMPTY ; REL.ID = EMPTY ; VER.ID = EMPTY
*
! SUBROUTINE INPUT.DATA.SG1(
*
* FILE.NAME = EMPTY; ITEM.NAME = EMPTY; ITEM = EMPTY
* CL = EMPTY; LN = EMPTY; LH = EMPTY; LHM = EMPTY
* LOCN = EMPTY; CONV = EMPTY; EDITS = EMPTY; EDIT.FILE = EMPTY
* SEC.USER.ID = EMPTY; CURSOR.KEYS = EMPTY
* NUMC = EMPTY; FIXED = EMPTY; DEF.SUPP = EMPTY; TC.FUNC = EMPTY
* RSP.CL = EMPTY; RSP.LN = EMPTY; TC.FILL = EMPTY
* STD.SUBR.NAME = EMPTY
* )
*
! Temporary & Other
*
* PG = EMPTY; LINE = EMPTY; TEXT = EMPTY; TMP = EMPTY
* DT = EMPTY; TM = EMPTY
* CN = EMPTY; LOC = EMPTY
* MAX = EMPTY
*
~STANDARD.FUNCTIONS.DVC.SCR~
*CODE.SEGMENT: STANDARD.FUNCTIONS.DVC.SCR
*
* WARNING: STANDARD.FUNCTIONS is to be INCLUDED in programs only.
*          Subroutines INCLUDE the code segment STANDARD.FUNCTIONS.SUBR
*          Device Control Subroutines INCLUDE STANDARD.FUNCTIONS.DVC
*
*          The .DVC routine was designed for communications
*           and printer sub-routine calls.
*
*          The .SUBR extension is now used in all called sub-routines.
*
*          One difference between the three code segments
*           being .DVC and .SUBR do not output screen escape
*           sequences. They also expect system controls and
*           screen escape sequences to be passed unchanged
*           either in the CALL or thru COMMON area.
*
*          It is especially important to use the .DVC version when
*          working with programs in Axion's K-bil Sub-Applications such as
*             - Counter Cash
*             - Addressable Interface
*             - Work Order Printing
*             - EFT Communication Programs
*             - Genie (by its open structure)
*
*          And Utility Routines such as
*              -Communications
*              -Auxilary Port Handling/Printing
*              -Menus
*              -Screen Handling
*              -Functions like Unpack Number, Lock.Item, MOD11.DIGIT
*
*
*
! Standard characters
*
! Screen Escape Sequences
*
RVB = EMPTY; RVE = EMPTY; RVH = EMPTY
CLL = EMPTY; CLS = EMPTY; CLB = EMPTY
AUX.ON = EMPTY; AUX.OFF = EMPTY
COL.ON = EMPTY; COL.OFF = EMPTY
CLB0 = EMPTY; CLB1 = EMPTY; CLB2 = EMPTY; CLB3 = EMPTY; * 20,21,22,23
*
~STANDARD.FUNCTIONS.READ~
*CODE.SEGMENT: STANDARD.FUNCTIONS.READ
*
PORT = (FIELD(ICONV(0,"U50BB")," ",1) + 1000)[2,3]
*
OPEN "DICT","TERMINAL.FILE" TO TERM.TEMP THEN
READV TT FROM TERM.TEMP,"TERMINALS",PORT + 1 ELSE TT = "R"
END ELSE
TT = "R"
END
*
~STANDARD.FUNCTIONS.SUBR~
*CODE.SEGMENT: STANDARD.FUNCTIONS.SUBR
*
* WARNING: STANDARD.FUNCTIONS is to be INCLUDED in programs only.
*          Subroutines INCLUDE the code segment STANDARD.FUNCTIONS.SUBR
*          Device Control Subroutines INCLUDE STANDARD.FUNCTIONS.DVC
*
*          The .DVC routine was designed for communications
*           and printer sub-routine calls.
*
*          The .SUBR extension is now used in all called sub-routines.
*
*          One difference between the three code segments
*           being .DVC and .SUBR do not output screen escape
*           sequences. They also expect system controls and
*           screen escape sequences to be passed unchanged
*           either in the CALL or thru COMMON area.
*
*          It is especially important to use the .DVC version when
*          working with programs in Axion's K-bil Sub-Applications such as
*             - Counter Cash
*             - Addressable Interface
*             - Work Order Printing
*             - EFT Communication Programs
*             - Genie (by its open structure)
*
*          And Utility Routines such as
*              -Communications
*              -Auxilary Port Handling/Printing
*              -Menus
*              -Screen Handling
*              -Functions like Unpack Number, Lock.Item, MOD11.DIGIT
*
*
*
! Standard characters
*
*%%MDD%%=**
EMPTY = ""; ZERO = 0; ONE = 1; TWO = 2
FALSE = ""; TRUE = 1; STAT = ""
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254); ESC = CHAR(27)
*
! Screen Escape Sequences
*
RVB = EMPTY; RVE = EMPTY; RVH = EMPTY
CLL = EMPTY; CLS = EMPTY; CLB = EMPTY
AUX.ON = EMPTY; AUX.OFF = EMPTY
COL.ON = EMPTY; COL.OFF = EMPTY
CLB0 = EMPTY; CLB1 = EMPTY; CLB2 = EMPTY; CLB3 = EMPTY; * 20,21,22,23
*
! System Information
*
WHO = ICONV(0,"U50BB"); * ULT ONLY
* WHO = @USER0; * REV ONLY
PORT = (FIELD(WHO," ",ONE)+1000)[TWO,3]; ACCT = FIELD(WHO," ",TWO)
OPSYS = "U"; * ULT ONLY
* OPSYS = "P"; PCK ONLY
* OPSYS = "R"; * REV ONLY
*%%MDD%%=OPSYS = "M"; * MDD ONLY
TT = SYSTEM(7); * INST SUPP; * ULT ONLY
* TT = EMPTY; * REV ONLY
PT = EMPTY; AT = EMPTY
*
! Software Control
*
* RSP = EMPTY; RSPBUF = EMPTY; * SUBR
* SUBR
GENERIC = FALSE; * ULT ONLY
* SUBR
* GENERIC = FIELD(@USER0," ",3); * REV ONLY
* TYPE.RUN = "S"; AUTO.RUN = EMPTY; PHAN.RUN = EMPTY; * SUBR
* DISP.ONLY = EMPTY; REDISP = EMPTY; * SUBR
* TRC = EMPTY; TM.MAX = 0; * SUBR
* PROCBUF = EMPTY; RSPLOG = EMPTY; * SUBR
*
! Screen Attributes
*
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN
CLB = @(ZERO,23); CLB0 = @(ZERO,20); CLB1 = @(ZERO,21); CLB2 = @(ZERO,22); CLB3 = @(ZERO,23)
END ELSE
CLB = @(ZERO,23):CLL; CLB0 = @(ZERO,20):CLL; CLB1 = @(ZERO,21):CLL; CLB2 = @(ZERO,22):CLL; CLB3 = @(ZERO,23):CLL
END
*
BEGIN CASE
*
CASE OPSYS EQ "R"
RVB = CHAR(27):"00"; RVE = CHAR(27):"0A"; RVH = CHAR(27):"01"
AUX.ON = EMPTY; AUX.OFF = EMPTY
*
CASE TT EQ "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
CASE TT EQ "R" AND OPSYS EQ "M"
RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TT EQ "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(18):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):3; AUX.OFF = CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(20):CHAR(0):CHAR(0):CHAR(0):CHAR(0):CHAR(27):4
* SUBR
* IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":; * ULT ONLY
*
CASE TT EQ "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
*
CASE TT EQ "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TT EQ "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TT EQ "E"
RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TT EQ "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TRUE; RVB = EMPTY; RVE = EMPTY; RVH = EMPTY; AUX.ON = EMPTY; AUX.OFF = EMPTY
END CASE
*
! Software Location Information
*
SYS.SYST = EMPTY; SYS.APPL = EMPTY; SYS.APPL.SUB = EMPTY
* SYS.PROG = EMPTY; SYS.LOCT = EMPTY; SYS.LOCT.SUB = EMPTY
SYS.ID = EMPTY ; REL.ID = EMPTY ; VER.ID = EMPTY
*
! SUBROUTINE INPUT.DATA.SG1(
*
* FILE.NAME = EMPTY; ITEM.NAME = EMPTY; ITEM = EMPTY
* CL = EMPTY; LN = EMPTY; LH = EMPTY; LHM = EMPTY
* LOCN = EMPTY; CONV = EMPTY; EDITS = EMPTY; EDIT.FILE = EMPTY
* SEC.USER.ID = EMPTY; CURSOR.KEYS = EMPTY
* NUMC = EMPTY; FIXED = EMPTY; DEF.SUPP = EMPTY; TC.FUNC = EMPTY
* RSP.CL = EMPTY; RSP.LN = EMPTY; TC.FILL = EMPTY
* STD.SUBR.NAME = EMPTY
* )
*
! Temporary & Other
*
* PG = EMPTY; LINE = EMPTY; TEXT = EMPTY; TMP = EMPTY
* DT = EMPTY; TM = EMPTY
* CN = EMPTY; LOC = EMPTY
* MAX = EMPTY
*
~STAT.BEGIN~
*CODE.SEGMENT: STAT.BEGIN
*
* EMPTY
*
~STAT.CRITERIA~
*CODE.SEGMENT:      STAT.CRITERIA
* VERSION: 920410 263 REGF&LPI6-PASSED-TO-GENERATE.STMT.MASK
* PRIOR: 911008 263  ANNUAL.NOTICE.MONTH.RECEIVED.FROM.STAT.SUB.INPUT
* PRIOR: 910801 263  PRINT.MASK.IS.NOW.IN.CALL.TO.'GENERATE.STMT.MASK'
* PRIOR: 910724 263  IF.GET.LIST.THEN.BYPASS.ALL.EXLN.CODE
* PRIOR: 900124
* PRIOR: 890725
* DESCRIPTION:       PRINT STATEMENTS
*
* AUTHOR:            31 MAY 87  D. HORSMAN  FROM STATEMENTS.9.5X7.3
*                               Split off validation and
*                               standardize all statement formats.
!
REJECTED.DESC = ""
*
CTR = 0; STMT.COUNT = 0; ACR = 1; FR.FLAG = 0; TO.FLAG = 0
STMT.COUNT.MPG = 0; ACT.ID = ""
FR.ACT = STR("0",6); TO.ACT = STR("9",6); SINGLE = 0
INPUTS = ''; LPI6 = ''; LPI8 = ''
*
LN = 4; RNTP.RSP = ""
INPUT AUTO.RUN
IF AUTO.RUN THEN READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
*
CALL STAT.SUBR.INPUT(PAR.FILE,MXACR,PMT.N.S,RECALC.DISC,PCODE.SORT,SYS.PROG,CNT.FILE,RQC,DBTW,TT.PMT,TT.ADJ,TT.DEP,CCR,MDQA,MDQS,MDD,DCR,PYM,SYS.TST,MTP,MAT MG,MAT MG.LGTH,CO.NAME,RNTP.RSP,ST.IDATE,PYDD,FR.ACT,TO.ACT,LFL,HF,HC,AUTO.RUN,MAT BMG,REJECTED.DESC,FCV,FCN,CLC,LN,BFS,BFS.ANN,MAT TDSC,ST.PRDT,DISC.DATE,TM,RPR,RNTP,BILLING.CYCLES,CYCSEL,MXPRT,INRNG,SINGLE,INPUTS,CURRENT.RUN,GEN,AN.NO,DFL)
*
IF HF AND NOT(AUTO.RUN OR SINGLE) THEN CALL AUTO.LOADER(SYS.PROG,INPUTS,"Statements")
!
*
IF DISC.DATE EQ "CALC" THEN DISC.DATE = ""
IF NOT(RPR) THEN FR.FLAG = 1
IF SYS.TST<8> AND SYS.TST<1> THEN
TDY = ICONV(SYS.TST<6>,"D")
IF OCONV(TDY,'D2') = '' THEN TDY = DATE()
IF OCONV(TDY,'D2') = '31 DEC 67' THEN TDY = DATE()
END
IF OPSYS = "R" THEN HOLD.FILES = 0 ELSE READV HOLD.FILES FROM PAR.FILE, "STATEMENT.HOLD.FILES",1 ELSE HOLD.FILES = 0
READ CITIES FROM PAR.FILE,"CITIES" ELSE CITIES = ""
READ WOT FROM PAR.FILE,"WORK.ORDER.TYPES" ELSE WOT = ""
*
LN = LN+2
DISP.LN = LN
CLS.COL = 0; CLS.ROW = DISP.LN; GOSUB CLS.ROUTINE 
*
SELECT SVC.FILE
MSG.SVC.ID = ""; MSG.SVC.CODE = ""
LOOP
READNEXT SVC.ID ELSE SVC.ID = ""
UNTIL SVC.ID = "" DO
READ SVC FROM SVC.FILE,SVC.ID THEN
IF SVC<10> # "" THEN
LOCATE SVC<10> IN MTP<1> SETTING MN THEN
IF MG(MN) # "" THEN MSG.SVC.ID<-1> = SVC.ID; MSG.SVC.CODE<-1> = SVC<10>
END
END
END
REPEAT
*#
LATE.BAL = "Previous balance"
LOCATE "B" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN LATE.BAL = TMP
END
TMP = ""; THIRTY.D.MG = ""
LOCATE "T" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN THIRTY.D.MG = TMP
END
*#
IF FR.ACT EQ TO.ACT AND FR.ACT # "000000" THEN SINGLE = 1
IF FR.ACT EQ "000000" THEN FR.FLAG = 1
*
PTY = EMPTY; PQUE = EMPTY; PQUE.FUNC = "START"
CALL STAT.SUBR.PTR(PAR.FILE,PTY,PQUE,PQUE.FUNC,PTR.ON,PTR.OFF,REGF,COMF,C12.FONT,C12.FONT.CR,CRCOM78,CRCOM72,CRCOMF,LPI6,LPI8)
*
IF FIRST AND NOT(SINGLE OR GEN) THEN
IF OPSYS = "R" THEN PRINT CLB:RVB:"Now printing Statement Mask":RVE:
CALL GENERATE.STMT.MASK(REGF,LPI6,COMF,CRCOM78,THIRTY.D.MG,SYS.TST,SYS.PROG,VERSION,MXACR,ACR,PMT.N.S,FIRST,SINGLE,MAT PL)
GOSUB PSTMTS; FIRST = ""; PRINT CLB:
END
IF NOT(SINGLE) THEN
PRINT @(0,DISP.LN):"Now selecting accounts":@(0,DISP.LN+1)
*
IF SYS.TST<1> AND SYS.TST<5> # "" THEN
* EXLN = 'GET-LIST ':SYS.TST<5>; * REV ONLY
* ULT ONLY
EXLN = 'GET-LIST ':SYS.TST<5>:', //SELECT. > ACT.ID.LIST'
EXECUTE EXLN
END ELSE
EXLN = ''
IF PCODE.SORT THEN EXLN = EXLN:"BY SORT.PCODE "
IF NOT(FR.ACT EQ "000000" AND TO.ACT EQ "999999") THEN
EXLN = EXLN:'WITH ID >= "':FR.ACT:'" AND WITH ID <= "':TO.ACT:'" AND '
END
IF RPR THEN
EXLN = EXLN:'WITH LAST.STMT.DATE = "':OCONV(ST.PRDT,'D2'):'" AND WITH BAL >= "':OCONV(MDQA,"MR2"):'"'
END ELSE
EXLN = EXLN:'WITH STAT # "C" AND WITH BAL >= "':OCONV(MDQA,"MR2"):'"'
IF RNTP = 1 THEN
EXLN = EXLN:' AND WITH CS GE "':MDQS:'" OR WITH STAT EQ "D" AND WITH BAL >= "':OCONV(MDQA,"MR2"):'"'
END ELSE
IF COUNT(BFS,",") < 5 THEN
TEMP = 1
CN = 1
LOOP BF = BFS[CN,1] WHILE BF # '' DO
IF (LFL OR RNTP.RSP = 'SELECT') AND BF # '' THEN
IF TEMP THEN EXLN = EXLN:' AND WITH BILL.FREQS '; TEMP = '' ELSE
EXLN = EXLN:' OR '
END
IF BF EQ "^" THEN BF = ""
EXLN = EXLN:'"':BF:'"'
END
CN = CN + 2
REPEAT
END
END
END
PRINT
IF SYS.TST<1> THEN PRINT EXLN
PRINT
EXECUTE "SSELECT ACT ":EXLN
END
*
PRINT BELL:
RQM; RQM; RQM; RQM
PRINT BELL:
PRINT @(0,DISP.LN):CLL:"Selection of accounts completed":@(0,DISP.LN):
*
END ELSE
PRINT @(0,DISP.LN)
PRINT
PRINT "Print the account ":FR.ACT:"."
PRINT
END
MPG.RUN = ""; MPG.IDS = ""
OLCA = ""; RTO.ADD = ""; MXPRT.ABORT = ""
RTO.ADD1 = ""; RTO.ADD2 = ""; RTO.ADD3 = ""; RTO.ADD4 = ""
IF MXPRT THEN MXPRT = MXPRT - 2
*
* INTERUPT.LINE = "Use ":RVB:"F1":RVE:" to INTERUPT after next statement, then ":RVB:"F3":RVE:" to CONTINUE statement printing"; * REV ONLY
* IF NOT(SINGLE) THEN PRINT @(0,23):INTERUPT.LINE:; * REV ONLY
!
*#
~STAT.MAIN.LOOP~
*CODE.SEGMENT:      STAT.MAIN.LOOP
* VERSION: 920128 263  MOVE-SETTING-OF-STAT.TY-TO-B4-IF-RPR
* PRIOR: 911009 2.6  MATREAD.CHANGED.TO.READ.OF.STT.AND.EFT
* PRIOR: 910513 2.6  TO.FORCE.PRINTING.OF.ALL.INACTIVE.EFTS
* PRIOR: 900211 2.6 ADDED.ATR.TYPE.T-TAX.CHANGE
* PRIOR: 910116 2.6  WAS.NOT.UNLOCKING.IF.NOT.STATEMENT.CYCLE
* PRIOR: 900719 2.1
* PRIOR: 890818
* COPYRIGHT          AXION COMPUTER SYSTEMS LTD.
*   1984                 ALL RIGHTS RESERVED
*
* DESCRIPTION:       PRINT STATEMENTS
*                      PROCESS ACT FILE
*                      ANALYZE ACTS FOR STMT GENERATION
*                      MOVE ATR TO ATH
*                      GET.NADDS: BUILD MAILING NAME AND ADDRESS
*                      RUN MODES FROM MENU:
*                          REGULAR = RTNP 0, LFL 0
*                          LATES          1      1
*                          BOTH           2      1
*
*                    SYS.TST<6> TIMING ON
*                    SYS.TST<9> PRINT SUPPRESSION
*                    SYS.TST<8> SETS DISPLAY ON IN GET.NADDS
!
IF SYS.TST<1> THEN TEST.ON = 1 ELSE TEST.ON = 0
IF SYS.TST<2> AND TEST.ON THEN DSR = 1 ELSE DSR = 0
IF RNTP = 1 THEN LFL = 1
*
!
*
NXT: *
*
RJT.FL = ""
*
IF MXPRT AND STMT.COUNT GE MXPRT AND NOT(MPG.RUN) THEN GOTO FINISH
*
IF TO.FLAG THEN MPG.RUN = 1
*
IF MPG.RUN THEN
ACT.ID = MPG.IDS<1>
IF ACT.ID = "" THEN GOTO FINISH
DEL MPG.IDS<1,0,0>
STMT.COUNT.MPG = STMT.COUNT.MPG + 1
END ELSE
*
IF SINGLE THEN ACT.ID = FR.ACT ELSE
READNEXT ACT.ID ELSE MPG.RUN = 1; GOTO NXT
END
IF ACT.ID = TO.ACT AND TO.ACT # "999999" THEN TO.FLAG = 1
IF ACT.ID = FR.ACT AND FR.ACT # "000000" THEN FR.FLAG = 1
END
*
IF NOT(SINGLE) THEN
*
GOSUB STD.DELAY
*
END
*
*
IF OPSYS = "R" THEN
INPUT ALERT,-1
INPUTCLEAR
IF ALERT = CHAR(0):CHAR(59) THEN GOSUB CALL.MENU
END
*
IF NOT(RPR) OR RECALC.DISC THEN
LOOP STAT = -1; CALL LOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE,STAT) WHILE STAT DO REPEAT
END
SKIP.FLAG = 0
MATREAD ACT FROM ACT.FILE,ACT.ID THEN
IF NOT(SINGLE) AND BILLING.CYCLES # "" THEN
TMP = ACT$BILL.DAY+0
LOCATE TMP IN BILLING.CYCLES<1> BY "AR" SETTING CYC.NUM ELSE NULL
IF BILLING.CYCLES<1,CYC.NUM> = "" THEN CYC.NUM = 1
IF FIELD(CYCSEL,"*",CYC.NUM) # "Y" THEN SKIP.FLAG = 1
END
IF NOT(SKIP.FLAG) THEN
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = ""
MATREAD ADD FROM ADD.FILE,ACT$ADD.ID THEN
GOSUB EXDATA
END ELSE RJT.FL = 1; *** Address data is missing
END; * OF SKIP.FLAG
END ELSE RJT.FL = 2; *** Account data is missing
IF NOT(RPR) OR RECALC.DISC THEN CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LCK.FILE)
IF RJT.FL THEN
IF TEST.ON THEN REJECTED.ACCTS<-1> = ACT.ID:VM:RJT.FL
IF SINGLE OR SYS.TST<1> THEN
IF SINGLE AND (RJT.FL = 12 OR RJT.FL = 11) AND NOT(RPR) THEN
IF SYS.TST<1> THEN PRINT CLB:"Rejected -  (":REJECTED.DESC<RJT.FL>:"). Trying a reprint! ":
RPR = 1; RECALC.DISC = 0; TO.FLAG = 0
GOTO NXT
END
IF SYS.TST<1> THEN PRINT CLB:"Rejected - Reason: ":RJT.FL:". Enter <cr> ":; INPUT TMP:
END
END
IF SYS.TST<2> = "2" AND TEST.ON THEN
PRINT CLB:"Exiting NXT":; INPUT TMP:
END
IF SINGLE THEN MPG.RUN = 1
GOTO NXT
!
EXDATA: *
IF DSR THEN
PRINT CLB:"EXDATA":; INPUT TMP:
END
IF (ACT$STAT = "C"  OR ACT$CREDIT.STATUS GE 9) THEN RJT.FL = 3; RETURN; *** Account Status is in collections
* RJT.FL 7 IS NOW AVAILABLE
*
BFS.FL = ""
ANN.FL = ""
STAT.TY = RNTP+1
STAT.TY.CN = 0
LOOP STAT.TY.CN = STAT.TY.CN + 1 WHILE ACT$BILL.FREQS<1,STAT.TY.CN> # "" DO
IF NOT(BFS.FL) THEN
IF ACT$BILL.FROM.DATES<1,STAT.TY.CN> GT ACT$LAST.STMT.DATE AND INDEX(BFS,ACT$BILL.FREQS<1,STAT.TY.CN>,1) # 0 AND ACT$EFT.BILLING<1,STAT.TY.CN> # "Y" THEN BFS.FL = 1
END
IF ACT$BILL.FROM.DATES<1,STAT.TY.CN> GT ACT$LAST.STMT.DATE AND ACT$BILL.FREQS<1,STAT.TY.CN> = "Y" AND ACT$EFT.BILLING<1,STAT.TY.CN> # "Y" THEN ANN.FL = 1
REPEAT
IF BFS.ANN THEN
IF ANN.FL THEN STAT.TY = 3 ELSE STAT.TY = 2
END
*
IF RPR THEN
LAST.VC = ""
VC = 1
LOOP
TTY = ATR$TYPES<1,VC>
IF TTY = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
IF SINGLE OR EDT = ST.PRDT THEN
MGI = ATR$REFS<1,VC>; IF MGI # "" AND MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
IF LAST.VC = "" THEN LAST.VC = VC+1
END ELSE IF EDT LT ST.PRDT THEN TTY = ""
END
UNTIL TTY = "" DO VC = VC+1 REPEAT
IF NOT(LAST.VC) THEN RJT.FL = 8; RETURN; *** No statement to reprint
PST.VC = VC
IF ACT$LAST.STMT.DATE # ST.PRDT THEN RJT.FL = 12; RETURN; *** Not a reprint
IF FR.FLAG THEN GOSUB GEN.STMT; RETURN
END ELSE
LOCATE "S" IN ATR$TYPES<1> SETTING PST.VC ELSE LOCATE "" IN ATR$TYPES<1> SETTING PST.VC ELSE NULL
IF ATR$EFF.DATES = "" THEN RJT.FL = 9; RETURN; *** Account was never billed (not trans.)
LAST.VC = 1
END
*
CDEB = 0; TFL = ""; BFL = ""; FND = ""
FOR VC = LAST.VC TO PST.VC-1 UNTIL FND
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
IF TMT GT 0 THEN TFL = 1; CDEB = CDEB+TMT
IF COUNT("BRTW",TTY) THEN TFL = 1
IF TTY = "B" THEN
IF NOT(BFL) THEN BFL = VC ELSE FND = 1
END
NEXT VC
*
IF LFL AND NOT(ACT$STAT = "D" AND INDEX(BFS,"^",1)) AND NOT(TFL) THEN STAT.TY = 1
IF ACT$STAT = "D" AND ACT$CREDIT.STATUS LT MDQS THEN STAT.TY = 4
*
AGD = FIELD(ACT$AGED.AMTS,"*",1)
AGD<2> = FIELD(ACT$AGED.AMTS,"*",2)
AGD<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGD<4> = FIELD(ACT$AGED.AMTS,"*",4)
AGT = AGD<2>+AGD<3>+AGD<4>; IF CDEB THEN AGT = AGT+AGD<1>
*
IF NOT(ACT$STAT = "D" AND INDEX(BFS,"^",1)) THEN
EFT.BILLING = 0
TMP = ACT$PAY.METHOD; IF TMP[1,3] = "CUP" THEN TMP = "CUP"
IF TMP = "CUP" AND NOT(LFL) THEN RJT.FL = 4; RETURN; *** Account pays with coupons
IF TMP = "EFT" THEN
READ EFT FROM EFT.FILE,ACT.ID THEN
IF EFT<1> = "Y" THEN
EFT.BILLING = 1; TM.CN = 0
LOOP TM.CN = TM.CN + 1 WHILE ACT$BILL.FREQS<1,TM.CN> # "" AND EFT.BILLING DO
IF NOT(ACT$EFT.BILLING<0,TM.CN> = "Y" OR ACT$EFT.BILLING<0,TM.CN> = "B") THEN EFT.BILLING = 0
REPEAT
* END ELSE
* IF (EFT$STAT # "C" AND EFT$ERROR.FLAG # "E") AND NOT(SINGLE) THEN RJT.FL = 5; RETURN; *** No EFT NSFs or Errors found
* IF (EFT$ERROR.FLAG = "E" AND NOT(LFL)) AND NOT(SINGLE) THEN RJT.FL = 6; RETURN; *** NSF or Error found but not a late run
END
END
END
LOCATE TMP IN PYM<1> SETTING LOC THEN
IF PYM<7,LOC> # "N" THEN
*** Not a reprint, valid Bill Freq, due annual, late notice, or $ amt on trans.
IF NOT(TFL) AND NOT(LFL) AND NOT(SINGLE) THEN RJT.FL = 11; RETURN
END ELSE
IF (NOT(TMP = "EFT" AND NOT(EFT.BILLING))) OR (TMP = "EFT" AND EFT.BILLING) THEN
IF (RNTP = 2 AND NOT(LFL)) AND NOT(SINGLE) THEN RJT.FL = 13; RETURN; *** No statement for this Pay Method
END
END
IF RNTP = 1 OR (RNTP = 2 AND LFL) THEN
IF (NOT(TMP = "EFT" AND NOT(EFT.BILLING))) OR (TMP = "EFT" AND EFT.BILLING) OR TMP # "EFT" THEN
IF PYM<8,LOC> # "Y" THEN RJT.FL = 10; RETURN; *** No Late Notice for this Pay Method
END
*** Credit Status less than Min Delinq Credit Status
IF PYM<7,LOC> # "Y" AND PYM<8,LOC> = "Y" AND ABS(ACT$CREDIT.STATUS) LT MDQS AND NOT(SINGLE) THEN RJT.FL = 15; RETURN
END
END
END
IF NOT(SINGLE) THEN
*** Bal. less than Min Bal or less than Min days between Statements
IF ((AGT LT MDQA) OR (TDY-ACT$LAST.STMT.DATE LE DBTW)) AND NOT(RPR) THEN RJT.FL = 14; RETURN
END
*** Not a reprint, valid Bill Freq, due annual, late notice, or $ amt on trans.
IF NOT(RPR) AND NOT(BFS.FL) AND NOT(ANN.FL) AND NOT(LFL) AND NOT(ACT$STAT = "D" AND INDEX(BFS,"^",1)) AND NOT(CDEB) THEN RJT.FL = 11; RETURN
GOSUB GEN.STMT; RJT.FL = 0; * IF RPR OR (CDEB) OR SINGLE THEN GOSUB GEN.STMT; RJT.FL = 0
*
ACT.WRITE: *
IF MPG.RUN = -1 THEN MPG.RUN = "" ELSE IF (NOT(RPR) OR RECALC.DISC) AND NOT(RJT.FL) THEN MATWRITE ACT ON ACT.FILE,ACT.ID
RETURN
!
GEN.STMT: *
*
IF DSR THEN
PRINT CLB:"GEN.STMT":; INPUT TMP:
END
*
IF FIRST AND DISC.DATE = "CALC" THEN DISC.DATE = ""
*
IF NOT(DISC.DATE) THEN
L.B.DATE = ""; VC = 1
LOOP UNTIL ACT$BILL.FROM.DATES<1,VC> = "" DO
IF ACT$BILL.FROM.DATES<1,VC> GT L.B.DATE THEN L.B.DATE = ACT$BILL.FROM.DATES<1,VC>
VC = VC + 1
REPEAT
IF RPR AND NOT(RECALC.DISC) THEN L.B.MONTH = ST.PRDT ELSE L.B.MONTH = TDY
IF NOT(L.B.DATE) THEN L.B.DATE = L.B.MONTH
L.B.DAY = OCONV(L.B.DATE,"D2-")
L.B.DAY = L.B.DAY[4,2]
TMP1 = OCONV(L.B.MONTH,"D2-")
L.B.MONTH = TMP1[1,2]; CURR.YR = TMP1[7,2]
L.B.MONTH = L.B.MONTH-ACT$CREDIT.STATUS+1
IF L.B.MONTH LT 1 THEN L.B.MONTH = L.B.MONTH+12; CURR.YR = CURR.YR-1
L.B.DAY = ICONV(L.B.MONTH:"/":L.B.DAY:"/":CURR.YR,"D")
DISC.DATE = L.B.DAY+MDD
END
*
CALL MOD11.DIGIT(ACT.ID,CD); FID = ACT.ID:"-":CD
CLS.COL = 0; CLS.ROW = DISP.LN - 2; GOSUB CLS.ROUTINE
STMT.COUNT = STMT.COUNT + 1
PRINT @(0,DISP.LN):"Generating statement # ":STMT.COUNT:" for acct # no. ":ACT.ID:"-":CD:@(0,DISP.LN):
*
GOSUB SU.PL
IF MPG.RUN = -1 THEN STMT.COUNT = STMT.COUNT - 1
*
IF RPR OR MPG.RUN = -1 THEN RETURN
*
* SEND OLD TRANS. TO HISTORY
* IF STAT.TY # 1 AND NOT(SINGLE) THEN
IF STAT.TY # 1 THEN
LOCATE "S" IN ATR$TYPES<1> SETTING VC THEN
IF ATR$EFF.DATES<1,VC+1> # "" THEN
LOW.VC = VC+1
VC = COUNT(ATR$EFF.DATES,VM)+1; IF ATR$EFF.DATES<1,VC> = "" THEN VC = VC-1
MATREAD SAVE.ATR FROM ATH.FILE,ACT.ID ELSE MAT SAVE.ATR = ""
FOR VC = VC TO LOW.VC STEP -1
TM = ATR$EFF.DATES<1,VC>
DEL ATR$EFF.DATES<1,VC,0>
INS TM BEFORE SAVE.ATR$EFF.DATES<1,1>
TM = ATR$ENTRY.DATES<1,VC>; DEL ATR$ENTRY.DATES<1,VC,0>; INS TM BEFORE SAVE.ATR$ENTRY.DATES<1,1>
TM = ATR$ENTRY.PERIODS<1,VC>; DEL ATR$ENTRY.PERIODS<1,VC,0>; INS TM BEFORE SAVE.ATR$ENTRY.PERIODS<1,1>
TM = ATR$TYPES<1,VC>; DEL ATR$TYPES<1,VC,0>; INS TM BEFORE SAVE.ATR$TYPES<1,1>
TM = ATR$REFS<1,VC>; DEL ATR$REFS<1,VC,0>; INS TM BEFORE SAVE.ATR$REFS<1,1>
TM = ATR$TOTAL.AMTS<1,VC>; DEL ATR$TOTAL.AMTS<1,VC,0>; INS TM BEFORE SAVE.ATR$TOTAL.AMTS<1,1>
TM = ATR$DESCS<1,VC>; DEL ATR$DESCS<1,VC,0>; INS TM BEFORE SAVE.ATR$DESCS<1,1>
TM = ATR$SVC.TYPES<1,VC>; DEL ATR$SVC.TYPES<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.TYPES<1,1>
TM = ATR$SVC.QNTYS<1,VC>; DEL ATR$SVC.QNTYS<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.QNTYS<1,1>
TM = ATR$SVC.AMTS<1,VC>; DEL ATR$SVC.AMTS<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.AMTS<1,1>
TM = ATR$SVC.FROM.DATES<1,VC>; DEL ATR$SVC.FROM.DATES<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.FROM.DATES<1,1>
TM = ATR$SVC.TO.DATES<1,VC>; DEL ATR$SVC.TO.DATES<1,VC,0>; INS TM BEFORE SAVE.ATR$SVC.TO.DATES<1,1>
NEXT VC
MATWRITE SAVE.ATR ON ATH.FILE,ACT.ID
END
END
END
*
IF ACT$LAST.BILL.DATE THEN ADJ.BDT = ACT$LAST.BILL.DATE ELSE ADJ.BDT = TDY
CALL PACK.NUMBER(ADJ.BDT,TM); INS TM BEFORE ATR$EFF.DATES<1,1>
CALL PACK.NUMBER(TDY,TM); INS TM BEFORE ATR$ENTRY.DATES<1,1>
INS "" BEFORE ATR$ENTRY.PERIODS<1,1>
* IF SINGLE THEN DOCK = "I" ELSE DOCK = "S"; INS DOCK BEFORE ATR$TYPES<1,1>
INS "S" BEFORE ATR$TYPES<1,1>
TM = MGI[5,99]; INS TM BEFORE ATR$REFS<1,1>
CALL PACK.NUMBER(BLN,TM); INS TM BEFORE ATR$TOTAL.AMTS<1,1>
* TM = ""; IF SINGLE THEN TM = "Special Statement" ELSE IF STAT.TY = 1 THEN TM = "Late Notice"
IF STAT.TY = 1 THEN TM = "A" ELSE TM = ""
INS TM BEFORE ATR$DESCS<1,1>
INS "" BEFORE ATR$SVC.TYPES<1,1>
INS "" BEFORE ATR$SVC.QNTYS<1,1>
INS "" BEFORE ATR$SVC.AMTS<1,1>
INS "" BEFORE ATR$SVC.FROM.DATES<1,1>
INS "" BEFORE ATR$SVC.TO.DATES<1,1>
MATWRITE ATR ON ATR.FILE,ACT.ID
*
ACT$LAST.STMT.DATE = TDY
RETURN
!
GET.ADDRESSES: *
IF DSR THEN
PRINT CLB:"GET.ADDRESS":; INPUT TMP:
END
LCA = FIELD(ADD$GEOGRAPHIC.DATA,"*",4)
IF LCA # OLCA THEN
READ RTO.ADD FROM PAR.FILE,"REMIT.TO*":LCA ELSE RTO.ADD = ""
RTO.ADD1 = RTO.ADD<1>
RTO.ADD2 = RTO.ADD<2>
RTO.ADD3 = RTO.ADD<3>
OLCA = LCA
END
IF OPSYS = "R" THEN
IF SYS.TST<8> THEN DISPLAY = 1 ELSE DISPLAY = 0
CALL GET.NADDS(SYS.TST,DISPLAY,MAX.LINES,MAT ACT,MAT ADD,ACT.ID,ACT$ADD.ID,NAMES,SVC.ADD,SVC.LINE,BN,DROP.DESC,ERROR)
NAME = NAMES<1>
IF NOT(ERROR) THEN SN = NAMES:AM:SVC.ADD
IF BN = "" THEN BN = SN
END ELSE
LNM = FIELD(ACT$CUS.NAME,"*",1)
FNM = FIELD(ACT$CUS.NAME,"*",2)
TTL = FIELD(ACT$CUS.NAME,"*",3)
SN = TRIM(TTL:" ":FNM:" ":LNM); NAME = SN
*
STT.ID = FIELD(ACT$ADD.ID,"*",3)
IF STT.ID THEN
APT.NUM = FIELD(ACT$ADD.ID,"*",1)
HOUSE.NUM = FIELD(ACT$ADD.ID,"*",2)
READ STT FROM STT.FILE,STT.ID ELSE STT = ""
IF APT.NUM # "" THEN HOUSE.NUM = APT.NUM:"-":HOUSE.NUM
SN<2> = TRIM(HOUSE.NUM:" ":STT<1>)
SVC.LINE = SN<2>
LOCATE STT<2> IN CITIES<1> SETTING LC THEN CITY = CITIES<2,LC>:", ":CITIES<3,LC> ELSE CITY = ""
SN<3> = CITY
SN<4> = ADD$POST.CODE
END ELSE SN<2> = "Billing only"
*
BTDT = ""; BILL.TO.VC = ""
FOR VC = 1 TO 2
IF ACT$BILL.ADDR<1,VC> # "" THEN
BEFF = ACT$BILL.EFF.DATE<1,VC>
IF BEFF LE ST.PRDT AND (BTDT = "" OR BEFF LE BTDT) THEN
BILL.TO.VC = VC
BTDT = BEFF
END
END
NEXT VC
IF BILL.TO.VC = "" THEN BN = SN; GOSUB GET.PO.BOX ELSE
IF ACT$BILL.NAME<1,BILL.TO.VC> = "" THEN BN = SN<1> ELSE
BILL.NAME = ACT$BILL.NAME<1,BILL.TO.VC>
BN = TRIM(FIELD(BILL.NAME,"*",3):" ":FIELD(BILL.NAME,"*",2):" ":FIELD(BILL.NAME,"*",1))
END
BILL.ADDR = ACT$BILL.ADDR<1,BILL.TO.VC>
IF BILL.ADDR = "" THEN
BN<2> = SN<2>
GOSUB GET.PO.BOX
BN<3> = SN<3>
BN<4> = SN<4>
END ELSE
BN<2> = FIELD(BILL.ADDR,"*",1)
BN<3> = FIELD(BILL.ADDR,"*",2):", ":FIELD(BILL.ADDR,"*",3)
BN<4> = FIELD(BILL.ADDR,"*",4)
END
END
END
RETURN
!
GET.PO.BOX: *
IF ACT$PO.BOX # "" THEN
IF ACT$PO.BOX = "GD" THEN BN<2> = "General Delivery" ELSE BN<2> = "P.O. Box ":ACT$PO.BOX
END
RETURN
!
CALL.MENU: *
PRINT CLB:
EXECUTE "CALL.MENU"; * DON'T CHANGE
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TTL = "Statements - Print or reprint statements"
PRINT @(0,1):(SPACE(40-LEN(TTL)/2):TTL) "L#80":RVE:
PRINT @(0,6):
IF RPR THEN PRINT "Reprint": ELSE PRINT "New": 
PRINT " statements dated ":OCONV(ST.PRDT,"D2")
IF NOT(RPR) THEN PRINT @(0,8):CLL:"Disconnect date used for this statement run: ":OCONV(DISC.DATE,"D2"):
RETURN
!
~STAT.PRINT.6X85~
*CODE.SEGMENT:      STAT.PRINT.6X85
* VERSION: 890712
* DESCRIPTION:       PRINT STATEMENTS
*
*                    12 JUL 89  H. HORSMAN    FROM STATEMENTS.9.5X7.0
*
*
!
GEN.MASK: *
IF FIRST THEN
LATE.BAL.LINE = "Previous balance"
LOCATE "B" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN LATE.BAL.LINE = TMP
END
TMP = ""; THIRTY.DAY.MSG = ""
LOCATE "T" IN MTP<1> SETTING MSG.NUM THEN
TMP = MG(MSG.NUM)
TMP = TRIM(TMP<1>)
IF TMP # "" THEN THIRTY.DAY.MSG = TMP
END
FOR ACR = 1 TO MXACR
IF ACR = 1 THEN FILLER = SPACE(2) ELSE FILLER = SPACE(7)
PL(ACR,6) = STR("X",30):"999999-9" "R#12":OCONV(TDY,"D2") "R#13"
PL(ACR,11) = SPACE(32):"DD-MMM-YY":"999.99-" "R#14"
PL(ACR,12) = FILLER:STR("X",30)
PL(ACR,13) = FILLER:STR("X",30)
PL(ACR,14) = FILLER:STR("X",30)
PL(ACR,15) = FILLER:STR("X",30)
PL(ACR,18) = THIRTY.DAY.MSG<1>
PL(ACR,21) = SPACE(40):"PAGE XX"
PL(ACR,24) = SPACE(37):"Due Date  DD-MMM-YY"
PL(ACR,27) = STR("X",30):"999999-9" "R#12":OCONV(TDY,"D2") "R#13"
FOR LN = 31 TO 45
PL(ACR,LN) = "DDMMMYY ":STR("X",37):"999.99-" "R#11"
NEXT LN
FOR LN = 47 TO 50
PL(ACR,LN) = STR("X",55)
NEXT LN
NEXT ACR
GOSUB PSTMTS
FIRST = ""
END
*
RETURN
!
SU.PL: *
PG = 1; LN = 31
GOSUB GET.ADDRESSES
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:CLB:"Entering SU.PL":; INPUT TMP:
END
PL(ACR,27) = SN<2> "L#30":FID "R#12":OCONV(TDY,"D2") "R#13"
PREV.BLN = ACT$BALANCE
GOSUB SU.TOP
DXP = ""; DMT = 0
*
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
PREV.BLN = PREV.BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
IF PREV.BLN NE 0 THEN
PL(ACR,LN) = PST.DATE "L#8":LATE.BAL.LINE "L#37":OCONV(PREV.BLN,"MR2M") "R#11"
END
*
BLN = PREV.BLN
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 45 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(ACR,LN) = EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#11"
END ELSE PL(ACR,LN) = EDT "L#8":TDE "L#36":OCONV(TMT,"MR2ZM") "R#12"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN
IF NOT(TTY = "W" AND STY1 = "c") THEN AMT = ""
END
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 45 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#25":" ":SDTS
PL(ACR,LN) = COMF:SPACE(19):SDE "L#41":OCONV(AMT,"MR2ZM") "R#11":REGF
END
SC = SC+1
REPEAT
END
END
NEXT VC
GOSUB SU.MG
TMP = LN
IF BMSG<2> # "" THEN TMP = TMP+1
IF BMSG # "" THEN TMP = TMP+2
IF TMP > 43 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF BLN > 0 THEN LC = 1 ELSE IF BLN LT 0 THEN LC = 2 ELSE LC = 3
IF LN < 44 THEN LN = LN+2 ELSE LN = LN+1
PL(ACR,LN) = SPACE(8):BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#11"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(ACR,LN) = "IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#12"
END
*
IF BMSG # "" THEN
LN = LN+2
PL(ACR,LN) = BMSG<1>[1,55]
LN = LN+1
PL(ACR,LN) = BMSG<2>[1,55]
END
IF LN < 45 THEN
PL(ACR,45) = "Payments received at our office after ":OCONV(TDY-1,"D0") "L#7":"do not show"
END
ACR = ACR+1; IF ACR > MXACR THEN GOSUB PSTMTS
RETURN
!
MPG: *
IF MPG.RUN THEN
PL(ACR,21) = SPACE(40):"PAGE ":PG
PL(ACR,45) = COMF:SPACE(19):"Continued on next page ...":REGF
ACR = ACR+1; IF ACR > MXACR THEN GOSUB PSTMTS
GOSUB SU.TOP; PG = PG+1
PL(ACR,24) = SPACE(40):"PAGE ":PG
PL(ACR,31) = COMF:SPACE(19):"... Continued from previous page":REGF
LN = 32
RETURN
END
*
MPG.IDS<-1> = ACT.ID
FOR LN = 1 TO 51; PL(ACR,LN) = ""; NEXT LN
RETURN
!
SU.MG: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"Entering SU.MG":; INPUT TMP:
END
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<3> = AMG<1>
ML<4> = AMG<2>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
BMSG = "";  ****
IF MG.LGTH(MN) > 2 THEN
BMSG<1> = ML<1>
BMSG<2> = ML<2>
IF BMSG<1> = "" AND BMSG<2> = "" THEN BMSG = ""
ML = AMG
END
FOR TMP = 47 TO 50
PL(ACR,TMP) = ML<TMP-46>[1,55]
NEXT TMP
RETURN
!
SU.TOP: *
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
IF ACT$CREDIT.STATUS EQ 1 AND ACT$STAT = "D" THEN PDD = "NOW DUE"
IF ACT$CREDIT.STATUS GT THEN PDD = "PAST DUE"
IF PDD = "" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END
END ELSE PDD = PYDD
IF ACR = 1 THEN FILLER = SPACE(2) ELSE FILLER = SPACE(7)
PL(ACR,6) = SN<2> "L#30":FID "R#12":OCONV(TDY,"D2") "R#13"
* PL(ACR,11) = SPACE(38):OCONV(ACT$BALANCE,"MR2M") "R#18"
PL(ACR,11) = SPACE(38):OCONV(ACT$BALANCE,"MR2M") "R#18"
PL(ACR,12) = FILLER:BN<1>
PL(ACR,13) = FILLER:BN<2>
PL(ACR,14) = FILLER:BN<3>
PL(ACR,15) = FILLER:BN<4>
PL(ACR,18) = THIRTY.DAY.MSG<1>
PL(ACR,24) = SPACE(37):"Due Date ":OCONV(PDD,"D2") "L#9"
*
RETURN
!
PSTMTS: *
IF (TEST.FL<1> # "" AND TEST.FL<5> # "") THEN PRINT BELL:"Entering PSTMTS":; INPUT TMP:
IF TEST.FL<7> EQ "" OR RPR THEN
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 6
LOOP
PTEMP = ""
FOR ACR = 1 TO MXACR
TEMP = PL(ACR,LN)
IF TRIM(TEMP) = "" THEN PTEMP = PTEMP:SPACE(60) ELSE
IF ACR = MXACR THEN PRINT PTEMP:TEMP: ELSE
IF TEMP[1,LEN(COMF)] # COMF THEN PRINT PTEMP:TEMP "L#60": ELSE PRINT PTEMP:TEMP:CR:REGF:SPACE(60*ACR):
PTEMP = ""
END
END
NEXT ACR
PRINT
UNTIL LN = 5 DO
LN = LN+1; IF LN > 51 THEN LN = 1
REPEAT
PRINT COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS NE "R" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
END
MAT PL = ""
ACR = 1
RETURN
!
FINISH: *
LN = 8
LOOP UNTIL LN = 30 DO
PL(ACR,LN) = SPACE(LN-3):OCONV(TDY,"D2"):" Count: ":STMT.COUNT
LN = LN+1
REPEAT
GOSUB PSTMTS
*
IF BAD.ACCTS<1> # "" THEN
CALL PRINTER.ON(STAT); IF STAT THEN STOP
PRINT "Accounts containing garbage: ":
AC = 1
LOOP UNTIL BAD.ACCTS<AC> = "" DO
PRINT BAD.ACCTS<AC>:" ":; AC = AC+1
REPEAT
PRINT
PRINTER OFF
END
*
IF REJECTED.ACCTS<1> # '' AND TEST.FL<5> NE '' THEN
CALL PRINTER.ON(STAT); IF STAT THEN STOP
PRINT
PRINT
PRINT "Accounts rejected in processing: "
AC = 1
LOOP UNTIL REJECTED.ACCTS<AC> = "" DO
PRINT REJECTED.ACCTS<AC,1> "L#10":REJECTED.ACCTS<AC,2> "L#4":REJECTED.DESC<REJECTED.ACCTS<AC,2>>
AC = AC + 1
REPEAT
PRINT
PRINTER OFF
* PRINT CLB:"Enter <CR> . . . ":; INPUT TMP:
* PRINT @(0,8):CLS
* PRINT
* PRINT "Accounts rejected in processing: ":
* PRINT
* AC = 1
* LOOP UNTIL REJECTED.ACCTS<AC> = "" DO
* PRINT REJECTED.ACCTS<AC,1> "L#10":REJECTED.ACCTS<AC,2> "L#4":REJECTED.DESC<REJECTED.ACCTS<AC,2>>[1,50]
* IF LEN(REJECTED.DESC<REJECTED.ACCTS<AC,2>>) > 50 THEN
* PRINT "     ":REJECTED.DESC<REJECTED.ACCTS<AC,2>>[51,70]
* END
* AC = AC + 1
* REPEAT
* PRINT
END
*
EXECUTE 'SP-ASSIGN'; * ULT ONLY
CLS.COL = 0; CLS.ROW = DISP.LN; GOSUB CLS.ROUTINE
STOP
!
*#
~STAT.PRINT.95X70~
*CODE.SEGMENT:      STAT.PRINT.95X70
* DESCRIPTION:       PRINT STATEMENTS
*
*                    31 MAY 87  D. HORSMAN    FROM STATEMENTS.9.5X7.0
*
*                    01 MAY 87  H. HORSMAN    ANALYST'S COMMENT
*                               THIS VERSION DOES NOT CONTAIN THE TEST OF
*                               PAY.METHOD STATEMENT FLAG. IF THE STATEMENT
*                               FLAG IS 'N', THEN NO STATEMENT SHOULD
*                               BE PRINTED FOR THE SUBSCRIBER!
*
*
*                    01 MAR 87  DAVID HORSMAN  Problem with disconnected
*                               Not receiving statements.
*
*                    25 SEP 86  BOB CONARROE  FROM STATEMENTS.9.5X7.3
*
*
!
9741: * GEN.MASK
IF FIRST THEN
PL(1,2) = SPACE(58):STR("X",22)
FOR LN = 4 TO 5
PL(1,LN) = STR("X",80)
NEXT LN
TM = STR("X",29):"999999-9" "R#9":OCONV(TDY,"D2") "R#11"
PL(1,8) = "XXX XXX ":STR("X",22):" ":TM
PL(1,13) = SPACE(8):STR("X",30):"999.99-" "R#36"
PL(1,14) = SPACE(8):STR("X",30)
PL(1,15) = SPACE(8):STR("X",30)
PL(1,16) = SPACE(8):STR("X",30)
PL(1,25) = SPACE(58):STR("X",22)
PL(1,28) = STR("X",30):" ":TM
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN PL(1,LN) = STR("X",44):" " ELSE PL(1,LN) = SPACE(47)
PL(1,LN) = PL(1,LN):CRCOM78:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB 9747
FIRST = ""
END
*
RETURN
!
9742: *
PG = 1
GOSUB 9734
GOSUB 9744
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(1,30) = CRCOM78:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 30
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#21":" ":SDTS
PL(1,LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(1,LN) = PL(1,LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB 9745
GOSUB 9746
GOSUB 9747
RETURN
!
9743: *
IF MPG.RUN THEN
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,42) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB 9746
FOR TM = 30 TO 42
PL(1,TM) = SPACE(47):PL(1,TM)
NEXT TM
GOSUB 9747
PG = PG+1
GOSUB 9744
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,30) = CRCOMF:"... Continued from previous page"
LN = 31
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
9744: *
SVC.LIST = ""
SVC.CN = 1
LOOP WHILE ACT$SERVICES<1,SVC.CN> # "" AND LEN(SVC.LIST) < 20 DO
IF SVC.CN > 1 THEN SVC.LIST = SVC.LIST:", "
SVC.LIST = SVC.LIST:ACT$SERVICES<1,SVC.CN>:" (":ACT$QNTYS<1,SVC.CN>+0:")"
SVC.CN = SVC.CN + 1
REPEAT
SALN = SN<2> "L#30":FID "R#8":OCONV(TDY,"D2") "R#11"
*
PL(1,2) = SPACE(58):TDSC(STAT.TY)
PL(1,25) = PL(1,2)
*
PL(1,4) = RTO.ADD1
PL(1,5) = RTO.ADD2
PL(1,8) = ADD$DWELLING.TYPE "L#4":FIELD(ACT$RATE.TYPE,"*",1) "L#4":SVC.LIST "L#22":" ":SALN
PL(1,28) = SN<1> "L#30":" ":SALN
RETURN
!
9745: *
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<5> = AMG<1>
ML<6> = AMG<2>
ML<7> = AMG<3>
ML<8> = AMG<4>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN
PL(1,LN) = (ML<LN-33>:SPACE(46))[1,46]:" ":PL(1,LN)
END ELSE PL(1,LN) = SPACE(47):PL(1,LN)
NEXT LN
RETURN
!
9746: *
PL(1,13) = SPACE(8):BN<1> "L#55"
IF PG # 1 OR NOT(MPG.RUN) THEN PL(1,13) = PL(1,13):OCONV(BLN,"MR2M") "R#11"
PL(1,14) = SPACE(8):BN<2>
PL(1,15) = SPACE(8):BN<3>
PL(1,16) = SPACE(8):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(1,20) = SPACE(59):OCONV(PDD,"D2")
RETURN
!
9747: *
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 2
LOOP
IF LN < 23 OR LN > 24 THEN
PTM = ""
TM = PL(1,LN)
IF TRIM(TM) # "" THEN
IF LN > 29 AND LN < 43 THEN PRINT TM:CR:REGF: ELSE PRINT TM:
END
PRINT
END
UNTIL LN = 1 DO
LN = LN+1; IF LN > 44 THEN LN = 1
REPEAT
PRINT CR:COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~STAT.PRINT.95X73~
*CODE.SEGMENT:      STAT.PRINT.95X73
* DESCRIPTION:       PRINT STATEMENTS
*
* AUTHOR:            31 MAY 87  D. HORSMAN  FROM STATEMENTS.9.5X7.3
*                               Split off validation and
*                               standardize all statement formats.
*
*
*
!
9741: * GEN.MASK
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF FIRST THEN
PL(1,2) = SPACE(58):STR("X",22)
FOR LN = 4 TO 5
PL(1,LN) = STR("X",80)
NEXT LN
TM = STR("X",29):"999999-9" "R#9":OCONV(TDY,"D2") "R#11"
PL(1,8) = "XXX XXX ":STR("X",22):" ":TM
PL(1,13) = SPACE(8):STR("X",30):"999.99-" "R#36"
PL(1,14) = SPACE(8):STR("X",30)
PL(1,15) = SPACE(8):STR("X",30)
PL(1,16) = SPACE(8):STR("X",30)
PL(1,25) = SPACE(58):STR("X",22)
PL(1,28) = STR("X",30):" ":TM
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN PL(1,LN) = STR("X",44):" " ELSE PL(1,LN) = SPACE(47)
PL(1,LN) = PL(1,LN):CRCOM78:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB 9747
FIRST = ""
END
*
RETURN
!
9742: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
PG = 1
GOSUB 9734
GOSUB 9744
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(1,30) = CRCOM78:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 30
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(1,LN) = CRCOM78:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 41 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#21":" ":SDTS
PL(1,LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(1,LN) = PL(1,LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB 9745
GOSUB 9746
GOSUB 9747
RETURN
!
9743: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF MPG.RUN THEN
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,42) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB 9746
FOR TM = 30 TO 42
PL(1,TM) = SPACE(47):PL(1,TM)
NEXT TM
GOSUB 9747
PG = PG+1
GOSUB 9744
PL(1,25) = SPACE(70):"PAGE ":PG
PL(1,30) = CRCOMF:"... Continued from previous page"
LN = 31
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
9744: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
SVC.LIST = ""
SVC.CN = 1
LOOP WHILE ACT$SERVICES<1,SVC.CN> # "" AND LEN(SVC.LIST) < 20 DO
IF SVC.CN > 1 THEN SVC.LIST = SVC.LIST:", "
SVC.LIST = SVC.LIST:ACT$SERVICES<1,SVC.CN>:" (":ACT$QNTYS<1,SVC.CN>+0:")"
SVC.CN = SVC.CN + 1
REPEAT
SALN = SN<2> "L#30":FID "R#8":OCONV(TDY,"D2") "R#11"
*
PL(1,2) = SPACE(58):TDSC(STAT.TY)
PL(1,25) = PL(1,2)
*
PL(1,4) = RTO.ADD1
PL(1,5) = RTO.ADD2
PL(1,8) = ADD$DWELLING.TYPE "L#4":FIELD(ACT$RATE.TYPE,"*",1) "L#4":SVC.LIST "L#22":" ":SALN
PL(1,28) = SN<1> "L#30":" ":SALN
RETURN
!
9745: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
*
* THE FOLLOWING TEST WAS CHANGED TO TAKE INTO ACCOIUNT STATUS 'N'.
*
*GOOD HARV, (DH)* IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
IF ACT$STAT = "D" THEN MGI = "MSG.D" ELSE MGI = "MSG.C"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<5> = AMG<1>
ML<6> = AMG<2>
ML<7> = AMG<3>
ML<8> = AMG<4>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN
PL(1,LN) = (ML<LN-33>:SPACE(46))[1,46]:" ":PL(1,LN)
END ELSE PL(1,LN) = SPACE(47):PL(1,LN)
NEXT LN
RETURN
!
9746: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
PL(1,13) = SPACE(8):BN<1> "L#55"
IF PG # 1 OR NOT(MPG.RUN) THEN PL(1,13) = PL(1,13):OCONV(BLN,"MR2M") "R#11"
PL(1,14) = SPACE(8):BN<2>
PL(1,15) = SPACE(8):BN<3>
PL(1,16) = SPACE(8):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(1,20) = SPACE(59):OCONV(PDD,"D2")
RETURN
!
9747: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 2
LOOP
PTM = ""
TM = PL(1,LN)
IF TRIM(TM) # "" THEN
IF LN > 29 AND LN < 43 THEN PRINT TM:CR:REGF: ELSE PRINT TM:
END
PRINT
UNTIL LN = 1 DO
LN = LN+1; IF LN > 44 THEN LN = 1
REPEAT
PRINT CR:COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~STAT.PRINT.LINDSAY~
*CODE.SEGMENT:           STAT.PRINT.LINDSAY
* DESCRIPTION:       PRINT STATEMENTS (LINDSAY CATV FORMAT)
*
*                    08 MAR 88  MESSAGE UPPED FROM 45 TO 47 CHARACTERS.
*                               MESSAGE UPPED FROM 4 TO 6 LINES.
*
*                    31 MAY 87  D. HORSMAN    FROM STATEMENTS.LINDSAY
*
*                    01 MAY 87  H. HORSMAN    ANALYST'S COMMENT
*                               THIS VERSION DOES NOT CONTAIN THE TEST OF
*                               PAY.METHOD STATEMENT FLAG. IF THE STATEMENT
*                               FLAG IS 'N', THEN NO STATEMENT SHOULD
*                               BE PRINTED FOR THE SUBSCRIBER!
*
*                    01 MAR 87  DAVID HORSMAN  Problem with disconnected
*                               Not receiving statements.
*
*                    25 SEP 86  BOB CONARROE  FROM STATEMENTS.9.5X7.3
*
*                    ** FEB 87   BOB CONARROE **
*
!
9741: * GEN.MASK
IF FIRST THEN
PL(1,2) = SPACE(69):OCONV(TDY,"D2")
FOR LN = 4 TO 5
PL(1,LN) = SPACE(6): STR("X",72)
NEXT LN
PL(1,8) = SPACE(10):STR("X",25):SPACE(8):STR("X",22):SPACE(5):"999999-9"
PL(1,14) = SPACE(61):"$99999.99"
PL(1,16) = SPACE(10):STR("X",30)
PL(1,17) = SPACE(10):STR("X",30)
PL(1,18) = SPACE(10):STR("X",30)
PL(1,19) = SPACE(10):STR("X",30):SPACE(22):"DD MMM YY"
PL(1,31) = SPACE(69):OCONV(TDY,"D2")
PL(1,35) = PL(1,8)
FOR LN = 38 TO 50
IF LN # 44 THEN PL(1,LN) = C12.FONT.CR:STR("X",47)
NEXT LN
FOR LN = 38 TO 54
PL(1,LN) = PL(1,LN):CRCOM72:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB 9747
FIRST = ""
END
*
RETURN
!
9742: *
PG = 1
GOSUB 9734
GOSUB 9744
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(1,38) = CRCOM72:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 39
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 53 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(1,LN) = CRCOM72:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(1,LN) = CRCOM72:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 53 THEN GOSUB 9743; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#20":" ":SDTS
PL(1,LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(1,LN) = PL(1,LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 53 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 55 THEN
IF LN < 53 THEN LN = LN+2 ELSE LN = LN+1
PL(1,LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB 9745
GOSUB 9746
GOSUB 9747
RETURN
!
9743: *
IF MPG.RUN THEN
PL(1,31) = SPACE(59):"PAGE ":PG:PL(1,31)[66,99]
PL(1,54) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB 9746
GOSUB 9747
PG = PG+1
GOSUB 9744
PL(1,31) = SPACE(59):"PAGE ":PG:PL(1,31)[66,99]
PL(1,38) = CRCOMF:"... Continued from previous page"
LN = 39
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
9744: *
PL(1,2) = SPACE(69):OCONV(TDY,"D2")
PL(1,31) = PL(1,2)
*
PL(1,4) = SPACE(6): RTO.ADD1
PL(1,5) = SPACE(6): RTO.ADD2
PL(1,8) = SPACE(10):SN<1> "L#30":SPACE(3):SN<2> "L#25":"  ":FID
PL(1,35) = PL(1,8)
RETURN
!
9745: *
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<7> = AMG<1>
ML<8> = AMG<2>
ML<9> = AMG<3>
ML<10> = AMG<4>
ML<11> = AMG<5>
ML<12> = AMG<6>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 38 TO 43
PL(1,LN) = C12.FONT.CR:ML<LN-37> "L#47":PL(1,LN)
NEXT LN
FOR LN = 45 TO 50
PL(1,LN) = C12.FONT.CR:ML<LN-38> "L#47":PL(1,LN)
NEXT LN
RETURN
!
9746: *
IF PG # 1 OR NOT(MPG.RUN) THEN PL(1,14) = SPACE(60):OCONV(BLN,"MR2M$") "R#10"
PL(1,16) = SPACE(10):BN<1>
PL(1,17) = SPACE(10):BN<2>
PL(1,18) = SPACE(10):BN<3>
PL(1,19) = SPACE(10):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
* REMOVE RTEMP FROM TM<1> AT 1 SETTING RFLAG; * REV ONLY
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(1,19) = PL(1,19) "L#62":OCONV(PDD,"D2")
RETURN
!
9747: *
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT LPI8
PRINT REGF
FOR LN = 2 TO 56
IF LN = 37 THEN PRINT C12.FONT.CR ELSE PRINT PL(1,LN)
NEXT LN
PRINTER OFF
CTR = CTR+1
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~STATUS.VAR.EQUATES~
*CODE.SEGMENT: STATUS.VAR.EQUATES
*
* FILE: STL      ID: STATUS.LOG
EQU STATUS.CHANNEL     TO 1; * CHANNEL #
EQU STATUS.CHAN.STAT   TO 2; * CHANNEL STATUS
EQU STATUS.DESC        TO 3; * CHANNEL DESCRIPTION
EQU STATUS.CHECKED     TO 4; * DT*TM OF LAST STATUS CHECK
EQU STATUS.SRVC        TO 5; * SERVICE ASSOC'T W THIS CHANNEL
EQU STATUS.FLAGGED     TO 6; * FLAG
*
*
EQU AI.UP TO "UP"
EQU AI.DN TO "DN"
EQU AI.ON TO "ON"
EQU AI.OFF TO "OFF"
*
~STD.DIM~
*CODE.SEGMENT: STD.DIM
*
DIM STD(50)
*
~STM.DIM~
*CODE.SEGMENT: ?
DIM STM(20)
~STM.VAR.EQUATES~
*CODE.SEGMENT: STM.VAR.EQUATES
*
* FILE 'STM' EQUATES - GENERATED 13:37:09  07 MAY 1991
EQU STM$ISSUE.DATE TO 1;                * DATE OF STATEMENT GENERATION
EQU STM$DUE.DATE TO 2;                  * PAYMENT DUE DATE
EQU STM$AMT.DUE TO 3;                   * PAYMENT AMOUNT DUE
EQU STM$FL.CODE TO 4;                   * FRANCHISE/LICENSE CODE
EQU STM$RATE.TYPE TO 5;                 * SUBSCRIBER'S RATE TYPE
EQU STM$DWELLING.TYPE TO 6;             * DWELLING TYPE OF SVC ADDRESS
EQU STM$SVC.ADDR TO 7;                  * HOUSE  STREET NAME  APT NUM
EQU STM$SUB.NAME TO 8;                  * SUB NAME AND ALT NAME
EQU STM$SVC.AT.ADDR TO 9;               * ACTIVE SERVICES OF SUBSCRIBER
EQU STM$ALL.ACCTS.MSG TO 10;            * THE 4 LINE ALL ACCOUNTS MESSAGE
EQU STM$OTHER.MSG.TYPE TO 11;           * C D AND P MESSAGE TYPES
EQU STM$OTHER.MSG.TEXT TO 12;           * 4 LINES OF OTHER MESSAGE TEXT
EQU STM$PCODE TO 13;                    * POSTAL/ZIP CODE OF MAILING ADDR
EQU STM$BILL.ADDR TO 14;                * MAILING ADDRESS OF THE SUBSCRIBER
EQU STM$PNS.MSG TO 15;                  * PMT REC'D AFTER 'DATE' NOT SHOWN
EQU STM$PREV.BAL TO 16;                 * BAL FWD FROM LAST STMT
EQU STM$TRANS.DATE TO 17;               * EFFECTIVE DATE OF THE TRANSACTION
EQU STM$TRANS.DESC TO 18;               * SVC DESC, FROM DATE, TO DATE
EQU STM$TRANS.AMT TO 19;                * TRANSACTION AMOUNT
~STT.DIM~
*CODE.SEGMENT: ?
DIM STT(10)
~STT.EQUATES~
*CODE.SEGMENT: ?
EQUATE STT$NAME TO STT(1)
EQUATE STT$CITY.NUM TO STT(2)
EQUATE STT$FIRST.HOUSE.NUMS TO STT(3)
EQUATE STT$LAST.HOUSE.NUMS TO STT(4)
EQUATE STT$VALID.HOUSE.NUMS TO STT(5)
EQUATE STT$ZONES TO STT(6)
EQUATE STT$GEO.DATA TO STT(7)
~STX.DIM~
*CODE.SEGMENT: ?
DIM STX(10)
~STX.EQUATES~
*CODE.SEGMENT: ?
* FILE 'STX' EQUATES - GENERATED 09:34:06  09 NOV 1983
EQU STX$STR.ID TO STX(1);               * STREET NUMBER
EQU STX$ADDRESS TO STX(2);              * STREET ADDRESS
~SVC.DIM~
*CODE.SEGMENT: SVC.DIM
*
DIM SVC(15)
~SVC.EQUATES~
*CODE.SEGMENT: SVC.EQUATES
*
* FILE 'SVC' EQUATES - GENERATED 13:23:09  03 MAY 1992
EQU SVC$DESC TO SVC(1);                 * DESCRIPTION OF SERVICE
EQU SVC$BILL.FREQS TO SVC(2);           * ALLOWED BILLING FREQUENCY
EQU SVC$DVC.FUNCS TO SVC(3);            * DEVICE FUNCTIONS REQUIRED FOR SERVICE
EQU SVC$COMPONENTS TO SVC(4);           * COMPONENT OF SERVICE
EQU SVC$REVERTS.TO TO SVC(5);           * SERVICE TO WHICH THIS SERVICE REVERTS
EQU SVC$RATE.AREAS TO SVC(6);           * AREAS FOR RATE AND TAX CALCULATION
EQU SVC$TAX.NAMES TO SVC(7);            * APPLICABLE TAX TABLES
EQU SVC$PRICES TO SVC(8);               * SELLING PRICE
EQU SVC$BILL.METHOD TO SVC(9);          * METHOD AND DAY OF BILLING
EQU SVC$MSG.TYPE TO SVC(10);            * STATEMENT MESSAGE TYPE
EQU SVC$BULK.CODE TO SVC(11);           * BULK CODE FOR REPORTING (E,I,N,S)
EQU SVC$BULK.QNTY TO SVC(12);           * STARTING OUTLET QNTY FOR BULK ACCOUNTS
EQU SVC$SUPP.RPT TO SVC(13);            * SUPPLIER REPORT TO BE PRINTED (Y,N)
EQU SVC$COUNT.FREE TO SVC(14);          * COUNTING OF FREE SERVICE (I,S)
~SVC.VAR.EQUATES~
*CODE.SEGMENT: SVC.VAR.EQUATES
*
* FILE 'SVC' EQUATES - GENERATED 13:23:10  03 MAY 1992
EQU SVC$DESC TO 1;                      * DESCRIPTION OF SERVICE
EQU SVC$BILL.FREQS TO 2;                * ALLOWED BILLING FREQUENCY
EQU SVC$DVC.FUNCS TO 3;                 * DEVICE FUNCTIONS REQUIRED FOR SERVICE
EQU SVC$COMPONENTS TO 4;                * COMPONENT OF SERVICE
EQU SVC$REVERTS.TO TO 5;                * SERVICE TO WHICH THIS SERVICE REVERTS
EQU SVC$RATE.AREAS TO 6;                * AREAS FOR RATE AND TAX CALCULATION
EQU SVC$TAX.NAMES TO 7;                 * APPLICABLE TAX TABLES
EQU SVC$PRICES TO 8;                    * SELLING PRICE
EQU SVC$BILL.METHOD TO 9;               * METHOD AND DAY OF BILLING
EQU SVC$MSG.TYPE TO 10;                 * STATEMENT MESSAGE TYPE
EQU SVC$BULK.CODE TO 11;                * BULK CODE FOR REPORTING (E,I,N,S)
EQU SVC$BULK.QNTY TO 12;                * STARTING OUTLET QNTY FOR BULK ACCOUNTS
EQU SVC$SUPP.RPT TO 13;                 * SUPPLIER REPORT TO BE PRINTED (Y,N)
EQU SVC$COUNT.FREE TO 14;               * COUNTING OF FREE SERVICE (I,S)
~SVS.DIM~
*CODE.SEGMENT: ?
DIM SVS(20)
~SVS.EQUATES~
*CODE.SEGMENT: ?
* FILE 'SVS' EQUATES - GENERATED 10:38:23  28 MAR 1994
EQU SVS$MONTH.END.DATES TO SVS(1);      * MONTH END DATE FOR SERVICE COUNT
EQU SVS$MONTH.END.QNTYS TO SVS(2);      * MONTH END QUANTITY FOR SERVICE
EQU SVS$MONTH.END.COUNT TO SVS(3);      * MONTH END COUNT OF SERVICE
EQU SVS$UNREPORTED.DATES TO SVS(4);     * UNREPORTED SERVICE CHANGE DATES
EQU SVS$UNREPORTED.QNTYS TO SVS(5);     * UNREPORTED SERVICE QUANTITY CHANGE
EQU SVS$UNREPORTED.STARTS TO SVS(6);    * UNREPORTED START COUNT
EQU SVS$UNREPORTED.STOPS TO SVS(7);     * UNREPORTED STOP COUNT
EQU SVS$REPORTED.DATES TO SVS(8);       * LAST REPORTED SERVICE CHANGE DATES
EQU SVS$REPORTED.QNTYS TO SVS(9);       * LAST REPORTED SERVICE QUANTITY CHANGE
EQU SVS$REPORTED.STARTS TO SVS(10);     * LAST REPORTED START COUNT
EQU SVS$REPORTED.STOPS TO SVS(11);      * LAST REPORTED STOP COUNT
EQU SVS$NO.BASIC TO SVS(12);            * SUBS WITH NO BASIC SERVICE
EQU SVS$RATE.IDS TO SVS(13);            * RATE.IDS AT LAST MONTHEND UPDATE
EQU SVS$RATE.QNTYS TO SVS(14);          * QUANTIES AT LAST MONTHEND UPDATE
EQU SVS$RATE.COUNTS TO SVS(15);         * COUNTS BY QNTY AT LAST ME UPDATE
EQU SVS$FREE.RATE.IDS TO SVS(16);       * FREE RATE IDS
EQU SVS$FREE.RATE.QNTYS TO SVS(17);     * FREE RATE QNTYS
EQU SVS$FREE.RATE.COUNTS TO SVS(18);    * FREE RATE COUNTS
~SYS.COMM.WAIT.QUIET~
*CODE.SEGMENT: SYS.COMM.WAIT.QUIET
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Communications Design)
*
*   DATE: 10 FEB 89
*
* VARIABLES:
*        IN: COMM.WAIT.QUIET      -    Number of seconds continuous quiet
*            COMM.WAIT.MAX        -    Max length of wait
*            COMM.WAIT.ERROR      -    Max length error flag (null/1)
*            COMM.WAIT.PAUSE      -    # of RQMs to be performed
*            COMM.WAIT.CLEAR      -    Clear buffer if it exceeds
*                                       this # of char's.
*
* INITIALIZATION
CW.START.TIME = TIME()
CW.START.DATE = DATE()
* CURRENT # OF CHAR'S IN TYPE AHEAD BUFFER
BEGIN CASE
CASE OPSYS = "U"
CW.START.SYS11 = SYSTEM(11)
CASE OPSYS = "M"
CW.START.SYS11 = 1
CASE OPSYS = "R"
CW.START.SYS11 = 1
END CASE
*
CW.CONT.QUIET = 0
*
CW.LAST.SYS11 = CW.START.SYS11
CW.LAST.DATE  = CW.START.DATE
CW.LAST.TIME  = CW.START.TIME
*
*
* MAIN LOOP
LOOP
*
* DETERIME TOTAL ELP
CW.CURR.TIME = TIME()
CW.CURR.DATE = DATE()
IF CW.START.DATE NE CW.CURR.DATE THEN
CW.ELP = (CW.CURR.DATE-CW.START.DATE-1) * 86400 + 86400 - CW.START.TIME + CW.CURR.TIME
END ELSE
CW.ELP = ABS(CW.CURR.TIME-CW.START.TIME)
END
*@ PRINT "CW.ELP ":CW.ELP; *@
IF CW.ELP GT COMM.WAIT.MAX THEN COMM.WAIT.ERROR = 1
*@ PRINT "COMM.WAIT.ERROR ":COMM.WAIT.ERROR; *@
*
IF NOT(COMM.WAIT.ERROR) THEN
*
* CURRENT # OF CHAR'S IN TYPE AHEAD BUFFER
BEGIN CASE
CASE OPSYS = "U"
CW.CURR.SYS11 = SYSTEM(11)
CASE OPSYS = "M"
CW.CURR.SYS11 = 1
CASE OPSYS = "R"
CW.CURR.SYS11 = 1
END CASE
*
* DETERMINE CHANGE IN BUFFER
*
* # OF CHAR'S HAS CHANGED
IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
CW.LAST.SYS11 = CW.CURR.SYS11
CW.LAST.DATE  = CW.CURR.DATE
CW.LAST.TIME  = CW.CURR.TIME
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
*@ PRINT "CW.LAST.DATE ":CW.LAST.DATE; *@
*@ PRINT "CW.LAST.TIME ":CW.LAST.TIME; *@
IF CW.LAST.SYS11 GT COMM.WAIT.CLEAR AND COMM.WAIT.CLEAR THEN
INPUTCLEAR
CW.LAST.SYS11 = 0
CW.CURR.SYS11 = 1
END; * OF CLEAR
END ELSE
*
* BUFFER IS QUIET
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
IF CW.LAST.DATE NE CW.CURR.DATE THEN
CW.CONT.QUIET = (CW.CURR.DATE-CW.LAST.DATE-1) * 86400 + 86400 - CW.LAST.TIME + CW.CURR.TIME
END ELSE
CW.CONT.QUIET = ABS(CW.CURR.TIME-CW.LAST.TIME)
END
*@ PRINT "CW.CONT.QUIET ":CW.CONT.QUIET; *@
*
IF CW.LAST.SYS11 GT COMM.WAIT.CLEAR AND COMM.WAIT.CLEAR THEN
INPUTCLEAR
CW.LAST.SYS11 = 0
CW.CURR.SYS11 = 0
END; * OF CLEAR
*
END; * OF LAST.SYS11
*
END; * OF NOT(COMM.WAIT.ERROR)
*
WHILE NOT(COMM.WAIT.ERROR) AND CW.CONT.QUIET LT COMM.WAIT.QUIET DO
*
* Wait the required # of RQMs
FOR CW.TEMP = 1 TO COMM.WAIT.PAUSE
RQM
NEXT CW.TEMP
*
REPEAT
*
~SYS.COMMON~
*CODE.SEGMENT: SYS.COMMON
*
*
COMMON SYS.PROG,SYS.LOCT,SYS.SLOC,SYS.FILE,SYS.ITEM
COMMON FUNCTION,SUB.FUNCTION
COMMON SUBR.FUNCTION,SUBR.SUB.FUNCTION
COMMON CALL.FUNCTION,CALL.SUB.FUNCTION
COMMON USER.NAME,USER.CO.CODE
COMMON MENU.APPL,MENU.SUB.APPL,MENU.GRP.APPL
COMMON MENU.NAME,PRMPTING,TOPIC.KEY,MENU.CONTROL
COMMON TASK.NUM,TASK.STEP,TOPIC.ID,USER.KEY,PSD.KEY,SPTM.KEY,CTC.KEY
COMMON WAIT.FLAG,USER.MODE,USER.ABORT,SYS.ABORT,USER.LOCKED,CHECK.TIME
COMMON SYS.VALUES,SYS.ANSWERS,LAST.LOCT
COMMON SCH.FLAG,MSG.FLAG,TCL.FLAG,OFF.FLAG
COMMON CO.DATA,SY.FILE,PS.FILE,MENU.PARAMS,MENU.APPL.DESC
COMMON EXEC.VERB,EXEC.FILE.ITEM,MENU.FILE,MENU.SUBJCT,MENU.PREV
COMMON LCK.STAT,PORTD
COMMON STRUCT(120),USER.UPD(20)
*
*,MENU.EI.APPL,MENU.NUM,MENU.TYPE
*COMMON LO.D.M,HI.D.M,HI.S.M,LO.TCL.M,LO.T.M,HI.T.M,LO.O.M,HI.O.M,LO.M.M,HI.M.M,LO.S.M
*COMMON OFF.RSP,TCL.RSP,SYS.RSP,BELL,LF,FF,CR,SVM,VM,AM,WHO,PORT,ACCT,CLS,CLL
*,STAT.CHECK
*COMMON YES,NO,TRUE,FALSE,TERMINAL,RVB,RVE
*,MENU(25),SLOC(25),PRMPT(25),PORTD(25)
*,MODE.DESC(30),STAT.DESC(15)
*
*
~SYS.ERR.INIT~
*CODE.SEGMENT: SYS.ERR.INIT
*
* DAVID HORSMAN
*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
PORT.NUM = PORT.KEY
PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORTS.LIST.BUILD = 9
PORT.CONT = FALSE; PORT.TYPE = EMPTY; PORT.ON = FALSE
PORT.LOC = ONE; PORT.VC = ONE
*
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
TMP = EMPTY; TMP0 = EMPTY; TPM1 = EMPTY; TMP2 = EMPTY
*
*
TEXT = EMPTY; OUTPUTS = EMPTY
MSG.DISP = FALSE; MSG = EMPTY; MSG.N = ZERO
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY; COM.AI.ERR.TYPE = EMPTY
COM.AI.ERR.FUNC = EMPTY; COM.AI.ERR.DISP = ONE
COM.AI.RUN.ELP = ZERO; COM.AI.ON = EMPTY; COM.AI.UP = EMPTY
*
ERR.DISP.ONLY = FALSE; ERR.CLB = FALSE
ERR.CL = 31; ERR.LN = 5; ERR.LEN = 48; ERR.FMT = EMPTY
ERR.LN.MIN = 5; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CLS = FALSE; ERR.BELL = FALSE; ERR.CR = FALSE
ERR.HDR = "Error Messages "; ERR.TEXT = EMPTY
ERR.LAST = EMPTY; ERR.TMP = EMPTY
*
CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 18
CHECK.LEN = 33; CHECK.LN.HI = ZERO
*
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
*
LCK.ELP.MAX = 60
*
~SYS.ERROR.CONTROL~
*CODE.SEGMENT: SYS.ERROR.CONTROL
*
* AUTHOR: DAVID G. HORSMAN
*
!
*INCLUDE DH.BP SYS.ERROR.CONTROL
*
*
*
ERROR.CONTROL: * Subroutine to display & log errors
ERROR.CN = 0
ERROR.FATAL = 99
ERROR.READ = 0
ERROR.WRITE = 0
*
LOOP
ERROR.CN = ERROR.CN + 1
ERROR.TEXT1 = ERROR.TEXT<1>
ERROR.CODE1 = ERROR.CODE<1>
ERROR.CODE2 = ERROR.CODE<2>
*
WHILE LEN(ERROR.TEXT:ERROR.CODE) # 0 DO
PRINT @(0,21):CLS:@(0,23):
IF LEN(ERROR.CODE1) =0 THEN ERROR.CODE1 = 5
IF NOT(NUM(ERROR.CODE1)) THEN ERROR.CODE1 = 5
IF ERROR.CODE1 < 5 ! (ERROR.CODE1 > 10 & ERROR.CODE1 < 13) THEN PRINT BELL:
*
ERROR.DISP = TRIM((USER.NAME:", ":ERROR.TEXT1)[1,75])
PRINT ERROR.DISP:
*
IF ERROR.CODE1 < 3 THEN PRINT "!  ": ELSE
IF ERROR.CODE1 < 5 ! (ERROR.CODE1 > 10 & ERROR.CODE1 < 13) THEN
PRINT ".  ":
END ELSE
IF ERROR.CODE2 # "" THEN PRINT ", ": ELSE PRINT ".  ":
END
END
*
ERROR.RSP = ""
IF ERROR.CODE1 < 5 ! (ERROR.CODE1 > 10 & ERROR.CODE1 < 13) THEN
PRINT "Enter <CR>":BELL:
INPUT ERROR.RSP:
END ELSE RQM; RQM
*
IF ERROR.CODE1 < 3 THEN
FOR A = 1 TO 3
RQM
PRINT BELL:
NEXT A
END
*
IF NOT(ERROR.READ) THEN
READ ERROR.REC FROM SY.FILE,"@ERRORS@":USER.NAME ELSE ERROR.REC = ""
ERROR.READ = 1
END
*
*
*1 IS SCRUTINIZED
*2 IS PURGE
*3 IS ANY ACTIONS TO
*4 IS APPLICATION
*5 IS MENU NUMBER
*6 IS MENU OPTION
*7 IS PROGRAM NAME
*8 IS PROGRAM LOCATION
*9 IS PROGRAM SUB-LOCATION
*10 IS PORT
*11 IS ACCOUNT
*12 IS DATE
*13 IS TIME
*14 IS SEVERITY OF ERROR
*15 IS TEXT FOR DISPLAY
*16 IS WHAT USER TYPED IS RESPONSE TO 'ENTER <CR>'
*
*
IF ERROR.CODE < 11 THEN
ERROR.REC1 = "0":VM:"0":VM:VM:VM:VM:VM:SYS.PROG:VM:SYS.LOCT:VM:SYS.SLOC
ERROR.REC1 = ERROR.REC1:VM:PORT:VM:ACCT:VM:DATE():VM:TIME()
ERROR.REC1 = ERROR.REC1:VM:ERROR.CODE1:VM:ERROR.TEXT1:VM:ERROR.RSP:AM:ERROR.REC
ERROR.REC = ERROR.REC1
ERROR.REC1 = ""
END
*
IF ERROR.FATAL > ERROR.CODE1 THEN ERROR.FATAL = ERROR.CODE1
ERROR.CODE = DELETE(ERROR.CODE,1)
ERROR.TEXT = DELETE(ERROR.TEXT,1)
REPEAT
*
IF ERROR.READ & NOT(ERROR.WRITE) THEN
WRITE ERROR.REC ON SY.FILE,"@ERRORS@":USER.NAME
ERROR.WRITE =1
END
*
IF ERROR.FATAL = 1 THEN CHAIN "MENU-RUN OFF"
*
IF ERROR.FATAL = 2 THEN STOP
*
IF ERROR.FATAL = 3 THEN
FOR A = 1 TO 10
RQM
NEXT A
END
*
RETURN
*
!
~SYS.ERROR.STRUCT~
*CODE.SEGMENT: SYS.ERROR.STRUCT
*
!
*#INCLUDE DH.BP SYS.ERROR.CONTROL
*#
*#
*# ERROR.CODE1 = 0        DON'T DISPLAY (SECURITY)
*# ERROR.CODE1 = 1 OR 2   DISPLAY
*# ERROR.CODE1 = 3        SLAVE MODE DON'T INPUT
*# ERROR.CODE1 = 4        DIAL-UP PORT HUNG DON'T DISP OR INPUT
*#
*# ERROR.CODE2 = SEVERITY
*#
*# ERROR.CODE3 = WRITE FLAG
*#
*# ERROR.CODE4 = BELL FLAG
*#
*# ERROR.CODE5 = ENTRY FLAG (ERROR.RSP)
*#
*#
ERROR.CONTROL: *# Subroutine to display & log errors
ERROR.CN = 0
ERROR.FATAL = 99
*ERROR.READ = 0
*ERROR.WRITE = 0
*#
LOOP
ERROR.CN = ERROR.CN + 1
ERROR.TEXT1 = ERROR.TEXT<1>
ERROR.CODE1 = ERROR.CODE<1>[1,1]
ERROR.CODE2 = ERROR.CODE<1>[2,1]
ERROR.CODE3 = ERROR.CODE<1>[3,1]
ERROR.CODE4 = ERROR.CODE<1>[4,1]
ERROR.CODE5 = ERROR.CODE<1>[5,1]
*#
*#WHILE LEN(ERROR.TEXT:ERROR.CODE) DO
IF LEN(ERROR.TEXT<2>:ERROR.CODE<2>) THEN ERROR.MORE = 1 ELSE ERROR.MORE = 0
IF LEN(ERROR.TEXT:ERROR.CODE) THEN
*#
IF ERROR.CODE2 LT 4 AND ERROR.CODE1 THEN ERROR.CODE3 = 1
*#
IF STRUCT(27)<1,PORT+1> GT 0 AND STRUCT(27)<1,PORT+1> LT 11 THEN ERROR.CODE1 = 3
*#
IF ERROR.CODE1 AND ERROR.CODE1 LT 4 THEN
ERROR.LN = ERROR.CODE[6,2]
IF NOT(NUM(ERROR.LN)) THEN ERROR.LN = 22
IF NOT(LEN(ERROR.LN)) OR ERROR.LN LT 0 THEN ERROR.LN = 22
ERROR.CL = ERROR.CODE[8,2]
IF NOT(NUM(ERROR.CL)) THEN ERROR.CL = 0
IF NOT(LEN(ERROR.CL)) OR ERROR.CL LT 0 THEN ERROR.CL = 0
IF ERROR.CODE2 LT 4 THEN
ERROR.LN = 10
PRINT @(0,5):CLS:BELL:
RQM
PRINT BELL:
ERROR.CODE5 = 1
END
*#PRINT @(0,21):CLL:
IF NOT(ERROR.CL) THEN PRINT @(0,ERROR.LN):CLL:
PRINT @(ERROR.CL,ERROR.LN):
IF ERROR.CODE4 THEN PRINT BELL:; RQM
IF ERROR.CODE1 EQ 1 THEN
ERROR.DISP = TRIM((USER.NAME:", ":ERROR.TEXT1)[1,75])
ERROR.DISP = RVB:"[=| ":RVE:ERROR.DISP
END ELSE ERROR.DISP = RVB:"[=| ":RVE:TRIM(ERROR.TEXT1)
IF ERROR.CODE2 LT 4 THEN PRINT RVB:
PRINT ERROR.DISP:
IF ERROR.CODE2 LT 4 THEN PRINT "!  ": ELSE
IF ERROR.CODE5 EQ 1 THEN
PRINT ".  ":
END ELSE IF ERROR.CODE1 NE 2 THEN
IF ERROR.MORE THEN PRINT ", ": ELSE IF NOT(ERROR.CODE5) THEN PRINT ".":
END ELSE
PRINT " ":
END
END
IF ERROR.CODE2 LT 4 THEN PRINT RVE:
END
*#
*#
ERROR.RSP = ""
IF ERROR.CODE5 AND ERROR.CODE1 AND ERROR.CODE1 LT 3 THEN
ERROR.LEN = ERROR.CODE[10,3]
IF ERROR.LEN EQ '' OR NOT(NUM(ERROR.LEN)) THEN ERROR.LEN = 50
IF ERROR.LEN LT 1 THEN ERROR.LEN = 50
IF ERROR.CODE5 EQ 1 THEN PRINT "Enter <CR>   ":
FOR TEMP = 1 TO 10 UNTIL SYSTEM(11) OR ERROR.CODE5 EQ 2
IF NOT(SYSTEM(11)) THEN RQM
NEXT TEMP
IF SYSTEM(11) OR ERROR.CODE2 LT 6 OR ERROR.CODE5 EQ 2 THEN
*#INPUT ERROR.RSP:
OLD.RSP = ERROR.RSP
IF ERROR.CL+ERROR.LEN GT 80 THEN ERROR.LEN = 79 - ERROR.CL
IF ERROR.CODE5 EQ 2 THEN ERROR.FORCE = 1 ELSE ERROR.FORCE = 0
CALL SYS.LINE.INPUT(ERROR.CL+LEN(ERROR.DISP)+1,ERROR.LN,ERROR.LEN,OLD.RSP,ERROR.RSP,0,1,1,ERROR.FORCE)
IF INDEX(OFF.RSP,"*":ERROR.RSP:"*",1) OR INDEX(TCL.RSP,"*":ERROR.RSP:"*",1) THEN
PRINT @(0,23):CLL:RVB:"[SYSTEM DEBUG|> ":RVE:
INPUT TEMP.RSP:
IF TEMP.RSP EQ 'APEX ABORT' THEN
IF INDEX(OFF.RSP,"*":ERROR.RSP:"*",1) THEN EXECUTE "OFF"
IF INDEX(TCL.RSP,"*":ERROR.RSP:"*",1) THEN STOP
RETURN
END; *# OF APEX ABORT
END; *# OF OFF OR TCL COMMAND
END ELSE ERROR.RSP = "" ; *# OF SYSTEM(11) OR ERROR.CODE2 LT 6
END; *# OF ERROR.CODE5 AND ERROR.CODE1 AND ERROR.CODE1 LT 3
*#
WAIT.TEMP = WAIT.FLAG - 1
IF NOT(NUM(WAIT.TEMP)) THEN WAIT.TEMP = 3
IF WAIT.TEMP LT 0 THEN WAIT.TEMP = 0
IF NOT(LEN(WAIT.TEMP)) THEN WAIT.TEMP = 3
FOR A = 1 TO WAIT.TEMP UNTIL SYSTEM(11); RQM; NEXT A
*#
*#
IF ERROR.CODE3 THEN
*IF NOT(ERROR.READ) THEN
READV NEXT.ERROR FROM SY.FILE,"@ERRORS@":USER.NAME,1 ELSE NEXT.ERROR = 2
*ERROR.READ = 1
*END
*#
*#1 IS SCRUTINIZED
*#2 IS PURGE
*#3 IS ANY ACTIONS TO
*#4 IS APPLICATION
*#5 IS MENU NUMBER
*#6 IS MENU OPTION
*#7 IS PROGRAM NAME
*#8 IS PROGRAM LOCATION
*#9 IS PROGRAM SUB-LOCATION
*#10 IS PORT
*#11 IS ACCOUNT
*#12 IS DATE
*#13 IS TIME
*#14 IS SEVERITY OF ERROR
*#15 IS TEXT FOR DISPLAY
*#16 IS WHAT USER TYPED IS RESPONSE TO 'ENTER <CR>'
*#
*#
ERROR.REC = '0':VM:'0':VM:STRUCT(5):VM:MENU.APPL:VM:MENU.CONTROL<1,9>:VM:PRMPTING
ERROR.REC = ERROR.REC:VM:SYS.PROG<1>:VM:SYS.LOCT<1>:VM:SYS.SLOC<1>:VM
ERROR.REC = ERROR.REC:PORT:VM:ACCT:VM:DATE():VM:TIME()
ERROR.REC = ERROR.REC:VM:ERROR.CODE<1>:VM:ERROR.TEXT1:VM:ERROR.RSP
*#
WRITEV ERROR.REC ON SY.FILE,"@ERRORS@":USER.NAME,NEXT.ERROR
NEXT.ERROR = NEXT.ERROR + 1
WRITEV NEXT.ERROR ON SY.FILE,"@ERRORS@":USER.NAME,1
*ERROR.WRITE =1
ERROR.REC = ""
END
*#
IF NUM(ERROR.CODE2) THEN
IF ERROR.FATAL GT ERROR.CODE2 THEN ERROR.FATAL = ERROR.CODE2
END
*#
ERROR.CODE = DELETE(ERROR.CODE,1)
ERROR.TEXT = DELETE(ERROR.TEXT,1)
*#
*REPEAT
END; *# OF LEN(ERROR.TEXT:ERROR.CODE)
WHILE ERROR.MORE DO REPEAT
*#
*IF ERROR.WRITE THEN WRITEV NEXT.ERROR ON SY.FILE,"@ERRORS@":USER.NAME,1
IF NOT(NUM(ERROR.FATAL)) THEN ERROR.FATAL = 0
IF ERROR.FATAL EQ 1 THEN EXECUTE "OFF"
IF ERROR.FATAL EQ 2 THEN STOP
IF ERROR.FATAL EQ 3 THEN PRINT BELL:
ERROR.TEXT = ''
RETURN
*#
!
*#
SYS.CLEAR.PAGE.MID: *#
FOR TEMP = CLS.LO TO CLS.HI WHILE NOT(SYSTEM(11)) OR TEMP LT 14
PRINT @(0,TEMP):CLL:RVB:"[":@(79):RVB:"]":RVE:
NEXT TEMP
CLS.HI = 20
CLS.LO = 5
*#
RETURN; *# from gosub...
*#
!
~SYS.HEADING~
*CODE.SEGMENT: SYS.HEADING
*
* AUTHOR: DAVID G. HORSMAN
*
TEMP = 0
TEMP1 = 0
TEMP2 = 0
SCR.PORT = ""
SCR.UPD = ""
SCR.CNTR = ""
*
IF STRUCT(25)<1,PORT+1> THEN
*
IF STRUCT(70) > 0 THEN SCR.CNTR = (STRUCT(70)-1)[1,1] ELSE SCR.CNTR = "s"
IF STRUCT(91) > 0 THEN SCR.CNTR = SCR.CNTR:(STRUCT(91)-1)[1,1] ELSE SCR.CNTR = SCR.CNTR:"m"
IF WAIT.FLAG THEN SCR.CNTR = SCR.CNTR:WAIT.FLAG[1,1] ELSE SCR.CNTR = SCR.CNTR:"w"
*
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF STRUCT(21)<1,TEMP> # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVE
SCR.PORT = SCR.PORT:STRUCT(21)<1,TEMP>[1,1]
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVB; TEMP1 = 2
END ELSE
SCR.PORT = SCR.PORT:"o"
END
REPEAT
SCR.PORT = SCR.PORT[1,10+TEMP1]
*
TEMP = 0
TEMP2 = 0
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF USER.UPD(TEMP) # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVE
SCR.UPD = SCR.UPD:USER.UPD(TEMP)[1,1]
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVB; TEMP2 =TEMP2 + 2
END ELSE
SCR.UPD = SCR.UPD:"o"
END
REPEAT
SCR.UPD = SCR.UPD[1,10+TEMP2]
*
END
*
*
IF OUT.TO.PRINT = 1 THEN
PRINTER ON
PRINT FF
MAX.COL = 132
MAX.LN = 60
END ELSE
*
*# LINE 0 - LINE 0 - LINE 0
PRINT @(0,0):CLL:RVB: ; *#
MAX.COL = 80
MAX.LN = 20
END
*
*
PRINT (OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS")) "L#20": ; *#
PRINT (PORT:".":ACCT:".":STRUCT(2)) "L#13":" ": ; *#
*
IF STRUCT(25)<1,PORT+1> THEN PRINT " ":MODE.DESC(USER.MODE) "L#5":" ": ELSE PRINT SPACE(7): ; *#
PRINT MENU.APPL.DESC "L#39":
*#
*#v
*# LINE 1 - LINE 1 - LINE 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,1):RVB:CLL: ; *#
END
*#^
IF STRUCT(25)<1,PORT+1> THEN 
PRINT "[P ": ; *#
TEMP3 = "R#":(TEMP1+10)
PRINT SCR.PORT TEMP3: ; *#
PRINT "]": ; *#
END ELSE PRINT SPACE(14): ; *#
*
*
IF STRUCT(25)<1,PORT+1> THEN
PRINT "[U ": ; *#
TEMP3 = "L#":(TEMP2+10)
PRINT SCR.UPD TEMP3: ; *#
PRINT "]": ; *#
END ELSE PRINT SPACE(14): ; *#
IF STRUCT(25)<1,PORT+1> THEN PRINT ("[":SCR.CNTR[1,3]:"]") "L#5": ELSE PRINT SPACE(5): ; *#
PRINT "  ":
*# 40 CHARS AVAIL.
PRINT MENU.CONTROL<1,1> "L#45": ; *#
*
*# LINE 2 - LINE 2 - LINE 2
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,2):CLL: ; *#
END
PRINT CO.DATA<1,1,1> "L#35": ; *#
PRINT SYS.PROG.DESC "L#45": ; *#
*# LINE 3 - LINE 3 - LINE 3
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,3):CLL: ; *#
END
LN = 3
*
*
IF NOT(OUT.TO.PRINT) THEN PRINT RVE: ELSE PRINT
TEMP = 0
LOOP TEMP = TEMP + 1 WHILE LEN(SCR.HEADING<TEMP>) # 0 DO
PRINT SCR.HEADING[1,MAX.COL-1]: ; *#
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE PRINT @(0,LN):CLL: ; *#
REPEAT
*
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN
PRINT
PRINTER OFF
END ELSE
PRINT @(0,LN):CLS: ; *#
END
*
RETURN
*#**
*#**
~SYS.INCL.11.ABORT~
*CODE.SEGMENT: SYS.INCL.11.ABORT
*
*#$INCLUDE DH.IBP SYS.INCL.11.ABORT
*#
*#
IF SYSTEM(11) THEN
PRINT @(0,22):CLL:BELL:"Yes? ":
INPUT TEMP.RSP:
IF TEMP.RSP EQ "END" OR TEMP.RSP EQ "CAN" OR TEMP.RSP EQ "KILL" OR TEMP.RSP EQ CHAR(27) THEN
USER.ABORT = 1
END ELSE IF TEMP.RSP NE "" THEN
EXECUTE TEMP.RSP
END
END
*#
~SYS.INCL.14.BUSY~
*CODE.SEGMENT: SYS.INCL.14.BUSY
*#
*# DAVID HORSMAN - 31 MAR 88
*# 
STRUCT(14) = PORT+1
STRUCT(27)<1,PORT+1> = 11
*#
WRITEV STRUCT(14) ON SY.FILE,"@SYS@USER@":USER.NAME,14
*#
~SYS.INCL.142127~
*CODE.SEGMENT: SYS.INCL.142127
*#
*# DAVID HORSMAN - 31 MAR 88
*# 
READV STRUCT(14) FROM SY.FILE,"@SYS@USER@":USER.NAME,14 ELSE STRUCT(14) = F
READV TEMP1 FROM SY.FILE,"@SYS@USER@":USER.NAME,21 ELSE TEMP1 = F
READV TEMP FROM SY.FILE,"@SYS@USER@":USER.NAME,27 ELSE TEMP = F
*#
IF STRUCT(14) THEN
PRINT @(44,23):RVB:" | Cport":STRUCT(14)-1 "R#2":" | ":RVE:@(75):RVB:" |=]":RVE:
CPORT = STRUCT(14)
END
*#
*#
IF STRUCT(14) NE PORT+1 AND NOT(SYSTEM(11)) THEN
IF TEMP<1,PORT+1> LT 1 OR TEMP<1,PORT+1> GT 11 THEN
LOOP WHILE TEMP<1,PORT+1> LE 0 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> + 10 REPEAT
LOOP WHILE TEMP<1,PORT+1> GE 11 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> - 10 REPEAT
STRUCT(27) = TEMP
WRITEV TEMP ON SY.FILE,"@SYS@USER@":USER.NAME,27
END
END ELSE
*
LOOP WHILE TEMP<1,PORT+1> LE 10 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> + 10 REPEAT
LOOP WHILE TEMP<1,PORT+1> GT 21 DO TEMP<1,PORT+1> = TEMP<1,PORT+1> - 10 REPEAT
FOR A = 1 TO 20 UNTIL NOT(LEN(TEMP1<1,A>))
IF A NE PORT+1 AND TEMP1<1,A> AND TEMP<1,A> GE 11 THEN TEMP<1,A> = 4; TEMP1<1,A> = 4
NEXT A
STRUCT(14) = PORT+1
WRITEV STRUCT(14) ON SY.FILE,"@SYS@USER@":USER.NAME,14
STRUCT(27) = TEMP
WRITEV TEMP ON SY.FILE,"@SYS@USER@":USER.NAME,27
STRUCT(21) = TEMP1
WRITEV TEMP1 ON SY.FILE,"@SYS@USER@":USER.NAME,21
PRINT @(44,23):RVB:" | Cport":STRUCT(14)-1 "R#2":" | ":RVE:@(75):RVB:" |=]":RVE:
CPORT = STRUCT(14)
END; * of slave/controlling port (0-10 / 11-20)
*#
*#
~SYS.INCL.21.BUSY~
*CODE.SEGMENT: SYS.INCL.21.BUSY
*#
*# DAVID HORSMAN - 31 MAR 88
*# 
READV STRUCT(21) FROM SY.FILE,"@SYS@USER@":USER.NAME,21 ELSE STRUCT(21) = F
*#
IF STRUCT(21)<1,PORT+1> EQ 5 THEN STRUCT(21)<1,PORT+1> = 6
IF STRUCT(21)<1,PORT+1> EQ 1 THEN STRUCT(21)<1,PORT+1> = 2
*#
WRITEV STRUCT(21) ON SY.FILE,"@SYS@USER@":USER.NAME,21
*#
~SYS.INCL.21.CHECK~
*CODE.SEGMENT: SYS.INCL.21.CHECK
*#
*# subroutine to check if a reset is required
*# 
*# 
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@USER@":STRUCT(2)
*#
READV STRUCT(21) FROM SY.FILE,SYS.ITEM,21 THEN
IF STRUCT(21)<1,PORT+1> EQ F THEN STRUCT(21)<1,PORT+1> = T
END ELSE
STRUCT(21)<1,PORT+1> = 9
WRITEV STRUCT(21) ON SY.FILE,SYS.ITEM,21
END
*#
IF (STRUCT(21)<1,PORT+1> GE 3 AND STRUCT(21)<1,PORT+1> LE 4) OR STRUCT(21)<1,PORT+1> GT 6 THEN
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "RESET"
GOSUB RECORD.USER.CALL
*#RSP = MENU.NAME
RSP = F
END
*# 
IF PORTD<5> NE "D" THEN PRINT @(4,23):RVB:" | C Reset | ":RVE:
*#
~SYS.INCL.ABORT.CHECK~
*CODE.SEGMENT: SYS.INCL.ABORT.CHECK
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: APR 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF ABORT.OK THEN
*
CP<ABORT.PRESENT> = "Abort is: ":ABORT.FLAG<ONE>
IF COUNT(ABORT.FLAG,AM) GE TWO THEN
IF NUM(ABORT.FLAG<TWO>) AND NUM(ABORT.FLAG<3>) THEN
IF (ABORT.FLAG<TWO> AND DATE() GT ABORT.FLAG<TWO>) OR (DATE() GE ABORT.FLAG<TWO> AND TIME() GE ABORT.FLAG<3>) THEN
IF ABORT.DEL THEN DELETE PAR.FILE,"TRANSFER.ABORT":PORT
ABORT.OK = FALSE
END; *# of date/time
END
END
*
IF ABORT.OK THEN
IF NUM(ABORT.FLAG<ONE>) THEN DONE.FLAG = ABORT.FLAG<ONE> ELSE DONE.FLAG = ABORT.PRESENT
MAX = DCOUNT(ITEM,AM)
IF ITEM[1,1] NE ESC AND ITEM[1,1] NE "@" THEN
ITEM = ESC:"ABORT"; MAX = ONE; CN = ZERO
END ELSE
IF ITEM<MAX> NE ESC:"END" THEN MAX = MAX + ONE
ITEM<MAX> = ESC:"ABORT"
END
ITEM<-ONE> = ESC:"END"; MAX = MAX + ONE
TMP = TRIM(ABORT.FLAG<ONE>[ONE,4])
IF TMP EQ "OFF" THEN STAT = LOGOFF.COMMAND
END ELSE ABORT.FLAG = EMPTY
*
END ELSE
ABORT.FLAG = EMPTY
IF DONE.FLAG EQ ABORT.PRESENT THEN DONE.FLAG = FALSE
END
*      
~SYS.INCL.ABORT.CHECK.READ~
*CODE.SEGMENT: SYS.INCL.ABORT.CHECK.READ
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: APR 89
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
READ ABORT.FLAG FROM PAR.FILE,FKEY.ID THEN FKEY.FOUND = TRUE; ABORT.OK = TRUE; ABORT.DEL = FALSE ELSE ABORT.OK = FALSE; ABORT.DEL = FALSE; FKEY.FOUND = FALSE
*
~SYS.INCL.ACC.OPSYS~
*CODE.SEGMENT: SYS.INCL.ACC.OPSYS
*
* AUTHOR: David Horsman
* COMPANY: Macroscope Design Matrix
* RELEASED: 15 June 91
*
* Copyright (c) 1992 All rights reserved
*
READ ACC.FMT.REC FROM COM.FILE,"ACC.FMT" THEN
*
ACC.FILE.DICT = ACC.FMT.REC<ONE>
ACC.FILE.NAME = ACC.FMT.REC<TWO>
ACC.ID = ("000":PORT) "R#3"
ACC.AM.DESC = ACC.FMT.REC<4>
ACC.AM.DT = ACC.FMT.REC<5>
ACC.AM.TM = ACC.FMT.REC<6>
ACC.AM.VERB = ACC.FMT.REC<7>
ACC.DESC.FMT = ACC.FMT.REC<8>
*
END ELSE
*
*
BEGIN CASE
*
CASE OPSYS EQ "M"
ACC.FILE.DICT = "DICT"
ACC.FILE.NAME = "ACC"
ACC.ID = ("000":PORT) "R#3"
ACC.AM.DESC = 4
ACC.AM.DT = 5
ACC.AM.TM = 6
ACC.AM.VERB = 7
ACC.DESC.FMT = "L#30"
*
CASE OPSYS EQ "U"
ACC.FILE.DICT = "DICT"
ACC.FILE.NAME = "ACC"
ACC.ID = "MENU.":("000":PORT) "R#3"
ACC.AM.DESC = 4
ACC.AM.DT = 5
ACC.AM.TM = 6
ACC.AM.VERB = 7
ACC.DESC.FMT = "L#30"
*
CASE OPSYS EQ "R"
ACC.FILE.DICT = EMPTY
ACC.FILE.NAME = "LISTS"
ACC.ID = "PORT.":("000":PORT) "R#3"
ACC.AM.DESC = ONE
ACC.AM.DT = 5
ACC.AM.TM = 6
ACC.AM.VERB = 7
ACC.DESC.FMT = "L#30"
*
CASE TRUE
ACC.FILE.DICT = EMPTY
ACC.FILE.NAME = "SYS"
ACC.ID = "PORT.":("000":PORT) "R#3"
ACC.AM.DESC = ONE
ACC.AM.DT = TWO
ACC.AM.TM = 3
ACC.AM.VERB = 4
ACC.DESC.FMT = "L#30"
STOP
*
END CASE
*
END; * 
*
~SYS.INCL.ACK.OR.SEND~
*CODE.SEGMENT: SYS.INCL.ACK.OR.SEND
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 23 SEP 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
ACK.RSP.INPUT: * Subroutine to input ACK.RSP
*
B = ZERO
IF ACK.RSP NE "GO" THEN ACK.RSP = ""
VALID.PKT = ZERO
*
LOOP
*
A = ZERO
TMP = ERR.CN
IF DIR.FLAG EQ DOUT THEN TMP = INT(TMP/TWO)
IF TMP LE ERR.LOW THEN TMP = ERR.LOW
IF TMP GT ERR.HI AND ERR.HI THEN TMP = ERR.HI
TMP = TMP + ERR.IN.OFFSET
CHAR.PAUSE = TMP * (ONE+TMP/10) * 20
LOOP
*
A = A + ONE
ACK.CHAR.CN = SYSTEM(ELEVEN); * ULT ONLY
*%%MDD%%=ACK.CHAR.CN = SYSTEM(14)
*
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT CHAR.PAUSE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
*
IF A GT 47 THEN RQM; * IF DIR.FLAG EQ DOUT THEN RQM
ACK.CHAR.CN1 = SYSTEM(ELEVEN); * ULT ONLY
*%%MDD%%=ACK.CHAR.CN1 = SYSTEM(14)
*
WHILE A LE 50 AND ACK.RSP EQ "" AND (ACK.CHAR.CN NE ACK.CHAR.CN1 OR ACK.CHAR.CN LT 4) AND ACK.CHAR.CN LT LINE.MAX.LEN+15 DO REPEAT
*
IF A LT 50 THEN
*
IF ACK.RSP EQ "" THEN ACK.RSP = "?NO RSP?"
*
* ACK.CHAR.CN1 = SYSTEM(ELEVEN); * ULT ONLY
* *%%MDD%%=ACK.CHAR.CN1 = SYSTEM(14)
*
IF ACK.CHAR.CN1 GT 4 THEN
*
B = B + ONE
*
INPUT ACK.RSP,ACK.CHAR.CN1 - ONE:
*
LOOP UNTIL NOT(LEN(ACK.RSP)) OR ACK.RSP EQ "GO" OR ACK.RSP[ONE,LEN(ESC)] EQ ESC OR ACK.RSP[ONE,LEN(PICK.ESC)] EQ PICK.ESC OR ACK.RSP[ONE,ONE] EQ "*" OR ACK.RSP[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE DO
IF (ACK.RSP EQ "OFF" OR ACK.RSP EQ "KILL") THEN STOP
ACK.RSP = ACK.RSP[TWO,HI.NUM]
REPEAT
*
IF ACK.RSP[ONE,ONE] EQ "*" THEN
PRINT CR:
PRINT "G":CR:
PRINT CR:
END
*
* Packet validation
VALID.PKT = TRUE
FOR TMP = ONE TO 3 WHILE LEN(ACK.RSP) AND VALID.PKT
* Trim ESC or PICK.ESC char
IF ACK.RSP[ONE,LEN(ESC)] EQ ESC THEN
TMP = ONE
ACK.RSP = ACK.RSP[LEN(ESC)+ONE,HI.NUM]
END ELSE IF ACK.RSP[ONE,LEN(PICK.ESC)] EQ PICK.ESC THEN
TMP = ONE
ACK.RSP = ACK.RSP[LEN(PICK.ESC)+ONE,HI.NUM]
* Trim  Start block char
END ELSE IF ACK.RSP[ONE,LEN(STB)] EQ STB THEN
IF TMP NE TWO THEN VALID.PKT = FALSE
ACK.RSP = ACK.RSP[LEN(STB)+ONE,HI.NUM]
END ELSE IF ACK.RSP[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE THEN
LINE.MESSAGE = ACK.RSP; GOSUB PACKET.ERROR.RECVD
VALID.PKT = FALSE
END ELSE
IF TMP EQ 3 THEN VALID.PKT = TRUE ELSE VALID.PKT = FALSE
END
NEXT TMP
*
END; * GT 4
*
* Loop back for bad block
IF ERR.CN GE ERR.MAX AND ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERR.ABORT.VRF
*
* ACK.CHAR.CN1 = ZERO; * REV ONLY
*
END ELSE
ERR.CN = ERR.CN + ONE
END; * OF A LT 50
*
UNTIL ACK.RSP EQ "GO" OR B GT 30 OR ACK.CHAR.CN1 LE 4OR STAT EQ MAX.ERR.ABORT.VRF DO
*
IF VALID.PKT THEN
IF ERR.CN GT ERR.LOW THEN
*IF ERR.CN.LAST LE ERR.CN.LAST.HI THEN 
ERR.CN = ERR.CN - ONE; ERR.CN.LAST = ERR.CN.LAST.HI
*END ELSE ERR.CN.LAST = ERR.CN.LAST - ONE
END
END
*
REPEAT
*
*
RETURN
*
CHAR.SEND.PKT: * Subroutine to send packet
*
TMP = ERR.CN
IF TMP GT ERR.HI THEN TMP = ERR.HI
IF TMP LT ERR.LOW THEN TMP = ERR.LOW
TMP = TMP + ERR.OUT.OFFSET
IF TMP LT ONE THEN TMP = ONE
CHAR.PAUSE = (TMP-ONE) * (ONE+TMP/20)
TC = ZERO
*
LOOP
TC = TC + ONE
TC.CHAR = LINE.PACKET[TC,ONE]
WHILE LEN(TC.CHAR) DO
IF SEQ(TC.CHAR) GE 252 THEN TC.CHAR = CHAR(SEQ(TC.CHAR)-224)
PRINT TC.CHAR:
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT CHAR.PAUSE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
REPEAT
*
RETURN
*
~SYS.INCL.AVG.DAY~
*CODE.SEGMENT: SYS.INCL.AVG.DAY
*
*$INCLUDE DH.IBP SYS.INCL.AVG.DAY
*
AVG.DAY = 10
*
~SYS.INCL.BATCH.RSP~
*CODE.SEGMENT: SYS.INCL.BATCH.RSP
*
EQU BATCH.RSP TO "*LISTU*ULIST*UL*SYS.ULIST*WHERE*WHO*TIME*DATE*LISTVERBS*LISTDICT*BLIST*CATALOG*BASIC*CLEAR-FILE*CLEAR-LOCKS-MACRO*CLEAR.LOCKS*DECATALOG*SEARCH*"
*QLISTFILES*LISTFILES*DELETE*LIST*SORT*COPY*"
*
~SYS.INCL.CALC.BCC~
*CODE.SEGMENT: SYS.INCL.CALC.LRC
*
* COMPANY: AXION / MACROSCOPE DESIGN MAXTRIX
*
* AUTHOR: DAVID HORSMAN
*
*   NOTE: THIS CALCULATION IS A PART OF AXION COMPUTER SOFTWARE'S
* GENERAL (AND EAGLE) ON PREMISE ADDRESSABLE INTERFACE SOFTWARE
* AND IS A PART OF THE KBIL SUBSCRIBER BILLING SYSTEM.
*
*
***** LRC
TC.SUM = "00000000"
TC.CN = ZERO
TC.MAX = LEN(TC.PACKET)
*
LOOP
*
TC.CN = TC.CN + ONE
IF LBL.DISP THEN PRINT "CHAR # ":TC.CN:" ":
*
S8 = TC.SUM[ONE,ONE]
S7 = TC.SUM[TWO,ONE]
S6 = TC.SUM[3,ONE]
S5 = TC.SUM[4,ONE]
S4 = TC.SUM[5,ONE]
S3 = TC.SUM[6,ONE]
S2 = TC.SUM[7,ONE]
S1 = TC.SUM[8,ONE]
*
UNTIL TC.CN GT TC.MAX DO
*
TC = TC.PACKET[TC.CN,ONE]
*
IF LBL.DISP THEN PRINT TC:" ":
*
TC.SEQ = SEQ(TC)
*
IF LBL.DISP THEN
PRINT TC.SEQ
PRINT
PRINT "SUM ":TC.SUM
END
*
IF TC.SEQ GT 127 THEN T8 = "1"; TC.SEQ = TC.SEQ - 128 ELSE T8 = "0"
IF TC.SEQ GT  63 THEN T7 = "1"; TC.SEQ = TC.SEQ -  64 ELSE T7 = "0"
IF TC.SEQ GT  31 THEN T6 = "1"; TC.SEQ = TC.SEQ -  32 ELSE T6 = "0"
IF TC.SEQ GT  15 THEN T5 = "1"; TC.SEQ = TC.SEQ -  16 ELSE T5 = "0"
IF TC.SEQ GT   7 THEN T4 = "1"; TC.SEQ = TC.SEQ -   8 ELSE T4 = "0"
IF TC.SEQ GT   3 THEN T3 = "1"; TC.SEQ = TC.SEQ -   4 ELSE T3 = "0"
IF TC.SEQ GT   1 THEN T2 = "1"; TC.SEQ = TC.SEQ -   2 ELSE T2 = "0"
IF TC.SEQ THEN T1 = "1" ELSE T1 = "0"
*
IF LBL.DISP THEN
PRINT "MAP ":T8:T7:T6:T5:T4:T3:T2:T1
END
*
IF (T8 OR S8) AND NOT(T8 AND S8) THEN S8 = "1" ELSE S8 = "0"
IF (T7 OR S7) AND NOT(T7 AND S7) THEN S7 = "1" ELSE S7 = "0"
IF (T6 OR S6) AND NOT(T6 AND S6) THEN S6 = "1" ELSE S6 = "0"
IF (T5 OR S5) AND NOT(T5 AND S5) THEN S5 = "1" ELSE S5 = "0"
IF (T4 OR S4) AND NOT(T4 AND S4) THEN S4 = "1" ELSE S4 = "0"
IF (T3 OR S3) AND NOT(T3 AND S3) THEN S3 = "1" ELSE S3 = "0"
IF (T2 OR S2) AND NOT(T2 AND S2) THEN S2 = "1" ELSE S2 = "0"
IF (T1 OR S1) AND NOT(T1 AND S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF LBL.DISP THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
REPEAT
*
TC.SEQ = 0
IF S8 THEN TC.SEQ = TC.SEQ + 128
IF S7 THEN TC.SEQ = TC.SEQ +  64
IF S6 THEN TC.SEQ = TC.SEQ +  32
IF S5 THEN TC.SEQ = TC.SEQ +  16
IF S4 THEN TC.SEQ = TC.SEQ +   8
IF S3 THEN TC.SEQ = TC.SEQ +   4
IF S2 THEN TC.SEQ = TC.SEQ +   2
TC.SEQ = TC.SEQ + S1
*
TC.HEX = OCONV(CHAR(TC.SEQ),"MX")
TC.HEX = ("00":TC.HEX) "R#2"
*
IF LBL.DISP THEN PRINT "END > SEQ ":TC.SEQ:"    HEX ":TC.HEX
*
*
~SYS.INCL.CALC.LRC~
*CODE.SEGMENT: SYS.INCL.CALC.LRC
* USED BY: AI.PARSE.INPUT.EA
*          AI.PARSE.OUTPUT.EA
*          AI.TEST.LRC
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
* AUTHOR: DAVID HORSMAN
*
*   NOTE: THIS CALCULATION IS A PART OF AXION COMPUTER SOFTWARE'S
* GENERAL (AND EAGLE) ON PREMISE ADDRESSABLE INTERFACE SOFTWARE
* AND IS A PART OF THE KBIL SUBSCRIBER BILLING SYSTEM.
*
*
***** LRC
TC.SUM = "00000000"
TC.CN = ZERO
TC.MAX = LEN(TC.PACKET)
*
LOOP
*
TC.CN = TC.CN + ONE
IF CNT.TST$LBL THEN PRINT "CHAR # ":TC.CN:" ":
*
S8 = TC.SUM[ONE,ONE]
S7 = TC.SUM[TWO,ONE]
S6 = TC.SUM[3,ONE]
S5 = TC.SUM[4,ONE]
S4 = TC.SUM[5,ONE]
S3 = TC.SUM[6,ONE]
S2 = TC.SUM[7,ONE]
S1 = TC.SUM[8,ONE]
*
UNTIL TC.CN GT TC.MAX DO
*
TC = TC.PACKET[TC.CN,ONE]
*
IF CNT.TST$LBL THEN PRINT TC:" ":
*
TC.SEQ = SEQ(TC)
*
IF CNT.TST$LBL THEN
PRINT TC.SEQ
PRINT
PRINT "SUM ":TC.SUM
END
*
IF TC.SEQ GT 127 THEN T8 = "1"; TC.SEQ = TC.SEQ - 128 ELSE T8 = "0"
IF TC.SEQ GT  63 THEN T7 = "1"; TC.SEQ = TC.SEQ -  64 ELSE T7 = "0"
IF TC.SEQ GT  31 THEN T6 = "1"; TC.SEQ = TC.SEQ -  32 ELSE T6 = "0"
IF TC.SEQ GT  15 THEN T5 = "1"; TC.SEQ = TC.SEQ -  16 ELSE T5 = "0"
IF TC.SEQ GT   7 THEN T4 = "1"; TC.SEQ = TC.SEQ -   8 ELSE T4 = "0"
IF TC.SEQ GT   3 THEN T3 = "1"; TC.SEQ = TC.SEQ -   4 ELSE T3 = "0"
IF TC.SEQ GT   1 THEN T2 = "1"; TC.SEQ = TC.SEQ -   2 ELSE T2 = "0"
IF TC.SEQ THEN T1 = "1" ELSE T1 = "0"
*
IF CNT.TST$LBL THEN
PRINT "MAP ":T8:T7:T6:T5:T4:T3:T2:T1
END
*
IF (T8 OR S8) AND NOT(T8 AND S8) THEN S8 = "1" ELSE S8 = "0"
IF (T7 OR S7) AND NOT(T7 AND S7) THEN S7 = "1" ELSE S7 = "0"
IF (T6 OR S6) AND NOT(T6 AND S6) THEN S6 = "1" ELSE S6 = "0"
IF (T5 OR S5) AND NOT(T5 AND S5) THEN S5 = "1" ELSE S5 = "0"
IF (T4 OR S4) AND NOT(T4 AND S4) THEN S4 = "1" ELSE S4 = "0"
IF (T3 OR S3) AND NOT(T3 AND S3) THEN S3 = "1" ELSE S3 = "0"
IF (T2 OR S2) AND NOT(T2 AND S2) THEN S2 = "1" ELSE S2 = "0"
IF (T1 OR S1) AND NOT(T1 AND S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF CNT.TST$LBL THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
REPEAT
*
TC.SEQ = 0
IF S8 THEN TC.SEQ = TC.SEQ + 128
IF S7 THEN TC.SEQ = TC.SEQ +  64
IF S6 THEN TC.SEQ = TC.SEQ +  32
IF S5 THEN TC.SEQ = TC.SEQ +  16
IF S4 THEN TC.SEQ = TC.SEQ +   8
IF S3 THEN TC.SEQ = TC.SEQ +   4
IF S2 THEN TC.SEQ = TC.SEQ +   2
TC.SEQ = TC.SEQ + S1
*
TC.HEX = OCONV(CHAR(TC.SEQ),"MX")
TC.HEX = ("00":TC.HEX) "R#2"
*
IF CNT.TST$LBL THEN PRINT "END > SEQ ":TC.SEQ:"    HEX ":TC.HEX
*
*
~SYS.INCL.CALC.XOR.COMPL~
*CODE.SEGMENT: SYS.INCL.CALC.LRC
* USED BY: AI.PARSE.INPUT.PA
*          AI.PARSE.OUTPUT.PA
*          AI.TEST.XOR
*
*
* AUTHOR: DAVID HORSMAN
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
*   NOTE: THIS CALCULATION IS A PART OF AXION COMPUTER SOFTWARE'S
* GENERAL (AND EAGLE) ON PREMISE ADDRESSABLE INTERFACE SOFTWARE
* AND IS A PART OF THE KBIL SUBSCRIBER BILLING SYSTEM.
*
*
***** LRC
TC.SUM = "00000000"
TC.CN = ZERO
TC.MAX = LEN(TC.PACKET)
*
LOOP
*
TC.CN = TC.CN + ONE
IF CNT.TST$X THEN PRINT "CHAR # ":TC.CN:" ":
*
S8 = TC.SUM[ONE,ONE]
S7 = TC.SUM[TWO,ONE]
S6 = TC.SUM[3,ONE]
S5 = TC.SUM[4,ONE]
S4 = TC.SUM[5,ONE]
S3 = TC.SUM[6,ONE]
S2 = TC.SUM[7,ONE]
S1 = TC.SUM[8,ONE]
*
UNTIL TC.CN GT TC.MAX DO
*
TC = TC.PACKET[TC.CN,ONE]
*
IF CNT.TST$X THEN PRINT TC:" ":
*
TC.SEQ = SEQ(TC)
*
IF CNT.TST$X THEN
PRINT TC.SEQ
PRINT
PRINT "SUM ":TC.SUM
END
*
IF TC.SEQ GT 127 THEN T8 = "1"; TC.SEQ = TC.SEQ - 128 ELSE T8 = "0"
IF TC.SEQ GT  63 THEN T7 = "1"; TC.SEQ = TC.SEQ -  64 ELSE T7 = "0"
IF TC.SEQ GT  31 THEN T6 = "1"; TC.SEQ = TC.SEQ -  32 ELSE T6 = "0"
IF TC.SEQ GT  15 THEN T5 = "1"; TC.SEQ = TC.SEQ -  16 ELSE T5 = "0"
IF TC.SEQ GT   7 THEN T4 = "1"; TC.SEQ = TC.SEQ -   8 ELSE T4 = "0"
IF TC.SEQ GT   3 THEN T3 = "1"; TC.SEQ = TC.SEQ -   4 ELSE T3 = "0"
IF TC.SEQ GT   1 THEN T2 = "1"; TC.SEQ = TC.SEQ -   2 ELSE T2 = "0"
IF TC.SEQ THEN T1 = "1" ELSE T1 = "0"
*
IF CNT.TST$X THEN
PRINT "MAP ":T8:T7:T6:T5:T4:T3:T2:T1
END
*
IF (T8 OR S8) AND NOT(T8 AND S8) THEN S8 = "1" ELSE S8 = "0"
IF (T7 OR S7) AND NOT(T7 AND S7) THEN S7 = "1" ELSE S7 = "0"
IF (T6 OR S6) AND NOT(T6 AND S6) THEN S6 = "1" ELSE S6 = "0"
IF (T5 OR S5) AND NOT(T5 AND S5) THEN S5 = "1" ELSE S5 = "0"
IF (T4 OR S4) AND NOT(T4 AND S4) THEN S4 = "1" ELSE S4 = "0"
IF (T3 OR S3) AND NOT(T3 AND S3) THEN S3 = "1" ELSE S3 = "0"
IF (T2 OR S2) AND NOT(T2 AND S2) THEN S2 = "1" ELSE S2 = "0"
IF (T1 OR S1) AND NOT(T1 AND S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF CNT.TST$X THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
REPEAT
*
IF CNT.TST$LBL THEN
PRINT
PRINT "COMPLEMENT"
PRINT "CURR":TC.SUM
END
IF NOT(S8) THEN S8 = "1" ELSE S8 = "0"
IF NOT(S7) THEN S7 = "1" ELSE S7 = "0"
IF NOT(S6) THEN S6 = "1" ELSE S6 = "0"
IF NOT(S5) THEN S5 = "1" ELSE S5 = "0"
IF NOT(S4) THEN S4 = "1" ELSE S4 = "0"
IF NOT(S3) THEN S3 = "1" ELSE S3 = "0"
IF NOT(S2) THEN S2 = "1" ELSE S2 = "0"
IF NOT(S1) THEN S1 = "1" ELSE S1 = "0"
*
TC.SUM = S8:S7:S6:S5:S4:S3:S2:S1
*
IF CNT.TST$LBL THEN
PRINT "SUM ":TC.SUM; PRINT
END
*
*
TC.SEQ = 0
IF S8 THEN TC.SEQ = TC.SEQ + 128
IF S7 THEN TC.SEQ = TC.SEQ +  64
IF S6 THEN TC.SEQ = TC.SEQ +  32
IF S5 THEN TC.SEQ = TC.SEQ +  16
IF S4 THEN TC.SEQ = TC.SEQ +   8
IF S3 THEN TC.SEQ = TC.SEQ +   4
IF S2 THEN TC.SEQ = TC.SEQ +   2
TC.SEQ = TC.SEQ + S1
*
TMP = TC.SEQ; GOSUB HX.CONV; * TC.HEX = OCONV(CHAR(TC.SEQ),"MX")
TC.HEX = ("00":TMP1) "R#2"
*
IF CNT.TST$LBL THEN PRINT "END > SEQ ":TC.SEQ:"    HEX ":TC.HEX
*
*
~SYS.INCL.CHK.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.CHK.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
*
DT = DATE(); TM = TIME()
*
IF ((DT - DELAY.DT) * 86400) + (TM - DELAY.TM) GT DELAY.RESET THEN
*
READ DELAY.CN.MAX FROM PAR.FILE,"STARDARD.DELAY.CURR" ELSE DELAY.CN.MAX = ZERO:AM:300
*
DELAY.RESET = DELAY.CN.MAX<TWO>
DELAY.CN.MAX = DELAY.CN.MAX<ONE>
*
DELAY.DT = DATE(); DELAY.TM = TIME()
*
END
*
*
~SYS.INCL.COMM.WAIT.QUIET~
*CODE.SEGMENT: SYS.COMM.WAIT.QUIET
*     AUTHOR: DAVE HORSMAN
* DATE WRITTEN: 10 FEB 89
*    COMPANY: Macroscope Design Matrix
*                  & (additionally)
*             Axion Computer Software Ltd.
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*  APPLICATION: System Communications Design
*
*    VARIABLES:
*        IN: PAR.FILE             -    Parameter file for reading control
*                                            records.
*            COMM.WAIT.KEY        -    Read control file when filled
*            COMM.WAIT.QUIET      -    Number of seconds continuous quiet
*            COMM.WAIT.MAX        -    Max length of wait
*            COMM.WAIT.ERROR      -    Max length error flag (null/1)
*            COMM.WAIT.PAUSE      -    # of RQMs to be performed
*            COMM.WAIT.CLEAR      -    Clear buffer if it exceeds
*                                       this # of char's.
*
IF LEN(COMM.WAIT.KEY) THEN
READ COMM.WAIT.REC FROM PAR.FILE,COMM.WAIT.KEY ELSE
COMM.WAIT.REC = EMPTY 
RETURN; *# TO CALLING PROGRAM
END
END ELSE COMM.WAIT.REC = EMPTY 
*
COMM.WAIT.REC.CN.MAX = DCOUNT(COMM.WAIT.REC,AM)
COMM.WAIT.REC.CN     = ZERO
COMM.WAIT.RECVD      = EMPTY
COMM.WAIT.RECVD.LEN  = ZERO
COMM.STRING.FOUND = TRUE
COMM.LINE.TO.PRINT = FALSE
COMM.INIT         = FALSE
*
LOOP
*
IF COMM.WAIT.REC.CN LE COMM.WAIT.REC.CN.MAX AND COMM.STRING.FOUND AND NOT(COMM.LINE.TO.PRINT) THEN
COMM.WAIT.REC.CN = COMM.WAIT.REC.CN + ONE
COMM.WAIT.COMMAND = COMM.WAIT.REC<COMM.WAIT.REC.CN>
*
COMM.WAIT.VERB = FIELD(COMM.WAIT.COMMAND," ",ONE)
COMM.WAIT.SUBJECT = FIELD(COMM.WAIT.COMMAND," ",TWO)
COMM.WAIT.PREDICATE = FIELD(COMM.WAIT.COMMAND," ",3)
COMM.STRING.TO.BE.FOUND = EMPTY
*
BEGIN CASE
*
CASE COMM.WAIT.VERB EQ "WAIT" AND NOT(NUM(COMM.WAIT.SUBJECT))
*
BEGIN CASE
*
CASE COMM.WAIT.SUBJECT EQ "PAUSE"
IF NOT(NUM(COMM.WAIT.PREDICATE)) THEN COMM.WAIT.PREDICATE = ZERO
COMM.WAIT.PAUSE = COMM.WAIT.PREDICATE + ZERO
*
CASE COMM.WAIT.SUBJECT EQ "QUIET"
IF NOT(NUM(COMM.WAIT.PREDICATE)) THEN COMM.WAIT.PREDICATE = ZERO
COMM.WAIT.QUIET = COMM.WAIT.PREDICATE + ZERO
*
END CASE
*
CASE COMM.WAIT.VERB EQ "CLEAR" OR COMM.WAIT.VERB EQ "INIT"
INPUTCLEAR
COMM.INIT = FALSE
*
CASE INDEX("*PAUSE*SLEEP*EXECUTE*PERFORM*DO*","*":COMM.WAIT.VERB:"*",ONE) OR (COMM.WAIT.VERB EQ "WAIT" AND NUM(COMM.WAIT.SUBJECT))
IF COMM.WAIT.VERB EQ "WAIT" THEN COMM.WAIT.PREDICATE = COMM.WAIT.SUBJECT; COMM.WAIT.SUBJECT = "SLEEP"
*
BEGIN CASE
*
CASE COMM.WAIT.VERB EQ "EXECUTE" OR COMM.WAIT.VERB EQ "PERFORM" OR COMM.WAIT.VERB EQ "DO"
*
CASE COMM.WAIT.PREDICATE MATCHES "1N':'2N" OR COMM.WAIT.PREDICATE MATCHES "2N':'2N" OR COMM.WAIT.PREDICATE MATCHES "1N':'2N':'2N" OR COMM.WAIT.PREDICATE MATCHES "2N':'2N':'2N"
EXEC.VERB = "SLEEP ":COMM.WAIT.PREDICATE
EXEC.FLAG = TRUE
*
CASE NUM(COMM.WAIT.PREDICATE)
IF NOT(NUM(COMM.WAIT.PAUSE)) THEN COMM.WAIT.PAUSE = ONE
IF COMM.WAIT.PAUSE LT ZERO THEN COMM.WAIT.PAUSE = ABS(COMM.WAIT.PAUSE)
IF NOT(COMM.WAIT.PAUSE) THEN COMM.WAIT.PAUSE = ONE
EXEC.VERB = "SLEEP ":COMM.WAIT.PAUSE
EXEC.FLAG = TRUE
*
CASE COMM.WAIT.SUBJECT[ONE,ONE] EQ '"' OR COMM.WAIT.SUBJECT[ONE,ONE] EQ "'" OR COMM.WAIT.SUBJECT[ONE,ONE] EQ '/' OR COMM.WAIT.SUBJECT[ONE,ONE] EQ '\'
CHAR.END = COMM.WAIT.SUBJECT.SYS11
STRING.START = INDEX(COMM.WAIT.COMMAND,CHAR.END,ONE)
STRING.END   = INDEX(COMM.WAIT.COMMAND,CHAR.END,TWO)
IF NOT(STRING.END) THEN STRING.END = LEN(COMM.COMMAND) + ONE
COMM.STRING.TO.BE.FOUND = COMM.WAIT.COMMAND[STRING.START + ONE,(STRING.END - STRING.START - ONE)]
EXEC.FLAG = FALSE
*
CASE TRUE
EXEC.FLAG = FALSE
*
END CASE
*
IF EXEC.FLAG THEN
EXEC.RSP = EMPTY
EXECUTE EXEC.VERB, //OUT. > EXEC.RSP
END
*
CASE TRUE
COMM.LINE.TO.PRINT = TRUE
*
END CASE
*
END; *# OF LOAD NEXT VERB
*
* WAIT INITIALIZATION
IF NOT(COMM.INIT) THEN
COMM.INIT = TRUE
CW.START.TIME = TIME()
CW.START.DATE = DATE()
* CURRENT # OF CAHR'S IN TYPE AHEAD BUFFER
*
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
CW.START.SYS11 = SYSTEM(ELEVEN)
* INPUT TMP,-ONE:; * REV ONLY
* CW.START.SYS11 = LEN(TMP); * REV ONLY
CASE OPSYS EQ "M"
CW.START.SYS11 = ONE
CASE OPSYS EQ "R"
* INPUT TMP,-ONE:; * REV ONLY
* CW.START.SYS11 = LEN(TMP); * REV ONLY
END CASE
*
CW.CONT.QUIET = ZERO
*
CW.LAST.SYS11 = CW.START.SYS11
CW.LAST.DATE = CW.START.DATE
CW.LAST.TIME = CW.START.TIME
*
END
*
* MAIN LOOP
LOOP
*
* DETERMIN TOTAL ELP
CW.CURR.TIME = TIME()
CW.CURR.DATE = DATE()
IF CW.START.DATE NE CW.CURR.DATE THEN
CW.ELP = (CW.CURR.DATE - CW.START.DATE - ONE) * 86400 + 86400 - CW.START.TIME + CW.CURR.TIME
END ELSE
CW.ELP = ABS(CW.CURR.TIME - CW.START.TIME)
END
*# PRINT "CW.ELP ":CW.ELP; *#
IF CW.ELP GT COMM.WAIT.MAX THEN COMM.WAIT.ERROR = ONE
*@ PRINT "COMM.WAIT.ERROR ":COMM.WAIT.ERROR; *@
*
IF NOT(COMM.WAIT.ERROR) THEN
*
*# CURRENT # OF CHARS IN TYPE AHEAD BUFFER
BEGIN CASE
*
CASE OPSYS EQ "U"
* ULT ONLY
CW.CURR.SYS11 = SYSTEM(ELEVEN)
* INPUT TMP,-ONE:; * REV ONLY
* CW.CURR.SYS11 = LEN(TMP); * REV ONLY
CASE OPSYS EQ "M"
CW.CURR.SYS11 = ONE
CASE OPSYS EQ "R"
* INPUT TMP,-ONE:; * REV ONLY
* CW.CURR.SYS11 = LEN(TMP); * REV ONLY
END CASE
*
*# DETERMINE CHANGE IN BUFFER
*
*# # OF CHAR'S HAS CHANGED
IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
CW.LAST.SYS11 = CW.CURR.SYS11
CW.LAST.DATE = CW.CURR.DATE
CW.LAST.TIME = CW.CURR.TIME
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
*@ PRINT "CW.LAST.DATE  ":CW.LAST.DATE; *@
*@ PRINT "CW.LAST.TIME  ":CW.LAST.TIME; *@
END ELSE
*
*# BUFFER IS EMPTY
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
IF CW.LAST.DATE NE CW.CURR.DATE THEN
CW.CONT.QUIET = (CW.CURR.DATE - CW.LAST.DATE - ONE) * 86400 + 86400 - CW.LAST.TIME + CW.CURR.TIME
END ELSE
CW.CONT.QUIET = ABS(CW.CURR.TIME - CW.LAST.TIME)
END
*@ PRINT "CW.CONT.QUIET ":CW.CONT.QUIET; *@
*
END; *# OF LAST.SYS11
*
*#  DETERMINE IF CLEAR OR STRING CHECK IS REQUIRED
IF OPSYS EQ "R" OR (CW.LAST.SYS11 + COMM.WAIT.RECVD.LEN GT COMM.WAIT.CLEAR AND COMM.WAIT.CLEAR) OR LEN(COMM.STRING.TO.BE.FOUND) THEN
COMM.WAIT.RECVD.LEN = LEN(COMM.WAIT.RECVD)
TMP = LEN(COMM.STRING.TO.BE.FOUND)
IF CW.LAST.SYS11 LT TMP THEN TMP = CW.LAST.SYS11 - ONE
INPUT TMP1,TMP:
CW.LAST.SYS11 = CW.LAST.SYS11 - TMP; CW.CURR.SYS11 = CW.CURR.SYS11 - TMP
COMM.WAIT.RECVD = COMM.WAIT.RECVD:TMP1
* INPUTCLEAR
IF LEN(COMM.STRING.TO.BE.FOUND) THEN
COMM.STRING.FOUND = INDEX(COMM.WAIT.RECVD,COMM.STRING.TO.BE.FOUND,ONE)
IF COMM.STRING.FOUND THEN COMM.INIT = FALSE
END ELSE COMM.STRING.FOUND = TRUE
*
LOOP
COMM.WAIT.RECVD.LEN = LEN(COMM.WAIT.RECVD)
WHILE COMM.WAIT.RECVD.LEN GT LEN(COMM.STRING.TO.BE.FOUND) * TWO AND LEN(COMM.STRING.TO.BE.FOUND) DO
COMM.WAIT.RECVD = COMM.WAIT.RECVD[LEN(COMM.STRING.TO.BE.FOUND) +ONE,99999]
REPEAT
*
CW.LAST.SYS11 = ZERO 
IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
*# OF CHAR'S HAS CHANGED
CW.CURR.SYS11 = ONE 
END ELSE
CW.CURR.SYS11 = ZERO
END
END; * OF CLEAR OR STRING CHECK
*
END; * OF NOT(COMM.WAIT.ERROR)
*
*@ PRINT "COMM.WAIT.ERROR ":COMM.WAIT.ERROR; *@
*@ PRINT "COMM.INIT ":COMM.INIT; *@
*@ PRINT "CW.CONT.QUIET:*:COMM.WAIT.QUIET ":CW.CONT.QUIET:"*":COMM.WAIT.QUIET; *@
*@ PRINT "COMM.STRING.FOUND ":COMM.STRING.FOUND; *@
WHILE NOT(COMM.WAIT.ERROR) AND COMM.INIT AND ((CW.CONT.QUIET LT COMM.WAIT.QUIET) AND NOT(COMM.STRING.FOUND)) DO
*
* Wait the required # of RQMs
FOR CW.TEMP = ONE TO COMM.WAIT.PAUSE
RQM
NEXT CW.TEMP
*
REPEAT
*
IF COMM.LINE.TO.PRINT THEN
*
PRINT COMM.WAIT.COMMAND:CR:
COMM.LINE.TO.PRINT = FALSE
COMM.INIT = FALSE
*
* Wait the required # of RQMs
FOR CW.TEMP = ONE TO COMM.WAIT.PAUSE
RQM
NEXT CW.TEMP
*
END
*
WHILE NOT(COMM.WAIT.ERROR) AND ((CW.CONT.QUIET LT COMM.WAIT.QUIET) OR COMM.WAIT.REC.CN LT COMM.WAIT.REC.CN.MAX) DO REPEAT
*
~SYS.INCL.COMPANY.READ~
*CODE.SEGMENT: SYS.INCL.COMPANY.READ
*
*
*DGH 870624
*
*
*CO.DATA@@@@@ READ COMPANY DATA
*
SYS.FILE = "SYS"
IF STRUCT(29)<1,PORT+1> EQ "" THEN STRUCT(29)<1,PORT+1> = STRUCT(4)
LOOP
SYS.ITEM = "@CO.DATA@":STRUCT(29)<1,PORT+1>
READ CO.DATA FROM SY.FILE,SYS.ITEM ELSE
CO.DATA = AM:DATE()
SYS.ABORT = 1
PRINTER ON
PRINT "CAN NOT READ COMPANY DATA FOR ":SYS.ITEM
PRINT
PRINTER OFF
PRINT
PRINT "CAN NOT READ COMPANY DATA FOR ":SYS.ITEM
END
WHILE NOT(SYS.ABORT OR USER.ABORT) AND CO.DATA<4> NE STRUCT(29)<1,PORT+1> DO
STRUCT(29)<1,PORT+1> = CO.DATA<4>
PRINT "COMPANY CHANGED TO ":CO.DATA<4>
REPEAT
EXEC.VERB = ""; PRMPTING = ""
*
*
IF USER.ABORT OR SYS.ABORT THEN
*#IF PORTD<5> NE "D" THEN 
PRINT BELL:" ABORT AT COMPANY READ!":
IF SYS.PROG.TYPE GT 3 THEN RETURN
END
*
*
*
~SYS.INCL.CONV.AM.TO.VM~
*CODE.SEGMENT: SYS.INCL.CONV.AM.TO.VM
*
*
AM.CN = ONE
LOOP
AM.LOC = INDEX(LINE,CHAR(254),ONE)
WHILE AM.LOC DO
LINE = LINE[ONE,AM.LOC - ONE]:VM:LINE[AM.LOC + ONE,99999]
IF TF THEN PRINT @(50,23):'AM ':AM.CN:; * RQM
AM.CN = AM.CN + ONE
REPEAT
*
~SYS.INCL.CONV.NUM.FROM.HEX~
*CODE.SEGMENT: SYS.INCL.CONV.NUM.FROM.HEX
* AUTHOR: DAVID HORSMAN
* DATE.WRITTEN: 2 APR 94
* (c) Copyright 1994
* MACROSCOPE DESIGN MATRIX
*
* TMP INCOMING NUMBER
* TMP1 OUTGOING NUMBER
* TMP2 BASE
*
* 1,048,576   65,536  4,096  256  16  1
*
!
*
DIGIT.CN.MAX = 1
DIGIT.VAL.MAX = TMP2
TMP3 = LEN(TMP)
* * * LOOP WHILE DIGIT.VAL.MAX LE TMP DO
LOOP WHILE DIGIT.CN.MAX LT TMP3 DO
DIGIT.VAL.MAX = DIGIT.VAL.MAX * TMP2
DIGIT.CN.MAX = DIGIT.CN.MAX + 1
REPEAT
* DIGIT.CN.MAX = DIGIT.CN.MAX - ONE
DIGIT.VAL.MAX = DIGIT.VAL.MAX / TMP2
*
***PRINT
***PRINT "Digits: ":DIGIT.CN.MAX
***PRINT "Value:  ":DIGIT.VAL.MAX
***PRINT
*
!
*
*
* * * IF NUM(TMP) THEN
* * * TMP3 = ABS(TMP)
TMP5 = EMPTY
* * * DIGIT.CN = DIGIT.CN.MAX
DIGIT.CN = ONE
DIGIT.VAL = DIGIT.VAL.MAX
*********
* * * LOOP WHILE DIGIT.CN GT ONE AND TMP3 GT ZERO DO
LOOP WHILE DIGIT.CN LE DIGIT.CN.MAX DO
TMP5<DIGIT.CN> = ZERO
* * * LOOP WHILE TMP3 GE DIGIT.VAL DO
* * * TMP3 = TMP3 - DIGIT.VAL
***PRINT ".":
* * * TMP5<DIGIT.CN> = TMP5<DIGIT.CN> + ONE
TMP3 = TMP[DIGIT.CN,ONE]
IF TMP3 EQ EMPTY THEN TMP3 = "0"
TMP7 = ZERO
IF TMP3 NE "0" THEN
TMP7 = INDEX("123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",TMP3,ONE)
END
TMP5<DIGIT.CN> = TMP7 * DIGIT.VAL
* * * REPEAT
***PRINT
***PRINT "val: ":DIGIT.VAL
***PRINT " cn: ":DIGIT.CN
***PRINT "CHR: ":TMP5<DIGIT.CN>
***PRINT "ALL: ":TMP5
DIGIT.VAL = DIGIT.VAL / TMP2
DIGIT.CN = DIGIT.CN + ONE
* * * DIGIT.CN = DIGIT.CN - ONE
REPEAT
* * * TMP5<ONE> = TMP3
*
***PRINT "ALL: ":TMP5
TMP6 = EMPTY
LOOP WHILE LEN(TMP5) DO
* TMP6 = (OCONV(CHAR(TMP5<ONE>),"MX"))[TWO,ONE]:TMP6
* * * TMP7 = ZERO
* * * IF TMP5<ONE> THEN TMP7 = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[TMP5<ONE>,ONE]
* * * TMP6 = TMP7:TMP6
TMP6 = TMP6 + TMP5<ONE>
DEL TMP5<ONE>
REPEAT
***PRINT "FINAL: ":TMP6
*
*********
TMP1 = TMP6
* * * END ELSE TMP1 = EMPTY
*
~SYS.INCL.CONV.NUM.TO.HEX~
*CODE.SEGMENT: SYS.INCL.CONV.NUM.TO.HEX
* AUTHOR: DAVID HORSMAN
* DATE.WRITTEN: 2 APR 94
* (c) Copyright 1994
* MACROSCOPE DESIGN MATRIX
*
* TMP INCOMING NUMBER
* TMP1 OUTGOING NUMBER
* TMP2 BASE
*
* 1,048,576   65,536  4,096  256  16  1
*
!
*
DIGIT.CN.MAX = 1
DIGIT.VAL.MAX = TMP2
LOOP WHILE DIGIT.VAL.MAX LE TMP DO
DIGIT.VAL.MAX = DIGIT.VAL.MAX * TMP2
DIGIT.CN.MAX = DIGIT.CN.MAX + 1
REPEAT
* DIGIT.CN.MAX = DIGIT.CN.MAX - ONE
DIGIT.VAL.MAX = DIGIT.VAL.MAX / TMP2
*
*** PRINT
*** PRINT "Digits: ":DIGIT.CN.MAX
*** PRINT "Value:  ":DIGIT.VAL.MAX
*** PRINT
*
!
*
*
IF NUM(TMP) THEN
TMP3 = ABS(TMP)
TMP5 = EMPTY
DIGIT.CN = DIGIT.CN.MAX
DIGIT.VAL = DIGIT.VAL.MAX
*********
LOOP WHILE DIGIT.CN GT ONE AND TMP3 GT ZERO DO
TMP5<DIGIT.CN> = ZERO
LOOP WHILE TMP3 GE DIGIT.VAL DO
TMP3 = TMP3 - DIGIT.VAL
*** PRINT ".":
TMP5<DIGIT.CN> = TMP5<DIGIT.CN> + ONE
REPEAT
*** PRINT
*** PRINT "val: ":DIGIT.VAL
*** PRINT " cn: ":DIGIT.CN
*** PRINT "CHR: ":TMP5<DIGIT.CN>
*** PRINT "ALL: ":TMP5
DIGIT.VAL = DIGIT.VAL / TMP2
DIGIT.CN  = DIGIT.CN  - ONE
REPEAT
TMP5<ONE> = TMP3
*
*** PRINT "ALL: ":TMP5
TMP6 = EMPTY
LOOP WHILE LEN(TMP5) DO
* TMP6 = (OCONV(CHAR(TMP5<ONE>),"MX"))[TWO,ONE]:TMP6
TMP7 = ZERO
IF TMP5<ONE> THEN TMP7 = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[TMP5<ONE>,ONE]
TMP6 = TMP7:TMP6
DEL TMP5<ONE>
REPEAT
*** PRINT "FINAL: ":TMP6
*
*********
TMP1 = TMP6
END ELSE TMP1 = EMPTY
*
~SYS.INCL.CONV.TO.HEX~
*CODE.SEGMENT: SYS.INCL.CONV.TO.HEX
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: DEC 89, INCL CREATED: 25 MAR 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF NOT(LINE.IS.HEX) THEN
TC.CN = ZERO
TC.MAX = LEN(LINE)
HEX.LINE = ""; OLD.LINE = LINE
LOOP
TC.CN = TC.CN + ONE
WHILE TC.CN LE TC.MAX DO
TC = LINE[TC.CN,ONE]
HEX.LINE = HEX.LINE:OCONV(TC,"MX")
REPEAT
LINE = HEX.LINE
LINE.IS.HEX = TRUE
END
*
~SYS.INCL.CONV.TO.TXT~
*CODE.SEGMENT: SYS.INCL.CONV.TO.TXT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: DEC 89, INCL CREATED: 25 MAR 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF LINE.IS.HEX THEN
TC.CN = ONE
TC.MAX = LEN(LINE)
HEX.LINE = ""; OLD.LINE = LINE
LOOP WHILE TC.CN LE TC.MAX+ONE DO
TC = LINE[TC.CN,TWO]
HEX.LINE = HEX.LINE:ICONV(TC,"MX")
TC.CN = TC.CN + TWO
REPEAT
LINE = HEX.LINE
LINE.IS.HEX = FALSE
END
*
~SYS.INCL.CONV.VM.TO.AM~
*CODE.SEGMENT: SYS.INCL.CONV.VM.TO.AM
*
*
VM.CN = ONE
LOOP
VM.LOC = INDEX(LINE,CHAR(254),ONE)
WHILE VM.LOC DO
LINE = LINE[ONE,VM.LOC - ONE]:AM:LINE[VM.LOC + ONE,99999]
IF TF THEN PRINT @(50,23):'VM ':VM.CN:; * RQM
VM.CN = VM.CN + ONE
REPEAT
*
~SYS.INCL.CPORT~
*CODE.SEGMENT: SYS.INCL.CPORT
*
*$INCLUDE DH.IBP SYS.INCL.CPORT
*
IF STRUCT(14) EQ PORT+1 THEN EQ.PROG.STATUS = 11 ELSE
EQ.PROG.STATUS = 1
END
*
~SYS.INCL.CURR.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.CURR.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
READ DELAY.CN.MAX FROM PAR.FILE,"STANDARD.DELAY.CURR" THEN
DELAY.RESET = DELAY.CN.MAX<TWO>
DELAY.CN.MAX = DELAY.CN.MAX<ONE>
END ELSE NULL
*
*
~SYS.INCL.DEB.RSP~
*CODE.SEGMENT: SYS.INCL.DEB.RSP
*
*
EQU DEB.RSP TO "*DEB*DEBUG*debug*Debug*TEST*test*Test*"
*$INCLUDE DH.BP SYS.INCL.DEB.RSP
*
~SYS.INCL.END.RSP~
*CODE.SEGMENT: SYS.INCL.END.RSP
*
*
EQU END.RSP TO "*END*end*End*KILL*kill*Kill*"
*
~SYS.INCL.ENTER.STD.SUBR~
*CODE.SEGMENT: SYS.INCL.ENTER.STD.SUBR
*
*
READ TMP FROM COM.FILE,STD.SUBR.NAME THEN
TMP = GENERIC; TMP1 = SEC.USER$ITEM.ID
CALL @STD.SUBR.NAME(STD.FILE,SEC.USER$ITEM.ID,MAT STD,PAR.FILE,LCK.FILE,TMP1,TMP,CO.DATA,MAT CNT.TST,STAT)
MATWRITE STD ON STD.FILE,SEC.USER$ITEM.ID
END ELSE
PRINT CLB:RVB:"Function does not exist! Enter <cr> . . . ":RVE:BELL:; INPUT TMP.RSP
END
*
~SYS.INCL.ERROR~
*CODE.SEGMENT: SYS.INCL.ERROR
* USED BY: AI.TALKER
*          AI.CONTORL.UTILITY
*          AI.HANDLER
*          AI.CHECK.HANDLER
*          AI.CHANNEL.DN
*          AI.CHANNEL.UP
*          UPLOAD.PPV.BUYS
*          DOWNLOAD.PPV.BUYS
*
* ERR.HDR    -
* ERR.LN.MIN - 
* ERR.LN.HI  -
* ERR.LEN    -
* ERR.CLB    -
* ERR.CLS    -
* TEXT       -
* ERR.LN      -
* ERR.CL      -
* ERR.BELL     -
* ERR.CR       -
* ERR.FMT       -
* ERR.DISP.ONLY -
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*                ALL RIGHTS RESERVED
*
LOOP WHILE LEN(TEXT) AND TEXT<ONE> EQ EMPTY DO DEL TEXT<ONE> REPEAT
*
IF LEN(TEXT) THEN
*
ERR.LN = ERR.LN.MIN; ERR.FMT = "L#":ERR.LEN - TWO
*
IF ERR.CLB THEN ERR.LN = 23
*
IF (ERR.CLS AND ERR.CLB) THEN PRINT @(ZERO,ERR.LN):CLS: ELSE
*
PRINT @(ZERO,23):CLL:
*
IF NOT(ERR.CLB) THEN
*
IF ERR.LN.HI GT ERR.LN.MIN THEN
FOR ERR.LN = ERR.LN.MIN TO ERR.LN.MAX UNTIL ERR.LN GT ERR.LN.HI
PRINT @(ERR.CL,ERR.LN):RVB:"!":RVE:" " ERR.FMT:RVB:"!":RVE:
NEXT ERR.LN
ERR.LN.HI = ERR.LN.MIN - ONE
END
*
PRINT @(ERR.CL,ERR.LN.MIN - ONE):RVB:"!":ERR.HDR ERR.FMT:"!":RVE:
*
ERR.LN = ERR.LN.MIN
*
END; * of not clb (print on bottom)
*
END; * of clb (line 23) flag
*
IF ERR.BELL THEN PRINT BELL:
*
LOOP
*
TMP = TEXT<ONE>
TMP1 = LEN(TMP)
IF TMP1 GT ERR.LEN THEN TMP1 = ERR.LEN
DEL TEXT<ONE>
*
IF TMP1 THEN
PRINT @(ERR.CL,ERR.LN):RVB:"!":RVE:TMP ERR.FMT:RVB:"!":RVE:
IF NOT(ERR.CLB) THEN ERR.LN = ERR.LN + ONE
END; * of text present
*
IF ERR.CLB OR ERR.LN GT ERR.LN.MAX OR NOT(LEN(TEXT)) THEN
*
IF ERR.DISP.ONLY AND NOT(ERR.CR AND NOT(LEN(TEXT))) THEN
*
FOR A = ONE TO ERR.DISP.ONLY; RQM; NEXT A
*
END ELSE
*
TMP = ERR.CL + TMP1
*
IF NOT(ERR.CLB) THEN
IF TMP + 41 GT 78 THEN TMP = ZERO
PRINT @(TMP,23):CLL:
IF LEN(TEXT) THEN PRINT " More messages - ":
PRINT " Press <cr> to continue ":
END ELSE
*
IF TMP LT 70 THEN
PRINT " Press <cr> ":
END ELSE
PRINT BELL:
END; * 70
*
END; * ERR.CLB
*
INPUT RSP:
* IF ERR.CLB THEN PRINT @(ERR.CL,ERR.LN):CLL:
IF RSP = "KILL" THEN STOP
*
END; * ERR.DISP.ONLY
*
IF NOT(ERR.CLB) AND ERR.LN.HI LT ERR.LN THEN ERR.LN.HI = ERR.LN
*
IF NOT(ERR.CLB) AND LEN(TEXT) THEN ERR.LN = ERR.LN.MIN
*
END; * of page or end of text
*
WHILE LEN(TEXT) DO REPEAT
*
IF NOT(ERR.CLB) AND ERR.CLS THEN
* LOOP WHILE ERR.LN LE ERR.LN.MAX DO PRINT @(ERR.CL,ERR.LN):CLL:; ERR.LN = ERR.LN + ONE REPEAT
LOOP WHILE ERR.LN LE ERR.LN.MAX DO
PRINT @(ERR.CL,ERR.LN):RVB:"!":RVE:" " ERR.FMT:RVB:"!":RVE:
ERR.LN = ERR.LN + ONE
REPEAT
END ELSE IF NOT(ERR.CLB) AND ERR.LN LE ERR.LN.MAX THEN
PRINT @(ERR.CL,ERR.LN):RVB:"!":STR("-",ERR.LEN - TWO) ERR.FMT:"!":RVE:
END
*
END; * of text present
*
~SYS.INCL.ERROR.BU~
*CODE.SEGMENT: SYS.INCL.DISPLAY
*
*
IF LBL.DISP THEN PRINT @(60,20):"Error Display" "L#18":; RQM
ERR.LN = ERR.LN.MIN
*
IF LEN(TEXT) THEN
IF DCOUNT(TEXT,AM) LE 1 THEN ERR.LN = 23
ERR.FMT = "L#":ERR.LEN
IF ERR.CLS AND (ERR.LN.MIN AND ERR.LN.MAX) THEN PRINT @(ZERO,ERR.LN):CLS:
*
LOOP
*
IF LEN(TEXT) THEN
PRINT @(ERR.CL,ERR.LN):TEXT<ONE> ERR.FMT:
ERR.LN = ERR.LN + ONE
DEL TEXT<ONE>
END; * of text present
*
IF ERR.LN GT ERR.LN.MAX OR NOT(LEN(TEXT)) THEN
*
IF ERR.LN NE 23 THEN PRINT @(ZERO,23):CLL ELSE PRINT " - ":
IF LEN(TEXT) THEN PRINT "More messages to display":
MSG.DISP = TRUE
*
IF TST.CR THEN
PRINT " - Press <cr>":
INPUT TST.RSP:
IF RSP = "KILL" THEN STOP
END ELSE IF NOT(ERR.DISP.ONLY) THEN RQM ELSE
FOR A = ONE TO ERR.DISP.ONLY; RQM; NEXT A
END
*
ERR.LN = ERR.LN.MIN
*
END; * of last msg or next page
*
WHILE LEN(TEXT) DO REPEAT
*
IF MSG.DISP THEN PRINT @(ZERO,23):CLL:
*
END; * of text present
*
~SYS.INCL.EXEC.STD.FUNC~
*CODE.SEGMENT: SYS.INCL.EXEC.STD.FUNC
*
*
* Execute command
*
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = EXEC.VERB
LCK.STAT = FALSE
EXEC.VERB.ID = EXEC.VERB
IF EXEC.VERB[ONE,ONE] EQ "." THEN
EXEC.VERB = EXEC.VERB[TWO,9999]
CR.FLAG = TRUE
END
*
! Check for generic toggle (CHAR(1) <CTRL>-A)
*
IF EXEC.VERB[ONE,ONE] EQ CHAR(1) THEN
IF GENERIC THEN GENERIC = FALSE ELSE GENERIC = TRUE
EXEC.VERB = EXEC.VERB[TWO,9999]
END
*
! Check for RESET param (^)
*
IF EXEC.VERB[ONE,ONE] EQ "^" THEN RESET.SW = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! TCL request made (TCL)
*
IF EXEC.VERB EQ "TCL" AND (MENU.NAME NE EMPTY AND MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE>) THEN
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
END
PAR.MENU$LOCN<ONE,ONE> = SCR.LOCN
*
! Check for 'Enter <cr>' param   (%)
*
IF EXEC.VERB[ONE,ONE] EQ "%" THEN CR.FLAG = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! Question for user (!)
*
LOOP TC = INDEX(EXEC.VERB,"!",ONE) WHILE TC DO
TMP = FIELD(EXEC.VERB,"!",TWO); TMP1 = EXEC.VERB[ONE,TC - ONE]
TMP2 = INDEX(EXEC.VERB,"!",TWO)
IF TMP2 THEN TMP2 = EXEC.VERB[TMP2 + ONE,999] ELSE TMP2 = EMPTY
PRINT CLB:TMP[ONE,70]:" ":; INPUT TMP.RSP:
EXEC.VERB = TMP1:TMP.RSP:TMP2
REPEAT
*
! Insert port key here ($)
*
LOOP TC = INDEX(EXEC.VERB,"$",ONE) WHILE TC DO
TC.BEG = TC - ONE
TC.END = INDEX(EXEC.VERB,"$",TWO)
IF NOT(TC.END) THEN TC.END = TC.BEG + ONE
TC.WORD = EXEC.VERB[TC.BEG,TC.END - TC.BEG]
BEGIN CASE
CASE TC.WORD EQ "PORT"
EXEC.VERB = EXEC.VERB[ONE,TC.BEG]:PORT.KEY:EXEC.VERB[TC.END,999]
CASE TC.WORD EQ "OPER"
CASE TC.WORD EQ "ACCT"
CASE TC.WORD EQ "FILE"
CASE TC.WORD EQ "ITEM"
CASE TC.WORD EQ "DATE"
CASE TC.WORD EQ "TIME"
CASE TC.WORD EQ "SYS11"
CASE TC.WORD EQ "SEL.ERROR"
CASE TC.WORD EQ "TST"
CASE TC.WORD EQ "SYS.ERROR"
CASE TC.WORD EQ "MENU.NAME"
CASE TC.WORD EQ "APPL"
CASE TC.WORD EQ "SUB.APPL"
CASE TC.WORD EQ "PROG"
CASE TC.WORD EQ "LOCT"
CASE TC.WORD EQ "SYS"
CASE TC.WORD EQ "OPSYS"
CASE TC.WORD EQ "TOPIC"
CASE TC.WORD EQ "USER"
CASE TC.WORD EQ "MODE"
CASE TRUE
EXEC.VERB = EXEC.VERB[ONE,TC.BEG]:"$":EXEC.VERB[TC.END,999]
END CASE
REPEAT
*
! Insert account name here (#?) (  #D   #T   #n  )
*
LOOP TC = INDEX(EXEC.VERB,"#",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF TMP EQ EMPTY THEN TMP = "?"
IF NUM(TMP) THEN
IF TMP LT ONE THEN TMP = ONE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:FIELD(ACCT,".",TMP):EXEC.VERB[TC + TWO,999]
END ELSE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:PAR.MENU$USER:EXEC.VERB[TC+ ONE,999]
END
REPEAT
*
! Insert date or time here (  #D  #T  #n   )
*
LOOP TC = INDEX(EXEC.VERB,"_",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF NOT(NUM(TMP)) THEN TMP = ONE
IF TMP EQ "T" THEN TMP1 = OCONV(DATE(),"D2") ELSE
IF TMP EQ "D" THEN TMP1 = OCONV(TIME(),"MTS") ELSE TMP1 = "?"
END
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:TMP1:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Insert special routines name here   (   .?   )
*
ROUTINE.SUFFIX = EMPTY
LOOP TC = INDEX(EXEC.VERB,".?",ONE) WHILE TC DO
IF NOT(LEN(ROUTINE.SUFFIX)) THEN
TMP = EXEC.VERB[ONE,TC - ONE]
LOOP UNTIL NOT(INDEX(TMP," ",ONE)) DO TMP = TMP[TWO,999] REPEAT
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = EMPTY
LOCATE TMP IN SPECIAL.ROUTINES<ONE> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<TWO,LOC>
END
EXEC.VERB = EXEC.VERB[ONE,TC]:ROUTINE.SUFFIX:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Check for lock param (l)
*
IF EXEC.VERB[ONE,ONE] EQ "l" THEN
EXEC.VERB = EXEC.VERB[TWO,9999]
LCK.ITM = TRUE
END ELSE LCK.ITM = FALSE
*
! Process terminal input to routing
*
PARAMS = EXEC.VERB
EXEC.VERB = EXEC.VERB<ONE,ONE,ONE>
EXEC.VERB.ID = EXEC.VERB
DEL PARAMS<ONE,ONE,ONE>
EXEC.IN = EMPTY
*
LOOP UNTIL PARAMS = EMPTY DO
IF OPSYS = "R" THEN DATA PARAMS<ONE,ONE,ONE> ELSE EXEC.IN = EXEC.IN:PARAMS<ONE,ONE,ONE>:AM
DEL PARAMS<ONE,ONE,ONE>
REPEAT
*
BEGIN CASE
*
CASE OPSYS = "U"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
* IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP ":EXEC.VERB
END
*
CASE OPSYS = "R"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP.OBJ ":EXEC.VERB
END
*
CASE TRUE
TMP = FIELD(EXEC.VERB," ",ONE)
IF TMP EQ "RUN" THEN
TMP = FIELD(EXEC.VERB," ",TWO)
EXEC.VERB = EXEC.VERB[COL2() + ONE,9999]
END
*
END CASE
*
! Check group authorization
*
IF EXEC.VERB.ID[ONE,ONE] EQ "." OR EXEC.VERB EQ "TCL" THEN
LOCATE "TCL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "ALL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE LCK.STAT = TRUE
END
IF LCK.STAT THEN
PRINT CLB:RVB:"You do not have access to TCL! Enter <cr> . . . ":RVE:BELL:; INPUT TMP.RSP:
END
END
*
IF SEC.USER.ID NE EMPTY THEN
MSG.VERB = "SYS.MSG.SEND"
MSG.IN = "-2":AM:SEC.USER.ID
EXECUTE MSG.VERB, //IN. < MSG.IN
END
*
! Lock record
*
IF NOT(LCK.STAT) THEN
IF EXEC.VERB.ID[ONE,ONE] EQ "." THEN EXEC.VERB.ID = EXEC.VERB.ID[TWO,999]
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "RUN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",3)
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "CHAIN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",TWO)
IF LCK.ITM THEN
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE,LCK.STAT)
WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
END ELSE LCK.STAT = FALSE
END; * Of lock stat
*
! OFF request made
*
IF RESET.SW OR EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
PAR.MENU$MENU.ID = EMPTY
PAR.MENU$LOCN   = ONE
PAR.MENU$DESC = "OFF"
END
PAR.MENU$GROUP = EMPTY
PAR.MENU$USER = EMPTY
END
*
! Write location
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Ready to execute routing
*
IF NOT(LCK.STAT) THEN
*
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
*
READ TMP FROM ACC.FILE,ACC.ID ELSE TMP = EMPTY
IF EXEC.DESC EQ EMPTY THEN
TMP<ACC.AM.DESC> = EXEC.VERB<ONE,ONE,ONE>
END ELSE
TMP<ACC.AM.DESC> = EXEC.DESC
END
TMP<ACC.AM.VERB> = EXEC.VERB
TMP<ACC.AM.DT>   = DATE()
TMP<ACC.AM.TM>   = TIME()
WRITE TMP ON ACC.FILE,ACC.ID
*
MATWRITE STD ON COM.FILE,SEC.USER$ITEM.ID
*
*%%ULT%%=IF EXEC.VERB EQ "TCL" THEN STOP
*%%PCK%%=IF EXEC.VERB EQ "TCL" THEN STOP
*%%MDD%%=IF EXEC.VERB EQ "TCL" THEN ABORT
*
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF RESET.SW EQ 999 THEN GOTO UNLOCK
CHAIN "ZZOFF"
END
*
IF EXEC.VERB[ONE,6] EQ "CHAIN " THEN CHAIN EXEC.VERB[7,999]
*
* is it a PC command
IF EXEC.VERB[ONE,3] EQ "PC " THEN
*
EXECUTE EXEC.VERB; * DON'T CHANGE
*
END ELSE
*
* Not a PC command
IF EXEC.IN EQ EMPTY THEN
*
EXECUTE EXEC.VERB
*
END ELSE
*
EXEC.IN = EXEC.IN[ONE,LEN(EXEC.IN) - ONE]
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
END
*
END; * Of PC or not
*
END; * Of item not locked
*
IF LCK.ITM THEN
CALL UNLOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE)
END
*
*
IF CR.FLAG EQ TWO THEN
*960605*DGH*PRINT CLB:RVB:"Continuing . . . ":RVE:BELL:; RQM; RQM
PRINT @(ZERO):CLL:RVB:"Continuing . . . ":RVE:BELL:; RQM; RQM
END ELSE IF CR.FLAG THEN
PRINT @(ZERO):CLL:"Enter <cr> to continue . . . ":; INPUT TMP.RSP:
END
*
~SYS.INCL.EXEC.STD.FUNC.13MAR94~
*CODE.SEGMENT: SYS.INCL.EXEC.STD.FUNC
*
*
* Execute command
*
PAR.MENU$DT = DATE()
PAR.MENU$TM = TIME()
PAR.MENU$DESC = EXEC.VERB
LCK.STAT = FALSE
EXEC.VERB.ID = EXEC.VERB
IF EXEC.VERB[ONE,ONE] EQ "." THEN EXEC.VERB = EXEC.VERB[TWO,9999]
*
! Check for generic toggle (CHAR(1) <CTRL>-A)
*
IF EXEC.VERB[ONE,ONE] EQ CHAR(1) THEN
IF GENERIC THEN GENERIC = FALSE ELSE GENERIC = TRUE
EXEC.VERB = EXEC.VERB[TWO,9999]
END
*
! Check for RESET param (^)
*
IF EXEC.VERB[ONE,ONE] EQ "^" THEN RESET.SW = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! TCL request made (TCL)
*
IF EXEC.VERB EQ "TCL" AND (MENU.NAME NE EMPTY AND MENU.NAME NE PAR.MENU$MENU.ID<ONE,ONE>) THEN
INS MENU.NAME BEFORE PAR.MENU$MENU.ID<ONE,ONE>
INS SCR.LOCN BEFORE PAR.MENU$LOCN<ONE,ONE>
END
PAR.MENU$LOCN<ONE,ONE> = SCR.LOCN
*
! Check for 'Enter <cr>' param   (%)
*
IF EXEC.VERB[ONE,ONE] EQ "%" THEN CR.FLAG = TRUE; EXEC.VERB = EXEC.VERB[TWO,999]
*
! Question for user (!)
*
LOOP TC = INDEX(EXEC.VERB,"!",ONE) WHILE TC DO
TMP = FIELD(EXEC.VERB,"!",TWO); TMP1 = EXEC.VERB[ONE,TC - ONE]
TMP2 = INDEX(EXEC.VERB,"!",TWO)
IF TMP2 THEN TMP2 = EXEC.VERB[TMP2 + ONE,999] ELSE TMP2 = EMPTY
PRINT CLB:TMP[ONE,70]:" ":; INPUT TMP.RSP:
EXEC.VERB = TMP1:TMP.RSP:TMP2
REPEAT
*
! Insert port key here ($)
*
LOOP TC = INDEX(EXEC.VERB,"$",ONE) WHILE TC DO
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:PORT.KEY:EXEC.VERB[TC + ONE,999]
REPEAT
*
! Insert account name here (#?) (  #D   #T   #n  )
*
LOOP TC = INDEX(EXEC.VERB,"#",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF TMP EQ EMPTY THEN TMP = "?"
IF NUM(TMP) THEN
IF TMP LT ONE THEN TMP = ONE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:FIELD(ACCT,".",TMP):EXEC.VERB[TC + TWO,999]
END ELSE
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:PAR.MENU$USER:EXEC.VERB[TC+ ONE,999]
END
REPEAT
*
! Insert date or time here (  #D  #T  #n   )
*
LOOP TC = INDEX(EXEC.VERB,"_",ONE) WHILE TC DO
TMP = EXEC.VERB[TC,TWO]
TMP = TMP[TWO,ONE]
IF NOT(NUM(TMP)) THEN TMP = ONE
IF TMP EQ "T" THEN TMP1 = OCONV(DATE(),"D2") ELSE
IF TMP EQ "D" THEN TMP1 = OCONV(TIME(),"MTS") ELSE TMP1 = "?"
END
EXEC.VERB = EXEC.VERB[ONE,TC - ONE]:TMP1:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Insert special routines name here   (   .?   )
*
ROUTINE.SUFFIX = EMPTY
LOOP TC = INDEX(EXEC.VERB,".?",ONE) WHILE TC DO
IF NOT(LEN(ROUTINE.SUFFIX)) THEN
TMP = EXEC.VERB[ONE,TC - ONE]
LOOP UNTIL NOT(INDEX(TMP," ",ONE)) DO TMP = TMP[TWO,999] REPEAT
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = EMPTY
LOCATE TMP IN SPECIAL.ROUTINES<ONE> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<TWO,LOC>
END
EXEC.VERB = EXEC.VERB[ONE,TC]:ROUTINE.SUFFIX:EXEC.VERB[TC + TWO,999]
REPEAT
*
! Check for lock param (l)
*
IF EXEC.VERB[ONE,ONE] EQ "l" THEN
EXEC.VERB = EXEC.VERB[TWO,9999]
LCK.ITM = TRUE
END ELSE LCK.ITM = FALSE
*
! Process terminal input to routing
*
PARAMS = EXEC.VERB
EXEC.VERB = EXEC.VERB<ONE,ONE,ONE>
EXEC.VERB.ID = EXEC.VERB
DEL PARAMS<ONE,ONE,ONE>
EXEC.IN = EMPTY
*
LOOP UNTIL PARAMS = EMPTY DO
IF OPSYS = "R" THEN DATA PARAMS<ONE,ONE,ONE> ELSE EXEC.IN = EXEC.IN:PARAMS<ONE,ONE,ONE>:AM
DEL PARAMS<ONE,ONE,ONE>
REPEAT
*
BEGIN CASE
*
CASE OPSYS = "U"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
* IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP ":EXEC.VERB
END
*
CASE OPSYS = "R"
IF EXEC.VERB[ONE,6] NE "CHAIN" AND EXEC.VERB NE "OFF" AND EXEC.VERB NE "TCL" AND EXEC.VERB.ID[ONE,ONE] NE "." THEN
IF FIELD(EXEC.VERB," ",TWO) EQ EMPTY THEN EXEC.VERB = "RUN BP.OBJ ":EXEC.VERB
END
*
CASE TRUE
TMP = FIELD(EXEC.VERB," ",ONE)
IF TMP EQ "RUN" THEN
TMP = FIELD(EXEC.VERB," ",TWO)
EXEC.VERB = EXEC.VERB[COL2() + ONE,9999]
END
*
END CASE
*
! Check group authorization
*
IF EXEC.VERB.ID[ONE,ONE] EQ "." OR EXEC.VERB EQ "TCL" THEN
LOCATE "TCL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE
LOCATE "ALL" IN PAR.MENU$GROUP<ONE,ONE> SETTING TMP ELSE LCK.STAT = TRUE
END
IF LCK.STAT THEN
PRINT CLB:RVB:"You do not have access to TCL! Enter <cr> . . . ":RVE:BELL:; INPUT TMP.RSP:
END
END
*
! Lock record
*
IF NOT(LCK.STAT) THEN
IF EXEC.VERB.ID[ONE,ONE] EQ "." THEN EXEC.VERB.ID = EXEC.VERB.ID[TWO,999]
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "RUN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",3)
IF FIELD(EXEC.VERB.ID," ",ONE) EQ "CHAIN" THEN EXEC.VERB.ID = FIELD(EXEC.VERB.ID," ",TWO)
IF LCK.ITM THEN
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE,LCK.STAT)
WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
END ELSE LCK.STAT = FALSE
END; * Of lock stat
*
! OFF request made
*
IF RESET.SW OR EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
PAR.MENU$MENU.ID = EMPTY
PAR.MENU$LOCN   = ONE
PAR.MENU$DESC = "OFF"
END
PAR.MENU$GROUP = EMPTY
PAR.MENU$USER = EMPTY
END
*
! Write location
*
MATWRITE PAR.MENU ON PAR.FILE,CALL.ID
*
! Ready to execute routing
*
IF NOT(LCK.STAT) THEN
*
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
*
READ TMP FROM ACC.FILE,ACC.ID ELSE TMP = EMPTY
TMP<ACC.AM.DESC> = EXEC.DESC
TMP<ACC.AM.VERB> = EXEC.VERB
TMP<ACC.AM.DT>   = DATE()
TMP<ACC.AM.TM>   = TIME()
WRITE TMP ON ACC.FILE,ACC.ID
*
MATWRITE STD ON COM.FILE,SEC.USER$ITEM.ID
*
IF EXEC.VERB EQ "TCL" THEN STOP
*
IF EXEC.VERB EQ "OFF" OR EXEC.VERB EQ "CHAIN OFF" THEN
IF RESET.SW EQ 999 THEN GOTO UNLOCK
CHAIN "AXOFF"
END
*
IF EXEC.VERB[ONE,6] EQ "CHAIN " THEN CHAIN EXEC.VERB[7,999]
*
* is it a PC command
IF EXEC.VERB[ONE,3] EQ "PC " THEN
*
EXECUTE EXEC.VERB; * DON'T CHANGE
*
END ELSE
*
* Not a PC command
IF EXEC.IN EQ EMPTY THEN
*
EXECUTE EXEC.VERB
*
END ELSE
*
EXEC.IN = EXEC.IN[ONE,LEN(EXEC.IN) - ONE]
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
END
*
END; * Of PC or not
*
END; * Of item not locked
*
IF LCK.ITM THEN
CALL UNLOCK.ITEM(COM.FILE,"MD",EXEC.VERB.ID,LCK.FILE)
END
*
*
IF CR.FLAG EQ TWO THEN
PRINT CLB:RVB:"Continuing . . . ":RVE:BELL:; RQM; RQM
END ELSE IF CR.FLAG THEN
PRINT CLB:"Enter <cr> to continue . . . ":; INPUT TMP.RSP:
END
*
~SYS.INCL.FIRSTWORD~
*CODE.SEGMENT: SYS.INCL.FIRSTWORD
*
TC.CN = ONE; OLD.TC.CN = TC.CN
TC = "?"; TC.MARK = "^"; TC.SP = ZERO
TC.MARK1 = "#"
WORD.CN = ONE
FIRST = ""; SECOND = ""
*
IF LINE.DISP THEN
IF LEN(LINE) GT 77 THEN TMP.DISP = FALSE ELSE
*PRINT @(ZERO,18):CLL:
PRINT @(ZERO,19):CLL:
PRINT @(ZERO,20):CLL:" ":LINE "L#77":
PRINT @(ZERO,21):CLL:
PRINT @(ZERO,22):CLL:
TMP.DISP = TRUE
END
END ELSE TMP.DISP = FALSE
*
FOR WORD.CN = ONE TO TWO UNTIL TC EQ EMPTY
*
LOOP
*
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,21):TC.MARK1:@(TC.CN,21):RVB:TC.MARK:RVE:" ":; OLD.TC.CN = TC.CN
*
UNTIL INDEX(" ;",TC,ONE) OR TC EQ EMPTY DO TC.CN = TC.CN + ONE REPEAT
*
IF WORD.CN EQ ONE THEN
FIRST = LINE[ONE,TC.CN - ONE]
TC.SP = TC.CN
TC.MARK = "&"
TC.MARK1 = "="
TC.CN = TC.CN + ONE
END ELSE
SECOND = LINE[TC.SP+ONE,TC.CN - ONE - (TC.SP)]
END
*
NEXT WORD.CN
*
IF TMP.DISP THEN
*PRINT @(ZERO,21):RVB:">":STR("-",TC.CN - ONE):"<":RVE:" ":
PRINT @(ZERO,21):">":RVB:STR("-",TC.SP - ONE):RVE:"&":RVB:STR("_",TC.CN - TC.SP - ONE):RVE:"<":" ":
END
*
IF TMP.DISP THEN
PRINT @(10,19):FIRST:"|":@(20,19):SECOND:"|     "
END
*
~SYS.INCL.FKEY.DISP~
*CODE.SEGMENT: SYS.INCL.FKEY.DISP
*
FUNC.VC.OFFSET = ZERO; FUNC.CL = ZERO
FUNC.STR = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0><"
*
* Display function keys; * : *
IF NOT(GENERIC) AND NOT(SYSTEM(11)) THEN
**PRINT @(ZERO,STAT.LN):RVB:FUNC.RSP:RVE:
PRINT @(ZERO,STAT.LN):
LOOP
TMP = 5 + LEN(CURSOR.KEYS<4,FUNC.VC + FUNC.VC.OFFSET>)
* ULT ONLY
IF SYSTEM(11) THEN TMP = 999
UNTIL FUNC.VC + FUNC.VC.OFFSET GT FUNC.VC.MAX OR FUNC.CL + TMP GE 80 DO
TMP1 = FUNC.STR[FUNC.VC + FUNC.VC.OFFSET,ONE]
PRINT RVB:("F":TMP1):RVE:" ":CURSOR.KEYS<4,FUNC.VC + FUNC.VC.OFFSET>:"  ":
FUNC.CL = FUNC.CL + TMP
FUNC.VC.OFFSET = FUNC.VC.OFFSET + ONE
REPEAT
END
~SYS.INCL.FSEARCH.BOT~
*CODE.SEGMENT: SYS.INCL.FSEARCH.BOT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 01 OCT 87
* (c) Copyright 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
WHILE NOT(FKEY.FOUND) AND FSEARCH.CN LT FSEARCH.MAX DO
FSEARCH.CN = FSEARCH.CN + ONE
REPEAT
*
~SYS.INCL.FSEARCH.TOP~
*CODE.SEGMENT: SYS.INCL.FSEARCH.TOP
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 01 OCT 87
* (c) Copyright 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
* FSEARCH.PREFIX must be set upon entry!
*
FSEARCH.MAX = 6
FSEARCH.CN  = ONE
FKEY.ID     = ""
FKEY.SUFFIX = ""
*
LOOP
*
BEGIN CASE
CASE FSEARCH.CN EQ ONE
FSEARCH.SUFFIX = "@ALL"
CASE FSEARCH.CN EQ TWO
FSEARCH.SUFFIX = "@ACCT@":ACCT:"@":PORT
CASE FSEARCH.CN EQ 3
FSEARCH.SUFFIX = "@ACCT@":ACCT
CASE FSEARCH.CN EQ 4
FSEARCH.SUFFIX = "@PORT@":PORT
CASE FSEARCH.CN EQ 5
FSEARCH.SUFFIX = "@USER@":USER.ID
CASE FSEARCH.CN EQ 6
FSEARCH.SUFFIX = "@APPL@":APPL
CASE FSEARCH.CN
FSEARCH.SUFFIX = FSEARCH.PREFIX
END CASE
*
FKEY.ID = FSEARCH.PREFIX:FSEARCH.SUFFIX
FKEY.FOUND = FALSE
*
~SYS.INCL.HDR.DISP~
*CODE.SEGMENT: SYS.INCL.HDR.DISP
*
* PRINT @(ZERO,ZERO):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
PRINT @(ZERO,TWO):CLL:RVB:OCONV(TIME(),"MTS") "L#10":(SPACE(35 - LEN(TITLE) / TWO):TITLE) "L#70":RVE:
*
~SYS.INCL.HEADING~
*CODE.SEGMENT: SYS.HEADING
*
*$INCLUDE DH.BP SYS.HEADING(OUT.TO.PRINT,SYS.PROG.DESC,SCR.HEADING)
!
*#*$INCLUDE DH.BP SYS.COMMON
*#*
*#*$INCLUDE DH.BP SYS.STANDARD.FUNCTIONS
*#*
*#*SYS.PROG = "SYS.SCHED.NEXT":AM:SYS.PROG
*#*SYS.LOCT = "INIT":AM:SYS.LOCT
*#*SYS.SLOC = "":AM:SYS.SLOC
SYS.SLOC<1>="HEADING"
*#**
*#*GOSUB S.HEADING
*#**
*#*End.of.prog: * bypass GOTO for abnormal end.
*#**
*#*SYS.PROG = DELETE(SYS.PROG,1)
*#*SYS.LOCT = DELETE(SYS.LOCT,1)
*#*SYS.SLOC = DELETE(SYS.SLOC,1)
*#*RETURN
*#*!
*#**
*#**
*#*S.HEADING: * Subroutine to print screen heading.
TEMP = 0
TEMP1 = 0
SCR.PORT = ""
SCR.UPD = ""
SCR.CNTR = ""
*
*
IF STRUCT(25)<1,PORT+1> THEN
*
IF STRUCT(70) > 0 THEN SCR.CNTR = (STRUCT(70)-1)[1,1] ELSE SCR.CNTR = "o"
IF STRUCT(91) > 0 THEN SCR.CNTR = SCR.CNTR:(STRUCT(91)-1)[1,1] ELSE SCR.CNTR = SCR.CNTR:"o"
IF WAIT.FLAG THEN SCR.CNTR = SCR.CNTR:WAIT.FLAG[1,1] ELSE SCR.CNTR = SCR.CNTR:"w"
*
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF STRUCT(21)<1,TEMP> # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVE
SCR.PORT = SCR.PORT:STRUCT(21)<1,TEMP>[1,1]
IF TEMP-1 EQ PORT THEN SCR.PORT = SCR.PORT:RVB; TEMP1 = 2
END ELSE
SCR.PORT = SCR.PORT:"o"
END
REPEAT
SCR.PORT = SCR.PORT[1,10+TEMP1]
*
TEMP = 0
TEMP2 = 0
LOOP TEMP = TEMP + 1 WHILE TEMP < 11 DO
IF USER.UPD(TEMP) # 0 THEN
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVE
SCR.UPD = SCR.UPD:USER.UPD(TEMP)[1,1]
IF TEMP-1 EQ PORT THEN SCR.UPD = SCR.UPD:RVB; TEMP2 = 2
END ELSE
SCR.UPD = SCR.UPD:"o"
END
REPEAT
SCR.UPD = SCR.UPD[1,10+TEMP2]
*
END
*
*
IF OUT.TO.PRINT = 1 THEN
PRINTER ON
PRINT FF
MAX.COL = 132
MAX.LN = 60
END ELSE
*
*# LINE 0 - LINE 0 - LINE 0
PRINT @(0,0):CLL:RVB: ; *#
*#CLS:
MAX.COL = 80
MAX.LN = 20
END
*
*
PRINT (OCONV(DATE(),"D2"):"  ":OCONV(TIME(),"MTS")) "L#20": ; *#
*@*#PRINT (SPACE(20-LEN(CO.DATA<1,1,1>)/2+.5):CO.DATA<1,1,1>) "L#40":
PRINT (PORT:".":ACCT:".":STRUCT(2)) "R#15": ; *#
*
*IF OUT.TO.PRINT = 1 THEN PRINT ELSE
*PRINT @(0,1):CLL:
*END
*
IF STRUCT(25)<1,PORT+1> THEN PRINT (" ":MODE.DESC(USER.MODE):" mode") "L#16": ELSE PRINT SPACE(16): ; *#
*#PRINT (SPACE(20-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#40":
PRINT MENU.APPL.DESC "L#28":
*#
*#v
*# LINE 1 - LINE 1 - LINE 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,1):CLL: ; *#
END
*#^
IF STRUCT(25)<1,PORT+1> THEN 
*#PRINT "Ports.on>":
PRINT "[P|": ; *#
*#IF NOT(TEMP1) THEN PRINT SCR.PORT "R#10": ELSE 
PRINT SCR.PORT "R#12": ; *#
*#PRINT "<":
PRINT "] ": ; *#
END ELSE PRINT SPACE(15): ; *#
*
*IF OUT.TO.PRINT = 1 THEN PRINT ELSE
*PRINT @(0,2):CLL:
*END
*
IF STRUCT(25)<1,PORT+1> THEN
*#PRINT "Upd>":
PRINT "[U|": ; *#
*#IF NOT(TEMP1) THEN PRINT SCR.UPD "R#10": ELSE 
PRINT SCR.UPD "L#12": ; *#
*#PRINT "<":
PRINT "] ": ; *#
END ELSE PRINT SPACE(15): ; *#
*@*#PRINT (SPACE(25-LEN(MENU.CONTROL<1,1>)/2+.5):MENU.CONTROL<1,1>) "L#50":
IF STRUCT(25)<1,PORT+1> THEN PRINT SCR.CNTR "R#15": ELSE PRINT SPACE(15): ; *#
*
*# LINE 2 - LINE 2 - LINE 2
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,2):CLL: ; *#
END
PRINT CO.DATA<1,1,1> "L#35": ; *#
*#SPACE(INT(17.5-LEN(CO.DATA<1,1,1>)/2+.5)):
*#PRINT (SPACE(20-LEN(MENU.APPL.DESC)/2+.5):MENU.APPL.DESC) "L#39" ; *#
PRINT " ":MENU.CONTROL<1,1> "L#43":
*#SPACE(20-LEN(MENU.CONTROL<1,1>)/2+.5):
*# LINE 3 - LINE 3 - LINE 3
IF OUT.TO.PRINT = 1 THEN PRINT ELSE
PRINT @(0,3):CLL: ; *#
END
LN = 3
*
IF LEN(SYS.PROG.DESC) # 0 THEN
PRINT (SPACE((80-LEN(SYS.PROG.DESC)) / 2):SYS.PROG.DESC) "L#80": ; *#
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE PRINT @(0,LN):CLL: ; *#
END
*
IF NOT(OUT.TO.PRINT) THEN PRINT RVE: ELSE PRINT
TEMP = 0
LOOP TEMP = TEMP + 1 WHILE LEN(SCR.HEADING<TEMP>) # 0 DO
PRINT SCR.HEADING[1,MAX.COL-1]: ; *#
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN PRINT ELSE PRINT @(0,LN):CLL: ; *#
REPEAT
*
LN = LN + 1
IF OUT.TO.PRINT = 1 THEN
PRINT
PRINTER OFF
END ELSE
PRINT @(0,LN):CLS: ; *#
END
*
*#*RETURN
*#**
*#**
*#*END
~SYS.INCL.HI.DEV.MODE~
*CODE.SEGMENT: SYS.INCL.HI.DEV.MODE
*
EQU HI.D.M TO 20
*
~SYS.INCL.HI.SALES.MODE~
*CODE.SEGMENT: SYS.INCL.HI.SALES.MODE
*
EQU HI.S.M TO 2
*
~SYS.INCL.HI.TRAIN.MODE~
*CODE.SEGMENT: SYS.INCL.HI.TRAIN.MODE
*
EQU HI.T.M TO 6
*
~SYS.INCL.ITEM.TYPE~
*CODE.SEGMENT: SYS.INCL.ITEM.TYPE
*
*
ATTR1.TC = ATTR1[ONE,ONE]
*
BEGIN CASE
*
CASE ATTR1[ONE,10] EQ "*PROGRAM: "
PROG.LIST<-ONE> = ITEM.ID
PRINT "PROG" "L#5":
WRITE.FLAG = TRUE
IF LIST.TYPE NE "PROG" THEN LIST.TYPE = "PROG"
RTN.TYPE = "PROG"
*
CASE ATTR1[ONE,15] EQ "*CODE.SEGMENT: "
CSEG.LIST<-ONE> = ITEM.ID
PRINT "CSEG" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*PROC*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "CSEG"
RTN.TYPE = "CSEG"
*
CASE ATTR1[ONE,TWO] EQ "PQ"
PROC.LIST<-ONE> = ITEM.ID
PRINT "PROC" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "PROC"
RTN.TYPE = "PROC"
*
CASE ATTR1[ONE,11] EQ "SUBROUTINE "
SUBR.LIST<-ONE> = ITEM.ID
PRINT "SUBR" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*CSEG*PROC*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "SUBR"
RTN.TYPE = "SUBR"
*
CASE INDEX("ASXDQP",ATTR1.TC,ONE)
DICT.LIST<-ONE> = ITEM.ID
PRINT "DICT" "L#5":
WRITE.FLAG = TRUE
IF INDEX("*ABORT*OTHER*","*":LIST.TYPE:"*",ONE) THEN LIST.TYPE = "DICT"
RTN.TYPE = "DICT"
*
CASE TRUE
OTHER.LIST<-ONE> = ITEM.ID
PRINT "OTHR" "L#5":
IF LIST.TYPE EQ "ABORT" THEN LIST.TYPE = "OTHER"
RTN.TYPE = "OTHER"
*
END CASE
*
~SYS.INCL.LASTWORD~
*CODE.SEGMENT: SYS.INCL.LASTWORD
*
*
* find last statement
*
TC.SPCC = ")":VM:">":VM:"]":VM:"}":VM:"'":VM:'"':VM:","
TC.ALTC = "(":VM:"<":VM:"[":VM:"{":VM:"'":VM:'"':VM:" "
TC.CN = LEN(LINE); TC.CN.START = ZERO; TC.CN.MAX = TC.CN
OLD.TC.CN = TC.CN
*
IF LINE.DISP THEN
IF LEN(LINE) GT 77 THEN TMP.DISP = FALSE ELSE
**PRINT @(ZERO,18):CLL:
**PRINT @(ZERO,19):CLL:
PRINT @(ZERO,20):CLL:" ":LINE "L#77":
**PRINT @(ZERO,22):CLL:
TMP.DISP = TRUE
END
END ELSE TMP.DISP = FALSE
*
LOOP
*
LOOP
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
UNTIL TC EQ ";" OR NOT(TC.CN) DO
TC.CN = TC.CN - ONE
REPEAT
*
TC.CN.START = TC.CN; TC.CN = TC.CN + ONE
*
LOOP
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
WHILE TC EQ " " AND TC.CN LT TC.CN.MAX DO TC.CN = TC.CN + ONE REPEAT
*
WHILE (TC EQ "*" OR TC EQ "!") AND TC.CN.START DO
*
TC.CN.MAX = TC.CN.START - ONE; TC.CN = TC.CN.MAX
*
REPEAT
*
! Find last word
*
* Trim spaces
*
TC.CN = TC.CN.MAX
*
LOOP
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
WHILE LINE[TC.CN,ONE] EQ " " OR NOT(TC.CN GT TC.CN.START) DO TC.CN = TC.CN - ONE REPEAT
*
TC.CN.END = TC.CN + ONE
TC.SPCC.CN = ZERO
*
! Find start of word
*
LOOP
*
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
*
LOCATE TC IN TC.SPCC<ONE> SETTING TMP THEN
TC.SPCC.CN = TC.SPCC.CN + ONE
TC.CN = TC.CN - ONE
LOOP
TC = LINE[TC.CN,ONE]
IF TC EQ TC.ALTC<ONE,TMP> THEN TC.SPCC.CN = TC.SPCC.CN - ONE ELSE
IF TC EQ TC.SPCC<ONE,TMP> THEN TC.SPCC.CN = TC.SPCC.CN + ONE
END
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
WHILE TC.SPCC.CN GT ZERO AND TC.CN GT TC.CN.START DO
TC.CN = TC.CN - ONE
REPEAT
IF TC.CN GT TC.CN.START THEN
TC.CN = TC.CN - ONE
TC = LINE[TC.CN,ONE]
END ELSE TC = EMPTY
END ELSE NULL
*
UNTIL INDEX(" ;",TC,ONE) OR (INDEX(":+-*/",TC,ONE) AND TC.CN LT TC.CN.END - ONE) OR TC.CN LE TC.CN.START DO
TC.CN = TC.CN - ONE
REPEAT
*
LAST = TRIM(LINE[TC.CN + ONE,TC.CN.END - TC.CN - ONE])
IF TMP.DISP THEN
PRINT @(TC.CN,22):RVB:">":STR("-",TC.CN.END - TC.CN - ONE):"<":RVE:" ":
END
*
IF TMP.DISP THEN
*PRINT @(ZERO,19):CLL:RVB:LAST:RVE:" ":
PRINT @(30,19):LAST:"|           "
END
*
~SYS.INCL.LCK.ITM~
*CODE.SEGMENT: SYS.INCL.LCK.ITM
*
* LCK.FIL.ID
* LCK.ITM.ID
* LCK.TYPE
* LCK.ITM
* LCK.RELS
* LCK.ELP.MAX
*
IF LCK.ITM THEN
*
LCK.STAT = FALSE
LCK.DT = DATE(); LCK.TM = TIME(); LCK.ELP = ZERO
*
LOOP
LCK.TMP = LCK.TYPE; LCK.STAT = EMPTY
CALL SYS.ITM.LCK(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TMP,"1",SYS.PROG,"0",OPER,EXP.LCK.TM,SYS.LOCT,"A","",LCK.STAT)
LCK.ELP = ((DATE() - LCK.DT) * 86400) + (TIME() - LCK.TM)
UNTIL NOT(LCK.STAT) OR LCK.ELP GT LCK.ELP.MAX DO REPEAT
*
END
*
~SYS.INCL.LCK.RELS~
*CODE.SEGMENT: SYS.INCL.LCK.RELS
*
* LCK.FIL.ID
* LCK.ITM.ID
* LCK.TYPE
* LCK.ITM
* LCK.RELS
* LCK.ELP.MAX
*
IF LCK.RELS THEN
*
LCK.TMP = LCK.TYPE
CALL SYS.ITM.RLS(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TMP,"1",SYS.PROG,"0",OPER,EXP.LCK.TM,SYS.LOCT,"A","",LCK.STAT)
LCK.RELS.DT = DATE(); LCK.RELS.TM = TIME()
LCK.RELS.ELP = ((LCK.RELS.DT - LCK.DT) * 86400) + (LCK.RELS.TM - LCK.TM)
*
END
*
~SYS.INCL.LIST.RSP~
*CODE.SEGMENT: SYS.INCL.LIST.RSP
*
*
EQU LIST.RSP TO "*COPY-LIST*GET-LIST*QSELECT*FORM-LIST*SELECT*SSELECT*"
*
~SYS.INCL.LIST.TYPE.WRITE~
*CODE.SEGMENT: SYS.INCL.LIST.TYPE.WRITE
*
*
WRITE PROG.LIST ON LISTS.FILE,LIST.NAME:".PROG"
WRITE CSEG.LIST ON LISTS.FILE,LIST.NAME:".CSEG"
WRITE PROC.LIST ON LISTS.FILE,LIST.NAME:".PROC"
WRITE SUBR.LIST ON LISTS.FILE,LIST.NAME:".SUBR"
WRITE DICT.LIST ON LISTS.FILE,LIST.NAME:".DICT"
WRITE OTHER.LIST ON LISTS.FILE,LIST.NAME:".OTHER"
*
WRITE CODE.LIST ON LISTS.FILE,LIST.NAME:".CODE"
WRITE EDIT.LIST ON LISTS.FILE,LIST.NAME:".EDIT"
*
~SYS.INCL.LO.DEV.MODE~
*CODE.SEGMENT: SYS.INCL.LO.DEV.MODE
*
EQU LO.D.M TO 11
*
~SYS.INCL.LO.TCL.MODE~
*CODE.SEGMENT: SYS.INCL.LO.TCL.MODE
*
EQU LO.TCL.M TO 9
*
~SYS.INCL.LO.TRAIN.MODE~
*CODE.SEGMENT: SYS.INCL.LO.TRAIN.MODE
*
EQU LO.T.M TO 3
*
~SYS.INCL.LOAD.ACC~
*CODE.SEGMENT: SYS.INCL.LOAD.ACC
*
* DAVID HORSMAN
*
READ ACC.REC FROM ACC.FILE,ACC.ID ELSE ACC.REC = EMPTY
ACC.DESC = ACC.REC<ACC.AM.DESC> 
ACC.VERB = ACC.REC<ACC.AM.VERB> 
ACC.DT   = ACC.REC<ACC.AM.DT>   
ACC.TM   = ACC.REC<ACC.AM.TM>   
*
~SYS.INCL.LOAD.AUTO~
*CODE.SEGMENT: SYS.INCL.LOAD.AUTO
*
INPUT AUTO.RUN
*
IF NOT(STAT) AND AUTO.RUN THEN
*
LCK.FILE.ID = "PAR"; LCK.ID = "CURRENT.RUN"
*
IF NOT(STAT) AND LCK.ITM THEN
*
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(PAR.FILE,LCK.FILE.ID,LCK.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN STAT = LCK.STAT
WHILE NOT(STAT) AND LCK.STAT DO REPEAT
*
IF NOT(STAT) THEN
READ CURRENT.RUN FROM PAR.FILE,LCK.ID ELSE CURRENT.RUN = EMPTY
END
*
IF NOT(LCK.STAT) THEN
CALL UNLOCK.ITEM(PAR.FILE,LCK.FILE.ID,LCK.ID,LCK.FILE)
END
*
END ELSE IF NOT(STAT) THEN
READ CURRENT.RUN FROM PAR.FILE,LCK.ID ELSE CURRENT.RUN = EMPTY
END
*
IF STAT THEN
TEXT = "Unable to perform current procedure"
STOP
END
*
END ELSE CURRENT.RUN = EMPTY
*
~SYS.INCL.LOAD.CMD~
*CODE.SEGMENT: SYS.INCL.LOAD.CMD
*
*
*
*
PROC.FL = TRUE; PROC.BUF = EMPTY
TCL.FL = FALSE; TCL.BUF = EMPTY
EXEC.FL = FALSE; EXEC.BUF = EMPTY
CMD.BUF = EMPTY
*
BEGIN CASE
CASE OPSYS EQ "M"
*TCL.BUF = SYSTEM(??)
IF TCL.BUF NE EMPTY THEN CMD.BUF = TCL.BUF
* MDD ONLY
PROCREAD PROC.BUF ELSE PROC.FL = FALSE
IF PROC.FL THEN
PROC.CN.MAX = DCOUNT(PROC.BUF,AM)
PROC.REC = PROC.BUF; TMP = PROC.BUF; PROC.BUF = EMPTY
FOR CN = ONE TO PROC.CN.MAX
IF (CN - ONE) THEN PROC.BUF = PROC.BUF:" "
PROC.BUF = PROC.BUF:TMP<CN>
NEXT CN
CMD.BUF = PROC.BUF
END; * of PROC.FL
CASE OPSYS EQ "P"
CASE OPSYS EQ "R"
CASE OPSYS EQ "U"
* ULT ONLY
PROCREAD PROC.BUF ELSE PROC.FL = FALSE
CASE TRUE
PROC.FL = FALSE
PROC.BUF = EMPTY
END CASE
IF PROC.BUF[ONE,3] EQ "SET" THEN PROC.FL = FALSE
* IF PROC.BUF EQ EMPTY THEN PROC.FL = FALSE
*
*
!
*
~SYS.INCL.LOAD.CO~
*CODE.SEGMENT: SYS.INCL.LOAD.CO
*
*DATE: 24 FEB 93
*
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = ""
IF OPERATORS = "" THEN OPERATORS = ACCT[1,3]
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; INPUT RSP; STOP
ACCTG.PERIOD = CURR.ACCTG.PERIOD[1,2]:"-":CURR.ACCTG.PERIOD[3,2]
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; INPUT RSP; STOP
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DT = CO.DATA<2,1,1>
~SYS.INCL.LOAD.PORT.KEY~
*CODE.SEGMENT: SYS.INCL.LOAD.PORT.KEY
*
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
~SYS.INCL.LOAD.STD.DATA~
*CODE.SEGMENT: SYS.INCL.LOAD.STD.DATA
*
*
IF STD.FUNC EQ "READ" OR STD.FUNC EQ "PERFORM" THEN
* Enter STanDard SUBRoutine
*
LOOP
STD.CONT = FALSE
*
IF STD.FUNC EQ "PERFORM" THEN
PRINT @(ZERO,22):CLL:RVB:"Enter file name: ":RVE:BELL:
INPUT TMP.RSP:
IF TMP.RSP NE EMPTY THEN SEC.USER$FILE.NAME = TMP.RSP ELSE PRINT SEC.USER$FILE.NAME:
END
IF SEC.USER$FILE.NAME EQ EMPTY THEN SEC.USER$FILE.NAME = "COM"
OPEN SEC.USER$FILE.NAME TO STD.FILE THEN
*
IF STD.FUNC EQ "PERFORM" THEN
PRINT @(ZERO,22):CLL:RVB:"Enter Item ID: ":RVE:BELL:
INPUT TMP.RSP:
IF TMP.RSP NE EMPTY THEN SEC.USER$ITEM.ID = TMP.RSP ELSE PRINT SEC.USER$ITEM.ID:
END
*
MATREAD STD FROM STD.FILE,SEC.USER$ITEM.ID ELSE
PRINT CLB:RVB:SEC.USER$ITEM.ID:" item is missing! Enter <cr> . . .":RVE:BELL:; INPUT TMP.RSP:
END
*
END ELSE
PRINT CLB:RVB:SEC.USER$FILE.NAME:" file is missing! Enter <cr> . . .":RVE:BELL:; INPUT TMP.RSP:
STD.FUNC = "PERFORM"; STD.CONT = TRUE
END; * Of open
WHILE STD.CONT DO REPEAT
*
END; * Of read or perform
*
~SYS.INCL.LOAD.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.LOAD.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
*
READ DELAY.CN.MAX FROM PAR.FILE,"STANDARD.DELAY" ELSE DELAY.CN.MAX = ZERO:AM:300
*
DELAY.RESET = DELAY.CN.MAX<TWO>
DELAY.CN.MAX = DELAY.CN.MAX<ONE>
*
DELAY.DT = DATE(); DELAY.TM = TIME()
*
*
~SYS.INCL.LOAD.TST~
*CODE.SEGMENT: SYS.INCL.LOAD.TEST.ITEM
*
* AUTHOR: David Horsman
*
CALL SH.MAINT.TST.SUB(CNT.FILE,CNT.TST.ID,MAT CNT.TST,PAR.FILE,LCK.FILE,CNT.ID.SAVE,GENERIC,CO.DATA,SYS.TST,STAT)
*
INPUT TMP:
RETURN
*
* REMOVE THESE VARIABLES
*
TEST.FL = ZERO; LIST.NAME = EMPTY; DIS.SUB = ZERO; DIS.ITEM = ZERO
*  TF         ; TST<TST$LIST.NAME>; LBL.DISP     ; ID.DISP
DIS.PROG = ZERO; TIMING = ZERO; BREAK.ON = ZERO
*TST<TST$RTN>  ; TST<TST$TIMING>; TST<TST$BREAK>
*
* These variable are handled here or s/b replaced
* TST<TST$TA>
BREAK.ON = ZERO;   WKO.TEST = ZERO
*TST<TST$BREAK>;   TST$AM = 12 & TST$VM = 1
*
*
TST.ID = "SYSTEM.TEST"
READ TST FROM CNT.FILE,TST.ID ELSE TST = EMPTY
*
LBL.DISP = FALSE; CNT.TST$CR = FALSE; ID.DISP = FALSE; FILE.UPD = FALSE
TF = EMPTY
IF LEN(TST<TST$AM,TST$VM>) THEN TF = TST<TST$AM,TST$VM>
IF TF EQ 9 THEN TF = EMPTY
*
*
IF TF EQ EMPTY THEN
TF = FALSE
IF TST<TST$SYS> GT TF THEN TF = TST<TST$SYS>
IF TST<TST$APPL> GT TF THEN TF = TST<TST$APPL>
IF TF THEN
LBL.DISP = TST<TST$LBL>
IF LBL.DISP GE 3 THEN CNT.TST$CR = TRUE ELSE CNT.TST$CR = FALSE
IF LBL.DISP GE 5 THEN ID.DISP = TRUE
FILE.UPD = TST<TST$FILE>
IF FILE.UPD THEN ID.DISP = TRUE
END
END ELSE
IF TF GE 3 THEN CNT.TST$CR = TRUE
IF TF GE 1 THEN LBL.DISP = TRUE
IF TF GE 5 THEN ID.DISP = TRUE
IF TF GE 6 AND TF LE 8 THEN FILE.UPD = TF
END
*
!
*
IF TST<TST$BREAK> THEN
* BREAK IS ON
END ELSE
* BREAK IS OFF
END
IF TST<TST$TA> THEN
*TYPE AHEAD IS ON
END ELSE
* TYPE AHEAD IS OFF
END
*
IF TF THEN
TEST.FL = 1
DIS.PROG  = TST<TST$RTN>
DIS.SUB   = TST<TST$LBL>
DIS.ITEM  = TST<TST$FILE>
LIST.NAME = TST<TST$LIST.NAME>
TIMING    = TST<6>
BREAK.ON  = TST<7>
WKO.TEST  = TST<8>
PRINT @(0,22):CLL:RVB:("Rtn ":TST<TST$RTN>:" SubRtn ":TST<TST$LBL>:" Item ":TST<TST$FILE>:" List ":TST<TST$LIST.NAME>) "L#75":RVE:
PRINT @(0,23):CLL:RVB:("Tst ":TST<TST$SYS>:"Timing ":TST<6>:" Break ":TST<7>:" WKO ":TST<8>:" Appl ":TST<TST$APPL>) "L#75":RVE:
*
IF CNT.TST$CR THEN PRINT CLB:"SYS.INCL.LOAD.TST <cr> ":; INPUT TMP:
*
RQM
END
!
~SYS.INCL.LOAD.TST.DOC~
*CODE.SEGMENT: SYS.INCL.LOAD.TST.DOC
*
*
* READS CNT (THE VARIABLE 'TST') WHICH MUST BE LOADED
*
* 'SYS.TST' IN GENERAL.COMMON.AREA SHOULD BE LOADED WHERE APPLICABLE
*
* FILE: CNT     ITEM: SYSTEM.TEST
*
*EQ TST$SYS            TO 1
*** TST$APPL           ** 17
*EQ TST$RTN            TO 2
*EQ TST$LBL            TO 3
*EQ TST$FILE           TO 4
*EQ TST$LIST.NAME      TO 5
*EQ TST$TEST.DATE      TO 6
*EQ TST$BREAK          TO 7
*EQ TST$TIMING         TO 8
*EQ TST$TA             TO 9
*
*EQ TST$SPEC.APPL      TO 10
*EQ TST$SPEC.VAL       TO 11
*
*EQ TST$WO             TO 12
*EQ TST$BILL           TO 13
*EQ TST$SYST           TO 14
*EQ TST$RELS           TO 15
*EQ TST$PAUSE          TO 16
*EQ TST$APPL           TO 17
*
!
*
* ATR   PURPOSE
*   1   ON/OFF
*
*   2   Display 'ENTERING' PROGRAM OR EXTERNAL SUBROUTINE (CALLED)
*       1 - Display LOCATION 
*       2 - Display Location and PAUSE
*       3 - Display Location and INPUT <cr>
*
*   3   Display 'ENTERING' AN INTERNAL SUBROUTINE (GOSUB)
*       1 - Display LOCATION 
*       2 - Display Location and PAUSE
*       3 - Display Location and INPUT <cr>
*
*   4   Display Item ID Flag
*       1 - Display Item ID being processed
*       2 - Display Item ID being processed and PAUSE
*       3 - Display Item ID being processed and INPUT <cr>
*       6 - Display Item ID and MSG when ERROR/REJECTED, etc.
*
*   5   LIST.NAME to be PROCESSED
*
*   6   TEST.DATE to be used (EXTERNAL FORMAT)
*
*   7   BREAK is ON
*
*   8   TIMING Display is ON
*
*   9   TYPE-AHEAD is OFF
*
*  10   Application / Routine Name Table
*
*  11   Test Flag Value for Table
*
*  12   W/O Sup-application Flags
*    mv 1 W/O Processing in Genie
*    mv 2  "  Printing
*    mv 3  "  Type processing Disc
*    mv 4  "   "       "      Connect
*    mv 5  "   "       "      Transfers
*    mv 6  "   "       "      Premium
*    mv 7 Device processing
*    mv 8 Addr Intfc processing
*    mv 9 Headend Intfc ports
*
*  13   Billing Sub-application Flags
*    mv 1 Billing
*    mv 2 Statements
*    mv 3 Daily update
*    mv 4 Monthly update
*    mv 5 EFT/PAC processing
*    mv 6 Late charges
*
*  14   System Maintenence Flags
*    mv 1 Parameters
*    mv 2 Purging
*    mv 3 Backup/Restore
*    mv 4 Printer processing
*    mv 5 Input processing
*    mv 6 Numeric/Special conversions
*
*  15   Release Distribution Flags
*
*  16   Standard Number of Pauses
*         typically 1 to 3 seconds
*
!
!
*
* Note: The structure of the test flags is
*
* 1 - 9      system 
*
* 10 - 15  Applications
*
* 10  { spec.appl#1 { spec.appl#2 { spec.appl#3 { . . . } } } }
* 11  { spec.val#1  { spec.val#2  { spec.val#3  { . . . } } } }
*
!
!
* NOTE: The usage of test flags is
*
* blank - don't use this flag, use system flags
* 0     - Test status is force off at this level
* GT 0  - Test flag is forced off
*    9  - Use system RTN & LBL flag
*    1  - Display message (no pause)
*    2  - Display message and pause for val#
*    3  - Input a <cr> after msg display
*    4  - Full test control (3,5,6,7)
*    5  - Display id's (5,6,7)
*    6  - Display run stats (6,7)
*    7  - Display run progress only
*    8  - Do not write
*
!
*
* Statement label to be used:     LOAD.TST: *
*
* REQUIRES: 
*
*   TST$AM
*   TST$VM
*
!
*
~SYS.INCL.LOCK.ITEM~
*CODE.SEGMENT: SYS.INCL.LOCK.ITEM
*
IF NOT(STAT) AND LCK.ITM THEN
LOOP
LCK.STAT = LCK.TYPE
CALL LOCK.ITEM(COM.FILE,LCK.FILE.ID,LCK.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN STAT = LCK.STAT
WHILE NOT(STAT) AND LCK.STAT DO REPEAT
END
*
~SYS.INCL.LOG.ENTRY~
*CODE.SEGMENT: SYS.INCL.LOG.ENTRY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: 25 JAN 90
*
* (c) Copyright 1990
* MACROSCOPE DESIGN MATRIX
*
*# Load the error log record
EL.ID = "TRANSFER.LOG":EL.PREFIX
IF EL.CN THEN
TMP = (100000+EL.CN)[2,5]
EL.ID = EL.ID:"@":TMP
END
READ EL FROM PAR.FILE,EL.ID THEN EL.FOUND = TRUE ELSE EL.FOUND = FALSE; EL = ""
*
IF LEN(EL) + LEN(EL.DATA) GE 2000 THEN
EL.CN = EL.CN + 1
FKEY.ID = "TRANSFER.LOG.CN":EL.PREFIX
WRITE EL.CN ON PAR.FILE,FKEY.ID
*
EL.ID = "TRANSFER.LOG":EL.PREFIX
TMP = (100000+EL.CN)[2,5]
EL.ID = EL.ID:"@":TMP
EL = EL.DATA
END ELSE
EL<-ONE> = EL.DATA
END
*
*# Write error log
WRITE EL ON PAR.FILE,EL.ID
*
~SYS.INCL.LPT.CO~
*CODE.SEGMENT: SYS.INCL.LPT.CO
*
*
PRINT FF:TIMEDATE() "L#25":(SPACE(40 - LEN(CO.NAME) / TWO):CO.NAME) "L#80":("Page ":LPT.PG) "R#25"
*
~SYS.INCL.MAIN.RSP~
*CODE.SEGMENT: SYS.INCL.MAIN.RSP
*
*
EQU MAIN.RSP TO "*M*?*TOPIC*TCL*OFF*EXIT*SCHEDULE*"
*#
*#       Clear screen.
PRINT @(0,5):CLS:
*#
*#       Lock User record.
*LOOP
*
~SYS.INCL.MENU.RSP~
*CODE.SEGMENT: SYS.INCL.MENU.RSP
*
*DGH 870624
*DGH 871216
*
EQU MENU.RSP TO "*MKTG*FILES*DICTS*MENUS*LISTS*AXION*DSL*UTILS*UT*PG*ED*M*"
*
*#NU.RSP.SYN TO "*/MKTG*/FILES*/DICTS*/MENUS*/LISTS*/AXION*/DSL*/UTILS*/UTILS*/PG*/SD@CD*/*"
*
*
~SYS.INCL.MENU.RSP.SYNONYM~
*CODE.SEGMENT: SYS.INCL.MENU.RSP
*
*DGH 870624
*DGH 871216
*
******* MENU.RSP TO "*MKTG*FILES*DICTS*MENUS*LISTS*AXION*DSL*UTILS*UT*PG*ED*M*"
*
EQU MENU.RSP.SYN TO "*/MKTG*/FILES*/DICTS*/MENUS*/LISTS*/AXION*/DSL*/UTILS*/UTILS*/PG*/SD@CD*/*"
*
*
~SYS.INCL.OFF.RSP~
*CODE.SEGMENT: SYS.INCL.OFF.RSP
*
*
EQU OFF.RSP TO "*OFF*off*Off*STOP*stop*HALT*halt*Halt*BYE*bye*Bye*LOGOFF*logoff*Logoff*"
*
~SYS.INCL.OPER.LOAD~
*CODE.SEGMENT: SYS.INCL.OPER.LOAD
*
READV OPER FROM PAR.FILE,CALL.ID,8 ELSE NULL
*
~SYS.INCL.PACK.NUMBER~
*CODE.SEGMENT: SYS.INCL.PACK.NUMBER
*
* AUTHOR:            DAVID STERN - AXION
* UPDATED:           DAVID HORSMAN - MACROSCOPE
* DESCRIPTION:       UNPACK A NUMBER IN HEX
*
BEGIN CASE
CASE OPSYS EQ "R"
IF NUM.IN MATCHES "0N" THEN NUM.OUT = ICONV(NUM.IN,"HEX") ELSE
IF NUM.IN MATCHES "'-'0N" THEN NUM.OUT = CHAR(13):ICONV(-NUM.IN,"HEX") ELSE NUM.OUT = EMPTY
END
CASE OPSYS EQ "U"
IF NUM.IN MATCHES "0N" THEN NUM.OUT = ICONV(NUM.IN,"MX") ELSE
IF NUM.IN MATCHES "'-'0N" THEN NUM.OUT = ICONV(NUM.IN,"MX") ELSE NUM.OUT = EMPTY
END
CASE OPSYS EQ "M"
IF NUM.IN MATCHES "0N" THEN NUM.OUT = ICONV(NUM.IN,"MX") ELSE
IF NUM.IN MATCHES "'-'0N" THEN NUM.OUT = CHAR(13):ICONV(-NUM.IN,"MX") ELSE NUM.OUT = EMPTY
END
CASE TRUE; NUM.OUT = EMPTY
END CASE
*
~SYS.INCL.PARSE.LINE~
*CODE.SEGMENT: SYS.INCL.PARSE.LINE
*
EQU EOF TO CHAR(26)
EQU XOF TO CHAR(19)
EQU XON TO CHAR(17)
*
! VERB THEN ELSE TERM
*
* OPEN file.name {THEN statements {END }}ELSE statements {END}
*OPEN_file.var,file.name.string_{
*THEN{_|<rs>}statement{<rs>statements . . .}{_|<rs>END}
*}ELSE{_|<rs>}statement{<rs>statements . . .}{<rs>|<rs>END}
* "@SYS@VERBS"
*
! FUNCTION TERM
* "@SYS@FUNCTIONS"
*
! COND THEN ELSE TERM
*
*IF_condition_THEN{_|<rs>}statement{<rs>statements . . .}{<rs>|<rs>END}{
*{_|_}ELSE{_|<rs>}statement{<rs>statements . . .}{<rs>|<rs>END}}
* "@SYS@CONDITIONS"
*
! LOOP THEN COND THEN
* "@SYS@LOOPS"
*
*
SYS$LN.SEP = ';':AM
SYS$LN.PREFIX.SEP = '!*/\@'
SYS$CLAUSE.SEP = "'":'" ;'
SYS$WORD.SEP = "'":' ,"-.;:'
SYS$REFERENCE.SEP = '(<[,;: '
SYS$REFERENCE.TERM = ',)]>'
* SYS$PERSOR.SEP = ?
* SYS$SYLLABLE.SEP = ?
* "@SYS@FUNCTIONS"
*
TC.CN = ONE; OLD.TC.CN = TC.CN
*
IF TERM.DISP THEN
IF LEN(LINE) GT 77 THEN TMP.DISP = FALSE ELSE
PRINT @(ZERO,19):CLL:
PRINT @(ZERO,20):CLL:
PRINT @(ZERO,21):CLL:" ":LINE "L#77":
PRINT @(ZERO,22):CLL:
TMP.DISP = TRUE
END
END ELSE TMP.DISP = FALSE
*
! LOOP To process words in line
*
LOOP
*
*
! LOOP To get next word
*
LOOP
*
TC = LINE[TC.CN,ONE]
IF TMP.DISP THEN PRINT @(OLD.TC.CN,22):" ":@(TC.CN,22):RVB:"^":RVE:" ":; OLD.TC.CN = TC.CN
*
TC.CONT = TRUE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
IF INDEX(SYS$LN.SEPARTOR,TC,ONE) THEN TC.CONT = FALSE
UNTIL TC.CONT OR TC EQ EMPTY DO TC.CN = TC.CN + ONE REPEAT
*
FIRST = LINE[ONE,TC.CN - ONE]
*
IF TMP.DISP THEN
PRINT @(ZERO,22):RVB:">":STR("-",TC.CN - ONE):"<":RVE:" ":
END
*
IF TMP.DISP THEN
PRINT @(ZERO,20):CLL:RVB:FIRST:RVE:" ":
END
*
~SYS.INCL.PICKTR.COMMANDS~
*CODE.SEGMENT: SYS.INCL.PICKTR.COMMANDS
*CODE.SEGMENT: COMMAND.PROCESS
*
*Subroutine to parse control parameters
*      
COMMAND.SCAN = TRUE
*# Loop to input program control parameters from master computer
LOOP
*      
DEL.CN = ZERO
BLCK.RSP = ITEM<ONE>
*      
IF BLCK.RSP EQ NULL.FLAG THEN
DEL.CN = ONE
END ELSE IF BLCK.RSP[ONE,9] EQ COMMAND THEN
BLCK.RSP = BLCK.RSP[TEN,HI.NUM]; DEL.CN = ONE
IF ITEM<TWO> EQ NULL.FLAG THEN
ITEM<TWO> = EMPTY
IF ITEM<3> EQ NULL.FLAG THEN
ITEM<3> = EMPTY
IF ITEM<4> EQ NULL.FLAG THEN
ITEM<4> = EMPTY
IF ITEM<5> EQ NULL.FLAG THEN
ITEM<5> = EMPTY
END
END
END
END
*
*      
*# Load program control parameters from master computer
*      
IF BLCK.RSP EQ "?INIT" THEN
INIT.FLAG = FALSE
*
END ELSE IF BLCK.RSP EQ "INIT" THEN
DIR.FLAG = EMPTY; IN.FILE.NAME  = EMPTY; OUT.FILE.NAME = EMPTY
IN.ITEM.NAME  = EMPTY; COMM.SYS.NAME = EMPTY
OOUT.ITEM.NAME = EMPTY; OPTIONS = EMPTY; ACCT.NAME = EMPTY
IF NOT(FROM.LIST AND LIST.SOURCE) THEN LIST.NAME = EMPTY; LIST.SOURCE = EMPTY
*      
INIT.FLAG = TRUE; CDIR.FLAG = FALSE; FILE.FLAG = FALSE; ITEM.FLAG = FALSE
OPTN.FLAG = FALSE; LIST.FLAG = FALSE; ACCT.FLAG = FALSE; SYST.FLAG = FALSE
SRCE.FLAG = FALSE
*      
END ELSE IF BLCK.RSP EQ "ITEM.TYPE" THEN
VRF.ITEM.TYPE = ITEM<TWO>; DEL.CN = TWO
IF VRF.ITEM.TYPE NE ITEM.TYPE THEN STAT = 16
*      
END ELSE IF BLCK.RSP EQ "TDIR" THEN
DIR.FLAG = ITEM<TWO>; DEL.CN = TWO
CDIR.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "FNAM" THEN
IN.FILE.NAME = ITEM<TWO>
OUT.FILE.NAME = ITEM<3>; DEL.CN = 3
FILE.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "INAM" THEN
OUT.ITEM.NAME = ITEM<TWO>
IN.ITEM.NAME = ITEM<3>; DEL.CN = 3
ITEM.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "OPTN" THEN
OPTIONS = ITEM<TWO>; DEL.CN = TWO
OPTN.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "SRCE" THEN
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.SOURCE = ITEM<TWO>
DEL.CN = TWO
SRCE.FLAG = TRUE
ITEM.DATE = EMPTY
*
END ELSE IF BLCK.RSP EQ "LIST.CN" THEN
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.CN = ITEM<TWO>
DEL.CN = TWO
*
END ELSE IF BLCK.RSP EQ "ABORT" THEN
ABORT.FLAG = ITEM<TWO>; DEL.CN = TWO
STAT = ABORT.RECVD; *# ABORT RECEIVED
*
END ELSE IF BLCK.RSP EQ "LIST" THEN
DEL.CN = TWO
IF NOT(LIST.SOURCE AND FROM.LIST) THEN
LIST.NAME = ITEM<TWO>
IF NOT(LEN(LIST.NAME)) THEN LIST.FLAG = FALSE; FROM.LIST = FALSE ELSE
LIST.FLAG = TRUE
IF LIST.SOURCE THEN
IF NOT(FROM.LIST) THEN
IF COUNT(LIST.NAME," ") THEN
EXEC.VERB = LIST.NAME
END ELSE IF LIST.NAME EQ "*" OR LIST.NAME EQ "ALL" THEN
EXEC.VERB = "SSELECT ":IN.FILE.NAME
END ELSE
EXEC.VERB = "GET-LIST ":LIST.NAME
END
EXECUTE EXEC.VERB, //OUT. > EXEC.RSP
CP<20> = EXEC.RSP
END
END; *# of list.source
FROM.LIST = TRUE
END; *# of not(from.list)
END; *# of not master or source
*      
END ELSE IF BLCK.RSP EQ "ACCT" THEN
ACCT.NAME = ITEM<TWO>; DEL.CN = TWO
*# IF LEN(ACCT.NAME) AND ACCT.NAME NE ACCT THEN PRINT "???????ACCT??????"; STOP
ACCT.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "SYST" THEN
TMP = ITEM<TWO>; DEL.CN = TWO
COMM.SYS.NAME = FIELD(TMP,"#",1)
DICT.BASE = ZERO; FILE.BASE = ZERO
FILE.OPT = FIELD(TMP,"#",2)
DICT.MOD = FIELD(TMP,"#",3); DICT.SEP = FIELD(TMP,"#",4)
FILE.MOD = FIELD(TMP,"#",5); FILE.SEP = FIELD(TMP,"#",6)
*# IF LEN(SYS.NAME) AND SYS.NAME NE COMM.SYS.NAME THEN PRINT "???????SYS??????"; STOP
SYST.FLAG = TRUE
*      
END ELSE IF BLCK.RSP EQ "TP.MAX" THEN
TP.MAX = ITEM<TWO>; DEL.CN = TWO
*      
END ELSE IF BLCK.RSP EQ "ERR.CN" THEN
ERR.CN = ITEM<TWO>; DEL.CN = TWO
IF MAIN.FLAG EQ SLAVE THEN ERR.CN = ERR.CN + TWO
IF ERR.CN LT ERR.LOW THEN ERR.CN = ERR.LOW
*      
END ELSE IF BLCK.RSP EQ "ERROR" THEN
BLCK.RSP = ITEM<TWO>; DEL.CN = TWO
STAT = 47; *# ERROR RECEIVED
CP<16,-1> = BLCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*      
END ELSE IF BLCK.RSP EQ "DONE" THEN
DONE.FLAG = WORK.DONE
*      
END ELSE IF BLCK.RSP EQ "?INAM" THEN
ITEM.FLAG = FALSE
*      
END ELSE IF BLCK.RSP EQ "END.LIST" THEN
FROM.LIST = FALSE
STAT = LIST.FINISHED
*      
END ELSE IF BLCK.RSP EQ "KILL" OR BLCK.RSP EQ "OFF" OR BLCK.RSP EQ "TCL" OR BLCK.RSP[ONE,5] EQ "ERROR" OR BLCK.RSP[ONE,ONE] EQ "?" THEN
STAT = ABORT.RECVD; *# KILL/OFF/TCL/ERROR RECEIVED
CP<16,-1> = BLCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*
END ELSE
ERR.CN.ALL = ERR.CN.ALL + ONE
END; *# of valid commands
*
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE
*      
END ELSE
IF BLCK.RSP EQ "KILL" OR BLCK.RSP EQ "OFF" OR BLCK.RSP EQ "TCL" THEN
*# Block is a user command
*      
IF MAIN.FLAG NE MASTER THEN STAT = 37 ; *# Terminal entered KILL,OFF,TCL command
*      
END
*# Block is not a command
* ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
IF NOT(CNTR.FLAG) THEN COMMAND.SCAN = FALSE ELSE DEL.CN = ONE
*      
END; *# of block not command
*      
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERROR.ABORT
*      
LOOP WHILE DEL.CN DO DEL ITEM<ONE,ZERO,ZERO>; DEL.CN = DEL.CN - ONE REPEAT
WHILE LEN(ITEM) AND COMMAND.SCAN DO REPEAT
*      
~SYS.INCL.PICKTR.DETAIL~
*CODE.SEGMENT: SYS.INCL.PICKTR.DETAIL
*      
*#  MAIN.FLAG EQ ENTRY
IF MAIN.FLAG EQ ENTRY THEN
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
PRINT
PRINT
PRINT "Enter item name: ":
LOOP
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "LIST" OR RSP EQ "*" OR RSP EQ "ALL" THEN
PRINT
PRINT "Enter list name: ":
IF RSP EQ "*" OR RSP EQ "ALL" THEN LIST.NAME = "*" ELSE INPUT LIST.NAME
LOOP TC = LIST.NAME[ONE,ONE] WHILE LEN(LIST.NAME) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO LIST.NAME = LIST.NAME[TWO,HI.NUM] REPEAT
IF LIST.NAME EQ "KILL" THEN ABORT
IF LIST.NAME EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF LIST.NAME[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
PRINT
PRINT "On this system (Y/N)? ":
INPUT YES.NO
IF YES.NO[ONE,ONE] EQ "Y" OR YES.NO[ONE,ONE] EQ "y" OR YES.NO = EMPTY THEN LIST.SOURCE = TRUE ELSE LIST.SOURCE = FALSE
END ELSE
LIST.SOURCE = EMPTY; LIST.NAME = EMPTY
END
WHILE NOT(DONE.FLAG) AND NOT(LEN(RSP)) OR SYSTEM(ELEVEN) GT 3 DO REPEAT
*
IN.ITEM.NAME = RSP
PRINT
*
IF NOT(DONE.FLAG OR LEN(LIST.NAME) OR STAT) THEN
PRINT "Enter output item name (":IN.ITEM.NAME:"): ":
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = IN.ITEM.NAME ELSE OUT.FILE.NAME = EMPTY
*
IF OUT.FILE.NAME NE IN.FILE.NAME THEN
IF NOT(LEN(OUT.FILE.NAME)) THEN OUT.FILE.NAME = IN.FILE.NAME
PRINT
PRINT "Enter output file name (":OUT.FILE.NAME:"): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = OUT.FILE.NAME
* OUT.FILE.NAME = IN.FILE.NAME
END
OUT.ITEM.NAME = RSP
END; *# of not done
*
MAX = 0
ISIZE = 0
*      
END; *# of MAIN.FLAG EQ ENTRY
*      
~SYS.INCL.PICKTR.EQU~
*CODE.SEGMENT: SYS.INCL.PICKTR.EQU
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
ERR.VRF.ARRAY<3> = "RECVD":VM:"STAT":VM:"CHK.SUM.BAD":VM:"CHK.ID":VM:"NON.PACKET":VM:"CHK.SUM":VM:"KEYBOARD.ABORT":VM:"PREV.CHK.ID":VM:"END":VM:"ABORT":VM:"CHOKE":VM:"HEX.ON":VM:"13":VM:"MAX.ERR.ABORT":VM:"SLEEP":VM:"PAUSE"
ERR.VRF.ARRAY<5> = 1:VM:2:VM:0:VM:0:VM:0:VM:0:VM:0:VM:0:VM:9:VM:10:VM:11:VM:12:VM:0:VM:14:VM:15:VM:16
*      
*# Equates Area
*
*# Miscellaneous
EQU ZERO            TO 0
EQU ONE             TO 1
EQU TWO             TO 2
EQU TEN             TO 10
EQU ELEVEN          TO 11
EQU HI.NUM          TO 99999
EQU NULL.FLAG       TO "@}n"
EQU COMMAND         TO "@}c"
EQU PERR.MESSAGE    TO "@}e"
EQU CONT.MESSAGE    TO "@}+"
*
EQU EMPTY TO ""
*
*# Equates for DONE.FLAG
EQU SCAN.FOR.WORK   TO 1;   *# DONE.FLAG
EQU SHUTDOWN.DONE   TO 9;   *# DONE.FLAG
EQU ABORT.PRESENT   TO 16;  *# DONE.FLAG
*QU ABORT.VRF     TO 17;  *# DONE.FLAG
EQU UNAVAIL.SCHED   TO 18;  *# DONE.FLAG
EQU NO.WORK         TO 19;  *# DONE.FLAG
EQU WORK.DONE       TO 59;  *# DONE.FLAG
EQU ENTRY.DONE      TO 39;  *# DONE.FLAG
*QU ABORT.COMMAND   TO 117; *# DONE.FLAG
*
*# Equates for STAT
*
*# Error message verification & counting
EQU RECVD.VRF            TO 1; *# STAT
EQU STAT.VRF             TO 2; *# STAT
EQU CHK.SUM.BAD.VRF      TO 3; *# STAT
EQU CHK.ID.VRF           TO 4; *# STAT
EQU NON.PACKET.VRF       TO 5; *# STAT
EQU CHK.SUM.VRF          TO 6; *# STAT
EQU KEYBOARD.ABORT.VRF   TO 7; *# STAT
EQU PREV.CHK.ID.VRF      TO 8; *# STAT
EQU END.VRF              TO 9; *# STAT
EQU ABORT.VRF            TO 10; *# STAT
EQU CHOKE.VRF            TO 11; *# STAT
EQU HEX.FLAG.VRF         TO 12; *# STAT
*13
EQU MAX.ERR.ABORT.VRF    TO 14; *# STAT
EQU SLEEP.VRF            TO 15; *# STAT
EQU PAUSE.VRF            TO 16; *# STAT
*
*# Resource control parameters
EQU ITEM.TYPE.ERROR      TO 17;  *# STAT
EQU UNAVAIL.SCHED.STAT   TO 18;  *# STAT
EQU LIST.FINISHED        TO 19;  *# STAT
EQU FILE.MISSING         TO 20;  *# STAT
EQU ITEM.OV.ERROR        TO 21;  *# STAT
EQU ITEM.NEW.ERROR       TO 22;  *# STAT
EQU ITEM.OV.RQRD.ERROR   TO 23;  *# STAT
EQU FPOINTER.OV.ERROR    TO 24;  *# STAT
EQU FPOINTER.TR.ERROR    TO 25;  *# STAT
EQU ITEM.MISSING         TO 26;  *# STAT
EQU MAX.ITEM.SIZE        TO 29;  *# STAT
EQU WAIT.ERROR           TO 30;  *# STAT
EQU LOGOFF.COMMAND       TO 31;  *# STAT
EQU COMM.ERROR.STAT      TO 32;  *# STAT
EQU LINE.HUNG            TO 33;  *# STAT
*
*
*# Main program control
EQU MASTER         TO "MASTER"
EQU SLAVE          TO "SLAVE"
EQU ENTRY          TO "ENTER"
EQU DIN            TO "IN"
EQU DOUT           TO "OUT"
*
EQU CP TO COMM.PARAM 
EQU TP TO TRANS.PARAM
*
~SYS.INCL.PICKTR.HEADER~
*CODE.SEGMENT: SYS.INCL.PICKTR.HEADER
*
* DAVID HORSMAN 03 OCT 89
*
FILE.OPT = "MC,S,?,QC"
IF MAIN.FLAG = MASTER  THEN
PRINT
END ELSE
*      
*#  MAIN.FLAG = SLAVE OR ENTRY
PRINT
PRINT
PRINT "Enter direction of tranfer (OUT)":
INPUT RSP
*      
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
* MAIN.FLAG = ENTRY
*      
IF RSP EQ "" THEN RSP =  DOUT
IF RSP NE DIN AND RSP NE DOUT THEN RSP = DOUT
DIR.FLAG = RSP
*      
PRINT
PRINT
PRINT "Enter the system name (UNKNOWN)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "UNKNOWN"
COMM.SYS.NAME = RSP
*      
PRINT
PRINT
PRINT "Enter the account name (SYSPROG)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "SYSPROG"
ACCT.NAME = RSP
*      
PRINT "Enter the account password (PUBLIC)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "PUBLIC"
ACCT.PASS = RSP
*      
PRINT
PRINT
PRINT "Enter input file name (BP)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "BP"
IN.FILE.NAME = RSP
*      
PRINT
PRINT
PRINT "Enter output file name (BP): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "BP"
OUT.FILE.NAME = RSP
*      
LOOP
CONT = FALSE
PRINT
PRINT
PRINT "Enter options (O): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "O"
CN = ZERO
OPTIONS = EMPTY
LOOP
CN = CN + ONE
TC = RSP[CN,ONE]
WHILE TC NE EMPTY DO
IF NOT(INDEX("OAEN",TC,ONE)) THEN CONT = TRUE ELSE OPTIONS = OPTIONS:TC
*# O OVERWRITE
*# A APPEND
*# E EXISTS ON FILE
*# N NON-EXISTANT ONLY
*      
REPEAT
*
WHILE CONT DO REPEAT
*
LOOP
CONT = FALSE
PRINT
PRINT
PRINT "Enter the file creation options (MD,S,?,QC): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" AND TC NE "," DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "MC,S,?,QC"
CN = ZERO
FILE.OPT = EMPTY
CNMAX = COUNT(RSP,",") + ONE
LOOP
CN = CN + ONE
TC = FIELD(RSP,",",CN)
WHILE CN LE CNMAX DO
IF NOT(INDEX("FC,DC,DAC,MC,S,?,QC",TC,ONE)) THEN CONT = TRUE ELSE
IF LEN(TC) THEN
IF LEN(FILE.OPT) THEN FILE.OPT = FILE.OPT:","
FILE.OPT = FILE.OPT:TC
END
END
*# FC File creation (dict and/or data) OK
*# DC Dict creation OK
*# DAC Data area creation OK
*# MC MD Q-pointer create OK
*# S Search for the file as far as is possible
*# ? Asking the user questions is OK
*# QC Q-pointer for file is OK to create
*      
REPEAT
*
WHILE CONT DO REPEAT
*
IF DIR.FLAG EQ DIN THEN
CFILE.NAME = OUT.FILE.NAME
END ELSE CFILE.NAME = IN.FILE.NAME
*
MD.FILE.NAME = "MD"; DICT.NAME = CFILE.NAME; DICT.BASE = FALSE; DICT.MOD = FALSE; DICT.SEP = FALSE; FILE.MOD = FALSE; FILE.SEP = FALSE; FILE.NAME = CFILE.NAME; FILE.BASE = FALSE; STAT = FALSE; PROG.DEBUG = FALSE
*
CALL SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,FILE.OPT,FILE.NAME,FILE.BASE,STAT,PROG.DEBUG)
*
*PRINT BELL:; INPUT POOP
*
END; *# of SLAVE OR ENTRY
*      
~SYS.INCL.PICKTR.JOB.LOAD~
*CODE.SEGMENT: SYS.INCL.PICKTR.JOB.LOAD
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 17 FEB 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
TP<TP.CN+ONE,ONE> =  IN.FILE.NAME
TP<TP.CN+ONE,TWO> = OUT.FILE.NAME
TP<TP.CN+ONE,3> =  IN.ITEM.NAME
TP<TP.CN+ONE,4> = OUT.ITEM.NAME
TP<TP.CN+ONE,5> =       OPTIONS
TP<TP.CN+ONE,6> =      DIR.FLAG
TP<TP.CN+ONE,7> =     LIST.NAME
TP<TP.CN+ONE,8,ONE> = ACCT.NAME
TP<TP.CN+ONE,8,TWO> = ACCT.PASS
TP<TP.CN+ONE,9,ONE> = COMM.SYS.NAME
TP<TP.CN+ONE,9,TWO> = FILE.OPT
TP<TP.CN+ONE,9,3>   = DICT.MOD
TP<TP.CN+ONE,9,4>   = DICT.SEP
TP<TP.CN+ONE,9,5>   = FILE.MOD
TP<TP.CN+ONE,9,6>   = FILE.SEP
TP<TP.CN+ONE,TEN> =  LIST.SOURCE
IF MAIN.FLAG EQ ENTRY THEN
TP<TP.CN+ONE,ELEVEN> = EMPTY
TP<TP.CN+ONE,12> = ZERO
END
*
~SYS.INCL.PRINT.INIT~
*CODE.SEGMENT: SYS.INCL.PRINT.INIT 
*
TMP = "LP":AM:"PKH":AM:"AUX":AM:"TERM"
LOOP
PRINT
PRINT "ENTER PRINTER DEVICE (LP,PKH,AUX,TERM): ":
INPUT RSP
LOCATE RSP IN TMP SETTING PRINTER.FLAG ELSE PRINTER.FLAG = ZERO
WHILE NOT(PRINTER.FLAG) DO PRINT BELL: REPEAT
~SYS.INCL.PRINT.OFF~
*CODE.SEGMENT: SYS.INCL.PRINT.OFF 
*
BEGIN CASE
CASE PRINTER.FLAG EQ ONE
PRINTER OFF
CASE PRINTER.FLAG EQ TWO
PRINT CAPT.PRNT.OFF:
CASE PRINTER.FLAG EQ 3
PRINT AUX.OFF:
CASE TRUE
END CASE
~SYS.INCL.PRINT.ON~
*CODE.SEGMENT: SYS.INCL.PRINT.ON 
*
BEGIN CASE
CASE PRINTER.FLAG EQ ONE
PRINTER ON
CASE PRINTER.FLAG EQ TWO
PRINT CAPT.PRNT.ON:
CASE PRINTER.FLAG EQ 3
PRINT AUX.ON:
CASE TRUE
END CASE
~SYS.INCL.QUIET.LOAD~
*CODE.SEGMENT: SYS.INCL.QUIET.LOAD
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
LINE.MAX.LEN = CP<TWO>
IF NOT(LINE.MAX.LEN) THEN LINE.MAX.LEN = 70
*# Maximum # of err's for this run
ERR.MAX.ALL = CP<3>
IF NOT(ERR.MAX.ALL) THEN ERR.MAX.ALL = 1000
*# Maximum # of err - floating speed regulator
ERR.MAX = CP<4>
IF NOT(ERR.MAX) THEN ERR.MAX = 30
*ERR.CN = CP<5>
*IF NOT(NUM(ERR.CN)) THEN ERR.CN = ZERO
*IF NOT(ERR.CN) THEN ERR.CN = 3
*LOOP WHILE ERR.CN GE ERR.MAX AND ERR.CN GT TEN DO ERR.CN = ERR.CN - TEN REPEAT
COMM.WAIT.MAX = CP<6>
IF NOT(COMM.WAIT.MAX) THEN COMM.WAIT.MAX = 300
COMM.WAIT.PAUSE = CP<7>
IF NOT(COMM.WAIT.PAUSE) THEN COMM.WAIT.PAUSE = ONE
COMM.WAIT.CLEAR = CP<8>
IF NOT(COMM.WAIT.CLEAR) THEN COMM.WAIT.CLEAR = 75
*ERR.CN.ALL = CP<9>
*ERR.CN.ALL = ZERO
*ERR.CN.TOTAL = CP<TEN>
*IF NOT(NUM(ERR.CN.TOTAL)) THEN ERR.CN.TOTAL = ZERO
*IF NOT(NUM(ERR.CN.ALL)) THEN ERR.CN.ALL = ZERO
COMM.SYNC = CP<ELEVEN>
IF NOT(NUM(COMM.SYNC)) THEN COMM.SYNC = EMPTY
COMM.WAIT.QUIET = CP<ONE>
*ERR.CN.ARRAY = CP<17>
AM.MAX = CP<18>
IF AM.MAX LE 5 THEN AM.MAX = 100
ERR.LOW = CP<19,ONE>; ERR.OUT.OFFSET = CP<19,TWO>; ERR.IN.OFFSET = CP<19,3>; ERR.CHOKE = CP<19,4>; ERR.HI = CP<19,5>
*IF ERR.CN LT ERR.LOW THEN ERR.CN = ERR.LOW
*      
~SYS.INCL.QUIET.WRITE~
*CODE.SEGMENT: SYS.INCL.QUIET.WRITE
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
READ COMM.PARAM FROM PAR.FILE,"TRANSFER.QUIET":PORT ELSE
READ COMM.PARAM FROM PAR.FILE,"TRANSFER.QUIET" ELSE
CP = ""
END
END
CP<5> = ERR.CN
CP<9> = ERR.CN.ALL
CP<10> = ERR.CN.TOTAL + ERR.CN.ALL
CP<12,1,1> = DATE()
CP<12,1,2> = TIME()
CP<12,1,3> = WHO
* :COMM.ERROR:SVM
CP<12,1,5> = STAT
* :TRANS.CN:SVM:TRANS.MAX:SVM:DONE.FLAG:SVM:COMM.INIT:SVM:COMM.STARTUP:SVM:COMM.SHUTDOWN:SVM:
* ACK.RSP
CP<12,1,12> = ACK.RSP
CP<12,1,13> = LINE.PACKET
CP<17> = ERR.CN.ARRAY
CP<28> = ERR.LEVEL
IF LEN(CP) GT 10000 THEN CP = CP[1,7000]
ERR.LOW = CP<19,ONE>; ERR.OUT.OFFSET = CP<19,TWO>; ERR.IN.OFFSET = CP<19,3>; ERR.CHOKE = CP<19,4>; ERR.HI = CP<19,5>
WRITE COMM.PARAM ON PAR.FILE,"TRANSFER.QUIET":PORT
* IF STAT  AND NOT(ERR.SENT AND ERR.RECVD) THEN
* PRINTER ON
* PRINT FF:
* PRINT OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS"):" ":WHO
* TMP = DCOUNT(COMM.PARAM,AM)
* FOR TMP1 = ONE TO TMP
* PRINT COMM.PARAM<TMP1>
* NEXT TMP1
* PRINT "ERR.CN ":ERR.CN
* PRINT "  STAT ":STAT
* PRINT "    CN ":CN
* PRINT "   MAX ":MAX
* PRINT
* PRINT "  ITEM ":ITEM<ONE>
* PRINT "  LINE ":LINE
* PRINT FF:
* PRINTER OFF
* PRINTER CLOSE
* END
*
~SYS.INCL.RECORD.TIME~
*CODE.SEGMENT: SYS.INCL.RECORD.TIME
*# 870630 DGH
RECORD.TIME: * to record time usage
*
IF CHECK.TIME AND INDEX(SYS.PROG,"SYS.TIME",1) # 0 THEN RETURN
IF CHECK.TIME < 3 OR CHECK.TIME > 7 THEN
IF EQ.PROG.TYPE > 1 THEN CHECK.TIME = 1 ELSE CHECK.TIME = 9
END
CALL SYS.TIME
*END
*
RETURN
*
~SYS.INCL.RECORD.USER.CALL~
*CODE.SEGMENT: SYS.INCL.RECORD.USER.CALL
* 870630 DGH
!
RECORD.USER.CALL: *Subroutine to update user info
*
SYS.SLOC<1> = "RECORD.USER.CALL"
IF CALL.FUNCTION<1> # "LOGON" AND CALL.FUNCTION<1> # "LOGOFF" AND CALL.FUNCTION<1> # "MENU" THEN CALL.FUNCTION<1> = "UNKNOWN"
IF CALL.SUB.FUNCTION<1> # "UPDATE" AND CALL.SUB.FUNCTION<1> # "READ" THEN
IF CALL.SUB.FUNCTION<1> # "WRITE" AND CALL.SUB.FUNCTION<1> # "RESET" THEN RETURN
END
LOOP
SYS.FILE = "SYS"
IF STRUCT(2) # "" THEN USER.NAME = STRUCT(2)
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
WHILE (USER.LOCKED AND USER.LOCKED # PORT+1) AND NOT(USER.ABORT) DO REPEAT
*
RETURN
!
RECORD.LOCATION: * to record you menu location AND topics
USER.UPD(2) = 1
TEMP = (100000+DATE())[2,5]
TEMP = TEMP:(100000+TIME())[2,5]
IF TEMP > LAST.LOCT + (STRUCT(48) * 5) OR INDEX(SYS.RSP,"*":PRMPTING:"*",1) # 0 THEN
CALL.FUNCTION<1> = "MENU"
CALL.SUB.FUNCTION<1> = "UPDATE"
GOSUB RECORD.USER.CALL
LAST.LOCT = TEMP
END ELSE
STRUCT(29)<1,PORT + 1> = USER.CO.CODE
STRUCT(30)<1,PORT + 1> = MENU.APPL:SVM:MENU.SUB.APPL:SVM:MENU.GRP.APPL
STRUCT(31)<1,PORT + 1> = MENU.CONTROL<1,7>
STRUCT(32)<1,PORT + 1> = MENU.NAME
STRUCT(33)<1,PORT + 1> = PRMPTING
STRUCT(34)<1,PORT + 1> = TOPIC.KEY
STRUCT(35)<1,PORT + 1> = MENU.CONTROL<1,9>
END
*
RETURN
*
*
~SYS.INCL.REMOVE.AM~
*CODE.SEGMENT: SYS.INCL.REMOVE.AM
*
*
AM.CN = ONE
LOOP
AM.LOC = INDEX(LINE,CHAR(254),ONE)
WHILE AM.LOC DO
LINE = LINE[ONE,AM.LOC - ONE]:'":AM:"':LINE[AM.LOC + ONE,99999]
IF TF THEN PRINT @(50,23):'AM ':AM.CN:; * RQM
AM.CN = AM.CN + ONE
REPEAT
*
~SYS.INCL.REMOVE.ESC~
*CODE.SEGMENT: SYS.INCL.REMOVE.ESC
*
*
ESC.CN = ONE
LOOP
ESC.LOC = INDEX(LNS,CHAR(27),ONE)
WHILE ESC.LOC DO
AM.LOC = DCOUNT(LNS[1,ESC.LOC],CHAR(254))
LINE = LNS<AM.LOC>
LOOP
ESC.LOC = INDEX(LINE,CHAR(27),ONE)
WHILE ESC.LOC DO
LINE = LINE[ONE,ESC.LOC - ONE]:'":ESC:"':LINE[ESC.LOC + ONE,99999]
IF TF THEN PRINT @(40,23):'ESC ':ESC.CN:; * RQM
ESC.CN = ESC.CN + ONE 
REPEAT
LNS<AM.LOC> = LINE
REPEAT
*
~SYS.INCL.REMOVE.SVM~
*CODE.SEGMENT: SYS.INCL.REMOVE.SVM
*
*
SVM.CN = ONE
LOOP
SVM.LOC = INDEX(LNS,CHAR(252),ONE)
WHILE SVM.LOC DO
AM.LOC = DCOUNT(LNS[1,SVM.LOC],CHAR(254))
LINE = LNS<AM.LOC>
LOOP
SVM.LOC = INDEX(LINE,CHAR(252),ONE)
WHILE SVM.LOC DO
LINE = LINE[ONE,SVM.LOC - ONE]:'":SVM:"':LINE[SVM.LOC + ONE,99999]
IF TF THEN PRINT @(40,23):'SVM ':SVM.CN:; * RQM
SVM.CN = SVM.CN + ONE 
REPEAT
LNS<AM.LOC> = LINE
REPEAT
*
~SYS.INCL.REMOVE.VM~
*CODE.SEGMENT: SYS.INCL.REMOVE.VM
*
*
VM.CN = ONE
LOOP
VM.LOC = INDEX(LNS,CHAR(253),ONE)
WHILE VM.LOC DO
AM.LOC = DCOUNT(LNS[ONE,VM.LOC],CHAR(254))
LINE = LNS<AM.LOC>
LOOP
VM.LOC = INDEX(LINE,CHAR(253),ONE)
WHILE VM.LOC DO
LINE = LINE[ONE,VM.LOC - ONE]:'":VM:"':LINE[VM.LOC + ONE,99999]
IF TF THEN PRINT @(40,23):'VM ':VM.CN:; * RQM
VM.CN = VM.CN + ONE 
REPEAT
LNS<AM.LOC> = LINE
REPEAT
*
~SYS.INCL.RLS.ITM~
*CODE.SEGMENT: SYS.INCL.RLS.ITM
*
IF LCK.ITM THEN
CALL SYS.ITM.RLS(LCK.FIL.ID,LCK.ITM.ID,LCK.FILE,LCK.ID,LCK,LCK.TMP,"1",SYS.PROG,"0",OPER,EXP.LCK.TM,SYS.LOCT,"A","",LCK.STAT)
END
*
~SYS.INCL.RSP.KEY~
*CODE.SEGMENT: SYS.INCL.RSP.KEY 
*#
*# Subroutine to load slave key
*#
*# Variables: EQIOW      Rsp write slave output flag
*#            S27        Rsp mode (last char STRUCT(27)<1,PORT+1>)
*#            ESP        Rsp mode suffix
*#
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@RSP-STACK@"
*#
IF EQIOW THEN
SYS.ITEM = SYS.ITEM:"SLAVE@"
SYS.ITEM = SYS.ITEM:ESP
END ELSE
IF STRUCT(27)<1,PORT+1> LT 11 THEN
SYS.ITEM = SYS.ITEM:"SLAVE@"
END ELSE
SYS.ITEM = SYS.ITEM:"LAST@"
END
IF S27 EQ 4 THEN SYS.ITEM = SYS.ITEM:"QUE" ELSE
SYS.ITEM = SYS.ITEM:STR("0",2-LEN(PORT)):PORT
END
END
*#
~SYS.INCL.RUN.DISP.END~
*CODE.SEGMENT: SYS.INCL.RUN.DISP.END
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    26 NOV 91
*
IF NOT(SNGL) AND NOT(PHANTOM.RUN) THEN
IF NOT(T.CN) THEN T.CN = C.CN
IF CNT.TST$LBL THEN
PRINT CLB0:"Counts - Examined: ":C.CN "L#5":"  Skipped: ":S.CN "L#5":"  Updated: ":U.CN "L#5":
IF P.CN THEN PRINT "  Semi-updated: ":P.CN "L#5":
PRINT CLB1:"Total: ":RSTAT.MISC2 "L#8":"  Total time: ":OCONV(RSTAT.ELP,"MTS") "L#8":"  Update time: ":OCONV(U.TM,"MTS") "L#8":
IF P.CN THEN PRINT "  Semi-updated: ":P.CN "L#5":
IF CNT.TST$CR THEN PRINT " <cr>":; INPUT TMP:
END; * of CNT.TST$LBL
END; * of not sngl
*
~SYS.INCL.RUN.DISP.ID~
*CODE.SEGMENT: SYS.INCL.RUN.INS
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    25 NOV 91
*
IF NOT(SNGL) AND NOT(PHANTOM.RUN) THEN
B.CN = B.CN + ONE
IF CNT.TST$LBL OR B.CN GE D.CN THEN
B.CN = ZERO
IF U.CN NE ZERO THEN
U.TM.AVG = INT((U.TM / U.CN) * 100) / 100
END ELSE U.TM.AVG = EMPTY
C.ELP = ((DATE() - START.DT) * 86400) + (TIME() - START.TM)
C.TM.AVG = INT((C.ELP / C.CN) * 100) / 100
PRINT CLB0:"Times - Avg.: ":C.TM.AVG "L#5":"  Avg.Update: ":U.TM.AVG "L#5":"  Total: ":OCONV(C.ELP,"MTS"):  "  Last ID: ":ID "L#10":
PRINT CLB1:"Counts - Examined: ":C.CN "L#5":"  Skipped: ":S.CN "L#5":"  Updated: ":U.CN "L#5":
IF P.CN THEN PRINT "  Semi-updated: ":P.CN "L#5":
IF CNT.TST$CR THEN PRINT BELL:" <cr>":; INPUT TMP:
END; * of CNT.TST$LBL
END; * of not sngl
*
~SYS.INCL.RUN.ELP~
*CODE.SEGMENT: SYS.INCL.RUN.ELP
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
END.DT = DATE(); END.TM = TIME()
RSTAT.ELP = ((START.DT - END.DT) * 86400) + (END.TM - START.TM)
*
~SYS.INCL.RUN.INIT~
*CODE.SEGMENT: SYS.INCL.RUN.INIT
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
START.DT = DATE(); START.TM = TIME(); END.DT = START.DT; END.TM = START.TM
*
MATREAD CNT.RSTAT FROM CNT.FILE,RSTAT.ID ELSE
* RSTAT.ID = "SYSTEM.RUNS"
MATREAD CNT.RSTAT FROM CNT.FILE,"SYSTEM.RUNS" ELSE
MAT CNT.RSTAT = EMPTY
CNT.RSTAT$CN.MAX = 100
END
END
RSTAT.MAX = CNT.RSTAT$CN.MAX
IF NOT(CNT.RSTAT$LH) THEN CNT.RSTAT$LH = 50
D.CN = 100 / CNT.RSTAT$LH
IF CNT.RSTAT$PERCENT GT D.CN THEN D.CN = CNT.RSTAT$PERCENT
IF T.CN THEN D.CN = INT(T.CN * D.CN / 100) ELSE D.CN = CNT.RSTAT$UNITS
IF NOT(D.CN) THEN D.CN = ONE
*
C.CN = ZERO; C.TM = ZERO; U.CN = ZERO; U.TM = ZERO
P.CN = ZERO; P.TM = ZERO; S.CN = ZERO; S.TM = ZERO
RSTAT.MISC1 = EMPTY; RSTAT.MISC2 = EMPTY
RSTAT.MISC3 = EMPTY; RSTAT.MISC4 = EMPTY
RSTAT.RUN = ONE; RSTAT.ELP = ZERO; B.CN = ZERO; T.CN = ZERO
*
*
~SYS.INCL.RUN.INS~
*CODE.SEGMENT: SYS.INCL.RUN.INS
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    20 NOV 91
*
* CNT.FILE, RSTAT.ID, RSTAT.RUN, RSTAT.MAX, START.DT, START.TM, END.DT, END.TM
* , C.CN, C.TM, U.CN, U.TM, P.CN, P.TM, S.CN, S.TM
* , RSTAT.MISC1, RSTAT.MISC2, RSTAT.MISC3, RSTAT.MISC4
* , CNT.TST$LBL, STAT
* RSTAT.MAX
*
IF CNT.TST$LBL THEN
PRINT CLB:"SYS.INCL.RUN.INS ":
IF CNT.TST$CR THEN PRINT BELL:" <cr>":; INPUT TMP:
END
*
INS RSTAT.RUN  BEFORE CNT.RSTAT$RUN.NO<ONE,ONE>
INS START.DT  BEFORE CNT.RSTAT$DT<ONE,ONE>
INS START.TM  BEFORE CNT.RSTAT$TM<ONE,ONE>
INS END.DT    BEFORE CNT.RSTAT$END.DT<ONE,ONE>
INS END.TM    BEFORE CNT.RSTAT$END.TM<ONE,ONE>
RSTAT.ELP = ((END.DT - START.DT) * 86400) + (END.TM - START.TM)
INS RSTAT.ELP BEFORE CNT.RSTAT$ELP<ONE,ONE>
INS C.CN   BEFORE CNT.RSTAT$CN<ONE,ONE>
INS C.TM   BEFORE CNT.RSTAT$TM<ONE,ONE>
INS U.CN   BEFORE CNT.RSTAT$UPD.CN<ONE,ONE>
INS U.TM   BEFORE CNT.RSTAT$UPD.TM<ONE,ONE>
INS P.CN   BEFORE CNT.RSTAT$PUPD.CN<ONE,ONE>
INS P.TM   BEFORE CNT.RSTAT$PUPD.TM<ONE,ONE>
INS S.CN   BEFORE CNT.RSTAT$SKIP.CN<ONE,ONE>
INS S.TM   BEFORE CNT.RSTAT$SKIP.TM<ONE,ONE>
INS RSTAT.MISC1 BEFORE CNT.RSTAT$MISC1<ONE,ONE>
INS RSTAT.MISC2 BEFORE CNT.RSTAT$MISC2<ONE,ONE>
INS RSTAT.MISC3 BEFORE CNT.RSTAT$MISC3<ONE,ONE>
INS RSTAT.MISC4 BEFORE CNT.RSTAT$MISC4<ONE,ONE>
IF NOT(RSTAT.MAX) THEN RSTAT.MAX = 100
*
LOOP
RSTAT.CN = DCOUNT(CNT.RSTAT$RUN.NO,VM)
WHILE RSTAT.CN GT RSTAT.MAX DO
DEL CNT.RSTAT$RUN.NO<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$DT<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$END.DT<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$END.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$ELP<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$UPD.CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$UPD.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$PUPD.CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$PUPD.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$SKIP.CN<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$SKIP.TM<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC1<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC2<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC3<ONE,RSTAT.MAX + ONE>
DEL CNT.RSTAT$MISC4<ONE,RSTAT.MAX + ONE>
REPEAT
*
*
MATWRITE CNT.RSTAT ON CNT.FILE,RSTAT.ID
*
~SYS.INCL.SCR.CO~
*CODE.SEGMENT: SYS.INCL.SCR.CO
*SCR.CO,CO.NAME,PHAN.RUN
*
*DATE: 24 FEB 93
*
SCR.CO = OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15"
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ZERO):RVB:SCR.CO:RVE:
*
~SYS.INCL.SLEEP.1~
*CODE.SEGMENT: SYS.INCL.SLEEP.1
EXECUTE "SLEEP 1"
*
~SYS.INCL.SLEEP.10~
*CODE.SEGMENT: SYS.INCL.SLEEP.10
EXECUTE "SLEEP 10"
*
~SYS.INCL.SLEEP.3~
*CODE.SEGMENT: SYS.INCL.SLEEP.3
EXECUTE "SLEEP 3"
*
~SYS.INCL.SLEEP.5~
*CODE.SEGMENT: SYS.INCL.SLEEP.5
EXECUTE "SLEEP 5"
*
~SYS.INCL.STAT.LINE~
*CODE.SEGMENT: SYS.INCL.STAT.LINE
*
*
IF USER.MODE GE LO.D.M THEN
ZZTEMP = FIELD(SYS.PROG<1>,".",1)
IF INDEX("*SYS*CODE*SH*EI*","*":ZZTEMP:"*",1) NE 0 THEN
ZZTEMP = SYS.PROG<1>[COL2()+1,999]
END ELSE ZZTEMP = SYS.PROG<1>
PRINT @(0,23):
PRINT CO.DATA<3> "L#6":" ":STRUCT(2) "L#6":" ":
PRINT ZZTEMP "L#6":" ":SYS.LOCT<1> "L#6":" ":SYS.SLOC<1> "L#6":" ":
ZZTEMP = ''
END
*
~SYS.INCL.STATUS.CHECK~
*CODE.SEGMENT: SYS.INCL.STATUS.CHECK
*
EQU STAT.CHECK TO "*O*N*I*C*H*X*L*P*D*A*M*"
*
~SYS.INCL.STATUS.DESC~
*CODE.SEGMENT: SYS.INCL.STATUS.DESC
*
*$INCLUDE DH.IBP SYS.INCL.STATUS.DESC
*
STAT.DESC(1) = "Optional"
STAT.DESC(2) = "Not started"
STAT.DESC(3) = "In progress"
STAT.DESC(4) = "Complete"
STAT.DESC(5) = "Hold for now"
STAT.DESC(6) = "Cancelled"
STAT.DESC(7) = "Loaded"
STAT.DESC(8) = "Purged"
STAT.DESC(9) = "In Daily Schedule"
STAT.DESC(10) = "Add Step"
STAT.DESC(11) = "Modified"
STAT.DESC(12) = "?"
STAT.DESC(13) = "?"
STAT.DESC(14) = "?"
STAT.DESC(15) = "?"
*
~SYS.INCL.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
* ULT ONLY
FOR DELAY.CN = ONE TO DELAY.CN.MAX UNTIL SYSTEM(11)
* FOR DELAY.CN = ONE TO DELAY.CN.MAX; * REV ONLY
BEGIN CASE
CASE OPSYS EQ "U"
RQM
CASE OPSYS EQ "M"
EXECUTE "SLEEP 1"
CASE OPSYS EQ "R"
RQM
CASE TRUE
RQM
END CASE
NEXT DELAY.CN
*
*
~SYS.INCL.STEP.DISPLAY~
*CODE.SEGMENT: SYS.INCL.STEP.DISPLAY
*
SYS.SLOC<1> = "SCHED"
IF TASK.NUM # 0 AND PORTD<5> # "D" THEN
PRINT @(TEMP.CL,TEMP.LN):RVB:"|":RVE:("Task: ":TASK.NUM:" - ":TASK.STEP:" ":STRUCT(62)<1,PORT+1>) "L#48":RVB:"|":RVE:
READV TEMP.DESC FROM PS.FILE,"@J@":CO.DATA<3>:"@":TASK.NUM,1 ELSE
TEMP.DESC = ''
END
PRINT @(TEMP.CL,TEMP.LN+1):RVB:"|":RVE:TEMP.DESC "L#48":RVB:"|":RVE:
PRINT @(TEMP.CL,TEMP.LN+2):RVB:"|":STR("-",48):"|":RVE:
END
TEMP.CL = 0
TEMP.LN = 21
*#
~SYS.INCL.STEP.DISPLAY.ELP~
*CODE.SEGMENT: SYS.INCL.STEP.DISPLAY.ELP
*
SYS.SLOC<1> = "ELP.TIME"
PRINT @(0,5):RVB:"|":RVE:("The elasped time was ":OCONV(ELP.TIME,"MTS")) "L#48":RVB:"|":RVE:
PRINT @(0,6):RVB:"|":RVE:("The key used was ":PSD.KEY) "L#48":RVB:"|":RVE:
PRINT @(0,7):RVB:"|":STR("-",48):"|":RVE:
*
*
~SYS.INCL.SYS.RSP~
*CODE.SEGMENT: SYS.INCL.SYS.RSP
*
*
EQU SYS.RSP TO "*PKH*SCHED*SCHEDULE*MESSAGE*WAIT*FASTER*SLOWER*FAST*SLOW*HELP*"
*
*#.RSP.SYN TO "*PKH*SCHEDULE*SCHEDULE*MESSAGE*WAIT*WAIT*WAIT*WAIT*WA
*
*
* SYS.RSP = "*SCHEDULE*MESSAGE*WAIT*HELP*TIME*WHO*WHERE*STATUS*CONTACTS*TCL*OFF*"
* SYS.RSP = SYS.RSP:"EXPENSES*NOTES*PHONE.BOOK*SHOPPING*ACCOUNTS*USERS*PORTS*UTILITIES*"
~SYS.INCL.SYS.RSP.SYNONYM~
*CODE.SEGMENT: SYS.INCL.SYS.RSP.SYNONYM
*
*
****EQU SYS.RSP TO "*PKH*SCHED*SCHEDULE*MESSAGE*WAIT*FASTER*SLOWER*FAST*SLOW*HELP*"
*
EQU SYS.RSP.SYN TO "*PKH*SCHEDULE*SCHEDULE*MESSAGE*WAIT*WAIT*WAIT*WAIT*WAIT*HELP*"
*
*
~SYS.INCL.TC.INPUT~
*CODE.SEGMENT: SYS.INCL.TC.INPUT
*
*
TC = OCONV(TC,"U51EA")
*
TC = OCONV(TC,'U51EA')
*
~SYS.INCL.TCL.RSP~
*CODE.SEGMENT: SYS.INCL.TCL.RSP
*
*
EQU TCL.RSP TO "*EXIT*EXI*EX*COMMAND*EXIT.MENU*exit.menu*exit*command*"
*#("*":CHAR(6):"*":CHAR(24):"*":CHAR(27):"*":CHAR(251):"*")
*
~SYS.INCL.UNPACK.NUMBER~
*CODE.SEGMENT: SYS.INCL.UNPACK.NUMBER
*
* AUTHOR:            DAVID STERN - AXION
* UPDATED:           DAVID HORSMAN - MACROSCOPE
* DESCRIPTION:       UNPACK A NUMBER IN HEX
*
BEGIN CASE
CASE OPSYS EQ "R"
IF NUM.IN[ONE,ONE] = CHAR(13) THEN NUM.OUT = -OCONV(NUM.IN[TWO,99],"HEX") ELSE NUM.OUT = OCONV(NUM.IN,"HEX")
CASE OPSYS EQ "U"
NUM.OUT = OCONV(NUM.IN,"MX")
IF NUM.OUT[ONE,ONE] = "D" THEN NUM.OUT = -NUM.OUT[TWO,99] ELSE IF NUM.OUT[ONE,TWO] = "0D" THEN NUM.OUT = -NUM.OUT[3,99] ELSE NUM.OUT = NUM.OUT + ZERO
CASE OPSYS EQ "M"
NUM.OUT = OCONV(NUM.IN,"MX")
IF NUM.OUT[ONE,ONE] = "D" THEN NUM.OUT = -NUM.OUT[TWO,99] ELSE IF NUM.OUT[ONE,TWO] = "0D" THEN NUM.OUT = -NUM.OUT[3,99] ELSE NUM.OUT = NUM.OUT + ZERO
CASE TRUE; NUM.OUT = EMPTY
END CASE
*
~SYS.INCL.UPD.AUTO~
*CODE.SEGMENT: SYS.INCL.UPD.AUTO
*
IF NOT(STAT) AND NOT(AUTO.RUN) THEN
CALL AUTO.LOADER(EXEC.VERB,EXEC.IN,EXEC.DESC)
END
*
~SYS.INCL.UPD.STD.DELAY~
*CODE.SEGMENT: SYS.INCL.UPD.STD.DELAY
*
* AUTHOR:  DAVID HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT (C) 1992 MACROSCOPE DESIGN MATRIX
*   ALL RIGHTS RESERVED
*
WRITE DELAY.CN.MAX:AM:DELAY.RESET ON PAR.FILE,"STANDARD.DELAY.CURR"
*
*
~SYS.INCL.UPD.TERM~
*CODE.SEGMENT: SYS.INCL.UPD.TERM
*
*
TERMS = EMPTY
TAUXS = EMPTY
BEGIN CASE
CASE OPSYS EQ "M"
OPEN "DEVICES" TO DEVICE.FILE ELSE STOP
CASE TRUE
OPEN "PAR" TO DEVICE.FILE ELSE STOP
END CASE
*
CN.MAX = DCOUNT(DICT.TERMINAL.FL<ONE>,VM)
*
FOR CN = ONE TO CN.MAX
PORT.NUM = DICT.TERMINAL.FL<ONE,CN>
LOOP WHILE LEN(PORT.NUM) LT 3 DO PORT.NUM = "0":PORT.NUM REPEAT
* TERMINAL TYPE
TERMS<DICT.TERMINAL.FL<ONE,CN> + ONE> = DICT.TERMINAL.FL<TWO,CN>
* PORT LOCATION
BEGIN CASE
CASE OPSYS EQ "M"
READ DEVICE FROM DEVICE.FILE,"PORT*":PORT.NUM ELSE DEVICE = EMPTY
DEVICE<ONE> = DICT.TERMINAL.FL<11,CN>
WRITE DEVICE ON DEVICE.FILE,"PORT*":PORT.NUM
CASE TRUE
READ DEVICE FROM DEVICE.FILE,"MENU.":PORT.NUM ELSE DEVICE = EMPTY
DEVICE<ONE> = DICT.TERMINAL.FL<11,CN>
WRITE DEVICE ON DEVICE.FILE,"MENU.":PORT.NUM
END CASE
* AUX PORT ON / OFF FLAGS
TAUXS<DICT.TERMINAL.FL<ONE,CN> + ONE> = DICT.TERMINAL.FL<TWO,CN>
*
NEXT CN
*
WRITE TERMS ON DICT.TERMINAL.FL.FILE,"TERMINALS"
WRITE TAUXS ON DICT.TERMINAL.FL.FILE,"AUXILARYS"
*
~SYS.INCL.UPDT.ACC~
*CODE.SEGMENT: SYS.INCL.UPDT.ACC
*
* DAVID HORSMAN
*
ACC.REC<ACC.AM.DESC> = ACC.DESC
ACC.REC<ACC.AM.VERB> = ACC.VERB
ACC.REC<ACC.AM.DT>   = ACC.DT
ACC.REC<ACC.AM.TM>   = ACC.TM
WRITE ACC.REC ON ACC.FILE,ACC.ID
*
~SYS.INCL.USER.MODE.DESC~
*CODE.SEGMENT: SYS.INCL.USER.MODE.DESC
*
*$INCLUDE DH.IBP SYS.INCL.USER.MODE.DESC
*
MODE.DESC(1) = "Customer Introduction"
MODE.DESC(2) = "Customer Demonstration"
MODE.DESC(3) = "Trainee Demonstration"
MODE.DESC(4) = "Inexperienced Trainee"
MODE.DESC(5) = "Normal Trainee"
MODE.DESC(6) = "Advanced Trainee"
MODE.DESC(7) = "New Operator"
MODE.DESC(8) = "Normal Operator"
MODE.DESC(9) = "Advanced Operator"
MODE.DESC(10) = "Systems Operator"
MODE.DESC(11) = "Dev - Conceptualization"
MODE.DESC(12) = "Dev - Design"
MODE.DESC(13) = "Dev - Detailed Design"
MODE.DESC(14) = "Dev - Codeing"
MODE.DESC(15) = "Dev - Debugging"
MODE.DESC(16) = "Dev - Testing"
MODE.DESC(17) = "Dev - System Testing"
MODE.DESC(18) = "Release System"
MODE.DESC(19) = "Installation"
MODE.DESC(20) = "Service & Support"
MODE.DESC(21) = "?"
MODE.DESC(22) = "?"
MODE.DESC(23) = "?"
MODE.DESC(24) = "?"
MODE.DESC(25) = "?"
MODE.DESC(26) = "?"
MODE.DESC(27) = "?"
MODE.DESC(28) = "?"
MODE.DESC(29) = "?"
MODE.DESC(30) = "?"
~SYS.INCL.USER.SET~
*CODE.SEGMENT: ?
USER.ID = "USER@":ACCT:"@":PORT; APPL = "PICKTR"
~SYS.INCL.UTILS.RSP~
*CODE.SEGMENT: SYS.INCL.UTILS.RSP
*
*DGH 870625
*
EQU UTILS.RSP TO "*UT*PG*ED*M*"
*
EQU UTILS.RSP.SYN TO "*/UTILS*/PG*/SD@CD*/*"
*
*
~SYS.INPUT.DATE.CODE~
*PROGRAM: SYS.INPUT.DATE.CODE
*
* AUTHOR: DAVID HORSMAN
*
!
*
*$INCLUDE IBP SYS.INPUT.DATE.CODE
*
INPUT.DATE.CODE: * Date to remove from hold and reason code or comments
IF INDEX("*H*X*","*":F.T:"*",1) # 0 THEN
PRINT @(0,21):CLL:@(0,22):CLL:@(0,23):CLL:
ENT.DATE = "0"
IF F.T = "H" THEN
PRINT "Till what date? ":
ENT.DATE = ""
INPUT ENT.DATE:
ENT.DATE = ICONV(ENT.DATE,"D2")
IF LEN(ENT.DATE) = 0 THEN ENT.DATE = "0"
IF ENT.DATE # 0 THEN PRINT @(16):OCONV(ENT.DATE,"D2"):@(28): ELSE PRINT @(16):"on request":@(28):
END
PRINT "Comment: ":
INPUT ENT.CODE:
P.S<CN,DATE.CODE.VM> = ENT.DATE:"*":ENT.CODE:SVM:P.S<CN,DATE.CODE.VM>
END
RETURN
*
~SYS.STANDARD.FUNCTIONS~
*CODE.SEGMENT: SYS.STANDARD.FUNCTIONS
*
* Author: David G. Horsman
*
* Company: Macroscope Design Matrix
*
* (C) 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1992
*
*
EQU BELL TO CHAR(7); EQU LF TO CHAR(10); EQU FF TO CHAR(12)
EQU CR TO CHAR(13); EQU ESC TO CHAR(27)
EQU SVM TO CHAR(252); EQU VM TO CHAR(253); EQU AM TO CHAR(254)
EQU STXC TO CHAR(2); EQU EMPTY TO ""
EQU TRUE TO 1; EQU FALSE TO 0; EQU TWO TO 2; EQU ONE TO 1; EQU ZERO TO 0
*
RSP = EMPTY; RSPBUF = EMPTY
WHO = ICONV(0,"U50BB"); * ULT ONLY
* WHO = ICONV(0,"U50BB"); * MDD ONLY
* WHO = @USER0; * REV ONLY
PORT = (FIELD(WHO," ",ONE)+1000)[TWO,3]; ACCT = FIELD(WHO," ",TWO)
OPSYS = "U"; * ULT ONLY
* OPSYS = "R"; * REV ONLY
* OPSYS = "R"; * MDD ONLY
RUN.TYPE = "S"; PHANTOM.RUN = FALSE
GENERIC = FALSE; * ULT ONLY
* GENERIC = FIELD(@USER0," ",3); * REV ONLY
* GENERIC = FALSE; * MDD ONLY
TT = SYSTEM(7); * ULT ONLY
* TT = EMPTY; * REV ONLY
* TT = SYSTEM(7); * MDD ONLY
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
*
IF GENERIC THEN
CLB = @(ZERO,23); CLB0 = @(ZERO,21); CLB1 = @(ZERO,22); CLB2 = @(ZERO,23)
END ELSE
CLB = @(ZERO,23):CLL; CLB0 = @(ZERO,21):CLL; CLB1 = @(ZERO,22):CLL; CLB2 = @(ZERO,23):CLL
END
*
BEGIN CASE
CASE OPSYS EQ "R"
RVB = CHAR(27):"00"; RVE = CHAR(27):"0A"; RVH = CHAR(27):"01"
AUX.ON = EMPTY; AUX.OFF = EMPTY
CASE TT EQ "D"
RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE TT EQ "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":; * ULT ONLY
CASE TT EQ "U"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
CASE TT EQ "M"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = EMPTY; AUX.OFF = EMPTY
CASE 1
RVB = EMPTY; RVE = EMPTY; RVH = EMPTY; AUX.ON = EMPTY; AUX.OFF = EMPTY
END CASE
*
~SYS.TCL.PTASK~
*CODE.SEGMENT: SYS.TCL.PTASK
*
*
P.TASK: * Print TCL.
*
CPAGETEN = INT( ( L.W - 1) / SCR.LINES ) * SCR.LINES
P.V3 = P.V<1,3>
P.V2 = P.V<1,2>
P.V1 = P.V<1,1>
P.V4 = P.V<1,4>
P.V5 = P.V<1,5>
P.V6 = P.V<1,6>
P.V7 = P.V<1,7>
*
IF OUT.TO.PRINT THEN
PRINTER ON
END ELSE
IF TOP.DISPLAY.FLAG THEN
PRINT @(0,6):CLL:
PR.FL = 0
END ELSE
PRINT @(0,L.W-CPAGETEN+7):CLL:
END
END
*
*
*
*
IF NOT(OUT.TO.PRINT) THEN PRINT @(5):RVB: ELSE PRINT; VRF.EXTRA = VRF.EXTRA + 1
PRINT L.W "R#3":"| ":
*IF PR.FL & NOT(OUT.TO.PRINT) THEN
IF NOT(OUT.TO.PRINT) THEN
PRINT RVE:P.V2 "L#45":"  ":RVB:FIELD(P.V1,"*",1) "L#1":" ":FIELD(P.V3,"*",1) "L#5":" ":FIELD(P.V6,"*",1) "L#5":" ":FIELD(P.V7,"*",1) "L#5":" |":RVE:
END ELSE
PRINT P.V2 "L#45":"  ":FIELD(P.V1,"*",1) "L#1":" ":FIELD(P.V3,"*",1) "L#5":" ":FIELD(P.V6,"*",1) "L#5":" ":FIELD(P.V7,"*",1) "L#5":
END
IF OUT.TO.PRINT THEN
PRINTER OFF
END
RETURN
*
*
~SYS.TCL.UPD~
*CODE.SEGMENT: SYS.TCL.UPD
*
!
UPDATE.FILE: * subroutine to write TCL.STACK or PRESTORE
PRINT @(60,23):"Update.File" "L#18":
IF OLD.CALL.SUB.FUNCTION = "LOGGED" THEN
WRITE P.S ON SY.FILE,"@TCL@STACK@":CO.DATA<3>:"@":STRUCT(2)
END ELSE IF OLD.CALL.SUB.FUNCTION = "PRESTORE" THEN
TEMP.CN = 0
LOOP TEMP.CN = TEMP.CN + 1 WHILE P.S<TEMP.CN> # "" DO
PRESTORE.REC<TEMP.CN+20> = P.S<TEMP.CN>
REPEAT
WRITE PRESTORE.REC ON PS.FILE,"@TCL@":CO.DATA<3>:"@":DISP.PRESTORE
END
*@*UNLOCK
RETURN
!
RECORD.PORT: * to record which task this port is working on
PRINT @(60,23):"Record.Port" "L#18":
IF CALL.SUB.FUNCTION = "LOGGED" THEN
END
RETURN
!
CLEAR.PORT: * to clear this port of current task and step information.
PRINT @(60,23):"Clear.Port" "L#18":
IF CALL.SUB.FUNCTION = "LOGGED" THEN
END
RETURN
!
RECORD.TCL: * to record a change in task or step
PRINT @(60,23):"Record.Tcl" "L#18":
RETURN
!
WAIT.RTN: * Subroutine to modify WAIT.FLAG
PRINT @(60,23):"Wait.Rtn" "L#18":
IF WAIT.TEMP[1,4] = "WAIT" THEN
WAIT.TEMP = FIELD(WAIT.TEMP," ",2)
IF NUM(WAIT.TEMP) THEN
IF WAIT.TEMP < 6 THEN WAIT.FLAG = WAIT.TEMP
END ELSE
IF WAIT.FLAG THEN WAIT.FLAG = 0 ELSE WAIT.FLAG = 1
END
END
RETURN
*
*
~SYS.TEST.FL.LOAD~
*CODE.SEGMENT: SYS.TEST.FL.LOAD
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Testing Design)
*
*   DATE: 14 JAN 88
*
*OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
READ TEST.FL FROM CNT.FILE,"SYSTEM.TEST" THEN
*
END ELSE
*
* 1 Initialization Zones Trace Flag (MV)
* 2 Main Loop Zones
* 2]1 Main Loop Trace Flag
* 2]2 Level Two Trace Flag
* 2]2\1 Level Two, Sub-level One
* 22\2 Level Two, Sub-level Two
* 2]3 Level Three Trace Flag
* 3 List to Use
* 4 Date to Use
* 5 On/Off string
* 6 Termination Zones
*
* NOTE: Comment lines starting with *S> denote internal program structure.
*
TEST.FL = "0":AM:"0":AM:"":AM:DATE():AM:"":AM:"0"
END
*
~SYS.TEST.FL.OPEN~
*CODE.SEGMENT: SYS.TEST.FL.OPEN
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Testing Design)
*
*   DATE: 14 JAN 88
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
*
~SYS.USER.NAME~
*CODE.SEGMENT: SYS.USER.NAME
*
!
*
*
*
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = ""
SYS.ITEM = ""
*
*
SYS.SLOC = "ACC"
OPEN "ACC" TO AC.FILE ELSE
ERROR.TEXT = "no ACC file"
ERROR.CODE = 1
GOSUB ERROR.CONTROL
STOP
END
*
CALL.ID = "MENU.":PORT
READV USER.NAME FROM AC.FILE,CALL.ID,2 ELSE
USER.NAME = "?"
ERROR.TEXT = "I don't know your name"
ERROR.CODE = "19011"
GOSUB ERROR.CONTROL
STOP
END
*
*
*
!
*
~SYSS.DIM~
*CODE.SEGMENT: ?
DIM SYSS(10)
~SYSS.EQUATES~
*CODE.SEGMENT: SYSS.EQUATES
*
* FILE 'CNTR.REC' EQUATES - GENERATED 15:53:29  15 AUG 1984
EQU EI.IA.V.S TO CNTR.REC(1); * VALID STANDARD INFO. AREAS
EQU EI.IA.A TO CNTR.REC(2);     * ADDITIONAL VALID IA'S AND VALID ACTIONS
EQU EI.IA.V.A TO CNTR.REC(3);   * VALID ACTIONS ON STANDARD IA'S
EQU EI.IA.P.S TO CNTR.REC(4);       * INFO-AREA PREFIX/SUFFIX FLAG
EQU EI.U.P.S TO CNTR.REC(5);     * USER FILE/KEY PREFIX/SUFFIX FLAG
EQU EI.V.F TO CNTR.REC(6);      * DATA PROCESSING VERIFICATION ACTION FLAG
EQU EI.A.M TO CNTR.REC(7);      * ENTITY KEY INPUT METHOD FLAG
EQU EI.P.F TO CNTR.REC(8);       * The root of the information file.
EQU EI.S.F TO CNTR.REC(9);     * The name of the secondary info file.
EQU EI.P.C TO CNTR.REC(10);  * A series of commands and screen input.
*
~SYSTEM.TEST~
*CODE.SEGMENT: ?
SYSTEM.TEST: *
*
*
* 'SYS.TST' IN GENERAL.COMMON.AREA SHOULD BE LOADED WHERE APPLICABLE
*
* ATR   PURPOSE
*   1   TESTING ON/OFF
*   2   DISPLAY 'ENTERING' PROGRAM OR CALLED SUBROUTINE
*   3   DISPLAY 'ENTERING' A SUBROUTINE
*   4   1 - DISPLAY ITEM ID BEING PROCESSED
*       2 - DISPLAY ITEM AND MSG IF ERROR/REJECTED, ETC.
*   5   LIST.NAME TO BE PROCESSED
*   6   TEST.DATE TO BE USED (EXTERNAL FORMAT)
*   7   BREAK IS ON
*   8   TIMING DISPLAY IS ON
*   9   PROGRAM SPECIFIC
*  10   PROGRAM SPECIFIC
*  11   PROGRAM SPECIFIC
!
TEST.FL = 0; LIST.NAME = ""; DIS.SUB = 0; DIS.ITEM = 0; DIS.PROG = 0
TIMING = 0; BREAKON = 0; WKO.TEST = 0; PROG.TEST9 = 0; PROG.TEST10 = 0
PROG.TEST11 = 0
IF SYS.TST<1> THEN
TEST.FL =   1
DIS.PROG  = SYS.TST<2>
DIS.SUB   = SYS.TST<3>
DIS.ITEM  = SYS.TST<4>
LIST.NAME = SYS.TST<5>
TIMING    = SYS.TST<6>
BREAKON  = SYS.TST<7>
WKO.TEST  = SYS.TST<8>
PROG.TEST9 = SYS.TST<9>
PROG.TEST10 = SYS.TST<10>
PROG.TEST11 = SYS.TST<11>
END ELSE SYS.TST = ""
!
~TAX.DIM~
DIM TAX(10)
~TAX.EQUATES~
*CODE.SEGMENT: TAX.EQUATES
*
* FILE 'TAX' EQUATES - GENERATED 13:36:21  31 MAR 1993
EQU TAX$DESC TO TAX(1);                 * DESCRIPTION OF TAX
EQU TAX$PRORATE.FLAG TO TAX(2);         * WHETHER TAX IS PRORATED OVER BILLING
EQU TAX$EFF.DATES TO TAX(3);            * EFFECTIVE DATE FOR TAX RATE
EQU TAX$TAX.RATES TO TAX(4);            * PERCENTAGE RATE OF TAX
EQU TAX$RENTAL.AMT.FLAG TO TAX(5);      * WHETHER TAX APPLICABLE ON RENTALS
EQU TAX$SALES.AMT.FLAG TO TAX(6);       * WHETHER TAX APPLICABLE ON SALES
EQU TAX$OTHER.AMT.FLAG TO TAX(7);       * WHETHER TAX APPLICABLE ON OTHER CHARGES
EQU TAX$EXEMPT.RATE.TYPES TO TAX(8);    * LIST OF EXEMPT RATE TYPES (SEP BY ,'S)
EQU TAX$ACCTG.METHOD TO TAX(9);         * A - ACCRUAL, C - CASH
~TAX.VAR.EQUATES~
*CODE.SEGMENT: TAX.VAR.EQUATES
*
* FILE 'TAX' EQUATES - GENERATED 13:36:21  31 MAR 1993
EQU TAX$DESC TO 1;                      * DESCRIPTION OF TAX
EQU TAX$PRORATE.FLAG TO 2;              * WHETHER TAX IS PRORATED OVER BILLING
EQU TAX$EFF.DATES TO 3;                 * EFFECTIVE DATE FOR TAX RATE
EQU TAX$TAX.RATES TO 4;                 * PERCENTAGE RATE OF TAX
EQU TAX$RENTAL.AMT.FLAG TO 5;           * WHETHER TAX APPLICABLE ON RENTALS
EQU TAX$SALES.AMT.FLAG TO 6;            * WHETHER TAX APPLICABLE ON SALES
EQU TAX$OTHER.AMT.FLAG TO 7;            * WHETHER TAX APPLICABLE ON OTHER CHARGES
EQU TAX$EXEMPT.RATE.TYPES TO 8;         * LIST OF EXEMPT RATE TYPES (SEP BY ,'S)
EQU TAX$ACCTG.METHOD TO 9;              * A - ACCRUAL, C - CASH
~TEMP~
*CODE.SEGMENT: ?
~TEMP.ADD.EQUATES~
*FILE 'SAVE.ADD' EQUATES - GENERATED 12:08:58  22 APR 1985
EQU SAVE.ADD$MULT.APT.NUMS TO SAVE.ADD(1);        * STRING OF APT. NOS. AT THIS ADDRESS
EQU SAVE.ADD$ACT.IDS TO SAVE.ADD(2);              * CUSTOMER ACCOUNT NO.
EQU SAVE.ADD$ACT.FROM.DATES TO SAVE.ADD(3);       * ACCOUNT CONNECT DATE
EQU SAVE.ADD$ACT.TO.DATES TO SAVE.ADD(4);         * ACCOUNT DISCONNECT DATE
EQU SAVE.ADD$STAT TO SAVE.ADD(5);                 * ADDRESS SERVICE STATUS
EQU SAVE.ADD$POST.CODE TO SAVE.ADD(6);            * POSTAL/ZIP CODE OF ADDRESS
EQU SAVE.ADD$DWELLING.TYPE TO SAVE.ADD(7);        * TYPE OF DWELLING
EQU SAVE.ADD$DROP.TYPE TO SAVE.ADD(8);            * TYPE OF DROP
EQU SAVE.ADD$HOT.OUTLETS TO SAVE.ADD(9);          * NUMBER OF HOT OUTLETS AT ADDRESS
EQU SAVE.ADD$WIRED.OUTLETS TO SAVE.ADD(10);       * NUMBER OF OUTLETS WIRED AT ADDRESS
EQU SAVE.ADD$TECH.INFO TO SAVE.ADD(11);           * TECHNICAL INFORMATION FOR ADDRESS
EQU SAVE.ADD$GEOGRAPHIC.DATA TO SAVE.ADD(12);     * GEOGRAPHIC DATA
EQU SAVE.ADD$BULK.ACT.ID TO SAVE.ADD(13);         * POINTER TO BULK ACCOUNT
EQU SAVE.ADD$CONF.WO.NUMS TO SAVE.ADD(14);        * CONFIRMED WORK ORDER NO.
EQU SAVE.ADD$WKO.TYPE TO SAVE.ADD(15);            * TYPE OF WORK ORDER
EQU SAVE.ADD$WKO.ACT.ID TO SAVE.ADD(16);          * ACCOUNT TO WHICH WORK ORDER APPLIED
EQU SAVE.ADD$WKO.EFF.DATE TO SAVE.ADD(17);        * EFFECTIVE DATE OF WORK ORDER
EQU SAVE.ADD$WKO.COMPL.DATE TO SAVE.ADD(18);      * COMPLETION DATE OF WORK ORDER
EQU SAVE.ADD$OUTLET.LOCATIONS TO SAVE.ADD(19);    * LOCATION OF OUTLET WITHIN ADDRESS
EQU SAVE.ADD$MESSAGE TO SAVE.ADD(20);             * ADDRESS MESSAGE
EQU SAVE.ADD$DROP TO SAVE.ADD(21);                * DROP NUMBER
EQU SAVE.ADD$MASTER TO SAVE.ADD(22);               * MASTER DROP (FCI)
~TEMP10~
*CODE.SEGMENT: ?
SYS.INCL.CONV.TO.HEX
SYS.INCL.CONV.TO.TXT
SYS.INCL.ACK.OR.SEND
SYS.INCL.PICKTR.HEADER
SYS.INCL.PICKTR.DETAIL
SYS.INCL.PICKTR.COMMANDS
SYS.INCL.PICKTR.EQU
SYS.INCL.PICKTR.JOB.LOAD
SYS.INCL.SCHED.CHECK
SYS.INCL.SCHED.CHECK.READ
SYS.INCL.ABORT.CHECK
SYS.INCL.ABORT.CHECK.READ
SYS.INCL.QUIET.WRITE
SYS.INCL.QUIET.LOAD
SYS.INCL.COMM.WAIT.QUIET
STANDARD.FUNCTIONS.CHARACTERS
STANDARD.CHARACTERS
SYS.INCL.FSEARCH.TOP
SYS.INCL.FSEARCH.BOT
SYS.INCL.LOG.ENTRY
SYS.INCL.USER.SET
TEMP9
TEMP10
~TEMP9~
*CODE.SEGMENT: ?
SYS.SUBR.SYSTEM.NAME
SYS.SUBR.SYSTEM.TYPE
SYS.SUBR.FILE.STAT
SYS.COMM.WAIT.QUIET.SUB
SYS.LOG.ENTRY.SUB
PICKTR.HEADER.SUB
PICKTR.DETAIL.SUB
PICK.TRANSFER.SUB
PICK.TRANSFER
~TPL.DIM~
*CODE.SEGMENT: ?
DIM TPL(10)
~TPL.EQUATES~
*CODE.SEGMENT: ?
* FILE 'TPL' EQUATES - GENERATED 13:16:16  22 APR 1985
EQU TPL$ADD.ID TO TPL(1);               * POINTER TO ADDRESS.ID IN FILE 'ADD'
EQU TPL$STAT TO TPL(2);                 * STATUS (Taplock, Removed)
EQU TPL$DISC.DATE TO TPL(3);            * Disconnect date
EQU TPL$DISC.WO TO TPL(4);              * Disconnect work order number
EQU TPL$REM.DATE TO TPL(5);             * Taplock removal date
EQU TPL$REM.WO TO TPL(6);               * Taplock removal work order number
~TST.EQUATES~
*CODE.SEGMENT: TST.EQUATES
*
*
* FILE: CNT     ITEM: SYSTEM.TEST
*
EQU TST$SYS            TO 1
EQU TST$RTN            TO 2
EQU TST$LBL            TO 3
EQU TST$FILE           TO 4
EQU TST$LIST.NAME      TO 5
EQU TST$TEST.DATE      TO 6
EQU TST$BREAK          TO 7
EQU TST$TIMING         TO 8
EQU TST$TA             TO 9
*
EQU TST$SPEC.APPL      TO 10
EQU TST$SPEC.VAL       TO 11
*
EQU TST$WO             TO 12
EQU TST$BILL           TO 13
EQU TST$SYST           TO 14
EQU TST$RELS           TO 15
*
EQU TST$PAUSE          TO 16
EQU TST$APPL           TO 17
~TST.INCL.LOAD~
*CODE.SEGMENT: TST.INCL.LOAD
* VERSION: 940119 2.0  ADDED CNT.TST(17) FOR SH.MAINT.TST.SUB.
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   1990         ALL RIGHTS RESERVED
*
* AUTHOR: David Horsman
*
IF TYPE.RUN EQ "5" THEN
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
TYPE.RUN = "6"
CNT.TST.ID.SAVE = CNT.TST.ID
END ELSE NULL
*
END ELSE IF TYPE.RUN NE "9" THEN
CNT.TST.ID = "SYS.TST.":PORT
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST.":PORT
END ELSE
CNT.TST.ID = "SYS.TST"
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST"
END ELSE
CNT.TST.ID = "SYS.TST.":SYS.APPL.SUB
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST.":SYS.APPL.SUB
END ELSE
CNT.TST.ID = "SYS.TST.":ACCT
MATREAD CNT.TST FROM CNT.FILE,CNT.TST.ID THEN
CNT.TST.ID.SAVE = "SYS.TST.":ACCT
END ELSE
CNT.TST.ID = "SYS.TST.":PORT
CNT.TST.ID.SAVE = "SYS.TST.":PORT
MAT CNT.TST = EMPTY
END
END
END
END
END
*
IF AUTO.RUN THEN DISP.ONLY = TRUE
*
IF NOT(AUTO.RUN) AND CNT.TST$MAINT THEN
* CALL SH.MAINT.TST.SUB(CNT.FILE,CNT.TST.ID,MAT CNT.TST,PAR.FILE,LCK.FILE,CNT.ID.SAVE,GENERIC,CO.DATA,"1",STAT)
* CALL SH.SUBR.MAINT.TST(CNT.TST.FILE,CNT.TST.ID,MAT CNT.TST,LCK.FILE,MAT TDL,CNT.TST.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*960509*DGH*CALL SH.SUBR.MAINT.TST(TDL.REC,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,CNT.FILE,LCK.FILE)
*
CALL SH.SUBR.MAINT.TST(TDL.REC,CNT.TST.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,CNT.TST.FILE,LCK.FILE)
*
END
*
*
***CNT.TST$BREAK = TRUE
***CNT.TST$TA    = TRUE
***CNT.TST$RTN   = FALSE
***CNT.TST$ID    = FALSE
***CNT.TST$LBL   = FALSE
***CNT.TST$FILE  = FALSE
***CNT.TST$CR    = FALSE
***CNT.TST$LIST.NAME = EMPTY
***CNT.TST$X = FALSE
***CNT.TST$Y = FALSE
***CNT.TST$Z = FALSE
***CNT.TST$MAINT = FALSE
*
!
*
IF CNT.TST$ON THEN
*
LOCATE SYS.APPL.SUB IN CNT.TST$APPL<ONE> SETTING SYS.APPL.LOC THEN
*
*
***TC.CN = ZERO
***LOOP
***TC.CN = TC.CN + ONE
***TC = CNT.TST$PARAMS<ONE,SYS.APPL.LOC>[TC.CN,ONE]
TMP = CNT.TST$PARAMS<ONE,SYS.APPL.LOC>
***WHILE TC NE EMPTY DO
***BEGIN CASE
IF NOT(INDEX(TMP,"B",ONE)) THEN CNT.TST$BREAK = FALSE
*
IF NOT(INDEX(TMP,"T",ONE)) THEN CNT.TST$TA    = FALSE
*
IF NOT(INDEX(TMP,"R",ONE)) THEN CNT.TST$RTN   = FALSE
*
IF NOT(INDEX(TMP,"K",ONE)) THEN CNT.TST$ID    = FALSE
*
IF NOT(INDEX(TMP,"L",ONE)) THEN CNT.TST$LBL   = FALSE
*
IF NOT(INDEX(TMP,"F",ONE)) THEN CNT.TST$FILE  = FALSE
*
IF NOT(INDEX(TMP,"C",ONE)) THEN CNT.TST$CR    = FALSE
*
IF INDEX(TMP,"G",ONE) THEN CNT.TST$LIST.NAME = CNT.TST$LISTS<ONE,SYS.APPL.LOC>
*
IF NOT(INDEX(TMP,"X",ONE)) THEN CNT.TST$X = FALSE
*
IF NOT(INDEX(TMP,"Y",ONE)) THEN CNT.TST$Y = FALSE
*
IF NOT(INDEX(TMP,"Z",ONE)) THEN CNT.TST$Z = FALSE
*
IF NOT(INDEX(TMP,"M",ONE)) THEN CNT.TST$MAINT = FALSE
*
***END CASE
***REPEAT
END
*
!
*
IF CNT.TST$BREAK EQ EMPTY THEN CNT.TST$BREAK = TRUE
IF NOT(CNT.TST$BREAK) THEN 
BREAK OFF
END
*
IF CNT.TST$TA EQ EMPTY THEN CNT.TST$TA = TRUE
IF NOT(CNT.TST$TA) THEN 
* TYPEAHEAD OFF
END
*
END
IF AUTO.RUN THEN CNT.TST$CR = FALSE
*
IF CNT.TST$LBL THEN
PRINT CLB:"Exiting system test ":
IF CNT.TST$CR THEN PRINT BELL:" <cr>":; INPUT TMP:
END
*
*2APR94* RETURN
*
~TST.VAR.EQUATES~
*CODE.SEGMENT: TST.EQUATES
*
*
* FILE: CNT     ITEM: SYSTEM.TEST
*
EQU TST$SYS            TO 1
EQU TST$RTN            TO 2
EQU TST$LBL            TO 3
EQU TST$FILE           TO 4
EQU TST$LIST.NAME      TO 5
EQU TST$TEST.DATE      TO 6
EQU TST$BREAK          TO 7
EQU TST$TIMING         TO 8
EQU TST$TA             TO 9
*
EQU TST$SPEC.APPL      TO 10
EQU TST$SPEC.VAL       TO 11
*
EQU TST$WO             TO 12
EQU TST$BILL           TO 13
EQU TST$SYST           TO 14
EQU TST$RELS           TO 15
*
EQU TST$PAUSE          TO 16
EQU TST$APPL           TO 17
~ULT.STANDARD.FUNCTIONS~
*CODE.SEGMENT: ?
!
STANDARD.FUNCTIONS: *
EQUATE BELL TO CHAR(7)
EQUATE LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13)
EQUATE TRUE TO 1,T TO 1,FALSE TO 0,F TO 0
EQUATE SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+1000)[2,3]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
~UPR.DIM~
*CODE.SEGMENT: ?
DIM UPR(30)
~UPR.EQUATES~
*CODE.SEGMENT: ?
* FILE 'UPR' EQUATES - GENERATED 12:27:47  14 SEP 1984
EQU UPR$STATE.PROV TO UPR(1);           * ST/PRV
EQU UPR$COMPANY TO UPR(2);              * CABLE COMPANY NAME
EQU UPR$ADDRESS TO UPR(3);              * MAILING ADDRESS
EQU UPR$PCODE TO UPR(4);                * PZ.CODE
EQU UPR$COUNTRY TO UPR(5);              * CTY
EQU UPR$CONTACT TO UPR(6);              * CABLE COMPANY CONTACTS
EQU UPR$TITLE TO UPR(7);                * CONTACT TITLES
EQU UPR$SUBS TO UPR(8);                 * SUBS
EQU UPR$HOMES.PASSED TO UPR(9);         * PASSED
EQU UPR$HOMES.IN TO UPR(10);            * HOM.IN
EQU UPR$POP TO UPR(11);                 * POP
EQU UPR$PAY.SUBS TO UPR(12);            * PAYS
EQU UPR$OWNERSHIP TO UPR(13);           * O.C
EQU UPR$MSO TO UPR(14);                 * MSO.ID
EQU UPR$COMPETITOR TO UPR(15);          * CC
EQU UPR$TYPE TO UPR(16);                * CT
EQU UPR$SYSTEM.STATUS TO UPR(17);       * S.STAT
EQU UPR$START.DATE TO UPR(21);          * START.DATE
EQU UPR$COMMENTS TO UPR(22);            * COMMENTS
EQU UPR$PHONE TO UPR(23);               * PHONE NO.
EQU UPR$CONTACT.FLAG TO UPR(24);        * CONTACT FLAG
EQU UPR$COMP.CONTACT.FLAG TO UPR(25);   * COMP. CONTACT FLAG
EQU UPR$INTEREST.RATE TO UPR(26);       * ANNUAL INTEREST RATE FOR COST OF CREDIT
~WKH.DIM~
*CODE.SEGMENT: ?
DIM WKH(50)
~WKH.EQUATES~
*CODE.SEGMENT: ?
* FILE 'WKH' EQUATES - GENERATED 14:47:51  27 SEP 1984
EQU WKH$ACT.ID TO WKH(1);               * TENANT ACCOUNT NO.
EQU WKH$ADD.ID TO WKH(2);               * ADDRESS ID
EQU WKH$TFR.FROM.ADD.ID TO WKH(3);      * TFR. FROM ADDRESS ID
EQU WKH$TYPE TO WKH(4);                 * WORK ORDER TYPE
EQU WKH$STAT TO WKH(5);                 * WORK ORDER STATUS
EQU WKH$SCH.DATE TO WKH(6);             * SCHEDULED DATE
EQU WKH$SCH.TIME TO WKH(7);             * SCHEDULED TIME
EQU WKH$SCH.POINTS TO WKH(8);           * SCHEDULE POINTS
EQU WKH$SCH.TYPE TO WKH(9);             * SCHEDULE TYPE
EQU WKH$SCH.OVERBOOK TO WKH(10);        * SCHEDULE OVERBOOKED FLAG
EQU WKH$COMPL.DATE TO WKH(11);          * COMPLETION DATE
EQU WKH$OPERATOR TO WKH(12);            * OPERATOR ENTERING WORK ORDER
EQU WKH$INSTALLER TO WKH(13);           * INSTALLER COMPLETING WORK ORDER
EQU WKH$SALESMAN TO WKH(14);            * SALESMAN WHO SOLD W/O SERVICES
EQU WKH$DVC.COLLECT.INFO TO WKH(15);    * DEVICE COLLECTION INFORMATION
EQU WKH$DVC.PRINT.DATE TO WKH(16);      * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU WKH$DVC.REPRINT.DATE TO WKH(17);    * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU WKH$PRINT.DATE TO WKH(18);          * DATE WORK ORDER WAS FIRST PRINTED
EQU WKH$REPRINT.DATE TO WKH(19);        * DATE WORK ORDER WAS LAST REPRINTED
EQU WKH$ENTRY.DATE TO WKH(21);          * DATE WORK ORDER WAS ENTERED
EQU WKH$EFF.DATE TO WKH(22);            * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU WKH$DEPOSIT.AMT TO WKH(23);         * AMOUNT OF DEPOSIT ADJUSTMENT
EQU WKH$TOTAL.AMT TO WKH(24);           * TOTAL AMOUNT BILLED ON WORK ORDER
EQU WKH$ACTIVS TO WKH(25);              * WORK ORDER ACTIVITY
EQU WKH$ACTIV.QNTYS TO WKH(26);         * QUANTITY FOR THIS ACTIVITY
EQU WKH$ACTIV.AMTS TO WKH(27);          * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU WKH$ACTIV.SERVICES TO WKH(28);      * SERVICE PROVIDED FROM THIS ACTIVITY
EQU WKH$SVC.FREQS TO WKH(29);           * BILL FREQUENCY OF SERVICE
EQU WKH$SVC.LOCATIONS TO WKH(30);       * LOCATION OF OUTLET
EQU WKH$DVC.IDS TO WKH(31);             * DEVICE NO.
EQU WKH$DVC.ACTIV.STATS TO WKH(32);     * STATUS OF DEVICE ACTIVITY
EQU WKH$MAINT.CODES TO WKH(33);         * Service Order Maintenance codes
EQU WKH$MAINT.DESCS TO WKH(34);         * Service Order Maintenance descriptions
EQU WKH$BILL.SERVICES TO WKH(35);       * TYPE OF SERVICE BILLED
EQU WKH$BILL.QNTYS TO WKH(36);          * QUANTITY OF SERVICE BILLED
EQU WKH$BILL.FROM.DATES TO WKH(37);     * DATE FROM WHICH SERVICE IS BILLED
EQU WKH$BILL.TO.DATES TO WKH(38);       * DATE TO WHICH SERVICE IS BILLED
EQU WKH$BILL.RENT.AMTS TO WKH(39);      * RENTAL AMOUNT
EQU WKH$BILL.OTHER.AMTS TO WKH(40);     * NON-RENTAL AMOUNT
EQU WKH$BILL.FREQS TO WKH(41);          * BILL FREQUENCY FOR RATE CALC.
EQU WKH$BILL.DVC.NUMS TO WKH(42);       * DEVICE NO. FOR BILLING OF SERVICE
EQU WKH$BILL.SVC.LOCATIONS TO WKH(43);  * LOCATION OF BILLED SERVICE
EQU WKH$RATE.EFF.DATES TO WKH(44);      * EFF. DATE FOR RATE USED
EQU WKH$RATE.QNTYS TO WKH(45);          * NO. OF OUTLETS AT RATE
EQU WKH$MTHLY.RATES TO WKH(46);         * RATE PER OUTLET PER MONTH
EQU WKH$TAX.NAMES TO WKH(47);           * NAME OF TAX
EQU WKH$TAX.AMTS TO WKH(48);            * AMOUNT OF TAX
EQU WKH$BULK.ADD.IDS TO WKH(49);        * BULK ADDRESS POINTER
EQU WKH$MESSAGE TO WKH(50);             * WORK ORDER MESSAGE
~WKO.DIM~
*CODE.SEGMENT: ?
DIM WKO(60)
~WKO.EQUATES~
*CODE.SEGMENT: WKO.EQUATES
*
* FILE 'WKO' EQUATES - GENERATED 16:14:40  30 DEC 1991
EQU WKO$ACT.ID TO WKO(1);               * TENANT ACCOUNT NO.
EQU WKO$ADD.ID TO WKO(2);               * ADDRESS ID
EQU WKO$TFR.FROM.ADD.ID TO WKO(3);      * TFR. FROM ADDRESS ID
EQU WKO$TYPE TO WKO(4);                 * WORK ORDER TYPE
EQU WKO$STAT TO WKO(5);                 * WORK ORDER STATUS
EQU WKO$SCH.DATE TO WKO(6);             * SCHEDULED DATE
EQU WKO$SCH.TIME TO WKO(7);             * SCHEDULED TIME
EQU WKO$SCH.POINTS TO WKO(8);           * SCHEDULE POINTS
EQU WKO$SCH.TYPE TO WKO(9);             * SCHEDULE TYPE
EQU WKO$SCH.OVERBOOK TO WKO(10);        * SCHEDULE OVERBOOKED FLAG
EQU WKO$COMPL.DATE TO WKO(11);          * COMPLETION DATE
EQU WKO$OPERATOR TO WKO(12);            * OPERATOR ENTERING WORK ORDER
EQU WKO$INSTALLER TO WKO(13);           * INSTALLER COMPLETING WORK ORDER
EQU WKO$SALESMAN TO WKO(14);            * SALESMAN WHO SOLD W/O SERVICES
EQU WKO$DVC.COLLECT.INFO TO WKO(15);    * DEVICE COLLECTION INFORMATION
EQU WKO$DVC.PRINT.DATE TO WKO(16);      * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU WKO$DVC.REPRINT.DATE TO WKO(17);    * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU WKO$PRINT.DATE TO WKO(18);          * DATE WORK ORDER WAS FIRST PRINTED
EQU WKO$REPRINT.DATE TO WKO(19);        * DATE WORK ORDER WAS LAST REPRINTED
EQU WKO$DEPOSIT.TAX TO WKO(20);         * TAX ON THE DEPOSIT AMOUNT
EQU WKO$ENTRY.DATE TO WKO(21);          * DATE WORK ORDER WAS ENTERED
EQU WKO$EFF.DATE TO WKO(22);            * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU WKO$DEPOSIT.AMT TO WKO(23);         * AMOUNT OF DEPOSIT ADJUSTMENT
EQU WKO$TOTAL.AMT TO WKO(24);           * TOTAL AMOUNT BILLED ON WORK ORDER
EQU WKO$ACTIVS TO WKO(25);              * WORK ORDER ACTIVITY
EQU WKO$ACTIV.QNTYS TO WKO(26);         * QUANTITY FOR THIS ACTIVITY
EQU WKO$ACTIV.AMTS TO WKO(27);          * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU WKO$ACTIV.SERVICES TO WKO(28);      * SERVICE PROVIDED FROM THIS ACTIVITY
EQU WKO$SVC.FREQS TO WKO(29);           * BILL FREQUENCY OF SERVICE
EQU WKO$SVC.LOCATIONS TO WKO(30);       * LOCATION OF OUTLET
EQU WKO$DVC.IDS TO WKO(31);             * DEVICE NO.
EQU WKO$DVC.ACTIV.STATS TO WKO(32);     * STATUS OF DEVICE ACTIVITY
EQU WKO$MAINT.CODES TO WKO(33);         * Service Order Maintenance codes
EQU WKO$OUTCOME.CODES TO WKO(34);       * Service Order Outcome Codes
EQU WKO$BILL.SERVICES TO WKO(35);       * TYPE OF SERVICE BILLED
EQU WKO$BILL.QNTYS TO WKO(36);          * QUANTITY OF SERVICE BILLED
EQU WKO$BILL.FROM.DATES TO WKO(37);     * DATE FROM WHICH SERVICE IS BILLED
EQU WKO$BILL.TO.DATES TO WKO(38);       * DATE TO WHICH SERVICE IS BILLED
EQU WKO$BILL.RENT.AMTS TO WKO(39);      * RENTAL AMOUNT
EQU WKO$BILL.OTHER.AMTS TO WKO(40);     * NON-RENTAL AMOUNT
EQU WKO$BILL.FREQS TO WKO(41);          * BILL FREQUENCY FOR RATE CALC.
EQU WKO$BILL.DVC.NUMS TO WKO(42);       * DEVICE NO. FOR BILLING OF SERVICE
EQU WKO$BILL.SVC.LOCATIONS TO WKO(43);  * LOCATION OF BILLED SERVICE
EQU WKO$RATE.EFF.DATES TO WKO(44);      * EFF. DATE FOR RATE USED
EQU WKO$RATE.QNTYS TO WKO(45);          * NO. OF OUTLETS AT RATE
EQU WKO$MTHLY.RATES TO WKO(46);         * RATE PER OUTLET PER MONTH
EQU WKO$TAX.NAMES TO WKO(47);           * NAME OF TAX
EQU WKO$TAX.AMTS TO WKO(48);            * AMOUNT OF TAX
EQU WKO$PRINT.SOURCE TO WKO(49);        * Printed by System or out of GENIE
EQU WKO$MESSAGE TO WKO(50);             * WORK ORDER MESSAGE
EQU WKO$DISC.REASON TO WKO(51);         * Reason the subscriber was disconnected
EQU WKO$SCH.REQUEST TO WKO(52);         * Scheduled date is at sub's request.
EQU WKO$TROUBLE.CLASS TO WKO(53);       * Trouble classification code
EQU WKO$TRUCK.ROLL TO WKO(54);          * WAS A TRUCK ROLLED FOR THE WKO?
EQU WKO$CONF.DATE.TM TO WKO(55);        * The WKO confirmation date and time.
EQU WKO$REQUEST.DATE TO WKO(56);        * Date install was requested for.
EQU WKO$TAKEN.DATE TO WKO(57);          * Date the order was taken.
EQU WKO$TAKEN.TM TO WKO(58);            * The time the order was taken.
EQU WKO$ENTRY.TM TO WKO(59);            * The time of day the order was entered.
EQU WKO$COMPL.TM TO WKO(60);            * The time of day the order was completed.
~WKO.VAR.EQUATES~
*CODE.SEGMENT: WKO.VAR.EQUATES
*
* FILE 'WKO' EQUATES - GENERATED 16:14:41  30 DEC 1991
EQU WKO$ACT.ID TO 1;                    * TENANT ACCOUNT NO.
EQU WKO$ADD.ID TO 2;                    * ADDRESS ID
EQU WKO$TFR.FROM.ADD.ID TO 3;           * TFR. FROM ADDRESS ID
EQU WKO$TYPE TO 4;                      * WORK ORDER TYPE
EQU WKO$STAT TO 5;                      * WORK ORDER STATUS
EQU WKO$SCH.DATE TO 6;                  * SCHEDULED DATE
EQU WKO$SCH.TIME TO 7;                  * SCHEDULED TIME
EQU WKO$SCH.POINTS TO 8;                * SCHEDULE POINTS
EQU WKO$SCH.TYPE TO 9;                  * SCHEDULE TYPE
EQU WKO$SCH.OVERBOOK TO 10;             * SCHEDULE OVERBOOKED FLAG
EQU WKO$COMPL.DATE TO 11;               * COMPLETION DATE
EQU WKO$OPERATOR TO 12;                 * OPERATOR ENTERING WORK ORDER
EQU WKO$INSTALLER TO 13;                * INSTALLER COMPLETING WORK ORDER
EQU WKO$SALESMAN TO 14;                 * SALESMAN WHO SOLD W/O SERVICES
EQU WKO$DVC.COLLECT.INFO TO 15;         * DEVICE COLLECTION INFORMATION
EQU WKO$DVC.PRINT.DATE TO 16;           * DATE DVC RETURN W/O WAS FIRST PRINTED
EQU WKO$DVC.REPRINT.DATE TO 17;         * DATE DVC RETURN W/O WAS LAST REPRINTED
EQU WKO$PRINT.DATE TO 18;               * DATE WORK ORDER WAS FIRST PRINTED
EQU WKO$REPRINT.DATE TO 19;             * DATE WORK ORDER WAS LAST REPRINTED
EQU WKO$DEPOSIT.TAX TO 20;              * TAX ON THE DEPOSIT AMOUNT
EQU WKO$ENTRY.DATE TO 21;               * DATE WORK ORDER WAS ENTERED
EQU WKO$EFF.DATE TO 22;                 * EFFECTIVE DATE FOR BILLING OF W/ORDER
EQU WKO$DEPOSIT.AMT TO 23;              * AMOUNT OF DEPOSIT ADJUSTMENT
EQU WKO$TOTAL.AMT TO 24;                * TOTAL AMOUNT BILLED ON WORK ORDER
EQU WKO$ACTIVS TO 25;                   * WORK ORDER ACTIVITY
EQU WKO$ACTIV.QNTYS TO 26;              * QUANTITY FOR THIS ACTIVITY
EQU WKO$ACTIV.AMTS TO 27;               * AMOUNT OF CHARGE FOR THIS ACTIVITY
EQU WKO$ACTIV.SERVICES TO 28;           * SERVICE PROVIDED FROM THIS ACTIVITY
EQU WKO$SVC.FREQS TO 29;                * BILL FREQUENCY OF SERVICE
EQU WKO$SVC.LOCATIONS TO 30;            * LOCATION OF OUTLET
EQU WKO$DVC.IDS TO 31;                  * DEVICE NO.
EQU WKO$DVC.ACTIV.STATS TO 32;          * STATUS OF DEVICE ACTIVITY
EQU WKO$MAINT.CODES TO 33;              * Service Order Maintenance codes
EQU WKO$OUTCOME.CODES TO 34;            * Service Order Outcome Codes
EQU WKO$BILL.SERVICES TO 35;            * TYPE OF SERVICE BILLED
EQU WKO$BILL.QNTYS TO 36;               * QUANTITY OF SERVICE BILLED
EQU WKO$BILL.FROM.DATES TO 37;          * DATE FROM WHICH SERVICE IS BILLED
EQU WKO$BILL.TO.DATES TO 38;            * DATE TO WHICH SERVICE IS BILLED
EQU WKO$BILL.RENT.AMTS TO 39;           * RENTAL AMOUNT
EQU WKO$BILL.OTHER.AMTS TO 40;          * NON-RENTAL AMOUNT
EQU WKO$BILL.FREQS TO 41;               * BILL FREQUENCY FOR RATE CALC.
EQU WKO$BILL.DVC.NUMS TO 42;            * DEVICE NO. FOR BILLING OF SERVICE
EQU WKO$BILL.SVC.LOCATIONS TO 43;       * LOCATION OF BILLED SERVICE
EQU WKO$RATE.EFF.DATES TO 44;           * EFF. DATE FOR RATE USED
EQU WKO$RATE.QNTYS TO 45;               * NO. OF OUTLETS AT RATE
EQU WKO$MTHLY.RATES TO 46;              * RATE PER OUTLET PER MONTH
EQU WKO$TAX.NAMES TO 47;                * NAME OF TAX
EQU WKO$TAX.AMTS TO 48;                 * AMOUNT OF TAX
EQU WKO$PRINT.SOURCE TO 49;             * Printed by System or out of GENIE
EQU WKO$MESSAGE TO 50;                  * WORK ORDER MESSAGE
EQU WKO$DISC.REASON TO 51;              * Reason the subscriber was disconnected
EQU WKO$SCH.REQUEST TO 52;              * Scheduled date is at sub's request.
EQU WKO$TROUBLE.CLASS TO 53;            * Trouble classification code
EQU WKO$TRUCK.ROLL TO 54;               * WAS A TRUCK ROLLED FOR THE WKO?
EQU WKO$CONF.DATE.TM TO 55;             * The WKO confirmation date and time.
EQU WKO$REQUEST.DATE TO 56;             * Date install was requested for.
EQU WKO$TAKEN.DATE TO 57;               * Date the order was taken.
EQU WKO$TAKEN.TM TO 58;                 * The time the order was taken.
EQU WKO$ENTRY.TM TO 59;                 * The time of day the order was entered.
EQU WKO$COMPL.TM TO 60;                 * The time of day the order was completed.
~WKP.DIM~
*CODE.SEGMENT: ?
DIM WKP(10)
~WKP.EQUATES~
*CODE.SEGMENT: ?
* FILE 'WKP' EQUATES - GENERATED 11:42:14  12 JUL 1984
EQU WKP$TOTAL.POINTS TO WKP(1);         * TOTAL POINTS ALLOCATED
EQU WKP$POINTS.TAKEN TO WKP(2);         * NO. OF POINTS ALREADY TAKEN
EQU WKP$SCH.TIMES TO WKP(3);            * SCH. TIMES WHERE ENTERED
EQU WKP$SCH.POINTS TO WKP(4);           * SCH. POINTS FOR SCH. TIMES ENTERED
EQU WKP$SCH.AREAS TO WKP(5);            * SERVICE AREAS LIST
~WKS.DIM~
*CODE.SEGMENT: WKS.DIM
*
DIM WKS(20)
~WKS.EQUATES~
*CODE.SEGMENT: WKS.EQUATES
*
* FILE 'WKS' EQUATES - GENERATED 16:54:46  08 APR 1992
EQU WKS$PERIODS TO WKS(1);              * 
EQU WKS$WEIGHTED.TOTALS TO WKS(2);      * 
EQU WKS$WEIGHTED.COMPLETED TO WKS(3);   * 
EQU WKS$WEIGHTED.PERCENT TO WKS(4);     * 
EQU WKS$WEIGHTED.OVER.BY.CUST TO WKS(5);     * 
EQU WKS$WEIGHTED.OVER.NOT.BY.CUST TO WKS(6); * 
EQU WKS$ACTUAL.TOTALS TO WKS(7);        * 
EQU WKS$ACTUAL.COMPLETED TO WKS(8);     * 
EQU WKS$ACTUAL.PERCENT TO WKS(9);       * 
EQU WKS$ACTUAL.OVER.BY.CUST TO WKS(10);      * 
EQU WKS$ACTUAL.OVER.NOT.BY.CUST TO WKS(11);  * 
EQU WKS$WEIGHTED.TOTAL.CUST TO WKS(12); * 
EQU WKS$WEIGHTED.NON.BULK.CUST TO WKS(13);   * 
EQU WKS$WEIGHTED.BULK.CUST TO WKS(14);       * 
EQU WKS$WEIGHTED.NO.BASIC.CUST TO WKS(15);   * 
EQU WKS$ACTUAL.TOTAL.CUST TO WKS(16);   * 
EQU WKS$ACTUAL.NON.BULK.CUST TO WKS(17);* 
EQU WKS$ACTUAL.BULK.CUST TO WKS(18);    * 
EQU WKS$ACTUAL.NO.BASIC.CUST TO WKS(19);* 
~WKS.VAR.EQUATES~
*CODE.SEGMENT: WKS.VAR.EQUATES
*
* FILE 'WKS' EQUATES - GENERATED 16:54:47  08 APR 1992
EQU WKS$PERIODS TO 1;                   * 
EQU WKS$WEIGHTED.TOTALS TO 2;           * 
EQU WKS$WEIGHTED.COMPLETED TO 3;        * 
EQU WKS$WEIGHTED.PERCENT TO 4;          * 
EQU WKS$WEIGHTED.BY.CUST TO 5;          * 
EQU WKS$WEIGHTED.NOT.BY.CUST TO 6;      * 
EQU WKS$ACTUAL.TOTALS TO 7;             * 
EQU WKS$ACTUAL.COMPLETED TO 8;          * 
EQU WKS$ACTUAL.PERCENT TO 9;            * 
EQU WKS$ACTUAL.BY.CUST TO 10;           * 
EQU WKS$ACTUAL.NOT.BY.CUST TO 11;       * 
EQU WKS$WEIGHTED.TOTAL.CUST TO 12;      * 
EQU WKS$WEIGHTED.NON.BULK TO 13;        * 
EQU WKS$WEIGHTED.BULK TO 14;            * 
EQU WKS$WEIGHTED.NO.BASIC TO 15;        * 
EQU WKS$ACTUAL.TOTAL.CUST TO 16;        * 
EQU WKS$ACTUAL.NON.BULK.CUST TO 17;     * 
EQU WKS$ACTUAL.BULK.CUST TO 18;         * 
EQU WKS$ACTUAL.NO.BASIC.CUST TO 19;     * 
~WO.DVC.OUT.STATUS~
*CODE.SEGMENT: WO.DVC.OUT.STATUS
*
* GENERAL.COMMON.AREA
*
*
DVC.OUT = "N"; LOC = 1
LOOP ACTIV = WKO$ACTIVS<1,LOC> UNTIL ACTIV = "" OR DVC.OUT EQ "Y" DO
IF ACTIV = "IC" OR ACTIV = "ID" THEN
IF WKO$ACTIV.QNTYS<1,LOC> < 0 THEN
SC = 1
LOOP DVC.ID = WKO$DVC.IDS<1,LOC,SC> UNTIL DVC.ID = "" OR DVC.OUT EQ "Y" DO
IF WKO$DVC.ACTIV.STATS<1,LOC,SC> = "" THEN DVC.OUT = "Y" ELSE
SC = SC+1
END
REPEAT
END
END
IF DVC.OUT NE "Y" THEN LOC = LOC+1
REPEAT
*
*
~WO.LOCKUP~
*CODE.SEGMENT: WO.LOCKUP
*
*
* GENERAL.COMMON.AREA
*
IF RL THEN RETURN ELSE RL = ONE
REF = "ACT*":ACT.ID; CALL UPDATE.LOCK(ACT.FILE); IF STAT GT ZERO THEN STAT = 999; RETURN
REF = "ADD*":ADD.ID; CALL UPDATE.LOCK(ADD.FILE); IF STAT GT ZERO THEN STAT = 999; RETURN
REF = "WKO*":WKO.ID; CALL UPDATE.LOCK(WKO.FILE); IF STAT GT ZERO THEN STAT = 999; RETURN
*
~WOA.DIM~
*CODE.SEGMENT: ?
DIM WOA(10)
~WOA.EQUATES~
*CODE.SEGMENT: ?
* FILE 'WOA' EQUATES - GENERATED 11:47:32  07 OCT 1983
EQU WOA$CODES TO WOA(1);                * ACTIVITY CODE
EQU WOA$DESCS TO WOA(2);                * ACTIVITY DESCRIPTION
EQU WOA$TYPES TO WOA(3);                * ACTIVITY TYPE
EQU WOA$GENERATES TO WOA(4);            * GENERATED SUBSTITUTE ACTIVITIES
~WOT.DIM~
*CODE.SEGMENT: ?
DIM WOT(25)
~WOT.EQUATES~
*CODE.SEGMENT: WOT.EQUATES
*
* FILE 'WOT' EQUATES - GENERATED 12:26:07  30 DEC 1991
EQU WOT$TYPE TO WOT(1);                 * TYPE OF WORK ORDER
EQU WOT$DESC TO WOT(2);                 * DESCRIPTION
EQU WOT$BASIC.POINTS TO WOT(3);         * BASIC POINTS FOR W/O TYPE
EQU WOT$REQD.ACTIVS TO WOT(4);          * REQUIRED ACTIVITY
EQU WOT$REQD.POINTS TO WOT(5);          * W/O POINTS FOR REQD. ACTIVITY
EQU WOT$OPT.ACTIVS TO WOT(6);           * OPTIONAL ACTIVITY
EQU WOT$OPT.POINTS TO WOT(7);           * W/O POINTS FOR OPT. ACTIVITY
EQU WOT$FUNC TO WOT(8);                 * BASIC FUNCTION OF W/O
EQU WOT$NEW.TNT TO WOT(9);              * W/O SPECIFIC TO NEW OR OLD TENANT
EQU WOT$ACT.STATS TO WOT(10);           * VALID ACT STATUSES FOR W/O
EQU WOT$ADD.STATS TO WOT(11);           * VALID ADD STATUSES FOR W/O
EQU WOT$SCH.REQD TO WOT(12);            * WHETHER W/O SCHEDULING IS REQUIRED
EQU WOT$SCH.TYPE TO WOT(13);            * SCHEDULE TYPE
EQU WOT$PRINT.DESC TO WOT(14);          * DESCRIPTION PRINTED ON WORK ORDER
EQU WOT$PURGE.REQ TO WOT(15);           * PURGE OPTION
EQU WOT$CONFIRM.OPT TO WOT(16);         * CONFIRMATION OPTION
EQU WOT$CANCEL.OPT TO WOT(17);          * CANCELLATION OPTION
EQU WOT$INSTALL.OPT TO WOT(18);         * INSTALLER OPTION
EQU WOT$SALES.OPT TO WOT(19);           * SALESMAN OPTION
EQU WOT$DISC.REASON TO WOT(20);         * DISCONNECT REASON
EQU WOT$ROLL TO WOT(21);                * IS A TRUCK ROLL REQUIRED?
~WOT.VAR.EQUATES~
*CODE.SEGMENT: WOT.VAR.EQUATES
*
* FILE 'WOT' EQUATES - GENERATED 12:26:07  30 DEC 1991
EQU WOT$TYPE TO 1;                      * TYPE OF WORK ORDER
EQU WOT$DESC TO 2;                      * DESCRIPTION
EQU WOT$BASIC.POINTS TO 3;              * BASIC POINTS FOR W/O TYPE
EQU WOT$REQD.ACTIVS TO 4;               * REQUIRED ACTIVITY
EQU WOT$REQD.POINTS TO 5;               * W/O POINTS FOR REQD. ACTIVITY
EQU WOT$OPT.ACTIVS TO 6;                * OPTIONAL ACTIVITY
EQU WOT$OPT.POINTS TO 7;                * W/O POINTS FOR OPT. ACTIVITY
EQU WOT$FUNC TO 8;                      * BASIC FUNCTION OF W/O
EQU WOT$NEW.TNT TO 9;                   * W/O SPECIFIC TO NEW OR OLD TENANT
EQU WOT$ACT.STATS TO 10;                * VALID ACT STATUSES FOR W/O
EQU WOT$ADD.STATS TO 11;                * VALID ADD STATUSES FOR W/O
EQU WOT$SCH.REQD TO 12;                 * WHETHER W/O SCHEDULING IS REQUIRED
EQU WOT$SCH.TYPE TO 13;                 * SCHEDULE TYPE
EQU WOT$PRINT.DESC TO 14;               * DESCRIPTION PRINTED ON WORK ORDER
EQU WOT$PURGE.REQ TO 15;                * PURGE OPTION
EQU WOT$CONFIRM.OPT TO 16;              * CONFIRMATION OPTION
EQU WOT$CANCEL.OPT TO 17;               * CANCELLATION OPTION
EQU WOT$INSTALL.OPT TO 18;              * INSTALLER OPTION
EQU WOT$SALES.OPT TO 19;                * SALESMAN OPTION
EQU WOT$DISC.REASON TO 20;              * DISCONNECT REASON
EQU WOT$ROLL TO 21;                     * IS A TRUCK ROLL REQUIRED?
~XPV.DIM~
DIM XPV(10)
~XPV.EQUATES~
*CODE.SEGMENT: XPV.EQUATES
*
* FILE 'XPV' EQUATES - GENERATED 15:56:53  04 MAR 1994
EQU XPV$EVENT.NUMS TO XPV(1);           * EVENT NUMBERS
EQU XPV$DUR TO XPV(2);                  * DURATION OF THE EVENT SHOWN (1-16 SECS)
EQU XPV$ACCOUNT TO XPV(3);              * THE ACCOUNT THAT WATCHED THE EVENT
EQU XPV$ACC TO XPV(4);                  * COMPANY CODE (PICK ACCOUNT)
EQU XPV$ERROR TO XPV(5);                * ERROR TEXT FROM THE SPLIT OR UPLOAD
EQU XPV$DONE TO XPV(6);                 * PROCESSED BY THE SPLIT INDICATOR
EQU XPV$COLL.ERR TO XPV(7);             * COLLECTION ERROR CODE
EQU XPV$AI.CODE TO XPV(8);              * CODE FOR THE AI.TYPE
EQU XPV$GROUP TO XPV(9);                * COLLECTION GROUP NUMBER
EQU XPV$TIME TO XPV(10);                * TIME OF UPLOAD
~XPV.VAR.EQUATES~
*CODE.SEGMENT: XPV.VAR.EQUATES
*
* FILE 'XPV' EQUATES - GENERATED 15:56:53  04 MAR 1994
EQU XPV$EVENT.NUMS TO 1;                * EVENT NUMBERS
EQU XPV$DUR TO 2;                       * DURATION OF THE EVENT SHOWN (1-16 SECS)
EQU XPV$ACCOUNT TO 3;                   * THE ACCOUNT THAT WATCHED THE EVENT
EQU XPV$ACC TO 4;                       * COMPANY CODE (PICK ACCOUNT)
EQU XPV$ERROR TO 5;                     * ERROR TEXT FROM THE SPLIT OR UPLOAD
EQU XPV$DONE TO 6;                      * PROCESSED BY THE SPLIT INDICATOR
EQU XPV$COLL.ERR TO 7;                  * COLLECTION ERROR CODE
~XTR.EQUATES~
*CODE.SEGMENT: XTR.EQUATES
*
* FILE 'XTR' EQUATES - GENERATED 05:22:00  25 JUL 1991
~XTR.ERR.DIM~
*CODE.SEGMENT: ?
DIM XTR.ERR(5)
~XTR.ERR.EQUATES~
*CODE.SEGMENT: XTR.ERR.EQUATES
*
* FILE 'XTR.ERR' EQUATES - GENERATED 21:24:13  06 DEC 1991
EQU XTR.ERR$DATE.SEQ TO XTR.ERR(1);     * Date*sequence number from transmission
EQU XTR.ERR$ERR TO XTR.ERR(2);          * Error number detected in split
~XTR.ERR.VAR.EQUATES~
*CODE.SEGMENT: XTR.ERR.VAR.EQUATES
*
* FILE 'XTR.ERR' EQUATES - GENERATED 21:24:13  06 DEC 1991
EQU XTR.ERR$DATE.SEQ TO 1;              * Date*sequence number from transmission
EQU XTR.ERR$ERR TO 2;                   * Error number detected in split
~XTR.INCL.POST.READ~
*CODE.SEGMENT: XTR.INCL.POST.READ
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
LOOP
LCK.STAT = -LCK.TYPE; CALL LOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID,LCK.FILE,LCK.STAT)
WHILE LCK.STAT DO REPEAT
READ XTR.POST FROM CNT.FILE,XTR.POST.ID ELSE XTR.POST = EMPTY
*
~XTR.INCL.POST.WRITE~
*CODE.SEGMENT: XTR.INCL.POST.WRITE
*
* COMPANY: Axion Computer System
* Author:  David Horsman
* Date:    21 NOV 91
*
IF NOT(CNT.TST$FILE) THEN
WRITE XTR.POST ON CNT.FILE,XTR.POST.ID
END
CALL UNLOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID,LCK.FILE)
*
~XTR.TRANS.DIM~
*CODE.SEGMENT: ?
DIM XTR.TRANS(20)
~XTR.TRANS.EQUATES~
*CODE.SEGMENT: XTR.TRANS.EQUATES
*
* FILE 'XTR.TRANS' EQUATES - GENERATED 21:24:30  06 DEC 1991
EQU XTR.TRANS$REC.CN TO XTR.TRANS(1);   * Record counter
EQU XTR.TRANS$FAILED TO XTR.TRANS(2);   * Transmission split has failed
EQU XTR.TRANS$TOT.REMT TO XTR.TRANS(3); * Total remitances
EQU XTR.TRANS$REMT.CN TO XTR.TRANS(4);  * total number of remitances
EQU XTR.TRANS$BAT.LAST TO XTR.TRANS(5); * Last batch number
EQU XTR.TRANS$TRANS.DT TO XTR.TRANS(6); * Transmission date
EQU XTR.TRANS$TRANS.TM TO XTR.TRANS(7); * Transmission time
EQU XTR.TRANS$DEP.DT TO XTR.TRANS(8);   * Deposit date
EQU XTR.TRANS$CALC.REMT.CN TO XTR.TRANS(9);  * Actual count of remitances
EQU XTR.TRANS$CALC.TOT.REMT TO XTR.TRANS(10);* Calculated total remitances
EQU XTR.TRANS$BAT TO XTR.TRANS(11);          * 
EQU XTR.TRANS$ERR TO XTR.TRANS(12);          * Error array for batch
EQU XTR.TRANS$BAT.REMT.CN TO XTR.TRANS(13);  * Erorr batch remitance counts
EQU XTR.TRANS$BAT.TOT.REMT TO XTR.TRANS(14); * Error batch total remitances
EQU XTR.TRANS$BAT.ERR TO XTR.TRANS(15);      * Error batch error array
EQU XTR.TRANS$FOUND TO XTR.TRANS(16);        * Count of found header records
EQU XTR.TRANS$SPLIT TO XTR.TRANS(17);        * Has this transmission been split
~XTR.TRANS.VAR.EQUATES~
*CODE.SEGMENT: XTR.TRANS.VAR.EQUATES
*
* FILE 'XTR.TRANS' EQUATES - GENERATED 21:24:30  06 DEC 1991
EQU XTR.TRANS$REC.CN TO 1;              * Record counter
EQU XTR.TRANS$FAILED TO 2;              * Transmission split has failed
EQU XTR.TRANS$TOT.REMT TO 3;            * Total remitances
EQU XTR.TRANS$REMT.CN TO 4;             * total number of remitances
EQU XTR.TRANS$BAT.LAST TO 5;            * Last batch number
EQU XTR.TRANS$TRANS.DT TO 6;            * Transmission date
EQU XTR.TRANS$TRANS.TM TO 7;            * Transmission time
EQU XTR.TRANS$DEP.DT TO 8;              * Deposit date
EQU XTR.TRANS$CALC.REMT.CN TO 9;        * Actual count of remitances
EQU XTR.TRANS$CALC.TOT.REMT TO 10;      * Calculated total remitances
EQU XTR.TRANS$BAT TO 11;                * 
EQU XTR.TRANS$ERR TO 12;                * Error array for batch
EQU XTR.TRANS$BAT.REMT.CN TO 13;        * Erorr batch remitance counts
EQU XTR.TRANS$BAT.TOT.REMT TO 14;       * Error batch total remitances
EQU XTR.TRANS$BAT.ERR TO 15;            * Error batch error array
EQU XTR.TRANS$FOUND TO 16;              * Count of found header records
EQU XTR.TRANS$SPLIT TO 17;              * Has this transmission been split
~XTR.VAR.EQUATES~
*CODE.SEGMENT: XTR.VAR.EQUATES
*
* FILE 'XTR' EQUATES - GENERATED 05:22:01  25 JUL 1991
