~BL~
*PROGRAM: BL
*
TERM = "R"
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
START: *
*
PRINT "FILE: ":
INPUT FILE.NAME
IF FILE.NAME EQ "KILL" OR FILE.NAME EQ EMPTY THEN STOP
*
PRINT "ITEM: ":
INPUT ITEM.NAME
IF ITEM.NAME EQ "KILL" OR ITEM.NAME EQ EMPTY THEN STOP
*
!
*
LOAD.ITEM: *
*
OPEN FILE.NAME TO INP.FILE ELSE GOTO START
*
READ ITEM FROM INP.FILE,ITEM.NAME ELSE GOTO START
*
!
*
INP.ATTR: *
*
PRINT
PRINT "ATTRIBUTE ":
INPUT ATTR
IF ATTR EQ "KILL" THEN STOP
IF ATTR EQ EMPTY THEN GOTO UPD.ITEM
IF NOT(NUM(ATTR)) THEN GOTO INP.ATTR
IF ATTR LE ZERO THEN GOTO INP.ATTR
*
*
PRINT "          1         2         3         4        5        6         7"
PRINT "01234567890123456789012345678901234567890123456790123456790123456789"
*
PRINT ITEM<ATTR>
PRINT
*
*
PRINT "COLUMN (NUMERIC) OR STRING: ":
INPUT POSN
*
IF NOT(NUM(POSN)) OR POSN EQ '' THEN
TEMP = POSN
POSN = INDEX(ITEM<ATTR>,TEMP,1)
IF NOT(POSN) THEN GOTO INP.ATTR
POSN = POSN + LEN(TEMP) - 1
* PRINT
* PRINT POSN
* PRINT
END
PRINT
PRINT ATTR "R#4":" ":ITEM<ATTR>
PRINT
PRINT
*
!
*
UPD.ATTR: *
*
ITEM<ATTR> = ITEM<ATTR>[1,POSN]:AM:ITEM<ATTR>[POSN+1,9999]
*
PRINT ATTR "R#4":" ":ITEM<ATTR>
PRINT ATTR+1 "R#4":" ":ITEM<ATTR+1>
PRINT
*
GOTO INP.ATTR
*
!
*
UPD.ITEM: *
*
WRITE ITEM ON INP.FILE,ITEM.NAME
*
GOTO START
*
END
~BU.DATE.CONVERT~
X*PROGRAM: DATE.CONVERT
*
*DGH OF AIM - MAY 19/85
*
10 PRINT
PRINT
INPUT A
IF LEN(A) = 0 THEN
PRINT
TEMP = DATE()
TEMP1 = TIME()
PRINT "The date is ":OCONV(TEMP,"D2"):", or internally ":TEMP
PRINT
PRINT "The time is ":OCONV(TEMP1,"MTS"):", or internally ":TEMP1
PRINT
PRINT
END ELSE IF NUM(A) THEN
PRINT
PRINT A:" is ":OCONV(A,"D2")
PRINT
GOTO 10
END ELSE IF ICONV(A,"D") # 0 THEN
PRINT
PRINT A:" is ":ICONV(A,"D")
PRINT
GOTO 10
END
END
~BU.GET.ICONV~
XSUBROUTINE GET.ICONV(FLD,CONV)
* PROGRAM:           GET.ICONV
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       VALIDATED "ICONV" FUNCTION FOR ULTIMATE
* DATE WRITTEN:      29 NOV 83
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
FLD = TRIM(FLD)
IF CONV[1,1] = "D" THEN
XFLD = FLD
IF CONV MATCHES "'D'1N'N'" THEN FLD = ICONV(FLD,CONV[1,2]) ELSE FLD = ICONV(FLD,CONV)
IF NOT(NUM(FLD)) THEN FLD = ""; RETURN
MTHS = "JAN}FEB}MAR}APR}MAY}JUN}JUL}AUG}SEP}OCT}NOV}DEC"; MTH = ""; POS = 1
LOOP TEMP = XFLD[POS,1] WHILE TEMP MATCHES "1N" DO POS = POS+1 REPEAT
IF TEMP MATCHES "1A" THEN MTH = XFLD[POS,3] ELSE TEMP = XFLD[POS+1,1]; IF TEMP MATCHES "1A" THEN MTH = XFLD[POS+1,3]
IF MTH = "" THEN MTH = XFLD[1,POS-1] ELSE LOCATE MTH IN MTHS<1> SETTING MTH ELSE MTH = ""
IF MTH # OCONV(FLD,"D2-")[1,2] THEN FLD = ""
RETURN
END
IF CONV[1,2] = "MT" THEN
FOR POS = 1 TO 3
TEMP = FIELD(FLD,":",POS); IF NOT(TEMP MATCH "0N") THEN FLD = ""; RETURN
BEGIN CASE
CASE POS = 1; IF TEMP < 0 OR TEMP > 23 THEN FLD = ""; RETURN
CASE POS = 2; IF TEMP < 0 OR TEMP > 59 THEN FLD = ""; RETURN
CASE POS = 3; IF TEMP THEN IF TEMP < 0 OR TEMP > 59 THEN FLD = ""; RETURN
END CASE
NEXT POS
END ELSE IF CONV[1,1] = "M" THEN IF FLD = "" THEN RETURN ELSE IF NOT(NUM(FLD)) THEN FLD = ""; RETURN
FLD = ICONV(FLD,CONV)
RETURN
END
~BU.INPUT.DATA~
XSUBROUTINE INPUT.DATA (ITEM,CL,LN,LH,LOCN,CONV,EDITS,EDIT.FILE,RSP,STAT)
* PROGRAM:           INPUT.DATA
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       STANDARDIZED DATA INPUT
*            STAT    MEANING
*               0    GOOD RESPONSE
*              -1    REQUEST BACKUP
*               1    BAD RESPONSE (ERROR MESSAGE IN RSP<2>)
*             999    REQUEST KILL
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
SUPPRESS.ERROR.PRINT = 0
AC = FIELD(LOCN,",",1); VC = FIELD(LOCN,",",2); SC = FIELD(LOCN,",",3)
SB = INDEX(LOCN,",",3); IF NOT(SB) THEN SB = "" ELSE SB = LOCN[SB+1,9]
IF LH[1,1] MATCHES "1A" THEN MS = LH[1,1]:"#":LH[2,99]; LH = LH[2,99] ELSE MS = "L#":LH
IF AC THEN FLD = ITEM<AC,VC,SC> ELSE FLD = ""
IF SB # "" THEN FLD = FIELD(FLD,SB[1,1],SB[2,9])
IF FLD[1,1] # "!" THEN NO.PROMPT = 0 ELSE
IF STAT = -1 THEN RETURN
FLD = FLD[2,999]; NO.PROMPT = 1
END
IF CONV[1,1] = "M" OR CONV[1,1] = "D" THEN NON.NUMERIC.CONV = 0 ELSE NON.NUMERIC.CONV = 1
STAT = 0
DEF = FLD; IF DEF # "" THEN IF CONV # "" THEN IF NUM(DEF) OR NON.NUMERIC.CONV THEN DEF = OCONV(DEF,CONV)
DISP.DEF = DEF:STR(".",LH-LEN(DEF))
LOOP
PRINT @(CL,LN):DISP.DEF MS:@(CL,LN):; IF LH > 4 THEN ML = LH ELSE ML = 4
IF NO.PROMPT THEN RSP = DEF ELSE
INPUT RSP,ML:_; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP = "\" THEN RSP = "" ELSE IF RSP = "" OR RSP = "^" THEN
IF RSP = "^" THEN STAT = -1
RSP = DEF; PRINT @(CL,LN):RSP MS:; DEFAULT.USED = 1
IF STAT = -1 THEN RETURN
END ELSE DEFAULT.USED = ""
GOSUB 1000; * EDITS
END
WHILE STAT > 0 DO
IF SUPPRESS.ERROR.PRINT THEN RSP<2> = TEXT; RETURN ELSE GOSUB 9000; STAT = 0
REPEAT
FLD = RSP; IF NOT(NON.NUMERIC.CONV) THEN CALL GET.ICONV(FLD,CONV)
IF CONV = "" THEN RSP = FLD ELSE IF NUM(FLD) OR NON.NUMERIC.CONV THEN RSP = OCONV(FLD,CONV)
PRINT @(CL,LN):RSP MS:
IF SB # "" THEN
IF AC THEN PRE.FLD = ITEM<AC,VC,SC> ELSE PRE.FLD = ""
CNT = SB[2,9]; SB = SB[1,1]; PART.FLD = FLD; FLD = ""
FLD.CNT = COUNT(PRE.FLD,SB)+1; IF FLD.CNT < CNT THEN FLD.CNT = CNT
FOR NUM = 1 TO FLD.CNT
IF NUM > 1 THEN FLD = FLD:SB
IF NUM = CNT THEN FLD = FLD:PART.FLD ELSE FLD = FLD:FIELD(PRE.FLD,SB,NUM)
NEXT NUM
END
IF AC THEN
ITEM<AC,VC,SC> = FLD; POS = LEN(ITEM<AC>)
LOOP WHILE ITEM<AC>[POS,1] > CHAR(250) DO POS = POS-1; ITEM<AC> = ITEM<AC>[1,POS] REPEAT
END
RETURN
!
1000 * EDITS
ED.VC = 1; IF EDITS<1,ED.VC> = "SE" THEN SUPPRESS.ERROR.PRINT = 1; ED.VC = ED.VC+1
IF LEN(RSP) > LH THEN STAT = 1; TEXT = "Max. length is ":LH:" characters"; RETURN
IF SB # "" THEN IF COUNT(RSP,SB[1,1]) THEN STAT = 1; TEXT = "Character '":SB[1,1]:"' may not be used"; RETURN
LOOP ED = EDITS<1,ED.VC> UNTIL ED = "" DO
ED1 = ED<1,1,1>; ED2 = ED<1,1,2>; ED3 = ED<1,1,3>
IF ED1 # "" THEN IF ED1 MATCHES "2A" THEN GOSUB 1100
IF STAT < 1 THEN ED.VC = ED.VC+1 ELSE RETURN
REPEAT
RETURN
!
1100 * INTERNAL EDIT CALLS
BEGIN CASE
CASE ED1 = "OP"; IF RSP = "" THEN ED.VC = 99
CASE ED1 = "RQ"; IF RSP = "" THEN STAT = 1; TEXT = "An entry is required"
CASE ED1 = "LO"; IF RSP < ED2 THEN STAT = 1; TEXT = "Lowest valid entry is ":ED2
CASE ED1 = "HI"; IF RSP > ED2 THEN STAT = 1; TEXT = "Highest valid entry is ":ED2
CASE ED1 = "NC"
IF NOT(DEFAULT.USED) THEN RSP = RSP/100
TEMP = RSP[LEN(RSP),1]; IF TEMP = " " OR TEMP = "-" THEN RSP = TRIM(TEMP):RSP[1,LEN(RSP)-1]
IF NOT(NUM(RSP)) THEN STAT = 1; TEXT = "Entry must be in cents"
CASE ED1 = "ND"
TEMP = RSP[LEN(RSP),1]; IF TEMP = " " OR TEMP = "-" THEN RSP = TRIM(TEMP):RSP[1,LEN(RSP)-1]
IF NOT(NUM(RSP)) THEN STAT = 1; TEXT = "Entry must be in dollars and cents"
CASE ED1 = "NU"
TEMP = RSP[LEN(RSP),1]; IF TEMP = " " OR TEMP = "-" THEN RSP = TRIM(TEMP):RSP[1,LEN(RSP)-1]
IF NOT(NUM(RSP)) THEN STAT = 1; TEXT = "Entry must be numeric"
CASE ED1 = "DT"
IF RSP # "" THEN TEMP = RSP; CALL GET.ICONV(TEMP,"D"); IF TEMP = "" THEN STAT = 1; TEXT = "Invalid date"
CASE ED1 = "DD"; IF RSP = "" THEN RSP = OCONV(DATE(),"D0.")
CASE ED1 = "LF"; IF ED3 THEN RSP = STR(ED2,ED3-LEN(RSP)):RSP ELSE RSP = ED2:RSP
CASE ED1 = "RF"; IF ED3 THEN RSP = RSP:STR(ED2,ED3-LEN(RSP)) ELSE RSP = RSP:ED2
CASE ED1 = "FI"; READV DUMMY FROM EDIT.FILE,RSP,1 ELSE STAT = 1; TEXT = "Not valid"
CASE ED1 = "DF"
IF RSP = "" THEN
IF ED2[1,1] # "*" THEN RSP = ED2 ELSE
ED4 = ED<1,1,4>; IF ED4 < 1 THEN ED4 = 1
READV RSP FROM EDIT.FILE,ED3,ED4 ELSE RSP = ""
END
END
CASE ED1 = "EQ"
IF NOT(ED2[1,1] = "*" OR ED2[1,1] = "@") THEN DEL ED<1,1,1> ELSE
IF ED2[1,1] = "*" THEN
ED4 = ED<1,1,4>; IF ED4 < 1 THEN ED4 = 1
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = ""
END ELSE ED = FIELD(EDITS,"@",2); ED.VC = ED.VC+COUNT(ED,VM)
END
TEXT = ""; SCAN.VC = 1; IF COUNT(ED,VM) THEN SCAN.SC = 0 ELSE SCAN.SC = 1
LOOP TEMP = ED<1,SCAN.VC,SCAN.SC>[1,LH] UNTIL TEMP = RSP OR TEMP = "" DO
TEXT = TEXT:TEMP:", "
IF SCAN.SC THEN SCAN.SC = SCAN.SC+1 ELSE SCAN.VC = SCAN.VC+1
REPEAT
IF TEMP = "" THEN
IF LEN(TEXT) > 65 THEN TEXT = "valid  "
STAT = 1; TEXT = "Entry must be ":TEXT[1,LEN(TEXT)-2]
END
CASE ED1 = "MA"
IF NOT(ED2[1,1] = "*" OR ED2[1,1] = "@") THEN DEL ED<1,1,1> ELSE
IF ED2[1,1] = "*" THEN
ED4 = ED<1,1,4>; IF ED4 < 1 THEN ED4 = 1
READV ED FROM EDIT.FILE,ED3,ED4 ELSE ED = ""
END ELSE ED = FIELD(EDITS,"@",2); ED.VC = ED.VC+COUNT(ED,VM)
END
TEXT = ""; SCAN.VC = 1; IF COUNT(ED,SVM) THEN SCAN.SC = 1 ELSE SCAN.SC = 0
LOOP TEMP = ED<1,SCAN.VC,SCAN.SC> UNTIL RSP MATCHES TEMP OR TEMP = "" DO
TEXT = TEXT:TEMP:", "
IF SCAN.SC THEN SCAN.SC = SCAN.SC+1 ELSE SCAN.VC = SCAN.VC+1
REPEAT
IF TEMP = "" THEN
IF LEN(TEXT) > 60 THEN TEXT = "a valid string  "
STAT = 1; TEXT = "Entry must match ":TEXT[1,LEN(TEXT)-2]
END
END CASE
RETURN
!
9000 * ERROR ROUTINE
IF TEXT = "" THEN RETURN
PRINT BELL:@(0,23):CLL:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN TO 9999 ELSE PRINT @(0,23):CLL:
9999 RETURN
END
~BU.LOCK.ITEM~
XSUBROUTINE LOCK.ITEM (FILE.NUM,FILE.NAME,ITEM.NAME,LOCK.FILE,STAT)
* PROGRAM:           LOCK.ITEM
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       LOCK AN ITEM
*
*             STAT      MEANING
*                0      SUCCESSFULLY LOCKED
*                1      ALREADY LOCKED AT ANOTHER TERMINAL
*              999      OPERATOR 'KILL' REQUEST
*               -1      INPUT STAT - NO MESSAGE IF ALREADY LOCKED
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
READ.IT: * ATTEMPT TO READ THE LOCK ITEM
MSG = ""
FOR TRY = 1 TO 5
IF MSG # "" THEN IF STAT # -1 THEN PRINT @(0,23):CLL:MSG:" - Retry No.":TRY-1:
* MSG = ""; * REV ONLY
* LOCK FILE.NUM, ITEM.NAME ELSE MSG = FILE.NAME:" ":ITEM.NAME:" in use."; * REV ONLY
* IF MSG # "" THEN GOTO NEXT.TRY ELSE STAT = 0; RETURN; * REV ONLY
FOR COUNTER = 1 TO 3
READ LOCK.ITEM FROM LOCK.FILE,FILE.NAME:"*":ITEM.NAME ELSE GOTO LOCK.IT
IF LOCK.ITEM<1> = PORT THEN GOTO LOCK.IT
RQM
NEXT COUNTER
IF MSG = "" THEN IF STAT # -1 THEN
PORT.NUM = LOCK.ITEM<1>
ACCT.NUM = LOCK.ITEM<2>
LOCK.DATE = OCONV(LOCK.ITEM<3>,"D2"); LOCK.DATE = LOCK.DATE[1,2]:LOCK.DATE[4,3]:LOCK.DATE[8,2]
LOCK.TIME = OCONV(LOCK.ITEM<4>,"MT")
MSG = FILE.NAME:" ":ITEM.NAME:" in use by ":ACCT.NUM:" (":PORT.NUM:" ":LOCK.DATE:" ":LOCK.TIME:")"
END
NEXT.TRY: *
NEXT TRY
IF STAT = -1 THEN STAT = 1; RETURN
PRINT BELL:@(0,23):CLL:MSG:" - Again (<cr>/N)? ":
INPUTCLEAR
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "N" THEN PRINT @(0,23):CLL:; GOTO READ.IT
STAT = 1
RETURN
!
LOCK.IT: * LOCK THE ITEM
IF MSG # "" THEN PRINT @(0,23):CLL:
LOCK.ITEM    = PORT
LOCK.ITEM<2> = ACCT
LOCK.ITEM<3> = DATE()
LOCK.ITEM<4> = TIME()
WRITE LOCK.ITEM ON LOCK.FILE,FILE.NAME:"*":ITEM.NAME
STAT = 0
RETURN
END
~BU.PRINTER.FONT~
X*PROGRAM:           PRINTER.FONT
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       SETS G.E. 3000 PRINTER FONT
* DATE WRITTEN:      16 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
CO.NAME = OCONV("CO.DATA","TMD;X;1;1")
CO.NAME = CO.NAME<1,1,1>
TITLE = "Select printer font for GE-3000 series printers"
PRINT @(0,0):CLS:("Acct: ":ACCT) "L#20":(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) "L#40":OCONV(DATE(),"D2") "R#20":
PRINT @(0,1):("Port: ":PORT) "L#15":(SPACE(25-LEN(TITLE)/2+.5):TITLE) "L#50":OCONV(TIME(),"MTS") "R#15"
!
FONT.CODES = "11}12}13}14"
PRINT @(20,4):"1. 17 CPI NLQ font":@(20,5):"2. 17 CPI draft font":
PRINT @(20,6):"3. 12 CPI NLQ font":@(20,7):"4. 12 CPI draft font":
PRINT @(20,8):"5. 10 CPI NLQ font":@(20,9):"6. 10 CPI draft font":
*
LOOP
PRINT @(20,22):CLL:"Enter your choice: ":
INPUT RSP:
IF RSP = "" THEN STOP
WHILE RSP < 1 OR RSP > 6 DO PRINT BELL: REPEAT
*
FONT.CODES = "14}12}13}11}13}11"
PITCH.CODES = "44}44}60}60}72}72"
*
FONT.CODE = CHAR(27):"[;":FONT.CODES<1,RSP>:"m"
PITCH.CODE = CHAR(27):"[;":PITCH.CODES<1,RSP>:" G"
* PAGE.CODE = CHAR(27):"[7920r"
*
PRINTER ON
PRINT FONT.CODE:PITCH.CODE:
PRINTER OFF
*
PRINT @(20,23):CLL:"Set to mode ":RSP:" - hit <cr> to end   ":
INPUT RSP:
END
~BU.PROGLIST~
X*PROGRAM:           PROGLIST
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND PRINT BASIC PROGRAMS IN FILE 'BP'
* DATE WRITTEN:      22 OCT 82
* DATE RELEASED:     22 OCT 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT EQUATES:
IF EQUATES[1,1] # "O" THEN OLD = "" ELSE OLD = 1; EQUATES = EQUATES[2,1]
*
OPEN "BP" TO BP.FILE ELSE STOP
OPEN "OLD.BP" TO OLD.FILE ELSE STOP
OPEN "IBP" TO IBP.FILE ELSE STOP
*
DIM LINES(1200),INCL.LINES(600); MAX.LINES = 60
FONT.17 = CHAR(27):"[;12m":CHAR(27):"[;44 G"; FONT.12 = CHAR(27):"[;11m":CHAR(27):"[;60 G"
IF EQUATES[1,1] = "X" THEN EQUATES = EQUATES[2,1]; REQD.FONT = FONT.12; MAX.COLS = 98 ELSE REQD.FONT = FONT.17; MAX.COLS = 130
PRINTER ON; PRINT REQD.FONT:; PRINTER OFF
IF EQUATES # 1 THEN EQUATES = 0
!
MAIN: * READ EACH PROGRAM SELECTED
READNEXT PROG ELSE PRINTER ON; PRINT FONT.17:; STOP
FILE.NAME = ""; IF NOT(OLD) THEN MATREAD LINES FROM BP.FILE,PROG THEN FILE.NAME = "BP"
IF FILE.NAME = "" THEN FILE.NAME = "OLD.BP"; MATREAD LINES FROM OLD.FILE,PROG ELSE GOTO MAIN
PRINT; PRINT PROG
PROG = "Program Listing - '":FILE.NAME:" ":PROG:"'"; LINE.NUM = MAX.LINES; PAGE.NUM = 1; TAB = 0; NUM = 1; CASE.FLAG = 0
LOOP LINE = LINES(NUM) UNTIL LINE = "" DO
GOSUB PRINTLINE
IF LINE[1,1] = "$" THEN IF EQUATES THEN
SAVE.NUM = NUM; NUM = "$   "; INCL.PROG = FIELD(LINE," ",3)
MATREAD INCL.LINES FROM IBP.FILE,INCL.PROG ELSE MAT INCL.LINES = ""
LINE = "*"; GOSUB PRINTLINE; INCL.NUM = 1
LOOP LINE = INCL.LINES(INCL.NUM) UNTIL LINE = "" DO GOSUB PRINTLINE; INCL.NUM = INCL.NUM+1 REPEAT
IF INCL.NUM > 1 THEN LINE = "*"; GOSUB PRINTLINE
NUM = SAVE.NUM
END
NUM = NUM+1
REPEAT
GOTO MAIN
!
PRINTLINE: * ANALYSE AND PRINT LINE
T.LEFT = 0; T.RIGHT = 0; LABEL = ""
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-T.LEFT; IF TAB < 0 THEN TAB = 0
INDENT = TAB*3; P.LINE = NUM "R#4":"  "
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6+INDENT):STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":SPACE(INDENT):LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE # "" THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
PRINTER ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]
P.LINE = SPACE(12+INDENT):P.LINE[POS+1,999]
REPEAT
PRINT P.LINE; TAB = TAB+T.RIGHT; PRINTER OFF; PRINT "*":
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
BEGIN CASE
CASE FIRST = "IF" OR FIRST = "LOCATE" OR FIRST[1,4] = "READ" OR FIRST[1,7] = "MATREAD" OR FIRST = "WRITET" OR FIRST = "WEOF" OR FIRST = "OPEN"
GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "LOOP"; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "WHILE" OR FIRST = "UNTIL"; T.LEFT = 1; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "FOR"; POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN T.RIGHT = 1
CASE FIRST = "BEGIN"; T.RIGHT = 1; CASE.FLAG = 1
CASE FIRST = "CASE"; T.RIGHT = 1; IF CASE.FLAG = 1 THEN CASE.FLAG = 0 ELSE T.LEFT = 1
CASE FIRST = "END"
IF LINE[POS+1,4] = "CASE" THEN T.LEFT = 2; RETURN
T.LEFT = 1; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "NEXT" OR FIRST = "REPEAT"; T.LEFT = 1
END CASE
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
LASTWORD: * GET LAST WORD
POS = LEN(LINE)
LOOP WHILE LINE[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" OR NOT(POS) DO POS = POS-1 REPEAT
LAST = TRIM(LINE[POS+1,999])
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
MSK = "L#":MAX.COLS-50
PRINT FF:TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":LF
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
RETURN
END
~BU.SEARCH~
X*PROGRAM: BU.SEARCH
*
EQU BELL TO CHAR(7), LF TO CHAR(10), FF TO CHAR(12), CR TO CHAR(13)
EQU SVM TO  CHAR(252), VM TO CHAR(253), AM TO CHAR(254)
WHO = ICONV(0,"U50BB")
PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2)
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
EQU YES TO "*YES*Y*Yes*yes*y*OK*", NO TO "*NO*N*No*no*n*NOT OK*"
EQU TRUE.RSP TO "*T*t*1*TRUE*True*true*NOT FALSE*not false*YES*Y*Yes*yes*y*OK*"
EQU FALSE.RSP TO "*F*f*0*FALSE*False*false*NOT TRUE*not true*NO*N*No*no*n*NOT OK*"
EQU TRUE TO 1
EQU FALSE TO 0
*
TERMINAL = SYSTEM(7); * REVERSE VIDEO BEGIN/END
*RVB = CHAR(14); RVE = CHAR(15)
*PRINT CHAR(27):"0Q":
BEGIN CASE
CASE TERMINAL = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"
CASE TERMINAL = "R"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
CASE TERMINAL = "V"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
CASE 1; RVB = ""; RVE = ""; PRINT BELL:
END CASE
*
*PROGRAM: SEARCH
*FILE   : MACRO.UTILS
*
*INCLUDE SYS.STANDARD.FUNCTIONS FROM BP.UTL.SOURCE
*
*PROMPT(0)
*#EQU AM TO CHAR(254)
*#EQU VM TO CHAR(253)
*#EQU SVM TO CHAR(252)
*#EQU SV TO CHAR(252)
EQU EOS TO CHAR(12)
VAL1 = 1
VAL0 = 0
PHANTOM.FLAG=VAL0
**
*IF PRINTER.FLAG THEN
*   PRINTER ON
*   PRINT EOS:STR("*",70)
*   PRINT "Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILENAME
*   PRINT
*   PRINTER OFF
*END
*PRINT EOS:STR("*",70)
*   PRINT "Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILENAME
*PRINT
FINDS=""
CN = 0
LOOP
   CN = CN + 1
   PRINT "ENTER STRING TO SEARCH FOR (RET WHEN DONE) ":
   INPUT ANS
UNTIL ANS="" OR ANS[1,1] = "@" DO
   FINDS<1,-1>=ANS
   IF PRINTER.FLAG THEN
      PRINTER ON
      PRINT
      PRINT "STRING ":CN:" IS: ":ANS
      PRINTER OFF
   END
   PRINT
   PRINT "STRING ":CN:" IS: ":ANS
   CN = CN + 1
REPEAT
******
****
**
*
SEARCH.ID = "none"
IF ANS[1,1] EQ "@" THEN
   OPEN "SYS" TO SY.FILE ELSE PRINT BELL:"SYS MISSSING!"; STOP
   SYS.FILE = "SYS"
   SYS.ITEM = ANS[2,9999]
   SEARCH.ID = SYS.ITEM
   READ PROCESS.REC FROM SY.FILE,SYS.ITEM ELSE PRINT BELL:"ITEM MISSING!"; STOP
   FILE.LIST     = PROCESS.REC<3>  ;* PROMPT 6
   FINDS         = PROCESS.REC<4>  ;* PROMPT 1
   VPARAMS       = PROCESS.REC<5>
   EPARAMS       = PROCESS.REC<6>
   IPARAMS       = PROCESS.REC<7>
   FILENAME      = PROCESS.REC<8>  ;* PROMPT 4
   OUT.FILENAME  = PROCESS.REC<9>  ;* PROMPT 5
   PHANTOM.FLAG  = PROCESS.REC<10> ;* (0/1) * PROMPT 2
   PRINTER.FLAG  = PROCESS.REC<11> ;* (0,1) * PROMPT 3
*  VERSION CONTROL PARAMETERS *
   IN.CODE.TYPE  = PROCESS.REC<12> ;* (*%%^^^%%^)
   OUT.CODE.TYPE = PROCESS.REC<13> ;* (*%%^^^%%^)
   NULLS.FLAG    = PROCESS.REC<14> ;* (EQ/NE/NO)
   REM.FLAG      = PROCESS.REC<15> ;* (0/1)
   EXISTING.FLAG = PROCESS.REC<16> ;* (0/1)
*  REPETATIVE RUN OPTIMIZER TABLES *
   USE.TBL.FLAG  = PROCESS.REC<17> ;* (0 ! "" / 1)
*******
****
**
*
END ELSE
   PRINT "RUN IN PHANTOM MODE? ":
   INPUT ANS
   IF INDEX("*Y*y*YES*yes*ok*OK*","*":ANS:"*",1) NE 0 THEN PHANTOM.FLAG=VAL1
   PRINT
   PRINTER.FLAG = 0
   PRINT "PRINT ON THE PRINTER? ":
   INPUT ANS
   IF INDEX("*YES*Y*y*yes*ok*OK*","*":ANS:"*",1) THEN
      PRINTER.FLAG = VAL1
   END
   10 PRINT "ENTER FILE TO SEARCH: ":
   INPUT FILENAME
   *
   11 PRINT "ENTER FILE FOR OUTPUT: ":
   INPUT OUT.FILENAME
*
   12 PRINT "ENTER LIST TO USE (MD): ":
   INPUT FILE.LIST
*
*
   VPARAMS = ""
   EPARAMS = ""
   IPARAMS = ""
   IN.CODE.TYPE = ""
   OUT.CODE.TYPE = ""
   NULLS.FLAG    = ""
   EXISTING.FLAG = ''
   REM.FLAG      = ""
   USE.TBL.FLAG  = ""
END
*******
****
**
*
IF FILENAME = "END" OR FILENAME = CHAR(27) OR FILENAME = CHAR(251) THEN STOP
OPEN "",FILENAME TO FILE ELSE PRINT "CAN'T OPEN ":FILENAME;STOP
*
IF OUT.FILENAME = "END" OR OUT.FILENAME = CHAR(27) OR OUT.FILENAME = CHAR(251) THEN STOP
IF OUT.FILENAME NE "" THEN
OPEN "",OUT.FILENAME TO OUT.FILE ELSE PRINT "CAN'T OPEN ":OUT.FILENAME;STOP
END
*
FOUND = VAL1
OPEN "DICT",FILENAME TO POINTER.FILE ELSE FOUND = VAL0
IF FOUND = VAL0 THEN
   PRINT "CAN'T OPEN ":FILENAME
   PRINT
   OPEN "","POINTER-FILE" TO POINTER.FILE ELSE PRINT "CAN'T OPEN POINTER-FILE";STOP
END
**
*
*
FOR TEMP = 1 TO PRINTER.FLAG+1
 IF TEMP EQ 2 THEN
 PRINTER ON
 PRINT EOS:STR("*",70)
 END ELSE
 PRINT EOS:STR("*",70)
 END
 PRINT "[=| ":STR("_",70)
 PRINT "[=| "
 PRINT "[=| "
 PRINT "[=| ":"Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILENAME
 PRINT "[=| "
 PRINT "[=| "
 PRINT "[=| ":"Item: ":SEARCH.ID
 PRINT "[=| ":"List: ":FILE.LIST
 PRINT "[=| "
 PRINT "[=| ":" Input code type: ":IN.CODE.TYPE
 PRINT "[=| ":"Output code type: ":OUT.CODE.TYPE
 PRINT "[=| ":"   Process nulls: ":NULLS.FLAG
 PRINT "[=| ":"Existing code in: ":EXISTING.FLAG
 PRINT "[=| ":" Process remarks: ":REM.FLAG
 PRINT "[=| ":"Use prior tables: ":USE.TBL.FLAG
 PRINT "[=| "
 PRINT "[=| ":STR("_",70)
 PRINT "[=| "
 *
 CN = 0
 LOOP CN = CN + 1 WHILE FINDS<1,CN> NE "" DO
    PRINT "[=| "
    PRINT "[=| "
    PRINT "[=| ":" Search String: ":FINDS<1,CN>
    PRINT "[=| ":"Sec. Valid: ":VPARAMS<1,CN>
    PRINT "[=| ":"  Extracts: ":EPARAMS<1,CN>
    PRINT "[=| "
    PRINT "[=| ":"   Inserts: ":IPARAMS<1,CN>
    PRINT "[=| "
    PRINT "[=| ":STR("_",70)
 *
 REPEAT
 IF TEMP EQ 2 THEN PRINTER OFF
NEXT TEMP
*
*
IF FINDS="" THEN STOP
LIST=""
LIST.CN = 1
FLIN=""
FTXT=""
IF FILE.LIST NE "" THEN
EXEC.VERB = "GET-LIST ":FILE.LIST
PRINT "[=| "
PRINT "[=| "
PRINT "[=| ":EXEC.VERB
*EXECUTE EXEC.VERB, //SELECT. > ID
PERFORM EXEC.VERB RTNLIST ID.LIST
*EXECUTE EXEC.VERB
*SELECT FILE TO ID
PRINT "[=| "
END
*
FIRST = 1
*READNEXT ID ELSE
IF NOT(FIRST) THEN
IF FILE.LIST EQ "" AND FILENAME NE "" THEN
EXEC.VERB = "GET-LIST ":FILENAME
PRINT "[=| "
PRINT "[=| ":EXEC.VERB
*EXECUTE EXEC.VERB, //SELECT. > ID
*PERFORM EXEC.VERB RTNLIST ID
*EXECUTE EXEC.VERB
*ESELECT FILE TO ID
*
*EXEC.VERB = "GET-LIST ":FILENAME
*PRINT "[=| "
*PRINT "[=| ":EXEC.VERB
*EXECUTE EXEC.VERB, //SELECT. > ID
*
READNEXT ID ELSE
EXEC.PARAM = "SAVE-LIST ":FILENAME
EXEC.VERB = "SSELECT ":FILENAME
PRINT "[=| "
PRINT "[=| ":EXEC.VERB
PRINT "[=| ":">":EXEC.PARAM
EXECUTE EXEC.VERB, //IN. < EXEC.PARAM
*
EXEC.VERB = "GET-LIST ":FILENAME
PRINT "[=| "
PRINT "[=| ":EXEC.VERB
EXECUTE EXEC.VERB, //SELECT. > ID
*
*READNEXT ID ELSE
*PRINT "[=| ":BELL:"FILE IS EMPTY !!!!"
*STOP
*END
END
END
END
*SELECT FILE
DONE=0
*IF PRINTER.FLAG THEN PRINTER ON
LOOP
*IF FIRST THEN FIRST = 0 ELSE
*    READNEXT ID ELSE DONE=1
*END
IF NOT(LEN(ID.LIST)) THEN DONE = 1 ELSE
ID = ID.LIST<1>
ID.LIST = DELETE(ID.LIST,1,0,0)
END
UNTIL DONE DO
   FOUND = 0
   LBL.CN = 0
   LBL.MAX = 0
   IN.LBLS = ''
   OUT.LBLS = ''
   READ ITEM FROM FILE,ID THEN
       FOR FTXT.CN=1 TO (1+COUNT(FINDS,VM))
           THIS=FINDS<1,FTXT.CN>
*IF
           I = INDEX(ITEM,THIS,1)
*END ELSE
*I=
*END
*vvvvv
     IF I THEN
        IF PRINTER.FLAG THEN
           PRINTER ON
           PRINT "[=| "
           IF NOT(FOUND) THEN PRINT "[=| ":"*** FOUND *** ":ID
           PRINT "[=| ":("***":FTXT.CN:"***") "L#10":THIS
           PRINTER OFF
        END
        PRINT "[=| "
        IF NOT(FOUND) THEN PRINT "[=| ":"*** FOUND *** ":ID
        FOUND = 1
        FTXT<LIST.CN,FTXT.CN>=THIS
        PRINT "[=| ":("***":FTXT.CN:"***") "L#10":THIS
        FLIN.CN = 0
        LOOP
           FLIN.CN = FLIN.CN + 1
*IF
           I=INDEX(ITEM,THIS,FLIN.CN)
*END ELSE
*I=
*END
        WHILE I DO
*IF
              J = DCOUNT(ITEM[1,I],AM)
*END ELSE
*J=
*END
*** CONCATENATE UNCHANGES CODE TO NEW.ITEM
               LINE = ITEM<J>
               ORIG.LINE = LINE
              IF PRINTER.FLAG THEN
                 PRINTER ON
                 PRINT "[=| ":J "R#4 ":LINE
                 PRINTER OFF
              END
              PRINT "[=| ":J "R#4 ":LINE
               VALS = VPARAMS<1,FTXT.CN>
               VALID = 1
*
               CALL SEARCH.VALIDATE(LINE,THIS,VALS,VALID)
*
               IF VALID THEN
                  IN.VER     = IN.CODE.TYPE
                  OUT.VER    = OUT.CODE.TYPE
                  CODE.VER   = ''
                  CODE.EXT.C = ''
                  GEN.OLD.FLAG = ''
                  CALL SEARCH.VALIDATE.VERSION(ORIG.LINE,LINE,IN.VER,OUT.VER,VALID,CODE.VER,CODE.EXT.C,NULLS.FLAG,EXISTING.FLAG,REM.FLAG,GEN.OLD.FLAG)
               END
*
               IF VALID THEN
                  PRINT "[=| ":J "R#4 ":">>> ":
                  EVALS = EPARAMS<1,FTXT.CN>
                  CALL SEARCH.PARAM.EXTRACT(LINE,THIS,EVALS,VALID,EXT.PARAMS)
*
                  IF VALID THEN
                     IVALS = IPARAMS<1,FTXT.CN>
                     IN.LINE = LINE
                     LBL.VERB = THIS
                     IF IVALS[1,1] EQ "@" THEN
                        IF IVALS EQ "@DB.ST.LBLS.NUM" THEN
                           CALL CODE.CONV.DB.ST.LBLS.NUM(VALID,LBL.VERB,IN.LINE,OUT.LINE,IN.LBLS,OUT.LBLS,LBL.CN,LBL.MAX)
                           IF VALID THEN LINE = OUT.LINE
                        END ELSE
                           TEMP = "CODE.CONV.":IVALS[2,9999]
                           CALL @TEMP(VALID,IN.LINE,OUT.LINE)
                           IF VALID THEN LINE = OUT.LINE
                        END
                     END ELSE
                        CALL SEARCH.PARAM.OUTPUT(LINE,EXT.PARAMS,IVALS,VALID,ORIG.LINE,OUT.LINE)
                     END
                     *ITEM = 
*
                     IF VALID THEN
*                        ITEM.PREF = ITEM[1,I]
*                        ITEM.SUFF = ITEM[I+1,32267]
*                        ITEM.PREF<J> = ""
*                        ITEM.SUFF<1> = ""
*                        ITEM = ITEM.PREF:OUT.LINE:ITEM.SUFF
*
                         PRINT
                         TCN = 0
                         LOOP TCN = TCN + 1 WHILE OUT.LINE<TCN> NE "" DO
                           OUT.LINE<TCN> = "*%%":OUT.CODE.TYPE:"%%=":OUT.LINE<TCN>
                         REPEAT
                         IF CODE.VER EQ "" THEN
                           CODE.VER = IN.CODE.TYPE
                           CODE.EXT.C = '='
                        END
                         IF ORIG.LINE[1,3] EQ "*%%" THEN
                            TEMP.LINE = ORIG.LINE[10,9999]
                         END ELSE TEMP.LINE = ORIG.LINE
                         IF GEN.OLD.FLAG THEN
                           OUT.LINE = "*%%":CODE.VER:"%%":CODE.EXT.C:TEMP.LINE:AM:OUT.LINE
                         END ELSE
                            IF ORIG.LINE[1,6] NE "*%%":OUT.CODE.TYPE[1,3] THEN
                               OUT.LINE = "*%%":CODE.VER:"%%":CODE.EXT.C:TEMP.LINE:AM:OUT.LINE
                            END ELSE
                               PRINT ">new<"
                            END
                         END
*
*
                         TCN = 0
                         LOOP TCN = TCN + 1 WHILE OUT.LINE<TCN> NE "" DO
                           PRINT "|||> ":TCN "R#3":OUT.LINE<TCN>
PRINTER ON
                           PRINT "|||> ":TCN "R#3":OUT.LINE<TCN>
PRINTER OFF
                         REPEAT
                         ITEM = REPLACE(ITEM,J,0,0,OUT.LINE)
PRINT
PRINT
*PRINT CHAR(7)
*INPUT X
                        TEMP.ADJ = 1
                        LOOP WHILE INDEX(OUT.LINE,THIS,TEMP.ADJ) DO TEMP.ADJ = TEMP.ADJ + 1 REPEAT
                        FLIN.CN = FLIN.CN + TEMP.ADJ - 2
                     END
                  END
                  IF VALID THEN
                     PRINT RVB:"++":RVE
                  END ELSE
                     PRINT "--"
                  END
               END
*
              FLIN<LIST.CN,FTXT.CN,FLIN.CN> = J:VALID
*
        REPEAT
*
*^^^^^
           END
      NEXT FTXT.CN
*
      IF NOT(FOUND) THEN
         IF NOT(PHANTOM.FLAG) THEN
            IF PRINTER.FLAG THEN
               PRINTER ON
               PRINT "[=| ":ID:" not present . . ."
               PRINTER OFF
            END
            PRINT "[=| ":ID:" not present . . ."
         END
      END ELSE
         IF PRINTER.FLAG THEN
            PRINTER ON
            PRINT "[=| "
            PRINT "[=| "
            PRINTER OFF
         END
*         PRINT "[=| "
*         PRINT "[=| "
TEMP9 = COUNT(IN.LBLS,AM)
IF IN.LBLS NE '' THEN TEMP9 = TEMP9 + 1
FOR TEMP7 = 1 TO 2
IF TEMP7 = 2 THEN PRINTER ON
PRINT "[=| ":"X-REF OF STRING TO NUM LABEL"
PRINT "[=| "
FOR TEMP8 = 1 TO TEMP9
*
PRINT "[=| ":(IN.LBLS<TEMP8>:"....................................") "L#30":" ":OUT.LBLS<TEMP8>
*
NEXT TEMP8
IF TEMP7 = 2 THEN PRINTER OFF
NEXT TEMP7
*
*
         LIST<LIST.CN> = ID
         LIST.CN = LIST.CN + 1
         IF OUT.FILENAME NE "" THEN
            WRITE ITEM ON OUT.FILE,ID
*PRINT CHAR(7):
*INPUT X
         END
      END
*
   END
*   PRINT "[=| "
REPEAT
*IF PRINTER.FLAG THEN PRINTER OFF
*
*
IF PRINTER.FLAG THEN B = 2 ELSE B = 1
FOR A = 1 TO B
   IF A = 2 THEN PRINTER ON
   CN = 0
   LOOP CN = CN + 1 UNTIL LIST<CN> EQ "" DO
      IF CN = 1 THEN
         *
         PRINT "[=| ":EOS:STR("*",70)
         PRINT "[=| ":"Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILENAME
         PRINT "[=| "
         PRINT "[=| ":STR("*",20)
         PRINT "[=| ":"       STRINGS"
         PRINT "[=| ":STR("*",20)
         FOR C=1 TO (1+COUNT(FINDS,VM))
            PRINT "[=| ":FINDS<1,C>
         NEXT C
         PRINT "[=| ":STR("*",20)
         PRINT "[=| "
         PRINT "[=| "
         PRINT "[=| ":STR("*",50)
         PRINT "[=| ":"SUMMARY LISTING OF PROGRAMS WHERE STRING(s) FOUND"
         PRINT "[=| ":STR("*",50)
         PRINT "[=| "
      END
      PRINT "[=| ":LIST<CN>
*$INCLUDE DH.IBP SEARCH.PRINT.MAP
*
   REPEAT
   IF A = 2 THEN PRINTER OFF
NEXT A
PRINTER CLOSE
*
*
*
*
*
IF LIST > "" THEN
   PRINT "[=| ":"'SELECT.LIST' FILED"
   WRITE LIST ON POINTER.FILE,"SELECT.LIST@":FILE.LIST
   WRITE FTXT ON POINTER.FILE,"SELECT.FTXT@":FILE.LIST
   WRITE FLIN ON POINTER.FILE,"SELECT.FLIN@":FILE.LIST
END ELSE
   PRINT "[=| ":"NO ITEMS FOUND"
   DELETE POINTER.FILE,"SELECT.LIST"
   DELETE POINTER.FILE,"SELECT.FTXT"
   DELETE POINTER.FILE,"SELECT.FLIN"
END
PRINT "[=| "
PRINT "[=| "
PRINT "[=| ":"* * * * *   Type any key to return to TCL . . .    * * * * * * *"
PRINT "[=| "
PRINT "[=| "
FOR A = 1 TO 100 UNTIL SYSTEM(11)
   PRINT "[=| ":CHAR(7):
   FOR B = 1 TO 5 UNTIL SYSTEM(11)
      PRINT "[=| ":CHAR(7):
      RQM
   NEXT B
   FOR B = 1 TO 25 UNTIL SYSTEM(11)
      RQM
   NEXT B
NEXT A
END
~BU.STAT.PRINT.95X70~
X*CODE.SEGMENT:      STAT.PRINT.95X70
* DESCRIPTION:       PRINT STATEMENTS
*
*                    31 MAY 87  D. HORSMAN    FROM STATEMENTS.9.5X7.0
*
*                    01 MAY 87  H. HORSMAN    ANALYST'S COMMENT
*                               THIS VERSION DOES NOT CONTAIN THE TEST THE
*                               PAY.METHOD STATEMENT FLAG IF THE STATEMENT
*                               FLAG IS 'N', THEN NO STATEMENT SHOULD
*                               BE PRINTED FOR THE SUBSCRIBER!
*
*
*                    01 MAR 87  DAVID HORSMAN  Problem with disconnected
*                               Not receiving statements.
*
*                    25 SEP 86  BOB CONARROE  FROM STATEMENTS.9.5X7.3
*
*
!
GEN.MASK: *
IF FIRST THEN
PL(2) = SPACE(58):STR("X",22)
FOR LN = 4 TO 5
PL(LN) = STR("X",80)
NEXT LN
TM = STR("X",29):"999999-9" "R#9":OCONV(TDY,"D2") "R#11"
PL(8) = "XXX XXX ":STR("X",22):" ":TM
PL(13) = SPACE(8):STR("X",30):"999.99-" "R#36"
PL(14) = SPACE(8):STR("X",30)
PL(15) = SPACE(8):STR("X",30)
PL(16) = SPACE(8):STR("X",30)
PL(25) = SPACE(58):STR("X",22)
PL(28) = STR("X",30):" ":TM
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN PL(LN) = STR("X",44):" " ELSE PL(LN) = SPACE(47)
PL(LN) = PL(LN):CRCOM78:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB PSTMTS
FIRST = ""
END
*
RETURN
!
SU.PL: *
PG = 1
GOSUB GET.ADDRESSES
GOSUB SU.HDR
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(30) = CRCOM78:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 30
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 41 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(LN) = CRCOM78:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(LN) = CRCOM78:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 41 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#21":" ":SDTS
PL(LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(LN) = PL(LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB SU.MG
GOSUB SU.AD
GOSUB PSTMTS
RETURN
!
MPG: *
IF MPG.RUN THEN
PL(25) = SPACE(70):"PAGE ":PG
PL(42) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB SU.AD
FOR TM = 30 TO 42
PL(TM) = SPACE(47):PL(TM)
NEXT TM
GOSUB PSTMTS
PG = PG+1
GOSUB SU.HDR
PL(25) = SPACE(70):"PAGE ":PG
PL(30) = CRCOMF:"... Continued from previous page"
LN = 31
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
SU.HDR: *
SVC.LIST = ""
SVC.CN = 1
LOOP WHILE ACT$SERVICES<1,SVC.CN> # "" AND LEN(SVC.LIST) < 20 DO
IF SVC.CN > 1 THEN SVC.LIST = SVC.LIST:", "
SVC.LIST = SVC.LIST:ACT$SERVICES<1,SVC.CN>:" (":ACT$QNTYS<1,SVC.CN>+0:")"
SVC.CN = SVC.CN + 1
REPEAT
SALN = SN<2> "L#30":FID "R#8":OCONV(TDY,"D2") "R#11"
*
PL(2) = SPACE(58):TDSC(STAT.TY)
PL(25) = PL(2)
*
PL(4) = RTO.ADD1
PL(5) = RTO.ADD2
PL(8) = ADD$DWELLING.TYPE "L#4":FIELD(ACT$RATE.TYPE,"*",1) "L#4":SVC.LIST "L#22":" ":SALN
PL(28) = SN<1> "L#30":" ":SALN
RETURN
!
SU.MG: *
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<5> = AMG<1>
ML<6> = AMG<2>
ML<7> = AMG<3>
ML<8> = AMG<4>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN
PL(LN) = (ML<LN-33>:SPACE(46))[1,46]:" ":PL(LN)
END ELSE PL(LN) = SPACE(47):PL(LN)
NEXT LN
RETURN
!
SU.AD: *
PL(13) = SPACE(8):BN<1> "L#55"
IF PG # 1 OR NOT(MPG.RUN) THEN PL(13) = PL(13):OCONV(BLN,"MR2M") "R#11"
PL(14) = SPACE(8):BN<2>
PL(15) = SPACE(8):BN<3>
PL(16) = SPACE(8):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(20) = SPACE(59):OCONV(PDD,"D2")
RETURN
!
PSTMTS: *
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 2
LOOP
IF LN < 23 OR LN > 24 THEN
PTM = ""
TM = PL(LN)
IF TRIM(TM) # "" THEN
IF LN > 29 AND LN < 43 THEN PRINT TM:CR:REGF: ELSE PRINT TM:
END
PRINT
END
UNTIL LN = 1 DO
LN = LN+1; IF LN > 44 THEN LN = 1
REPEAT
PRINT CR:COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~BU.STAT.PRINT.95X73~
X*CODE.SEGMENT:      STAT.PRINT.95X73
* DESCRIPTION:       PRINT STATEMENTS
*
* AUTHOR:            31 MAY 87  D. HORSMAN  FROM STATEMENTS.9.5X7.3
*                               Split off validation and
*                               standardize all statement formats.
*
*
*
!
GEN.MASK: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF FIRST THEN
PL(2) = SPACE(58):STR("X",22)
FOR LN = 4 TO 5
PL(LN) = STR("X",80)
NEXT LN
TM = STR("X",29):"999999-9" "R#9":OCONV(TDY,"D2") "R#11"
PL(8) = "XXX XXX ":STR("X",22):" ":TM
PL(13) = SPACE(8):STR("X",30):"999.99-" "R#36"
PL(14) = SPACE(8):STR("X",30)
PL(15) = SPACE(8):STR("X",30)
PL(16) = SPACE(8):STR("X",30)
PL(25) = SPACE(58):STR("X",22)
PL(28) = STR("X",30):" ":TM
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN PL(LN) = STR("X",44):" " ELSE PL(LN) = SPACE(47)
PL(LN) = PL(LN):CRCOM78:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB PSTMTS
FIRST = ""
END
*
RETURN
!
SU.PL: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
PG = 1
GOSUB GET.ADDRESSES
GOSUB SU.HDR
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(30) = CRCOM78:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 30
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 41 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(LN) = CRCOM78:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(LN) = CRCOM78:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 41 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#21":" ":SDTS
PL(LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(LN) = PL(LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 42 THEN
IF LN < 40 THEN LN = LN+2 ELSE LN = LN+1
PL(LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB SU.MG
GOSUB SU.AD
GOSUB PSTMTS
RETURN
!
MPG: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF MPG.RUN THEN
PL(25) = SPACE(70):"PAGE ":PG
PL(42) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB SU.AD
FOR TM = 30 TO 42
PL(TM) = SPACE(47):PL(TM)
NEXT TM
GOSUB PSTMTS
PG = PG+1
GOSUB SU.HDR
PL(25) = SPACE(70):"PAGE ":PG
PL(30) = CRCOMF:"... Continued from previous page"
LN = 31
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
SU.HDR: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
SVC.LIST = ""
SVC.CN = 1
LOOP WHILE ACT$SERVICES<1,SVC.CN> # "" AND LEN(SVC.LIST) < 20 DO
IF SVC.CN > 1 THEN SVC.LIST = SVC.LIST:", "
SVC.LIST = SVC.LIST:ACT$SERVICES<1,SVC.CN>:" (":ACT$QNTYS<1,SVC.CN>+0:")"
SVC.CN = SVC.CN + 1
REPEAT
SALN = SN<2> "L#30":FID "R#8":OCONV(TDY,"D2") "R#11"
*
PL(2) = SPACE(58):TDSC(STAT.TY)
PL(25) = PL(2)
*
PL(4) = RTO.ADD1
PL(5) = RTO.ADD2
PL(8) = ADD$DWELLING.TYPE "L#4":FIELD(ACT$RATE.TYPE,"*",1) "L#4":SVC.LIST "L#22":" ":SALN
PL(28) = SN<1> "L#30":" ":SALN
RETURN
!
SU.MG: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
*
* THE FOLLOWING TEST WAS CHANGED TO TAKE INTO ACCOIUNT STATUS 'N'.
*
*GOOD HARV, (DH)* IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
IF ACT$STAT = "D" THEN MGI = "MSG.D" ELSE MGI = "MSG.C"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<5> = AMG<1>
ML<6> = AMG<2>
ML<7> = AMG<3>
ML<8> = AMG<4>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 30 TO 42
IF LN > 33 AND LN < 42 THEN
PL(LN) = (ML<LN-33>:SPACE(46))[1,46]:" ":PL(LN)
END ELSE PL(LN) = SPACE(47):PL(LN)
NEXT LN
RETURN
!
SU.AD: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
PL(13) = SPACE(8):BN<1> "L#55"
IF PG # 1 OR NOT(MPG.RUN) THEN PL(13) = PL(13):OCONV(BLN,"MR2M") "R#11"
PL(14) = SPACE(8):BN<2>
PL(15) = SPACE(8):BN<3>
PL(16) = SPACE(8):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(20) = SPACE(59):OCONV(PDD,"D2")
RETURN
!
PSTMTS: *
IF TEST.FL<1> EQ "1" AND TEST.FL<5> NE '' THEN
PRINT BELL:"?":; INPUT TMP:
END
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT
PRINT REGF:
LN = 2
LOOP
PTM = ""
TM = PL(LN)
IF TRIM(TM) # "" THEN
IF LN > 29 AND LN < 43 THEN PRINT TM:CR:REGF: ELSE PRINT TM:
END
PRINT
UNTIL LN = 1 DO
LN = LN+1; IF LN > 44 THEN LN = 1
REPEAT
PRINT CR:COMF:
PRINTER OFF
CTR = CTR+2
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~BU.STAT.PRINT.LINDSAY~
X*CODE.SEGMENT:           STAT.PRINT.LINDSAY
* DESCRIPTION:       PRINT STATEMENTS (LINDSAY CATV FORMAT)
*
*                    31 MAY 87  D. HORSMAN    FROM STATEMENTS.LINDSAY
*
*                    01 MAY 87  H. HORSMAN    ANALYST'S COMMENT
*                               THIS VERSION DOES NOT CONTAIN THE TEST THE
*                               PAY.METHOD STATEMENT FLAG IF THE STATEMENT
*                               FLAG IS 'N', THEN NO STATEMENT SHOULD
*                               BE PRINTED FOR THE SUBSCRIBER!
*
*                    01 MAR 87  DAVID HORSMAN  Problem with disconnected
*                               Not receiving statements.
*
*                    25 SEP 86  BOB CONARROE  FROM STATEMENTS.9.5X7.3
*
*                    ** FEB 87   BOB CONARROE **
*
!
GEN.MASK: *
IF FIRST THEN
PL(2) = SPACE(69):OCONV(TDY,"D2")
FOR LN = 4 TO 5
PL(LN) = STR("X",80)
NEXT LN
PL(8) = SPACE(10):STR("X",25):SPACE(8):STR("X",22):SPACE(5):"999999-9"
PL(14) = SPACE(61):"$99999.99"
PL(16) = SPACE(10):STR("X",30)
PL(17) = SPACE(10):STR("X",30)
PL(18) = SPACE(10):STR("X",30)
PL(19) = SPACE(10):STR("X",30):SPACE(22):"DD MMM YY"
PL(31) = SPACE(69):OCONV(TDY,"D2")
PL(35) = PL(8)
FOR LN = 38 TO 46
IF LN # 42 THEN PL(LN) = C12.FONT.CR:STR("X",45)
NEXT LN
FOR LN = 38 TO 54
PL(LN) = PL(LN):CRCOM72:"DDMMMYY ":STR("X",37):"999.99-" "R#9"
NEXT LN
GOSUB PSTMTS
FIRST = ""
END
*
RETURN
!
SU.PL: *
PG = 1
GOSUB GET.ADDRESSES
GOSUB SU.HDR
DXP = ""; DMT = 0
*
BLN = ACT$BALANCE
FOR VC = 1 TO PST.VC-1
TTY = ATR$TYPES<1,VC>
IF COUNT("ABCRW",TTY) THEN
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
BLN = BLN-TMT
END
NEXT VC
PST.DATE = ""
IF ATR$TYPES<1,PST.VC> = "S" THEN
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,PST.VC>,PST.DATE)
PST.DATE = OCONV(PST.DATE,"D2"); PST.DATE = PST.DATE[1,2]:PST.DATE[4,3]:PST.DATE[8,2]
END
PL(38) = CRCOM72:PST.DATE "L#8":"Previous balance" "L#37":OCONV(BLN,"MR2M") "R#9"
*
LN = 39
FOR VC = PST.VC-1 TO LAST.VC STEP -1
CALL UNPACK.NUMBER(ATR$ENTRY.DATES<1,VC>,EDT)
EDT = OCONV(EDT,"D2"); EDT = EDT[1,2]:EDT[4,3]:EDT[8,2]
CALL UNPACK.NUMBER(ATR$EFF.DATES<1,VC>,EFDT)
EFDT = OCONV(EFDT,"D2"); EFDT = EFDT[1,2]:EFDT[4,3]:EFDT[8,2]
TTY = ATR$TYPES<1,VC>
CALL UNPACK.NUMBER(ATR$TOTAL.AMTS<1,VC>,TMT)
TDE = ATR$DESCS<1,VC>
STY = ATR$SVC.TYPES<1,VC,1>; STY1 = STY[1,1]
PBY = ""; IF STY[3,99] MATCHES "6N" AND TTY = "B" THEN PBY = 1
BEGIN CASE
CASE TTY = "A"
IF STY1 = "a" THEN TDE = STY[3,99] ELSE TDE = "Adjustment"
LOCATE TDE IN TT.ADJ<1> SETTING LC THEN TDE = TT.ADJ<2,LC>
CASE TTY = "B"; TDE = "Regular billing"
CASE TTY = "R"; TDE = "Rate change"
CASE TTY = "C"
IF STY1 = "p" THEN TDE = STY[3,99] ELSE
TDE = "Payment"
IF TMT > 0 THEN TDE = TDE:" adj."
END
LOCATE TDE IN TT.PMT<1> SETTING LC THEN TDE = TT.PMT<2,LC>
CASE TTY = "D"
IF STY1 = "d" THEN TDE = STY[3,99] ELSE
TDE = "Deposit"
END
LOCATE TDE IN TT.DEP<1> SETTING LC THEN TDE = TT.DEP<2,LC>
CASE TTY = "W" AND STY[3,99] MATCHES "6N"
TDE = "Rental adjustments"
CASE TTY = "W"
IF NOT(TMT) THEN TTY = ""
TM = TDE<1,1,2>; IF TM # "" THEN TDE = TDE<1,1,1>; TM = " - ":FIELD(TM,",",1)
LOCATE TDE IN WOT$TYPE<1> SETTING LC THEN TDE = WOT$DESC<1,LC>:TM
CASE 1; TTY = ""
END CASE
IF TTY # "" THEN IF TMT THEN
IF EDT # EFDT THEN TDE = TDE:" on ":EFDT
IF TTY # "D" THEN BLN = BLN+TMT
LN = LN+1; IF LN > 53 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
OLN = LN
IF TTY = "D" THEN
IF TMT > 0 THEN TDE = TDE:" collected:" ELSE TDE = TDE:" refunded:"
PL(LN) = CRCOM72:EDT "L#8":TDE "L#20":OCONV(TMT,"MR2ZM") "R#7"
END ELSE PL(LN) = CRCOM72:EDT "L#8":TDE "L#37"
IF NOT(TTY = "A" OR TTY = "C" OR TTY = "D" OR PBY) THEN
SC = 1
LOOP STY = ATR$SVC.TYPES<1,VC,SC> UNTIL STY = "" DO
CALL UNPACK.NUMBER(ATR$SVC.AMTS<1,VC,SC>,AMT)
QNTY = ATR$SVC.QNTYS<1,VC,SC>
STY1 = STY[1,1]
BEGIN CASE
CASE STY1 = "a"
SDE = STY[3,99]; LOCATE SDE IN TT.ADJ<1> SETTING LC THEN SDE = TT.ADJ<2,LC>
CASE STY1 = "c"
SDE = "Charges"
IF STY[3,99] MATCHES "6N" THEN
TMP = STY[3,6]
READV TMPA FROM ACT.FILE,TMP,1 ELSE TMPA = ""
TMPS = FIELD(TMPA,"*",3)
READV TMPSN FROM STT.FILE,TMPS,1 ELSE TMPSN = ""
SDE = (FIELD(TMPA,"*",1):"-":FIELD(TMPA,"*",2):" ":TMPSN)
IF SDE[1,1] = "-" THEN SDE = SDE[2,99]
SDE = TMP:": ":SDE
END
CASE STY1 = "p"
SDE = STY[3,99]
IF SDE = "" THEN SDE = "Payment" ELSE
LOCATE SDE IN TT.PMT<1> SETTING LC THEN SDE = TT.PMT<2,LC>
END
CASE STY1 = "t"
SDE = STY[3,99]; MATREAD TAX FROM TAX.FILE,SDE THEN SDE = TAX$DESC
CASE STY1 = "l"
SDE = "Discount"
IF NOT(DXP) THEN
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,DXP)
IF NOT(DXP) OR DXP > ST.PRDT THEN
DMT = AMT
IF DCR<10> THEN
SDE = "Discount     expires on:"
IF NOT(DXP) THEN
DXP = ST.PRDT+DCR<10>
CALL PACK.NUMBER(DXP,TM); ATR$SVC.FROM.DATES<1,VC,SC> = TM
END
END
END
END
CASE 1
IF STY = "b" THEN STY = "(BASIC)"
MATREAD SVC FROM SVC.FILE,STY ELSE MAT SVC = ""
SDE = SVC$DESC
END CASE
IF AMT OR QNTY THEN
IF SC = 1 THEN IF AMT = TMT THEN IF ATR$SVC.TYPES<1,VC,2> = "" THEN AMT = ""
CALL UNPACK.NUMBER(ATR$SVC.FROM.DATES<1,VC,SC>,FDT)
IF NOT(FDT AND AMT) THEN SDTS = "" ELSE
FDT = OCONV(FDT,"D2"); FDT = FDT[1,2]:FDT[4,3]:FDT[8,2]
CALL UNPACK.NUMBER(ATR$SVC.TO.DATES<1,VC,SC>,TDT)
IF TDT THEN
TDT = OCONV(TDT,"D2")
TDT = TDT[1,2]:TDT[4,3]:TDT[8,2]
SDTS = FDT:"-":TDT
END ELSE SDTS = FDT
END
LN = LN+1; IF LN > 53 THEN GOSUB MPG; IF NOT(MPG.RUN) THEN MPG.RUN = -1; RETURN
IF SDTS # "" THEN SDE = SDE "L#20":" ":SDTS
PL(LN) = CRCOMF:SDE "L#37":OCONV(AMT,"MR2ZM") "R#9"
END
SC = SC+1
REPEAT
END
IF OLN = LN THEN PL(LN) = PL(LN):OCONV(TMT,"MR2ZM") "R#9"
END
NEXT VC
IF BLN > 0 THEN LC = 1 ELSE IF BLN THEN LC = 2 ELSE LC = 3
IF LN < 53 THEN LN = LN+2 ELSE LN = LN+1
PL(LN) = CRCOMF:BMG(LC) "L#37":OCONV(BLN,"MR2M") "R#9"
IF DXP AND LN < 55 THEN
IF LN < 53 THEN LN = LN+2 ELSE LN = LN+1
PL(LN) = CRCOMF:"IF YOU PAY AFTER ":OCONV(DXP,"D0") "L#7":"PLEASE PAY   ":OCONV(BLN-DMT,"MR2M") "R#9"
END
*
GOSUB SU.MG
GOSUB SU.AD
GOSUB PSTMTS
RETURN
!
MPG: *
IF MPG.RUN THEN
PL(31) = SPACE(59):"PAGE ":PG:PL(31)[66,99]
PL(54) = CRCOMF:"Continued on next page ..."
IF PG = 1 THEN GOSUB SU.AD
GOSUB PSTMTS
PG = PG+1
GOSUB SU.HDR
PL(31) = SPACE(59):"PAGE ":PG:PL(31)[66,99]
PL(38) = CRCOMF:"... Continued from previous page"
LN = 39
RETURN
END
*
MPG.IDS<-1> = ACT.ID
MAT PL = ""
RETURN
!
SU.HDR: *
PL(2) = SPACE(69):OCONV(TDY,"D2")
PL(31) = PL(2)
*
PL(4) = RTO.ADD1
PL(5) = RTO.ADD2
PL(8) = SPACE(10):SN<1> "L#30":SPACE(3):SN<2> "L#25":"  ":FID
PL(35) = PL(8)
RETURN
!
SU.MG: *
IF RPR THEN
IF MGI = "" THEN ML = "" ELSE
IF MGI[1,4] # "MSG." THEN MGI = "MSG.":MGI
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
END ELSE
IF ACT$STAT = "A" THEN MGI = "MSG.C" ELSE MGI = "MSG.D"
TM = ACT$CREDIT.STATUS
IF TM < 1 THEN TM = 1
IF TM > 9 THEN TM = 9
LOOP
MGO = MGI:TM
IF MGO[1,4] # "MSG." THEN MGO = "MSG.":MGO
LOCATE MGO[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
WHILE ML = "" AND TM > 0 DO
TM = TM-1
REPEAT
MGI = MGO
END
IF ML = "" THEN
MGI = "MSG.P"
LOCATE MGI[5,9] IN MTP<1> SETTING MN ELSE NULL
ML = MG(MN)
IF ML = "" THEN MGI = ""
END
ALWAYS.ID = "MSG.A"
TMP = 1
LOOP UNTIL MSG.SVC.ID<TMP> = "" DO
LOCATE MSG.SVC.ID<TMP> IN ACT$SERVICES<1> SETTING LOC THEN ALWAYS.ID = "MSG.":MSG.SVC.CODE<TMP>
TMP = TMP+1
REPEAT
LOCATE ALWAYS.ID[5,9] IN MTP<1> SETTING MN ELSE NULL
AMG = MG(MN)
ML<5> = AMG<1>
ML<6> = AMG<2>
ML<7> = AMG<3>
ML<8> = AMG<4>
*
LOOP
POS = INDEX(ML,"@DDMMMYY@",1)
WHILE POS DO
IF RPR THEN DISC.DATE = ACT$DISC.DATE
ML = ML[1,POS-1]:OCONV(DISC.DATE,"D2"):ML[POS+9,999]
ACT$DISC.DATE = DISC.DATE
REPEAT
*
FOR LN = 38 TO 41
PL(LN) = C12.FONT.CR:ML<LN-37> "L#45":PL(LN)
NEXT LN
FOR LN = 43 TO 46
PL(LN) = C12.FONT.CR:ML<LN-38> "L#45":PL(LN)
NEXT LN
RETURN
!
SU.AD: *
IF PG # 1 OR NOT(MPG.RUN) THEN PL(14) = SPACE(60):OCONV(BLN,"MR2M$") "R#10"
PL(16) = SPACE(10):BN<1>
PL(17) = SPACE(10):BN<2>
PL(18) = SPACE(10):BN<3>
PL(19) = SPACE(10):BN<4>
*
IF PYDD = "NONE" THEN
PDD = ""
END ELSE IF PYDD = "BILL" THEN
TM = ACT$BILL.FROM.DATES; PDD = ""
LOOP WHILE TM # "" DO
TM1 = TM<1,1>
DEL TM<1,1,0>
* REMOVE RTEMP FROM TM<1> AT 1 SETTING RFLAG; * REV ONLY
IF TM1 >= ST.PRDT+15 AND TM1 > PDD THEN PDD = TM1
REPEAT
IF PDD = "" THEN PDD = ST.PRDT+15
END ELSE PDD = PYDD
IF PDD THEN PL(19) = PL(19) "L#62":OCONV(PDD,"D2")
RETURN
!
PSTMTS: *
CALL PRINTER.ON(STAT); IF STAT THEN STOP
IF FIRST THEN PRINT LPI8
PRINT REGF
FOR LN = 2 TO 56
IF LN = 37 THEN PRINT C12.FONT.CR ELSE PRINT PL(LN)
NEXT LN
PRINTER OFF
CTR = CTR+1
IF CTR = 50 THEN
IF OPSYS = "U" THEN IF NOT(HF) THEN PRINT @(0,DISP.LN):; PRINTER CLOSE
CTR = 0
END
MAT PL = ""
RETURN
!
*#
*#
*#
~BU.STATEMENTS.9.5X7.0~
X*PROGRAM:           STATEMENTS.9.5X7.0
* DESCRIPTION:       PRINT STATEMENTS
*
*                    31 MAY 87  D. HORSMAN    FROM STATEMENTS.9.5X7.0
*
*                    01 MAY 87  H. HORSMAN    ANALYST'S COMMENT
*                               THIS VERSION DOES NOT CONTAIN THE TEST THE
*                               PAY.METHOD STATEMENT FLAG IF THE STATEMENT
*                               FLAG IS 'N', THEN NO STATEMENT SHOULD
*                               BE PRINTED FOR THE SUBSCRIBER!
*
*
*                    01 MAR 87  DAVID HORSMAN  Problem with disconnected
*                               Not receiving statements.
*
*                    25 SEP 86  BOB CONARROE  FROM STATEMENTS.9.5X7.0
*
*                    ** FEB 87   BOB CONARROE **
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP SAVE.ATR.DIM
$INCLUDE IBP SAVE.ATR.EQUATES
$INCLUDE IBP STT.DIM
$INCLUDE IBP STT.EQUATES
$INCLUDE IBP SVC.DIM
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP TAX.DIM
$INCLUDE IBP TAX.EQUATES
$INCLUDE IBP WOT.DIM
$INCLUDE IBP WOT.EQUATES
$INCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*
SYS.PROG = "STATEMENTS.9.5X7.0"
SYS.LOCT = "INIT"
SYS.SLOC = "OPEN"
*
OPEN "ACT" TO ACT.FILE ELSE PRINT SYS.PROG:" - ACT"; INPUT RSP; STOP
OPEN "ATR" TO ATR.FILE ELSE PRINT SYS.PROG:" - ATR"; INPUT RSP; STOP
OPEN "ATH" TO ATH.FILE ELSE PRINT SYS.PROG:" - ATH"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT SYS.PROG:" - ADD"; INPUT RSP; STOP
OPEN "STT" TO STT.FILE ELSE PRINT SYS.PROG:" - STT"; INPUT RSP; STOP
OPEN "SVC" TO SVC.FILE ELSE PRINT SYS.PROG:" - SVC"; INPUT RSP; STOP
OPEN "TAX" TO TAX.FILE ELSE PRINT SYS.PROG:" - TAX"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT SYS.PROG:" - PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT SYS.PROG:" - CNT"; INPUT RSP; STOP
OPEN "EFT" TO EFT.FILE ELSE PRINT SYS.PROG:" - EFT"; INPUT RSP; STOP
OPEN "LOCKS" TO LOCK.FILE ELSE PRINT "LOCKS"; INPUT RSP; STOP; * ULT ONLY
* LOCK.FILE = 0; * REV ONLY
TDY = DATE(); BAD.ACCTS = ""; REJECTED.ACCTS = ""; * list of accounts with non-numerics in aging date
RJT.FLAG = ""
*
*
DIM MG(20)
MAT MG = ""
*
DIM BMG(3)
MAT BMG = ""
*
DIM TDSC(4)
MAT TDSC = ""
*
*
$INCLUDE BP STAT.BEGIN
*
$INCLUDE BP STAT.CRITERIA
*
$INCLUDE BP STAT.MAIN.LOOP
*
$INCLUDE BP STAT.PRINT.95X70
*
$INCLUDE IBP CLS.ROUTINE
*
END
~BU.STATEMENTS.9.5X7.3~
X*PROGRAM:           STATEMENTS.9.5X7.3
* DESCRIPTION:       PRINT STATEMENTS
*
* AUTHOR:            31 MAY 87  D. HORSMAN  FROM STATEMENTS.9.5X7.3
*
*                    31 MAY 87  D. HORSMAN  Split off validation and
*                                standardize all statement formats.
*
*                    13 MAY 87  D. HORSMAN  Split input subroutine off.
*
*                    01 MAR 87  D. HORSMAN  Problem with disconnected
*                               acct's not receiving statements.
*
*
*                    ** FEB 87  BOB CONARROE **
*
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP SAVE.ATR.DIM
$INCLUDE IBP SAVE.ATR.EQUATES
$INCLUDE IBP STT.DIM
$INCLUDE IBP STT.EQUATES
$INCLUDE IBP SVC.DIM
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP TAX.DIM
$INCLUDE IBP TAX.EQUATES
$INCLUDE IBP WOT.DIM
$INCLUDE IBP WOT.EQUATES
$INCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*
SYS.PROG = "STATEMENTS.9.5X7.3"
SYS.LOCT = "INIT"
SYS.SLOC = "OPEN"
*
OPEN "ACT" TO ACT.FILE ELSE PRINT SYS.PROG:" - ACT"; INPUT RSP; STOP
OPEN "ATR" TO ATR.FILE ELSE PRINT SYS.PROG:" - ATR"; INPUT RSP; STOP
OPEN "ATH" TO ATH.FILE ELSE PRINT SYS.PROG:" - ATH"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT SYS.PROG:" - ADD"; INPUT RSP; STOP
OPEN "STT" TO STT.FILE ELSE PRINT SYS.PROG:" - STT"; INPUT RSP; STOP
OPEN "SVC" TO SVC.FILE ELSE PRINT SYS.PROG:" - SVC"; INPUT RSP; STOP
OPEN "TAX" TO TAX.FILE ELSE PRINT SYS.PROG:" - TAX"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT SYS.PROG:" - PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT SYS.PROG:" - CNT"; INPUT RSP; STOP
OPEN "EFT" TO EFT.FILE ELSE PRINT SYS.PROG:" - EFT"; INPUT RSP; STOP
OPEN "LOCKS" TO LOCK.FILE ELSE PRINT "LOCKS"; INPUT RSP; STOP; * ULT ONLY
* LOCK.FILE = 0; * REV ONLY
TDY = DATE(); BAD.ACCTS = ""; REJECTED.ACCTS = ""; * list of accounts with non-numerics in aging date
RJT.FLAG = ""
*
*
DIM MG(20)
MAT MG = ""
*
DIM BMG(3)
MAT BMG = ""
*
DIM TDSC(4)
MAT TDSC = ""
*
*
$INCLUDE BP STAT.BEGIN
*
$INCLUDE BP STAT.CRITERIA
*
$INCLUDE BP STAT.MAIN.LOOP
*
$INCLUDE BP STAT.PRINT.95X73
*
$INCLUDE IBP CLS.ROUTINE
*
END
~BU.STATEMENTS.LINDSAY~
X*PROGRAM:           STATEMENTS.LINDSAY
* DESCRIPTION:       PRINT STATEMENTS
*
* AUTHOR:            31 MAY 87  D. HORSMAN  FROM STATEMENTS.9.5X7.3
*
*                    31 MAY 87  D. HORSMAN  Split off validation and
*                                standardize all statement formats.
*
*                    13 MAY 87  D. HORSMAN  Split input subroutine off.
*
*                    01 MAR 87  D. HORSMAN  Problem with disconnected
*                               acct's not receiving statements.
*
*
*                    ** FEB 87  BOB CONARROE **
*
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP SAVE.ATR.DIM
$INCLUDE IBP SAVE.ATR.EQUATES
$INCLUDE IBP STT.DIM
$INCLUDE IBP STT.EQUATES
$INCLUDE IBP SVC.DIM
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP TAX.DIM
$INCLUDE IBP TAX.EQUATES
$INCLUDE IBP WOT.DIM
$INCLUDE IBP WOT.EQUATES
$INCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*
SYS.PROG = "STATEMENTS.LINDSAY"
SYS.LOCT = "INIT"
SYS.SLOC = "OPEN"
*
OPEN "ACT" TO ACT.FILE ELSE PRINT SYS.PROG:" - ACT"; INPUT RSP; STOP
OPEN "ATR" TO ATR.FILE ELSE PRINT SYS.PROG:" - ATR"; INPUT RSP; STOP
OPEN "ATH" TO ATH.FILE ELSE PRINT SYS.PROG:" - ATH"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT SYS.PROG:" - ADD"; INPUT RSP; STOP
OPEN "STT" TO STT.FILE ELSE PRINT SYS.PROG:" - STT"; INPUT RSP; STOP
OPEN "SVC" TO SVC.FILE ELSE PRINT SYS.PROG:" - SVC"; INPUT RSP; STOP
OPEN "TAX" TO TAX.FILE ELSE PRINT SYS.PROG:" - TAX"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT SYS.PROG:" - PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT SYS.PROG:" - CNT"; INPUT RSP; STOP
OPEN "EFT" TO EFT.FILE ELSE PRINT SYS.PROG:" - EFT"; INPUT RSP; STOP
OPEN "LOCKS" TO LOCK.FILE ELSE PRINT "LOCKS"; INPUT RSP; STOP; * ULT ONLY
* LOCK.FILE = 0; * REV ONLY
TDY = DATE(); BAD.ACCTS = ""; REJECTED.ACCTS = ""; * list of accounts with non-numerics in aging date
RJT.FLAG = ""
*
*
DIM MG(20)
MAT MG = ""
*
DIM BMG(3)
MAT BMG = ""
*
DIM TDSC(4)
MAT TDSC = ""
*
*
$INCLUDE BP STAT.BEGIN
*
$INCLUDE BP STAT.CRITERIA
*
$INCLUDE BP STAT.MAIN.LOOP
*
$INCLUDE BP STAT.PRINT.LINDSAY
*
$INCLUDE IBP CLS.ROUTINE
*
END
~CHAR.HI~
*PROGRAM: CHAR.HI
*
TERM = "R"
*
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
*
BEGIN CASE
*
CASE TERM = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
CASE TERM = "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "R"
RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "E"
RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TERM = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
*
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
OPEN "SYS" TO IN.FILE ELSE STOP
PRINT "ENTER ITEM NAME: ":
INPUT ITEM.NAME
READ ITEM FROM IN.FILE,ITEM.NAME THEN
ITEM.LEN = LEN(ITEM)
AM.COUNT = DCOUNT(ITEM,AM)
PRINT "SYS ":ITEM.NAME
PRINT
PRINT "LINES: ":AM.COUNT
FOR AM.CN = 1 TO AM.COUNT
PRINT @(0):AM.CN:
LINE = ITEM<AM.CN>
LINE.LEN = LEN(LINE)
FOR TC.CN = 1 TO LINE.LEN
PRINT @(10):TC.CN:
TC = LINE[TC.CN,1]
TC.SEQ =SEQ(TC)
*IF TC.SEQ > 127 AND TC.SEQ < 252 THEN
IF TC.SEQ > 124 THEN
PRINT BELL
PRINT
PRINT "LINE # ":AM.CN:">>>>":LINE
PRINT ">>>>>TC.CN>>> ":TC.CN:"    >>>TC>>>":TC:"     >>>TC.SEQ>>>":TC.SEQ
END
NEXT TC.CN
NEXT AM.CN
END ELSE
PRINT BELL:
END
END
~CHAR.LO~
*PROGRAM: CHAR.LO
*
TERM = "R"
*
BELL = CHAR(7); LF = CHAR(10); FF = CHAR(12); CR = CHAR(13)
SVM = CHAR(252); VM = CHAR(253); AM = CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
*
BEGIN CASE
*
CASE TERM = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
CASE TERM = "P"; RVB = CHAR(133); RVE = CHAR(128); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "p"; RVB = CHAR(0); RVE = CHAR(0); RVH = CHAR(0); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"
CLL = CHAR(27):"K"; CLS = CHAR(27):"J"
*
CASE TERM = "R"
RVB = CHAR(27):"0P":CHAR(0):CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "E"
RVB = CHAR(27):"4":CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):"3"; AUX.OFF = CHAR(20):CHAR(27):"4"
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*
CASE TERM = "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TERM = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
*
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
OPEN "SYS" TO IN.FILE ELSE STOP
PRINT "ENTER ITEM NAME: ":
INPUT ITEM.NAME
READ ITEM FROM IN.FILE,ITEM.NAME THEN
ITEM.LEN = LEN(ITEM)
AM.COUNT = DCOUNT(ITEM,AM)
PRINT "SYS ":ITEM.NAME
PRINT
PRINT "LINES: ":AM.COUNT
FOR AM.CN = 1 TO AM.COUNT
PRINT @(0):AM.CN:
LINE = ITEM<AM.CN>
LINE.LEN = LEN(LINE)
FOR TC.CN = 1 TO LINE.LEN
PRINT @(10):TC.CN:
TC = LINE[TC.CN,1]
TC.SEQ =SEQ(TC)
*IF TC.SEQ > 127 AND TC.SEQ < 252 THEN
IF TC.SEQ < 32 THEN
PRINT BELL
PRINT
PRINT "LINE # ":AM.CN:">>>>":LINE
PRINT ">>>>>TC.CN>>> ":TC.CN:"    >>>TC>>>":TC:"     >>>TC.SEQ>>>":TC.SEQ
END
NEXT TC.CN
NEXT AM.CN
END ELSE
PRINT BELL:
END
END
~CHECK.COMPILE~
*PROGRAM: CHECK.COMPILE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "LISTS" TO LISTS.FILE ELSE PRINT "LISTS file is missing!"; STOP
OPEN "MD" TO MD.FILE ELSE PRINT "MD file is missing!"; STOP
OPEN "SYS" TO SYS.FILE ELSE PRINT "SYS file is missing!"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
PROC.FL = TRUE
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
IF NOT(PROC.FL) THEN
IF TERM.DISP THEN PRINT "Run is not a proc!"
END ELSE
IF TERM.DISP THEN PRINT "Proc buffer is ":PROC.BUFFER
END
*
!
*
PRINT
PRINT "Enter the name of the list: ":
INPUT LIST.NAME:
IF LIST.NAME EQ EMPTY THEN PRINT "LIST is missing!"; STOP
IF LIST.NAME EQ "KILL" THEN PRINT "KILL requested!"; STOP
PRINT
IF TERM.DISP THEN PRINT "The list name is ":LIST.NAME
*
!
*
READ PORT.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":PORT ELSE PORT.TYPE = "INSTALL"
IF TERM.DISP THEN PRINT "Port type is ":PORT.TYPE
*
!
*
READ RUN.TYPE FROM SYS.FILE,LIST.NAME:".RUNTYPE" ELSE RUN.TYPE = "DUMMY"
IF TERM.DISP THEN PRINT "Type of run: ":RUN.TYPE
RTN.TYPE = "INSTALL"
*
!
*
READ TAPE.ID FROM SYS.FILE,LIST.NAME:".TAPE" ELSE TAPE.ID = "DUMMY"
IF TERM.DISP THEN PRINT "Tape ID is ":TAPE.ID
*
*
!
*
PRINT "Enter the file to be processed: ":
INPUT FILE.NAME:
IF FILE.NAME EQ EMPTY THEN PRINT "No file name!"; STOP
IF FILE.NAME EQ "KILL" THEN PRINT "KILL requested!"; STOP
PRINT
IF TERM.DISP THEN PRINT "File being processed: ":FILE.NAME
*
OPEN FILE.NAME TO ITEM.FILE ELSE
PRINT FILE.NAME:" file not found!":BELL
STOP
END
*
!
*
READ MD.REC FROM MD.FILE,FILE.NAME ELSE
PRINT "File is missing from MD!"; STOP
END
*
MD.TYPE = MD.REC<ONE>
MD.ACCT = MD.REC<TWO>
MD.FILE.NAME = MD.REC<3>
IF MD.FILE.NAME[ONE,3] EQ "IN." THEN MD.FILE.NAME = MD.FILE.NAME[4,9999]
IF MD.FILE.NAME[ONE,4] EQ "OUT." THEN MD.FILE.NAME = MD.FILE.NAME[5,9999]
IF MD.FILE.NAME[ONE,4] EQ "OLD." THEN MD.FILE.NAME = MD.FILE.NAME[5,9999]
*
!
*
IN.FIL.OPEN: *
*
OPEN "IN.":FILE.NAME TO INIMP.FILE ELSE
READ MD.REC FROM MD.FILE,"IN.":FILE.NAME ELSE
IF MD.TYPE EQ "Q" THEN
MD.REC = "Q":AM:MD.ACCT:AM:"IN.":MD.FILE.NAME
WRITE MD.REC ON MD.FILE,"IN.":FILE.NAME
GOTO IN.FIL.OPEN
END
END
PRINT "IN file is missing!"; STOP
END
*
!
*
OUT.FIL.OPEN: *
*
OPEN "OUT.":FILE.NAME TO OUTIMP.FILE ELSE
READ MD.REC FROM MD.FILE,"OUT.":FILE.NAME ELSE
IF MD.TYPE EQ "Q" THEN
MD.REC = "Q":AM:MD.ACCT:AM:"OUT.":MD.FILE.NAME
WRITE MD.REC ON MD.FILE,"OUT.":FILE.NAME
GOTO OUT.FIL.OPEN
END
END
PRINT "OUT file is missing!"; STOP
END
*
!
*
OLD.FIL.OPEN: *
*
OPEN "OLD.":FILE.NAME TO OLDIMP.FILE ELSE
READ MD.REC FROM MD.FILE,"OLD.":FILE.NAME ELSE
IF MD.TYPE EQ "Q" THEN
MD.REC = "Q":AM:MD.ACCT:AM:"OLD.":MD.FILE.NAME
WRITE MD.REC ON MD.FILE,"OLD.":FILE.NAME
GOTO OLD.FIL.OPEN
END
END
PRINT "OLD file is missing!"; STOP
END
*
!
*
NOPAGE.FL = FALSE
LPTR.FL = FALSE
FAST.FL = FALSE
FAST.FF = TRUE
PRINT
PRINT "Enter options (T,P,N,F,FE): ":
INPUT LPTR.DVC
LOOP WHILE LEN(LPTR.DVC) DO
TC = LPTR.DVC[ONE,ONE]
LPTR.DVC = LPTR.DVC[TWO,9999]
IF TC = "T" THEN LPTR.FL = FALSE
IF TC = "P" THEN LPTR.FL = TRUE
IF TC = "N" THEN NOPAGE.FL = TRUE
IF TC = "F" THEN FAST.FL = TRUE; FAST.FF = FALSE
IF TC = "E" THEN FAST.FF = TRUE
REPEAT
*
*
!
*
READ FILE.LIST FROM LISTS.FILE,LIST.NAME THEN
IF TERM.DISP THEN PRINT
IF TERM.DISP THEN PRINT "List found in LISTS."
END ELSE
READ FILE.LIST FROM SYS.FILE,LIST.NAME THEN
IF TERM.DISP THEN PRINT
IF TERM.DISP THEN PRINT "List found in SYS.FILE."
END ELSE FILE.LIST = EMPTY
END
*
IF FILE.LIST EQ EMPTY THEN
IF TERM.DISP THEN PRINT
IF TERM.DISP THEN PRINT "The list is empty!"
IF TERM.DISP THEN PRINT
CONT = TRUE; FILE.LIST = EMPTY
EXEC.VERB = 'SSELECT OUT.':FILE.NAME:' EQ "$]"'
*
EXECUTE EXEC.VERB, //OUT. > TMP.ID.LIST
*
LOOP
READNEXT ID FROM TMP.ID.LIST ELSE CONT = FALSE
WHILE CONT DO
FILE.LIST<-ONE> = ID
REPEAT
END
*
PROG.LIST = EMPTY; CSEG.LIST = EMPTY; SUBR.LIST = EMPTY; PROC.LIST = EMPTY
OTHER.LIST = EMPTY; ITEM.LIST = EMPTY; CODE.LIST = EMPTY
LN.CN = 9999; PG = ZERO; LN.CN.MAX = 60
IF NOT(LPTR.FL) THEN LN.CN.MAX = 22
TITLE = "Program Compile Verify"
TITLE1 = FILE.NAME:" from the list ":LIST.NAME
*
FIRST = TRUE
CURR.DT = OCONV(DATE(),"D")
CURR.MM = CURR.DT[4,8]
CURR.YR = CURR.DT[8,4]
IF TERM.DISP THEN PRINT CURR.YR
IF TERM.DISP THEN PRINT CURR.MM
*
IF LPTR.FL THEN
IF TERM.DISP THEN PRINT
IF TERM.DISP THEN PRINT
IF TERM.DISP THEN PRINT FILE.NAME:" ":DCOUNT(FILE.LIST,AM)
CALL PRINTER.ON(STAT)
END
*
*
!! MAIN PROGRAM
*
LOOP
*
ITEM.ID = FILE.LIST<ONE>
*
IF ITEM.ID[ONE,ONE] EQ "$" THEN
ITEM.ID = ITEM.ID[TWO,9999]
END
*
IF ITEM.ID[ONE,ONE] EQ "*" THEN
ITEM.ID = ITEM.ID[TWO,99999]
END
*
WHILE LEN(FILE.LIST) DO
*
LN.CN = LN.CN + ONE; IF LN.CN GT LN.CN.MAX THEN GOSUB LPTR.HEADER
*
IF LPTR.FL THEN
PRINTER OFF
IF TERM.DISP THEN PRINT "*":
CALL PRINTER.ON(STAT)
END
*
PRINT ITEM.ID "L#25":" ":
*
DEL FILE.LIST<ONE>
*
ITEM.LIST<-ONE> = ITEM.ID
*
MSG = EMPTY
*
!
*
READV ATTR1 FROM INIMP.FILE,ITEM.ID,ONE THEN
*
WRITE.FLAG = FALSE; LIST.TYPE = EMPTY
*
$INCLUDE IBP SYS.INCL.ITEM.TYPE
*
READV ATTR1.DOL FROM OUTIMP.FILE,"$":ITEM.ID,ONE ELSE
ATTR1.DOL = EMPTY
MSG<-ONE> = "** ** CODE NOT ON PRESENT ** **"
END; * Of read
*
END ELSE
ATTR1 = EMPTY
ATTR1.DOL = EMPTY
PRINT "LOST ":
MSG<-ONE> = "** ** ITEM NOT ON PRESENT ** **"
END; * Of read
*
!
*
YR = ATTR1.DOL<ONE,3>[LEN(ATTR1.DOL<ONE,3>) - 3,9999]
MM = ATTR1.DOL<ONE,3>[LEN(ATTR1.DOL<ONE,3>) - 7,9999]
*
PRINT ATTR1.DOL<ONE,4> "L#8":" ":ATTR1.DOL<ONE,3> "L#11":
*
IF YR NE CURR.YR THEN
PRINT " * ":
END ELSE IF MM NE CURR.MM THEN
PRINT " m ":
END ELSE PRINT "   ":
*
PRINT ATTR1.DOL<ONE,ONE> "L#10":
*
LOOP
IF LPTR.FL THEN
PRINT MSG<ONE> "L#65"
END ELSE
PRINT MSG<ONE> "L#15"
END
DEL MSG<ONE>
WHILE LEN(MSG) DO REPEAT
*
*
REPEAT
*
!
*
PRINT
*
IF PROC.FL THEN
PROCWRITE RTN.TYPE
END
*
STOP
*
!
*
LPTR.HEADER: *
*
PG = PG + ONE
LN.CN = 7
*
IF NOT(LPTR.FL) THEN
IF NOT(NOPAGE.FL) THEN
PRINT "Enter <cr> to continue . . . ":
INPUT CONT.RSP
IF CONT.RSP EQ "KILL" OR CONT.RSP EQ "END" THEN PRINT "KILL requested!"; STOP
IF CONT.RSP EQ "GO" THEN NOPAGE.FL = TRUE
END
END ELSE
IF NOT(FIRST) THEN
IF FAST.FL THEN PRINTER CLOSE
IF FAST.FF THEN
PRINT FF:
END
END
END
FIRST = FALSE
*
PRINT OCONV(DATE(),"D2") "L#14":(SPACE(25 - INT(LEN(TITLE) / TWO + .5)):TITLE) "L#50":("Page ":PG) "R#14"
PRINT OCONV(TIME(),"MTS") "L#14":(SPACE(25 - INT(LEN(TITLE1) / TWO + .5)):TITLE1) "L#50":WHO "R#14"
PRINT
PRINT
PRINT "Item......................" "L#25":" Type ..Time.. ...Date.... * ...File... ":"Coments................. " "L#15"
PRINT
*
RETURN
*
!
*
END
~DATASENSE.UPPER.CASE~
SUBROUTINE DATASENSE.UPPER.CASE (SUBJECT)
*      This program converts lower case text to upper case.
*  It is necessary because Microdatas don't support OCONV(X,'MCU')
*
*
PROGRAM="DATASENSE.UPPER.CASE"
IF SUBJECT > "" THEN
    RESULT=""
    FOR X=1 TO LEN(SUBJECT)
        A=SUBJECT[X,1]
        IF A >= "a" AND A <= "z" THEN
            A=CHAR(SEQ(A)-32)
        END
        RESULT=RESULT:A
    NEXT X
    SUBJECT=RESULT
END
RETURN; * TO CALLING PROGRAM
*
END
~DUMMY~
*PROGRAM: DUMMY
*
PRINT "DUMMY"
*
*
END
~FILE.KEY.CONVERT~
*PROGRAM: FILE.KEY.CONVERT
*
$INCLUDE IBP STANDARD.FUNCTIONS
SYS.PROG = 'FILE.KEY.CONVERT'
SYS.LOCT = ''
SYS.SLOC = ''
RUN.DATE = DATE()
RUN.TIME = TIME()
Start.of.prog: *
PRINT @(0,5):CLS:@(0,7):
PRINT 'Enter "FROM" file name: ':; INPUT INP.FILE.NAME:
IF INP.FILE.NAME = "" OR INP.FILE.NAME = "END" THEN STOP
PRINT @(0,9):'Enter "TO" file name: ':; INPUT OUT.FILE.NAME:
IF OUT.FILE.NAME = "" THEN GOTO Start.of.prog
PRINTER CLOSE
EXECUTE "SP-ASSIGN HS"
PRINTER ON
PRINT FF:SYS.PROG
PRINT
PRINT
PRINT OCONV(RUN.DATE,'D2'):'     ':OCONV(RUN.TIME,'MTS'):
PRINT
PRINT '"FROM" file name: ':INP.FILE.NAME
PRINT
PRINT '"TO" file name: ':OUT.FILE.NAME
PRINT
PRINTER OFF
OPEN INP.FILE.NAME TO INP.FILE ELSE GOTO Start.of.prog
OPEN OUT.FILE.NAME TO OUT.FILE ELSE GOTO Start.of.prog
CONT = 1
INP.DELETE = 0
PRINT @(40,7):'Enter old key prefix: ':; INPUT INP.PREFIX:
PRINT @(40,9):'Enter new key prefix: ':; INPUT OUT.PREFIX:
PRINT @(0,11):BELL:'Delete "FROM" records? ':; INPUT INP.DELETE:
IF INP.DELETE = "YES" THEN INP.DELETE = 1
IF NOT(NUM(INP.DELETE)) THEN INP.DELETE = 0
IF INP.DELETE # 1 THEN INP.DELETE = 0
PRINT @(0,13):"OK to continue? ":; INPUT RSP:
IF RSP # "Y" THEN STOP
PRINTER ON
PRINT; PRINT "INP.DELETE: ":INP.DELETE
PRINT; PRINT "INP PREFIX: ":INP.PREFIX
PRINT; PRINT "OUT PREFIX: ":OUT.PREFIX
PRINT; PRINT; PRINT; PRINT
INP.K.L = LEN(INP.PREFIX)
OUT.K.L = LEN(OUT.PREFIX)
LOOP
READNEXT ID ELSE CONT = 0
WHILE CONT DO
IF ID[1,INP.K.L] = INP.PREFIX THEN
*
READ INP.REC FROM INP.FILE,ID THEN
*
ID.SUFFIX = ID[INP.K.L+1,99]
WRITE INP.REC ON OUT.FILE,OUT.PREFIX:ID.SUFFIX
PRINTER ON
PRINT ID "L#15":" COPIED TO ":OUT.PREFIX:ID.SUFFIX:"<"
PRINTER OFF
PRINT ID "L#15":" COPIED TO ":OUT.PREFIX:ID.SUFFIX:"<"
*
IF INP.DELETE THEN
DELETE INP.FILE,ID
PRINTER ON
PRINT ID "L#15":" DELETED<"
PRINTER OFF
PRINT ID "L#15":" DELETED<"
END
*
*
END ELSE
PRINT "Record not found on old file!  Key: ":ID:"   ":; INPUT CONT
PRINTER ON
PRINT "Record not found on old file!  Key: ":ID
PRINTER OFF
END
*
*
END ELSE
PRINTER ON
PRINT ID "L#15":" is bypassed because of the key prefix<"
PRINTER OFF
PRINT ID "L#15":" is bypassed because of the key prefix<"
END
*
REPEAT
GOTO Start.of.prog
END
~GEN.LIST~
*PROGRAM: GEN.LIST
*
SYS.PROG = "GEN.LIST"
SYS.LOCT = "1"
SYS.SLOC = ""
SYS.PROG.DESC = "List Generate Utility"
$INCLUDE IBP STANDARD.FUNCTIONS
*
*@* DIM STATEMENTS *@*
SYS.LOCT = "2"
DIM EXEC(20); MAT EXEC = ""
*
*@* OPEN STATEMENTS *@*
E.START.DATE = DATE(); E.START.TIME = TIME()
OPEN "SYS.STRUCTURE" TO SY.FILE ELSE ERROR = 1; GOSUB ERROR.RTN; STOP
*
*
PRINT @(0,5):CLS:(SPACE(40-LEN(SYS.PROG.DESC)/2):RVB:SYS.PROG.DESC:RVE) "L#60":
PRINT @(0,7):'USER: ':; INPUT E.USER:; PRINT @(7,7):E.USER:
PRINT @(40,7):'LIST: ':; INPUT E.LIST:; PRINT @(47):E.LIST
PRINT @(0,9)'FILE: ':; INPUT E.FILE:; PRINT @(7,9):E.FILE
* USER, LIST, AND LISTS FILE.
*
*
READ E.DATA FROM SY.FILE,"@E.PARAM@GEN.LIST@":E.FILE THEN
E.DATA<1> = E.USER; * USER EXECUTING GENERATE LIST
E.DATA<2> = E.LIST; * NAME OF LIST TO GENERATE
E.DATA<3> = E.FILE; * NAME OF LISTS FILE
E.FILA = E.DATA<4>; * ATTRIBUTE WITH THE FILE NAME THE LIST ACCESSES
E.SORA = E.DATA<5>; * ATTRIBUTE OF SORT FIELD NAMES
E.ETYP = E.DATA<5>; * ATTRIBUTE OF ENTITY TYPES VALIDATION FIELD
E.SELA = E.DATA<6>; * ATTR FOR SELECTION FIELDS/OPERATIONS/VALUES
E.TIMA = E.DATA<7>; * ATTR FOR EXECUTION DATE & TIME TAKEN
E.USE.ET = E.DATA<8>; * USE ENTITY.TYPES IN GENERATION
PR.PARAM = E.DATA<9>; * Print parameters
IN.PARAM = 0; * Input these parameters
END ELSE
*
ERROR = 2
GOSUB ERROR.RTN
E.FILA = ""; E.SORA = ""; E.ETYP = ""; E.SELA = ""
E.TIMA = ""; E.TIMA = ""; E.USE.ET = ""; PR.PARAM = 0; IN.PARAM = 1
END
*
IF PR.PARAM ! IN.PARAM THEN
PRINT@(0,11):'FILA: ':
IF IN.PARAM THEN INPUT E.FILA:
PRINT @(7):E.FILA
*
PRINT @(10,11):'SORA: ':
IF IN.PARAM THEN INPUT E.SORA:
PRINT @(17):E.SORA
*
PRINT @(20,11):'ETYP: ':
IF IN.PARAM THEN INPUT E.ETYP:
PRINT @(27):E.ETYP
*
PRINT @(30,11):'SELA: ':
IF IN.PARAM THEN INPUT E.SELA:
PRINT @(37):E.SELA
*
PRINT @(40,11):'TIMA: ':
IF IN.PARAM THEN INPUT E.TIMA:
PRINT @(47):E.TIMA
*
PRINT @(50,11):'USE ET? ':
IF IN.PARAM THEN INPUT E.USE.ET:
PRINT @(59):E.USE.ET
END
*
E.START.DATE = DATE(); E.START.TIME = TIME()
*
OPEN E.FILE TO LS.FILE ELSE ERROR = 4; GOSUB ERROR.RTN; STOP
*
*
MATREAD EXEC FROM LS.FILE,E.LIST ELSE ERROR = 5; GOSUB ERROR.RTN; STOP
*
* FILE SELECTION
*
E.LINE = 'SELECT'
FILE.NAME = EXEC(E.FILA)
IF FILE.NAME = '' OR FILE.NAME = ' ' THEN ERROR = 6; GOSUB ERROR.RTN; GOSUB INPUT.FILE.NAME
* DICTIONARY
DICT.OPT = 1
OPEN 'DICT ':FILE.NAME TO DC.FILE ELSE ERROR = 3; GOSUB ERROR.RTN; DICT.OPT = 0
* START LINE
E.LINE = E.LINE:' ':FILE.NAME
*
* SORTING CRITERIA
*
IF EXEC(E.SORA) = ' ' OR EXEC(E.SORA) = '' THEN NULL ELSE
CN = 0
CONT = 1
LOOP
CN = CN + 1
IF LEN(E.LINE) > 140 THEN ERROR = 7; GOSUB ERROR.RTN; CONT = 0
E.SORT = EXEC(E.SORA)<1,CN>
WHILE CONT = 1 & E.SORT # ' ' & E.SORT # '' DO
EXECSORT = ''
IF DICT.OPT = 0 THEN
EXECSORT = E.SORT
END ELSE
READV EXECSORT FROM DC.FILE,E.SORT,2 ELSE EXECSORT = E.SORT
END
IF EXECSORT # '0' THEN E.LINE = E.LINE:' BY ':EXECSORT
REPEAT
IF CN > 1 THEN E.LINE = 'S':E.LINE
END
*
* SELECTION
*
* ENTITY.TYPES
*
EXECETYC = ''
E.ETYC = 'ET'
IF DICT.OPT = 0 THEN
EXECETYC = E.ETYC
END ELSE
READV EXECETYC FROM DC.FILE,E.ETYC,2 ELSE EXECETYC = E.ETYC
END
CN = 0
CONT = 1
LOOP
CN = CN + 1
IF LEN(E.LINE) > 140 THEN ERROR = 8; GOSUB ERROR.RTN; CONT = 0
WHILE CONT = 1 & EXEC(E.ETYP)<1,CN> # ' ' & EXEC(E.ETYP)<1,CN> # '' DO
IF CN = 1 THEN
E.LINE = E.LINE:' WITH ':EXECETYC:' = "':EXEC(E.ETYP)<1,CN>:'"'
END ELSE
E.LINE = E.LINE:' OR ':' = "':EXEC(E.ETYP)<1,CN>:'"'
END
REPEAT
*
* SELECTION
*
* FIELD OPERAND VALUE
*
CN1 = 0
CONT = 1
LOOP
CN1 = CN1 + 1
IF LEN(E.LINE) > 140 THEN ERROR = 9; GOSUB ERROR.RTN; CONT = 0
E.TEST = EXEC(E.SELA)<1,CN1,1>:EXEC(E.SELA)<1,CN1,2>:EXEC(E.SELA)<1,CN1,3>
FOR A = 1 TO 10
IF E.TEST[1,1] = ' ' THEN E.TEST = E.TEST[2,99]
NEXT A
WHILE CONT = 1 & E.TEST # ' ' & E.TEST # '' DO
E.SELC = EXEC(E.SELA)<1,CN1,1>
EXECSELC = ''
IF DICT.OPT = 0 THEN
EXECSELC = E.SELC
END ELSE
READV EXECSELC FROM DC.FILE,E.SELC,2 ELSE EXECSELC = E.SELC
END
IF CN > 1 AND CN1 = 1 THEN E.LINE = E.LINE:' AND' ELSE
IF CN1 > 1 THEN E.LINE = E.LINE:' OR'
END
IF E.SELC # ' ' & E.SELC # '' THEN
E.LINE = E.LINE:' WITH ':EXECSELC
END
E.LINE = E.LINE:' ':EXEC(E.SELA)<1,CN1,2>:' "':EXEC(E.SELA)<1,CN1,3>:'"'
REPEAT
*
*
* WRITE TO PROC
*
*WRITEV 'H':E.LINE ON PROCFILE,"GEN.LIST.PROC",11
*WRITEV 'H':EXEC(E.FILA) ON PROCFILE,"GEN.LIST.PROC",15
*WRITEV 'H@LIST@':E.LIST ON PROCFILE,"GEN.LIST.PROC",18
*CN = 0
*LOOP CN = CN + 1 WHILE EXEC(E.TIMA)<1,CN,1> # '' DO REPEAT
*EXEC(E.TIMA)<1,CN> = DATE():SVM:E.USER:SVM:0:SVM:TIME()
*
*
E.NAME.OF.LIST = '@LIST@':E.LIST
*
*
PRINT @(0,13):"Executing command: ":E.LINE; PRINT
EXECUTE E.LINE, //OUT. > E.RESULT
*
*
IF LEN(E.RESULT) = 0 THEN
PRINT @(0,14):CLL:E.RESULT:
PRINT @(0,15):CLL:'Moving to list file.'
E.COL = FIELD(E.RESULT,' ',1)
CONT = 1
E.LIST.CHAIN = ''
CN = 0
LOOP
READNEXT E.LIST.NEXT ELSE CONT = 0
WHILE CONT = 1 DO
E.LIST.CHAIN = E.LIST.CHAIN:E.LIST.NEXT:AM
CN = CN + 1
IF CN - INT(CN/25) * 25 = 0 THEN PRINT @(0,17):CLL:CN "R#3":" - ":
PRINT '*':
REPEAT
E.COL = CN
WRITE E.LIST.CHAIN ON LS.FILE,E.NAME.OF.LIST
END ELSE
ERROR = 10
PRINT @(0,21):BELL:'I encountered an error ':E.USER:'.':
PRINT @(0,22):'The message was: ':E.RESULT<1>:'.':
IF E.RESULT<2> # '' THEN PRINT @(0,23):'                 ':E.RESULT<2>:'.':
FOR TEMP = 1 TO 10; RQM; NEXT TEMP
PRINT @(0,20):'I must terminate. Please check your List Criteria.':BELL:
GOSUB ERROR.RTN
END
E.END.DATE = DATE(); E.END.TIME = TIME()
IF E.END.DATE # E.START.DATE THEN
E.TIME = 86400 - E.START.TIME + E.END.TIME
END ELSE
E.TIME = E.END.TIME - E.START.TIME
END
CN = 0
LOOP CN = CN + 1 WHILE EXEC(E.TIMA)<1,CN,1> # '' DO REPEAT
EXEC(E.TIMA)<1,CN> = E.START.DATE:SVM:E.USER:SVM:E.COL:SVM:E.TIME
IF ERROR < 4 THEN MATWRITE EXEC ON LS.FILE,E.LIST
PRINT @(0,19):BELL:'Date: ':OCONV(E.START.DATE,'D'):'.  Time to execute (Minutes:Seconds): ':OCONV(E.TIME,'MTS')[4,99]:
PRINT @(0,21):CLS:@(0,23):'Hit <CR> to return to menu.':; INPUT A$:
GOTO End.of.program
*
*
*
INPUT.FILE.NAME: *@* FILE INPUT SUBROUTINE
PRINT @(0,21):CLS:@(0,23):'What is the file to be processed? ':
INPUT FILE.NAME:
IF FILE.NAME # '' THEN RETURN
GOTO INPUT.FILE.NAME
*
*
ERROR.RTN: *@* ERROR HANDLING
PRINT @(0,20):CLS:@(0,23):BELL:'Error ':ERROR:'.':
RQM; RQM
RQM; RQM
RETURN
*
End.of.program: *
END
*
~HEX.CONV~
*PROGRAM: HEX.CONV
*
PROMPT CHAR(0)
LOOP
PRINT "?":
INPUT ANS
WHILE ANS NE "END" DO
ANS.LEN = LEN(ANS)
FINAL.RESULT = 0
*FOR STR.CN = ANS.LEN TO 1 STEP - 1
FOR STR.CN = 1 TO ANS.LEN
PRINT "STR.CN ":STR.CN
ANS.MULT = 1
FOR A = 2 TO STR.CN
PRINT "MULT ":A
ANS.MULT = ANS.MULT * 16
NEXT A
PRINT "MULT RESULT ":ANS.MULT
STR.CHAR = ANS[ANS.LEN-STR.CN+1,1]
MULT.CONV = INDEX("123456789ABCDEF",STR.CHAR,1)
PRINT "MULT.CONV ":MULT.CONV
MULT.ADD = MULT.CONV * ANS.MULT
PRINT "MULT.ADD ":MULT.ADD
FINAL.RESULT = FINAL.RESULT + MULT.ADD
PRINT "INTERMEDIATE ":FINAL.RESULT
NEXT STR.CN
PRINT
PRINT "RESULT: ":FINAL.RESULT
REPEAT
END
~JL~
*PROGRAM: JL
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
LOOP
*
LOOP
PRINT "FILE: ":
INPUT FILE.NAME
FILE.OPEN = TRUE
OPEN FILE.NAME TO INP.FILE ELSE FILE.OPEN = FALSE
WHILE LEN(FILE.NAME) AND NOT(FILE.OPEN) DO PRINT BELL: REPEAT
*
*
WHILE LEN(FILE.NAME) DO
*
LOOP
*
LOOP
PRINT "ITEM: ":
INPUT ITEM.NAME
ITEM.ON.FILE = TRUE
READ ITEM FROM INP.FILE,ITEM.NAME ELSE ITEM.ON.FILE = FALSE
WHILE LEN(ITEM.NAME) AND NOT(ITEM.ON.FILE) DO PRINT BELL: REPEAT
*
*
WHILE LEN(ITEM.NAME) DO
*
LOOP
*
LOOP
PRINT
PRINT "ATTRIBUTE":
INPUT ATTR
IF LEN(ATTR) THEN
IF NOT(NUM(ATTR)) THEN ATTR = -ONE ELSE
IF ATTR GT DCOUNT(ITEM,AM) THEN ATTR = -ONE
IF ATTR LT TWO THEN ATTR = -ONE
END
END
WHILE ATTR EQ -ONE DO PRINT BELL: REPEAT
*
WHILE ATTR GT ONE DO
*
*
CN.START = ATTR - 10
IF CN.START LT ONE THEN CN.START = ONE
CN.END = CN.START + 18
*
FOR CN = CN.START TO CN.END
IF CN EQ ATTR OR CN EQ ATTR-1 THEN
PRINT "*":
END ELSE
PRINT " ":
END
PRINT CN "R#3":ITEM<CN> "L#75"
NEXT CN
*
*
PRINT "Y/N: ":; INPUT RSP
IF RSP EQ "Y" THEN
PRINT
PRINT ITEM<ATTR-1>
PRINT
ITEM<ATTR-1> = ITEM<ATTR-1>:ITEM<ATTR>
ITEM = DELETE(ITEM,ATTR,0,0)
PRINT
PRINT ITEM<ATTR-1>
PRINT
*
WRITE ITEM ON INP.FILE,ITEM.NAME
*
END
*
*
REPEAT
*
REPEAT
*
REPEAT
*
*
END
~JUN30.LISTALLF~
PQN
C
C    29 JUN 93
C
C   PROGRAMS IN.BP
C
C
HSORT ONLY DICT IN.BP (P)
PP
C
HLISTDICT IN.BP (P)
PP
C
HSORT ONLY IN.BP (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.UTL
C
C
HSORT ONLY DICT IN.BP.UTL (P)
PP
C
HLISTDICT IN.BP.UTL (P)
PP
C
HSORT ONLY IN.BP.UTL (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.IBP
C
C
HSORT ONLY DICT IN.IBP (P)
PP
C
HLISTDICT IN.IBP (P)
PP
C
HSORT ONLY IN.IBP (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.CONV
C
C
HSORT ONLY DICT IN.BP.CONV (P)
PP
C
HLISTDICT IN.BP.CONV (P)
PP
C
HSORT ONLY IN.BP.CONV (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.INST
C
C
HSORT ONLY DICT IN.BP.INST (P)
PP
C
HLISTDICT IN.BP.INST (P)
PP
C
HSORT ONLY IN.BP.INST (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.IBP
C
C
HSORT ONLY IN.MDD.IBP (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.BP.UTL
C
C
HSORT ONLY IN.MDD.BP.UTL (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MACRO.UTILS
C
C
HSORT ONLY DICT IN.MACRO.UTILS (P)
PP
C
HLISTDICT IN.MACRO.UTILS (P)
PP
C
HSORT ONLY IN.MACRO.UTILS (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.PICKTR
C
C
HSORT ONLY DICT IN.PICKTR (P)
PP
C
HLISTDICT IN.PICKTR (P)
PP
C
HSORT ONLY IN.PICKTR (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.DH.BP
C
C
HSORT ONLY DICT IN.DH.BP (P)
PP
C
HLISTDICT IN.DH.BP (P)
PP
C
HSORT ONLY IN.DH.BP (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS LISTS
C
C
HSORT ONLY DICT LISTS (P)
PP
C
HLISTDICT LISTS (P)
PP
C
HSORT ONLY LISTS (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS SYS
C
C
HSORT ONLY DICT SYS (P)
PP
C
HLISTDICT SYS (P)
PP
C
HSORT ONLY SYS (P)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS MD
C
C
HSORT ONLY MD (P)
PP
C
C
C
C
C
RTN

~JUN30.TCREALLF.MIN~
PQN
C
C    29 JUN 93
C
C   PROGRAMS IN.BP
C
C
HCREATE-FILE (IN.BP 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.UTL
C
C
HCREATE-FILE (IN.BP.UTL 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.IBP
C
C
HCREATE-FILE (IN.IBP 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.CONV
C
C
HCREATE-FILE (IN.BP.CONV 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.INST
C
C
HCREATE-FILE (IN.BP.INST 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.IBP
C
C
HCREATE-FILE (IN.MDD.IBP 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.BP.UTL
C
C
HCREATE-FILE (IN.MDD.BP.UTL 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MACRO.UTILS
C
C
HCREATE-FILE (IN.MACRO.UTILS 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.PICKTR
C
C
HCREATE-FILE (IN.PICKTR 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.DH.BP
C
C
HCREATE-FILE (IN.DH.BP 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS LISTS
C
C
HCREATE-FILE (LISTS 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS SYS
C
C
HCREATE-FILE (SYS 19,1 103,1)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS MD
C
C
HCREATE-FILE (MD 19,1 103,1)
PP
C
C
C
C
RTN

~JUN30.TDUMPALLF~
PQN
C
C
HT-ATT 8192
PP
C
C
HSELECT MD "JUN30.TLOADALLF" "JUN30.LISTALLF" "JUN30.TDUMPALLF" "JUN30.TCREALLF.MIN"
STON
HT-DUMP MD<
PP
C
C
C
HSELECT LISTS "BP.FILES"
STON
HT-DUMP LISTS<
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP
C
C
HSSELECT DICT IN.BP USING MD WITH *A1 EQ "A" "X" "S"
STON
HT-DUMP DICT IN.BP<
PP
C
HSSELECT IN.BP NE "*]"
STON
HSELECT IN.BP NE "$]"<
HT-DUMP IN.BP<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.UTL
C
C
HSSELECT DICT IN.BP.UTL USING MD WITH *A1 EQ "A" "X" "S"
STON
HT-DUMP DICT IN.BP.UTL<
PP
C
HSSELECT IN.BP.UTL NE "*]"
STON
HSELECT IN.BP.UTL NE "$]"<
HT-DUMP IN.BP.UTL<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.IBP
C
C
HSSELECT DICT IN.IBP USING MD WITH *A1 EQ "A" "X" "S"
STON
HT-DUMP DICT IN.IBP<
PP
C
HSSELECT IN.IBP NE "*]"
STON
HSELECT IN.IBP NE "$]"<
HT-DUMP IN.IBP<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.CONV
C
C
HSSELECT DICT IN.BP.CONV USING MD WITH *A1 EQ "A" "X" "S"
STON
HT-DUMP DICT IN.BP.CONV<
PP
C
HSSELECT IN.BP.CONV NE "*]"
STON
HSELECT IN.BP.CONV NE "$]"<
HT-DUMP IN.BP.CONV<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.INST
C
C
HSSELECT DICT IN.BP.INST USING MD WITH *A1 EQ "A" "X" "S"
STON
HT-DUMP DICT IN.BP.INST<
PP
C
HSSELECT IN.BP.INST NE "*]"
STON
HSELECT IN.BP.INST NE "$]"<
HT-DUMP IN.BP.INST<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.IBP
C
C
HSSELECT IN.MDD.IBP NE "*]"
STON
HSELECT IN.MDD.IBP NE "$]"<
HT-DUMP IN.MDD.IBP<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.BP.UTL
C
C
HSSELECT IN.MDD.BP.UTL NE "*]"
STON
HSELECT IN.MDD.BP.UTL NE "$]"<
HT-DUMP IN.MDD.BP.UTL<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MACRO.UTILS
C
C
HSSELECT DICT IN.MACRO.UTILS USING MD WITH *A1 EQ "A" "X" "S"
STON
HT-DUMP DICT IN.MACRO.UTILS<
PP
C
HSSELECT IN.MACRO.UTILS NE "*]"
STON
HSELECT IN.MACRO.UTILS NE "$]"<
HT-DUMP IN.MACRO.UTILS<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.PICKTR
C
C
HS-DUMP DICT IN.PICKTR
PP
C
HS-DUMP IN.PICKTR
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.DH.BP
C
C
HSSELECT DICT IN.DH.BP USING MD WITH *A1 EQ "A" "X" "S"
STON
HT-DUMP DICT IN.DH.BP<
PP
C
HSSELECT IN.DH.BP NE "*]"
STON
HSELECT IN.DH.BP NE "$]"<
HT-DUMP IN.DH.BP<
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS LISTS
C
C
HS-DUMP DICT LISTS
PP
C
HS-DUMP LISTS
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS SYS
C
C
HS-DUMP DICT SYS
PP
C
HS-DUMP SYS
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS MD
C
C
HS-DUMP MD
PP
C
C
C
C
C
RTN

~JUN30.TLOADALLF~
PQN
C
C
HT-ATT 8192
PP
C
C
HT-LOAD MD (O)
PP
C
C
C
HT-LOAD LISTS (O)
PP
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.BP (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.BP (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.UTL
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.BP.UTL (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.BP.UTL (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.IBP
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.IBP (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.IBP (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.CONV
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.BP.CONV (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.BP.CONV (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.BP.INST
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.BP.INST (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.BP.INST (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.IBP
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.MDD.IBP (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MDD.BP.UTL
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.MDD.BP.UTL (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.MACRO.UTILS
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.MACRO.UTILS (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.MACRO.UTILS (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.PICKTR
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.PICKTR (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.PICKTR (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS IN.DH.BP
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT IN.DH.BP (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD IN.DH.BP (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS LISTS
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT LISTS (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD LISTS (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS SYS
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD DICT SYS (O)
PP
C
CHT-FWD 1
CPP
C
HT-LOAD SYS (O)
PP
C
C
C
C    29 JUN 93
C
C   PROGRAMS MD
C
C@HT-FWD 1
C@PP
C
CHT-FWD 1
CPP
C
HT-LOAD MD (O)
PP
C
C
C
C
C
RTN

~LABEL.RTN~
SUBROUTINE LABEL.RTN (ERROR)
*
$INCLUDE DH.BP CG.COMMON.VARIABLES
$INCLUDE DH.BP STANDARD.FUNCTIONS
*
DIM LNVL(10)
MAT LNVL = ''
PROG.NAME = 'Label printing'
OPEN 'CODES' TO CD.FILE ELSE
PROGRAM.CONTROL = 'STOP'
RETURN
END
IF KEY.COUNTER < 2 THEN
*SP.RESULT = ''
*EXECUTE 'SP-ASSIGN I R1', //OUT. > SP.RESULT
*IF LEN(SP.RESULT) > 1 THEN PRINT 'SP.RESULT: ':SP.RESULT:'. Enter <CR>.':; INPUT A$:
MAT LNVL = STR('X',35)
LNVL(6) = ''
PRINT @(0,5):CLS:@(10,6):PROG.NAME:
PRINT @(0,8):CLL:'Mount labels on printer and enter <CR> ':
INPUT A$:
CN = 0; RSP = 'N'
LOOP CN = CN + 1 WHILE RSP # 'Y' DO
GOSUB Pr.rtn
PRINT @(0,8):CLL:'Is alignment correct? ':
INPUT RSP:
IF INDEX('*Y*YES*y*yes*Yes*','*':RSP:'*',1) # 0 THEN RSP = 'Y' ELSE
PRINT @(10,10):CLL:'Enter the number of line to shift printing or':
PRINT @(10,11):CLL:'align labels and enter <CR>. I will print another mask. ':
INPUT MSK.LN:
IF LEN(MSK.LN) = 0 THEN MSK.LN = 'GO TEAM'
IF NUM(MSK.LN) THEN
PRINTER ON
FOR A = 1 TO (6+MSK.LN)
PRINT ON 1 '<'
NEXT A
PRINTER OFF
END
END
REPEAT
END
CN = 0
LOOP
KEY.LNVL = 1
MAT LNVL = ''
CN = CN + 1
WHILE IN.FILE(3)<1,CN> # '' DO
IF IN.FILE(3)<1,CN> = 'MAIL' THEN
LNVL(KEY.LNVL) = IN.KEY.VL
IF IN.FILE(14)<1,CN> # '' THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):' care of ':IN.FILE(14)<1,CN>
END
KEY.LNVL = KEY.LNVL + 1
*
IF IN.FILE(4)<1,CN> # '' THEN LNVL(KEY.LNVL) = '# ':IN.FILE(4)<1,CN>:' - '
*
IF IN.FILE(5)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Street address missing on ':IN.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(5)<1,CN>:' '
*
IF IN.FILE(6)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Street name missing on ':IN.KEY.VL
GOSUB Po.box
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(6)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
END
*
*
IF IN.FILE(7)<1,CN> # '' & IN.FILE(7)<1,CN> # ' ' THEN
LNVL(KEY.LNVL) = IN.FILE(7)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
*
IF IN.FILE(8)<1,CN> = '' THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'City missing on ':IN.KEY.VL
END ELSE
READV CITY FROM CD.FILE,'030@':IN.FILE(8)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):CITY:', '
*
IF IN.FILE(9)<1,CN> = '' THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Province missing on ':IN.KEY.VL
END ELSE
READV PROV FROM CD.FILE,'020@':IN.FILE(9)<1,CN>,1 THEN
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):PROV
KEY.LNVL = KEY.LNVL + 1
END ELSE
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Province master record missing on ':IN.KEY.VL
END
END
*
END ELSE
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'City master record missing on ':IN.KEY.VL
END
END
*
IF IN.FILE(11)<1,CN> = '' THEN
*PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Postal code missing on ':IN.KEY.VL
END ELSE
LNVL(KEY.LNVL) = IN.FILE(11)<1,CN>
END
*
IF KEY.LNVL > 5 THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'Maximum number of lines for a label execeeded'
CALL.COMM=CALL.COMM:AM:'( ':KEY.LNVL:' lines present on ':IN.KEY.VL
END ELSE GOSUB Pr.rtn
END
REPEAT
LOOP WHILE CALL.COMM[1,1] = AM DO CALL.COMM=CALL.COMM[2,999] REPEAT
RETURN
!
*
Po.box: *#*
*
LNVL(KEY.LNVL) = ''
IF IN.FILE(12)<1,CN> = '' THEN
PROGRAM.CONTROL = 'STOP'
CALL.COMM=CALL.COMM:AM:'P O Box missing on ':IN.KEY.VL
END ELSE
LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(11)<1,CN>:' '
*
IF IN.FILE(13)<1,CN> = '' THEN
CALL.COMM=CALL.COMM:AM:'Station missing from P O Box on ':IN.KEY.VL
END ELSE LNVL(KEY.LNVL) = LNVL(KEY.LNVL):IN.FILE(12)<1,CN>
KEY.LNVL = KEY.LNVL + 1
END
RETURN
!
*
Pr.rtn: *#*
PRINTER ON
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE CN2 < 7 DO PRINT ON 1 LNVL(CN2) REPEAT
PRINTER OFF
RETURN
*
END
~MDD.CAT.DELETE~
*PROGRAM: MDD.LIST.DELETE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
LOOP
*
READNEXT ID ELSE STOP
*
WHILE TRUE DO
*
ID = FIELD(ID,"*",3)
*
*
IF ID NE "MDD.LIST.DELETE" AND ID NE "MDD.CAT.DELETE" THEN
EXECUTE "DELETE-CATALOG ":ID
END
*
REPEAT
*
END
~MDD.COMPILE.ALL~
*PROGRAM: MDD.COMPILE.ALL
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
*
PRINT "ENTER LIST NAME IN MD: ":
INPUT LIST.NAME
PRINT
PRINT "ACTIVATE CODE THIS RUN? ":
INPUT CODE.ACTIVATE:
*
PRINT "ENTER PRESTORE: ":
INPUT PRESTORE
*
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:"O       ACTIVATE MDD ":AM:"O":AM:"O":AM
IF CODE.ACTIVATE EQ "Y" THEN
PROC1 = PROC1:"HGET-LIST ":LIST.NAME:AM:"STON":AM:"HED BP<":AM
PROC1 = PROC1:"HP9 R9999/*%%MDD%%=//":CHAR(27):"FI":CHAR(27):"P9<":AM
PROC1 = PROC1:"HPD<":AM:"HP9<":AM:"P":AM:"C":AM:"C":AM:"C":AM
END
*
*
PROC2 = "PQN":AM
*
LOOP
LOOP
PROGNAME = FILE.LIST<1>
WHILE FILE.LIST[1,1] EQ "*" DO FILE.LIST = DELETE(FILE.LIST,1,0,0) REPEAT
PRINT PROGNAME
WHILE FILE.LIST NE "" DO
*
IF PRESTORE NE "N" AND PRESTORE NE "n" THEN
PROC1 = PROC1:'C':AM:'C':AM:'HED BP ':PROGNAME:AM:'STON':AM:'HP9 ':PRESTORE:'<':AM:'HPD<':AM:'HP9<':AM:'P':AM
END
*
PROC1 = PROC1:'C':AM:'C':AM:'O     ':PROGNAME:AM:'O':AM:'O':AM:'HBASIC BP ':PROGNAME:' (M,E,P)':AM:'P':AM
PROC2 = PROC2:'C':AM:'C':AM:'HCATALOG BP ':PROGNAME:' (P)':AM:'P':AM
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'HMSG KBIL-DEMO   COMPILE STEP OF ':LIST.NAME:' IS DONE!!!':AM:'P':AM
PROC2 = PROC2:'C':AM:'C':AM:'HMSG KBIL-DEMO   CATALOG STEP OF ':LIST.NAME:' IS DONE!!!':AM:'P':AM
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'(MD ':LIST.NAME:'.CATALOG':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".COMPILE"
WRITE PROC1 ON BP.FILE,LIST.NAME:".COMPILE"
WRITE PROC2 ON MDI.FILE,LIST.NAME:".CATALOG"
WRITE PROC2 ON BP.FILE,LIST.NAME:".CATALOG"
*
STOP
END
*
~MDD.COPY.ALL.DICT~
*PROGRAM: MDD.COPY.ALL.DICT
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
*
PRINT "ENTER LIST NAME IN MD: ":
INPUT LIST.NAME
PRINT
*
PRINT "ENTER ACCOUNT: ":
INPUT ACCOUNT
*
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:"O       DICTIONARY COPY    ":AM:"O":AM:"O":AM
*
*
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FILENAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
PRINT FILENAME
PROC1 = PROC1:'C':AM:'C':AM:'O        ':FILENAME:AM:'O':AM:'HED MD TEMPFILE':AM:'STON':AM:'HDE999<':AM:'HF<':AM:'HI<':AM:'HQ<':AM:'H':ACCOUNT:'<':AM:'H':FILENAME:'<':AM:'H<':AM:'HFI<':AM:'P':AM:'HCOPY DICT TEMPFILE *':AM:'STON':AM:'H(DICT ':FILENAME:"<":AM:"P":AM:'C':AM:'C':AM
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'HMSG KBIL-DEMO   COPY DICTIONARY STEP OF ':LIST.NAME:' IS DONE!!!':AM:'P':AM
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".COPY.DICT"
WRITE PROC1 ON BP.FILE,LIST.NAME:".COPY.DICT"
*
STOP
END
*
~MDD.CREATE.ALL.DICT~
*PROGRAM: MDD.CREATE.ALL.DICT
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
*
PRINT "ENTER LIST NAME IN MD: ":
INPUT LIST.NAME
PRINT
*
PRINT "ENTER ACCOUNT: ":
INPUT ACCOUNT
*
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC2 = "PQN":AM
PROC1 = PROC1:"O       Q-POINTER CREATION ":AM:"O":AM:"O":AM
PROC2 = PROC2:"O       DICTIONARY CREATION ":AM:"O":AM:"O":AM
*
*
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FILENAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
PRINT FILENAME
TEMP = LEN(PROC1)
PRINT TEMP
IF TEMP < 300 THEN PRINT PROC1
PROC1 = PROC1:'C':AM:'C':AM:'O       ':FILENAME:AM:'O':AM:'HED DICT ':FILENAME:' ':"DL/ID":AM:'STON':AM:'HDE999<':AM:'HF<':AM:'HI<':AM:'HQ<':AM:'H':ACCOUNT:'<':AM:'H':ACCOUNT:'.':FILENAME:'<':AM:'H<':AM:'H<':AM:'HFI<':AM:'P':AM:'C':AM:'C':AM:'C':AM
PROC2 = PROC2:'HCREATE-FILE (DICT ':FILENAME:' 19,1)':AM:'P':AM:'C':AM:'C':AM
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'HMSG KBIL-DEMO   QPOINTER STEP OF ':LIST.NAME:' IS DONE!!!':AM:'P':AM
PROC2 = PROC2:'C':AM:'C':AM:'HMSG KBIL-DEMO   CREATE DICT STEP OF ':LIST.NAME:' IS DONE!!!':AM:'P':AM
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".CRE.QPOINTER"
WRITE PROC1 ON BP.FILE,LIST.NAME:".CRE.QPOINTER"
WRITE PROC2 ON MDI.FILE,LIST.NAME:".CRE.DICT"
WRITE PROC2 ON BP.FILE,LIST.NAME:".CRE.DICT"
*
STOP
END
*
~MDD.DICT.CONV~
*PROGRAM: MDD.DICT.CONV
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO PL.FILE ELSE STOP
PRINT "ENTER THE NAME OF THE LIST: ":
INPUT LIST.NAME
PRINT
PRINT "ENTER PRESTORE: ":
INPUT PRESTORE
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 =  PROC1:"C":AM:"C":AM:"HT-REW":AM:"P":AM:"C":AM:"C":AM
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
PROC1 = PROC1:'C':AM:'C':AM:'HED DICT ':FNAME:' *':AM:'STON':AM:'HP9 ':PRESTORE:'<':AM:'HPD<':AM:'HP9<':AM:'P':AM
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'HMSG KBIL-DEMO DICT-CONV FINISHED !!!!!':AM:'P':AM:'C':AM:'RTN':AM
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".DICTCONV"
WRITE PROC1 ON PL.FILE,LIST.NAME:".DICTCONV"
*
STOP
END
*
~MDD.DICT.COPY.1~
*PROGRAM: MDD.DICT.COPY.1
*
*
*AUTHOR: DAVID HORSMAN
*
* McDonnell Douglas only
*
* PROGRAM WRITE A PROC OF THE FOLLOWING FORMAT:
*
*        C
*        C fname
*        C
*        HSET.FILE account.name fname
*        PP
*        C
*        HCOPY DICT fname * (O)
*        STON
*        H(DICT QFILE
*        P
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PRINT
PRINT "ENTER PROC FILE NAME (PL): ":; INPUT PL.FILE.NAME
IF PL.FILE.NAME EQ "" THEN PL.FILE.NAME = "PL"
*
PRINT "ENTER LIST NAME IN MD (FILES.LIST): ":; INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "FILES.LIST"
*
PRINT
PRINT "ENTER ACCOUNT TO COPY TO (":ACCT:"): ":; INPUT ACCOUNT.NAME
IF ACCOUNT.NAME EQ "" THEN ACCOUNT.NAME = ACCT
*
PRINT
PRINT "ENTER PROC NAME (DICTCOPYALLF.":ACCOUNT.NAME:"): ":; INPUT PROC.NAME
IF PROC.NAME EQ "" THEN PROC.NAME = "DICTCOPYALLF.":ACCOUNT.NAME
*
FILE.NAME.PREFIX = "OUT."
PRINT "ENTER FILE NAME PREFIX (":FILE.NAME.PREFIX:", NONE for blank): ":; INPUT FILE.NAME.PREFIX
IF FILE.NAME.PREFIX EQ "" THEN FILE.NAME.PREFIX = "OUT."
IF FILE.NAME.PREFIX EQ "NONE" THEN FILE.NAME.PREFIX = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "",PL.FILE.NAME TO PL.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM:"O":AM:"O ":PROC.NAME:" ":ACCT:" ":FILE.NAME.PREFIX:AM:"O":AM:"C ":OCONV(DATE(),"D2"):AM:"C":AM
*
LOOP
*FNAME = FIELD(FILE.LIST<1>," ",3)
LOOP
FNAME = FILE.LIST<1>
WHILE FNAME[1,1] EQ "*" AND LEN(FILE.LIST) DO
DEL FILE.LIST<1,0,0>
REPEAT
WHILE FILE.LIST NE "" DO
*
IF FNAME[1,1] NE "*" THEN
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 AND FNAME NE "PL" AND FNAME NE "PROCLIB" THEN
PROC1 = PROC1:'O':AM:'O':AM:'O  ':FNAME:AM:'O':AM:'HSET.FILE ':AM:'STON':AM:'H':ACCOUNT.NAME:'<':AM:'H':FNAME:'<':AM:'P':AM
PROC1 = PROC1:'HCOPY DICT ':FILE.NAME.PREFIX:FNAME:' * (O)':AM:'STON':AM
PROC1 = PROC1:'H(DICT QFILE<':AM:'P':AM
END
END
DEL FILE.LIST<1,0,0>
REPEAT
*
*%%MDD%%=PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'RTN':AM
*%%STD%%=PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,PROC.NAME
WRITE PROC1 ON PL.FILE,PROC.NAME
*
STOP
END
*
~MDD.DICT.SEARCH~
*PROGRAM: MDD.DICT.SEARCH
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","PL" TO PL.FILE ELSE STOP
PRINT "ENTER THE NAME OF THE LIST: ":
INPUT LIST.NAME
PRINT
PRINT "ENTER PRESTORE: ":
INPUT PRESTORE
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC2 = "PQN":AM
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
PROC1 = PROC1:'C':AM:'C':AM:'HSSELECT DICT ':FNAME:' WITH V/CORR EQ "':PRESTORE:'"':AM:'STON':AM:'HSAVE-LIST ':FNAME:'.':LIST.NAME:'.DRESULT<':AM:'P':AM
PROC2 = PROC2:'C':AM:'C':AM:'HGET-LIST ':FNAME:'.':LIST.NAME:'.DRESULT':AM:'STON':AM:'HED DICT ':FNAME:'<':AM:'P':AM:'C':AM
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'HMSG KBIL-DEMO DICT-SEARCH FINISHED !!!!!':AM:'P':AM:'C':AM:'RTN':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'HMSG KBIL-DEMO DICT-SEARCH & EDIT FINISHED !!!!!':AM:'P':AM:'C':AM:'RTN':AM
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".DICTSEARCH"
WRITE PROC1 ON PL.FILE,LIST.NAME:".DICTSEARCH"
WRITE PROC2 ON MDI.FILE,LIST.NAME:".DICTEDIT"
WRITE PROC2 ON PL.FILE,LIST.NAME:".DICTEDIT"
*
STOP
END
*
~MDD.INSTALL.POINTERS~
*PROGRAM: MDD.INSTALL.POINTERS
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
*
PRINT "ENTER LIST NAME IN MD: ":
INPUT LIST.NAME
PRINT
*
PRINT "ENTER ACCOUNT: ":
INPUT ACCOUNT
*
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:"O       Q-POINTER CREATION ":AM:"O":AM:"O":AM
*
*
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FILENAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
PRINT FILENAME
TEMP = LEN(PROC1)
PRINT TEMP
IF TEMP < 300 THEN PRINT PROC1
PROC1 = PROC1:'C':AM:'C':AM:'O       ':FILENAME:AM:'O':AM:'HED DICT ':FILENAME:' ':ACCOUNT:'.':FILENAME:AM:'STON':AM:'HDE999<':AM:'HF<':AM:'HI<':AM:'HQ<':AM:'H':ACCOUNT:'<':AM:'H':ACCOUNT:'.':FILENAME:'<':AM:'H<':AM:'H<':AM:'HFI<':AM:'P':AM:'C':AM:'C':AM:'C':AM
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'HMSG KBIL-DEMO   QPOINTER STEP OF ':LIST.NAME:' IS DONE!!!':AM:'P':AM
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".QPOINTER"
WRITE PROC1 ON BP.FILE,LIST.NAME:".QPOINTER"
*
STOP
END
*
~MDD.LIST.DELETE~
*PROGRAM: MDD.LIST.DELETE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
LOOP
*
READNEXT ID ELSE STOP
*
WHILE TRUE DO
*
ID = FIELD(ID,"*",3)
*
*
EXECUTE "DELETE-LIST ":ID
*
REPEAT
*
END
~MDD.LIST.DELETE.YR~
*PROGRAM: MDD.LIST.DELETE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "DICT","POINTER-FILE" TO PF.FILE ELSE STOP
*
!
*
LOOP
PRINT
PRINT "Enter account name to delete lists from: ":
INPUT ACCOUNT.NAME
IF ACCOUNT.NAME EQ "KILL" THEN STOP
IF ACCOUNT.NAME NE ACCT THEN
PRINT BELL:"You are in the wrong account!!!"
PRINT ACCOUNT.NAME:" # ":ACCT:" !!!"
PRINT
ACCOUNT.NAME = EMPTY
END
WHILE ACCOUNT.NAME NE ACCT DO REPEAT
*
!
*
LOOP
PRINT
PRINT "Enter latest year to delete: ":
INPUT DEL.YR
IF NOT(NUM(DEL.YR)) THEN DEL.YR = EMPTY
IF DEL.YR LT 1985 OR DEL.YR GT 2001 THEN
PRINT BELL:"The year ":DEL.YR:" is < 1985 or > 2001!!"
DEL.YR = EMPTY
END
IF DEL.YR = "KILL" THEN STOP
WHILE NOT(DEL.YR) DO PRINT BELL: REPEAT
*
!
*
LOOP
*
READNEXT ID ELSE STOP
*
WHILE TRUE DO
*
LIST.NAME = FIELD(ID,"*",3)
ACCT.NAME = FIELD(ID,"*",ONE)
ITEM.TYPE = FIELD(ID,"*",TWO)
*
PRINT LIST.NAME "L#15":" ":
*
IF ITEM.TYPE NE "L" THEN
PRINT "not a list.":
END ELSE
*
IF ACCT.NAME NE ACCOUNT.NAME THEN
PRINT "wrong account.":
END ELSE
*
!
*
READ PF.REC FROM PF.FILE,ID THEN
*
DT = PF.REC<5>
*
YR = DT[LEN(DT) - 3,9999]
PRINT YR "L#4":" ":
*
IF NUM(YR) THEN
*
IF YR LT 1985 OR YR GT 2001 THEN
PRINT "is outside of range!":BELL:" ":
END ELSE
*
IF YR LE DEL.YR THEN
*
PRINT "will be deleted now. ":
*
EXECUTE "DELETE-LIST ":LIST.NAME, //OUT. > EXEC.OUT
*
AM.CN.MAX = DCOUNT(EXEC.OUT,AM)
AM.CN = ZERO
LOOP
AM.CN = AM.CN + ONE
WHILE AM.CN LE AM.CN.MAX DO
IF EXEC.OUT<AM.CN> EQ EMPTY THEN
DEL EXEC.OUT<AM.CN>
AM.CN.MAX = AM.CN.MAX - ONE
END ELSE
AM.CN = AM.CN + ONE
END
REPEAT
IF LEN(EXEC.OUT) THEN PRINT EXEC.OUT "L#20":" ":
*
END ELSE
*
PRINT "is valid and will be retained.":
*
END
*
END; * in range
*
END ELSE
PRINT "is not a numeric date!":BELL:" ":
END; * of not num date
*
END ELSE
PRINT "list is no longer on file!!!":BELL:
END
*
END; * OF WRONG ACCOUNT
*
END; * OF WRONG ITEM TYPE
*
PRINT
*
REPEAT
*
!
*
STOP
*
END
~MDD.QPT.SET~
*PROGRAM: MDD.QPT.WRITE
*
*
*AUTHOR: DAVID HORSMAN
*
* McDonnell Douglas only
*
* PROGRAM WRITES A PROC THAT EDITS MD FILE ENTRY DL/ID AND POINTS BACK
*   INTO THE ACCOUNT AT accountname.filename FOR THE DATA AREA
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PRINT
PRINT "ENTER BP FILE NAME (BP.UTL): ":; INPUT BP.FILE.NAME
IF BP.FILE.NAME EQ "" THEN BP.FILE.NAME = "BP.UTL"
*
PRINT "ENTER LIST NAME IN MD (FILES): ":; INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "FILES"
*
PRINT
PRINT "ENTER PROC NAME (QPNTALLF): ":; INPUT PROC.NAME
IF PROC.NAME EQ "" THEN PROC.NAME = "QPNTALLF"
*
PRINT
PRINT "ENTER ACCOUNT TO POINT AT (PROGRAMS): ":; INPUT ACCOUNT.NAME
IF ACCOUNT.NAME EQ "" THEN ACCOUNT.NAME = "PROGRAMS"
*
FILE.NAME.PREFIX = ACCT:"."
PRINT "ENTER FILE NAME PREFIX (":FILE.NAME.PREFIX:", NONE for blank)": ; INPUT FILE.NAME.PREFIX
IF FILE.NAME.PREFIX EQ "" THEN FILE.NAME.PREFIX = ACCT:"."
IF FILE.NAME.PREFIX EQ "NONE" THEN FILE.NAME.PREFIX = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "",BP.FILE.NAME TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM:"C":AM:"C ":PROC.NAME:" ":ACCT:" ":FILE.NAME.PREFIX:AM:"C":AM:"C ":OCONV(DATE(),"D2"):AM:"C":AM
*
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF FNAME[1,1] NE "*" THEN
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HED ':AM:'A\2':AM:'H.MD ':FNAME:AM:'STON':AM
PROC1 = PROC1:'HDE999<':AM:'HF<':AM
PROC1 = PROC1:'HI<':AM:'HQ<':AM:'H':ACCOUNT.NAME:'<':AM:'H':FILE.NAME.PREFIX:FNAME:'<':AM:'H<':AM:'HFI<':AM:'P':AM
END
END
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,PROC.NAME
WRITE PROC1 ON BP.FILE,PROC.NAME
*
STOP
END
*
~MDD.TAPE.PROCWRITE~
*PROGRAM: MDD.TAPE.PROCWRITE
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
PROC3 = ""
PROC4 = ""
*
OPEN "","MD" TO MD.FILE ELSE STOP
OPEN "","DH.PL" TO PL.FILE ELSE STOP
OPEN "","CNT" TO CNT.FILE ELSE STOP
OPEN "","PAR" TO PAR.FILE ELSE STOP
OPEN "","LISTS" TO LISTS.FILE ELSE STOP
*
PRINT
PRINT "Enter the name of the list to use (TAPE.FILES): ":
INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "TAPE.FILES"
*
PRINT
PRINT "Enter the file name that contains the list (LISTS): ":
INPUT FILE.NAME
IF FILE.NAME EQ "" THEN FILE.NAME = "LISTS"
*
PRINT
PRINT "Enter proc names prefix (blank): ":
INPUT PROC.NAME.PREFIX
IF PROC.NAME.PREFIX[LEN(PROC.NAME.PREFIX),1] NE '.' AND LEN(PROC.NAME.PREFIX) THEN PROC.NAME.PREFIX = PROC.NAME.PREFIX:"."
*
PRINT
PRINT "Use the suppress item names option on data areas (Y/N)? ":
INPUT S.OPTION.FLAG
IF S.OPTION.FLAG EQ "Y" THEN S.OPTION.FLAG = 1 ELSE S.OPTION.FLAG = ""
*
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
OPEN "",FILE.NAME TO LISTS.FILE ELSE STOP
READ FILE.LIST FROM LISTS.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-ATT 8192':AM:'PP':AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-LOAD MD (O)':AM:'PP':AM:'C':AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-LOAD ':FILE.NAME:' (O)':AM:'PP':AM:'C':AM
PROC2 = "PQN":AM
PROC3 = "PQN":AM
PROC3 = PROC3:'C':AM:'C':AM:'HT-ATT 8192':AM:'PP':AM
PROC3 = PROC3:'C':AM:'C':AM:'HSELECT MD "':PROC.NAME.PREFIX:LIST.NAME:".":'TLOAD" "':PROC.NAME.PREFIX:LIST.NAME:".":'LIST" "':PROC.NAME.PREFIX:LIST.NAME:".":'TDUMP" "':PROC.NAME.PREFIX:LIST.NAME:".":'TCRE.MIN"':AM:'STON':AM:'HT-DUMP MD<':AM:'PP':AM:'C':AM
PROC3 = PROC3:'C':AM:'C':AM:'HSELECT ':FILE.NAME:' "':LIST.NAME:'"':AM:'STON':AM:'HT-DUMP ':FILE.NAME:'<':AM:'PP':AM:'C':AM
PROC4 = "PQN":AM
*
*FILE.LIST = DELETE(FILE.LIST,1,0,0)
CN = 0
*
LOOP
*
FNAME = FILE.LIST<1>
CN = CN + 1
*
IF FNAME[1,1] NE "*" THEN
*
IF FNAME[1,5] EQ "DICT " OR FNAME[1,5] EQ "DICT." THEN
FDICT = "DICT"
FNAME = TRIM(FNAME)
FNAME = FIELD(FNAME," ",2)
DATA.FLAG = ""
END ELSE
FDICT = ""
DATA.FLAG = 1
END
*
END
*
WHILE FILE.LIST NE "" DO
*
IF FILE.NAME[1,1] NE "*" THEN
*
DMOD = '37,1'
PROC1 = PROC1:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM:'C@HT-FWD 1':AM:'C@PP':AM
PROC2 = PROC2:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
PROC3 = PROC3:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
PROC4 = PROC4:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
*
IF INDEX(FNAME,"BP",1) OR INDEX(FNAME,"MACRO",1) OR INDEX(FNAME,"MODEL.",1) THEN BP.FLAG = 1 ELSE
IF INDEX(FNAME,"MENUS",1) OR INDEX(FNAME,"PL",1) OR INDEX(FNAME,"HLP",1) THEN BP.FLAG = 1 ELSE BP.FLAG = ""
END
*
IF NOT(BP.FLAG) THEN
PROC1 = PROC1:'C':AM:'HT-LOAD DICT ':FNAME:' (O)':AM:'PP':AM
PROC3 = PROC3:'C':AM:'HS-DUMP DICT ':FNAME:AM:'PP':AM
PROC4 = PROC4:'C':AM:'HSORT ONLY DICT ':FNAME:' (P)':AM:'PP':AM
PROC4 = PROC4:'C':AM:'HLISTDICT ':FNAME:' (P)':AM:'PP':AM
END
*
IF NOT(DATA.FLAG) THEN
PROC2 = PROC2:'C':AM:'HCREATE-FILE (DICT ':FNAME:' 19,1 )':AM:'PP':AM:'C':AM
END ELSE
DMOD = '103,1'
END
*
IF DATA.FLAG THEN
PROC1 = PROC1:'C':AM:'HT-LOAD ':FNAME:' (O'
IF S.OPTION.FLAG THEN PROC1 = PROC1:',S'
PROC1 = PROC1:')':AM:'PP':AM:'C':AM:'C':AM
PROC2 = PROC2:'C':AM:'HCREATE-FILE (':FNAME:' 19,1 ':DMOD:')':AM:'PP':AM:'C':AM
PROC3 = PROC3:'C':AM:'HS-DUMP ':FNAME:AM:'PP':AM:'C':AM:'C':AM
PROC4 = PROC4:'C':AM:'HSORT ONLY ':FNAME:' (P)':AM:'PP':AM:'C':AM:'C':AM
END
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
*
END; *# OF FNAME[1,1] NE "*"
*
PRINT
PRINT CN "R#3":") ":FDICT:" ":FNAME
*
REPEAT
*
BEGIN CASE
CASE OPSYS EQ 'M'
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC3 = PROC3:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC4 = PROC4:'C':AM:'C':AM:'C':AM:'RTN':AM
CASE 1
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'C@X':AM:'RTN':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
PROC3 = PROC3:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
PROC4 = PROC4:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
END CASE
*
WRITE PROC1 ON MD.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TLOAD"
WRITE PROC1 ON BP.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TLOAD"
WRITE PROC1 ON PL.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TLOAD"
WRITE PROC2 ON MD.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TCRE.MIN"
WRITE PROC2 ON BP.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TCRE.MIN"
WRITE PROC2 ON PL.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TCRE.MIN"
WRITE PROC3 ON MD.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TDUMP"
WRITE PROC3 ON BP.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TDUMP"
WRITE PROC3 ON PL.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"TDUMP"
WRITE PROC4 ON MD.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"LIST"
WRITE PROC4 ON BP.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"LIST"
WRITE PROC4 ON PL.FILE,PROC.NAME.PREFIX:LIST.NAME:".":"LIST"
*
STOP
END
*
~MDD.TAPE.PROCWRITE.ALLF~
*PROGRAM: MDD.TAPE.PROCWRITE.ALLF
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
PROC3 = ""
PROC4 = ""
*
OPEN "","MD" TO MD.FILE ELSE STOP
OPEN "","PL" TO PL.FILE ELSE STOP
*
PRINT
PRINT "Enter the name of the list to use (FILES): ":
INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "FILES"
*
PRINT
PRINT "Enter the file name that contains the list (CNT): ":
INPUT FILE.NAME
IF FILE.NAME EQ "" THEN FILE.NAME = "CNT"
*
PRINT
PRINT "Enter proc names prefix (blank): ":
INPUT PROC.NAME.PREFIX
IF PROC.NAME.PREFIX[LEN(PROC.NAME.PREFIX),1] NE '.' AND LEN(PROC.NAME.PREFIX) THEN PROC.NAME.PREFIX = PROC.NAME.PREFIX:"."
*
PRINT
PRINT "Use the suppress item names option on data areas (Y/N)? ":
INPUT S.OPTION.FLAG
IF S.OPTION.FLAG EQ "Y" THEN S.OPTION.FLAG = 1 ELSE S.OPTION.FLAG = ""
*
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
OPEN "",FILE.NAME TO LST.FILE ELSE STOP
READ FILE.LIST FROM LST.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-ATT 8192':AM:'PP':AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-LOAD MD (O)':AM:'PP':AM:'C':AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-LOAD ':FILE.NAME:' (O)':AM:'PP':AM:'C':AM
PROC2 = "PQN":AM
PROC3 = "PQN":AM
PROC3 = PROC3:'C':AM:'C':AM:'HT-ATT 8192':AM:'PP':AM
PROC3 = PROC3:'C':AM:'C':AM:'HSELECT MD "':PROC.NAME.PREFIX:'TLOADALLF" "':PROC.NAME.PREFIX:'LISTALLF" "':PROC.NAME.PREFIX:'TDUMPALLF" "':PROC.NAME.PREFIX:'TCREALLF.MIN"':AM:'STON':AM:'HT-DUMP MD<':AM:'PP':AM:'C':AM
PROC3 = PROC3:'C':AM:'C':AM:'HSELECT ':FILE.NAME:' "':LIST.NAME:'"':AM:'STON':AM:'HT-DUMP ':FILE.NAME:'<':AM:'PP':AM:'C':AM
PROC4 = "PQN":AM
*
*FILE.LIST = DELETE(FILE.LIST,1,0,0)
CN = 0
*
LOOP
*
FNAME = FILE.LIST<1>
CN = CN + 1
*
IF FNAME[1,1] NE "*" THEN
*
IF FNAME[1,5] EQ "DICT " OR FNAME[1,5] EQ "DICT." THEN
FDICT = "DICT"
FNAME = TRIM(FNAME)
FNAME = FIELD(FNAME," ",2)
DATA.FLAG = ""
END ELSE
FDICT = ""
DATA.FLAG = 1
END
*
END
*
WHILE FILE.LIST NE "" DO
*
IF FILE.NAME[1,1] NE "*" THEN
*
DMOD = '37,1'
PROC1 = PROC1:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM:'C@HT-FWD 1':AM:'C@PP':AM
PROC2 = PROC2:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
PROC3 = PROC3:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
PROC4 = PROC4:'C':AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
*
IF INDEX(FNAME,"BP",1) OR INDEX(FNAME,"MACRO",1) OR INDEX(FNAME,"MODEL.",1) THEN BP.FLAG = 1 ELSE
IF INDEX(FNAME,"MENUS",1) OR INDEX(FNAME,"PL",1) OR INDEX(FNAME,"HLP",1) THEN BP.FLAG = 1 ELSE BP.FLAG = ""
END
*
IF NOT(BP.FLAG) THEN
PROC1 = PROC1:'C':AM:'HT-LOAD DICT ':FNAME:' (O)':AM:'PP':AM
PROC3 = PROC3:'C':AM:'HS-DUMP DICT ':FNAME:AM:'PP':AM
PROC4 = PROC4:'C':AM:'HSORT ONLY DICT ':FNAME:' (P)':AM:'PP':AM
PROC4 = PROC4:'C':AM:'HLISTDICT ':FNAME:' (P)':AM:'PP':AM
END
*
IF NOT(DATA.FLAG) THEN
PROC2 = PROC2:'C':AM:'HCREATE-FILE (DICT ':FNAME:' 19,1 )':AM:'PP':AM:'C':AM
END ELSE
DMOD = '103,1'
END
*
IF DATA.FLAG THEN
PROC1 = PROC1:'C':AM:'HT-LOAD ':FNAME:' (O'
IF S.OPTION.FLAG THEN PROC1 = PROC1:',S'
PROC1 = PROC1:')':AM:'PP':AM:'C':AM:'C':AM
PROC2 = PROC2:'C':AM:'HCREATE-FILE (':FNAME:' 19,1 ':DMOD:')':AM:'PP':AM:'C':AM
PROC3 = PROC3:'C':AM:'HS-DUMP ':FNAME:AM:'PP':AM:'C':AM:'C':AM
PROC4 = PROC4:'C':AM:'HSORT ONLY ':FNAME:' (P)':AM:'PP':AM:'C':AM:'C':AM
END
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
*
END; *# OF FNAME[1,1] NE "*"
*
PRINT
PRINT CN "R#3":") ":FDICT:" ":FNAME
*
REPEAT
*
BEGIN CASE
CASE OPSYS EQ 'M'
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC3 = PROC3:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC4 = PROC4:'C':AM:'C':AM:'C':AM:'RTN':AM
CASE 1
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'C@X':AM:'RTN':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
PROC3 = PROC3:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
PROC4 = PROC4:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
END CASE
*
WRITE PROC1 ON MD.FILE,PROC.NAME.PREFIX:"TLOADALLF"
WRITE PROC1 ON BP.FILE,PROC.NAME.PREFIX:"TLOADALLF"
WRITE PROC1 ON PL.FILE,PROC.NAME.PREFIX:"TLOADALLF"
WRITE PROC2 ON MD.FILE,PROC.NAME.PREFIX:"TCREALLF.MIN"
WRITE PROC2 ON BP.FILE,PROC.NAME.PREFIX:"TCREALLF.MIN"
WRITE PROC2 ON PL.FILE,PROC.NAME.PREFIX:"TCREALLF.MIN"
WRITE PROC3 ON MD.FILE,PROC.NAME.PREFIX:"TDUMPALLF"
WRITE PROC3 ON BP.FILE,PROC.NAME.PREFIX:"TDUMPALLF"
WRITE PROC3 ON PL.FILE,PROC.NAME.PREFIX:"TDUMPALLF"
WRITE PROC4 ON MD.FILE,PROC.NAME.PREFIX:"LISTALLF"
WRITE PROC4 ON BP.FILE,PROC.NAME.PREFIX:"LISTALLF"
WRITE PROC4 ON PL.FILE,PROC.NAME.PREFIX:"LISTALLF"
*
STOP
END
*
~MDD.TAPE.TO.MDD.CLEAR~
*PROGRAM: MDD.TAPE.TO.MDD.CLEAR
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,"FILES" ELSE STOP
*
PROC1 = "PQN":AM
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HCLEAR-FILE (DICT ':FNAME:AM
PROC1 = PROC1 :'P':AM
END
PROC1 = PROC1:'C':AM:'HCLEAR-FILE (DATA ':FNAME:AM
PROC1 = PROC1:'P':AM:'C':AM:'C':AM:'C':AM
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,"TCLRALLF"
WRITE PROC1 ON BP.FILE,"TCLRALLF"
*
STOP
END
*
~MDD.TAPE.TO.MDD.PROCWRITE~
*PROGRAM: TAPE.TO.MDD.PROCWRITE
*
*
*$INCLUDE IBP SYS.STANDARD.FUNCTIONS
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,"FILES" ELSE STOP
*
PROC1 = "PQN":AM
PROC1 =  PROC1:"C":AM:"C":AM:"HT-REW":AM:"P":AM:"C":AM:"C":AM
PROC2 = "PQN":AM
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
IF FNAME[1,1] NE "*" THEN
*
DMOD = '37,1'
PROC1 = PROC1:'C':AM:'C':AM
PROC1 = PROC1:'O      ':FNAME:AM:'O':AM:'O':AM
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HT-FWD 1':AM:'P':AM
PROC1 = PROC1:'HT-LOAD DICT ':FNAME:AM
PROC1 = PROC1:'P':AM
END ELSE
DMOD = '103,1'
END
PROC1 = PROC1:'HT-FWD 1':AM:'P':AM
PROC1 = PROC1:'HT-LOAD ':FNAME:AM:'P':AM:'C':AM:'C':AM
PROC2 = PROC2:'HCREATE-FILE (':FNAME:' 19,1 ':DMOD:')':AM:'P':AM:'C':AM:'C':AM
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,"TLOADALLF"
WRITE PROC1 ON BP.FILE,"TLOADALLF"
WRITE PROC2 ON MDI.FILE,"TCREALLF"
WRITE PROC2 ON BP.FILE,"TCREALLF"
*
STOP
END
*
~PROC.TEST~
*PROGRAM: PROC.TEST
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
TEMP = "CALL-PL DAVE"
EXECUTE TEMP
*
*
STOP
*
END
~REV.TO.ULT.DOS~
*PROGRAM: REV.TO.ULT.DOS
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF
PROC1 = ""
*
PRINT "Which PICK file? ":
INPUT FNAME
*
PRINT "Which Output file? ":
INPUT PC.FNAME
IF PC.FNAME EQ '' THEN PC.FNAME = FNAME
*
PRINT "Enter the name of the file list (MD)? ":
INPUT LISTNAME
IF LISTNAME EQ '' THEN LISTNAME = "FILES"
*
PRINT "Are any hex conversions necessary (Y/<cr>)? ":
INPUT HEXCONV.REQD; IF HEXCONV.REQD = "Y" THEN HEXCONV.REQD = 1 ELSE HEXCONV.REQD = ""
*
PRINT "Convert seven to eight bit delimiters (Y/<cr>)? ":
INPUT SBIT.REQD; IF SBIT.REQD = "Y" THEN SBIT.REQD = 1 ELSE SBIT.REQD = ""
*
PROC1="PQN":CRLF
IF FNAME NE "*" THEN
IF INDEX(FNAME,"USING",1) THEN
DICT.NAME = FIELD(FNAME,"USING",2)[6,999]
LOOP WHILE DICT.NAME[1,1] EQ " " AND LEN(DICT.NAME) DO DICT.NAME = DICT.NAME[2,999] REPEAT
FNAME = FIELD(FNAME," ",1)
IF INDEX(DICT.NAME,",",1) THEN
DICT.DICT = FIELD(DICT.NAME,",",1)
DICT.NAME = FIELD(DICT.NAME,",",2)
END ELSE
DICT.DICT = ""
END
END ELSE
DICT.NAME = FNAME
DICT.DICT = "DICT"
END
OPEN "",FNAME TO TFR.FILE ELSE STOP
*
*
IF HEXCONV.REQD THEN
OPEN DICT.DICT,DICT.NAME TO TFR.DICT ELSE STOP
ERR.CN = 0
FOR AM.CN = 0 TO 150 UNTIL ERR.CN > 30
READ DICT.ITEM FROM TFR.DICT,AM.CN THEN
IF INDEX(DICT.ITEM<7>,"MX",1) THEN HEXFLAG<AM.CN+1> = 1 ELSE HEXFLAG<AM.CN+1> = 0
END ELSE
ERR.CN = ERR.CN + 1
HEXFLAG<AM.CN+1> = 0
END
NEXT AM.CN
END ELSE
HEXFLAG = ""
END
*
*
OPEN "",PC.FNAME TO OUT.FILE ELSE STOP
EXEC.VERB =  "CREATE-FILE ":PC.FNAME:" 11,1 31,1"
PRINT EXEC.VERB
EXECUTE EXEC.VERB
EXEC.VERB =  "CLEAR-FILE DATA ":PC.FNAME
PRINT EXEC.VERB
EXECUTE EXEC.VERB
GOSUB CONVERT.FILE
END ELSE
OPEN "","MD" TO MDI.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,LISTNAME ELSE STOP
PROC1 = '~':LISTNAME:'~':CRLF:'PQN':CRLF:'C':CRLF:'C':CRLF
*CN = 1
*LOOP CN = CN + 1 WHILE FILE.LIST<CN> NE '' DO
*REPEAT
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
*GARBAGECOLLECT
FNAME = FIELD(FILE.LIST<1>," ",3)
FNAME = FILE.LIST<1>[COL1()+1,999]
IF INDEX(FNAME,"USING",1) THEN
DICT.NAME = FIELD(FNAME,"USING",2)[6,999]
LOOP WHILE DICT.NAME[1,1] EQ " " AND LEN(DICT.NAME) DO DICT.NAME = DICT.NAME[2,999] REPEAT
FNAME = FIELD(FNAME," ",1)
IF INDEX(DICT.NAME,",",1) THEN
DICT.DICT = FIELD(DICT.NAME,",",1)
DICT.NAME = FIELD(DICT.NAME,",",2)
END ELSE
DICT.DICT = "DICT"
END
END ELSE
DICT.NAME = FNAME
DICT.DICT = "DICT"
END
*
PROC1 = PROC1:'C':CRLF:'HCLEAR-FILE DATA ':FNAME:CRLF:'PP':CRLF
PRINT FNAME
PC.FNAME = "OUT.":FNAME
WHILE FILE.LIST NE "" DO
EXEC.VERB =  "CREATE-FILE ":PC.FNAME:" 11,1 31,1"
PRINT EXEC.VERB
EXECUTE EXEC.VERB
*
EXEC.VERB =  "CLEAR-FILE DATA ":PC.FNAME
PRINT EXEC.VERB
EXECUTE EXEC.VERB
SKIP.FLAG = ""
OPEN "",FNAME TO TFR.FILE ELSE SKIP.FLAG = 1
*
*
IF HEXCONV.REQD THEN
*
OPEN DICT.DICT,DICT.NAME TO TFR.DICT THEN
ERR.CN = 0
HEXFLAG = ""
PRINT
PRINT
PRINT FNAME
PRINT "*************************"
FOR AM.CN = 0 TO 150 UNTIL ERR.CN > 30
READ DICT.ITEM FROM TFR.DICT,AM.CN THEN
IF INDEX(DICT.ITEM<7>,"MX",1) THEN HEXFLAG<AM.CN+1> = 1 ELSE HEXFLAG<AM.CN+1> = 0
PRINT DICT.ITEM<7>
PRINT "*"
END ELSE
ERR.CN = ERR.CN + 1
HEXFLAG<AM.CN+1> = 0
PRINT "."
END
NEXT AM.CN
FOR B = 1 TO AM.CN
PRINT "A ":B-1:" - ":HEXFLAG<B>
NEXT B
END ELSE
HEXFLAG = ""
END
END ELSE
HEXFLAG = ""
END
*
OPEN "",PC.FNAME TO OUT.FILE ELSE SKIP.FLAG = 1
IF NOT(SKIP.FLAG) THEN
GOSUB CONVERT.FILE
PROC1 = PROC1:'C':FNAME:CRLF:'C':CRLF
END ELSE
STAT = 1
CALL PRINTER.ON(STAT)
PRINT FNAME:" WAS NOT CONVERTED TO PICK FORMAT!"
PRINT
PRINTER OFF
END
FILE.LIST = DELETE(FILE.LIST,1,0,0)
WRITE PROC1 ON MDI.FILE,LISTNAME:".CONV"
REPEAT
END
*
PROC1 = PROC1:'C':CRLF:'C':CRLF:'C':CRLF:'X':CRLF
WRITE PROC1 ON MDI.FILE,LISTNAME:".CONV"
*
STOP
*
CONVERT.FILE: *
*
*PRINT "Delete any DOS 'TEMP' files ..."; PCEXECUTE "DEL TEMP.0??"
*
FIRST = 1
*EXECUTE "GET-LIST ":FNAME, //SELECT. > ID
EXECUTE "GET-LIST ":FNAME
READNEXT ID ELSE
*PRINT " !!! ":
*EXECUTE "GET-LIST ":FNAME, //SELECT. > ID
READNEXT ID ELSE
PRINT " !! ":
*EXECUTE "SSELECT ":FNAME, //IN. < "SAVE-LIST ":FNAME
*EXECUTE "GET-LIST ":FNAME, //SELECT. > ID
*EXECUTE "SSELECT ":FNAME
*
EXEC.VERB = "SSELECT ":FNAME
PRINT EXEC.VERB
EXECUTE EXEC.VERB
*, //SELECT. > ID
*
*EXEC.VERB = "SAVE-LIST ":FNAME
*PRINT EXEC.VERB
*EXECUTE EXEC.VERB, //SELECT. < WID
*
*EXEC.VERB = "QSELECT POINTER-FILE ":FNAME
*PRINT EXEC.VERB
*EXECUTE EXEC.VERB, //SELECT. > ID
*
READNEXT ID ELSE ID = "@"
IF ID = "@" THEN PRINT " ! "
END
END
*
LOOP
IF NOT(FIRST) THEN
READNEXT ID ELSE ID = "@"
END ELSE FIRST = ''
UNTIL ID = "@" DO
*
READ REVITEM FROM TFR.FILE,ID THEN
IF HEXCONV.REQD THEN
IF HEXFLAG<1> AND NUM(ID) THEN
OUT.ID = ''
CALL PACK.NUMBER(ID,OUT.ID)
END
END
PRINT; PRINT ID
AMAX = DCOUNT(REVITEM,AM)
FOR AM.CN = 1 TO AMAX
LINE = REVITEM<AM.CN>
*PRINT ">"
*PRINT AM.CN "R#3":">":LINE
*
IF SBIT.REQD THEN GOSUB CONV.SBIT
*PRINT AM.CN "R#3":">":LINE
*
*
IF HEXCONV.REQD THEN
IF HEXFLAG<AM.CN+1> THEN
*
FIELD.IN = LINE
VMAX = DCOUNT(FIELD.IN,VM)
FOR VC = 1 TO VMAX
SMAX = DCOUNT(FIELD.IN,SVM)
FOR SVC = 1 TO SMAX
NUM.IN = FIELD.IN<1,VC,SVC>
CALL PACK.NUMBER(NUM.IN,NUM.OUT)
FIELD.IN<1,VC,SVC> = NUM.OUT
NEXT SVC
NEXT VC
*
LINE = FIELD.IN
END
END
REVITEM<AM.CN> = LINE
*PRINT AM.CN "R#3":">":LINE
NEXT AM.CN
*PRINT "->"
*
LTH = LEN(REVITEM); PRINT LTH "R#10"
*WRITE REVITEM ON OUT.FILE,ID
WRITE REVITEM ON TFR.FILE,ID
PRINT "--- Writing ":ID:" ---"
PRINT
DOSID = FNAME[1,8]
TEMP = 0
LOOP TEMP=TEMP+1 WHILE DOSID[TEMP,1] NE '' DO
IF DOSID[TEMP,1] EQ "." THEN
DOSID = DOSID[1,TEMP-1]:"O":DOSID[TEMP+1,999]
END
REPEAT
*PROC1 = PROC1:'C':CRLF:'C':CRLF:'RI':CRLF:'RO':CRLF:'IHPICK-PC OUT.':FNAME:' TO "':DOSID:'.TLD" (T)':CRLF:'[MD PICK-PC]':CRLF
*
*WRITE DOSITEM ON OUT.FILE,ID
*PRINT "--- Writing ":ID:" ---"
*PROC1 = PROC1:'C':CRLF:'C':CRLF:'RI':CRLF:'RO':CRLF:'IHPICK-PC OUT.':FNAME:' TO "':DOSID:'.TLD" (T)':CRLF:'[MD PICK-PC]':CRLF
END
REPEAT
*
*
DOSID = FNAME[1,8]
TEMP = 0
LOOP TEMP=TEMP+1 WHILE DOSID[TEMP,1] NE '' DO
IF DOSID[TEMP,1] EQ "." THEN
DOSID = DOSID[1,TEMP-1]:"O":DOSID[TEMP+1,999]
END
REPEAT
PROC1 = PROC1:'C':CRLF:'C':CRLF:'RI':CRLF:'RO':CRLF:'IHPICK-PC OUT.':FNAME:' TO "':DOSID:'.TLD" (T)':CRLF:'[MD PICK-PC]':CRLF
RETURN
*
CONV.SBIT: *
*
VMAX = COUNT(LINE,"}")
FOR VC = 1 TO VMAX
PRINT "v":
LOC = INDEX(LINE,"}",1)
LINE = LINE[1,LOC-1]:VM:LINE[LOC+1,9999]
NEXT VC
*
REVERSE.MAX = COUNT(LINE,SVM)
FOR RVC = 1 TO REVERSE.MAX
PRINT "r":
PRINT BELL:
LOC = INDEX(LINE,SVM,1)
LINE = LINE[1,LOC-1]:"\":LINE[LOC+1,9999]
NEXT RVC
*
SMAX = COUNT(LINE,"|")
FOR SVC = 1 TO SMAX
PRINT "s":
LOC = INDEX(LINE,"|",1)
LINE = LINE[1,LOC-1]:SVM:LINE[LOC+1,9999]
NEXT SVC
*
RETURN
END
~SELECT.BILL.FREQS~
SUBROUTINE SELECT.BILL.FREQS(FCV,FCN,CLC,LN,RNTP.RSP,BFS,BFS.ANN,MAT TDSC)
* PROGRAM:           SELECT.BILL.FREQS
* DESCRIPTION:       SELECT FREQUENCIES
*                    27 NOV 85  D. HORSMAN
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
DIM TDSC(4)
TDSC(1) = "LATE PAYMENT NOTICE"; TDSC(2) = "STATEMENT/INVOICE"
TDSC(3) = "ANNUAL PAYMENT INVOICE"; TDSC(4) = "CLOSING INVOICE"
*
FCV = "^}M}B}Q}H}Y":AM:"0}1}2}3}6}12":AM:"Disconnected}Monthly}Bi-monthly}Quarterly}Semi-Annually}Annually"
FCV.TMP = FCV<1>
FCN = "^,M,B,Q,H,Y"
CLC = "56}26}94}50}255}32}52}21}54}6}53}1}27":AM:"-1}-1}-1}1}T}1}0}0}0}0}-999}-999}999"
*
!
*
IF RNTP.RSP = "REGULAR" OR RNTP.RSP = "LATE" THEN
BFS.ANN = 1
BFS = FCN
END ELSE IF RNTP.RSP = "SELECT" THEN
LN = LN+2
PRINT @(8,LN):"Frequencies Selection":
BFS = ""
ASW = ""
CN = 0
LOOP CN = CN + 1 WHILE FCV.TMP # "" DO
PRINT @(10,LN+CN+1):FCV<3,CN> "L#15":" - Y":; ASW<CN> = "Y"
DEL FCV.TMP<1,1,0>
REPEAT
CN = 1
FCV.TMP = FCV<1>
LOOP WHILE FCV.TMP # "" DO
RSP = ASW<CN>
PRINT @(28,LN+CN+1):
INPUT RSP,1:
IF RSP # "Y" AND RSP # "N" THEN
TEMP = SEQ(RSP)
IF TEMP = 27 THEN PRINT CLS:; PRINT; STOP
LOCATE TEMP IN CLC<1> SETTING LC THEN TEMP1 = CLC<2,LC> ELSE TEMP1 = 0
IF NOT(NUM(TEMP1)) THEN
IF TEMP1 # "T" THEN TEMP1 = 0 ELSE
IF ASW<CN> = "Y" THEN ASW<CN> = "N" ELSE ASW<CN> = "Y"
TEMP1 = 1
END
END
PRINT @(28,LN+CN+1):ASW<CN>:
CN = CN + TEMP1
IF CN < 1 THEN CN = 1
END ELSE
PRINT @(28,LN+CN+1):RSP:
ASW<CN> = RSP
CN = CN + 1
END
DEL FCV.TMP<1,1,0>
REPEAT
BFS.ANN = ""
CN = 0
FCV.TMP = FCV<1>
LOOP CN = CN + 1 WHILE FCV.TMP # "" DO
RSP = ASW<CN>
IF RSP = "Y" THEN
BFS = BFS:",":FCV<1,CN>
IF FCV<1,CN> = "Y" THEN BFS.ANN = 1
END
LN = LN+1
DEL FCV.TMP<1,1,0>
REPEAT
LN = LN+1
BFS = BFS[2,99]
IF BFS = "" THEN STOP
END
*
RETURN
~SET.REMOTE~
*PROGRAM: SET.REMOTE
*
* Allows entry of lines into remote procedure proc
* in KBIL-INSTALL-5.MD and SYS
*
* AUTHOR: DAVID G. HORSMAN
* COMPANY: MACROSCOPE DESIGN MATRIX
*
* COPYRIGHT: (C) 1992 MACROSCOPE DESIGN MATRIX
*            ALL RIGHTS RESERVED
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "LISTS" TO LISTS.FILE ELSE STOP
OPEN "SYS" TO SYS.FILE ELSE STOP
OPEN "OUT.BP.INST" TO MD.FILE ELSE
OPEN "OUT.MD" TO MD.FILE ELSE STOP
END
*
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY.":PORT,ONE ELSE
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY",ONE ELSE TERM.DISP = TRUE
END
*
PROC.FL = TRUE
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
! MAIN
*
CONT = TRUE; PROC.CONT = TRUE
PROC1 = EMPTY; PROC.CN = ONE; PROC.CN.MAX = ZERO; FIRST = TRUE
READ PROC1 FROM SYS.FILE,"KBIL.REMOTE.":PORT ELSE PROC1 = EMPTY; FIRST = FALSE
PRINT
*
! MAIN LOOP
*
LOOP
*
! Loop to input proc lines
*
IF NOT(FIRST) THEN
*
IF PROC.CONT THEN PRINT "Enter your remote procedure, <cr> to end: "
*
LOOP
*
IF PROC.CONT THEN
PRINT PROC.CN "R#3":" ":
INPUT PROC.LINE:
IF PROC.LINE EQ "KILL" THEN STOP
IF PROC.LINE EQ EMPTY THEN PROC.CONT = FALSE
PRINT
END
*
WHILE PROC.CONT DO
PROC1<PROC.CN> = PROC.LINE
PROC.CN = PROC.CN + ONE; PROC.CN.MAX = PROC.CN.MAX + ONE
REPEAT
*
END ELSE FIRST = FALSE
*
! Loop to display entire procedure
*
PRINT
PRINT "Your remote batch contains the following lines:"
PROC.CN.MAX = DCOUNT(PROC1,AM)
FOR PROC.CN = ONE TO PROC.CN.MAX
PRINT PROC.CN "R#3":" ":PROC1<PROC.CN>
NEXT PROC.CN
PRINT
*
! Loop to allow changes, end, or clear & re-enter
*
RSP.CONT = TRUE
LOOP
*
PRINT "Enter a line number, END to end, or NEW to re-enter it: ":
INPUT RSP:
PRINT
*
IF RSP EQ "KILL" THEN STOP
*
IF RSP EQ "NEW" THEN
PROC.CONT = TRUE; RSP.CONT = FALSE
PROC1 = EMPTY; PROC.CN = ONE; PROC.CN.MAX = ZERO
END
*
IF NUM(RSP) THEN
IF RSP GT ZERO AND RSP LE PROC.CN.MAX + ONE THEN
PROC.CN = RSP
PRINT PROC.CN "R#3":" ":PROC1<PROC.CN>
PRINT "Delete it (Y/<cr>): ":; INPUT RSP
IF RSP EQ "Y" THEN
DEL PROC1<PROC.CN>
END ELSE
PROC.CONT = TRUE
FOR CN = ONE TO PROC.CN - ONE
PRINT CN "R#3":" ":PROC1<CN>
NEXT CN
END
RSP.CONT = FALSE
END
END
*
IF RSP EQ "END" THEN CONT = FALSE; PROC.CONT = FALSE; RSP.CONT = FALSE
*
WHILE RSP.CONT DO REPEAT
*
*
WHILE CONT DO REPEAT
*
!
*
READ PROC.REMOTE FROM SYS.FILE,"KBIL.REMOTE.BASE" ELSE
PROC.REMOTE = "PQN":AM:"O":AM:"O NOTHING TO DO . . . ":AM:"O":AM:"CX":AM:"RTN"
END
*
!
*
TMP = PROC1<ONE>
*
LOCATE "*MSG.LNS*" IN PROC.REMOTE SETTING LOC ELSE LOC = 9
*
TMP = "HSYS.MSG.SEND PROGRAMS ":TMP[TWO,9999]:AM:"STON":AM:"HPROGRAMS<":AM:"H":TMP[TWO,9999]:"<":AM:"P":AM:"C"
*
PROC.REMOTE<LOC> = TMP
*
!
*
LOCATE "*INS.LNS*" IN PROC.REMOTE SETTING LOC ELSE LOC = 8
*
PROC.REMOTE<LOC> = PROC1
*
WRITE PROC1 ON SYS.FILE,"KBIL.REMOTE.":PORT
WRITE PROC.REMOTE ON SYS.FILE,"KBIL.REMOTE"
*
WRITE PROC.REMOTE ON MD.FILE,"KBIL.REMOTE"
*
*
STOP
*
*
END
~SYS.COMMON~
*CODE.SEGMENT: SYS.COMMON
*
*
COMMON SYS.PROG,SYS.LOCT,SYS.SLOC,SYS.FILE,SYS.ITEM
COMMON FUNCTION,SUB.FUNCTION
COMMON SUBR.FUNCTION,SUBR.SUB.FUNCTION
COMMON CALL.FUNCTION,CALL.SUB.FUNCTION
COMMON USER.NAME,USER.CO.CODE
COMMON MENU.APPL,MENU.SUB.APPL,MENU.GRP.APPL
COMMON MENU.NAME,PRMPTING,TOPIC.KEY,MENU.CONTROL
COMMON TASK.NUM,TASK.STEP,TOPIC.ID,USER.KEY,PSD.KEY,SPTM.KEY,CTC.KEY
COMMON WAIT.FLAG,USER.MODE,USER.ABORT,SYS.ABORT,USER.LOCKED,CHECK.TIME
COMMON SYS.VALUES,SYS.ANSWERS,LAST.LOCT
COMMON SCH.FLAG,MSG.FLAG,TCL.FLAG,OFF.FLAG
COMMON CO.DATA,SY.FILE,PS.FILE,MENU.PARAMS,MENU.APPL.DESC
COMMON EXEC.VERB,EXEC.FILE.ITEM,MENU.FILE,MENU.SUBJCT,MENU.PREV
COMMON LCK.STAT,PORTD
COMMON STRUCT(120),USER.UPD(20)
*
*,MENU.EI.APPL,MENU.NUM,MENU.TYPE
*COMMON LO.D.M,HI.D.M,HI.S.M,LO.TCL.M,LO.T.M,HI.T.M,LO.O.M,HI.O.M,LO.M.M,HI.M.M,LO.S.M
*COMMON OFF.RSP,TCL.RSP,SYS.RSP,BELL,LF,FF,CR,SVM,VM,AM,WHO,PORT,ACCT,CLS,CLL
*,STAT.CHECK
*COMMON YES,NO,TRUE,FALSE,TERMINAL,RVB,RVE
*,MENU(25),SLOC(25),PRMPT(25),PORTD(25)
*,MODE.DESC(30),STAT.DESC(15)
*
*
~SYS.CONV.AM.TO.VM~
*PROGRAM: SYS.CONV.AM.TO.VM
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
TF = TRUE
ITEM.ON.FILE = FALSE
ITEM.NAME = TRUE
FILE.OPEN = FALSE
FILE.NAME = EMPTY
*
!
*
LOOP
*
LOOP
PRINT "FILE: ":
INPUT FILE.NAME
FILE.OPEN = TRUE
OPEN FILE.NAME TO INP.FILE ELSE FILE.OPEN = FALSE
WHILE LEN(FILE.NAME) AND NOT(FILE.OPEN) DO PRINT BELL: REPEAT
*
*
WHILE LEN(FILE.NAME) DO
*
LOOP
*
LOOP
PRINT "ITEM: ":
INPUT ITEM.NAME
ITEM.ON.FILE = TRUE
READ ITEM FROM INP.FILE,ITEM.NAME ELSE ITEM.ON.FILE = FALSE
WHILE LEN(ITEM.NAME) AND NOT(ITEM.ON.FILE) DO PRINT BELL: REPEAT
*
*
WHILE LEN(ITEM.NAME) DO
*
LOOP
*
LOOP
PRINT
PRINT "ATTRIBUTE":
INPUT ATTR
IF LEN(ATTR) THEN
IF NOT(NUM(ATTR)) THEN ATTR = -ONE ELSE
IF ATTR GT DCOUNT(ITEM,AM) THEN ATTR = -ONE
IF ATTR LT ZERO THEN ATTR = -ONE
END
END
WHILE ATTR EQ -ONE DO PRINT BELL: REPEAT
*
WHILE ATTR GE ZERO DO
*
*
IF ATTR THEN
*
CN.START = ATTR - 10
IF CN.START LT ONE THEN CN.START = ONE
CN.END = CN.START + 18
*
FOR CN = CN.START TO CN.END
IF CN EQ ATTR OR CN EQ ATTR-1 THEN
PRINT "*":
END ELSE
PRINT " ":
END
PRINT CN "R#3":ITEM<CN> "L#75"
NEXT CN
*
*
PRINT "Y/N: ":; INPUT RSP
*
END ELSE
RSP = "Y"
END
*
!
*
LINE = ITEM
GOSUB CONV.AM.TO.VM
ITEM = LINE
*
WRITE ITEM ON INP.FILE,ITEM.NAME
*
!
*
REPEAT
*
REPEAT
*
REPEAT
*
*
STOP
*
!
*
CONV.AM.TO.VM: *
*
$INCLUDE IBP SYS.INCL.CONV.AM.TO.VM
*
RETURN
*
END
~SYS.CONV.NUM.FROM.HEX~
*PROGRAM: SYS.CONV.NUM.FROM.HEX
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PROC.FL = TRUE
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
IF PROC.BUFFER[ONE,3] EQ "SET" THEN PROC.FL = FALSE
IF PROC.BUFFER EQ EMPTY THEN PROC.FL = FALSE
*
*
!
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO OFF
END
*
!
*
LOOP
*
LOOP
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT "Enter number: ":
END
*
INPUT NUM.IN:
IF NUM.IN EQ "KILL" THEN STOP
NUM.VALID = TRUE
WHILE NOT(NUM.VALID) DO
*????
REPEAT
*
IF TERM.DISP AND PROC.FL THEN PRINT NUM.IN:
*
!
*
LOOP
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT "Enter base: ":
END
*
INPUT NUM.BASE:
IF NUM.BASE EQ "KILL" THEN STOP
IF NUM(NUM.BASE) THEN
IF NUM.BASE LT ONE THEN NUM.BASE = "A"
END
WHILE NOT(NUM(NUM.BASE)) DO
*????
REPEAT
*
IF TERM.DISP AND PROC.FL THEN PRINT NUM.BASE:
*
!
*
TMP = NUM.IN; TMP1 = EMPTY; TMP2 = NUM.BASE
$INCLUDE IBP SYS.INCL.CONV.NUM.FROM.HEX
NUM.OUT = TMP1
*
!
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO ON
END
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT
PRINT " Number: ":NUM.IN
PRINT " Number in base ":NUM.BASE:" is ":NUM.OUT
END
*
WHILE TRUE DO REPEAT
*
STOP
*
END
~SYS.CONV.NUM.TO.HEX~
*PROGRAM: SYS.CONV.NUM.TO.HEX
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PROC.FL = TRUE
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
IF PROC.BUFFER[ONE,3] EQ "SET" THEN PROC.FL = FALSE
IF PROC.BUFFER EQ EMPTY THEN PROC.FL = FALSE
*
*
!
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO OFF
END
*
!
*
LOOP
*
LOOP
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT "Enter number: ":
END
*
INPUT NUM.IN:
IF NUM.IN EQ "KILL" THEN STOP
WHILE NOT(NUM(NUM.IN)) DO
*????
REPEAT
*
IF TERM.DISP AND PROC.FL THEN PRINT NUM.IN:
*
!
*
LOOP
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT "Enter base: ":
END
*
INPUT NUM.BASE:
IF NUM.BASE EQ "KILL" THEN STOP
IF NUM(NUM.BASE) THEN
IF NUM.BASE LT ONE THEN NUM.BASE = "A"
END
WHILE NOT(NUM(NUM.BASE)) DO
*????
REPEAT
*
IF TERM.DISP AND PROC.FL THEN PRINT NUM.BASE:
*
!
*
TMP = NUM.IN; TMP1 = EMPTY; TMP2 = NUM.BASE
$INCLUDE IBP SYS.INCL.CONV.NUM.TO.HEX
NUM.OUT = TMP1
*
!
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO ON
END
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT
PRINT " Number: ":NUM.IN
PRINT " Number in base ":NUM.BASE:" is ":NUM.OUT
END
*
WHILE TRUE DO REPEAT
*
STOP
*
END
~SYS.ERROR.STRUCT~
*CODE.SEGMENT: SYS.ERROR.STRUCT
*
!
*#INCLUDE DH.BP SYS.ERROR.CONTROL
*#
*#
*# ERROR.CODE1 = 0        DON'T DISPLAY (SECURITY)
*# ERROR.CODE1 = 1 OR 2   DISPLAY
*# ERROR.CODE1 = 3        SLAVE MODE DON'T INPUT
*# ERROR.CODE1 = 4        DIAL-UP PORT HUNG DON'T DISP OR INPUT
*#
*# ERROR.CODE2 = SEVERITY
*#
*# ERROR.CODE3 = WRITE FLAG
*#
*# ERROR.CODE4 = BELL FLAG
*#
*# ERROR.CODE5 = ENTRY FLAG (ERROR.RSP)
*#
*#
ERROR.CONTROL: *# Subroutine to display & log errors
ERROR.CN = 0
ERROR.FATAL = 99
*ERROR.READ = 0
*ERROR.WRITE = 0
*#
LOOP
ERROR.CN = ERROR.CN + 1
ERROR.TEXT1 = ERROR.TEXT<1>
ERROR.CODE1 = ERROR.CODE<1>[1,1]
ERROR.CODE2 = ERROR.CODE<1>[2,1]
ERROR.CODE3 = ERROR.CODE<1>[3,1]
ERROR.CODE4 = ERROR.CODE<1>[4,1]
ERROR.CODE5 = ERROR.CODE<1>[5,1]
*#
*#WHILE LEN(ERROR.TEXT:ERROR.CODE) DO
IF LEN(ERROR.TEXT<2>:ERROR.CODE<2>) THEN ERROR.MORE = 1 ELSE ERROR.MORE = 0
IF LEN(ERROR.TEXT:ERROR.CODE) THEN
*#
IF ERROR.CODE2 LT 4 AND ERROR.CODE1 THEN ERROR.CODE3 = 1
*#
IF STRUCT(27)<1,PORT+1> GT 0 AND STRUCT(27)<1,PORT+1> LT 11 THEN ERROR.CODE1 = 3
*#
IF ERROR.CODE1 AND ERROR.CODE1 LT 4 THEN
ERROR.LN = ERROR.CODE[6,2]
IF NOT(NUM(ERROR.LN)) THEN ERROR.LN = 22
IF NOT(LEN(ERROR.LN)) OR ERROR.LN LT 0 THEN ERROR.LN = 22
ERROR.CL = ERROR.CODE[8,2]
IF NOT(NUM(ERROR.CL)) THEN ERROR.CL = 0
IF NOT(LEN(ERROR.CL)) OR ERROR.CL LT 0 THEN ERROR.CL = 0
IF ERROR.CODE2 LT 4 THEN
ERROR.LN = 10
PRINT @(0,5):CLS:BELL:
RQM
PRINT BELL:
ERROR.CODE5 = 1
END
*#PRINT @(0,21):CLL:
IF NOT(ERROR.CL) THEN PRINT @(0,ERROR.LN):CLL:
PRINT @(ERROR.CL,ERROR.LN):
IF ERROR.CODE4 THEN PRINT BELL:; RQM
IF ERROR.CODE1 EQ 1 THEN
ERROR.DISP = TRIM((USER.NAME:", ":ERROR.TEXT1)[1,75])
ERROR.DISP = RVB:"[=| ":RVE:ERROR.DISP
END ELSE ERROR.DISP = RVB:"[=| ":RVE:TRIM(ERROR.TEXT1)
IF ERROR.CODE2 LT 4 THEN PRINT RVB:
PRINT ERROR.DISP:
IF ERROR.CODE2 LT 4 THEN PRINT "!  ": ELSE
IF ERROR.CODE5 EQ 1 THEN
PRINT ".  ":
END ELSE IF ERROR.CODE1 NE 2 THEN
IF ERROR.MORE THEN PRINT ", ": ELSE IF NOT(ERROR.CODE5) THEN PRINT ".":
END ELSE
PRINT " ":
END
END
IF ERROR.CODE2 LT 4 THEN PRINT RVE:
END
*#
*#
ERROR.RSP = ""
IF ERROR.CODE5 AND ERROR.CODE1 AND ERROR.CODE1 LT 3 THEN
ERROR.LEN = ERROR.CODE[10,3]
IF ERROR.LEN EQ '' OR NOT(NUM(ERROR.LEN)) THEN ERROR.LEN = 50
IF ERROR.LEN LT 1 THEN ERROR.LEN = 50
IF ERROR.CODE5 EQ 1 THEN PRINT "Enter <CR>   ":
FOR TEMP = 1 TO 10 UNTIL SYSTEM(11) OR ERROR.CODE5 EQ 2
IF NOT(SYSTEM(11)) THEN RQM
NEXT TEMP
IF SYSTEM(11) OR ERROR.CODE2 LT 6 OR ERROR.CODE5 EQ 2 THEN
*#INPUT ERROR.RSP:
OLD.RSP = ERROR.RSP
IF ERROR.CL+ERROR.LEN GT 80 THEN ERROR.LEN = 79 - ERROR.CL
IF ERROR.CODE5 EQ 2 THEN ERROR.FORCE = 1 ELSE ERROR.FORCE = 0
CALL SYS.LINE.INPUT(ERROR.CL+LEN(ERROR.DISP)+1,ERROR.LN,ERROR.LEN,OLD.RSP,ERROR.RSP,0,1,1,ERROR.FORCE)
IF INDEX(OFF.RSP,"*":ERROR.RSP:"*",1) OR INDEX(TCL.RSP,"*":ERROR.RSP:"*",1) THEN
PRINT @(0,23):CLL:RVB:"[SYSTEM DEBUG|> ":RVE:
INPUT TEMP.RSP:
IF TEMP.RSP EQ 'APEX ABORT' THEN
IF INDEX(OFF.RSP,"*":ERROR.RSP:"*",1) THEN EXECUTE "OFF"
IF INDEX(TCL.RSP,"*":ERROR.RSP:"*",1) THEN STOP
RETURN
END; *# OF APEX ABORT
END; *# OF OFF OR TCL COMMAND
END ELSE ERROR.RSP = "" ; *# OF SYSTEM(11) OR ERROR.CODE2 LT 6
END; *# OF ERROR.CODE5 AND ERROR.CODE1 AND ERROR.CODE1 LT 3
*#
WAIT.TEMP = WAIT.FLAG - 1
IF NOT(NUM(WAIT.TEMP)) THEN WAIT.TEMP = 3
IF WAIT.TEMP LT 0 THEN WAIT.TEMP = 0
IF NOT(LEN(WAIT.TEMP)) THEN WAIT.TEMP = 3
FOR A = 1 TO WAIT.TEMP UNTIL SYSTEM(11); RQM; NEXT A
*#
*#
IF ERROR.CODE3 THEN
*IF NOT(ERROR.READ) THEN
READV NEXT.ERROR FROM SY.FILE,"@ERRORS@":USER.NAME,1 ELSE NEXT.ERROR = 2
*ERROR.READ = 1
*END
*#
*#1 IS SCRUTINIZED
*#2 IS PURGE
*#3 IS ANY ACTIONS TO
*#4 IS APPLICATION
*#5 IS MENU NUMBER
*#6 IS MENU OPTION
*#7 IS PROGRAM NAME
*#8 IS PROGRAM LOCATION
*#9 IS PROGRAM SUB-LOCATION
*#10 IS PORT
*#11 IS ACCOUNT
*#12 IS DATE
*#13 IS TIME
*#14 IS SEVERITY OF ERROR
*#15 IS TEXT FOR DISPLAY
*#16 IS WHAT USER TYPED IS RESPONSE TO 'ENTER <CR>'
*#
*#
ERROR.REC = '0':VM:'0':VM:STRUCT(5):VM:MENU.APPL:VM:MENU.CONTROL<1,9>:VM:PRMPTING
ERROR.REC = ERROR.REC:VM:SYS.PROG<1>:VM:SYS.LOCT<1>:VM:SYS.SLOC<1>:VM
ERROR.REC = ERROR.REC:PORT:VM:ACCT:VM:DATE():VM:TIME()
ERROR.REC = ERROR.REC:VM:ERROR.CODE<1>:VM:ERROR.TEXT1:VM:ERROR.RSP
*#
WRITEV ERROR.REC ON SY.FILE,"@ERRORS@":USER.NAME,NEXT.ERROR
NEXT.ERROR = NEXT.ERROR + 1
WRITEV NEXT.ERROR ON SY.FILE,"@ERRORS@":USER.NAME,1
*ERROR.WRITE =1
ERROR.REC = ""
END
*#
IF NUM(ERROR.CODE2) THEN
IF ERROR.FATAL GT ERROR.CODE2 THEN ERROR.FATAL = ERROR.CODE2
END
*#
ERROR.CODE = DELETE(ERROR.CODE,1)
ERROR.TEXT = DELETE(ERROR.TEXT,1)
*#
*REPEAT
END; *# OF LEN(ERROR.TEXT:ERROR.CODE)
WHILE ERROR.MORE DO REPEAT
*#
*IF ERROR.WRITE THEN WRITEV NEXT.ERROR ON SY.FILE,"@ERRORS@":USER.NAME,1
IF NOT(NUM(ERROR.FATAL)) THEN ERROR.FATAL = 0
IF ERROR.FATAL EQ 1 THEN EXECUTE "OFF"
IF ERROR.FATAL EQ 2 THEN STOP
IF ERROR.FATAL EQ 3 THEN PRINT BELL:
ERROR.TEXT = ''
RETURN
*#
!
*#
SYS.CLEAR.PAGE.MID: *#
FOR TEMP = CLS.LO TO CLS.HI WHILE NOT(SYSTEM(11)) OR TEMP LT 14
PRINT @(0,TEMP):CLL:RVB:"[":@(79):RVB:"]":RVE:
NEXT TEMP
CLS.HI = 20
CLS.LO = 5
*#
RETURN; *# from gosub...
*#
!
~SYS.INCL.11.ABORT~
*CODE.SEGMENT: SYS.INCL.11.ABORT
*
*#$INCLUDE DH.IBP SYS.INCL.11.ABORT
*#
*#
IF SYSTEM(11) THEN
PRINT @(0,22):CLL:BELL:"Yes? ":
INPUT TEMP.RSP:
IF TEMP.RSP EQ "END" OR TEMP.RSP EQ "CAN" OR TEMP.RSP EQ "KILL" THEN
USER.ABORT = 1
END ELSE IF TEMP.RSP NE "" THEN
EXECUTE TEMP.RSP
END
END
*#
~SYS.INCL.END.RSP~
*CODE.SEGMENT: SYS.INCL.END.RSP
*
*
EQU END.RSP TO "*END*end*End*KILL*kill*Kill*"
*
~SYS.INCL.OFF.RSP~
*CODE.SEGMENT: SYS.INCL.OFF.RSP
*
*
EQU OFF.RSP TO "*OFF*off*Off*STOP*stop*HALT*halt*Halt*BYE*bye*Bye*LOGOFF*logoff*Logoff*"
*
~SYS.INCL.SYS.RSP~
*CODE.SEGMENT: SYS.INCL.SYS.RSP
*
*
EQU SYS.RSP TO "*PKH*SCHED*SCHEDULE*MESSAGE*WAIT*FASTER*SLOWER*FAST*SLOW*HELP*"
*
*#.RSP.SYN TO "*PKH*SCHEDULE*SCHEDULE*MESSAGE*WAIT*WAIT*WAIT*WAIT*WA
*
*
~SYS.INCL.SYS.RSP.SYNONYM~
*CODE.SEGMENT: SYS.INCL.SYS.RSP.SYNONYM
*
*
****EQU SYS.RSP TO "*PKH*SCHED*SCHEDULE*MESSAGE*WAIT*FASTER*SLOWER*FAST*SLOW*HELP*"
*
EQU SYS.RSP.SYN TO "*PKH*SCHEDULE*SCHEDULE*MESSAGE*WAIT*WAIT*WAIT*WAIT*WAIT*HELP*"
*
*
~SYS.INCL.TCL.RSP~
*CODE.SEGMENT: SYS.INCL.TCL.RSP
*
*
EQU TCL.RSP TO "*EXIT*EXI*EX*COMMAND*EXIT.MENU*exit.menu*exit*command*"
*#("*":CHAR(6):"*":CHAR(24):"*":CHAR(27):"*":CHAR(251):"*")
*
~SYS.LINE.INPUT~
SUBROUTINE SYS.LINE.INPUT(ERROR.CL,ERROR.LN,ERROR.LEN,OLD.RSP,ERROR.RSP,ERROR.T1,ERROR.T2,ERROR.T3,ERROR.FORCE)
*
*
INPUT ERROR.RSP
*
*
RETURN
END
~SYS.STANDARD.FUNCTIONS~
*CODE.SEGMENT: SYS.STANDARD.FUNCTIONS
*
*
EQU BELL TO CHAR(7), LF TO CHAR(10), FF TO CHAR(12), CR TO CHAR(13)
EQU SVM TO  CHAR(252), VM TO CHAR(253), AM TO CHAR(254)
WHO = ICONV(0,"U50BB")
PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2)
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
EQU YES TO "*YES*Y*Yes*yes*y*OK*", NO TO "*NO*N*No*no*n*NOT OK*"
EQU TRUE.RSP TO "*T*t*1*TRUE*True*true*NOT FALSE*not false*YES*Y*Yes*yes*y*OK*"
EQU FALSE.RSP TO "*F*f*0*FALSE*False*false*NOT TRUE*not true*NO*N*No*no*n*NOT OK*"
EQU TRUE TO 1
EQU FALSE TO 0
*
TERMINAL = SYSTEM(7); * REVERSE VIDEO BEGIN/END
*RVB = CHAR(14); RVE = CHAR(15)
*PRINT CHAR(27):"0Q":
BEGIN CASE
CASE TERMINAL = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"
CASE TERMINAL = "R"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
CASE TERMINAL = "V"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
CASE 1; RVB = ""; RVE = ""; PRINT BELL:
END CASE
*
~SYS.USER.NAME~
*CODE.SEGMENT: SYS.USER.NAME
*
!
*
*
*
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = ""
SYS.ITEM = ""
*
*
SYS.SLOC = "ACC"
OPEN "ACC" TO AC.FILE ELSE
ERROR.TEXT = "no ACC file"
ERROR.CODE = 1
GOSUB ERROR.CONTROL
STOP
END
*
CALL.ID = "MENU.":PORT
READV USER.NAME FROM AC.FILE,CALL.ID,2 ELSE
USER.NAME = "?"
ERROR.TEXT = "I don't know your name"
ERROR.CODE = "19011"
GOSUB ERROR.CONTROL
STOP
END
*
*
*
!
*
~TAPE.TO.MDD.CLEAR~
*PROGRAM: TAPE.TO.MDD.CLEAR
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,"FILES" ELSE STOP
*
PROC1 = "PQN":AM
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HCLEAR-FILE (DICT ':FNAME:AM
PROC1 = PROC1 :'P':AM
END
PROC1 = PROC1:'C':AM:'HCLEAR-FILE (DATA ':FNAME:AM
PROC1 = PROC1:'P':AM:'C':AM:'C':AM:'C':AM
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,"TCLRALLF"
WRITE PROC1 ON BP.FILE,"TCLRALLF"
*
STOP
END
*
~TAPE.TO.MDD.PROCWRITE~
*PROGRAM: TAPE.TO.MDD.PROCWRITE
*
*
$INCLUDE IBP SYS.STANDARD.FUNCTIONS
*
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,"FILES" ELSE STOP
*
PROC1 = "PQN":AM
PROC1 =  PROC1:"C":AM:"C":AM:"HT-REW":AM:"P":AM:"C":AM:"C":AM
PROC2 = "PQN":AM
*
IF FILE.LIST[1,1] EQ "*" THEN FILE.LIST = DELETE(FILE.LIST,1,0,0)
*
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF FNAME[1,1] NE "*" THEN
*
DMOD = '37,1'
PROC1 = PROC1:'C':AM:'C':AM
PROC1 = PROC1:'O      ':FNAME:AM:'O':AM:'O':AM
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HT-FWD 1':AM:'P':AM
PROC1 = PROC1:'HT-LOAD DICT ':FNAME:AM
PROC1 = PROC1:'P':AM
END ELSE
DMOD = '103,1'
END; * of INDEX(FNAME....
*
PROC1 = PROC1:'HT-FWD 1':AM:'P':AM
PROC1 = PROC1:'HT-LOAD ':FNAME:AM:'P':AM:'C':AM:'C':AM
PROC2 = PROC2:'HCREATE-FILE (':FNAME:' 19,1 ':DMOD:')':AM:'P':AM:'C':AM:'C':AM
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
*
END; * of not *........
*
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,"TLOADALLF"
WRITE PROC1 ON BP.FILE,"TLOADALLF"
WRITE PROC2 ON MDI.FILE,"TCREALLF"
WRITE PROC2 ON BP.FILE,"TCREALLF"
*
STOP
*
END
*
~TEST.1~
*PROGRAM: TEST.1
*
*
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13)
EQUATE SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254)
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
TERM = SYSTEM(7)
PRINT TERM
INPUT TERM
PRINT "TERMINAL TEST FOR ":TERM
TERM = TERM[1,1]
BEGIN CASE
*
CASE TERM = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
*
*CASE TERM = "0"; RVB = CHAR(133):CHAR(8); RVE = CHAR(128):CHAR(8); RVH = CHAR(133); AUX.ON = CHAR(27):"R"; AUX.OFF = CHAR(27):"T"; CLS = CHAR(27):"J"
*
CASE TERM = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
CLL = CHAR(27):"K"; CLS = CHAR(27):"k"
*IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
PRINT CHAR(27):"0Q"
*
CASE TERM = "E"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
CLS = CHAR(27):"k"; CLR = CHAR(27):"K"
IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
*
CASE TERM = "H"
RVB = CHAR(27):CHAR(48):"P"; RVE = CHAR(27):CHAR(48):"@"; RVH = CHAR(27):CHAR(48):"Q"
AUX.ON = CHAR(27):CHAR(42):CHAR(0); AUX.OFF = CHAR(27):CHAR(63):CHAR(0)
CLL = CHAR(15); CLS = CHAR(23)
*
CASE TERM = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
*
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
*
*
PRINT "TERM: ":TERM
*
*
*
PRINT "RVB"
PRINT RVB
B = 1
FOR A = 1 TO 3
PRINT "RVB"
FOR B = 1 TO 50 STEP 10
*PRINT @(0,B):">>>":
FOR C = 1 TO 20 STEP 2
PRINT @(B,C):RVB:
PRINT "123*":
PRINT RVE:"456":
NEXT C
NEXT B
PRINT " * * * * A * * * * "
RQM
PRINT "        ":A
RQM
NEXT A
PRINT "RVE"
PRINT RVE
FOR A = 1 TO 3
PRINT "RVB":
PRINT RVB:" * * * * A * * * * "
PRINT "RVE":
PRINT RVE:" * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
PRINT "BELL"
PRINT BELL
FOR A = 1 TO 3
PRINT "BELL"
PRINT BELL
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
*
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
PRINT 'CLL':STR("*",30):
FOR A = 1 TO 3
PRINT 'CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT CLL:
RQM
RQM
PRINT "*"
PRINT "*"
PRINT "*"
PRINT 'MID-LINE-CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT @(20):CLL:
RQM
RQM
NEXT A
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
FOR A = 1 TO 3
PRINT @(0,0):"CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,0):CLS:
RQM
RQM
RQM
PRINT @(0,0):"*"
PRINT "*"
PRINT "******************************************"
PRINT "******************************************"
PRINT @(0,10):"MID-SCR-CLS"
RQM
RQM
RQM
*PRINT @(0,10):"MID-SCR-CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,10):CLS:
RQM
RQM
RQM
NEXT A
*
*
END
~TEST.2~
*PROGRAM: TEST.2
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "RVB"
PRINT RVB
B = 1
FOR A = 1 TO 3
PRINT "RVB"
FOR B = 1 TO 50 STEP 10
*PRINT @(0,B):">>>":
FOR C = 1 TO 20 STEP 2
PRINT @(B,C):RVB:
PRINT "123*":
PRINT RVE:"456":
NEXT C
NEXT B
PRINT " * * * * A * * * * "
RQM
PRINT "        ":A
RQM
NEXT A
PRINT "RVE"
PRINT RVE
FOR A = 1 TO 3
PRINT "RVB":
PRINT RVB:" * * * * A * * * * "
PRINT "RVE":
PRINT RVE:" * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
PRINT "BELL"
PRINT BELL
FOR A = 1 TO 3
PRINT "BELL"
PRINT BELL
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
*
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
PRINT 'CLL':STR("*",30):
FOR A = 1 TO 3
PRINT 'CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT CLL:
RQM
RQM
PRINT "*"
PRINT "*"
PRINT "*"
PRINT 'MID-LINE-CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT @(20):CLL:
RQM
RQM
NEXT A
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
FOR A = 1 TO 3
PRINT @(0,0):"CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,0):CLS:
RQM
RQM
RQM
PRINT @(0,0):"*"
PRINT "*"
PRINT "******************************************"
PRINT "******************************************"
PRINT @(0,10):"MID-SCR-CLS"
RQM
RQM
RQM
*PRINT @(0,10):"MID-SCR-CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,10):CLS:
RQM
RQM
RQM
NEXT A
*
*
END
~TEST.CLL~
*PROGRAM: TEST.CLL
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT 
PRINT @(0,0)
FOR A = 1 TO 20
PRINT "XXXXXXXXXXXXXXXXXXXXXXXXXXX"
NEXT A
*
PRINT @(0,0)
FOR A = 1 TO 20
PRINT CLL:
NEXT A
*
END
~TEST.DECIMAL~
*PROGRAM: TEST.DECIMAL
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
LOOP
PRINT
PRINT "ENTER NUMBER:   ":
INPUT ANS
PRINT
WHILE ANS NE "END" DO
PRINT "MD0  ":OCONV(ANS,"MD0")
PRINT "MD2  ":OCONV(ANS,"MD2")
PRINT "***********ICONV***********"
PRINT "MD0  ":ICONV(ANS,"MD0")
PRINT "MD2  ":ICONV(ANS,"MD2")
PRINT "***********PICTURE***********"
PRINT "MFP9        ":OCONV(ANS,"MFP9")
PRINT "MFP99       ":OCONV(ANS,"MFP99")
PRINT "MFP.99     ":OCONV(ANS,"MFP.99")
PRINT "MFP9.99    ":OCONV(ANS,"MFP9.99")
PRINT "MFP99.99   ":OCONV(ANS,"MFP99.99")
PRINT "MFP999.99  ":OCONV(ANS,"MFP999.99")
PRINT "MFP9(9).99 ":OCONV(ANS,"MFP9(9).99")
PRINT "MF0P9(9).99 ":OCONV(ANS,"MF0P9(9).99")
PRINT "MF2P9(9).99 ":OCONV(ANS,"MF2P9(9).99")
PRINT "MF2'0'9*P9(7).99 ":OCONV(ANS,"MF2'0'9*P9(7).99")
REPEAT
END
~TEST.FIVE~
*PROGRAM: TEST.FIVE
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "TERM: ":TERM
*
PRINT "RVB"
PRINT RVB
B = 1
FOR A = 1 TO 3
PRINT "RVB"
FOR B = 1 TO 50 STEP 10
*PRINT @(0,B):">>>":
FOR C = 1 TO 20 STEP 2
PRINT @(B,C):RVB:
PRINT "123*":
PRINT RVE:"456":
NEXT C
NEXT B
PRINT " * * * * A * * * * "
RQM
PRINT "        ":A
RQM
NEXT A
PRINT "RVE"
PRINT RVE
FOR A = 1 TO 3
PRINT "RVE"
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
PRINT "BELL"
PRINT BELL
FOR A = 1 TO 3
PRINT "BELL"
PRINT BELL
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
*
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
PRINT 'CLL':STR("*",30):
FOR A = 1 TO 3
PRINT 'CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT CLL:
RQM
RQM
PRINT "*"
PRINT "*"
PRINT "*"
PRINT 'MID-LINE-CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT @(20):CLL:
RQM
RQM
NEXT A
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
FOR A = 1 TO 3
PRINT @(0,0):"CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,0):CLS:
RQM
RQM
RQM
PRINT @(0,0):"*"
PRINT "*"
PRINT "******************************************"
PRINT "******************************************"
PRINT @(0,10):"MID-SCR-CLS"
RQM
RQM
RQM
*PRINT @(0,10):"MID-SCR-CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,10):CLS:
RQM
RQM
RQM
NEXT A
*
*
END
~TEST.FOUR~
*PROGRAM: TEST.FOUR
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "WHO>":WHO
PRINT "PORT>":PORT
PRINT "ACCT>":ACCT
*
*
STOP
*
*
END
~TEST.ONE~
*PROGRAM: TEST.ONE
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "TERM: ":TERM
*
*
*
PRINT "RVB"
PRINT RVB
B = 1
FOR A = 1 TO 3
PRINT "RVB"
FOR B = 1 TO 10
PRINT @(0,B):">>>":
FOR C = 1 TO 10
PRINT @(C):RVB:
PRINT "123*":
NEXT C
NEXT B
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
PRINT "RVE"
PRINT RVE
FOR A = 1 TO 3
PRINT "RVE"
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
PRINT "BELL"
PRINT BELL
FOR A = 1 TO 3
PRINT "BELL"
PRINT BELL
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
*
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
PRINT 'CLL':STR("*",30):
FOR A = 1 TO 3
PRINT 'CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT CLL:
RQM
RQM
PRINT "*"
PRINT "*"
PRINT "*"
PRINT 'MID-LINE-CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT @(20):CLL:
RQM
RQM
NEXT A
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
FOR A = 1 TO 3
PRINT @(0,0):"CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,0):CLS:
RQM
RQM
RQM
PRINT @(0,0):"*"
PRINT "*"
PRINT "******************************************"
PRINT "******************************************"
PRINT @(0,10):"MID-SCR-CLS"
RQM
RQM
RQM
*PRINT @(0,10):"MID-SCR-CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,10):CLS:
RQM
RQM
RQM
NEXT A
*
*
END
~TEST.PRINT~
*PROGRAM: TEST.PRINT
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "ENTER <CR> WHEN THE LINE OF a's APPEARS"
PRINT AUX.ON
RQM
START.TIME = TIME()
FOR A = 1 TO 9
PRINT STR("X",80)
NEXT A
PRINT STR("a",80)
PRINT AUX.OFF
PRINT
PRINT "????":
INPUT ANS
END.TIME = TIME()
ELP.TIME = END.TIME-START.TIME
PRINT
PRINT "ELP ":ELP.TIME
PRINT "CPS ":800/ELP.TIME
PRINT
PRINT
PRINT AUX.ON
FOR A = 1 TO 100
PRINT A:">":STR("H",A)
NEXT A
PRINT AUX.OFF
FOR A = 1 TO 100
PRINT STR("h",A)
NEXT A
PRINT AUX.ON
FOR A = 1 TO 100
PRINT A:">":STR("X",A)
NEXT A
PRINT AUX.OFF
END
~TEST.PRINT.1~
*PROGRAM: TEST.PRINT.1
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "ENTER <CR> WHEN THE LINE OF a's APPEARS"
PRINT AUX.ON
RQM
START.TIME = TIME()
FOR A = 1 TO 9
PRINT STR("X",80)
NEXT A
PRINT STR("a",80)
PRINT AUX.OFF
PRINT
PRINT "????":
INPUT ANS
END.TIME = TIME()
ELP.TIME = END.TIME-START.TIME
PRINT
PRINT "ELP ":ELP.TIME
PRINT "CPS ":800/ELP.TIME
PRINT
PRINT
PRINT "????":
INPUT ANS
END.TIME1 = TIME()
ELP.TIME1 = END.TIME1-END.TIME
PRINT
PRINT "EMPTY TIME":ELP.TIME1
PRINT
END
~TEST.SEVEN~
*PROGRAM: TEST.SEVEN
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
TEMP = 1
LOOP WHILE TEMP = 1 DO
PRINT SYSTEM(7)
RQM
RQM
RQM
REPEAT
END
~TEST.SIX~
*PROGRAM: TEST.SIX
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "TERM: ":TERM
*
FOR A = 1 TO 30
*
FOR B = 1 TO 5
PRINT @(0,B):STR("*",50):@(0):CHAR(27):CHAR(A):STR("?",10):
NEXT B
NEXT A
PRINT "888888888888888888888888888888888888888888888888888888888888"
PRINT
PRINT
PRINT "RVB"
PRINT RVB
B = 1
FOR A = 1 TO 3
PRINT "RVB"
FOR B = 1 TO 50 STEP 10
*PRINT @(0,B):">>>":
FOR C = 1 TO 20 STEP 2
PRINT @(B,C):RVB:
PRINT "123*":
PRINT RVE:"456":
NEXT C
NEXT B
PRINT " * * * * A * * * * "
RQM
PRINT "        ":A
RQM
NEXT A
PRINT "RVE"
PRINT RVE
FOR A = 1 TO 3
PRINT "RVE"
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
PRINT "BELL"
PRINT BELL
FOR A = 1 TO 3
PRINT "BELL"
PRINT BELL
PRINT " * * * * A * * * * "
PRINT "        ":A
RQM
NEXT A
*
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
PRINT 'CLL':STR("*",30):
FOR A = 1 TO 3
PRINT 'CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT CLL:
RQM
RQM
PRINT "*"
PRINT "*"
PRINT "*"
PRINT 'MID-LINE-CLL':STR("*",30):
PRINT CR:
RQM
RQM
PRINT @(20):CLL:
RQM
RQM
NEXT A
*
*PRINT CLS:
FOR A = 1 TO 20
PRINT
NEXT A
*
*
FOR A = 1 TO 3
PRINT @(0,0):"CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,0):CLS:
RQM
RQM
RQM
PRINT @(0,0):"*"
PRINT "*"
PRINT "******************************************"
PRINT "******************************************"
PRINT @(0,10):"MID-SCR-CLS"
RQM
RQM
RQM
*PRINT @(0,10):"MID-SCR-CLS"
PRINT "*"
PRINT "*"
PRINT "*"
RQM
RQM
RQM
PRINT @(0,10):CLS:
RQM
RQM
RQM
NEXT A
*
*
END
~TEST.SYSTEM.FUNCS~
*PROGRAM: TEST.SYSTEM.FUNCS
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
PRINT "TERM: ":TERM
*
FOR A = 1 TO 100 UNTIL SYSTEM(11)
*
PRINT A "R#3":") ":
TMP = SYSTEM(A)
PRINT TMP:"<"
*
EXECUTE "SLEEP 1"
*
NEXT A
*
PRINT "****"
*
STOP
END
~TEST.THREE~
*PROGRAM: TEST.THREE
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
FOR A = 1 TO 20
PRINT "A":
TEMP = SYSTEM(A)
PRINT ">":TEMP:"<"
NEXT A
END
~TEST.TWO~
*PROGRAM: TEST.TWO
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
LOOP
INPUT TEMP
UNTIL TEMP EQ '' DO
PRINT CHAR(TEMP)
REPEAT
END
