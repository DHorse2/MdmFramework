~PICKTR.SET.ONE.SUB~
SUBROUTINE  PICKTR.SET.ONE.SUB(BLOCK.RSP,ITEM,STAT,VAL.SET.STAT,MAIN.FLAG,
INIT.FLAG,CDIR.FLAG,FILE.FLAG,ITEM.FLAG,OPTN.FLAG,LIST.FLAG,ACCT.FLAG,SYST.FLAG,SRCE.FLAG,
ITEM.TYPE,VRF.ITEM.TYPE,DIR.FLAG,IN.FILE.NAME,OUT.FILE.NAME,IN.ITEM.NAME,OUT.ITEM.NAME,
OPTIONS,LIST.SOURCE,ITEM.DATE,LIST.SCAN,ABORT.FLAG,LIST.NAME,SEL.EXEC,FROM.LIST,ACCT.NAME,
COMM.SYS.NAME,DICT.BASE,FILE.BASE,FILE.OPT,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,SYS.NAME,
TP.MAX,ERR.CN,OTHER.ERR.CN,ERR.CN.ALL,ERR.LOW,DONE.FLAG)
*PROGRAM: *# Subroutine to set control parameters
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* CALLED RTN:   10 AUG 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*# Load program control parameters from master computer
*      
*      
$INCLUDE IBP STANDARD.CHARACTERS
*      
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
TRANS.PARAM = EMPTY
COMM.PARAM = EMPTY
*
VAL.SET.STAT = TRUE
*
LOCATE BLOCK.RSP IN VAL.STRING SETTING VAL.LOC THEN
*
DEL.CN = ONE; GOSUB VAL.SET; *#
*
END ELSE
IF BLOCK.RSP[ONE,5] EQ "ERROR" THEN
IF LEN(BLOCK.RSP) GT 5 THEN
BLOCK.RSP = BLOCK.RSP[6,9999]; DEL.CN = ONE
END ELSE
BLOCK.RSP = ITEM<TWO>; DEL.CN = TWO
END
STAT = RECVD.VRF; *# ERROR RECEIVED
CP<16,-1> = BLOCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*
END ELSE IF BLOCK.RSP EQ "?INIT" THEN
DEL.CN = ONE; INIT.FLAG = FALSE
*
END ELSE IF BLOCK.RSP EQ "?INAM" THEN
DEL.CN = ONE; ITEM.FLAG = FALSE
*
END ELSE IF BLOCK.RSP EQ "KILL" OR BLOCK.RSP EQ "OFF" OR BLOCK.RSP EQ "TCL" OR BLOCK.RSP[ONE,5] EQ "ERROR" OR BLOCK.RSP[ONE,ONE] EQ "?" THEN
DEL.CN = ONE; STAT = ABORT.VRF; *# KILL/OFF/TCL/ERROR RECEIVED
CP<16,-1> = BLOCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*
END ELSE
*
GOSUB VAL.NOT.FOUND
*
END
*
END
*
LOOP WHILE DEL.CN DO DEL ITEM<ONE,ZERO,ZERO>; DEL.CN = DEL.CN - ONE REPEAT
*
RETURN
*
*
VAL.SET: *#
*
ON VAL.LOC GOTO VAL.INIT,VAL.ITEM.TYPE,VAL.TDIR,VAL.FNAM,VAL.INAM,VAL.OPTN,VAL.SRCE,VAL.LIST.CN,VAL.LIST.SCAN,VAL.ABORT,VAL.LIST,VAL.ACCT,VAL.SYST,VAL.ERR.CN,VAL.DONE,VAL.END.LIST,VAL.NOT.FOUND
*
GOTO VAL.NOT.FOUND
*
*RETURN
*
VAL.INIT: *#
DIR.FLAG = EMPTY; IN.FILE.NAME  = EMPTY; OUT.FILE.NAME = EMPTY
IN.ITEM.NAME  = EMPTY; COMM.SYS.NAME = EMPTY
OUT.ITEM.NAME = EMPTY; OPTIONS = EMPTY; ACCT.NAME = EMPTY
IF NOT(FROM.LIST AND LIST.SOURCE) THEN LIST.NAME = EMPTY; LIST.SOURCE = EMPTY
*      
INIT.FLAG = TRUE; CDIR.FLAG = FALSE; FILE.FLAG = FALSE; ITEM.FLAG = FALSE
OPTN.FLAG = FALSE; LIST.FLAG = FALSE; ACCT.FLAG = FALSE; SYST.FLAG = FALSE
SRCE.FLAG = FALSE
RETURN
*      
VAL.ITEM.TYPE: *#
VRF.ITEM.TYPE = ITEM<TWO>; DEL.CN = TWO
IF VRF.ITEM.TYPE NE ITEM.TYPE THEN STAT = ITEM.TYPE.ERROR
RETURN
*      
VAL.TDIR: *#
DIR.FLAG = ITEM<TWO>; DEL.CN = TWO
CDIR.FLAG = TRUE
RETURN
*      
VAL.FNAM: *#
IN.FILE.NAME = ITEM<TWO>
OUT.FILE.NAME = ITEM<3>; DEL.CN = 3
FILE.FLAG = TRUE
RETURN
*      
VAL.INAM: *#
OUT.ITEM.NAME = ITEM<TWO>
IN.ITEM.NAME = ITEM<3>; DEL.CN = 3
IF LEN(IN.ITEM.NAME) OR LEN(OUT.ITEM.NAME) THEN ITEM.FLAG = TRUE
RETURN
*      
VAL.OPTN: *#
OPTIONS = ITEM<TWO>; DEL.CN = TWO
OPTN.FLAG = TRUE
RETURN
*      
VAL.SRCE: *#
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.SOURCE = ITEM<TWO>
DEL.CN = TWO
SRCE.FLAG = TRUE
ITEM.DATE = EMPTY
RETURN
*
VAL.LIST.CN: *#
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.CN = ITEM<TWO>
DEL.CN = TWO
RETURN
*
VAL.LIST.SCAN: *#
*IF NOT(LIST.SOURCE AND FROM.LIST) THEN 
LIST.SCAN = ITEM<TWO>
DEL.CN = TWO
RETURN
*
VAL.ABORT: *#
ABORT.FLAG = ITEM<TWO>; DEL.CN = TWO
STAT = ABORT.VRF; *# ABORT RECEIVED
RETURN
*
VAL.LIST: *#
DEL.CN = TWO
IF NOT(FROM.LIST) THEN
LIST.NAME = ITEM<TWO>
IF NOT(LEN(LIST.NAME)) THEN LIST.FLAG = FALSE; FROM.LIST = FALSE ELSE
LIST.FLAG = TRUE
IF LIST.SOURCE THEN
IF NOT(FROM.LIST) THEN
SEL.EXEC = ONE
END ELSE SEL.EXEC = ZERO
END ELSE SEL.EXEC = -ONE
FROM.LIST = TRUE
END
END; *# of not(from.list)
RETURN
*      
VAL.ACCT: *#
ACCT.NAME = ITEM<TWO>; DEL.CN = TWO
*# IF LEN(ACCT.NAME) AND ACCT.NAME NE ACCT THEN PRINT "???????ACCT??????"; STOP
ACCT.FLAG = TRUE
RETURN
*      
VAL.SYST: *#
TMP = ITEM<TWO>; DEL.CN = TWO
COMM.SYS.NAME = FIELD(TMP,"#",1)
DICT.BASE = ZERO; FILE.BASE = ZERO
FILE.OPT = FIELD(TMP,"#",2)
DICT.MOD = FIELD(TMP,"#",3); DICT.SEP = FIELD(TMP,"#",4)
IF NOT(NUM(DICT.MOD)) THEN DICT.MOD = ZERO
IF NOT(NUM(DICT.SEP)) THEN DICT.SEP = ZERO
FILE.MOD = FIELD(TMP,"#",5); FILE.SEP = FIELD(TMP,"#",6)
IF NOT(NUM(FILE.MOD)) THEN FILE.MOD = ZERO
IF NOT(NUM(FILE.SEP)) THEN FILE.SEP = ZERO
*# IF LEN(SYS.NAME) AND SYS.NAME NE COMM.SYS.NAME THEN PRINT "???????SYS??????"; STOP
SYST.FLAG = TRUE
RETURN
*      
VAL.TP.MAX: *#
TP.MAX = ITEM<TWO>; DEL.CN = TWO
IF MAIN.FLAG EQ SLAVE THEN TP.MAX = HI.NUM
RETURN
*      
VAL.ERR.CN: *#
OTHER.ERR.CN = ITEM<TWO>; DEL.CN = TWO
IF MAIN.FLAG EQ SLAVE THEN OTHER.ERR.CN = OTHER.ERR.CN + TWO
IF OTHER.ERR.CN LT ERR.LOW THEN OTHER.ERR.CN = ERR.LOW
RETURN
*      
VAL.DONE: *#
DONE.FLAG = WORK.DONE
RETURN
*      
VAL.END.LIST: *#
FROM.LIST = FALSE
STAT = LIST.FINISHED
RETURN
*      
VAL.NOT.FOUND: *#
DEL.CN = ZERO; * ERR.CN.ALL = ERR.CN.ALL + ONE
VAL.SET.STAT = FALSE
RETURN
*
*      
*      
*VAL.INIT,VAL.ITEM.TYPE,VAL.TDIR,VAL.FNAM,VAL.INAM,VAL.OPTN,VAL.SRCE,VAL.LIST.CN,VAL.LIST.SCAN,VAL.ABORT,VAL.LIST,VAL.ACCT,VAL.SYST,VAL.ERR.CN,VAL.DONE,VAL.END.LIST
*INIT*ITEM.TYPE*TDIR*FNAM*INAM*OPTN*SRCE*LIST.CN*LIST.SCAN*ABORT*LIST*ACCT*SYST*ERR.CN*DONE*END.LIST*
*
END
~SYS.SUBR.FILE.STAT~
SUBROUTINE SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,OPTIONS,FILE.NAME,FILE.BASE,STAT,PROG.DEBUG,ACCT.NAME,MAIN.FLAG,EL.DATA,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
COMM.PARAM = EMPTY; TRANS.PARAM = EMPTY
*
*# STAT settings
EQU DICT.FILE.MISSING     TO 1; *# STAT
EQU DICT.OPEN.ERROR       TO 2; *# STAT
EQU NOT.A.FILE            TO 3; *# STAT
EQU MD.FILE.MISSING       TO 4; *# STAT
EQU DATA.OPEN.ERROR       TO 5; *# STAT
EQU DATA.FILE.MISSING     TO 6; *# STAT
*
EQU D.POINTER     TO "D"
EQU Q.POINTER     TO "Q"
*
EQU FILE.QACCT     TO DICT.BASE
EQU FILE.QNAME     TO DICT.MOD
*
*
* OPTION settings
EQU FILE.CREATE.OPT   TO "FC"
EQU DICT.CREATE.OPT   TO "DC"
EQU DATA.CREATE.OPT   TO "DAC"
EQU MD.CREATE.OPT     TO "MC"
EQU SEEK.OPT          TO "S"
EQU PROMPT.OPT        TO "?"
EQU QPOINT.OPT        TO "QC"
*
PROMPT.DEBUG = INDEX(OPTIONS,PROMPT.OPT,ONE)
IF MAIN.FLAG NE ENTRY THEN PROMPT.DEBUG = FALSE
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT; PRINT DICT.NAME:" ":FILE.NAME:" ":
EL.DATA<-ONE> = "File Status Processing - Start"; *# @@@#
EL.DATA<-ONE> = "Md: ":MD.FILE.NAME:"  Acct: ":ACCT.NAME:"  Opts: ":OPTIONS
EL.DATA<-ONE> = "Dict: ":DICT.NAME:"  b":DICT.BASE:"  m":DICT.MOD:"  s":DICT.SEP
EL.DATA<-ONE> = "File: ":FILE.NAME:" b":FILE.BASE:" m":FILE.MOD:" s":FILE.SEP
EL.DATA<-ONE> = "Stat: ":STAT:"  Deb: ":PROG.DEBUG:"/":PROMPT.DEBUG:"  Proc: ":MAIN.FLAG
EL.DATA<-ONE> = ">> "
*
STAT = FALSE
EXEC.VERB = "CREATE-FILE"
NACCT.NAME = ACCT.NAME
WORK.DICT.NAME = FIELD(DICT.NAME,",",1)
*WORK.DICT.NAME = DICT.NAME
WORK.FILE.NAME = FILE.NAME
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "oM":; *# @@@#
EL.DATA = EL.DATA:"oM"; *# @@@#
*
OPEN MD.FILE.NAME TO MD.FILE ELSE
STAT = MD.FILE.MISSING
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "- ":; *# @@@#
EL.DATA = EL.DATA:"- "; *# @@@#
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "Mmie! ":; *# @@@#
EL.DATA = EL.DATA:"Mmie! "; *# @@@#
RETURN
END
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "+ ":; *# @@@#
EL.DATA = EL.DATA:"+ "; *# @@@#
*
IF NOT(NUM(DICT.BASE)) THEN DICT.BASE = ZERO
IF NOT(NUM(DICT.MOD)) THEN DICT.MOD = 3
IF NOT(NUM(DICT.SEP)) THEN DICT.SEP = ONE
IF NOT(DICT.MOD) THEN DICT.MOD = 3
IF NOT(DICT.SEP) THEN DICT.SEP = ONE
*
IF NOT(NUM(FILE.BASE)) THEN FILE.BASE = ZERO
IF NOT(NUM(FILE.MOD)) THEN FILE.MOD = 101
IF NOT(NUM(FILE.SEP)) THEN FILE.SEP = ONE
IF NOT(FILE.MOD) THEN FILE.MOD = 101
IF NOT(FILE.SEP) THEN FILE.SEP = ONE
*
DEF.DICT.BASE = DICT.BASE
DEF.DICT.MOD  = DICT.MOD
DEF.DICT.SEP  = DICT.SEP
DEF.FILE.BASE = FILE.BASE
DEF.FILE.MOD  = FILE.MOD
DEF.FILE.SEP  = FILE.SEP
*
*
LOOP
*
DICT.FILE.RELOOP = FALSE
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "rD":; *# @@@#
EL.DATA = EL.DATA:"rD"; *# @@@#
*
READ DICT.FILE.ITEM FROM MD.FILE, WORK.DICT.NAME THEN
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "+ ":; *# @@@#
EL.DATA = EL.DATA:"+ "; *# @@@#
DICT.ON.FILE = TRUE
DICT.TYPE = DICT.FILE.ITEM<ONE>
DICT.BASE = DICT.FILE.ITEM<TWO>
DICT.MOD = DICT.FILE.ITEM<3>
DICT.SEP = DICT.FILE.ITEM<4>
*
IF DICT.TYPE[ONE,ONE] EQ D.POINTER AND LEN(DICT.TYPE) EQ TWO THEN
TC = DICT.TYPE[TWO,ONE]
IF TC EQ "X" OR TC EQ "Y" OR TC EQ "W" OR TC EQ "C" THEN DICT.TYPE = DICT.TYPE[ONE,ONE]
END; *# of D.POINTER[ONE,ONE]
*
BEGIN CASE
CASE DICT.TYPE NE D.POINTER AND DICT.TYPE NE Q.POINTER
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "Dpe! ":; *# @@@#
EL.DATA = EL.DATA:"Dpe! "; *# @@@#
STAT = NOT.A.FILE
*
CASE DICT.TYPE EQ Q.POINTER
*
WORK.FILE.NAME = FILE.QNAME
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "DQp ":; *# @@@#
EL.DATA = EL.DATA:"DQp "; *# @@@#
*
IF INDEX(OPTIONS,SEEK.OPT,ONE) OR INDEX(OPTIONS,MD.CREATE.OPT,ONE) THEN
*
NACCT.NAME = FILE.QACCT
WORK.DICT.NAME = FIELD(FILE.QNAME,",",1)
*
IF FILE.QACCT NE ACCT THEN
*
LOOP
*
MD.RELOOP = FALSE
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "rM":; *# @@@#
EL.DATA = EL.DATA:"rM"; *# @@@#
*
MD.FILE.NAME = FILE.QACCT:".MD"
READ MD.ITEM FROM MD.FILE, MD.FILE.NAME THEN
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "+ ":; *# @@@#
EL.DATA = EL.DATA:"+ "; *# @@@#
*
* IF MD.ITEM<ONE> EQ Q.POINTER AND INDEX(OPTIONS,SEEK.OPT,ONE) THEN
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "oM":; *# @@@#
EL.DATA = EL.DATA:"oM"; *# @@@#
OPEN MD.FILE.NAME TO MD.FILE THEN
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "+ ":; *# @@@#
EL.DATA = EL.DATA:"+ "; *# @@@#
DICT.FILE.RELOOP = TRUE
END ELSE
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "- ":; *# @@@#
EL.DATA = EL.DATA:"- "; *# @@@#
STAT = MD.FILE.MISSING
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "Mmie! ":; *# @@@#
EL.DATA = EL.DATA:"Mmie! "; *# @@@#
END
* END; *# of MD.ITEM is a Q.POINTER
*
END ELSE
*# MD.ITEM is missing
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "- ":; *# @@@#
EL.DATA = EL.DATA:"- "; *# @@@#
*
* IF INDEX(OPTIONS,FILE.CREATE.OPT,ONE) OR INDEX(OPTIONS,MD.CREATE.OPT,ONE) OR INDEX(OPTIONS,SEEK.OPT,ONE) THEN
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "cM ":; *# @@@#
EL.DATA = EL.DATA:"cM "; *# @@@#
WRITE "Q":AM:FILE.QACCT ON MD.FILE, MD.FILE.NAME
MD.RELOOP = TRUE
* END ELSE
* MD.RELOOP = FALSE
* MD.ITEM = EMPTY
* END
*
END; *# of MD.ITEM present/missing
*
WHILE MD.RELOOP AND NOT(STAT) DO REPEAT
*
END; *# of file is a q-pointer in samie account
*
END; *# of SEEK.OPT or MD.CREATE.OPT
*
IF FILE.QACCT EQ ACCT THEN
* Samie Account
*
IF FILE.QNAME NE FILE.NAME THEN
FILE.NAME = FILE.QNAME
DICT.NAME = FIELD(FILE.QNAME,",",1)
WORK.DICT.NAME = DICT.NAME
DICT.FILE.RELOOP = TRUE
END
*
END; *# of file is a q-pointer in samie account
*
WORK.FILE.NAME = FILE.QNAME
NACCT.NAME = FILE.QACCT
*
CASE TRUE
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "DDp ":; *# @@@#
EL.DATA = EL.DATA:"DDp "; *# @@@#
*
DICT.BASE = DICT.FILE.ITEM<TWO>
DICT.MOD = DICT.FILE.ITEM<3>
DICT.SEP = DICT.FILE.ITEM<4>
*
END CASE; *# POINTER type
*
END ELSE
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "- ":; *# @@@#
EL.DATA = EL.DATA:"- "; *# @@@#
*
DICT.TYPE = ""
DICT.FILE.ITEM = EMPTY
DICT.ON.FILE = FALSE
*
IF INDEX(OPTIONS,SEEK.OPT,ONE) THEN
IF NACCT.NAME NE ACCT THEN
WRITE "Q":AM:NACCT.NAME:AM:WORK.DICT.NAME ON MD.FILE, DICT.NAME
DICT.FILE.RELOOP = TRUE
END
END
*
END
*
IF NOT(STAT) AND NOT(DICT.ON.FILE) AND NOT(DICT.FILE.RELOOP) THEN
*
IF INDEX(OPTIONS,FILE.CREATE.OPT,ONE) OR INDEX(OPTIONS,DICT.CREATE.OPT,ONE) THEN
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "cD ":; *# @@@#
EL.DATA = EL.DATA:"cD "; *# @@@#
*
FILE.NAME.TEMP = FILE.NAME
DICT.NAME.TEMP = FIELD(DICT.NAME,",",ONE)
IF INDEX(FILE.NAME.TEMP,",",ONE) THEN FILE.NAME.TEMP = FIELD(FILE.NAME.TEMP,",",TWO)
IF FILE.NAME.TEMP NE DICT.NAME.TEMP THEN FILE.NAME.TEMP = DICT.NAME.TEMP:",":FILE.NAME.TEMP
EXEC.FILE = DICT.NAME.TEMP
IF FILE.NAME.TEMP NE DICT.NAME.TEMP THEN
EXEC.FILE = "DICT ":EXEC.FILE
EXEC.DATA = DEF.DICT.MOD:",":DEF.DICT.SEP
END ELSE
EXEC.DATA = DEF.DICT.MOD:",":DEF.DICT.SEP:" ":DEF.FILE.MOD:",":DEF.FILE.SEP
END
*
EXEC.COMMAND = EXEC.VERB:" ":EXEC.FILE:" ":EXEC.DATA
EXECUTE EXEC.COMMAND, //OUT. > EXEC.RSP
EL.DATA<-ONE> = EXEC.COMMAND
EL.DATA<-ONE> = EXEC.RSP
EL.DATA<-ONE> = ">> "
*
DICT.FILE.RELOOP = TRUE
*
END ELSE
* DICT NOT ON FILE
STAT = DICT.FILE.MISSING
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "Dmie! ":; *# @@@#
EL.DATA = EL.DATA:"Dmie! "; *# @@@#
*
END
*
END; *# of NOT(DICT.ON.FLIE)
*
WHILE DICT.FILE.RELOOP AND NOT(STAT) DO REPEAT
*
IF NOT(STAT) THEN
*
DICT.NAME = FIELD(DICT.NAME,",",ONE)
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "oD":; *# @@@#
EL.DATA = EL.DATA:"oD"; *# @@@#
*
OPEN "DICT ":DICT.NAME TO DICT.FILE THEN
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "+ ":; *# @@@#
EL.DATA = EL.DATA:"+ "; *# @@@#
*
LOOP
*
DATA.FILE.RELOOP = FALSE
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "rF":; *# @@@#
EL.DATA = EL.DATA:"rF"; *# @@@#
*
TEMP.FILE.NAME = WORK.FILE.NAME
IF INDEX(TEMP.FILE.NAME,",",ONE) THEN TEMP.FILE.NAME = FIELD(TEMP.FILE.NAME,",",TWO)
READ FILE.ITEM FROM DICT.FILE, TEMP.FILE.NAME THEN
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "+ ":; *# @@@#
EL.DATA = EL.DATA:"+ "; *# @@@#
*
DATA.ON.FILE = TRUE
FILE.TYPE = FILE.ITEM<ONE>
IF FILE.TYPE EQ D.POINTER OR (LEN(FILE.TYPE) EQ TWO AND FILE.TYPE[ONE,ONE] EQ D.POINTER AND INDEX("CWXY",FILE.TYPE[TWO,ONE],ONE)) THEN
FILE.BASE = FILE.ITEM<TWO>
FILE.MOD = FILE.ITEM<3>
FILE.SEP = FILE.ITEM<4>
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "FDp ":; *# @@@#
EL.DATA = EL.DATA:"FDp "; *# @@@#
END ELSE IF FILE.TYPE EQ Q.POINTER THEN
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "FQp ":; *# @@@#
EL.DATA = EL.DATA:"FQp "; *# @@@#
END ELSE
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "Fpe! ":; *# @@@#
EL.DATA = EL.DATA:"Fpe! "; *# @@@#
STAT = NOT.A.FILE
*
END
*
END ELSE
*# DATA FILE missing
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "- ":; *# @@@#
EL.DATA = EL.DATA:"- "; *# @@@#
*
DATA.ON.FILE = FALSE
*
IF INDEX(OPTIONS,FILE.CREATE.OPT,ONE) OR INDEX(OPTIONS,DATA.CREATE.OPT,ONE) THEN
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "cF ":; *# @@@#
EL.DATA = EL.DATA:"cF "; *# @@@#
*
FILE.NAME.TEMP = FILE.NAME
DICT.NAME.TEMP = FIELD(DICT.NAME,",",ONE)
IF INDEX(FILE.NAME.TEMP,",",ONE) THEN FILE.NAME.TEMP = FIELD(FILE.NAME.TEMP,",",TWO)
*
IF FILE.NAME.TEMP NE DICT.NAME.TEMP THEN
EXEC.FILE = "DATA ":DICT.NAME.TEMP:",":FILE.NAME.TEMP
END ELSE
EXEC.FILE = "DATA ":FILE.NAME.TEMP
END
EXEC.DATA = DEF.FILE.MOD:",":DEF.FILE.SEP
*
EXEC.COMMAND = EXEC.VERB:" ":EXEC.FILE:" ":EXEC.DATA
EXECUTE EXEC.COMMAND, //OUT. > EXEC.RSP
EL.DATA<-ONE> = EXEC.COMMAND
EL.DATA<-ONE> = EXEC.RSP
EL.DATA<-ONE> = ">> "
*
DATA.FILE.RELOOP = TRUE
*
END ELSE
*
STAT = DATA.FILE.MISSING
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "Fmie! ":; *# @@@#
EL.DATA = EL.DATA:"Fmie! "; *# @@@#
*
END; * of FILE.CRE option
*
END; *# of FILE ITEM on file/missing
*
WHILE DATA.FILE.RELOOP AND NOT(DATA.ON.FILE) AND NOT(STAT) DO REPEAT
*
END ELSE
*# DICT file missing
*
STAT = DICT.OPEN.ERROR
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "oDe! ":; *# @@@#
EL.DATA = EL.DATA:"oDe! "; *# @@@#
*
END; *# of DICT file ok/missing
*
END; * of NOT(STAT)
*
IF NOT(STAT) THEN
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "oF":; *# @@@#
EL.DATA = EL.DATA:"oF"; *# @@@#
*
*FILE.NAME.TEMP = WORK.FILE.NAME
FILE.NAME.TEMP = FILE.NAME
DICT.NAME.TEMP = FIELD(DICT.NAME,",",ONE)
IF INDEX(FILE.NAME.TEMP,",",ONE) THEN FILE.NAME.TEMP = FIELD(FILE.NAME.TEMP,",",TWO)
IF FILE.NAME.TEMP NE DICT.NAME.TEMP THEN FILE.NAME.TEMP = DICT.NAME.TEMP:",":FILE.NAME.TEMP
*
OPEN FILE.NAME.TEMP TO DATA.FILE THEN
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "+ ":; *# @@@#
EL.DATA = EL.DATA:"+ "; *# @@@#
END ELSE
STAT = DATA.OPEN.ERROR
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT "oFe! ":; *# @@@#
EL.DATA = EL.DATA:"oFe! "; *# @@@#
END
*
END; * of NOT(STAT)
*
IF NOT(NUM(DICT.BASE)) THEN DICT.BASE = DEF.DICT.BASE
IF NOT(NUM(DICT.MOD)) THEN  DICT.MOD  = DEF.DICT.MOD
IF NOT(NUM(DICT.SEP)) THEN  DICT.SEP  = DEF.DICT.SEP
IF NOT(NUM(FILE.BASE)) THEN FILE.BASE = DEF.FILE.BASE
IF NOT(NUM(FILE.MOD)) THEN  FILE.MOD  = DEF.FILE.MOD
IF NOT(NUM(FILE.SEP)) THEN  FILE.SEP  = DEF.FILE.SEP
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT ". ":; *# @@@#
EL.DATA = EL.DATA:". "; *# @@@#
*
IF PROG.DEBUG OR PROMPT.DEBUG THEN PRINT; PRINT DICT.NAME:" ":FILE.NAME:" ":; *# @@@#
EL.DATA<-ONE> = "File Status Processing - End"; *# @@@#
EL.DATA<-ONE> = "Md: ":MD.FILE.NAME:"  Acct: ":ACCT.NAME:"  Opts: ":OPTIONS
EL.DATA<-ONE> = "Dict: ":DICT.NAME:"  b":DICT.BASE:"  m":DICT.MOD:"  s":DICT.SEP
EL.DATA<-ONE> = "File: ":FILE.NAME:" b":FILE.BASE:" m":FILE.MOD:" s":FILE.SEP
EL.DATA<-ONE> = "Stat: ":STAT:"  Deb: ":PROG.DEBUG:"/":PROMPT.DEBUG:"  Proc: ":MAIN.FLAG
EL.DATA<-ONE> = "Done"
*
RETURN
*
END
~SYS.INPUT.CLEAR~
*
PROMPT CHAR(0)
ECHO OFF
INPUTCLEAR
*
PROG.MAIN: *
FOR A = 1 TO 100
LOOP
TEMP = SYSTEM(11)
WHILE TEMP GT 40 DO
INPUT TEMP1,30:
REPEAT
INPUTCLEAR
FOR B = 1 TO 10; NULL; NEXT B
NEXT A
INPUTCLEAR
RQM
TEMP = SYSTEM(11)
IF TEMP GT 10 THEN GOTO PROG.MAIN
*
ECHO ON
END
~SYS.SUBR.SYSTEM.NAME~
SUBROUTINE SYS.SUBR.SYSTEM.NAME(INP.FILE,SYSTEM.NAME,STAT)
*
*DAVID HORSMAN 03 OCT 89
*
READV SYSTEM.NAME FROM INP.FILE,"SYSTEM.NAME",1 THEN
STAT = 0
END ELSE
SYSTEM.NAME = "UNKNOWN"
STAT = 1
END
*
RETURN
*
END
~SYS.SUBR.SYSTEM.TYPE~
SUBROUTINE SYS.SUBR.SYSTEM.TYPE(INP.FILE,SYSTEM.TYPE,STAT)
*
*DAVID HORSMAN 06 OCT 89
*
READV SYSTEM.TYPE FROM INP.FILE,"SYSTEM.TYPE",1 THEN
STAT = 0
END ELSE
SYSTEM.TYPE = "UNKNOWN"
STAT = 1
END
*
RETURN
*
END
~SYS.COMM.WAIT.QUIET.SUB~
SUBROUTINE SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
*
* AUTHOR: DAVE HORSMAN
* COMPANY: Axion Computer Software
*                  & (additionally)
*          Macroscope Design Matrix (System Communications Design)
*
*   DATE: 10 FEB 89
*
* VARIABLES:
*        IN: CW.QUIET      -    Number of seconds continuous quiet
*            CW.MAX        -    Max length of wait
*            CW.ERROR      -    Max length error flag (null/1)
*            CW.PAUSE      -    # of RQMs to pause each loop
*            CW.CLEAR      -    max # of char's before clearing the
*                                        input buffer (null if don't clear)
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
COMM.PARAM = EMPTY; TRANS.PARAM = EMPTY
*
$INCLUDE IBP SYS.INCL.COMM.WAIT.QUIET
*
RETURN
~SYS.LOG.ENTRY.SUB~
SUBROUTINE SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 01 FEB 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
COMM.PARAM = EMPTY; TRANS.PARAM = EMPTY
*
$INCLUDE IBP SYS.INCL.LOG.ENTRY
*
RETURN
~PICKTR.HEADER.SUB~
SUBROUTINE PICKTR.HEADER.SUB(MAIN.FLAG,FILE.OPT,DIR.FLAG,COMM.SYS.NAME,SYS.NAME,ACCT.NAME,ACCT.PASS,IN.FILE.NAME,OUT.FILE.NAME,OPTIONS,CFILE.NAME,HOST.DETECT,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: 01 FEB 90
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
TRANS.PARAM = EMPTY
COMM.PARAM = EMPTY
*
$INCLUDE IBP SYS.INCL.PICKTR.HEADER
*
RECV.TRANSFER: *#
*
RETURN
*
END
~PICKTR.DETAIL.SUB~
SUBROUTINE PICKTR.DETAIL.SUB(ERR.LOW,ERR.CN,MAIN.FLAG,DONE.FLAG,LIST.NAME,LIST.SOURCE,IN.ITEM.NAME,OUT.ITEM.NAME,IN.FILE.NAME,OUT.FILE.NAME,CN,MAX,ISIZE,HOST.DETECT,OPTIONS,FILE.LIST,DIR.FLAG,FILE.OPT,DICT.BASE,DICT.MOD,DICT.SEP,FILE.BASE,FILE.MOD,FILE.SEP,ACCT.NAME,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: 01 FEB 90
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
TRANS.PARAM = EMPTY
COMM.PARAM = EMPTY
*
$INCLUDE IBP SYS.INCL.PICKTR.DETAIL
*
RECV.TRANSFER: *#
*
RETURN
*
END
~PICK.TRANSFER.SUB~
SUBROUTINE PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIR.FLAG,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,ERR.LEVEL,CW.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.REPEAT.HI,ERR.CONSEC.HI,ERR.OUT.OFFSET,ERR.IN.OFFSET,CHOKE.MODE,PREV.CHK.ID,HEX.MODE,BLOCK.MODE,STAT.RECVD,USER.ID,APPL,ERR.CN.LAST.HI,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,SYS.NAME.SUFFIX,FILTER.IN.STR,FILTER.OUT.STR)
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
TRANS.PARAM = EMPTY; SYS.NAME.SUFFIX = EMPTY
TRANS.ALL.OK = "999"; TRANS.ALL.NOT.OK.CN = "999"; COMM.PARAM.KEY = EMPTY
CHK.START.DATE = DATE(); CHK.START.TIME = TIME()
*
IF DIR.FLAG = DOUT THEN MAX = DCOUNT(ITEM,AM) + ONE ELSE MAX = 99999
*
CHK.ID = "A"; CHK.SUM = ZERO; CHK.SUM.VRF.ERROR = FALSE; VALID.PKT = FALSE
HEX.ON = FALSE; HEX.REQRD = ZERO; CONC = FALSE; LINE.CONT = FALSE
DONE.FLAG = FALSE; CHK.SUM.PREV = EMPTY; STAT.RECVD = FALSE; CN = ZERO
ITEM.OVFL.CN = ZERO; LEN.RSP.ZERO = ZERO; ERR.RECORDED = FALSE
ITEM.END = FALSE; BLOCK.ON = FALSE; VALID.CONSEC = ZERO
*
IF MAX GT AM.MAX THEN
TMP = INDEX(ITEM,AM,AM.MAX)
ITEM.OVFL = ITEM[TMP,HI.NUM]
ITEM = ITEM[ONE,TMP-ONE]
ITEM.OVFL.FLAG = TRUE
ITEM.OVFL.CN = AM.MAX - TWO
END ELSE
ITEM.OVFL.FLAG = FALSE
END
LINE = EMPTY; LINE.PACKET = EMPTY; LINE.IS.HEX = FALSE
*
IF HEX.MODE THEN HEX.REQRD = ERR.CN.LAST.HI
*
IF NOT(ERR.REPEAT.HI) THEN ERR.REPEAT.HI = 3
IF NOT(ERR.CONSEC.HI) THEN ERR.CONSEC.HI = ERR.MAX/4
ERR.CN.LAST = ERR.CN; ERR.CONSEC = ZERO; ERR.REPEAT = ERR.REPEAT.HI; ERR.RECVD = FALSE; ERR.SENT = FALSE
IF ERR.CN - 3 GT ERR.LOW THEN ERR.CN = ERR.CN - 3
*
*$INCLUDE IBP SYS.INCL.QUIET.READ
*$INCLUDE IBP SYS.INCL.QUIET.WRITE
*
IF DIR.FLAG EQ DIN THEN
FOR A = ONE TO 30 UNTIL SYSTEM(ELEVEN) GE 4
GOSUB PACKET.ERROR.PAUSE; *#
NEXT A
CN = ONE
END
*
FILTER.IN.MODE = FILTER.IN.STR<ONE,ONE>
FILTER.OUT.MODE = FILTER.OUT.STR<ONE,TWO>
*
IF BLOCK.MODE THEN ERR.SENT = BLOCK.MODE.VRF; GOSUB PACKET.ERROR.SEND; *#
*
IF CHOKE.MODE THEN ERR.SENT = CHOKE.MODE.VRF; GOSUB PACKET.ERROR.SEND; *#
*
IF STAT THEN ERR.SENT = STAT.VRF; GOSUB PACKET.ERROR.SEND; *#
*
LINE.CURR = EMPTY; LINE.PACKET.CURR = EMPTY; LINE.PACKET.CURR.ID = EMPTY
*
GOSUB ABORT.CHECK; *#
*
*
LOOP
*
CHK.ID.RECVD = EMPTY; CHK.SUM.RECVD = EMPTY
*
IF DIR.FLAG EQ DIN AND CN LE MAX THEN
*
*# Loop to input valid block
PKT.REPS = ERR.REPEAT.HI
*
LOOP
*
PKT.REPS = PKT.REPS - ONE
IF PKT.REPS THEN
*
*# Input next block or command
$INCLUDE IBP SYS.INCL.PORT.INP
*
RSP = ACK.RSP
CHK.ID.RECVD = EMPTY; CHK.SUM.RECVD = EMPTY
*
*# Is this a valid block?
IF VALID.PKT THEN
*
IF STAT AND ERR.RECVD NE ERR.SENT AND ERR.SENT NE STAT.VRF THEN
ERR.SENT = STAT.VRF; GOSUB PACKET.ERROR.SEND; *#
END; *# of STAT
*
RSP = RSP[3,HI.NUM]
CHK.ID.RECVD = FIELD(RSP,STB,ONE); CHK.SUM.RECVD = FIELD(RSP,STB,TWO)
*
*# Is this a valid block
IF CHK.ID.RECVD EQ CHK.ID THEN
*
*# Is the check-sum a valid numeric?
IF NOT(NUM(CHK.SUM.RECVD)) THEN
VALID.PKT = FALSE
ERR.SENT = CHK.SUM.BAD.VRF; GOSUB PACKET.ERROR.SEND; *#
END ELSE
*
*# The check-sum is a valid numeric, trim the pkt leader
LINE = RSP[COL2()+ONE,HI.NUM]
*
END; *# of valid numeric check-sum
*
END ELSE
*
*# The block ID is not correct
VALID.PKT = FALSE
TEMP = CHAR(SEQ(PREV.CHK.ID)-ONE)
IF TEMP = "@" THEN TEMP = "Y"
IF CHK.ID.RECVD EQ TEMP THEN PREV.CHK.ID = TEMP ELSE
TEMP = CHAR(SEQ(PREV.CHK.ID)+ONE)
IF TEMP = "Z" THEN TEMP = "A"
IF CHK.ID.RECVD EQ TEMP THEN PREV.CHK.ID = TEMP
END
*
IF CHK.ID.RECVD EQ PREV.CHK.ID THEN
*# Block OK
ERR.SENT = PREV.CHK.ID.VRF; GOSUB PACKET.ERROR.SEND; *#
*
END ELSE
*
*# Block NOT OK
LINE.MESSAGE = RSP; GOSUB PACKET.ERROR.RECVD; *#
IF NOT(MESSAGE.RECVD) THEN
ERR.SENT = CHK.ID.VRF; GOSUB PACKET.ERROR.SEND; *#
END; *# of block not a recvd message
END; *# of block repeat,message or junk
END; *# of valid block processing
*#
END ELSE 
*
*# This is a NOT A PACKET
VALID.PKT = FALSE
LEN.RSP = LEN(RSP)
IF NOT(LEN.RSP) THEN
LEN.RSP.ZERO = LEN.RSP.ZERO + ONE
IF LEN.RSP.ZERO GT 10 THEN STAT = MAX.ERR.ABORT.VRF; STAT.RECVD = LINE.HUNG
END ELSE LEN.RSP.ZERO = ZERO
ERR.SENT = NON.PACKET.VRF; GOSUB PACKET.ERROR.SEND; *#
END; *# of valid/invalid block processing
*
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERR.ABORT.VRF
IF ERR.CONSEC GE ERR.CONSEC.HI THEN
IF ERR.REPEAT LE ZERO THEN ERR.CONSEC = -ERR.MAX ELSE ERR.CONSEC = ZERO; ERR.REPEAT = ERR.REPEAT - ONE; ERR.CN = ERR.LOW
END
*
END; * OF PKT.REPS
*
WHILE NOT(VALID.PKT) AND STAT NE MAX.ERR.ABORT.VRF AND PKT.REPS DO
*
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = ERR.CN.LAST.HI; ERR.CONSEC = ERR.CONSEC + ONE; VALID.CONSEC = ZERO; ERR.CN.ALL = ERR.CN.ALL + ONE; ERR.LEVEL<ONE,TWO,ERR.CN+ONE> = ERR.LEVEL<ONE,TWO,ERR.CN+ONE> + ONE
*
REPEAT
*
END; *# OF DIR.FLAG
*
WHILE CN LT MAX AND STAT NE MAX.ERR.ABORT.VRF DO
*
*# Loop to transmit or receive an attribute
LOOP
*
TMP = DATE(); TMP1 = TIME()
IF TMP GT CHK.START.TIME OR (TMP GE CHK.START.DATE AND TMP1 GE CHK.START.TIME+CW.MAX) THEN
GOSUB ABORT.CHECK; *#
IF EL.TRACE THEN
EL.DATA = "* * * COMMUNICATION SETTINGS * * *":AM:"* * * ":(OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")) "L#22":" * * *":AM:CP:AM:STR("*",34)
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
CHK.START.DATE = TMP; CHK.START.TIME = TMP1
END
*
IF ERR.VRF.ARRAY<ONE,HEX.MODE.VRF> NE ERR.VRF.ARRAY<TWO,HEX.MODE.VRF> THEN ERR.SENT = HEX.MODE.VRF
*
IF CHOKE.MODE AND ERR.VRF.ARRAY<ONE,CHOKE.MODE.VRF> NE ERR.VRF.ARRAY<TWO,CHOKE.MODE.VRF> THEN ERR.SENT = CHOKE.MODE.VRF
*
IF STAT AND ERR.VRF.ARRAY<ONE,STAT.VRF> NE ERR.VRF.ARRAY<TWO,STAT.VRF> THEN ERR.SENT = STAT.VRF
*
IF ERR.RECVD NE ERR.SENT AND ERR.SENT THEN
IF ERR.VRF.ARRAY<5,ERR.SENT> THEN LINE.PACKET = EMPTY; GOSUB PACKET.ERROR.SEND.AGAIN; *#
END
*
IF CHOKE.MODE THEN
FOR TMP = ONE TO CHOKE.MODE
RQM
NEXT TMP
END
*
IF DIR.FLAG EQ DOUT THEN
*
VALID.PKT = TRUE
LINE.LEN = LINE.MAX.LEN; IF HEX.ON THEN LINE.LEN = LINE.LEN / TWO + ONE
*
*# Line continuation
IF LEN(LINE.CONT) THEN
LINE = LINE.CONT<ONE>; DEL LINE.CONT<ONE,ZERO,ZERO>; LINE.IS.HEX = FALSE
END ELSE
*
*# Get next attribute to transmit
CN = CN + ONE; ITEM.OVFL.CN = ITEM.OVFL.CN - ONE
IF CN LE MAX THEN
IF ITEM.OVFL.FLAG THEN
IF ITEM.OVFL.CN LE ZERO THEN
ITEM.OVFL.CN = AM.MAX - TWO
IF NOT(LEN(ITEM.OVFL)) THEN
ITEM.OVFL.FLAG = FALSE
END ELSE
TMP = INDEX(ITEM.OVFL,AM,AM.MAX)
IF NOT(TMP) THEN TMP = HI.NUM; ITEM.OVFL.CN = ONE
ITEM = ITEM:ITEM.OVFL[ONE,TMP-ONE]
ITEM.OVFL = ITEM.OVFL[TMP,HI.NUM]
END
END
END
IF NOT(LEN(ITEM)) THEN
ITEM<-ONE> = PERR.MESSAGE:">END>"
IF ITEM.END THEN
CHK.ID = CHAR(SEQ(CHK.ID)-ONE)
IF CHK.ID = "@" THEN CHK.ID = "Y"
END
ITEM.END = TRUE
END
*
LINE = EMPTY
*
LOOP
LINE = LINE:ITEM<ONE>; DEL ITEM<ONE,ZERO,ZERO>; LINE.IS.HEX = FALSE
WHILE LEN(LINE) + LEN(ITEM<ONE>) + ONE LT LINE.LEN * .9 AND LEN(ITEM) DO
LINE = LINE:AM
CN = CN + ONE; ITEM.OVFL.CN = ITEM.OVFL.CN - ONE
IF NOT(ERR.CN) THEN ERR.CN = ONE
REPEAT
*
*# Character Filter Out
*
END; *# of CN LT MAX
*
END; *# of line continuation
*
IF LEN(LINE) GT LINE.LEN THEN
$INCLUDE IBP SYS.INCL.LOAD.LINE.CONT
LINE = LINE.CONT<ONE>; DEL LINE.CONT<ONE,ZERO,ZERO>; LINE.IS.HEX = FALSE
END; *# of line too long
*
END; *# of DIR.FLAG 	eq DOUT
*
*# Calculate check-sum
IF (DIR.FLAG NE DOUT OR CN LE MAX) AND VALID.PKT THEN
*
*# Is this a command of some sort ?
IF LINE[ONE,LEN(PERR.MESSAGE)] NE PERR.MESSAGE AND LINE NE CONT.MESSAGE THEN
*
*IF HEX.ON AND ERR.VRF.ARRAY<ONE,HEX.MODE.VRF> EQ ERR.VRF.ARRAY<TWO,HEX.MODE.VRF> AND DIR.FLAG EQ DIN THEN
IF HEX.ON AND DIR.FLAG EQ DIN THEN
LINE.IS.HEX = TRUE
$INCLUDE IBP SYS.INCL.CONV.TO.TXT
END
*
END
*
$INCLUDE IBP SYS.INCL.CALC.CHK.SUM
*IF DIR.FLAG EQ DIN THEN CHK.SUM.PREV = CHK.SUM
END
*
IF HEX.ON AND ERR.VRF.ARRAY<ONE,HEX.MODE.VRF> EQ ERR.VRF.ARRAY<TWO,HEX.MODE.VRF> AND DIR.FLAG EQ DOUT THEN
LINE.IS.HEX = FALSE
$INCLUDE IBP SYS.INCL.CONV.TO.HEX
END
*
IF DIR.FLAG EQ DIN AND VALID.PKT THEN
*
*# Bad block
IF CHK.SUM NE CHK.SUM.RECVD THEN
ERR.SENT = CHK.SUM.VRF; GOSUB PACKET.ERROR.SEND; *#
IF CHK.SUM LT CHK.SUM.RECVD * .75 AND ERR.IN.OFFSET LT ERR.HI THEN ERR.IN.OFFSET = ERR.IN.OFFSET + ONE
HEX.REQRD = HEX.REQRD + ONE
END ELSE
*
*# Block OK
LINE.PACKET = ESC:"Y":CHK.ID:CR:NUL
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:; *#
PREV.CHK.ID = CHK.ID
*
IF ERR.CN GT ERR.LOW THEN
IF ERR.CN.LAST LE ZERO THEN ERR.CN = ERR.CN - ONE; ERR.CN.LAST = ERR.CN.LAST.HI ELSE ERR.CN.LAST = ERR.CN.LAST - ONE
END
ERR.CONSEC = ZERO
VALID.CONSEC = VALID.CONSEC + ONE
IF VALID.CONSEC GE ERR.MAX THEN ERR.REPEAT = ERR.REPEAT.HI; ERR.CONSEC = ZERO
*
*# Is this a command of some sort ?
IF LINE[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE THEN
LINE.MESSAGE = LINE; GOSUB PACKET.ERROR.RECVD; *#
*
* is this a line continuation command
END ELSE IF LINE EQ CONT.MESSAGE THEN
CONC = TRUE
*
END ELSE
*
*# Line continuation
IF CONC THEN
ITEM = ITEM:LINE
CONC = FALSE
END ELSE
*
*# Character Filter In
*# Next attribute
CN.INC = DCOUNT(LINE,AM)
CN = CN + CN.INC + NOT(CN.INC)
IF CN GT ONE THEN ITEM=ITEM:AM:LINE ELSE ITEM = LINE
END; *# OF CONC
*
END; *# of types of lines
END; *# OF CHK.VRF
*
END ELSE IF DIR.FLAG EQ DOUT THEN
*
*#  DIR.FLAG EQ DOUT
*
IF LEN(LINE.PACKET.CURR) THEN
LOOP
*
*# Input block verfication message
$INCLUDE IBP SYS.INCL.PORT.INP
*
*# Loop back for PACKET
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERR.ABORT.VRF
IF ERR.CONSEC GE ERR.CONSEC.HI THEN
IF ERR.REPEAT LE ZERO THEN ERR.CONSEC = -ERR.MAX ELSE ERR.CONSEC = ZERO; ERR.REPEAT = ERR.REPEAT - ONE; ERR.CN = ERR.LOW
END
*
WHILE ACK.RSP NE "GO" AND ACK.RSP NE ESC:"Y":LINE.PACKET.CURR.ID AND STAT NE MAX.ERR.ABORT.VRF DO
*
IF ACK.RSP[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE THEN LINE.MESSAGE = ACK.RSP; GOSUB PACKET.ERROR.RECVD ELSE
*
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = ERR.CN.LAST.HI; ERR.CONSEC = ERR.CONSEC + ONE; VALID.CONSEC = ZERO; ERR.CN.ALL = ERR.CN.ALL + ONE; ERR.LEVEL<ONE,TWO,ERR.CN+ONE> = ERR.LEVEL<ONE,TWO,ERR.CN+ONE> + ONE
*
END
*
IF ERR.RECVD NE ERR.SENT AND ERR.SENT THEN
IF ERR.VRF.ARRAY<5,ERR.SENT> THEN LINE.PACKET = EMPTY; GOSUB PACKET.ERROR.SEND; *#
END
*
*# Send block
LINE.PACKET = LINE.PACKET.CURR
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:; *#
*
TMP = DATE(); TMP1 = TIME()
IF TMP GT CHK.START.TIME OR (TMP GE CHK.START.DATE AND TMP1 GE CHK.START.TIME+CW.MAX) THEN
GOSUB ABORT.CHECK; *#
CHK.START.DATE = TMP; CHK.START.TIME = TMP1
END
*
REPEAT
CHK.SUM.PREV = EMPTY; VALID.PKT = TRUE
END; * of LINE.PACKET.CURR
*
IF CN LE MAX THEN
*
IF HEX.REQRD GT ZERO THEN HEX.REQRD = HEX.REQRD - ONE
IF HEX.ON AND NOT(HEX.MODE) AND HEX.REQRD EQ ZERO AND DIR.FLAG EQ DOUT THEN
*SET ARRAY FOR HEX
HEX.ON = FALSE
ERR.SENT = HEX.MODE.VRF; GOSUB PACKET.ERROR.SEND; *#
$INCLUDE IBP SYS.INCL.CONV.TO.TXT
END
*
LINE.CURR = LINE
LINE.PACKET.CURR = ESC:STB:CHK.ID:STB:CHK.SUM:STB:LINE.CURR:CR:NUL
LINE.PACKET.CURR.ID = CHK.ID
*# Send block
LINE.PACKET = LINE.PACKET.CURR
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:; *#
*
END
*
IF ERR.CN GT ERR.LOW THEN
IF ERR.CN.LAST LE ZERO AND ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE; ERR.CN.LAST = ERR.CN.LAST.HI ELSE ERR.CN.LAST = ERR.CN.LAST - ONE
END
ERR.CONSEC = ZERO
*
END; *# OF DIR.FLAG
*
*# Increment block ID
IF VALID.PKT THEN
CHK.ID = CHAR(SEQ(CHK.ID)+ONE)
IF CHK.ID = "Z" THEN CHK.ID = "A"
ERR.LEVEL<ONE,ONE,ONE> = ERR.LEVEL<ONE,ONE,ONE> + ONE
ERR.LEVEL<ONE,ONE,ERR.CN+TWO> = ERR.LEVEL<ONE,ONE,ERR.CN+TWO> + ONE
END ELSE IF DIR.FLAG EQ DIN THEN
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = ERR.CN.LAST.HI; ERR.CONSEC = ERR.CONSEC + ONE; VALID.CONSEC = ZERO; ERR.CN.ALL = ERR.CN.ALL + ONE; ERR.LEVEL<ONE,TWO,ERR.CN+ONE> = ERR.LEVEL<ONE,TWO,ERR.CN+ONE> + ONE
END
*
WHILE CN LE MAX AND DIR.FLAG EQ DOUT AND STAT NE MAX.ERR.ABORT.VRF DO REPEAT
*
REPEAT
*
*IF DONE.FLAG EQ UNAVAIL.SCHED THEN 
IF DONE.FLAG THEN STAT = DONE.FLAG
*
$INCLUDE IBP SYS.INCL.QUIET.READ
$INCLUDE IBP SYS.INCL.QUIET.WRITE
*
IF EL.TRACE THEN
EL.DATA = ERR.VRF.ARRAY
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
RETURN
*
PACKET.ERROR.RECVD: *# Subroutine to decode error messages recieved
*
MESSAGE.RECVD = TRUE
*
IF LINE.MESSAGE[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE THEN
LINE.MESSAGE = LINE.MESSAGE[LEN(PERR.MESSAGE)+ONE,HI.NUM]
MESS.TYPE  = FIELD(LINE.MESSAGE,">",TWO)
LOCATE MESS.TYPE IN ERR.VRF.ARRAY<3> SETTING MESS.LOC ELSE MESS.LOC = 13
MESS.VAR   = FIELD(LINE.MESSAGE,">",3)
MESS.STATE = FIELD(LINE.MESSAGE,">",4)
MESS.EXT   = FIELD(LINE.MESSAGE,">",5)
*
IF NOT(ERR.RECORDED) AND (EL.TRACE GE ONE OR EL.TRACE.IN OR (EL.TRACE.CN AND ERR.CN GT ERR.LOW + ERR.REPEAT.HI)) THEN
IF EL.TRACE EQ ONE AND NOT(EL.TRACE.IN) AND NOT(EL.TRACE.CN AND ERR.CN GT ERR.LOW + ERR.REPEAT.HI) THEN
EL.DATA = FIELD(ACK.RSP,ESC,ONE)
END ELSE EL.DATA = ACK.RSP
IF LEN(EL.DATA) THEN
EL.DATA = WHO:".":DATE():".":OCONV(TIME(),"MTS"):">":EL.DATA
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
ERR.RECORDED = TRUE
END
END
*
*
BEGIN CASE
*
CASE MESS.LOC EQ RECVD.VRF
LOCATE MESS.VAR IN ERR.VRF.ARRAY<3> SETTING MESS.LOC THEN
ERR.RECVD = MESS.LOC; IF ERR.SENT EQ ERR.RECVD THEN ERR.SENT = ZERO
IF ERR.VRF.ARRAY<TWO,MESS.LOC> LT ERR.VRF.ARRAY<ONE,MESS.LOC> THEN
ERR.VRF.ARRAY<TWO,MESS.LOC> = ERR.VRF.ARRAY<TWO,MESS.LOC> + ONE
END
IF ERR.VRF.ARRAY<TWO,MESS.LOC> LT ERR.VRF.ARRAY<ONE,MESS.LOC> THEN
LINE.PACKET = PERR.MESSAGE:">":ERR.VRF.ARRAY<3,MESS.LOC>:">":ERR.VRF.ARRAY<4,MESS.LOC>:">":CR:NUL
GOSUB PACKET.ERROR.PAUSE; *#
GOSUB CHAR.SEND.PKT; *#
END
END
*
CASE MESS.LOC
*
IF ERR.VRF.ARRAY<5,MESS.LOC> THEN
LINE.PACKET = PERR.MESSAGE:">":ERR.VRF.ARRAY<3,RECVD.VRF>:">":ERR.VRF.ARRAY<3,MESS.LOC>:">":CR:NUL
ERR.VRF.ARRAY<TWO,MESS.LOC> = ERR.VRF.ARRAY<ONE,MESS.LOC>
GOSUB PACKET.ERROR.PAUSE; *#
GOSUB CHAR.SEND.PKT; *#
END
*
BEGIN CASE
*
*# Is this the end of transmission
CASE MESS.LOC EQ END.VRF OR MESS.LOC EQ ABORT.VRF
INP.EXIT = TRUE
CONC = FALSE
IF MESS.LOC EQ END.VRF AND CN GT ONE THEN MAX = CN - ONE
* (^^^ MIGHT BE TRUE FOR ABORT AS WELL)
IF MESS.LOC EQ ABORT.VRF THEN STAT = 9
*
CASE MESS.LOC EQ STAT.VRF
IF NOT(NUM(MESS.VAR)) THEN STAT.REVCD = ERROR.RECVD ELSE STAT.REVCD = MESS.VAR
STAT = 9
ERR.RECVD = TRUE
INP.EXIT = TRUE
*
CASE MESS.LOC EQ CHK.ID.VRF
IF MESS.STATE EQ EMPTY THEN INP.EXIT = TRUE
*
CASE MESS.LOC EQ BLOCK.MODE.VRF
BLOCK.ON = MESS.VAR
*
CASE MESS.LOC EQ HEX.MODE.VRF
HEX.ON = MESS.VAR
*
CASE MESS.LOC EQ CHK.SUM.VRF
IF MESS.VAR EQ CHK.SUM.PREV AND DIR.FLAG EQ DOUT THEN
HEX.REQRD = HEX.REQRD + ONE
IF HEX.REQRD GT ERR.CN.LAST.HI * TWO THEN
*SET ARRAY FOR HEX
IF NOT(HEX.ON) THEN
HEX.ON = TRUE
HEX.REQRD = ERR.MAX * TWO
LINE.IS.HEX = FALSE
*SAVE.LINE = LINE
$INCLUDE IBP SYS.INCL.LOAD.LINE.CONT
LINE = LINE.CURR
$INCLUDE IBP SYS.INCL.LOAD.LINE.CONT
LINE = LINE.CONT<ONE>; DEL LINE.CONT<ONE,ZERO,ZERO>; LINE.IS.HEX = FALSE
$INCLUDE IBP SYS.INCL.CALC.CHK.SUM
$INCLUDE IBP SYS.INCL.CONV.TO.HEX
LINE.CURR = LINE
TEMP = CHAR(SEQ(CHK.ID)-ONE)
IF TEMP = "@" THEN TEMP = "Y"
LINE.PACKET.CURR = ESC:STB:TEMP:STB:CHK.SUM:STB:LINE.CURR:CR:NUL
*LINE = SAVE.LINE
LINE = LINE.CONT<ONE>; DEL LINE.CONT<ONE,ZERO,ZERO>; LINE.IS.HEX = FALSE
LINE.IS.HEX = FALSE
$INCLUDE IBP SYS.INCL.CALC.CHK.SUM
$INCLUDE IBP SYS.INCL.CONV.TO.HEX
END
ERR.SENT = HEX.MODE.VRF; GOSUB PACKET.ERROR.SEND; *#
END
END ELSE
CHK.SUM.PREV = MESS.VAR
IF (NUM(MESS.EXT) AND NUM(MESS.VAR)) AND (MESS.VAR NE MESS.EXT AND ERR.OUT.OFFSET LT ERR.HI) THEN
ERR.OUT.OFFSET = ERR.OUT.OFFSET + ONE
END ELSE
ERR.CN = ERR.CN + ONE; ERR.CN.LAST = ERR.CN.LAST.HI; ERR.CONSEC = ERR.CONSEC + ONE; VALID.CONSEC = ZERO; ERR.CN.ALL = ERR.CN.ALL + ONE; ERR.LEVEL<ONE,TWO,ERR.CN+ONE> = ERR.LEVEL<ONE,TWO,ERR.CN+ONE> + ONE
END
END
*
CASE MESS.LOC EQ NON.PACKET.VRF
IF MESS.VAR EQ "0" THEN
LEN.RSP.ZERO = LEN.RSP.ZERO + ONE
IF LEN.RSP.ZERO GT 10 THEN STAT = MAX.ERR.ABORT.VRF; STAT.RECVD = LINE.HUNG
END
INP.EXIT = TRUE
*
CASE MESS.LOC EQ SLEEP.VRF
*
EXEC.VERB = "SLEEP ":MESS.VAR
EXECUTE EXEC.VERB
*
CASE MESS.LOC EQ PAUSE.VRF
RQM; RQM; RQM
START.SYSTEM.11 = SYSTEM(ELEVEN)
START.DATE = DATE()
START.TIME = TIME()
LOOP
CURR.SYSTEM.11 = SYSTEM(ELEVEN)
CURR.TIME = ((DATE()-START.DATE) * 86400) + TIME() - START.TIME
WHILE CURR.SYSTEM.11 - START.SYSTEM.11 LT 10 AND CURR.TIME LT 3600 DO
EXECUTE "SLEEP 29"
REPEAT
*
CASE TRUE
NULL
*
END CASE
*
CASE TRUE
NULL
*
END CASE
*
END ELSE IF MAIN.FLAG NE MASTER AND (CHK.ID.RECVD EQ "OFF" OR CHK.ID.RECVD EQ "KILL" OR CHK.ID.RECVD EQ "TCL") THEN
CONT = FALSE
CONC = FALSE
MAX = CN - ONE
CHK.SUM.RECVD.ERROR = FALSE
STAT = ERROR.RECVD
STAT.RECVD = ERROR.RECVD
ERR.CN.ARRAY<ONE,6> = ERR.CN.ARRAY<ONE,6> + ONE
ERR.VRF.ARRAY<ONE,6> = ERR.VRF.ARRAY<ONE,6> + ONE
ERR.VRF.ARRAY<4,6> = CHK.ID.RECVD
*
END ELSE
MESSAGE.RECVD = FALSE
END; *# of PERR.MESSAGE or ERROR.CHECK
*
RETURN
*
PACKET.ERROR.SEND: *# Subroutine to send an inter-packet error message
*
BEGIN CASE
*
CASE ERR.SENT EQ RECVD.VRF
*
CASE ERR.SENT EQ STAT.VRF
ERR.RECVD = FALSE; ERR.VRF.ARRAY<4,STAT.VRF> = STAT
ERR.VRF.ARRAY<6,STAT.VRF> = MAIN.FLAG; ERR.VRF.ARRAY<7,STAT.VRF> = DIR.FLAG
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ CHK.SUM.BAD.VRF
ERR.RECVD = FALSE; ERR.VRF.ARRAY<4,CHK.SUM.BAD.VRF> = CHK.SUM.RECVD
ERR.VRF.ARRAY<6,CHK.SUM.BAD.VRF> = CHK.ID; ERR.VRF.ARRAY<7,CHK.SUM.BAD.VRF> = CN
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ CHK.ID.VRF
ERR.RECVD = CHK.ID.VRF; ERR.VRF.ARRAY<4,CHK.ID.VRF> = CHK.ID.RECVD
ERR.VRF.ARRAY<6,CHK.ID.VRF> = "NE"; ERR.VRF.ARRAY<7,CHK.ID.VRF> = CHK.ID:"/":PREV.CHK.ID
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ NON.PACKET.VRF
ERR.RECVD = NON.PACKET.VRF; ERR.VRF.ARRAY<4,NON.PACKET.VRF> = LEN.RSP
ERR.VRF.ARRAY<6,NON.PACKET.VRF> = CHK.ID; ERR.VRF.ARRAY<7,NON.PACKET.VRF> = CN
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ CHK.SUM.VRF
ERR.RECVD = CHK.SUM.VRF; ERR.VRF.ARRAY<4,CHK.SUM.VRF> = CHK.SUM
ERR.VRF.ARRAY<6,CHK.SUM.VRF> = "NE"; ERR.VRF.ARRAY<7,CHK.SUM.VRF> = CHK.SUM.RECVD
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ KEYBOARD.ABORT.VRF
*
CASE ERR.SENT EQ PREV.CHK.ID.VRF
ERR.RECVD = PREV.CHK.ID.VRF; ERR.VRF.ARRAY<4,PREV.CHK.ID.VRF> = PREV.CHK.ID
ERR.VRF.ARRAY<6,PREV.CHK.ID.VRF> = CHK.ID; ERR.VRF.ARRAY<7,PREV.CHK.ID.VRF> = CN
LINE.PACKET = ESC:"Y":PREV.CHK.ID:CR:NUL
*
CASE ERR.SENT EQ END.VRF
*
CASE ERR.SENT EQ ABORT.VRF
*
CASE ERR.SENT EQ CHOKE.MODE.VRF
ERR.RECVD = FALSE; ERR.VRF.ARRAY<4,CHOKE.MODE.VRF> = CHOKE.MODE
ERR.VRF.ARRAY<6,CHOKE.MODE.VRF> = MAIN.FLAG; ERR.VRF.ARRAY<7,CHOKE.MODE.VRF> = DIR.FLAG
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ HEX.MODE.VRF
ERR.RECVD = FALSE; ERR.VRF.ARRAY<4,HEX.MODE.VRF> = HEX.ON
ERR.VRF.ARRAY<6,HEX.MODE.VRF> = MAIN.FLAG; ERR.VRF.ARRAY<7,HEX.MODE.VRF> = DIR.FLAG
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ BLOCK.MODE.VRF
ERR.RECVD = FALSE; ERR.VRF.ARRAY<4,BLOCK.MODE.VRF> = BLOCK.MODE
ERR.VRF.ARRAY<6,BLOCK.MODE.VRF> = MAIN.FLAG; ERR.VRF.ARRAY<7,BLOCK.MODE.VRF> = DIR.FLAG
LINE.PACKET = EMPTY
*
CASE ERR.SENT EQ MAX.ERR.ABORT.VRF
*
CASE ERR.SENT EQ SLEEP.VRF
*
CASE ERR.SENT EQ PAUSE.VRF
*
CASE TRUE
*
END CASE
*
PACKET.ERROR.SEND.AGAIN: *#
IF ERR.SENT NE ERR.RECVD AND ERR.SENT THEN
IF ERR.RECVD NE HI.NUM THEN
ERR.RECVD = HI.NUM
ERR.CN.ARRAY<ONE,ERR.SENT> = ERR.CN.ARRAY<ONE,ERR.SENT> + ONE
ERR.VRF.ARRAY<ONE,ERR.SENT> = ERR.VRF.ARRAY<ONE,ERR.SENT> + ONE
END
END; *# OF ERR.SENT
*
IF LINE.PACKET EQ EMPTY THEN
LINE.PACKET = PERR.MESSAGE:">":ERR.VRF.ARRAY<3,ERR.SENT>:">":ERR.VRF.ARRAY<4,ERR.SENT>:">":ERR.VRF.ARRAY<6,ERR.SENT>:">":ERR.VRF.ARRAY<7,ERR.SENT>:">":CR:NUL
END
*
GOSUB PACKET.ERROR.PAUSE; *#
IF ERR.CN THEN GOSUB CHAR.SEND.PKT ELSE PRINT LINE.PACKET:; *#
*
RETURN
*
PACKET.ERROR.PAUSE: *# Subroutine to pause between error packets
*
IF SYSTEM(ELEVEN) LT 4 THEN
TMP = ERR.CN
TMP = TMP + ERR.IN.OFFSET
IF DIR.FLAG EQ DOUT THEN TMP = INT(TMP/TWO)
IF TMP LE ERR.LOW THEN TMP = ERR.LOW
IF TMP GT ERR.HI AND ERR.HI THEN TMP = ERR.HI
CHAR.PAUSE = TMP * (ONE+TMP/10) * 5
FOR TMP1 = ONE TO 50 UNTIL SYSTEM(ELEVEN) GE 4
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT CHAR.PAUSE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
NEXT TMP1
END
*
RETURN
*
ABORT.CHECK: *# Subroutine to check for abort every MAX.WAIT seconds
*
FSEARCH.PREFIX = "TRANSFER.ABORT"
$INCLUDE IBP SYS.INCL.FSEARCH.TOP
$INCLUDE IBP SYS.INCL.ABORT.CHECK.READ
$INCLUDE IBP SYS.INCL.FSEARCH.BOT
$INCLUDE IBP SYS.INCL.ABORT.CHECK
*
FSEARCH.PREFIX = "TRANSFER.SCHED"
$INCLUDE IBP SYS.INCL.FSEARCH.TOP
$INCLUDE IBP SYS.INCL.SCHED.CHECK.READ
$INCLUDE IBP SYS.INCL.FSEARCH.BOT
$INCLUDE IBP SYS.INCL.SCHED.CHECK
*
IF NOT(SCHED.OK) THEN DONE.FLAG = UNAVAIL.SCHED; STAT = UNAVAIL.SCHED
IF STAT EQ LOGOFF.COMMAND THEN DONE.FLAG = STAT; STAT = MAX.ERR.ABORT.VRF
*
$INCLUDE IBP SYS.INCL.QUIET.READ
$INCLUDE IBP SYS.INCL.QUIET.WRITE
$INCLUDE IBP SYS.INCL.QUIET.LOAD
*
RETURN
*
CHAR.SEND.PKT: *# Subroutine to send packet
*
$INCLUDE IBP SYS.INCL.PORT.OUT
*
RETURN
*
END
~PICK.TRANSFER~
*PROGRAM: PICK.TRANSFER
*      
*AUTHOR: DAVID HORSMAN
*DATE: 23 SEP 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.CHARACTERS
*      
$INCLUDE IBP STANDARD.CHARACTERS
*      
ERR.VRF.ARRAY = ""
*
$INCLUDE IBP SYS.INCL.PICKTR.EQU
*
$INCLUDE IBP SYS.INCL.PICKTR.INIT
*
*IF MAIN.FLAG EQ MASTER  THEN
*PRINT
*END ELSE
IF MAIN.FLAG NE MASTER THEN
*
$INCLUDE IBP SYS.INCL.USER.SET
*
HOST.DETECT = FALSE
CALL PICKTR.HEADER.SUB(MAIN.FLAG,FILE.OPT,DIR.FLAG,COMM.SYS.NAME,SYS.NAME,ACCT.NAME,ACCT.PASS,IN.FILE.NAME,OUT.FILE.NAME,OPTIONS,CFILE.NAME,HOST.DETECT,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
IF HOST.DETECT THEN GOTO RECV.TRANSFER ELSE MAIN.FLAG = ENTRY
*
IF NOT(INDEX(OPTIONS,"L",ONE)) THEN
IF DIR.FLAG EQ DIN THEN
CFILE.NAME = OUT.FILE.NAME
END ELSE CFILE.NAME = IN.FILE.NAME
*
MD.FILE.NAME = "MD"; DICT.NAME = CFILE.NAME; DICT.BASE = FALSE; DICT.MOD = FALSE; DICT.SEP = FALSE; FILE.MOD = FALSE; FILE.SEP = FALSE; FILE.NAME = CFILE.NAME; FILE.BASE = FALSE; STAT = FALSE; PROG.DEBUG = FALSE
*
CALL SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,FILE.OPT,FILE.NAME,FILE.BASE,STAT,PROG.DEBUG,ACCT.NAME,MAIN.FLAG,EL.DATA,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
IF EL.TRACE AND LEN(EL.DATA) THEN
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
END; *# OF "L"
END; *# of SLAVE OR ENTRY
*      
RECV.TRANSFER: *#
*
IF MAIN.FLAG NE ENTRY THEN ECHO OFF
*
IF MAIN.FLAG EQ MASTER THEN
*# Wait for line to go quiet
CW.ERROR = EMPTY
CW.KEY   = EMPTY
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
END
*      
IF EL.TRACE THEN
EL.DATA = "Session started, ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
RECV.TRANSFER.RELOOP: *#
*
LOOP
*
COMM.INIT = FALSE; COMM.ERROR = FALSE; COMM.STARTUP = FALSE; COMM.SHUTDOWN = FALSE
*
TRANS.NUMBER = ZERO; TP.CN.FOUND = FALSE
*
IF MAIN.FLAG EQ SLAVE THEN TP.MAX = HI.NUM
*
IF NOT(COMM.ERROR OR STAT) AND MAIN.FLAG EQ MASTER THEN
LOOP
GOSUB COMM.ABORT.CHECK
IF NOT(STAT) THEN
GOSUB COMM.SCHED.CHECK
IF SCHED.OK THEN
TRANS.SUF = "NEXT"
GOSUB PARAM.READ
ITEM = EMPTY
END ELSE
DONE.FLAG = UNAVAIL.SCHED
END
END ELSE IF STAT EQ LOGOFF.COMMAND OR STAT EQ ABORT.VRF THEN DONE.FLAG = STAT
WHILE NOT(STAT) AND (DONE.FLAG = ABORT.PRESENT OR DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED) DO
EXECUTE "SLEEP ":CW.MAX
IF NOT(TRANS.SLEEP.CN) THEN
IF EL.TRACE THEN
EL.DATA = "SLEEP ":CW.MAX:" because ":DONE.FLAG:", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
END
TRANS.SLEEP.CN = TRANS.SLEEP.CN + ONE
IF TRANS.SLEEP.CN GE TEN THEN TRANS.SLEEP.CN = ZERO
REPEAT
TP.MAX = DCOUNT(TP,AM) - ONE
IF TP.MAX LE ONE THEN TP.MAX = ONE
ACCT.NAME = "#?#"
END
*      
TRANS.ALL.OK = TRUE
*
IF NOT(STAT) THEN
*
FROM.LIST = FALSE; LIST.CN = ZERO; LIST.SCAN = FALSE; SCAN.CONT = TRUE
*      
LOOP
*
*IF NOT(FROM.LIST) THEN TP.CN = ZERO
*
LOOP 
*# Increment item counter
IF NOT(FROM.LIST) THEN TP.CN = TP.CN + ONE
*      
IF NOT(SYSTEM(ELEVEN) LE 3) AND MAIN.FLAG EQ ENTRY THEN
IF TP.CN EQ ONE THEN
*PAGE
END
*ITEM
END
*
*# Are we finished yet?
IF MAIN.FLAG EQ ENTRY THEN
IF NOT(LEN(TP<TP.CN+ONE>)) THEN SCAN.CONT = FALSE
END ELSE IF MAIN.FLAG EQ MASTER THEN
IF NOT(TP<TP.CN+ONE,12>) THEN SCAN.CONT = FALSE
END ELSE SCAN.CONT = FALSE
*
WHILE NOT(FROM.LIST) AND TP.CN LE TP.MAX AND SCAN.CONT DO REPEAT
*
IF NOT(TP.CN.FOUND) AND TP.CN GT TP.MAX THEN GOTO RECV.TRANSFER.BYPASS
TP.CN.FOUND = TRUE
*
GOSUB COMM.ABORT.CHECK
IF NOT(STAT) THEN
GOSUB COMM.SCHED.CHECK
IF NOT(SCHED.OK) THEN DONE.FLAG = UNAVAIL.SCHED
END
*      
IF (NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED) OR TRANS.PORT.ON) AND MAIN.FLAG EQ MASTER OR MAIN.FLAG EQ SLAVE THEN
*      
*# Loop to transmit control parameters
LOOP
*
IF MAIN.FLAG EQ MASTER THEN
*      
*# Load System name
IF TP<TP.CN+ONE,9,ONE> NE EMPTY THEN
COMM.SYS.NAME = TP<TP.CN+ONE,9,ONE>
END
IF COMM.SYS.NAME EQ EMPTY THEN COMM.SYS.NAME = "PICKTR"
 IN.FILE.NAME = TP<TP.CN+ONE,ONE>
OUT.FILE.NAME = TP<TP.CN+ONE,TWO>
 IN.ITEM.NAME = TP<TP.CN+ONE,3>
OUT.ITEM.NAME = TP<TP.CN+ONE,4>
     OPTIONS  = TP<TP.CN+ONE,5>
     DIR.FLAG = TP<TP.CN+ONE,6>
     ITEM = EMPTY
*      
IF NUM(DIR.FLAG) THEN
IF NOT(DIR.FLAG) AND LEN(DIR.FLAG) THEN
DIR.FLAG = DIN
END ELSE
DIR.FLAG = DOUT
END
END ELSE IF DIR.FLAG NE DIN AND DIR.FLAG NE DOUT THEN
DIR.FLAG = DOUT
END
*      
    LIST.NAME = TP<TP.CN+ONE,7>
*      
*# Perform port initialization if needed
*# On a SCRIPT acct.name will be reset to force initialization
*      
IF ((ACCT.NAME NE TP<TP.CN+ONE,8,ONE> AND TP<TP.CN+ONE,8,ONE> NE EMPTY) OR (TP.CN EQ ONE AND NOT(FROM.LIST)) OR COMM.SYS.NAME NE SYS.NAME) AND TP.CN LE TP.MAX THEN
*
*# Set Account name
    ACCT.NAME = TP<TP.CN+ONE,8>
    ACCT.PASS = EMPTY
IF ACCT.NAME EQ EMPTY THEN
    ACCT.NAME = WHO
    ACCT.NAME = FIELD(ACCT.NAME," ",TWO)
    ACCT.PASS = "AXION"
END
IF ACCT.NAME<ONE,ONE,TWO> NE EMPTY THEN
    ACCT.PASS = ACCT.NAME<ONE,ONE,TWO>
    ACCT.NAME = ACCT.NAME<ONE,ONE,ONE>
END
*
*# Set System name
SYS.NAME = COMM.SYS.NAME
*      
*# Perform end of processing script if needed
*
*# Account close script
CW.ERROR = EMPTY
CW.KEY   = "PICK.TRANSFER@SCRIPT@":SYS.NAME:"@":ACCT.NAME:"@DONE"
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
IF EL.TRACE THEN
EL.DATA = "Account close script ":SYS.NAME:" ":ACCT.NAME:", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
*# System close script
CW.ERROR = EMPTY
CW.KEY   = "PICK.TRANSFER@SCRIPT@":SYS.NAME:"@DONE"
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
IF EL.TRACE THEN
EL.DATA = "System close script ":SYS.NAME:", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*      
*# Wait for line to go quiet
CW.ERROR = EMPTY
CW.KEY   = EMPTY
TEMP = CW.QUIET * 2
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,TEMP,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
*
TRANS.PORT.ON = FALSE
*
*# Perform port initialization if needed
*
*# Load system comm parameters
SYS.NAME.SUFFIX = "@SYSTEM@":SYS.NAME
GOSUB COMM.PARAM.LOAD
*
*# Wait for line to go quiet
CW.ERROR = EMPTY
CW.KEY   = EMPTY
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
*      
IF NOT(STAT OR DONE.FLAG) THEN
*
*# Perform script file processing
*
*# System startup script
CW.ERROR = EMPTY
CW.KEY   = "PICK.TRANSFER@SCRIPT@":SYS.NAME
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
IF EL.TRACE THEN
EL.DATA = "System startup script ":SYS.NAME:", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*      
*# Logon the account now
TEMP = AM:CR:ACCT.NAME
IF ACCT.PASS NE EMPTY THEN TEMP = TEMP:CR:ACCT.PASS
CW.KEY = "PICK.TRANSFER@SCRIPT@TEMP@":PORT
WRITE TEMP ON PAR.FILE, CW.KEY
CW.ERROR = EMPTY
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF EL.TRACE THEN
EL.DATA = "Account Logon ":ACCT.NAME:" ":ACCT.PASS:", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
*# Perform script file processing
*# Account startup script
CW.ERROR = EMPTY
CW.KEY   = "PICK.TRANSFER@SCRIPT@":SYS.NAME:"@":ACCT.NAME
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
IF EL.TRACE THEN
EL.DATA = "Account startup script ":SYS.NAME:" ":ACCT.NAME:", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*      
COMM.INIT = FALSE
TRANS.PORT.ON = TRUE
*
END; *# of initialize if no error
*
END; *# of initialize or new account
*      
     FILE.OPT = TP<TP.CN+ONE,9,TWO>
     DICT.MOD = TP<TP.CN+ONE,9,3>
     DICT.SEP = TP<TP.CN+ONE,9,4>
     FILE.MOD = TP<TP.CN+ONE,9,5>
     FILE.SEP = TP<TP.CN+ONE,9,6>
     DICT.BASE = ZERO; FILE.BASE = ZERO
*
  LIST.SOURCE = TP<TP.CN+ONE,TEN>
    ITEM.DATE = TP<TP.CN+ONE,ELEVEN,ONE>
    LIST.SCAN = FIELD(ITEM.DATE,"*",8)
    IF NOT(NUM(LIST.SCAN)) THEN LIST.SCAN = TRUE
    IF NOT(LIST.SCAN) THEN LIST.SCAN = TRUE
    ITEM.SENT = TP<TP.CN+ONE,12>
END; *# of MASTER
*
IF NOT(COMM.ERROR OR STAT) AND NOT(COMM.INIT) AND MAIN.FLAG NE ENTRY THEN
*
IF NOT(COMM.SYNC) THEN
COMM.STARTUP = TRUE
END ELSE
COMM.STARTUP = FALSE
*CALL PICKTR.COMM.SYNC(COMM.STARTUP,"SYNC",STAT)
END; *# of COMM.SYNC
IF NOT(COMM.INIT) THEN COMM.INIT = TRUE 
*
END; *# of ne ENTRY
*      
IF EL.TRACE THEN
EL.DATA = ("Step ":TP.CN:" of ":TP.MAX:" started, ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:" ":STR("*",70)) "L#70"
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
IF MAIN.FLAG EQ MASTER AND NOT(FROM.LIST) THEN
*
ITEM<-ONE> = COMMAND:"INIT"
*      
IF DONE.FLAG OR (TP.CN GT TP.MAX AND MAIN.FLAG EQ MASTER) THEN
ITEM = ITEM:AM:COMMAND:"DONE"
DONE.FLAG = SHUTDOWN.DONE
END ELSE
IF STAT THEN
ITEM = ITEM:AM:COMMAND:"ERROR?":STAT
END
*
ITEM.TYPE = ONE 
ITEM = ITEM:AM:COMMAND:"ITEM.TYPE"
ITEM = ITEM:AM:ITEM.TYPE
*
ITEM = ITEM:AM:COMMAND:"TDIR"
IF DIR.FLAG EQ DIN THEN
ITEM = ITEM:AM:DOUT
END ELSE
ITEM = ITEM:AM:DIN
END
*      
ITEM = ITEM:AM:COMMAND:"FNAM"
ITEM = ITEM:AM:OUT.FILE.NAME
ITEM = ITEM:AM:IN.FILE.NAME
*      
ITEM = ITEM:AM:COMMAND:"INAM"
ITEM = ITEM:AM:OUT.ITEM.NAME
ITEM = ITEM:AM:OUT.ITEM.NAME
*      
ITEM = ITEM:AM:COMMAND:"OPTN"
ITEM = ITEM:AM:OPTIONS
*
ITEM = ITEM:AM:COMMAND:"LIST.CN"
ITEM = ITEM:AM:LIST.CN
*
ITEM = ITEM:AM:COMMAND:"LIST.SCAN"
ITEM = ITEM:AM:LIST.SCAN
*
ITEM = ITEM:AM:COMMAND:"SRCE"
TEMP = ABS(LIST.SOURCE-ONE)
ITEM = ITEM:AM:TEMP
*      
ITEM = ITEM:AM:COMMAND:"LIST"
ITEM = ITEM:AM:LIST.NAME
IF NOT(LEN(LIST.NAME)) THEN LIST.FLAG = FALSE; FROM.LIST = FALSE; LIST.SCAN = FALSE ELSE
LIST.FLAG = TRUE 
IF LIST.SOURCE THEN
IF NOT(FROM.LIST) THEN
SEL.EXEC = ONE
LIST.CN = ZERO; LIST.ERROR.CN = ZERO
END ELSE SEL.EXEC = FALSE
END ELSE SEL.EXEC = -ONE
FROM.LIST = TRUE 
END; *# of LEN(LIST.NAME)
*      
ITEM = ITEM:AM:COMMAND:"ACCT"
ITEM = ITEM:AM:ACCT.NAME
*      
ITEM = ITEM:AM:COMMAND:"SYST"
ITEM = ITEM:AM:SYS.NAME:"#":FILE.OPT:"#":DICT.MOD:"#":DICT.SEP:"#":FILE.MOD:"#":FILE.SEP
*      
ITEM = ITEM:AM:COMMAND:"TP.MAX"
ITEM = ITEM:AM:TP.MAX
*
ITEM = ITEM:AM:COMMAND:"ERR.CN"
ITEM = ITEM:AM:ERR.CN
*
END; *# of not(DONE)
*
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
INIT.FLAG = TRUE; CDIR.FLAG = TRUE; FILE.FLAG = TRUE; ITEM.FLAG = TRUE 
OPTN.FLAG = TRUE; ACCT.FLAG = TRUE; SYST.FLAG = TRUE
SRCE.FLAG = TRUE
*      
IF EL.TRACE THEN
EL.DATA = ("Outgoing Header Transmission":", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:" ":STR("*",70)) "L#70"
EL.DATA<-ONE> = SYS.NAME:", ":ACCT.NAME:" >>> ":IN.FILE.NAME:" ":IN.ITEM.NAME
EL.DATA<-ONE> = "*** Header Contents ***":AM:ITEM:AM:"*** *** *** *** ***"
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DOUT,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,ERR.LEVEL,CW.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.REPEAT.HI,ERR.CONSEC.HI,ERR.OUT.OFFSET,ERR.IN.OFFSET,CHOKE.MODE,PREV.CHK.ID,HEX.MODE,BLOCK.MODE,STAT.RECVD,USER.ID,APPL,ERR.CN.LAST.HI,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,SYS.NAME.SUFFIX,FILTER.IN.STR,FILTER.OUT.STR)
*
*#  MAIN.FLAG = SLAVE
*      
END ELSE IF MAIN.FLAG EQ SLAVE AND NOT(FROM.LIST) THEN
*      
INIT.FLAG = FALSE; CDIR.FLAG = FALSE; FILE.FLAG = FALSE; ITEM.FLAG = FALSE
OPTN.FLAG = FALSE; LIST.FLAG = FALSE; ACCT.FLAG = FALSE; SYST.FLAG = FALSE
SRCE.FLAG = FALSE; ITEM = EMPTY
*      
MD.FILE.NAME = "MD"; DICT.NAME = EMPTY; DICT.BASE = ZERO; DICT.MOD = ZERO; DICT.SEP = ZERO; FILE.MOD = ZERO; FILE.SEP = ZERO; FILE.OPT = "MC,S,?,QC"; FILE.NAME = EMPTY; FILE.BASE = ZERO; STAT = ZERO; PROG.DEBUG = FALSE
*
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
ITEM.TYPE = ONE 
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIN,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,ERR.LEVEL,CW.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.REPEAT.HI,ERR.CONSEC.HI,ERR.OUT.OFFSET,ERR.IN.OFFSET,CHOKE.MODE,PREV.CHK.ID,HEX.MODE,BLOCK.MODE,STAT.RECVD,USER.ID,APPL,ERR.CN.LAST.HI,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,SYS.NAME.SUFFIX,FILTER.IN.STR,FILTER.OUT.STR)
IF EL.TRACE THEN
EL.DATA = ("Incoming Header Transmission":", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:" ":STR("*",70)) "L#70"
EL.DATA<-ONE> = "*** Header Contents ***":AM:ITEM:AM:"*** *** *** *** ***"
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*      
CNTR.FLAG = TRUE 
GOSUB COMMAND.PROCESS
*      
END; *# of MAIN.FLAG EQ SLAVE
*
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
*      
IF FROM.LIST THEN
*
IF SEL.EXEC GT ZERO AND NOT(STAT) THEN
*
IF LIST.NAME EQ "*" OR LIST.NAME EQ "ALL" THEN
IF DIR.FLAG = DIN THEN TEMP = OUT.FILE.NAME ELSE TEMP = IN.FILE.NAME
EXEC.VERB = "SSELECT ":TEMP
END ELSE IF LIST.NAME[ONE,ONE] EQ "." THEN
EXEC.VERB = LIST.NAME[TWO,HI.NUM]
END ELSE
EXEC.VERB = "GET-LIST ":LIST.NAME
END
*
IF EL.TRACE THEN
EL.DATA = ("Select execute: ":EXEC.VERB:", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:" ":STR("*",70)) "L#70"
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
EXECUTE EXEC.VERB, //OUT. > EL.DATA
*
LOOP WHILE LEN(EL.DATA) AND NOT(LEN(EL.DATA<ONE>)) DO
DEL EL.DATA<ONE>
REPEAT
CP<20> = EL.DATA<ONE>
IF EL.TRACE THEN
EL.DATA = "*** Select terminal output *** ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:AM:EL.DATA:AM:"*** *** *** *** ***"
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
END ELSE IF SEL.EXEC LT ZERO AND NOT(STAT) THEN
*
START.SYS11 = SYSTEM(ELEVEN); END.SYS11 = START.SYS11
START.SEL.TIME = TIME(); END.SEL.TIME = START.SEL.TIME
RQM; RQM; RQM
*
FOR A = 1 TO HI.NUM UNTIL END.SYS11 GT START.SYS11 OR END.SEL.TIME-3600 GT START.SEL.TIME
EXECUTE "SLEEP ":CW.PAUSE
END.SYS11 = SYSTEM(ELEVEN); END.SEL.TIME = TIME()
IF END.SEL.TIME LT START.SEL.TIME THEN END.SEL.TIME = END.SEL.TIME + 86400
NEXT A
*
IF EL.TRACE THEN
EL.DATA = "Select wait for ":LIST.NAME:" from ":OCONV(START.SEL.TIME,"MTS"):" to ":OCONV(END.SEL.TIME,"MTS"):", ":OCONV(DATE(),"D2"):" on ":WHO
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
END; * of SEL.EXEC
*
SEL.EXEC = ZERO
*      
ITEM = EMPTY
LIST.CN = LIST.CN + ONE 
*      
IF LIST.SOURCE THEN
*      
ITEM.TYPE = TWO
*
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERR.ABORT.VRF
IF STAT THEN
ITEM<-ONE> = COMMAND:"ERROR?":STAT
END
*
ITEM<-ONE> = COMMAND:"ITEM.TYPE"
ITEM = ITEM:AM:ITEM.TYPE
*
LOOP
READNEXT ID ELSE
FROM.LIST = FALSE
ID = EMPTY
ITEM = ITEM:AM:COMMAND:"END.LIST"
END
UNTIL NOT(FROM.LIST) OR LIST.CN GE LIST.SCAN DO LIST.CN = LIST.CN + ONE REPEAT
*      
IF FROM.LIST THEN
IN.ITEM.NAME = ID; OUT.ITEM.NAME = ID
ITEM = ITEM:AM:COMMAND:"INAM"
ITEM = ITEM:AM:IN.ITEM.NAME
ITEM = ITEM:AM:OUT.ITEM.NAME
END
*      
ITEM = ITEM:AM:COMMAND:"LIST.CN"
ITEM = ITEM:AM:LIST.CN
*
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
IF EL.TRACE THEN
EL.DATA = ("Outgoing List Item Transmission":", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:" ":STR("*",70)) "L#70"
EL.DATA<-ONE> = "File: ":IN.FILE.NAME:"/":OUT.FILE.NAME:". List: ":LIST.NAME:" ":LIST.SOURCE:". Lines: ":MAX:", Size: ":ISIZE
EL.DATA<-ONE> = "*** List Item Contents ***":AM:ITEM:AM:"*** *** *** *** ***"
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DOUT,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,ERR.LEVEL,CW.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.REPEAT.HI,ERR.CONSEC.HI,ERR.OUT.OFFSET,ERR.IN.OFFSET,CHOKE.MODE,PREV.CHK.ID,HEX.MODE,BLOCK.MODE,STAT.RECVD,USER.ID,APPL,ERR.CN.LAST.HI,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,SYS.NAME.SUFFIX,FILTER.IN.STR,FILTER.OUT.STR)
IF STAT AND STAT NE LIST.FINISHED THEN TRANS.ALL.OK = FALSE
*      
END ELSE
*      
CN = ZERO; MAX = HI.NUM; ITEM.TYPE = TWO; ISIZE = HI.NUM
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIN,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,ERR.LEVEL,CW.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.REPEAT.HI,ERR.CONSEC.HI,ERR.OUT.OFFSET,ERR.IN.OFFSET,CHOKE.MODE,PREV.CHK.ID,HEX.MODE,BLOCK.MODE,STAT.RECVD,USER.ID,APPL,ERR.CN.LAST.HI,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,SYS.NAME.SUFFIX,FILTER.IN.STR,FILTER.OUT.STR)
IF STAT AND STAT NE LIST.FINISHED THEN TRANS.ALL.OK = FALSE
IF EL.TRACE THEN
EL.DATA = "Incoming List Item Transmission":", ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO
EL.DATA<-ONE> = "*** List Item Contents ***":AM:ITEM:AM:"*** *** *** *** ***"
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*      
CNTR.FLAG = TRUE 
GOSUB COMMAND.PROCESS
*      
END; *# of LIST.SOURCE
*      
IF NOT(FROM.LIST) THEN STAT = LIST.FINISHED; LIST.CN = LIST.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
*
END; *# of FROM.LIST
*      
*# Loopback for parameter input
WHILE NOT(DONE.FLAG OR STAT) AND NOT(INIT.FLAG AND CDIR.FLAG AND (ITEM.FLAG OR LIST.FLAG OR FROM.LIST) AND FILE.FLAG AND OPTN.FLAG) DO REPEAT
*      
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
END; *# of MAIN.FLAG EQ MASTER OR SLAVE
*      
IF MAIN.FLAG EQ ENTRY THEN
CALL PICKTR.DETAIL.SUB(ERR.LOW,ERR.CN,MAIN.FLAG,DONE.FLAG,LIST.NAME,LIST.SOURCE,IN.ITEM.NAME,OUT.ITEM.NAME,IN.FILE.NAME,OUT.FILE.NAME,CN,MAX,ISIZE,HOST.DETECT,OPTIONS,FILE.LIST,DIR.FLAG,FILE.OPT,DICT.BASE,DICT.MOD,DICT.SEP,FILE.BASE,FILE.MOD,FILE.SEP,ACCT.NAME,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
IF HOST.DETECT THEN GOTO RECV.TRANSFER
END
*      
IF NOT(COMM.ERROR OR DONE.FLAG OR STAT) THEN
*      
IF MAIN.FLAG NE ENTRY THEN
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
*      
IF DIR.FLAG EQ DOUT THEN
FILE.NAME = IN.FILE.NAME
ITEM.NAME = IN.ITEM.NAME
END ELSE
*      
*#  DIR.FLAG EQ DIN
FILE.NAME = OUT.FILE.NAME
ITEM.NAME = OUT.ITEM.NAME
END
*
ITEM = EMPTY
*      
IF NOT(STAT) THEN
*
IF NOT(FILE.MOD OR DICT.MOD OR DICT.BASE OR FILE.BASE) OR DIR.FLAG EQ DIN THEN
CFILE.NAME = FILE.NAME
*
MD.FILE.NAME = "MD"; DICT.NAME = CFILE.NAME
*
CALL SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,FILE.OPT,CFILE.NAME,FILE.BASE,STAT,PROG.DEBUG,ACCT.NAME,MAIN.FLAG,EL.DATA,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
IF EL.TRACE AND LEN(EL.DATA) THEN
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*
END
*
OPEN FILE.NAME TO TRF.FILE ELSE
ITEM = ITEM:AM:COMMAND:"ERROR?":FILE.NAME:" file missing?"
STAT = TWO
END
*      
IF NOT(STAT) THEN
*
READ ITEM FROM TRF.FILE,ITEM.NAME THEN
ITEM.ON.FILE = TRUE; ITEM.A1 = ITEM<ONE>; IF LEN(ITEM.A1) EQ TWO THEN ITEM.A1 = ITEM.A1[ONE,ONE]
END ELSE
ITEM = ITEM:AM:COMMAND:"ERROR?":ITEM.NAME:" item missing!"
ITEM.ON.FILE = FALSE; ITEM.A1 = EMPTY
END
*
END ELSE
ITEM = ITEM:AM:COMMAND:"ERROR?":ITEM.NAME:" was not read from ":FILE.NAME:"!"
ITEM.ON.FILE = FALSE; ITEM.A1 = EMPTY
END
*
IF DIR.FLAG EQ DOUT THEN
*
IF NOT(ITEM.ON.FILE) THEN STAT = ITEM.MISSING ELSE
IF ITEM.A1 EQ "Q" OR ITEM.A1 EQ "D" THEN 
STAT = FPOINTER.TR.ERROR
ITEM<ONE> = "**":ITEM<ONE>:"**"
END
END
CN = ZERO; MAX = DCOUNT(ITEM,AM); ISIZE = LEN(ITEM)
*
END ELSE
IF ITEM.ON.FILE THEN
IF ITEM.A1 EQ "Q" OR ITEM.A1 EQ "D" THEN STAT = FPOINTER.OV.ERROR
IF NOT(INDEX(OPTIONS,"O",ONE)) THEN STAT = ITEM.OV.ERROR
IF INDEX(OPTIONS,"N",ONE) THEN STAT = ITEM.NEW.ERROR
END ELSE
IF INDEX(OPTIONS,"E",ONE) THEN STAT = ITEM.OV.RQRD.ERROR
END
CN = ZERO; MAX = HI.NUM; ISIZE = HI.NUM; ITEM = EMPTY
END; *# OF DIR.FLAG
*
IF EL.TRACE THEN
EL.DATA = "Start DATA ":DIR.FLAG:" by ":MAIN.FLAG:",  Date ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:" Status ":STAT
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
ITEM.TYPE = 3
CALL PICK.TRANSFER.SUB(PAR.FILE,ITEM,ITEM.TYPE,MAIN.FLAG,DIR.FLAG,STAT,ACK.RSP,LINE.MAX.LEN,ERR.CN,ERR.CN.TOTAL,ERR.MAX,ERR.CN.ALL,ERR.MAX.ALL,CN,MAX,ISIZE,ERR.CN.ARRAY,ERR.LEVEL,CW.MAX,AM.MAX,ERR.LOW,ERR.HI,ERR.REPEAT.HI,ERR.CONSEC.HI,ERR.OUT.OFFSET,ERR.IN.OFFSET,CHOKE.MODE,PREV.CHK.ID,HEX.MODE,BLOCK.MODE,STAT.RECVD,USER.ID,APPL,ERR.CN.LAST.HI,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,SYS.NAME.SUFFIX,FILTER.IN.STR,FILTER.OUT.STR)
IF EL.TRACE THEN
EL.DATA = "End DATA ":DIR.FLAG:" by ":MAIN.FLAG:", Stat:":STAT:", Date ":OCONV(DATE(),"D2"):" at ":OCONV(TIME(),"MTS"):" on ":WHO:" Status ":STAT:AM:"!!!":AM:AM
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
END
*      
*#  DIR.FLAG EQ DIN
IF DIR.FLAG EQ DIN AND NOT(STAT) THEN
*
IF ITEM[ONE,LEN(COMMAND)] EQ COMMAND THEN CNTR.FLAG = FALSE; GOSUB COMMAND.PROCESS
*
IF INDEX(OPTIONS,"A",ONE) THEN
READ TMP FROM TRF.FILE,ITEM.NAME ELSE TMP = EMPTY
IF LEN(TMP) + LEN(ITEM) GT 32250 THEN STAT = MAX.ITEM.SIZE ELSE ITEM = TMP:AM:ITEM
TMP = EMPTY
END; *# of "A"
*
ITEM.A1 = ITEM<ONE>; IF LEN(ITEM.A1) EQ TWO THEN ITEM.A1 = ITEM.A1[ONE,ONE]
IF ITEM.A1 EQ "Q" OR ITEM.A1 EQ "D" THEN 
STAT = FPOINTER.TR.ERROR
ITEM<ONE> = "**":ITEM<ONE>:"**"
END
*
IF NOT(STAT) OR STAT EQ FPOINTER.TR.ERROR THEN 
WRITE ITEM ON TRF.FILE,ITEM.NAME
END
*
* DIR EQ DOUT
END ELSE IF DIR.FLAG EQ DOUT AND NOT(STAT) THEN
IF INDEX(OPTIONS,"D",ONE) THEN DELETE TRF.FILE,ITEM.NAME
END; *# of DIR DIN DOUT
END; *# of not(STAT)
*
END; *# of ne ENTRY
*
END; *# of not finished or error
*      
IF TP.CN LE TP.MAX AND NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED OR DONE.FLAG EQ SHUTDOWN.DONE OR DONE.FLAG EQ ENTRY.DONE) THEN
*
IF NOT(FROM.LIST) OR LIST.CN EQ ONE OR STAT THEN TP<TP.CN+ONE,ELEVEN> = SVM:TP<TP.CN+ONE,ELEVEN>
TP<TP.CN+ONE,ELEVEN,ONE> = DATE():"*":OCONV(TIME(),"MTS"):"*":WHO:"*":COMM.ERROR:"*":STAT:"*":CN:"*":MAX:"*":LIST.CN:"*":ISIZE:"*":DONE.FLAG
*
IF MAIN.FLAG NE ENTRY THEN
*
IF (NOT(STAT) OR STAT EQ LIST.FINISHED) THEN
*
IF NOT(FROM.LIST) THEN TP<TP.CN+ONE,12> = ONE
TRANS.ALL.NOT.OK.CN = ZERO; TRANS.SENT.ONE = TRUE; LIST.ERROR.CN = ZERO
*
END ELSE
*
IF STAT GE 20 AND STAT LT 30 THEN
*
LIST.ERROR.CN = LIST.ERROR.CN + ONE
IF LIST.ERROR.CN GT ERR.CONSEC.HI THEN
TRANS.ALL.NOT.OK.CN = TRANS.ALL.NOT.OK.CN + ONE
LIST.ERROR.CN = ZERO; *LIST.SCAN = HI.NUM
IF TRANS.SENT.ONE THEN TP<TP.CN+ONE,13> = TP<TP.CN+ONE,13> + ONE
END
*
END ELSE
*
TRANS.ALL.NOT.OK.CN = TRANS.ALL.NOT.OK.CN + ONE; LIST.ERROR.CN = ZERO
*
END
*
TRANS.ALL.OK = FALSE
IF TRANS.ALL.NOT.OK.CN EQ ONE THEN TP<TP.CN+ONE,13> = TP<TP.CN+ONE,13> + ONE
*
IF TRANS.ALL.NOT.OK.CN GT ERR.ITEM.RETRY THEN
FKEY.ID = "TRANSFER.ABORT@PORT@":PORT
WRITE "PORT DOWN ON MAX CONSECUTIVE ERRORS ( ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS"):" )" ON PAR.FILE,FKEY.ID
END
*
IF TP<TP.CN+ONE,13> GE ERR.ITEM.RETRY THEN
TP<TP.CN+ONE,12> = 99; LIST.SCAN = HI.NUM
END ELSE
TP<TP.CN+ONE,12> = ZERO
END; *# of set mv 12 if # of errors exceeded
*
END; *# of NOT(STAT) / STAT
*
* ENTRY
END ELSE
TRANS.ALL.OK = FALSE
TP<TP.CN+ONE,12> = ZERO
TP<TP.CN+ONE,13> = TP<TP.CN+ONE,13> + ZERO
END
*
END; *# of trans.cn le trans.max
*
IF NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED) THEN
*      
IF STAT EQ UNAVAIL.SCHED THEN DONE.FLAG = STAT; STAT = FALSE
*
IF STAT EQ MAX.ERR.ABORT.VRF THEN COMM.ERROR = STAT
IF STAT EQ COMM.ERROR.STAT THEN COMM.ERROR = STAT
*
IF LEN(TP) GT 31500 THEN STAT = MAX.ITEM.SIZE
*      
IF (MAIN.FLAG EQ ENTRY OR MAIN.FLAG EQ SLAVE) AND DONE.FLAG NE ENTRY.DONE THEN
IF TP.MAX LT TP.CN THEN TP.MAX = TP.CN
$INCLUDE IBP SYS.INCL.PICKTR.JOB.LOAD
END; *# of SLAVE or ENTER
*
IF TP.CN LE TP.MAX AND MAIN.FLAG NE ENTRY AND DONE.FLAG NE SHUTDOWN.DONE THEN
WRITEV TP<TP.CN+ONE> ON PAR.FILE,"PICK.TRANSFER":TRANS.PORT,TP.CN+ONE
CP<5> = ERR.CN
CP<9> = ERR.CN.ALL
CP<TEN> = ERR.CN.TOTAL + ERR.CN.ALL
CP<12> = DATE():SVM:OCONV(TIME(),"MTS"):SVM:WHO:SVM:COMM.ERROR:SVM:STAT.RECVD:SVM:STAT:SVM:TP.CN:SVM:TP.MAX:SVM:DONE.FLAG:SVM:COMM.INIT:SVM:COMM.STARTUP:SVM:COMM.SHUTDOWN:SVM:ACK.RSP<ONE,ONE,ONE>:SVM:OUT.FILE.NAME:SVM:OUT.ITEM.NAME:SVM:LIST.NAME:SVM:LIST.CN:SVM:LIST.ERROR.CN
CP<15> = TP<TP.CN+ONE>
*
CP<20> = ERR.CN.ARRAY
TEMP.MAX = DCOUNT(ERR.CN.ARRAY,VM)
FOR TEMP.CN = ONE TO TEMP.MAX
CP<17,TEMP.CN> = CP<17,TEMP.CN> + ERR.CN.ARRAY<ONE,TEMP.CN>
ERR.CN.ARRAY<ONE,TEMP.CN> = ZERO
NEXT TEMP.CN
ERR.CN.HISTORY = CP<17>
*
CP<28> = ERR.LEVEL
FOR TEMP.CN1 = ONE TO TWO
TEMP.MAX = DCOUNT(ERR.LEVEL<1,TEMP.CN1>,SVM)
FOR TEMP.CN = ONE TO TEMP.MAX
CP<27,TEMP.CN1,TEMP.CN> = CP<27,TEMP.CN1,TEMP.CN> + ERR.LEVEL<ONE,TEMP.CN1,TEMP.CN>
ERR.LEVEL<ONE,TEMP.CN1,TEMP.CN> = ZERO
NEXT TEMP.CN
NEXT TEMP.CN1
ERR.LEVEL.HISTORY = CP<27>
*
WRITE COMM.PARAM ON PAR.FILE,COMM.PARAM.KEY
END
*
**IF STAT EQ LIST.FINISHED OR (STAT GE 20 AND STAT LT 30) THEN STAT = FALSE; LIST.CN = ZERO; *# SKIP to next TP.CN
IF STAT EQ LIST.FINISHED     THEN STAT = FALSE; LIST.CN = ZERO
IF STAT GE 20 AND STAT LE 30 THEN
IF STAT GE 20 AND STAT LE 25 THEN STAT = FALSE; LIST.SCAN = HI.NUM
IF STAT GE 26 AND STAT LT 30 THEN
STAT = FALSE
END
*TP<TP.CN+ONE,ELEVEN> = SVM:TP<TP.CN+ONE,ELEVEN>
END
*      
END; *# of not finished yet
*      
WHILE NOT(COMM.ERROR OR DONE.FLAG OR STAT) DO REPEAT
END; *# of STAT upon program initalization
*      
IF (MAIN.FLAG EQ MASTER AND NOT(TRANS.ALL.OK)) OR MAIN.FLAG EQ ENTRY THEN
IF NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED OR DONE.FLAG EQ ABORT.PRESENT) OR MAIN.FLAG EQ ENTRY THEN
TRANS.SUF = "NEXT"
GOSUB PARAM.WRITE
END
END
*
IF MAIN.FLAG NE ENTRY THEN
*
IF NOT(COMM.ERROR OR STAT) THEN
IF NOT(COMM.SYNC) THEN
COMM.SHUTDOWN = ONE
END ELSE
COMM.SHUTDOWN = FALSE
*CALL PICKTR.COMM.SYNC(COMM.STARTUP,"STOP",STAT)
END; *# of COMM.SYNC
END; *# of not(COMM.ERROR OR STAT)
*
RECV.TRANSFER.BYPASS: *#
*
IF NOT(DONE.FLAG EQ NO.WORK OR DONE.FLAG EQ UNAVAIL.SCHED OR DONE.FLAG EQ ABORT.PRESENT) THEN
TRANS.SUF = "LAST"
GOSUB PARAM.WRITE
IF MAIN.FLAG EQ MASTER AND DONE.FLAG EQ SHUTDOWN.DONE THEN
DZERO.FLAG = FALSE; TP.CN = ONE
COMM.INIT = FALSE; COMM.ERROR = FALSE; COMM.STARTUP = FALSE; COMM.SHUTDOWN = EMPTY
END
*
IF MAIN.FLAG EQ MASTER THEN
OUT.ID = "PICK.TRANSFER":TRANS.PORT
*
DELETE PAR.FILE,OUT.ID
END
*
END
*
END; *# of MASTER / SLAVE or ENTER
*      
WHILE NOT(COMM.ERROR OR STAT) AND (MAIN.FLAG EQ MASTER AND DONE.FLAG NE ABORT.PRESENT) DO REPEAT
*
IF MAIN.FLAG NE ENTRY THEN
CW.ERROR = EMPTY
CW.KEY   = EMPTY
CALL SYS.COMM.WAIT.QUIET.SUB(PAR.FILE,CW.KEY,CW.QUIET,CW.MAX,CW.ERROR,CW.PAUSE,CW.CLEAR,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN,STAT)
IF CW.ERROR THEN STAT = WAIT.ERROR
INPUTCLEAR
END
*
ECHO ON
*      
*      
STOP
*      
COMM.ABORT.CHECK: *#
*
FSEARCH.PREFIX = "TRANSFER.ABORT"
$INCLUDE IBP SYS.INCL.FSEARCH.TOP
$INCLUDE IBP SYS.INCL.ABORT.CHECK.READ
$INCLUDE IBP SYS.INCL.FSEARCH.BOT
$INCLUDE IBP SYS.INCL.ABORT.CHECK
*
RETURN
*
COMM.SCHED.CHECK: *#
*
FSEARCH.PREFIX = "TRANSFER.SCHED"
$INCLUDE IBP SYS.INCL.FSEARCH.TOP
$INCLUDE IBP SYS.INCL.SCHED.CHECK.READ
$INCLUDE IBP SYS.INCL.FSEARCH.BOT
$INCLUDE IBP SYS.INCL.SCHED.CHECK
*
RETURN
*
COMM.PARAM.LOAD: *#
*
*# Read the port characteristics
SYS.NAME.SUFFIX = EMPTY
$INCLUDE IBP SYS.INCL.QUIET.READ
*
*# Load the port characteristics
*
ERR.CN = CP<5>
IF NOT(NUM(ERR.CN)) THEN ERR.CN = ZERO
IF NOT(ERR.CN) THEN ERR.CN = 3
$INCLUDE IBP SYS.INCL.QUIET.LOAD
*
LOOP WHILE ERR.CN GE ERR.MAX AND ERR.CN GT TEN DO ERR.CN = ERR.CN - TEN REPEAT
IF ERR.CN LT ERR.LOW THEN ERR.CN = ERR.LOW
IF ERR.CN - 5 GT ERR.LOW THEN ERR.CN = ERR.CN - 5
ERR.CN.ALL = CP<9>
ERR.CN.ALL = ZERO
ERR.CN.TOTAL = CP<TEN>
IF NOT(NUM(ERR.CN.TOTAL)) THEN ERR.CN.TOTAL = ZERO
IF NOT(NUM(ERR.CN.ALL)) THEN ERR.CN.ALL = ZERO
ERR.CN.HISTORY = CP<17>
ERR.CN.ARRAY = ""; * ERR.CN.ARRAY = CP<20>
ERR.LEVEL.HISTORY = CP<27>
ERR.LEVEL = ""; * ERR.LEVEL = CP<28>
*
EL.TRACE  = CP<21>
IF EL.TRACE GE 100 THEN EL.TRACE.ERROR = TRUE; EL.TRACE = EL.TRACE - 100 ELSE EL.TRACE.ERROR = FALSE
IF EL.TRACE GE 20 AND EL.TRACE LE 29 THEN EL.TRACE.OUT = TRUE; EL.TRACE = EL.TRACE - 20 ELSE EL.TRACE.OUT = FALSE
*
ERR.ITEM.RETRY = CP<22>
IF NOT(ERR.ITEM.RETRY) THEN ERR.ITEM.RETRY = 3
ERR.CN.LAST.HI = CP<23>
IF NOT(ERR.CN.LAST.HI) THEN ERR.CN.LAST.HI = 5
HEX.MODE = CP<24>
ERR.REPEAT.HI = CP<25>; IF NOT(ERR.REPEAT.HI) THEN ERR.REPEAT.HI = 3
ERR.CONSEC.HI = CP<26>; IF NOT(ERR.CONSEC.HI) THEN ERR.CONSEC.HI = 5
*      
RETURN
*
PACKET.ERROR.RECVD: *#
*
RETURN
*
COMMAND.PROCESS: *# Subroutine to parse control parameters
*      
$INCLUDE IBP SYS.INCL.PICKTR.COMMANDS
*
RETURN
*
PARAM.READ: *# Subroutine to read in next control parameters
*
DONE.FLAG = FALSE
TRANS.DELETE = FALSE
OUT.ID = "PICK.TRANSFER":TRANS.PORT
TRANS.NUMBER = TRANS.NUMBER + ONE
ERR.FL = EMPTY
*
NEXT.CN = ZERO; CONT = TRUE; TRANS.FIRST = FALSE; INC = ONE
LOOP
*
IF TRANS.DELETE THEN
DELETE PAR.FILE,OUT.ID
TRANS.DELETE = FALSE
END
*
IF NOT(DONE.FLAG) THEN
OUT.ID = "PICK.TRANSFER":TRANS.PORT
READ TRANS.PARAM FROM PAR.FILE,OUT.ID THEN
DONE.FLAG   = FALSE
TRANS.FIRST = FALSE
*FROM.LIST   = FALSE
TP.CN    = ZERO
TP.MAX = DCOUNT(TP,AM) - ONE
IF TP.MAX LT ONE THEN TP.MAX = ONE
CONT = FALSE
END ELSE DONE.FLAG = SCAN.FOR.WORK
END
*
IF DONE.FLAG EQ SCAN.FOR.WORK THEN
*
NEXT.CN = NEXT.CN + INC
IN.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":NEXT.CN
IF NEXT.CN EQ ONE THEN
OUT.ID = "PICK.TRANSFER":TRANS.PORT
END ELSE
OUT.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":NEXT.CN - TRUE
END
*
READ NEXT.PARAM FROM PAR.FILE,IN.ID THEN
WRITE NEXT.PARAM ON PAR.FILE,OUT.ID
END ELSE
*
IF NEXT.CN EQ ONE THEN
DONE.FLAG = NO.WORK
TP = EMPTY
TP.CN = ONE
END ELSE
TRANS.DELETE = TRUE
DONE.FLAG = FALSE
END
*
END
*
END ELSE CONT = FALSE
*
WHILE CONT DO REPEAT
*
RETURN
*
PARAM.WRITE: *# Subroutine to write in next control parameters
*
IF TRANS.SUF = "LAST" THEN OUT.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":ONE ELSE
OUT.ID = "PICK.TRANSFER":TRANS.PORT
END
ERR.FL = FALSE
*
READ NEXT.PARAM FROM PAR.FILE,OUT.ID THEN
NEXT.CN = ZERO; CONT = TRUE; INC = ONE; TRANS.FIRST = FALSE
LOOP
IF INC GT 100000 THEN ERR.FL = TRUE; CONT = FALSE
NEXT.CN = NEXT.CN + INC
OUT.ID = "PICK.TRANSFER":TRANS.PORT:"@":TRANS.SUF:"@":NEXT.CN
READ NEXT.PARAM FROM PAR.FILE,OUT.ID THEN
IF NOT(TRANS.FIRST) THEN
INC = INC * TWO
END ELSE IF INC GE TWO THEN
INC = INT(INC / TWO)
END
END ELSE
*# not on file
TRANS.FIRST = TRUE
IF INC EQ ONE THEN
CONT = FALSE
END ELSE
NEXT.CN = NEXT.CN - INC
INC = INT(INC / TWO)
END
END; *# of not on file
WHILE CONT DO REPEAT
END
IF NOT(ERR.FL) THEN
WRITE TRANS.PARAM ON PAR.FILE,OUT.ID
IF TRANS.SUF EQ "NEXT" THEN
CP<13> = OUT.ID:VM:TRANS.NUMBER:VM:DATE():VM:OCONV(TIME(),"MTS"):VM:WHO:VM:OUT.FILE.NAME:VM:OUT.ITEM.NAME:VM:LIST.NAME:VM:STAT.RECVD:VM:STAT
END ELSE
CP<14> = OUT.ID:VM:TRANS.NUMBER:VM:DATE():VM:OCONV(TIME(),"MTS"):VM:WHO:VM:OUT.FILE.NAME:VM:OUT.ITEM.NAME:VM:LIST.NAME:VM:STAT.RECVD:VM:STAT
END
END
*
RETURN
*      
END
~STANDARD.FUNCTIONS.CHARACTERS~
*CODE.SEGMENT: STANDARD.FUNCTIONS.CHARACTERS
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: JUN 85
* Used with permission 1986, 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
* (c) Copyright 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990
* Axion Computer Software Ltd.
*
STB = "|"
STX = "~"
ESC = "`"
PICK.ESC = "<PCK>"
NUL = CHAR(0)
*
!
STANDARD.FUNCTIONS: *
*
EQUATE BELL TO CHAR(7),LF TO CHAR(10),FF TO CHAR(12),CR TO CHAR(13)
*ESC TO CHAR(27), PICK.ESC TO CHAR(??),NUL TO CHAR(0)
*STB TO "|", STX TO CHAR(2), ETX TO CHAR(3)
*
* SUB-VALUE MARK, VALUE MARK, ATTRIBUTE MARK
*FIELD ATTR MARK, FIELD VALUE MARK, FIELD SUB-VALUE MARK
*KEY SEPARATOR, FIELD SEPARATOR
EQUATE SVM TO CHAR(252),VM TO CHAR(253),AM TO CHAR(254),
FAM TO "@",FVM TO "*",FSVM TO "#",
KSEP TO "@",DSEP TO "*"
*
EQUATE TRUE TO 1, FALSE TO ""
*
WHO = ICONV(0,"U50BB"); PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2); OPSYS = "U"
GENERIC = ""; CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
T132.ON = ""; T132.OFF = ""
IF GENERIC THEN CLB = @(0,23) ELSE CLB = @(0,23):CLL
*
BEGIN CASE
CASE SYSTEM(7) = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"; RVH = CHAR(27):"[1;7m"; AUX.ON = CHAR(27):"[5i"; AUX.OFF = CHAR(27):"[4i"
CASE SYSTEM(7) = "R"
RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = CHAR(18):CHAR(27):3; AUX.OFF = CHAR(20):CHAR(27):4
* IF NOT(SYSTEM(1)) THEN PRINT CHAR(27):"0Q":
CASE SYSTEM(7) = "U"; RVB = CHAR(14); RVE = CHAR(15); RVH = RVB; AUX.ON = ""; AUX.OFF = ""
CASE 1; RVB = ""; RVE = ""; RVH = ""; AUX.ON = ""; AUX.OFF = ""
END CASE
*
~STANDARD.CHARACTERS~
*CODE.SEGMENT: STANDARD.CHARACTERS
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 15 FEB 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
STB = "|"
STX = "~"
ESC = "`"
PICK.ESC = "<PCK>"
NUL = CHAR(0)
*
~SYS.INCL.PICKTR.EQU~
* CODE.SEGMENT: SYS.INCL.PICKTR.EQU
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
ERR.VRF.ARRAY<3> = "RECVD":VM:"STAT":VM:"CHK.SUM.BAD":VM:"CHK.ID":VM:"NON.PACKET":VM:"CHK.SUM":VM:"KEYBOARD.ABORT":VM:"PREV.CHK.ID":VM:"END":VM:"ABORT":VM:"CHOKE":VM:"HEX.ON":VM:"BLOCK.ON":VM:"MAX.ERR.ABORT":VM:"SLEEP":VM:"PAUSE"
ERR.VRF.ARRAY<5> = 1:VM:2:VM:0:VM:0:VM:0:VM:0:VM:0:VM:0:VM:9:VM:10:VM:11:VM:12:VM:13:VM:14:VM:15:VM:16
*      
*# Equates Area
*
*# Miscellaneous
EQU ZERO            TO 0
EQU ONE             TO 1
EQU TWO             TO 2
EQU TEN             TO 10
EQU ELEVEN          TO 11
EQU HI.NUM          TO 99999
EQU NULL.FLAG       TO "@}n"
EQU COMMAND         TO "@}c"
EQU PERR.MESSAGE    TO "@}e"
EQU CONT.MESSAGE    TO "@}+"
*
EQU EMPTY TO ""
*
*# Equates for DONE.FLAG
EQU SCAN.FOR.WORK   TO 1;   *# DONE.FLAG
EQU SHUTDOWN.DONE   TO 9;   *# DONE.FLAG
EQU ABORT.PRESENT   TO 16;  *# DONE.FLAG
*QU ABORT.VRF     TO 17;  *# DONE.FLAG
EQU UNAVAIL.SCHED   TO 18;  *# DONE.FLAG
EQU NO.WORK         TO 19;  *# DONE.FLAG
EQU WORK.DONE       TO 59;  *# DONE.FLAG
EQU ENTRY.DONE      TO 39;  *# DONE.FLAG
*QU ABORT.COMMAND   TO 117; *# DONE.FLAG
*
*# Equates for STAT
*
*# Error message verification & counting
EQU RECVD.VRF            TO 1; *# STAT
EQU STAT.VRF             TO 2; *# STAT
EQU CHK.SUM.BAD.VRF      TO 3; *# STAT
EQU CHK.ID.VRF           TO 4; *# STAT
EQU NON.PACKET.VRF       TO 5; *# STAT
EQU CHK.SUM.VRF          TO 6; *# STAT
EQU KEYBOARD.ABORT.VRF   TO 7; *# STAT
EQU PREV.CHK.ID.VRF      TO 8; *# STAT
EQU END.VRF              TO 9; *# STAT
EQU ABORT.VRF            TO 10; *# STAT
EQU CHOKE.MODE.VRF       TO 11; *# STAT
EQU HEX.MODE.VRF         TO 12; *# STAT
EQU BLOCK.MODE.VRF       TO 13; *# STAT
EQU MAX.ERR.ABORT.VRF    TO 14; *# STAT
EQU SLEEP.VRF            TO 15; *# STAT
EQU PAUSE.VRF            TO 16; *# STAT
*
*# Resource control parameters
EQU ITEM.TYPE.ERROR      TO 17;  *# STAT
EQU UNAVAIL.SCHED.STAT   TO 18;  *# STAT
EQU LIST.FINISHED        TO 19;  *# STAT
EQU FILE.MISSING         TO 20;  *# STAT
EQU ITEM.OV.ERROR        TO 21;  *# STAT
EQU ITEM.NEW.ERROR       TO 22;  *# STAT
EQU ITEM.OV.RQRD.ERROR   TO 23;  *# STAT
EQU FPOINTER.OV.ERROR    TO 24;  *# STAT
EQU FPOINTER.TR.ERROR    TO 25;  *# STAT
EQU ITEM.MISSING         TO 26;  *# STAT
EQU MAX.ITEM.SIZE        TO 29;  *# STAT
EQU WAIT.ERROR           TO 30;  *# STAT
EQU LOGOFF.COMMAND       TO 31;  *# STAT
EQU COMM.ERROR.STAT      TO 32;  *# STAT
EQU LINE.HUNG            TO 33;  *# STAT
*
*
*# Main program control
EQU MASTER         TO "MASTER"
EQU SLAVE          TO "SLAVE"
EQU ENTRY          TO "ENTER"
EQU DIN            TO "IN"
EQU DOUT           TO "OUT"
*
EQU CP TO COMM.PARAM 
EQU TP TO TRANS.PARAM
*
EQU VAL.STRING TO "*INIT*ITEM.TYPE*TDIR*FNAM*INAM*OPTN*SRCE*LIST.CN*LIST.SCAN*ABORT*LIST*ACCT*SYST*ERR.CN*DONE*END.LIST*"
*
~SYS.INCL.PICKTR.INIT~
*CODE.SEGMENT: SYS.INCL.PICKTR.INIT: *# Code to clear varialbles
* AUTHOR: DAVID HORSMAN
*DATE: 23 SEP 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*
*# Open files
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP:; STOP
*      
*# Read program run control data
USER.ID = "PICKTR":PORT; APPL = "PICKTR"; EL.CLASS = APPL; FSEARCH.PREFIX = "TRANSFER.PORT"
$INCLUDE IBP SYS.INCL.FSEARCH.TOP
READ TRANS.PORT FROM PAR.FILE,FKEY.ID THEN FKEY.FOUND = TRUE ELSE FKEY.FOUND = FALSE
$INCLUDE IBP SYS.INCL.FSEARCH.BOT
IF NOT(FKEY.FOUND) THEN TRANS.PORT = "05"
*      
COMM.PARAM.KEY = "TRANSFER.QUIET@PORT@":PORT; SYS.NAME.SUFFIX = EMPTY
GOSUB COMM.PARAM.LOAD
*
EL.DATA = EMPTY
IF EL.TRACE THEN
*
*# Load then error log record KEY
FSEARCH.PREFIX = "LOG.KEY"
$INCLUDE IBP SYS.INCL.FSEARCH.TOP
READ EL.SUFFIX FROM PAR.FILE,FKEY.ID THEN FKEY.FOUND = TRUE ELSE FKEY.FOUND = FALSE; EL.SUFFIX = ""
$INCLUDE IBP SYS.INCL.FSEARCH.BOT
*
*IF NOT(FKEY.FOUND) THEN EL.CN = ZERO ELSE
*
*# Load then error log record
FKEY.ID = "LOG.CN":EL.SUFFIX
READ EL.CN FROM PAR.FILE,FKEY.ID THEN FKEY.FOUND = TRUE ELSE FKEY.FOUND = FALSE; EL.CN = ""
*
*END
*
END ELSE EL.SUFFIX = ""; EL.CN = ZERO
*
TP = EMPTY 
*
*# Load port type for this port
IF TRANS.PORT EQ PORT THEN
FSEARCH.PREFIX = "TRANSFER.PORT.TYPE"
$INCLUDE IBP SYS.INCL.FSEARCH.TOP
*
READ MAIN.FLAG FROM PAR.FILE,FKEY.ID THEN
FKEY.FOUND = TRUE
IF NUM(MAIN.FLAG) THEN
IF MAIN.FLAG THEN
MAIN.FLAG = MASTER
END ELSE MAIN.FLAG = SLAVE
END
END ELSE MAIN.FLAG = SLAVE; FKEY.FOUND = FALSE
*
$INCLUDE IBP SYS.INCL.FSEARCH.BOT
*
END ELSE MAIN.FLAG = ENTRY
*
IF MAIN.FLAG = SLAVE AND TRANS.PORT NE PORT THEN MAIN.FLAG = ENTRY
*
STAT = FALSE; SYSTEM.NAME = EMPTY
CALL SYS.SUBR.SYSTEM.NAME(PAR.FILE,SYSTEM.NAME,STAT)
IF STAT THEN PRINT BELL:"SYSTEM NAME IS MISSING":; STOP
*
*# Load program control variables
ACK.RSP = EMPTY; CHK.ID = "@"; PREV.CHK.ID = "Z"; STAT.RECVD = EMPTY
DIR.FLAG = EMPTY; IN.FILE.NAME  = EMPTY; OUT.FILE.NAME = EMPTY; IN.ITEM.NAME  = EMPTY
OUT.ITEM.NAME = EMPTY; OPTIONS = EMPTY; LIST.NAME = EMPTY; ACCT.NAME = EMPTY
ACCT.PASS = EMPTY; SYS.NAME = EMPTY; COMM.SYS.NAME = EMPTY; LIST.SOURCE = EMPTY
DONE.FLAG = FALSE; STAT = FALSE; TP.CN = ZERO; ABORT.FLAG = FALSE
COMM.INIT = FALSE; COMM.ERROR = FALSE; COMM.STARTUP = FALSE; COMM.SHUTDOWN = FALSE
TRANS.FIRST = FALSE; TP.MAX = HI.NUM; TRANS.NUMBER = ZERO; ITEM = EMPTY
HOST.DETECT = FALSE; TRANS.ALL.NOT.OK.CN = ZERO; TRANS.SLEEP.CN = ZERO
LIST.ERROR.CN = ZERO; SEL.EXEC = ZERO; TRANS.SENT.ONE = FALSE
TRANS.PORT.ON = FALSE
*
*
MD.FILE.NAME = "MD"; DICT.NAME = EMPTY; DICT.BASE = ZERO; DICT.MOD = ZERO; DICT.SEP = ZERO; FILE.MOD = ZERO; FILE.SEP = ZERO; FILE.OPT = "MC,S,?"; FILE.NAME = EMPTY; FILE.BASE = ZERO; STAT = ZERO; PROG.DEBUG = FALSE
*
~SYS.INCL.CONV.TO.HEX~
*CODE.SEGMENT: SYS.INCL.CONV.TO.HEX
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: DEC 89, INCL CREATED: 25 MAR 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF NOT(LINE.IS.HEX) THEN
TC.CN = ZERO
TC.MAX = LEN(LINE)
HEX.LINE = ""; OLD.LINE = LINE
LOOP
TC.CN = TC.CN + ONE
WHILE TC.CN LE TC.MAX DO
TC = LINE[TC.CN,ONE]
HEX.LINE = HEX.LINE:OCONV(TC,"MX")
REPEAT
LINE = HEX.LINE
LINE.IS.HEX = TRUE
END
*
~SYS.INCL.CONV.TO.TXT~
*CODE.SEGMENT: SYS.INCL.CONV.TO.TXT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: DEC 89, INCL CREATED: 25 MAR 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
CHK.SUM.ORIG = ZERO
IF LINE.IS.HEX THEN
TC.CN = ONE
TC.MAX = LEN(LINE)
HEX.LINE = ""; OLD.LINE = LINE
LOOP WHILE TC.CN LE TC.MAX + ONE DO
TC = LINE[TC.CN,TWO]
CHK.SUM.ORIG = CHK.SUM.ORIG + SEQ(TC[ONE,ONE]) + SEQ(TC[TWO,ONE])
IF TC EQ "1C" OR TC EQ "1D" OR TC EQ "1E" THEN TC = "F":TC[TWO,ONE]
HEX.LINE = HEX.LINE:ICONV(TC,"MX")
TC.CN = TC.CN + TWO
REPEAT
LINE = HEX.LINE
LINE.IS.HEX = FALSE
END
*
~SYS.INCL.PICKTR.HEADER~
*CODE.SEGMENT: SYS.INCL.PICKTR.HEADER
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 03 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
FILE.OPT = "MC,S,?,QC"
IF MAIN.FLAG = MASTER  THEN
PRINT
END ELSE
*      
*#  MAIN.FLAG = SLAVE OR ENTRY
PRINT
PRINT
PRINT "Enter direction of tranfer (OUT)":
INPUT RSP
*      
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
* MAIN.FLAG = ENTRY
*      
IF RSP EQ "" THEN RSP =  DOUT
IF RSP NE DIN AND RSP NE DOUT THEN RSP = DOUT
DIR.FLAG = RSP
*      
PRINT
PRINT
PRINT "Enter the system name (UNKNOWN)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "UNKNOWN"
COMM.SYS.NAME = RSP
SYS.NAME = RSP
*      
PRINT
PRINT
PRINT "Enter the account name (SYSPROG)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "SYSPROG"
ACCT.NAME = RSP
*      
PRINT "Enter the account password (PUBLIC)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "PUBLIC"
ACCT.PASS = RSP
*      
PRINT
PRINT
PRINT "Enter input file name (BP)":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "BP"
IN.FILE.NAME = RSP
*      
PRINT
PRINT
PRINT "Enter output file name (":IN.FILE.NAME:"): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = IN.FILE.NAME
OUT.FILE.NAME = RSP
*      
LOOP
CONT = FALSE
PRINT
PRINT
PRINT "Enter options (O): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "O"
CN = ZERO
OPTIONS = EMPTY
LOOP
CN = CN + ONE
TC = RSP[CN,ONE]
WHILE TC NE EMPTY DO
IF NOT(INDEX("OAENL",TC,ONE)) THEN CONT = TRUE ELSE OPTIONS = OPTIONS:TC
*# O OVERWRITE
*# A APPEND
*# E EXISTS ON FILE
*# N NON-EXISTANT ONLY
*# L RETRIEVE FILE NAMES FROM LIST, ALL ITEMS (*)
*      
REPEAT
*
WHILE CONT DO REPEAT
*
LOOP
CONT = FALSE
PRINT
PRINT
PRINT "Enter the file creation options {FC,DC,DAC,(MC,S,?,QC)}: ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" AND TC NE "," DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:STB:"????":CR:NUL:
HOST.DETECT = TRUE; GOTO RECV.TRANSFER
END
IF RSP EQ "" THEN RSP = "MC,S,?,QC"
CN = ZERO
FILE.OPT = EMPTY
CNMAX = COUNT(RSP,",") + ONE
LOOP
CN = CN + ONE
TC = FIELD(RSP,",",CN)
WHILE CN LE CNMAX DO
IF NOT(INDEX("FC,DC,DAC,MC,S,?,QC",TC,ONE)) THEN CONT = TRUE ELSE
IF LEN(TC) THEN
IF LEN(FILE.OPT) THEN FILE.OPT = FILE.OPT:","
FILE.OPT = FILE.OPT:TC
END
END
*# FC File creation (dict and/or data) OK
*# DC Dict creation OK
*# DAC Data area creation OK
*# MC MD Q-pointer create OK
*# S Search for the file as far as is possible
*# ? Asking the user questions is OK
*# QC Q-pointer for file is OK to create
*      
REPEAT
*
WHILE CONT DO REPEAT
*
END; *# of SLAVE OR ENTRY
*      
~SYS.INCL.PICKTR.DETAIL~
*      
*#  MAIN.FLAG EQ ENTRY
IF MAIN.FLAG EQ ENTRY THEN
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE 
*
PRINT
RSP = EMPTY
*
LOOP
*
IF NOT(INDEX(OPTIONS,"L",ONE)) THEN
PRINT
PRINT "Enter item name: ":
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
END; * "L"
*
IF OPTIONS[ONE,ONE] EQ "l" THEN
READNEXT TEMP.ID FROM FILE.LIST ELSE
TEMP.ID = "@@@"
OPTIONS = OPTIONS[TWO,HI.NUM]
END
*
IF TEMP.ID NE "@@@" THEN
IN.FILE.NAME = TEMP.ID
OUT.FILE.NAME = TEMP.ID
IN.ITEM.NAME = "LIST"
OUT.ITEM.NAME = ""
LIST.NAME = "*"
IF DIR.FLAG EQ DOUT THEN LIST.SOURCE = TRUE ELSE LIST.SOURCE = FALSE
*
IF DIR.FLAG EQ DIN THEN
CFILE.NAME = OUT.FILE.NAME
END ELSE CFILE.NAME = IN.FILE.NAME
*
MD.FILE.NAME = "MD"; DICT.NAME = CFILE.NAME; DICT.BASE = FALSE; DICT.MOD = FALSE; DICT.SEP = FALSE; FILE.MOD = FALSE; FILE.SEP = FALSE; FILE.NAME = CFILE.NAME; FILE.BASE = FALSE; STAT = FALSE; PROG.DEBUG = FALSE
*
EL.DATA = ""
CALL SYS.SUBR.FILE.STAT(MD.FILE.NAME,DICT.NAME,DICT.BASE,DICT.MOD,DICT.SEP,FILE.MOD,FILE.SEP,FILE.OPT,FILE.NAME,FILE.BASE,STAT,PROG.DEBUG,ACCT.NAME,MAIN.FLAG,EL.DATA,EL.TRACE,EL.CLASS,EL.SUFFIX,EL.CN)
*
END; * "@@@"
END ELSE TEMP.ID = "@@@"
*
IF RSP EQ "LIST" OR RSP EQ "*" OR RSP EQ "ALL" OR (TEMP.ID = "@@@" AND INDEX(OPTIONS,"L",ONE)) THEN
LOOP
PRINT
PRINT "Enter list name: ":
IF RSP EQ "*" OR RSP EQ "ALL" THEN LIST.NAME = "*" ELSE INPUT LIST.NAME
LOOP TC = LIST.NAME[ONE,ONE] WHILE LEN(LIST.NAME) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO LIST.NAME = LIST.NAME[TWO,HI.NUM] REPEAT
IF LIST.NAME EQ "KILL" THEN ABORT
IF LIST.NAME EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF LIST.NAME[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
WHILE LIST.NAME EQ EMPTY DO REPEAT
*
IF LIST.NAME EQ "null" THEN LIST.NAME = EMPTY
*
IF NOT(INDEX(OPTIONS,"L",ONE)) AND NOT(DONE.FLAG) THEN
PRINT
PRINT "On this system (Y/N)? ":
INPUT YES.NO
IF YES.NO[ONE,ONE] EQ "Y" OR YES.NO[ONE,ONE] EQ "y" OR YES.NO = EMPTY THEN LIST.SOURCE = TRUE ELSE LIST.SOURCE = FALSE
*
END ELSE IF LIST.NAME NE "DONE" THEN
IF LIST.NAME[ONE,ONE] EQ "." THEN
EXEC.VERB = LIST.NAME[TWO,HI.NUM]
END ELSE
EXEC.VERB = "GET-LIST ":LIST.NAME
END
EXECUTE EXEC.VERB, //SELECT. > FILE.LIST
OPTIONS = "l":OPTIONS
END; * "L"
*
END ELSE IF NOT(INDEX(OPTIONS,"L",ONE)) THEN
LIST.SOURCE = EMPTY; LIST.NAME = EMPTY
END; * NOT LIST
*
WHILE NOT(DONE.FLAG) AND (((NOT(LEN(RSP)) OR SYSTEM(ELEVEN) GT 3) AND NOT(INDEX(OPTIONS,"L",ONE))) OR (INDEX(OPTIONS,"L",ONE) AND TEMP.ID = "@@@")) DO REPEAT
*
IF NOT(INDEX(OPTIONS,"L",ONE)) AND NOT(DONE.FLAG) THEN
*
IN.ITEM.NAME = RSP
PRINT
*
IF NOT(DONE.FLAG OR LEN(LIST.NAME)) THEN
PRINT "Enter output item name (":IN.ITEM.NAME:"): ":
INPUT RSP:
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = IN.ITEM.NAME ELSE OUT.FILE.NAME = EMPTY
*
IF OUT.FILE.NAME NE IN.FILE.NAME AND NOT(DONE.FLAG) THEN
IF NOT(LEN(OUT.FILE.NAME)) THEN OUT.FILE.NAME = IN.FILE.NAME
PRINT
PRINT "Enter output file name (":OUT.FILE.NAME:"): ":
INPUT RSP
LOOP TC = RSP[ONE,ONE] WHILE LEN(RSP) AND SEQ(TC) LT 65 AND TC NE ESC AND TC NE "*" DO RSP = RSP[TWO,HI.NUM] REPEAT
IF RSP EQ "KILL" THEN ABORT
IF RSP EQ "DONE" THEN DONE.FLAG = ENTRY.DONE
IF RSP[ONE,ONE] EQ ESC THEN
MAIN.FLAG = SLAVE; PRINT ESC:"????":CR:NUL:
GOTO RECV.TRANSFER
END
IF RSP EQ EMPTY THEN RSP = OUT.FILE.NAME
* OUT.FILE.NAME = IN.FILE.NAME
END
OUT.ITEM.NAME = RSP
END; *# of not done
*
END; *# of Running from a list
*
CN = ZERO; MAX = ZERO; ISIZE = ZERO
*      
END; *# of MAIN.FLAG EQ ENTRY
*      
~SYS.INCL.PICKTR.COMMANDS~
*CODE.SEGMENT: COMMAND.PROCESS: *# Subroutine to parse control parameters
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
COMMAND.SCAN = TRUE
*# Loop to input program control parameters from master computer
LOOP
*      
DEL.CN = ZERO
BLOCK.RSP = ITEM<ONE>
*      
IF BLOCK.RSP EQ NULL.FLAG THEN
DEL.CN = ONE
END ELSE IF BLOCK.RSP[ONE,LEN(COMMAND)] EQ COMMAND THEN
BLOCK.RSP = BLOCK.RSP[LEN(COMMAND)+ONE,HI.NUM]; DEL.CN = ONE
IF ITEM<TWO> EQ NULL.FLAG THEN
ITEM<TWO> = EMPTY
IF ITEM<3> EQ NULL.FLAG THEN
ITEM<3> = EMPTY
IF ITEM<4> EQ NULL.FLAG THEN
ITEM<4> = EMPTY
IF ITEM<5> EQ NULL.FLAG THEN
ITEM<5> = EMPTY
END
END
END
END
*
*      
*# Load program control parameters from master computer
*      
IF BLOCK.RSP EQ "?INIT" THEN
INIT.FLAG = FALSE
*
END ELSE IF BLOCK.RSP EQ "INIT" THEN
DIR.FLAG = EMPTY; IN.FILE.NAME  = EMPTY; OUT.FILE.NAME = EMPTY
IN.ITEM.NAME  = EMPTY; COMM.SYS.NAME = EMPTY
OUT.ITEM.NAME = EMPTY; OPTIONS = EMPTY; ACCT.NAME = EMPTY
IF NOT(FROM.LIST AND LIST.SOURCE) THEN LIST.NAME = EMPTY; LIST.SOURCE = EMPTY
*      
INIT.FLAG = TRUE; CDIR.FLAG = FALSE; FILE.FLAG = FALSE; ITEM.FLAG = FALSE
OPTN.FLAG = FALSE; LIST.FLAG = FALSE; ACCT.FLAG = FALSE; SYST.FLAG = FALSE
SRCE.FLAG = FALSE
*      
END ELSE IF BLOCK.RSP EQ "ITEM.TYPE" THEN
VRF.ITEM.TYPE = ITEM<TWO>; DEL.CN = TWO
IF VRF.ITEM.TYPE NE ITEM.TYPE THEN STAT = ITEM.TYPE.ERROR
*      
END ELSE IF BLOCK.RSP EQ "TDIR" THEN
DIR.FLAG = ITEM<TWO>; DEL.CN = TWO
CDIR.FLAG = TRUE
*      
END ELSE IF BLOCK.RSP EQ "FNAM" THEN
IN.FILE.NAME = ITEM<TWO>
OUT.FILE.NAME = ITEM<3>; DEL.CN = 3
FILE.FLAG = TRUE
*      
END ELSE IF BLOCK.RSP EQ "INAM" THEN
OUT.ITEM.NAME = ITEM<TWO>
IN.ITEM.NAME = ITEM<3>; DEL.CN = 3
IF LEN(IN.ITEM.NAME) OR LEN(OUT.ITEM.NAME) THEN ITEM.FLAG = TRUE
*      
END ELSE IF BLOCK.RSP EQ "OPTN" THEN
OPTIONS = ITEM<TWO>; DEL.CN = TWO
OPTN.FLAG = TRUE
*      
END ELSE IF BLOCK.RSP EQ "SRCE" THEN
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.SOURCE = ITEM<TWO>
DEL.CN = TWO
SRCE.FLAG = TRUE
ITEM.DATE = EMPTY
*
END ELSE IF BLOCK.RSP EQ "LIST.CN" THEN
IF NOT(LIST.SOURCE AND FROM.LIST) THEN LIST.CN = ITEM<TWO>
DEL.CN = TWO
*
END ELSE IF BLOCK.RSP EQ "LIST.SCAN" THEN
*IF NOT(LIST.SOURCE AND FROM.LIST) THEN 
LIST.SCAN = ITEM<TWO>
DEL.CN = TWO
*
END ELSE IF BLOCK.RSP EQ "ABORT" THEN
ABORT.FLAG = ITEM<TWO>; DEL.CN = TWO
STAT = ABORT.VRF; *# ABORT RECEIVED
*
END ELSE IF BLOCK.RSP EQ "LIST" THEN
DEL.CN = TWO
IF NOT(FROM.LIST) THEN
LIST.NAME = ITEM<TWO>
IF NOT(LEN(LIST.NAME)) THEN LIST.FLAG = FALSE; FROM.LIST = FALSE ELSE
LIST.FLAG = TRUE
IF LIST.SOURCE THEN
IF NOT(FROM.LIST) THEN
SEL.EXEC = ONE
END ELSE SEL.EXEC = ZERO
END ELSE SEL.EXEC = -ONE
FROM.LIST = TRUE
END
END; *# of not(from.list)
*      
END ELSE IF BLOCK.RSP EQ "ACCT" THEN
ACCT.NAME = ITEM<TWO>; DEL.CN = TWO
*# IF LEN(ACCT.NAME) AND ACCT.NAME NE ACCT THEN PRINT "???????ACCT??????"; STOP
ACCT.FLAG = TRUE
*      
END ELSE IF BLOCK.RSP EQ "SYST" THEN
TMP = ITEM<TWO>; DEL.CN = TWO
COMM.SYS.NAME = FIELD(TMP,"#",1)
DICT.BASE = ZERO; FILE.BASE = ZERO
FILE.OPT = FIELD(TMP,"#",2)
DICT.MOD = FIELD(TMP,"#",3); DICT.SEP = FIELD(TMP,"#",4)
IF NOT(NUM(DICT.MOD)) THEN DICT.MOD = ZERO
IF NOT(NUM(DICT.SEP)) THEN DICT.SEP = ZERO
FILE.MOD = FIELD(TMP,"#",5); FILE.SEP = FIELD(TMP,"#",6)
IF NOT(NUM(FILE.MOD)) THEN FILE.MOD = ZERO
IF NOT(NUM(FILE.SEP)) THEN FILE.SEP = ZERO
*# IF LEN(SYS.NAME) AND SYS.NAME NE COMM.SYS.NAME THEN PRINT "???????SYS??????"; STOP
SYST.FLAG = TRUE
*      
END ELSE IF BLOCK.RSP EQ "TP.MAX" THEN
TP.MAX = ITEM<TWO>; DEL.CN = TWO
IF MAIN.FLAG EQ SLAVE THEN TP.MAX = HI.NUM
*      
END ELSE IF BLOCK.RSP EQ "ERR.CN" THEN
OTHER.ERR.CN = ITEM<TWO>; DEL.CN = TWO
IF MAIN.FLAG EQ SLAVE THEN OTHER.ERR.CN = OTHER.ERR.CN + TWO
IF OTHER.ERR.CN LT ERR.LOW THEN OTHER.ERR.CN = ERR.LOW
*      
*END ELSE IF BLOCK.RSP EQ "ERROR" THEN
END ELSE IF BLOCK.RSP[1,5] EQ "ERROR" THEN
IF LEN(BLOCK.RSP) GT 5 THEN
BLOCK.RSP = BLOCK.RSP[6,9999]; DEL.CN = ONE
END ELSE
BLOCK.RSP = ITEM<TWO>; DEL.CN = TWO
END
STAT = RECVD.VRF; *# ERROR RECEIVED
CP<16,-1> = BLOCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*      
END ELSE IF BLOCK.RSP EQ "DONE" THEN
DONE.FLAG = WORK.DONE
*      
END ELSE IF BLOCK.RSP EQ "?INAM" THEN
ITEM.FLAG = FALSE
*      
END ELSE IF BLOCK.RSP EQ "END.LIST" THEN
FROM.LIST = FALSE
STAT = LIST.FINISHED
*      
END ELSE IF BLOCK.RSP EQ "KILL" OR BLOCK.RSP EQ "OFF" OR BLOCK.RSP EQ "TCL" OR BLOCK.RSP[ONE,5] EQ "ERROR" OR BLOCK.RSP[ONE,ONE] EQ "?" THEN
STAT = ABORT.VRF; *# KILL/OFF/TCL/ERROR RECEIVED
CP<16,-1> = BLOCK.RSP:SVM:TP.CN:SVM:LIST.CN
ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
*
END ELSE
ERR.CN.ALL = ERR.CN.ALL + ONE
END; *# of valid commands
*
IF ERR.CN GT ERR.LOW THEN ERR.CN = ERR.CN - ONE
*      
END ELSE
IF BLOCK.RSP EQ "KILL" OR BLOCK.RSP EQ "OFF" OR BLOCK.RSP EQ "TCL" THEN
*# Block is a user command
*      
IF MAIN.FLAG NE MASTER THEN STAT = KEYBOARD.ABORT.VRF; *# Terminal entered KILL,OFF,TCL command
*      
END
*# Block is not a command
* ERR.CN = ERR.CN + ONE
ERR.CN.ALL = ERR.CN.ALL + ONE
IF NOT(CNTR.FLAG) THEN COMMAND.SCAN = FALSE ELSE DEL.CN = ONE
*      
END; *# of block not command
*      
IF ERR.CN GE ERR.MAX OR ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERR.ABORT.VRF
*      
LOOP WHILE DEL.CN DO DEL ITEM<ONE,ZERO,ZERO>; DEL.CN = DEL.CN - ONE REPEAT
WHILE LEN(ITEM) AND COMMAND.SCAN DO REPEAT
*      
~SYS.INCL.PICKTR.JOB.LOAD~
* CODE.SEGMENT: SYS.INCL.PICKTR.JOB.LOAD
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 17 FEB 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
TP<TP.CN+ONE,ONE> =  IN.FILE.NAME
TP<TP.CN+ONE,TWO> = OUT.FILE.NAME
TP<TP.CN+ONE,3> =  IN.ITEM.NAME
TP<TP.CN+ONE,4> = OUT.ITEM.NAME
TP<TP.CN+ONE,5> =       OPTIONS
TP<TP.CN+ONE,6> =      DIR.FLAG
TP<TP.CN+ONE,7> =     LIST.NAME
TP<TP.CN+ONE,8,ONE> = ACCT.NAME
TP<TP.CN+ONE,8,TWO> = ACCT.PASS
TP<TP.CN+ONE,9,ONE> = COMM.SYS.NAME
TP<TP.CN+ONE,9,TWO> = FILE.OPT
TP<TP.CN+ONE,9,3>   = DICT.MOD
TP<TP.CN+ONE,9,4>   = DICT.SEP
TP<TP.CN+ONE,9,5>   = FILE.MOD
TP<TP.CN+ONE,9,6>   = FILE.SEP
TP<TP.CN+ONE,TEN> =  LIST.SOURCE
IF MAIN.FLAG EQ ENTRY THEN
TP<TP.CN+ONE,ELEVEN> = EMPTY
TP<TP.CN+ONE,12> = ZERO
END
*
~SYS.INCL.SCHED.CHECK~
*CODE.SEGMENT: SYS.INCL.SCHED.CHECK
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 9 SEP 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF NOT(SCHED.OK) THEN
SCHED.OK = TRUE
DT = DATE()
*
DT.VM.MAX = DCOUNT(SCHED.FLAG<6>,VM)
*
IF NOT(DT.VM.MAX) THEN DT.VM = ONE ELSE
*
LOCATE DT IN SCHED.FLAG<6> BY "AR" SETTING DT.VM ELSE
DT.VM = DT.VM - (DT.VM GT ONE)
END
*
IF DT GE SCHED.FLAG<6,DT.VM> THEN
IF DT GT SCHED.FLAG<7,DT.VM> AND SCHED.FLAG<7,DT.VM> THEN DT.VM = ONE
END
*
END
*
IF SCHED.FLAG<8,DT.VM> THEN SCHED.OK = FALSE ELSE
*
TM = TIME()
TM.VM.MAX = DCOUNT(SCHED.FLAG<9>,VM)
*
IF NOT(TM.VM.MAX) THEN TM.VM = ONE ELSE
IF TM.VM.MAX GE DT.VM THEN TM.VM = DT.VM ELSE TM.VM = ONE
END
*
TM.SVM.MAX = DCOUNT(SCHED.FLAG<9,TM.VM>,SVM)
*
IF NOT(TM.SVM.MAX) THEN TM.SVM.MAX = ONE
*
BEGIN CASE
*
CASE TM.SVM.MAX EQ ONE
TM.SVM = ONE
*
CASE TM.SVM.MAX EQ 7
TM.SVM = DT - (INT(DT/7) * 7)
IF NOT(TM.SVM) THEN TM.SVM = 7
TM.SVM = TM.SVM - ONE
IF NOT(TM.SVM) THEN TM.SVM = 7
IF TM GT SCHED.FLAG<TEN,TM.VM,TM.SVM> OR SCHED.FLAG<9,TM.VM,TM.SVM> LE SCHED.FLAG<TEN,TM.VM,TM.SVM> THEN
TM.SVM = TM.SVM + ONE
IF TM.SVM GT 7 THEN TM.SVM = ONE
END
*
CASE TM.SVM.MAX GE 28 AND TM.SVM.MAX LE 31
TM.SVM = (OCONV(DT,"DTWO"))[ONE,2]
TM.SVM = TM.SVM - ONE
IF NOT(TM.SVM) THEN
MM = OCONV(DT,"D2/")[ONE,TWO]; TM.SVM = 31; YY = OCONV(DT,"D2/")[7,TWO]
MM = MM - ONE
LOOP UNTIL ICONV(MM:"/":TM.SVM:"/":YY,"D") DO TM.SVM = TM.SVM - ONE REPEAT
IF TM.SVM GT TM.SVM.MAX THEN TM.SVM = TM.SVM.MAX
END
IF TM GT SCHED.FLAG<TEN,TM.VM,TM.SVM> OR SCHED.FLAG<9,TM.VM,TM.SVM> LE SCHED.FLAG<TEN,TM.VM,TM.SVM> THEN TM.SVM = TM.SVM + ONE; IF TM.SVM GT 31 THEN TM.SVM = ONE
*
CASE TRUE
TM.SVM = DT - SCHED.FLAG<6,DT.VM> + TRUE
IF TM.SVM GT TRUE AND TM.SVM LE TM.SVM.MAX THEN
TM.SVM = TM.SVM - TRUE
IF TM GT SCHED.FLAG<TEN,TM.VM,TM.SVM> OR SCHED.FLAG<9,TM.VM,TM.SVM> LE SCHED.FLAG<TEN,TM.VM,TM.SVM> THEN TM.SVM = TM.SVM + TRUE
END
IF TM.SVM GT TM.SVM.MAX THEN TM.SVM = TM.SVM.MAX
END CASE
*
*
TM.START = SCHED.FLAG<9,TM.VM,TM.SVM>
TM.END  = SCHED.FLAG<TEN,TM.VM,TM.SVM>
IF NOT(TM.END) THEN TM.END = 86400
IF TM.START EQ TM.END THEN
IF TM.START EQ ZERO THEN TM.START = 0; TM.END = 86400 ELSE
IF TM.START LE 43200 THEN TM.END = TM.END + 43200 ELSE
IF TM.START = 86400 THEN TM.START = ZERO ELSE TM.END = 86400
END
END
END
*
BEGIN CASE
CASE TM.START LT TM.END
IF TM GE TM.START AND TM LE TM.END THEN IN.RANGE = TRUE ELSE IN.RANGE = FALSE
CASE TM.START GT TM.END
IF TM GE TM.START OR  TM LE TM.END THEN IN.RANGE = TRUE ELSE IN.RANGE = FALSE
END CASE
*
IF (IN.RANGE AND SCHED.FLAG<ELEVEN,TM.VM,TM.SVM>) OR NOT(IN.RANGE OR SCHED.FLAG<ELEVEN,TM.VM,TM.SVM>) THEN SCHED.OK = FALSE
*
END; *@ OF SCHED.FLAG<8>
*
END; *@ OF SCHED.OK
*
~SYS.INCL.SCHED.CHECK.READ~
* CODE.SEGMENT: SYS.INCL.SCHED.CHECK.READ
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: APR 89
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
READ SCHED.FLAG FROM PAR.FILE,FKEY.ID THEN FKEY.FOUND = TRUE; SCHED.OK = FALSE ELSE SCHED.OK = TRUE; FKEY.FOUND = FALSE 
*
~SYS.INCL.ABORT.CHECK~
* CODE.SEGMENT: SYS.INCL.ABORT.CHECK
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: APR 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF ABORT.OK THEN
*
CP<ABORT.PRESENT> = "Abort is: ":ABORT.FLAG<ONE>
IF COUNT(ABORT.FLAG,AM) GE TWO THEN
IF NUM(ABORT.FLAG<TWO>) AND NUM(ABORT.FLAG<3>) THEN
IF (ABORT.FLAG<TWO> AND DATE() GT ABORT.FLAG<TWO>) OR (DATE() GE ABORT.FLAG<TWO> AND TIME() GE ABORT.FLAG<3>) THEN
IF ABORT.DEL THEN DELETE PAR.FILE,"TRANSFER.ABORT":PORT
ABORT.OK = FALSE
END; *# of date/time
END
END
*
IF ABORT.OK THEN
IF NUM(ABORT.FLAG<ONE>) THEN DONE.FLAG = ABORT.FLAG<ONE> ELSE DONE.FLAG = ABORT.PRESENT
MAX = DCOUNT(ITEM,AM)
IF ITEM[1,1] NE ESC AND ITEM[1,1] NE "@" THEN
ITEM = ESC:"ABORT"; MAX = ONE; CN = ZERO
END ELSE
IF ITEM<MAX> NE ESC:"END" THEN MAX = MAX + ONE
ITEM<MAX> = ESC:"ABORT"
END
ITEM<-ONE> = ESC:"END"; MAX = MAX + ONE
TMP = TRIM(ABORT.FLAG<ONE>[ONE,4])
IF TMP EQ "OFF" THEN STAT = LOGOFF.COMMAND
END ELSE ABORT.FLAG = EMPTY
*
END ELSE
ABORT.FLAG = EMPTY
IF DONE.FLAG EQ ABORT.PRESENT THEN DONE.FLAG = FALSE
END
*      
~SYS.INCL.ABORT.CHECK.READ~
* CODE.SEGMENT: SYS.INCL.ABORT.CHECK.READ
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: APR 89
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
READ ABORT.FLAG FROM PAR.FILE,FKEY.ID THEN FKEY.FOUND = TRUE; ABORT.OK = TRUE; ABORT.DEL = FALSE ELSE ABORT.OK = FALSE; ABORT.DEL = FALSE; FKEY.FOUND = FALSE
*
~SYS.INCL.QUIET.WRITE~
* CODE.SEGMENT: SYS.INCL.QUIET.WRITE
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
CP<5> = ERR.CN
CP<9> = ERR.CN.ALL
CP<10> = ERR.CN.TOTAL + ERR.CN.ALL
CP<12,ONE,ONE> = DATE()
CP<12,ONE,TWO> = TIME()
CP<12,ONE,3> = WHO
* :COMM.ERROR:SVM
CP<12,ONE,5> = STAT
* :TRANS.CN:SVM:TRANS.MAX:SVM:DONE.FLAG:SVM:COMM.INIT:SVM:COMM.STARTUP:SVM:COMM.SHUTDOWN:SVM:
* ACK.RSP
CP<12,ONE,12> = ACK.RSP<ONE,ONE,ONE>
CP<12,ONE,13> = LINE.PACKET<ONE,ONE,ONE>
CP<12,ONE,14> = TRANS.ALL.OK
CP<12,ONE,15> = TRANS.ALL.NOT.OK.CN
*
CP<20> = ERR.CN.ARRAY
TEMP.SVM.MAX = DCOUNT(ERR.CN.ARRAY,VM)
FOR TEMP.SVM = ONE TO TEMP.SVM.MAX
CP<17,TEMP.SVM> = CP<17,TEMP.SVM> + ERR.CN.ARRAY<ONE,TEMP.SVM>
ERR.CN.ARRAY<ONE,TEMP.SVM> = ZERO
NEXT TEMP.SVM
ERR.CN.HISTORY = CP<17>
*
CP<28> = ERR.LEVEL
FOR TEMP.VM = ONE TO TWO
TEMP.SVM.MAX = DCOUNT(ERR.LEVEL<ONE,TEMP.VM>,SVM)
FOR TEMP.SVM = ONE TO TEMP.SVM.MAX
CP<27,TEMP.VM,TEMP.SVM> = CP<27,TEMP.VM,TEMP.SVM> + ERR.LEVEL<ONE,TEMP.VM,TEMP.SVM>
ERR.LEVEL<ONE,TEMP.VM,TEMP.SVM> = ZERO
NEXT TEMP.SVM
NEXT TEMP.VM
ERR.LEVEL.HISTORY = CP<27>
*
IF LEN(CP) GT 10000 THEN CP = CP[1,7000]
ERR.LOW = CP<19,ONE>; ERR.OUT.OFFSET = CP<19,TWO>; ERR.IN.OFFSET = CP<19,3>; ERR.CHOKE = CP<19,4>; ERR.HI = CP<19,5>
WRITE COMM.PARAM ON PAR.FILE,COMM.PARAM.KEY
*
~SYS.INCL.QUIET.LOAD~
* CODE.SEGMENT: SYS.INCL.QUIET.LOAD
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 11 OCT 89
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
LINE.MAX.LEN = CP<TWO>
IF NOT(LINE.MAX.LEN) THEN LINE.MAX.LEN = 70
*# Maximum # of err's for this run
ERR.MAX.ALL = CP<3>
IF NOT(ERR.MAX.ALL) THEN ERR.MAX.ALL = 1000
*# Maximum # of err - floating speed regulator
ERR.MAX = CP<4>
IF NOT(ERR.MAX) THEN ERR.MAX = 30
*ERR.CN = CP<5>
*IF NOT(NUM(ERR.CN)) THEN ERR.CN = ZERO
*IF NOT(ERR.CN) THEN ERR.CN = 3
*LOOP WHILE ERR.CN GE ERR.MAX AND ERR.CN GT TEN DO ERR.CN = ERR.CN - TEN REPEAT
CW.MAX = CP<6>
IF NOT(CW.MAX) THEN CW.MAX = 300
CW.PAUSE = CP<7>
IF NOT(CW.PAUSE) THEN CW.PAUSE = ONE
CW.CLEAR = CP<8>
IF NOT(CW.CLEAR) THEN CW.CLEAR = 75
*ERR.CN.ALL = CP<9>
*ERR.CN.ALL = ZERO
*ERR.CN.TOTAL = CP<TEN>
*IF NOT(NUM(ERR.CN.TOTAL)) THEN ERR.CN.TOTAL = ZERO
*IF NOT(NUM(ERR.CN.ALL)) THEN ERR.CN.ALL = ZERO
COMM.SYNC = CP<ELEVEN>
IF NOT(NUM(COMM.SYNC)) THEN COMM.SYNC = EMPTY
CW.QUIET = CP<ONE>
*ERR.CN.ARRAY = CP<17>
AM.MAX = CP<18>
IF AM.MAX LE 5 THEN AM.MAX = 100
ERR.LOW = CP<19,ONE>; ERR.OUT.OFFSET = CP<19,TWO>; ERR.IN.OFFSET = CP<19,3>; CHOKE.MODE = CP<19,4>; ERR.HI = CP<19,5>
EL.TRACE  = CP<21>
EL.TRACE.CN  = EL.TRACE[4,ONE]
EL.TRACE.OUT = EL.TRACE[3,ONE]
EL.TRACE.IN  = EL.TRACE[TWO,ONE]
EL.TRACE     = EL.TRACE[ONE,ONE]
*
ERR.ITEM.RETRY = CP<22>
IF NOT(ERR.ITEM.RETRY) THEN ERR.ITEM.RETRY = 3
ERR.CN.LAST.HI = CP<23>
IF NOT(ERR.CN.LAST.HI) THEN ERR.CN.LAST.HI = 5
HEX.MODE = CP<24>
ERR.REPEAT.HI = CP<25>; IF NOT(ERR.REPEAT.HI) THEN ERR.REPEAT.HI = 3
ERR.CONSEC.HI = CP<26>; IF NOT(ERR.CONSEC.HI) THEN ERR.CONSEC.HI = 5
*
BLOCK.MODE = CP<29>
*
FILTER.IN.STR = CP<30>; FILTER.IN.MODE = FILTER.IN.STR<ONE,ONE>
FILTER.OUT.STR = CP<31>; FILTER.OUT.MODE = FILTER.OUT.STR<ONE,ONE>
*      
IF ERR.CN LT ERR.LOW THEN ERR.CN = ERR.LOW
*      
~SYS.INCL.QUIET.READ~
*CODE.SEGMENT: SYS.INCL.QUIET.READ: *# Code to clear varialbles
* AUTHOR: DAVID HORSMAN
*DATE: 23 SEP 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*
*# Load the port characteristics
PREV.COMM.PARAM.KEY = COMM.PARAM.KEY; COMM.PARAM.FOUND = FALSE
IF SYS.NAME.SUFFIX NE EMPTY THEN
COMM.PARAM.KEY = "TRANSFER.QUIET":SYS.NAME.SUFFIX
READ COMM.PARAM FROM PAR.FILE,COMM.PARAM.KEY THEN COMM.PARAM.FOUND = TRUE ELSE COMM.PARAM.FOUND = FALSE
END
*
IF NOT(COMM.PARAM.FOUND) THEN
COMM.PARAM.FOUND = TRUE
COMM.PARAM.KEY = "TRANSFER.QUIET@PORT@":PORT
READ COMM.PARAM FROM PAR.FILE,COMM.PARAM.KEY ELSE
COMM.PARAM.KEY = "TRANSFER.QUIET"
READ COMM.PARAM FROM PAR.FILE,COMM.PARAM.KEY ELSE
COMM.PARAM.KEY = PREV.COMM.PARAM.KEY
READ COMM.PARAM FROM PAR.FILE,COMM.PARAM.KEY ELSE
COMM.PARAM.KEY = "TRANSFER.QUIET@":APPL:"@DEFAULT"
READ COMM.PARAM FROM PAR.FILE,COMM.PARAM.KEY ELSE
CP = TEN; CW.QUIET = TEN; COMM.PARAM.FOUND = FALSE
END
END
END
END
END
*
~SYS.INCL.COMM.WAIT.QUIET~
*CODE.SEGMENT: SYS.COMM.WAIT.QUIET
*     AUTHOR: DAVE HORSMAN
* DATE WRITTEN: 10 FEB 89
*    COMPANY: Macroscope Design Matrix
*                  & (additionally)
*             Axion Computer Software Ltd.
*
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*  APPLICATION: System Communications Design
*
*    VARIABLES:
*        IN: PAR.FILE             -    Parameter file for reading control
*                                            records.
*            CW.KEY        -    Read control file when filled
*            CW.QUIET      -    Number of seconds continuous quiet
*            CW.MAX        -    Max length of wait
*            CW.ERROR      -    Max length error flag (null/1)
*            CW.PAUSE      -    # of RQMs to be performed
*            CW.CLEAR      -    Clear buffer if it exceeds
*                                       this # of char's.
ECHO OFF
IF LEN(CW.KEY) THEN
READ CW.REC FROM PAR.FILE,CW.KEY THEN
CW.REC.CN.MAX = DCOUNT(CW.REC,AM)
*
END ELSE
CW.REC.CN.MAX = ZERO
CW.REC = EMPTY 
RETURN; *# TO CALLING PROGRAM
END
END ELSE CW.REC = EMPTY; CW.REC.CN.MAX = ZERO
*
CW.REC.CN = ZERO; CW.RECVD = EMPTY; CW.RECVD.LEN = ZERO 
STRING.FOUND = TRUE; COMM.LINE.TO.PRINT = FALSE; COMM.INIT = FALSE 
CW.VERB = EMPTY; CW.SUBJECT = EMPTY; CW.PREDICATE = EMPTY
STRING.TO.BE.FOUND = EMPTY; EXEC.FLAG = FALSE; EXEC.VERB = EMPTY
CW.COMMAND = EMPTY
*
LOOP
*
IF NOT(COMM.LINE.TO.PRINT) THEN
*
CW.REC.CN = CW.REC.CN + ONE
*
IF CW.REC.CN LE CW.REC.CN.MAX AND STRING.FOUND THEN
IF CW.REC.CN EQ CW.REC.CN.MAX THEN COMM.INIT = FALSE
CW.COMMAND = CW.REC<CW.REC.CN>
*
CW.VERB = FIELD(CW.COMMAND," ",ONE)
CW.SUBJECT = FIELD(CW.COMMAND," ",TWO)
CW.PREDICATE = FIELD(CW.COMMAND," ",3)
STRING.TO.BE.FOUND = EMPTY
*
BEGIN CASE
*
CASE CW.VERB EQ "WAIT" AND NOT(NUM(CW.SUBJECT))
*
BEGIN CASE
*
CASE CW.SUBJECT EQ "PAUSE"
IF NOT(NUM(CW.PREDICATE)) THEN CW.PREDICATE = ZERO
CW.PAUSE = CW.PREDICATE + ZERO
*
CASE CW.SUBJECT EQ "QUIET"
IF NOT(NUM(CW.PREDICATE)) THEN CW.PREDICATE = ZERO
CW.QUIET = CW.PREDICATE + ZERO
*
END CASE
*
CASE CW.VERB EQ "CLEAR" OR CW.VERB EQ "INIT"
INPUTCLEAR
COMM.INIT = FALSE
*
CASE INDEX("*PAUSE*SLEEP*EXECUTE*PERFORM*DO*","*":CW.VERB:"*",ONE) OR (CW.VERB EQ "WAIT" AND NUM(CW.SUBJECT))
IF CW.VERB EQ "WAIT" THEN CW.PREDICATE = CW.SUBJECT; CW.SUBJECT = "SLEEP"
*
BEGIN CASE
*
CASE CW.VERB EQ "EXECUTE" OR CW.VERB EQ "PERFORM" OR CW.VERB EQ "DO"
*
CASE CW.PREDICATE MATCHES "1N':'2N" OR CW.PREDICATE MATCHES "2N':'2N" OR CW.PREDICATE MATCHES "1N':'2N':'2N" OR CW.PREDICATE MATCHES "2N':'2N':'2N"
EXEC.VERB = "SLEEP ":CW.PREDICATE
EXEC.FLAG = TRUE
*
CASE NUM(CW.PREDICATE)
IF NOT(NUM(CW.PAUSE)) THEN CW.PAUSE = ONE
IF CW.PAUSE LT ZERO THEN CW.PAUSE = ABS(CW.PAUSE)
IF NOT(CW.PAUSE) THEN CW.PAUSE = ONE
EXEC.VERB = "SLEEP ":CW.PAUSE
EXEC.FLAG = TRUE
*
CASE CW.SUBJECT[ONE,ONE] EQ '"' OR CW.SUBJECT[ONE,ONE] EQ "'" OR CW.SUBJECT[ONE,ONE] EQ '/' OR CW.SUBJECT[ONE,ONE] EQ '\'
CHAR.END = CW.SUBJECT.SYS11
STRING.START = INDEX(CW.COMMAND,CHAR.END,ONE)
STRING.END   = INDEX(CW.COMMAND,CHAR.END,TWO)
IF NOT(STRING.END) THEN STRING.END = LEN(CW.COMMAND) + ONE
STRING.TO.BE.FOUND = CW.COMMAND[STRING.START + ONE,(STRING.END - STRING.START - ONE)]
EXEC.FLAG = FALSE
*
CASE TRUE
EXEC.FLAG = FALSE
*
END CASE
*
IF EXEC.FLAG THEN
EXEC.RSP = EMPTY
EXECUTE EXEC.VERB, //OUT. > EXEC.RSP
END
*
CASE TRUE
COMM.LINE.TO.PRINT = TRUE
*
END CASE
*
END; *# OF LOAD NEXT VERB
END; *# OF NOT(TO.PRINT)
*
* WAIT INITIALIZATION
IF NOT(COMM.INIT) THEN
COMM.INIT = TRUE
CW.START.TIME = TIME()
CW.START.DATE = DATE()
* CURRENT # OF CAHR'S IN TYPE AHEAD BUFFER
*
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
CW.START.SYS11 = SYSTEM(ELEVEN)
* INPUT TMP,-ONE:; * REV ONLY
* CW.START.SYS11 = LEN(TMP); * REV ONLY
CASE OPSYS EQ "M"
CW.START.SYS11 = ONE
CASE OPSYS EQ "R"
* INPUT TMP,-ONE:; * REV ONLY
* CW.START.SYS11 = LEN(TMP); * REV ONLY
END CASE
*
CW.CONT.QUIET = ZERO
*
CW.LAST.SYS11 = CW.START.SYS11
CW.LAST.DATE = CW.START.DATE
CW.LAST.TIME = CW.START.TIME
*
END
*
* MAIN LOOP
LOOP
*
* LOOP TO CLEAR BUFFER OVERFLOW
LOOP
*
* DETERMIN TOTAL ELP
CW.CURR.TIME = TIME()
CW.CURR.DATE = DATE()
IF CW.START.DATE NE CW.CURR.DATE THEN
CW.ELP = (CW.CURR.DATE - CW.START.DATE - ONE) * 86400 + 86400 - CW.START.TIME + CW.CURR.TIME
END ELSE
CW.ELP = ABS(CW.CURR.TIME - CW.START.TIME)
END
*# PRINT "CW.ELP ":CW.ELP; *#
IF CW.ELP GT CW.MAX THEN CW.ERROR = ONE
*@ PRINT "CW.ERROR ":CW.ERROR; *@
*
*IF NOT(CW.ERROR) THEN
*
*# CURRENT # OF CHARS IN TYPE AHEAD BUFFER
BEGIN CASE
*
CASE OPSYS EQ "U"
* ULT ONLY
CW.CURR.SYS11 = SYSTEM(ELEVEN)
* INPUT TMP,-ONE:; * REV ONLY
* CW.CURR.SYS11 = LEN(TMP); * REV ONLY
CASE OPSYS EQ "M"
CW.CURR.SYS11 = ONE
CASE OPSYS EQ "R"
* INPUT TMP,-ONE:; * REV ONLY
* CW.CURR.SYS11 = LEN(TMP); * REV ONLY
END CASE
*
*# DETERMINE CHANGE IN BUFFER
*
*# # OF CHAR'S HAS CHANGED
IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
CW.LAST.SYS11 = CW.CURR.SYS11
CW.LAST.DATE = CW.CURR.DATE
CW.LAST.TIME = CW.CURR.TIME
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
*@ PRINT "CW.LAST.DATE  ":CW.LAST.DATE; *@
*@ PRINT "CW.LAST.TIME  ":CW.LAST.TIME; *@
END ELSE
*
*# BUFFER IS EMPTY
*@ PRINT "CW.LAST.SYS11 ":CW.LAST.SYS11; *@
IF CW.LAST.DATE NE CW.CURR.DATE THEN
CW.CONT.QUIET = (CW.CURR.DATE - CW.LAST.DATE - ONE) * 86400 + 86400 - CW.LAST.TIME + CW.CURR.TIME
END ELSE
CW.CONT.QUIET = ABS(CW.CURR.TIME - CW.LAST.TIME)
END
*@ PRINT "CW.CONT.QUIET ":CW.CONT.QUIET; *@
*
END; *# OF LAST.SYS11
*
*END; *# OF NOT(CW.ERROR)
*
*#  DETERMINE IF CLEAR OR STRING CHECK IS REQUIRED
*IF OPSYS EQ "R" OR (CW.LAST.SYS11 + CW.RECVD.LEN GT CW.CLEAR AND CW.CLEAR) OR LEN(STRING.TO.BE.FOUND) THEN
WHILE NOT(CW.ERROR) AND COMM.INIT AND CW.CURR.SYS11 GT CW.CLEAR DO
*
TMP = LEN(STRING.TO.BE.FOUND)
IF TMP LT CW.CLEAR - 10 THEN TMP = CW.CLEAR - 10
IF TMP LT 10 THEN TMP = 10
* IF CW.LAST.SYS11 - 4 LT TMP THEN TMP = CW.LAST.SYS11 - 4
IF CW.CURR.SYS11 - 4 LT TMP THEN TMP = CW.CURR.SYS11 - 4
*
IF TMP GT 4 THEN
INPUT TMP1,TMP:
TMP = LEN(TMP1)
*CW.LAST.SYS11 = CW.LAST.SYS11 - TMP; CW.CURR.SYS11 = CW.CURR.SYS11 - TMP
CW.RECVD = CW.RECVD:TMP1
CW.RECVD.LEN = LEN(CW.RECVD)
*END ELSE CW.LAST.SYS11 = CW.CURR.SYS11
END
*
REPEAT
CW.RECVD.LEN = LEN(CW.RECVD)
* END OF BUFFER OVERFLOW LOOP
*
* INPUTCLEAR
*
IF NOT(CW.ERROR) THEN
*
IF LEN(STRING.TO.BE.FOUND) THEN
STRING.FOUND = INDEX(CW.RECVD,STRING.TO.BE.FOUND,ONE)
IF STRING.FOUND THEN COMM.INIT = FALSE
END ELSE STRING.FOUND = TRUE
*
LOOP
*
CW.RECVD.LEN = LEN(CW.RECVD)
TMP = LEN(STRING.TO.BE.FOUND)
*
WHILE ((CW.RECVD.LEN GT LEN(STRING.TO.BE.FOUND) * TWO AND LEN(STRING.TO.BE.FOUND)) OR CW.RECVD.LEN GT 200) AND NOT(CW.ERROR) DO
*
IF NOT(TMP) THEN TMP = 150
CW.RECVD = CW.RECVD[TMP +ONE,99999]
*
REPEAT
*
* CW.LAST.SYS11 = ZERO 
* IF CW.CURR.SYS11 NE CW.LAST.SYS11 THEN
* *# OF CHAR'S HAS CHANGED
* CW.CURR.SYS11 = ONE 
* END ELSE
* CW.CURR.SYS11 = ZERO
* END
* *
*END; * OF STRING CHECK OR CW.CLEAR EXCEEDED
*
END; * OF NOT(CW.ERROR)
*
*@ PRINT "CW.ERROR ":CW.ERROR; *@
*@ PRINT "COMM.INIT ":COMM.INIT; *@
*@ PRINT "CW.CONT.QUIET:*:CW.QUIET ":CW.CONT.QUIET:"*":CW.QUIET; *@
*@ PRINT "STRING.FOUND ":STRING.FOUND; *@
WHILE NOT(CW.ERROR) AND COMM.INIT AND ((CW.CONT.QUIET LT CW.QUIET) AND NOT(STRING.FOUND)) DO
*
* Wait the required # of RQMs
FOR CW.TEMP = ONE TO CW.PAUSE
RQM
NEXT CW.TEMP
*
REPEAT
*
IF COMM.LINE.TO.PRINT THEN
*
PRINT CW.COMMAND:CR:
COMM.LINE.TO.PRINT = FALSE
COMM.INIT = FALSE
*
* Wait the required # of RQMs
FOR CW.TEMP = ONE TO CW.PAUSE
RQM
NEXT CW.TEMP
*
END
*
WHILE NOT(CW.ERROR) AND ((CW.CONT.QUIET LT CW.QUIET) OR CW.REC.CN LT CW.REC.CN.MAX) DO REPEAT
*
~SYS.INCL.FSEARCH.TOP~
* CODE.SEGMENT: SYS.INCL.FSEARCH.TOP
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 01 OCT 87
* (c) Copyright 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
* FSEARCH.PREFIX must be set upon entry!
*
FSEARCH.MAX = 6
FSEARCH.CN  = ONE
FKEY.ID     = ""
FKEY.SUFFIX = ""
*
LOOP
*
BEGIN CASE
CASE FSEARCH.CN EQ ONE
FSEARCH.SUFFIX = "@ALL"
CASE FSEARCH.CN EQ TWO
FSEARCH.SUFFIX = "@ACCT@":ACCT:"@":PORT
CASE FSEARCH.CN EQ 3
FSEARCH.SUFFIX = "@ACCT@":ACCT
CASE FSEARCH.CN EQ 4
FSEARCH.SUFFIX = "@PORT@":PORT
CASE FSEARCH.CN EQ 5
FSEARCH.SUFFIX = "@USER@":USER.ID
CASE FSEARCH.CN EQ 6
FSEARCH.SUFFIX = "@APPL@":APPL
CASE FSEARCH.CN
FSEARCH.SUFFIX = FSEARCH.PREFIX
END CASE
*
FKEY.ID = FSEARCH.PREFIX:FSEARCH.SUFFIX
FKEY.FOUND = FALSE
*
~SYS.INCL.FSEARCH.BOT~
* CODE.SEGMENT: SYS.INCL.FSEARCH.BOT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 01 OCT 87
* (c) Copyright 1987, 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
WHILE NOT(FKEY.FOUND) AND FSEARCH.CN LT FSEARCH.MAX DO
FSEARCH.CN = FSEARCH.CN + ONE
REPEAT
*
~SYS.INCL.LOG.ENTRY~
* CODE.SEGMENT: SYS.INCL.LOG.ENTRY
*
* AUTHOR: DAVID HORSMAN
*
* DATE WRITTEN: 25 JAN 90
*
* (c) Copyright 1990
* MACROSCOPE DESIGN MATRIX
*
*# Load the error log record
EL.ID = "LOG":EL.SUFFIX
IF EL.CN THEN
TMP = (100000+EL.CN)[2,5]
EL.ID = EL.ID:"@":TMP
END
READ ERR.LOG FROM PAR.FILE,EL.ID THEN EL.FOUND = TRUE ELSE EL.FOUND = FALSE; ERR.LOG = ""
*
IF LEN(ERR.LOG) + LEN(EL.DATA) GE 2000 THEN
EL.CN = EL.CN + 1
FKEY.ID = "LOG.CN":EL.SUFFIX
WRITE EL.CN ON PAR.FILE,FKEY.ID
*
EL.ID = "LOG":EL.SUFFIX
TMP = (100000+EL.CN)[2,5]
EL.ID = EL.ID:"@":TMP
ERR.LOG = EL.DATA
END ELSE
ERR.LOG<-ONE> = EL.DATA
END
*
*# Write error log
WRITE ERR.LOG ON PAR.FILE,EL.ID
*
~SYS.INCL.USER.SET~
USER.ID = "USER@":ACCT:"@":PORT; APPL = "PICKTR"
~TEMP9~
PICKTR.SET.ONE.SUB
SYS.SUBR.FILE.STAT
SYS.INPUT.CLEAR
SYS.SUBR.SYSTEM.NAME
SYS.SUBR.SYSTEM.TYPE
SYS.COMM.WAIT.QUIET.SUB
SYS.LOG.ENTRY.SUB
PICKTR.HEADER.SUB
PICKTR.DETAIL.SUB
PICK.TRANSFER.SUB
PICK.TRANSFER
~TEMP10~
STANDARD.FUNCTIONS.CHARACTERS
STANDARD.CHARACTERS
SYS.INCL.PICKTR.EQU
SYS.INCL.PICKTR.INIT
SYS.INCL.CONV.TO.HEX
SYS.INCL.CONV.TO.TXT
SYS.INCL.PICKTR.HEADER
SYS.INCL.PICKTR.DETAIL
SYS.INCL.PICKTR.COMMANDS
SYS.INCL.PICKTR.JOB.LOAD
SYS.INCL.SCHED.CHECK
SYS.INCL.SCHED.CHECK.READ
SYS.INCL.ABORT.CHECK
SYS.INCL.ABORT.CHECK.READ
SYS.INCL.QUIET.WRITE
SYS.INCL.QUIET.LOAD
SYS.INCL.QUIET.READ
SYS.INCL.COMM.WAIT.QUIET
SYS.INCL.FSEARCH.TOP
SYS.INCL.FSEARCH.BOT
SYS.INCL.LOG.ENTRY
SYS.INCL.USER.SET
TEMP9
TEMP10
SYS.INCL.LOAD.LINE.CONT
SYS.INCL.CALC.CHK.SUM
SYS.INCL.PORT.OUT
SYS.INCL.PORT.INP
~SYS.INCL.LOAD.LINE.CONT~
*CODE.SEGMENT: SYS.INCL.LOAD.LINE.CONT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: FEB 88, INCL CREATED: 21 JUN 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*# NOTE: The following formulas using hex flag leave max.len the same or
*# divide it by two.
LINE.LEN = LINE.MAX.LEN; IF HEX.ON THEN LINE.LEN = LINE.LEN / TWO + ONE
*IF LEN(LINE) GT LINE.LEN THEN
TEMP = EMPTY
LOOP WHILE LEN(LINE) DO
IF LEN(TEMP) THEN
TEMP = TEMP:AM:CONT.MESSAGE:AM:LINE[ONE,LINE.LEN]
END ELSE TEMP = LINE[ONE,LINE.LEN]
LINE = LINE[LINE.LEN+ONE,HI.NUM]
REPEAT
IF LEN(LINE.CONT) THEN LINE.CONT = AM:LINE.CONT
LINE.CONT = TEMP:LINE.CONT
*LINE = LINE.CONT<ONE>; DEL LINE.CONT<ONE,ZERO,ZERO>; LINE.IS.HEX = FALSE
*END; *# of line too long
*
~SYS.INCL.CALC.CHK.SUM~
*CODE.SEGMENT: SYS.INCL.CALC.CHECK.SUM
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: FEB 88, INCL CREATED: 21 JUN 90
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
TC.CN = ZERO
CHK.SUM = ZERO
TC.MAX = LEN(LINE)
LOOP
TC.CN = TC.CN + ONE
WHILE TC.CN LE TC.MAX DO
CHK.SUM = CHK.SUM + SEQ(LINE[TC.CN,ONE])
*SPOT TO SUB
REPEAT
PKT.OK = TRUE
IF DIR.FLAG EQ DIN THEN CHK.SUM.PREV = CHK.SUM
*
~SYS.INCL.PORT.OUT~
*CODE.SEGMENT: SYS.INCL.PORT.OUT
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 23 SEP 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
*
TMP = ERR.CN
IF TMP GT ERR.HI THEN TMP = ERR.HI
IF TMP LT ERR.LOW THEN TMP = ERR.LOW
TMP = TMP + ERR.OUT.OFFSET
IF TMP LT ONE THEN TMP = ONE
CHAR.PAUSE = (TMP-ONE) * (ONE+TMP/20)
TC = ZERO
*
LOOP
*
TC = TC + ONE
TC.CHAR = LINE.PACKET[TC,ONE]
*
WHILE LEN(TC.CHAR) DO
*
TC.SEQ = SEQ(TC.CHAR)
*
IF FILTER.OUT.MODE THEN
*
LOCATE TC.SEQ IN FILTER.OUT.STR<ONE,TWO> SETTING FILTER.OUT.STR.LOC THEN
TC.CHAR = CHAR(FILTER.OUT.STR<ONE,3,FILTER.OUT.STR.LOC>)
END
*
END ELSE
IF TC.SEQ GE 252 THEN TC.CHAR = CHAR(TC.SEQ-224); IF NOT(ERR.LOW) THEN ERR.LOW = ONE
END
*
PRINT TC.CHAR:
*
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT CHAR.PAUSE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
*
REPEAT
*
~SYS.INCL.PORT.INP~
*CODE.SEGMENT: SYS.INCL.PORT.INP
* AUTHOR: DAVID HORSMAN
* DATE WRITTEN: 23 SEP 88
* (c) Copyright 1988, 1989, 1990
* MACROSCOPE DESIGN MATRIX
*
IF ACK.RSP NE "GO" THEN ACK.RSP = EMPTY; ACK.RSP.LEN = ZERO
SAVE.ACK.RSP = EMPTY; VALID.PKT = FALSE; ERR.RECORDED = FALSE
INP.CN = ZERO; ERR.INC = ONE; INP.EXIT = FALSE
*
LOOP
*
PAUSE.CYC = ZERO
*
IF (DIR.FLAG EQ DOUT OR NOT(BLOCK.MODE)) AND NOT(DIR.FLAG EQ DOUT AND ACK.RSP EQ "GO") THEN
*
TMP = ERR.CN
IF DIR.FLAG EQ DOUT THEN TMP = INT(TMP / TWO)
IF TMP LE ERR.LOW THEN TMP = ERR.LOW
IF TMP GT ERR.HI AND ERR.HI THEN TMP = ERR.HI
TMP = TMP + ERR.IN.OFFSET
CHAR.PAUSE = TMP * (ONE + TMP / 10) * 10
*
LOOP
*
PAUSE.CYC = PAUSE.CYC + ONE
*
ACK.CHAR.CN = SYSTEM(ELEVEN); * ULT ONLY
*%%MDD%%=ACK.CHAR.CN = SYSTEM(14)
*
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT CHAR.PAUSE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
IF PAUSE.CYC GT 47 THEN RQM; * IF DIR.FLAG EQ DOUT THEN RQM
*
ACK.CHAR.CN1 = SYSTEM(ELEVEN); * ULT ONLY
*%%MDD%%=ACK.CHAR.CN1 = SYSTEM(14)
*
WHILE PAUSE.CYC LE 50 AND ((ACK.CHAR.CN NE ACK.CHAR.CN1 OR ACK.CHAR.CN1 LT 4) AND NOT(VALID.PKT)) AND ACK.CHAR.CN1 LT LINE.MAX.LEN + 15 DO REPEAT
*
END ELSE ACK.CHAR.CN1 = LINE.MAX.LEN
*
INP.CN = INP.CN + ONE
*
IF PAUSE.CYC LT 50 AND NOT(DIR.FLAG EQ DOUT AND ACK.RSP EQ "GO") THEN
*
IF ACK.CHAR.CN1 GT 4 THEN
*
INPUT ACK.RSP,ACK.CHAR.CN1 - ONE:
*
IF FILTER.IN.MODE THEN
*
TC.SVM.MAX = DCOUNT(FILTER.IN.STR<ONE,TWO>,SVM)
*
FOR TC.SVM = ONE TO TC.SVM.MAX
*
TC.CHAR.ORIG = CHAR(FILTER.IN.STR<ONE,TWO,TC.SVM>)
TC.CHAR.REPL = FILTER.IN.STR<ONE,3,TC.SVM>
IF LEN(TC.CHAR.REPL) THEN TC.CHAR.REPL = CHAR(TC.CHAR.REPL)
*
LOOP TC.CHAR.LOC = INDEX(ACK.RSP,TC.CHAR.ORIG,ONE) WHILE TC.CHAR.LOC DO
ACK.RSP = ACK.RSP[ONE,TC.CHAR.LOC - ONE]:TC.CHAR.REPL:ACK.RSP[TC.CHAR.LOC + ONE,HI.NUM]
REPEAT
*
NEXT TC.SVM
*
END
*
ACK.RSP.LEN = LEN(ACK.RSP)
ACK.CHAR.CN = ACK.CHAR.CN1 - ACK.RSP.LEN
*
IF ACK.RSP.LEN LT ACK.CHAR.CN1 - 4 THEN ERR.INC = -ONE ELSE ERR.INC = ONE
*
IF EL.TRACE GE 8 OR EL.TRACE.IN OR (EL.TRACE.CN AND ERR.CN GT ERR.LOW + ERR.REPEAT.HI) THEN
IF EL.TRACE EQ 8 AND NOT(EL.TRACE.IN) AND NOT(EL.TRACE.CN AND ERR.CN GT ERR.LOW + ERR.REPEAT.HI) THEN
EL.DATA = FIELD(ACK.RSP,ESC,ONE)
END ELSE EL.DATA = ACK.RSP
IF LEN(EL.DATA) THEN
EL.DATA = WHO:".":DATE():".":OCONV(TIME(),"MTS"):".":CN:">":EL.DATA
CALL SYS.LOG.ENTRY.SUB(PAR.FILE,EL.TRACE,EL.CLASS,EL.DATA,EL.SUFFIX,EL.CN)
ERR.RECORDED = TRUE
END
END
*
TC = ACK.RSP[ONE,ONE]
*
LOOP UNTIL TC EQ EMPTY OR SEQ(TC) DO
ACK.RSP = ACK.RSP[TWO,HI.NUM]
TC = ACK.RSP[ONE,ONE]
REPEAT
*
IF (ACK.RSP EQ "OFF" OR ACK.RSP EQ "KILL") THEN
IF MAIN.FLAG EQ MASTER THEN STAT = LOGOFF.COMAND ELSE STOP
END
*
LOOP UNTIL NOT(LEN(TC)) OR ACK.RSP EQ "GO" OR TC EQ ESC OR TC EQ "*" OR ACK.RSP[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE DO
ACK.RSP = ACK.RSP[TWO,HI.NUM]
TC = ACK.RSP[ONE,ONE]
REPEAT
*
ACK.RSP.LEN = LEN(ACK.RSP)
*
* Packet validation
IF DIR.FLAG EQ DIN AND ACK.RSP[ONE,TWO] EQ ESC:STB THEN 
ERR.INC = ZERO; SAVE.ACK.RSP = ACK.RSP; VALID.PKT = TRUE
*
END ELSE IF ACK.RSP[ONE,TWO] EQ ESC:"Y" THEN 
ERR.INC = ZERO; SAVE.ACK.RSP = ACK.RSP; VALID.PKT = TRUE
*
END ELSE IF TC EQ "*" THEN 
ERR.INC = TWO; ACK.RSP = SAVE.ACK.RSP
PRINT CR:"G":CR:
*
END ELSE IF ACK.RSP[ONE,LEN(PERR.MESSAGE)] EQ PERR.MESSAGE THEN
ERR.INC = ZERO; ACK.RSP = SAVE.ACK.RSP
LINE.MESSAGE = ACK.RSP; GOSUB PACKET.ERROR.RECVD
*
END ELSE IF VALID.PKT THEN
ERR.INC = ZERO; ACK.RSP = SAVE.ACK.RSP
END
*
END; * GT 4
*
* Loop back for bad block
*
END; * OF PAUSE.CYC LT 50
*
ACK.CHAR.CN1 = SYSTEM(ELEVEN); * ULT ONLY
*%%MDD%%=ACK.CHAR.CN1 = SYSTEM(14)
* ACK.CHAR.CN1 = ZERO; * REV ONLY
*
UNTIL ACK.RSP EQ "GO" OR (PAUSE.CYC GT 50 OR INP.CN GT 30 OR INP.EXIT) OR (ACK.CHAR.CN1 LE 4 AND (VALID.PKT OR ACK.CHAR.CN EQ ACK.CHAR.CN1)) OR STAT EQ MAX.ERR.ABORT.VRF DO
*
IF ACK.CHAR.CN1 GT 4 AND VALID.PKT THEN ERR.INC = -ONE ELSE
IF NOT(VALID.PKT) THEN ERR.INC = ONE
END
IF ERR.CN + ERR.INC GT ERR.LOW AND ERR.CN + ERR.INC LT ERR.HI THEN
ERR.CN = ERR.CN + ERR.INC; ERR.CN.LAST = ERR.CN.LAST.HI
END
*IF ERR.IN.OFFSET + ERR.INC GT ERR.LOW AND ERR.IN.OFFSET + ERR.INC LT ERR.HI THEN ERR.IN.OFFSET = ERR.IN.OFFSET + ERR.INC
IF ERR.CN GE ERR.MAX AND ERR.CN.ALL GE ERR.MAX.ALL THEN STAT = MAX.ERR.ABORT.VRF
*
REPEAT
*
