~DUMMY~
*PROGRAM: DUMMY
*
PRINT "DUMMY"
*
*
END
~GEN.LIST~
*PROGRAM: GEN.LIST
*
SYS.PROG = "GEN.LIST"
SYS.LOCT = "1"
SYS.SLOC = ""
SYS.PROG.DESC = "List Generate Utility"
$INCLUDE IBP STANDARD.FUNCTIONS
*
*@* DIM STATEMENTS *@*
SYS.LOCT = "2"
DIM EXEC(20); MAT EXEC = ""
*
*@* OPEN STATEMENTS *@*
E.START.DATE = DATE(); E.START.TIME = TIME()
OPEN "SYS.STRUCTURE" TO SY.FILE ELSE ERROR = 1; GOSUB ERROR.RTN; STOP
*
*
PRINT @(0,5):CLS:(SPACE(40-LEN(SYS.PROG.DESC)/2):RVB:SYS.PROG.DESC:RVE) "L#60":
PRINT @(0,7):'USER: ':; INPUT E.USER:; PRINT @(7,7):E.USER:
PRINT @(40,7):'LIST: ':; INPUT E.LIST:; PRINT @(47):E.LIST
PRINT @(0,9)'FILE: ':; INPUT E.FILE:; PRINT @(7,9):E.FILE
* USER, LIST, AND LISTS FILE.
*
*
READ E.DATA FROM SY.FILE,"@E.PARAM@GEN.LIST@":E.FILE THEN
E.DATA<1> = E.USER; * USER EXECUTING GENERATE LIST
E.DATA<2> = E.LIST; * NAME OF LIST TO GENERATE
E.DATA<3> = E.FILE; * NAME OF LISTS FILE
E.FILA = E.DATA<4>; * ATTRIBUTE WITH THE FILE NAME THE LIST ACCESSES
E.SORA = E.DATA<5>; * ATTRIBUTE OF SORT FIELD NAMES
E.ETYP = E.DATA<5>; * ATTRIBUTE OF ENTITY TYPES VALIDATION FIELD
E.SELA = E.DATA<6>; * ATTR FOR SELECTION FIELDS/OPERATIONS/VALUES
E.TIMA = E.DATA<7>; * ATTR FOR EXECUTION DATE & TIME TAKEN
E.USE.ET = E.DATA<8>; * USE ENTITY.TYPES IN GENERATION
PR.PARAM = E.DATA<9>; * Print parameters
IN.PARAM = 0; * Input these parameters
END ELSE
*
ERROR = 2
GOSUB ERROR.RTN
E.FILA = ""; E.SORA = ""; E.ETYP = ""; E.SELA = ""
E.TIMA = ""; E.TIMA = ""; E.USE.ET = ""; PR.PARAM = 0; IN.PARAM = 1
END
*
IF PR.PARAM ! IN.PARAM THEN
PRINT@(0,11):'FILA: ':
IF IN.PARAM THEN INPUT E.FILA:
PRINT @(7):E.FILA
*
PRINT @(10,11):'SORA: ':
IF IN.PARAM THEN INPUT E.SORA:
PRINT @(17):E.SORA
*
PRINT @(20,11):'ETYP: ':
IF IN.PARAM THEN INPUT E.ETYP:
PRINT @(27):E.ETYP
*
PRINT @(30,11):'SELA: ':
IF IN.PARAM THEN INPUT E.SELA:
PRINT @(37):E.SELA
*
PRINT @(40,11):'TIMA: ':
IF IN.PARAM THEN INPUT E.TIMA:
PRINT @(47):E.TIMA
*
PRINT @(50,11):'USE ET? ':
IF IN.PARAM THEN INPUT E.USE.ET:
PRINT @(59):E.USE.ET
END
*
E.START.DATE = DATE(); E.START.TIME = TIME()
*
OPEN E.FILE TO LS.FILE ELSE ERROR = 4; GOSUB ERROR.RTN; STOP
*
*
MATREAD EXEC FROM LS.FILE,E.LIST ELSE ERROR = 5; GOSUB ERROR.RTN; STOP
*
* FILE SELECTION
*
E.LINE = 'SELECT'
FILE.NAME = EXEC(E.FILA)
IF FILE.NAME = '' OR FILE.NAME = ' ' THEN ERROR = 6; GOSUB ERROR.RTN; GOSUB INPUT.FILE.NAME
* DICTIONARY
DICT.OPT = 1
OPEN 'DICT ':FILE.NAME TO DC.FILE ELSE ERROR = 3; GOSUB ERROR.RTN; DICT.OPT = 0
* START LINE
E.LINE = E.LINE:' ':FILE.NAME
*
* SORTING CRITERIA
*
IF EXEC(E.SORA) = ' ' OR EXEC(E.SORA) = '' THEN NULL ELSE
CN = 0
CONT = 1
LOOP
CN = CN + 1
IF LEN(E.LINE) > 140 THEN ERROR = 7; GOSUB ERROR.RTN; CONT = 0
E.SORT = EXEC(E.SORA)<1,CN>
WHILE CONT = 1 & E.SORT # ' ' & E.SORT # '' DO
EXECSORT = ''
IF DICT.OPT = 0 THEN
EXECSORT = E.SORT
END ELSE
READV EXECSORT FROM DC.FILE,E.SORT,2 ELSE EXECSORT = E.SORT
END
IF EXECSORT # '0' THEN E.LINE = E.LINE:' BY ':EXECSORT
REPEAT
IF CN > 1 THEN E.LINE = 'S':E.LINE
END
*
* SELECTION
*
* ENTITY.TYPES
*
EXECETYC = ''
E.ETYC = 'ET'
IF DICT.OPT = 0 THEN
EXECETYC = E.ETYC
END ELSE
READV EXECETYC FROM DC.FILE,E.ETYC,2 ELSE EXECETYC = E.ETYC
END
CN = 0
CONT = 1
LOOP
CN = CN + 1
IF LEN(E.LINE) > 140 THEN ERROR = 8; GOSUB ERROR.RTN; CONT = 0
WHILE CONT = 1 & EXEC(E.ETYP)<1,CN> # ' ' & EXEC(E.ETYP)<1,CN> # '' DO
IF CN = 1 THEN
E.LINE = E.LINE:' WITH ':EXECETYC:' = "':EXEC(E.ETYP)<1,CN>:'"'
END ELSE
E.LINE = E.LINE:' OR ':' = "':EXEC(E.ETYP)<1,CN>:'"'
END
REPEAT
*
* SELECTION
*
* FIELD OPERAND VALUE
*
CN1 = 0
CONT = 1
LOOP
CN1 = CN1 + 1
IF LEN(E.LINE) > 140 THEN ERROR = 9; GOSUB ERROR.RTN; CONT = 0
E.TEST = EXEC(E.SELA)<1,CN1,1>:EXEC(E.SELA)<1,CN1,2>:EXEC(E.SELA)<1,CN1,3>
FOR A = 1 TO 10
IF E.TEST[1,1] = ' ' THEN E.TEST = E.TEST[2,99]
NEXT A
WHILE CONT = 1 & E.TEST # ' ' & E.TEST # '' DO
E.SELC = EXEC(E.SELA)<1,CN1,1>
EXECSELC = ''
IF DICT.OPT = 0 THEN
EXECSELC = E.SELC
END ELSE
READV EXECSELC FROM DC.FILE,E.SELC,2 ELSE EXECSELC = E.SELC
END
IF CN > 1 AND CN1 = 1 THEN E.LINE = E.LINE:' AND' ELSE
IF CN1 > 1 THEN E.LINE = E.LINE:' OR'
END
IF E.SELC # ' ' & E.SELC # '' THEN
E.LINE = E.LINE:' WITH ':EXECSELC
END
E.LINE = E.LINE:' ':EXEC(E.SELA)<1,CN1,2>:' "':EXEC(E.SELA)<1,CN1,3>:'"'
REPEAT
*
*
* WRITE TO PROC
*
*WRITEV 'H':E.LINE ON PROCFILE,"GEN.LIST.PROC",11
*WRITEV 'H':EXEC(E.FILA) ON PROCFILE,"GEN.LIST.PROC",15
*WRITEV 'H@LIST@':E.LIST ON PROCFILE,"GEN.LIST.PROC",18
*CN = 0
*LOOP CN = CN + 1 WHILE EXEC(E.TIMA)<1,CN,1> # '' DO REPEAT
*EXEC(E.TIMA)<1,CN> = DATE():SVM:E.USER:SVM:0:SVM:TIME()
*
*
E.NAME.OF.LIST = '@LIST@':E.LIST
*
*
PRINT @(0,13):"Executing command: ":E.LINE; PRINT
EXECUTE E.LINE, //OUT. > E.RESULT
*
*
IF LEN(E.RESULT) = 0 THEN
PRINT @(0,14):CLL:E.RESULT:
PRINT @(0,15):CLL:'Moving to list file.'
E.COL = FIELD(E.RESULT,' ',1)
CONT = 1
E.LIST.CHAIN = ''
CN = 0
LOOP
READNEXT E.LIST.NEXT ELSE CONT = 0
WHILE CONT = 1 DO
E.LIST.CHAIN = E.LIST.CHAIN:E.LIST.NEXT:AM
CN = CN + 1
IF CN - INT(CN/25) * 25 = 0 THEN PRINT @(0,17):CLL:CN "R#3":" - ":
PRINT '*':
REPEAT
E.COL = CN
WRITE E.LIST.CHAIN ON LS.FILE,E.NAME.OF.LIST
END ELSE
ERROR = 10
PRINT @(0,21):BELL:'I encountered an error ':E.USER:'.':
PRINT @(0,22):'The message was: ':E.RESULT<1>:'.':
IF E.RESULT<2> # '' THEN PRINT @(0,23):'                 ':E.RESULT<2>:'.':
FOR TEMP = 1 TO 10; RQM; NEXT TEMP
PRINT @(0,20):'I must terminate. Please check your List Criteria.':BELL:
GOSUB ERROR.RTN
END
E.END.DATE = DATE(); E.END.TIME = TIME()
IF E.END.DATE # E.START.DATE THEN
E.TIME = 86400 - E.START.TIME + E.END.TIME
END ELSE
E.TIME = E.END.TIME - E.START.TIME
END
CN = 0
LOOP CN = CN + 1 WHILE EXEC(E.TIMA)<1,CN,1> # '' DO REPEAT
EXEC(E.TIMA)<1,CN> = E.START.DATE:SVM:E.USER:SVM:E.COL:SVM:E.TIME
IF ERROR < 4 THEN MATWRITE EXEC ON LS.FILE,E.LIST
PRINT @(0,19):BELL:'Date: ':OCONV(E.START.DATE,'D'):'.  Time to execute (Minutes:Seconds): ':OCONV(E.TIME,'MTS')[4,99]:
PRINT @(0,21):CLS:@(0,23):'Hit <CR> to return to menu.':; INPUT A$:
GOTO End.of.program
*
*
*
INPUT.FILE.NAME: *@* FILE INPUT SUBROUTINE
PRINT @(0,21):CLS:@(0,23):'What is the file to be processed? ':
INPUT FILE.NAME:
IF FILE.NAME # '' THEN RETURN
GOTO INPUT.FILE.NAME
*
*
ERROR.RTN: *@* ERROR HANDLING
PRINT @(0,20):CLS:@(0,23):BELL:'Error ':ERROR:'.':
RQM; RQM
RQM; RQM
RETURN
*
End.of.program: *
END
*
~LI.CLOSE.INCL~
*CODE.SEGMENT: LI.CLOSE.INCL
*
MATWRITE SLIST.CNTRL ON LST.FILE,LST.NAME
*
* LST.ID = SLIST.CNTRL$ITEMS<ONE,ONE>
*
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
*
*
~LI.DELETE~
*PROGRAM: LI.INS.DELETE
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*
$INCLUDE IBP SLIST.CNTRL.DIM
*
*
$INCLUDE IBP LI.INIT.INCL
*
LST.ON.FILE = FALSE
*
LOOP
*
LOOP
*
PRINT CLB:"Enter list name to DELETE: ":; INPUT LST.NAME
*
IF LEN(LST.NAME) THEN
*
$INCLUDE IBP LI.OPEN.INCL
*
END; * of len lst.name
*
WHILE NOT(LST.ON.FILE) AND LEN(LST.NAME) DO
*
PRINT CLB:BELL:"List ":LST.NAME:" was not found, enter <CR>! ":; INPUT RSP:
*
REPEAT
*
IF LST.NAME NE EMPTY THEN
*
PRINT CLB: "Are you sure (Y/<cr>)? ":; INPUT RSP:
*
IF RSP EQ "Y" THEN
*
LOOP WHILE LEN(SLIST.CNTRL$ITEMS) DO
LST.ID = SLIST.CNTRL$ITEMS<ONE,ONE>
DELETE LST.FILE,LST.NAME:"+":LST.ID
DEL SLIST.CNTRL$ITEMS<ONE,ONE>
PRINT CLB:LST.NAME:" ":LST.ID:
REPEAT
DELETE LST.FILE,LST.NAME
*
PRINT CLB:"List has been deleted, enter <cr>! ":; INPUT RSP:
*
END; * of Y
*
END; * of not empty list
*
WHILE LST.NAME NE EMPTY DO PRINT CLB: REPEAT
*
END
~LI.DISP.LI.SUB~
SUBROUTINE LI.DISP.LI.SUB(LST.FILE,LST.ID,LST,SLIST.CNTRL.ID,MAT SLIST.CNTRL,PAR.FILE,LCK.FILE,LST.ITEM.ID.SAVE,GENERIC,CO.DATA,DISP.ONLY,AUTO.RUN,SYS.TST,REDISP,STAT,LST.LOC,LST.LOC.MAX,LST.ID.LOC,LST.ID.LOC.MAX,LST.SEL)
*PROGRAM:     SH.LI.DISP.LI
*AUTHOR:       XXX
*DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                               (Axion)       (Macroscope)
*UTILITY PRODUCT BY Axion Computer Systems
*                            &
*                Macroscope Design Matrix
*                                                                           
!
*
*DATE WRITTEN:    06 OCT 91
*DATE RELEASED:   DD MMN YY
*MODIFICATIONS:   DATE    NAME    DESCRIPTION
*                 DD MMM YY
!
*
*INPUT.LNS*
* INPUT DISP.ONLY:
* INPUT AUTO.RUN:
* INPUT GENERIC:
* INPUT.END*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP CURSOR.EQUATES
*
SCR.ID = "LI.DISP.LI"
RELEASE.ID = "1.0"; LST.SEL = FALSE; UPDATED = FALSE
REF = ONE; REDISP = FALSE; PRINTER.FLAG = FALSE; NEW = FALSE
*
*
*DIM.LNS*
$INCLUDE IBP SLIST.CNTRL.DIM
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*EQU.END*
*
*OPEN.LNS
*OPEN.END*
*
*SCR.LNS*
*SUB.LNS*
* PORT.KEY = PORT
* LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
* READ GENERIC FROM PAR,FILE,"GENRIC.":PORT.KEY REPEAT
* READ CO.DATA FROM CNT.FILE,"CO,DATA"ELSE CO.DATA = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
IF NOT(GENERIC) THEN
READ POS.LOC FROM PAR.FILE,"CURSOR.LI.DISP.LI" ELSE POS.LOC = EMPTY
READ POS.REF FROM PAR.FILE,"*REF.LI.DISP.LI" ELSE POS.REF = EMPTY
READ POS.STR FROM PAR.FILE,"*CURSOR.STRING" ELSE POS.STR = EMPTY
END
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
VC = EMPTY; SC = EMPTY; LN.LOC = ONE; OLD.LN = LN.LOC + 3; LN.LOC.FIRST = TRUE
LN = ZERO; CL = ZERO; CL.LOC = one
CL.FORST = FALSE; * ; CL.FIRST = TRUE
OLD.CL = ZERO; CL.LOC = ONE; CLEAR = FALSE
IF NOT(GENERIC) THEN
POS.CN.MAX = DCOUNT(POS.LOC,AM)
LOOP UNTIL LN + ONE GE POS.CN.MAX OR POS.LOC<LN + ONE> NE EMPTY DO LN = LN + ONE REPEAT
CL = POS.LOC<LN + ONE,CL.LOC>
END
LST.RUN.TYPE = TWO; LST.END = FALSE
*INIT.END*
*
*
*REF.LNS*
DIM TOP.DISP.LOC(1)
VALID.REFS = "ID"
*REF.END*
*
!
*
*MAIN.LNS*
*
STAT = EMPTY
NEXT.ITEM: *
GOSUB DISP.BG
IF NOT(DISP.ONLY) THEN CALL LOCK.ITEM(LST.FILE,"LST",SLIST.CNTRL.ID:"":LST.ID,LCK.FILE,STAT)
IF STAT THEN GOTO UNLOCK
GOSUB DISP.FG; IF STAT THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB:"Enter R(edisplay), H(ard copy) or <CR> to end: ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
WHILE RSP NE EMPTY DO
IF RSP EQ "R" THEN
**v
LST.LOC = ONE; LST.ID.LOC = ONE; LST.END = FALSE
$INCLUDE IBP LI.READL.INCL
MAT TOP.DISP.LOC = EMPTY
**^
GOSUB DISP.BG
REDISP = TRUE
GOSUB DISP.FG
END ELSE IF RSP EQ "H" THEN
PRINTER.FLAG = TRUE
GOSUB DISP.LP
PRINTER.FLAG = FALSE
END
REPEAT
GOTO FINISH
END
*
!
*
CHANGES: *
IF NOT(LST.SEL OR STAT) THEN
TEXT = "Enter S(elect), R(edisplay), H(ard copy), KILL or <CR> to end: "
PRINT CLB:TEXT:
IF GENERIC THEN
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
END ELSE
RSP.LN = 23; RSP.CL = LEN(TEXT) + ONE; RSP = EMPTY
$INCLUDE IBP CURSOR.POS.LOC
END
END ELSE RSP = EMPTY
*
*
BEGIN CASE
*
CASE RSP EQ "KILL"; GOTO UNLOCK
*
CASE RSP EQ "END"; GOTO UNLOCK
*
CASE RSP EQ EMPTY; GOTO UPDATE
*
CASE RSP EQ "R"
**v
LST.LOC = ONE; LST.ID.LOC = ONE; LST.END = FALSE
$INCLUDE IBP LI.READL.INCL
MAT TOP.DISP.LOC = EMPTY
LST.LOC = ONE
**^
GOSUB DISP.BG
REDISP = TRUE
GOSUB DISP.FG
*
CASE RSP EQ "H"
PRINTER.FLAG = TRUE
GOSUB DISP.LP
PRINTER.FLAG = FALSE
*
CASE RSP EQ "S"; REF = ONE; GOSUB GET.DATA
*
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
*
END CASE
*
*
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*
!
*
UPDATE: *
* IF UPDATED THEN LDT.SEL = TRUE
* IF NOT(STAT) THEN
* *
* END
*
!
*
UNLOCK: *
CALL UNLOCK.ITEM(LST.FILE,"LST",LST.ID,LCK.FILE)
IF STAT THEN LST.SEL = FALSE
*
!
*
FINISH: *
*
*FIN.LNS*
* STOP
RETURN
*FIN.END*
*MAIN.END*
*
!
*
DISP.BG: *
MAT TOP.DISP.LOC = EMPTY
PRINT @(0,3):CLS:"":RVB:"ID> Item                       ":RVE:"":
RETURN
!
DISP.FG: *
*
DYN = EMPTY; GOSUB D01; IF STAT EQ 999 THEN GOTO UNLOCK
REDISP = FALSE
*
RETURN
*
!
*
DISP.LP: *
*
IF PRINTER.FLAG THEN
PRINTER ON
END
*
IF PRINTER.FLAG THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALES
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT
PRINT
PRINT "ID>Item" "L#39"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 0)):TOP.DISP.LOC(1) + 0:" ":LST<TOP.DISP.LOC(1) + 0> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 1)):TOP.DISP.LOC(1) + 1:" ":LST<TOP.DISP.LOC(1) + 1> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 2)):TOP.DISP.LOC(1) + 2:" ":LST<TOP.DISP.LOC(1) + 2> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 3)):TOP.DISP.LOC(1) + 3:" ":LST<TOP.DISP.LOC(1) + 3> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 4)):TOP.DISP.LOC(1) + 4:" ":LST<TOP.DISP.LOC(1) + 4> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 5)):TOP.DISP.LOC(1) + 5:" ":LST<TOP.DISP.LOC(1) + 5> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 6)):TOP.DISP.LOC(1) + 6:" ":LST<TOP.DISP.LOC(1) + 6> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 7)):TOP.DISP.LOC(1) + 7:" ":LST<TOP.DISP.LOC(1) + 7> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 8)):TOP.DISP.LOC(1) + 8:" ":LST<TOP.DISP.LOC(1) + 8> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 9)):TOP.DISP.LOC(1) + 9:" ":LST<TOP.DISP.LOC(1) + 9> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 10)):TOP.DISP.LOC(1) + 10:" ":LST<TOP.DISP.LOC(1) + 10> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 11)):TOP.DISP.LOC(1) + 11:" ":LST<TOP.DISP.LOC(1) + 11> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 12)):TOP.DISP.LOC(1) + 12:" ":LST<TOP.DISP.LOC(1) + 12> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 13)):TOP.DISP.LOC(1) + 13:" ":LST<TOP.DISP.LOC(1) + 13> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 14)):TOP.DISP.LOC(1) + 14:" ":LST<TOP.DISP.LOC(1) + 14> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) + 15)):TOP.DISP.LOC(1) + 15:" ":LST<TOP.DISP.LOC(1) + 15> "L#35"
PRINT SPACE(4):SPACE(TWO - LEN(TOP.DISP.LOC(1) +  16)):TOP.DISP.LOC(1) + 16:" ":LST<TOP.DISP.LOC(1) + 16> "L#35"
!
*
*
IF PRINTER.FLAG THEN
PRINTER OFF
END
*
RETURN
*
!
*
GET.DATA: *
ON REF GOSUB I01
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
*
*not new
GOSUB D01; IF STAT EQ 999 THEN RETURN
DYN = TOP.DISP.LOC(1)
IF DYN THEN
LOOP
PRINT CLB:"Enter I(nsert),A(dd), D(elete), S(elect) or <CR> to continue: ":
INPUT DYN:; IF DYN EQ "KILL" THEN STAT = 999; RETURN
* IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "S" THEN
LST.SEL = TRUE
RETURN
END
UNTIL DYN EQ "I" OR DYN EQ "A" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
END
*
IF DYN EQ "D" THEN
LST.ITEM.ID = LST.ITEM.ID.SAVE
LST.FUNC = "D"; LST.END = FALSE
$INCLUDE IBP LI.INS.CALL.INCL
DYN = "D"; GOSUB D01; IF STAT EQ 999 THEN RETURN
GOTO I01
*
END ELSE IF DYN EQ "I" OR DYN EQ "A" THEN
* I or A
LST.ITEM.ID = LST.ITEM.ID.SAVE
LST.FUNC = " "; LST.END = FALSE
$INCLUDE IBP LI.INS.CALL.INCL
UPDATED = TRUE
IF DYN EQ "A" THEN
LST.LOC = LST.LOC + ONE
LN = LN + ONE
IF LN GT 20 THEN LN = 4
END
*
IF LST.LOC GT 9999 THEN IF NEW AND DYN EQ "A" THEN RETURN ELSE
TEXT = "Max entries allowed is 9999"; GOSUB ERROR; GOTO I01
END
*
INS " " BEFORE LST<LST.LOC>; * TEMP
DYN = "I"; GOSUB D01; IF STAT EQ 999 THEN RETURN
*
END; * of I or A
*
*GOSUB D01; IF STAT EQ 999 THEN RETURN
IF DYN EQ "I" OR DYN EQ "A" THEN
FOR SUB.REF = ONE TO 1
ON SUB.REF GOSUB I01A
IF STAT EQ 999 THEN RETURN
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO; IF SUB.REF LT ZERO THEN SUB.REF = ONE
STAT = FALSE
END
IF SUB.REF EQ ONE THEN IF RSP EQ EMPTY THEN RETURN
NEXT SUB.REF
END
*
IF DYN NE EMPTY THEN GOTO I01
*
RETURN
*
!
*
I01A: *
IF LST<LST.LOC> EQ " " THEN LST<LST.LOC> = EMPTY
LN = LN.LOC + 3
PRINT @(1,LN):SPACE(2-LEN(LST.LOC)):" ":
** CALL INPUT.DATA.SG("LST","<LST.LOC>",LST.ITEM.ID.SAVE,4,LN."L35",ONE,"OP",EMPTY,RSP,REDISP,STAT)
**v
* CALL "I"
CALL INPUT.DATA.SG("LST","<LST.LOC>",LST.ITEM.ID SAVE,4,LN,"L35","35",ONE," ","OP",EMPTY,RSP,REDISP,STAT); * TEMP
**^
IF RSP EQ EMPTY THEN IF DYN NE "A" THEN PRINT BELL:; GOTO I01A
RETURN
*
!
*
D01: *
*
GOSUB D01.TOP
TOP.LOC = EMPTY; TC = "N"; RSP = TC
*
LOOP
*
IF TC EQ "N" THEN
LN = 3; LST.LOC = LST.LOC - ONE
LOOP
LN = LN + ONE
IF LN LE 20 THEN
$INCLUDE IBP LI.READN.INCL
END
WHILE NOT(LST.END) AND LN LE 20 DO
IFLN EQ 4 THEN TOP.LOC = LST.LOC
IF LN - 3 EQ LN.LOC THEN
TMP = RVB
LST.ITE.ID.SAVE = LST<LST.LOC>; LN.LOC = 3; OLD.LN = LN.LOC + 3
END ELSE TMP = EMPTY
IF LEN(RSP) LE ONE THEN
PRINT @(1,LN):SPACE(TWO - LEN(LN - 3)):RVE:" ":TMP:LST<LST.LOC> "L#35":RVE:
END
REPEAT
IF LST.END AND LNLE 20 AND LN - 3 LE LN.LOC THEN
LST.ITEM.ID.SAVE = LST<LST.LOC>; LN.LOC = LN - 3; OLD.LN = LN.LOC + 3
END
END; * of TC is N
*
*IF  THEN RSP = EMPTY ELSE
*
RSP = RSP[TWO,9999]
IF RSP EMPTY THEN
PRINT CLB:"Enter N(ext), P(rev), R(edisplay) or <CR> to use this page:":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
END
*
TC = RSP[ONE,ONE]
IF TC EQ "N" THEN LST.LOC = LST.LOC + ONE
*
IF TC EQ "R" THEN
LST.LOC = ONE; LST.ID.LOC = ONE; LST.END = FALSE
$INCLUDE IBP LI.READL.INCL
MAT TOP.DISP.LOC = EMPTY
TC = "N"; RSP = TC:RSP[TWO,9999]
END
*
IF TC EQ "P" THEN
LST.LOC = LST.LOC - 34; LST.END = FALSE
LOOP WHILE LST.LOC LT ONE AND LST.ID.LOC GT ONE DO
LST.END = FALSE; LST.ID.LOC = LST.ID.LOC - ONE
$INCLUDE IBP LI.READL.INCL
LST.LOC = LST.LOC.MAX + LST.LOC
REPEAT
IF LST.LOC LT ZERO THEN
LN.LOC = LN.LOC + (17 + LST.LOC); OLD.LN = LN.LOC + 3
LST.LOC = ZERO; PRINT BELL:
END
TC = "N"; RSP = TC:RSP[TWO,9999]; LST.LOC = LST.LOC + ONE
END
*
IF RSP = "N" THEN LN = 4; GOSUB C01
*
IF LEN(RSP) GT 5 THEN RSP = RSP[ONE,5]
*
*END; * of not top.disp.loc
*
WHILE LEN(RSP) DO REPEAT
*
*
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
*
RETURN
*
!
*
C01:  *
*
FOR LN = LN TO 20
PRINT @(1,LN):SPACE(38):
NEXT LN
RETURN
*
!
*
D01.TOP: *
*
IF TOP.DISP.LOC(1) THEN
LST.LOC = LST.LOC - 17
CLEAR = TRUE
END ELSE
*IF NOT(LN.LOC.FIRST) THEN
*CLEAR = TRUE; LN.LOC = 8; OLD.LN = LN.LOC + 3
*LST.LOC = LST.LOC - 8
*END
LST.LOC = LST.LOC - 1
LN.LOC.FIRST = FALSE
END
LST.LOC = LST.LOC + ONE; LST.END = FALSE
LOOP WHILE LST.LOC LT ONE AND LST.ID.LOC GT ONE DO
LST.ID.LOC = LST.ID.LOC - ONE
$INCLUDE IBP LI.READL.INCL
LST.LOC = LST.LOC.MAX + LST.LOC
REPEAT
IF LST.LOC LT ONE THEN
PRINT BELL:
*LN.LOC = LN.LOC + (17 + LST,LOC); OLD.LN = LN.LOC + 3
LN.LOC = LN.LOC + LST.LOC; OLD.LN = LN.LOC + 3
LST.LOC = ONE
END
*
RETURN
*
!
*
LI.INS.LBL: *
*
$INCLUDE IBP LI.INS.INCL
*
RETURN
*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE.80]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <CR> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
END
~LI.INIT.INCL~
*CODE.SEGMENT: LI.INIT.INCL
*
*INCLUDE IBP SLIST.CNTRL.EQUATES
*
*INCLUDE IBP SLIST.CNTRL.DIM
*
*
OPEN "SLIST" TO LST.FILE ELSE STOP
*
* LOAD LST.NAME!
*
*
~LI.INS.INCL~
*CODE.SEGMENT: LI.INS.INCL
*
LST.ID.LOC.MAX = DCOUNT(SLIST.CNTRL$ITEMS,VM)
LOCATE LST.ID IN SLIST.CNTRL$ITEMS<ONE> SETTING LST.ID.LOC ELSE NULL
*
SEQ = SLIST.CNTRL$SEQ[ONE,ONE]
*
IF SEQ EQ "A" THEN
LST.INC = -ONE
END ELSE
LST.INC = ONE
END
*
FIRST = TRUE
*
IF SLIST.CNTRL$SEQ NE EMPTY THEN
*
CONT = TRUE
LST.LOC.MAX = DCOUNT(LST.REC,AM)
*
LOOP
*
LOCATE LST.ITEM.ID IN LST.REC BY SLIST.CNTRL$SEQ SETTING LST.LOC THEN
*
IF LST.FUNC EQ "D" THEN
DEL LST.REC<LST.LOC>
END
CONT = FALSE
*
END ELSE
*
IF SLIST.CNTRL$SEQ[ONE,ONE] EQ "A" THEN
*
!
*
*Ascendins sequence
*
IF LST.LOC GT LST.LOC.MAX THEN
*
IF LST.INC LT ZERO THEN LST.INC = ONE
IF LST.ID.LOC GE LST.ID.LOC.MAX THEN
IF LST.FUNC EQ "A" THEN
INS LST.ITEM.ID BEFORE LST.REC<LST.LOC>
END
CONT = FALSE
END ELSE
IF FIRST THEN
FIRST = FALSE
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
IF TF THEN PRINT "W ":LST.NAME:"+":LST.ID
END
LST.ID.LOC = LST.ID.LOC + LST.INC
LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
READ LST.REC FROM LST.FILE,LST.NAME:"+":LST.ID ELSE LST.REC = EMPTY
IF TF THEN PRINT "R":LST.NAME:"+":LST.ID
LST.LOC.MAX = DCOUNT(LST.REC,AM)
END; * of LST.ID.LOC
*
END ELSE
*
IF LST.INC LT ZERO AND LST.LOC LE ONE AND LST.ID.LOC GT ONE THEN
IF FIRST THEN
FIRST = FALSE
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
IF TF THEN PRINT "W":LST.NAME:"+":LST.ID
END
LST.ID.LOC = LST.ID.LOC + LST.INC
LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
READ LST.REC FROM LST.FILE,LST.NAME:"+":LST.ID ELSE LST.REC = EMPTY
IF TF THEN PRINT "R":LST.NAME:"+":LST.ID
LST.LOC.MAX = DCOUNT(LST.REC,AM)
END ELSE
IF LST.FUNC EQ "A" THEN
INS LST.ITEM.ID BEFORE LST.REC<LST.LOC>
END
CONT = FALSE
END; * of -inc / inc
*
END; * of LST.LOC
*
END ELSE IF SLIST.CNTRL$SEQ[ONE,ONE] EQ "D" THEN
*
!
*
* Decending sequence
*
IF LST.LOC LE ONE THEN
*
IF LST.INC GT ZERO THEN LST.INC = -ONE
IF LST.ID.LOC LE ONE THEN
IF LST.FUNC EQ "A" THEN
INS LST.ITEM.ID BEFORE LST.REC<LST.LOC>
END
CONT = FALSE
END ELSE
IF FIRST THEN 
FIRST = FALSE
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
IF TF THEN PRINT "W":LST.NAME:"+":LST.ID
END
LST.ID.LOC = LST.ID.LOC + LST.INC
LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
READ LST.REC FROM LST.FILE,LST.NAME:"+":LST.ID ELSE LST.REC = EMPTY
IF TF THEN PRINT "R":LST.NAME:"+":LST.ID
LST.LOC.MAX = DCOUNT(LST.REC,AM)
END; * of LST.ID.LOC
*
END ELSE
*
IF LST.GT ZERO AND LST.LOC GE LST.LOC.MAX AND LST.ID.LOC LT LST.ID.LOC.MAX THEN
IF FIRST THEN
FIRST = FALSE
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
IF TF THEN PRINT "W":LST.NAME:"+":LST.ID
END
LST.ID.LOC = LST.ID.LOC + LST.INC
LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
READ LST.REC FROM LST.FILE,LST.NAME:"+":LST.ID ELSE LST.REC = EMPTY
IF TF THEN PRINT "R":LST.NAME:"+":LST.ID
LST.LOC.MAX = DCOUNT(LST.REC,AM)
END ELSE
IF LST.FUNC EQ "A" THEN
INS LST.ITEM.ID BEFORE LST.REC<LST,LOC>
END
CONT = FALSE
END; * of inc gt 0
END; *of LST.LOC
*
END; * of SEQ IS "Ax" OR "Dx"
*
END; * of LOC
*
WHILE CONT DO REPEAT
*
END ELSE
*
!
*
* Not in any sequence
*
CONT = TRUE
LST.LOC.MAX = DCOUNT(LST.REC,AM)
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
IF TF THEN PRINT "W":LST.NAME:"+":LST.ID
IF LST.FUNC EQ "D" THEN
LST.ID.LOC = ZERO
END ELSE
LST.ID.LOC = LST.ID.LOC.MAX
END
*
LOOP
*
IF LST.FUNC EQ "D" THEN LST.ID.LOC = LST.ID.LOC + ONE
LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
READ LST.REC FROM LST.FILE,LST.NAME:"+":LST.ID ELSE LST.REC = EMPTY
IF TF THEN PRINT "R":"+":LST.ID
LST.LOC.MAX = DCOUNT(LST.REC,AM)
*
IF LST.FUNC = "D" THEN
LOCATE LST.ITEM.ID IN LST.REC SETTING LST.LOC THEN
DEL LST.REC<LST.LOC>
CONT = FALSE
END; * of LOC
END ELSE IF LST.FUNC EQ "A" THEN
LST.REC<-ONE> = LST.ITEM.ID
CONT = FALSE
END; * of D or A
*
WHILE CONT AND LST.ID.LOC LT LST.ID.LOC.MAX DO REPEAT
*
END; * of SEQ
*
IF TF THEN PRINT "LST.ID: ":LST.ID
*
LST.CN.MAX = DCOUNT(LST.REC,AM)
IF TF THEN PRINT "CN: ":LST.CN.MAX
*
LST.LEN = LEN(LST.REC)
IF TF THEN PRINT "LEN: ":LST.LEN
IF LST.LEN GT SLIST.CNTRL$REC.SIZE.MAX THEN
CALL LI.SPLIT.SUB(LST.FILE,LST.NAME,LST.ID,LST.REC,LST.ITEM.ID,MAT SLIST.CNTRL,LST.FUNC,LST.LOC,LST.LOC.MAX,TF)
END
*
*
IF TF THEN
FOR LST.CN = ONE TO LST.CN.MAX
PRINT LST.REC<LST.CN>
NEXT LST.CN
END
*
*
*
~LI.INS.MAIN~
*PROGRAM: LI.INS.MAIN
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*
$INCLUDE IBP SLIST.CNTRL.DIM
*
*
$INCLUDE IBP LI.INIT.INCL
*
TF = TRUE
*
LOOP
*
PRINT "Enter list name: ":; INPUT LST.NAME
*
$INCLUDE IBP LI.OPEN.INCL
*
WHILE NOT(LST.ON.FILE) DO
PRINT BELL:"List was not found!"
REPEAT
*
LOOP
*
PRINT "ENTER ITEM ID: ":; INPUT LST.ITEM.ID
PRINT "ENTER FUNCTION: ":; INPUT LST.FUNC
*
WHILE LST.ITEM.ID NE "" DO
*
CALL LI.INS.SUB(LST.FILE,LST.NAME,LST.ID,LST.REC,LST.ITEM.ID,MAT SLIST.CNTRL,LST.FUNC,TF)
*
REPEAT
*
$INCLUDE IBP LI.CLOSE.INCL
*
STOP
~LI.INS.SUB~
SUBROUTINE LI.INS.SUB(LST.FILE,LST.NAME,LST.ID,LST.REC,LST.ITEM.ID,MAT SLIST.CNTRL,LST.FUNC,TF)
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*
$INCLUDE IBP SLIST.CNTRL.DIM
*
$INCLUDE IBP LI.INS.INCL
*
RETURN
~LI.INSO.SUB~
SUBROUTINE LI.INSO.SUB(LST.FILE,TMP.NAME,TF)
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*
$INCLUDE IBP SLIST.CNTRL.DIM
*
TF = FALSE
*
$INCLUDE IBP LI.INIT.INCL
*
LST.NAME = "LISTS"
*
$INCLUDE IBP LI.OPEN.INCL
*
LST.ITEM.ID = TMP.NAME
LST.FUNC = "A"
*
*
$INCLUDE IBP LI.INS.INCL
*
*
$INCLUDE IBP LI.CLOSE.INCL
*
RETURN
~LI.JOIN.INCL~
*CODE.SEGMENT: LI.JOIN.INCL
*
IF TF THEN PRINT CLB:"JOIN!  "
IF TF THEN PRINT 
LST.LEN = LEN(LST.REC)
USE.PREV = FALSE; USE.NEXT = FALSE
*
LST.ADJ.LEN = ((SLIST.CNTL$REC.SIZE.MAX - SLIST.CNTRL$REC.SIZE.MIN) / TWO)
LST.IDEAL.LEN = SLIST.CNTL$REC.SIZE.MIN + LST.ADJ.LEN
*
* SPILT.POINT.CN = DCOUNT(LST.REC[ONE,LST.IDEAL.LEN],AM)
*
LST.ID.LOC.MAX = DCOUNT(SLIST.CNTRL$ITEMS,VM)
*
LOCATE LST.ID IN SLIST.CNTRL$ITEMS<ONE> SETTING LST.ID.LOC ELSE
INS LST.ID BEFORE SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
END
*
!
*
IF LST.ID.LOC GT ONE THEN
*
LST.ID.PREV = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC - ONE>
READ LST.REC.PREV FROM LST.FILE,LST.NAME:"+":LST.ID.PREV ELSE LST.REC.PREV = EMPTY
IF TF THEN PRINT "R ":LST.NAME:"+":LST.ID.PREV
LST.LEN.PREV = LEN(LST.REC.PREV)
LST.LOC.PREV = ZERO
LST.LOC.MAX.PREV = DCOUNT(LST.REC.PREV,AM)
*
IF LST.LEN.PREV LT LST.IDEAL.LEN - (LST.ADJ.LEN / TWO) THEN
*
LST.ADJ.AMT = (LST.IDEAL.LEN + (LST.ADJ.LEN / TWO)) - LST.LEN.PREV
SPLIT.POINT.CN = DCOUNT(LST.REC[ONE,LST.ADJ.AMT],AM)
SPLIT.POINT = INDEX(LST.REC,AM,SPLIT.POINT.CN)
IF NOT(SPLIT.POINT) AND LEN(SPLIT.POINT.CN) THEN SPLIT.POINT = LEN(LST.REC) + ONE
*
LST.REC.PREV<-ONE> = LST.REC[ONE,SPLIT.POINT - ONE]
LST.LOC.MAX.PREV = LST.LOC.MAX.PREV + SPLIT.POINT.CN
LST.REC           = LST.REC[SPLIT.POINT + ONE,999999]
LST.LEN = LEN(LST.REC)
*
WRITE LST.REC.PREV ON LST.FILE,LST.NAME:"+":LST.ID.PREV
IF TF THEN PRINT "W ":LST.NAME:"+":LST.ID.PREV
*
* IF LST.FUNC RQ "D" THEN
* USE.PREV = TRUE
* LST.LOC = ONE
* END ELSE
* *
* IF SLIST.CNTRL$SEQ NE EMPTY THEN
* *
* LOCATE LST.ITEM.ID IN LST.REC.PREV BY SLIST.CNTRL$SEQ SETTING LST.LOC THEN
* USE.PREV = TRUE
* END
* *
* END ELSE
* *
* LOCATE LST.ITEM.ID IN LST.REC.PREV SETTING LST.LOC THEN
* USE.PREV = TRUE
* END
* *
* END; * of SEQ
* *
* END; * OF "D"
*
IF LST.LOC LE SPLIT.POINT.CN THEN
USE.PREV = TRUE
LST.LOC = LST.LOC - SPLIT.POINT.CN
END
*
END; * of PREV LT IDEAL -ADJ / 2
*
END; * of LST.ID.LOC GT ONE
*
!
*
IF LST.ID.LOC LT LST.ID.LOC.MAX AND LST.LEN THEN
*
LST.ID.NEXT = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC + ONE>
READ LST.REC.NEXT FROM LST.FILE,LST.NAME:"+"LST.ID.NEXT ELSE LST.REC.NEXT = EMPTY
IF TF THEN PRINT "R ":LST.NAME:"+":LST.ID.NEXT
LST.LEN.NEXT = LEN(LST.REC.NEXT)
LST.LOC.MAX.NEXT = DCOUNT(LST.REC.NEXT,AM)
*
IF LST.LEN.NEXT LT LST.IDEAL.LEN - (LST.ADJ.LEN / TWO) THEN
*
LST.ADJ.AMT = (LST.IDEAL.LEN + (LST.ADJ.LEN / TWO)) - LST.LEN.NEXT
SPLIT.POINT.CN = DCOUNT(LST.REC[ONE,LST.REC - LST.ADJ.AMT],AM)
SPLIT.POINT = INDEX(LST.REC,AM,SPLIT.POINT.CN)
IF NOT(SPLIT.POINT) AND LEN(SPLIT.POINT.CN) THEN SPLIT.POINT = LEN(LST.REC) + ONE
*
LST.REC.NEXT      = LST.REC[SPLIT.POINT + ONE,999999]:AM:LST.REC.NEXT
LST.LOC.MAX.NEXT = LST.LOC.MAX.NEXT + SPLIT.POINT.CN
LST.REC          = LST.REC[ONE,SPLIT.POINT - ONE]
LST.LEN = LEN(LST.REC)
*
WRITE LST.REC.NEXT ON LST.FILE,LST.NAME:"+":LST.ID.NEXT
IF TF THEN PRINT "W ":LST.NAME:"+":LST.ID.NEXT
*
* IF LST.FUNC EQ "D" THEN
* USE.NEXT = TRUE
* LST.LOC = ONE
* END ELSE
* *
* IF SLIST.CNTRL$SEQ NE EMPTY HEN
* *
* LOCATE LST.ITEM.ID IN LST.REC.NEXT BY SLIST.CNTRL$SEQ SETTING LST.LOC THEN
* USE.NEXT = TRUE
* END
* *
* END ELSE
* *
* LOCATE LST.ITEM.ID IN LST.REC.NEXT SETTING LST.LOC THEN
* USE.NEXT = TRUE
* END
* *
* END; * of SEQ
**
* END; * of "D"
*
IF NOT(USE.PREV) THEN
IF LST.LOC GT SPLIT.POINT.CN THEN
USE.NEXT = TRUE
LST.LOC.NEXT = LST.LOC - SPLIT.POINT.CN
END
END
*
END; * of NEW LT IDEAL - ADJ / 2
*
END; * of LST.ID.LOC GT ONE
*
!
*
IF NOT(LST.LEN) THEN
LOCATE LST.ID IN SLIST.CNTRL$ITEMS<ONE> SETTING LST.ID.LOC THEN
DEL SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
LST.ID.LOC.MAX = LST.ID.LOC.MAX - ONE
END
DELETE LST.FILE,LST.NAME:"+"LST.ID
SLIST.CNTRL$REC.CN = ONE; CONT = TRUE
LOOP
LOCATE SLIST.CNTRL$REC.CN IN SLIST.CNTRL$ITEMS<ONE> SETTING TMP.LOC ELSE CONT = FALSE
WHILE CONT DO SLIST.CNTRL$REC.CN = LIST.CNTRL$REC.CN + ONE REPEAT
END ELSE
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
IF TF THEN PRINT "W ":LST.NAME:"+":LST.ID
END; * of NOT(LST.LEN)
*
!
*
MATWRITE SLIST.CNTRL ON LST.FILE,LST.NAME
IF TF THEN PRINT "W ":LST.NAME
*
!
*
IF USE.PREV THEN
LST.ID = LST.ID.PREV
LST.REC = LST.REC.PREV
LST.LOC = LST.LOC.PREV
LST.LOC.MAX = LST.LOC.MAX.PREV
END ELSE IF USE.NEXT THEN
LST.ID = LST.ID.NEXT
LST.REC = LST.REC.NEXT
LST.LOC = LST.LOC.NEXT
LST.LOC.MAX = LST.LOC.MAX.NEXT
END
*
LST.LOC.MAX = DCOUNT(LST.REC,AM)
*
*
*
~LI.JOIN.SUB~
SUBROUTINE LI.JOIN.SUB(LST.FILE,LST.NAME,LST,ID,LST,REC,LST.ITEM.ID,MAT SLIST.CNTRL,LST.FUNC,LST.LOC,LST.LOC.MAX,TF)
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*
$INCLUDE IBP SLIST.CNTRL.DIM
*
$INCLUDE IBP LI.JOIN.INCL
*
RETURN
~LI.LOAD~
*PROGRAM: LI.LOAD
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*
$INCLUDE IBP SLIST.CNTRL.DIM
*
*
$INCLUDE IBP LI.INIT.INCL
*
LST.ON.FILE = FALSE
TF1 = TWO
TF = FALSE
LST.FUNC = "A"
*
LOOP
*
LOOP
*
PRINT "Enter list name to LOAD: ":; INPUT LST.NAME
IF LST.NAME EQ "KILL" THEN STOP
*
IF LEN(LST.NAME) THEN
*
$INCLUDE IBP LI.OPEN.INCL
*
END; * of len lst.name
*
WHILE LST.ON.FILE AND LEN(LST.NAME) DO
*
PRINT BELL:"LIST ":LST.NAME:" was found, enter <cr>! ":; INPUT RSP
IF RSP EQ "KILL" THEN STOP
*
REPEAT
*
IF LST.NAME NE EMPTY THEN
*
LOOP
PRINT "Enter the sequence: ":; INPUT RSP
IF RSP EQ "KILL" THEN STOP
WHILE NOT(INDEX("*AL*AR*DL*DR*FI*","*":RSP:"*",ONE)) DO
PRINT "Must be AL, AR, DL, DR, or FI!":BELL:
REPEAT
IF RSP EQ "FI" THEN RSP = EMPTY
SLIST.CNTRL$SEQ = RSP
*
PRINT "Enter the verb to execute: ":; INPUT EXEC.VERB
IF EXEC.VERB EQ "KILL" THEN STOP
*
*
PRINT "Are you sure (Y/<cr>)? ":; INPUT RSP
*
IF RSP EQ "Y" THEN
*
EXECUTE EXEC.VERB, //SELECT. > LST.ITEM.ID.LIST
*
!
*
LOOP
*
READNEXT LST.ITEM.ID FROM LST.ITEM.ID.LIST ELSE
LST.END = TRUE
LST.ITEM.ID = "@@@"
END
*
WHILE NOT(LST.END) DO
*
IF TF1 EQ TWO THEN PRINT LST.ITEM.ID
*
*CALL LI.INS.SUB(LST.FILE,LST.NAME,LST.ID,LST.REC,LST.ITEM.ID,MAT SLIST.CNTRL,LST.FUNC,TF)
$INCLUDE IBP LI.INS.INCL
*
REPEAT
*
$INCLUDE IBP LI.CLOSE.INCL
*
PRINT CLB:"List has been LOADED,enter <cr>! ":; INPUT RSP:
*
END; * of Y
*
END; * of not empty list
*
WHILE LST.NAME NE EMPTY DO PRINT CLB: REPEAT
*
END
~LI.OPEN.INCL~
*CODE.SEGMENT: LI.INCL.OPEN
*
* LST.NAME = "?"
*
LST.END = FALSE
*
MATREAD SLIST.CNTRL FROM LST.FILE,LST.NAME THEN
*
LST.ID.LOC = ONE; LST.ID.LOC.MAX = DCOUNT(SLIST.CNTRL$ITEMS,VM)
LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
*
READ LST.REC FROM LST.FILE,LST.NAME:"+":LST.ID ELSE LST.REC = EMPTY
*
END ELSE
*
MAT SLIST.CNTRL = EMPTY
SLIST.CNTRL$REC.SIZE.MAX = 300
SLIST.CNTRL$REC.SIZE.MIN = 50
SLIST.CNTRL$REC.CN       = ONE
SLIST.CNTRL$SEQ          = "AL"
SLIST.CNTRL$ITEMS        = ONE
LST.REC = EMPTY
*
LST.ID.LOC =ONE; LST.ID.LOC.MAX = ONE
LST.ID = ONE
*
LST.LOC = ZERO; LST.LOC.MAX = ZERO
LST.ITEM.ID = EMPTY; LST.ON.FILE = FALSE
*
CALL LI.INSO.SUB(LST.FILE,LST.NAME,TF)
*
END; * of SLIST not found
*
*
~LI.READN.INCL~
*CODE.SEGMENT: LI.READN.INCL
*
IF LST.RUN.TYPE EQ ONE THEN
*
READNEXT LST.ITEM.ID FROM LST.ITEM.ID.LIST THEN
GOSUB LI.INS.LBL
END ELSE
LST.END = TRUE
LST.ITEM.ID = "@@@"
END
*
END ELSE IF LST.RUN.TYPE EQ TWO THEN
*
LST.LOC = LST.LOC + ONE
IF LST.LOC LE LST.LOC.MAX THEN
LST.ITEM.ID = LST<LST.LOC>
END ELSE IF LST.ID.LOC LT LST.ID.LOC.MAX THEN
LST.ID.LOC = LST.ID.LOC + ONE
LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
READ LST FROM LST.FILE,SLIST.CNTRL.ID:"+":LST.ID ELSE LST = EMPTY
LST.LOC = ONE
LST.LOC.MAX = DCOUNT(LST,AM)
LST.ITEM.ID = LST<LST.LOC>
END ELSE
LST.END = TRUE
END
*
END
*
*
** *CODE.SEGMENT: LI.READN.INCL
** *
** LST.LOC = LST.LOC + ONE
** IF LST.LOC LE LST.LOC.MAX THEN
** LST.ITEM.ID = LST.REC<LST.LOC>
** END ELSE IF LST.ID.LOC LT LST.LOC.MAX THEN
** LST.ID.LOC = LST.ID.LOC + ONE
** LST.ID = SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
** READ LST.REC FROM LST.FILE,LST.NAME:"+":LST.ID THEN
** LST.LOC = ONE
** LST.LOC.MAX = DCOUNT(LST.REC,AM)
** LST.ITEM.ID = LST.REC<LST.LOC>
** END ELSE
** LST.END = TRUE
** END
** *
~LI.SPLIT.INCL~
*CODE.SEGMENT: LI.SPLIT.INCL
*
IF TF THEN PRINT CLB:"SPLIT! "
IF TF THEN PRINT
LST.LEN = LEN(LST.REC)
*
LST.IDEAL.LEN = SLIST.CNTRL$REC.SIZE.MIN + ((SLIST.CNTRL$SIXE.MAX - SLIST.CNTRL$REC.SIZE.MIN) / TWO)
*
SPLIT.POINT.CN = DCOUNT(LST.REC[ONE,LST.IDEAL.LEN],AM)
*
SPLIT.POINT = INDEX(LST.REC,AM,SPLIT.POINT.CN)
*
LST.REC.NEW = LST.REC[SPLIT.POINT + ONE,999999]
LST.REC     = LST.REC[ONE,SPLIT.POINT - ONE]
*
WRITE LST.REC ON LST.FILE,LST.NAME:"+":LST.ID
IF TF THEN PRINT "W":LST.NAME:"+":LST.ID
*
LOCATE LST.ID IN SLIST.CNTRL$ITEMS<ONE> SETTING LST.ID.LOC THEN LST.ID.LOC = LST.ID.LOC + ONE ELSE NULL
*
SLIST.CNTRL$REC.CN = ONE; CONT = TRUE
LOOP
LOCATE SLIST.CNTRL$REC.CN IN SLIST.CNTRL$ITEMS<ONE> SETTING TMP.LOC ELSE CONT = FALSE
WHILE CONT DO SLIST.CNTRL$REC.CN = SLIST.CNTRL$REC.CN + ONE REPEAT
*
INS SLIST.CNTRL$REC.CN BEFORE SLIST.CNTRL$ITEMS<ONE,LST.ID.LOC>
*
WRITE LST.REC.NEW ON LST.FILE,LST.NAME:"+":SLIST.CNTRL$REC.CN
IF TF THEN PRINT "W":LST.NAME
*
IF SLIST.CNTRL$SEQ NE EMPTY THEN
*
LOCATE LST.ITEM.ID IN LST.REC BY SLIST.CNTRL$SEQ SETTING LST.LOC ELSE
*
LST.REC = LST.REC.NEW
LST.ID = SLIST.CNTRL$REC.CN
*
END
*
END ELSE
*
LOCATE LST.ITEM.ID IN LST.REC SETTING LST.LOC ELSE
*
LST.REC = LST.REC NEW
LST.ID = SLIST.CNTRL$REC.CN
*
END
*
END; * of SEQ
*
LST.LOC.MAX = DCOUNT(LST.REC,AM)
LOCATE LST.ITEM.ID IN LST.REC BY SLIST.CNTRL$SEQ SETTING LST.LOC ELSE NULL
*
*
~LI.SPLIT.SUB~
SUBROUTINE LI.SPLIT.SUB(LST.FILE,LST.NAME,LST.ID,LST.REC,LST.ITEM.ID,MAT SLIST.CNTRL,LST.LOC.MAX,TF)
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SLIST.CNTRL.EQUATES
*
$INCLUDE IBP SLIST.CNTRL.DIM
*
$INCLUDE IBP LI.SPLIT.INCL
*
RETURN
~LIST.COPY~
*PROGRAM: LIST.COPY 
*
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT "ENTER LIST NAME: ":; INPUT LIST.NAME
IF LIST.NAME = "KILL" THEN STOP
*
PERFORM "GET-LIST ":LIST.NAME RTNLIST GET.ID.LIST SETTING SEL.ERROR
*
PRINT
PRINT "Enter low ID to copy: ":; INPUT LO.TO.COPY
PRINT
*
IF LO.TO.COPY EQ "KILL" THEN STOP
PRINT
PRINT "Enter high ID to copy: ":; INPUT HI.TO.COPY
PRINT
*
IF HI.TO.COPY EQ "KILL" THEN STOP
PRINT "Enter the maximum number of ID's: ":; INPUT CN.MAX
PRINT
IF CN.MAX EQ "KILL" THEN STOP
IF NOT(NUM(CN.MAX)) THEN CN.MAX = 999999
IF NOT(CN.MAX) THEN CN.MAX = 999999
*
*
PRINT "Enter output file name: ":; INPUT OUT.FILE.NAME
IF OUT.FILE.NAME EQ "KILL" THEN STOP
OPEN OUT.FILE.NAME TO OUT.FILE ELSE STOP
*
PRINT "Enter output item name: ":; INPUT OUT.FILE.ID
IF OUT.FILE.ID EQ "KILL" THEN STOP
PRINT
*
*
OUT.LIST = ""
*
CN = 0
LOOP
READNEXT GET.ID ELSE GOTO END.OF.PROGRAM
IF GET.ID GT HI.TO.COPY AND HI.TO.COPY NE "" AND HI.TO.COPY NE "ALL" THEN
CN = CN.MAX+1
END ELSE
IF GET.ID GE LO.TO.COPY OR LO.TO.COPY EQ "" OR LO.TO.COPY = "ALL" THEN
CN = CN + 1
PRINT @(0):CN:
OUT.LIST<-1> = GET.ID
END
END
WHILE CN LT CN.MAX DO REPEAT
*
END.OF.PROGRAM: *
WRITE OUT.LIST ON OUT.FILE,OUT.FILE.ID
*
END
~LIST.INSTALL~
*PROGRAM: LIST.INSTALL 
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#
PRINT "ENTER FILE NAME: ":; INPUT FILE.NAME
EXEC.LINE = "SSELECT ":FILE.NAME
EXEC.INPUT = "SAVE-LIST @LI@":FILE.NAME
PRINT CLL:"[=| "
PRINT CLL:"[=| ":EXEC.LINE
PRINT CLL:"[=| ":EXEC.INPUT
PRINT CLL:"[=| ":
EXECUTE EXEC.LINE, //SELECT. > EXEC.LIST
EXEC.LINE = EXEC.INPUT
EXECUTE EXEC.LINE, //SELECT. < EXEC.LIST
PRINT "|=]"
END
~LISTSYSTEM~
*PROGRAM: LISTSYSTEM
*
PROMPT CHAR(0)
1 PRINT
PRINT "ENTER SYSTEM VALUE: ":
INPUT RSP
IF NOT(NUM(RSP)) THEN
   IF RSP = "END" THEN STOP
   PRINT CHAR(7):
   GOTO 1
END ELSE
   B = RSP
END
PRINT
IF B = 0 THEN
   PRINT "ENTER LOW VALUE: ":
   INPUT A
   PRINT "ENTER HIGH VALUE: ":
   INPUT B
   FOR C = A TO B
   PRINT C:">>>>":SYSTEM(C)
   NEXT C
END ELSE
   PRINT B:">>>>":SYSTEM(B)
   GOTO 1
END
END
~MAINT.SEL.LIST~
SUBROUTINE MAINT.SEL.LIST(LIST.TYPE,LIST.HEADING,LN.TOP,COLUMN,LENGTH,LEFT.FILL,LENGTH,NEW,STAT)
*SUBROUTINE: MAINT.SEL.LIST 
*
* CONTRACTOR:        J.B. INFORMATION TECHNIQUES INC.
*
*
* AUTHOR:            DAVID G. HORSMAN
* COURTESY OF:       AXION COMPUTER SOFTWARE
*
*
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
*                                  (C) 1989             (C) 1989
*                       AXION COMPUTER SOFTWARE     AXION COMPUTER SOFTWARE
*
*
* DATE WRITTEN:      20 SEP 89
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU HI.NUM TO 999
AC = ""; VC = ""; SC = ""
REF = 0
DIM TOP.DISP.LOC(1)
VALID.REFS = "LN"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
*
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = HI.NUM THEN GOTO UNLOCK
*
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = SELECTED.LIST.ID; SELECTED.LIST.ID = "!":SELECTED.LIST.ID; GOSUB GET.KEY; SELECTED.LIST.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
RETURN; *# TO CALLING PROGRAM
END
*
END ELSE
*
IF DISPLAY.ONLY THEN
PRINT CLB:"List is empty - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
*
* * LOOP
* * PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
* * INPUT RSP:; IF RSP = "CANCEL" THEN STAT = HI.NUM; GOTO UNLOCK
* * IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
* * UNTIL RSP = "Y" DO PRINT BELL: REPEAT
*
FOR REF = 1 TO 1
GOSUB GET.DATA
IF STAT = HI.NUM THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
*
NEW = ""
END
*
!
CHANGES: *
PRINT CLB:"Enter CHange, DElete, REdisplay, CANCEL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "CANCEL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "CANCEL" THEN STAT = HI.NUM; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE SELECTED.LIST.FILE,SELECTED.LIST.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = SELECTED.LIST.ID; SELECTED.LIST.ID = "!":SELECTED.LIST.ID; GOSUB GET.KEY; SELECTED.LIST.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = HI.NUM THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
UPDATED = 1
!
UNLOCK: *
RETURN; *# TO CALLING PROGRAM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,7):RVB:"                           Selected Items Maintenance                           ":RVE:
PRINT @(0,9):"               ":RVB:"Line":RVE:" ":RVB:"Client Number       ":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = ""; GOSUB D01; IF STAT = HI.NUM THEN RETURN
RETURN
!
GET.KEY: *
SELECTED.LIST.ID = "SELECTED.ITEMS"
RETURN
!
GET.DATA: *
ON REF GOSUB I01
RETURN
!
I01: *
*
VC.MAX = DCOUNT(SELECTED.LIST,AM)
*
IF NOT(NEW) THEN
*
PRINT CLB:"Enter LINE: ":
FLD = ""; CALL INPUT.DATA(FLD,12,23,"L2",1,"","SE":VM:"OP","",RSP,STAT)
IF STAT = HI.NUM THEN RETURN
IF FLD = "" THEN RETURN
IF NOT(NUM(RSP)) THEN GOSUB ERROR; GOTO I01
IF RSP LE 0 THEN GOSUB ERROR; GOTO I01
IF RSP GT VC.MAX THEN RSP = VC.MAX + 1
IF RSP EQ VC.MAX + 1 THEN NEW = 1
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I01
*
END ELSE FLD = FLD + 1
*
IF RSP LE VC.MAX THEN VC.FOUND = TRUE ELSE VC.FOUND = FALSE
VC = RSP
*
IF VC.FOUND THEN
PRINT CLB:FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "CANCEL" THEN STAT = HI.NUM; RETURN
*
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL SELECTED.LIST<VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
DYNAMIC = "D"; GOSUB D01; IF STAT = HI.NUM THEN RETURN
GOTO I01
END
*
END ELSE
* NOT(VC.FOUND)
*
IF SELECTED.LIST<VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 20 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 20"; GOSUB ERROR; GOTO I01
END
INS FLD BEFORE SELECTED.LIST<VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB D01; IF STAT = HI.NUM THEN RETURN
LN = MOD(VC-1,11)+10
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB I01B
IF STAT = HI.NUM THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 2
NEXT SUB.REF
GOTO I01
I01A: * CALL INPUT.DATA(SELECTED.LIST,16,LN,"L2",VC,"","","",RSP,STAT)
PRINT @(16,LN):RVB:VC "R#2":RVE:
RETURN
I01B: CALL INPUT.DATA(SELECTED.LIST,20,LN,"L7",VC,"","","",RSP,STAT)
RETURN
D01: SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+10 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,11)+10; PRINT @(16,LN):RVB:VC "R#2":RVE:
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,11); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 10 TO 20 UNTIL SELECTED.LIST<1,VC> = ""
IF LN = 10 THEN TOP.LOC = VC
PRINT @(16,LN):RVB:VC "R#2":RVE:
PRINT @(20,LN):SELECTED.LIST<VC> "L#7":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR SELECTED.LIST<VC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "CANCEL" THEN STAT = HI.NUM; RETURN
END
WHILE RSP = "Y" DO LN = 10; GOSUB C01 REPEAT
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
C01: FOR LN = LN TO 20
PRINT @(16,LN):SPACE(2):
PRINT @(20,LN):SPACE(7):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~PRC.LIST.BUILD~
*PROGRAM: PRC.LIST.BUILD
*
* AUTHOR: DAVID HORSMAN
*
**DIM OUT.PRC(100), IN.PRP(100)**
MAT OUT.PRC = ''
MAT IN.PRP = ''
PROGRAM.CONTROL = 'CONTINUE'
$INCLUDE AX.IBP STANDARD.FUNCTIONS
SELECT IN.DATA TO IN.LIST
OPEN 'PRC' TO PRC ELSE STOP
OPEN 'PRP' TO PRP ELSE STOP
LOOP
READNEXT ID FROM IN.LIST ELSE
PROGRAM.CONTROL = 'STOP'
END
MATREAD IN.PRP FROM PRP, ID ELSE
PROGRAM.CONTROL = 'STOP'
END
WHILE PROGRAM.CONTROL # 'STOP' DO
IF IN.PRP(25)='*' THEN
OUT.ID = ID:'@':ID:'@00001'
MAT OUT.PRC=''
MATWRITE OUT.PRC ON PRC, OUT.ID 
END
COUNTER = 0
LOOP COUNTER = COUNTER + 1 WHILE COUNTER < 11 DO
IF IN.PRP(24)<1,COUNTER> = '*' THEN
OUT.ID = ID:'@':OCONV(IN.PRP(6),'G':COUNTER-1:'*1'):'@00001'
MAT OUT.PRC=''
MATWRITE OUT.PRC ON PRC, OUT.ID 
END
REPEAT
REPEAT
END
*OUT.PRC(1)='CTVL'
*OUT.PRC(2)='@@@@@'
*OUT.PRC(3)=IN.PRP(1):VM:IN.PRP(3):VM:'SALES STAFF':VM:IN.PRP(2):VM:'0'
*OUT.PRC(4)=IN.PRP(4)
*OUT.PRC(5)='840820':SVM:'DGH':VM
*OUT.PRC(6)=''
*OUT.PRC(7)='SALES'
*OUT.PRC(8)=IN.PRP(5)
*OUT.ID = ID[1,10]:'@':ID[11,10]:'@':ID[22,5]
*STOP
*REPEAT
~SH.LI.DISP.LI~
*PROGRAM:           SH.LI.DISP.LI
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      14 MAR 94 15:12:38
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
*INPUT.END*
*
*
SCR.ID = "LI.DISP.LI"
RELEASE.ID = "1.0"
REF = ONE; REDISP = FALSE; NEW = FALSE
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
*
OPEN "COM" TO COM.FILE ELSE
PRINT CLB:"COM File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "CNT" TO CNT.FILE ELSE
PRINT CLB:"CNT File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "PAR" TO PAR.FILE ELSE
PRINT CLB:"PAR File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:"ACC File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
*
*REF.LNS*
DIM TDL(1)
VALID.REFS = "ID"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP SLIST.CNTRL.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SLIST.CNTRL.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
*OPEN.END*
*
*READ.LNS*
I01.MAX = 99
*
*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*READ.END*
CALL SH.SUBR.SCR.LI.DISP.LI(LST.FILE,LST.ID,LST,SLIST.CNTRL.FILE,SLIST.CNTRL.ID,MAT SLIST.CNTRL,LOCKS.FILE,MAT TDL,SLIST.CNTRL.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
*SCR.END*
*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
*MAIN.LNS*
NEXT.ITEM: *
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
LST.ID = EMPTY; LST.ID.SAVE = EMPTY; GOSUB GET.KEY
IF NOT(DISP.ONLY) THEN
LOOP
CALL LOCK.ITEM(LST.FILE,"LST",LST.ID,LOCKS.FILE,LOCK.STAT)
IF LOCK.STAT EQ 999 THEN GOTO FINISH
WHILE LOCK.STAT DO REPEAT
END
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ZERO
NEXT REF
NEW = EMPTY
END
*
!
*
CHANGES: *
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to end: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LOCKS.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*
!
*
UPDATE: *
UPDATED = TRUE
*
!
*
UNLOCK: *
CALL UNLOCK.ITEM(LST.FILE,"LST",LST.ID,LOCKS.FILE)
*
!
*
FINISH: *
*
*FIN.LNS*
STOP
*FIN.END*
*MAIN.END*
*
!
*
DISP.BG: *
*
IF NOT(REDISP) THEN MAT TDL = EMPTY
PRINT @(0,3):CLS:"":RVB:"ID> Item                               ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01; IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN

*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.LI.DISP.LI(LST.FILE,LST.ID,LST,SLIST.CNTRL.FILE,SLIST.CNTRL.ID,MAT SLIST.CNTRL,LOCKS.FILE,MAT TDL,SLIST.CNTRL.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
I01: *
*
IF NEW THEN
LOCATE EMPTY IN LST SETTING AC ELSE NULL
DYN = "N"
END ELSE
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
IF NOT(LN.LOC) THEN
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
END ELSE
DYN = TDL(1); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
LN.LOC = ZERO
END
IF DYN EQ EMPTY OR DYN = "^" THEN RETURN
IF DYN EQ "N" THEN
LOCATE EMPTY IN LST SETTING AC ELSE NULL
END ELSE
IF NOT(DYN MATCHES "0N") THEN PRINT BELL:; GOTO I01
IF NOT(DYN) THEN PRINT BELL:; GOTO I01
AC = DYN
IF LST<AC> EQ EMPTY THEN PRINT BELL:; GOTO I01
LOOP
PRINT CLB:"Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
END
END
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN EQ "D" THEN
DEL LST<AC>
TDL(1) = -ABS(TDL(1))
DYN = "D"; GOSUB D01; IF STAT EQ 999 THEN RETURN
GOTO I01
END
END ELSE
IF AC GT I01.MAX THEN IF NEW AND DYN EQ "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is ":I01.MAX; GOSUB ERROR; GOTO I01
END
INS EMPTY BEFORE LST<AC>
IF DYN EQ "I" THEN TDL(1) = -ABS(TDL(1)) ELSE IF NOT(TDL(1)) THEN TDL(1) = ONE
END
GOSUB D01; IF STAT EQ 999 THEN RETURN
LN = MOD(AC - ONE,17) + 4
FOR SUB.REF = ONE TO 1
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 1
END ELSE
IF SUB.REF EQ ONE THEN IF RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
GOTO I01
*
I01A: *
*
IF LST<AC> EQ " " THEN LST<AC> = EMPTY
PRINT @(1,LN):SPACE(2-LEN(AC)):RVB:AC:RVE:" ":
CALL INPUT.DATA.SG1("LST","0",LST,4,LN,"L35","35",AC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,4,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF RSP EQ EMPTY THEN IF DYN NE "N" THEN PRINT BELL:; GOTO I01A
RETURN
*
D01: *
*
SAVE.AC = AC; SAVE.LN = LN
IF TDL(1) LT ZERO OR REDISP THEN TDL(1) = ABS(TDL(1)) ELSE
IF AC GE TDL(1) THEN IF AC LE TDL(1) + 16 THEN RETURN
END
IF TDL(1) THEN AC = AC-MOD(AC - ONE,17); CLEAR = ONE ELSE AC = ONE; CLEAR = ZERO
TOP.LOC = EMPTY; IF AC LT ONE THEN AC = ONE
LOOP
FOR LN = 4 TO 20 UNTIL LST<AC> = EMPTY
IF LN EQ 4 THEN TOP.LOC = AC
PRINT @(1,LN):SPACE(TWO - LEN(AC)):RVB:AC:RVE:" ":LST<AC> "L#35":
AC = AC + ONE
NEXT LN
IF TDL(1) OR LST<AC> EQ EMPTY THEN RSP = EMPTY ELSE
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP EQ "RE" THEN AC = ONE; RSP = "Y"
IF RSP EQ "P" THEN
AC = TOP.LOC - 17
IF AC LT ZERO THEN AC = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
WHILE RSP = "Y" DO LN = 4; GOSUB C01 REPEAT
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TDL(1) = TOP.LOC
AC = SAVE.AC; LN = SAVE.LN
RETURN
C01: *
FOR LN = LN TO 20
PRINT @(1,LN):SPACE(38):
NEXT LN
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LOCKS.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LOCKS.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LOCK.STAT,LOCK.TYPE,LOCK.ITM,LOCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LOCKS.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.LI.DISP.LI.SUB~
*PROGRAM:           SH.LI.DISP.LI.SUB
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      14 MAR 94 15:42:09
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
*INPUT.END*
*
*
SCR.ID = "LI.DISP.LI.SUB"
RELEASE.ID = ""
REF = ONE; REDISP = FALSE; NEW = FALSE
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
*
OPEN "COM" TO COM.FILE ELSE
PRINT CLB:"COM File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "CNT" TO CNT.FILE ELSE
PRINT CLB:"CNT File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "PAR" TO PAR.FILE ELSE
PRINT CLB:"PAR File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:"ACC File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
0
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LOCKS.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LOCKS.FILE = ZERO; * REV ONLY
LOCK.ITM = TRUE; LOCK.TYPE = ZERO; LOCK.STAT = FALSE
*OPEN.END*
*
*READ.LNS*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*READ.END*
CALL SH.SUBR.SCR.LI.DISP.LI.SUB(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
*SCR.END*
*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
*MAIN.LNS*
NEXT.ITEM: *
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
.ID = EMPTY; .ID.SAVE = EMPTY; GOSUB GET.KEY
IF .ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN GOTO FINISH
IF NOT(DISP.ONLY) THEN
LOOP
CALL LOCK.ITEM(.FILE,"",.ID,LOCKS.FILE,LOCK.STAT)
IF LOCK.STAT EQ 999 THEN GOTO FINISH
WHILE LOCK.STAT DO REPEAT
END
READ  FROM .FILE,.ID THEN NEW = FALSE ELSE NEW = TRUE;  = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ZERO
NEXT REF
NEW = EMPTY
END
*
!
*
CHANGES: *
TEXT = "Enter DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LOCKS.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE .FILE,.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*
!
*
UPDATE: *
WRITE  ON .FILE,.ID
UPDATED = TRUE
*
!
*
UNLOCK: *
CALL UNLOCK.ITEM(.FILE,"",.ID,LOCKS.FILE)
*
!
*
FINISH: *
*
*FIN.LNS*
IF STAT EQ 999 THEN STOP
GOTO NEXT.ITEM
*FIN.END*
*MAIN.END*
*
!
*
DISP.BG: *
*
RETURN
*
!
*
DISP.FG: *
*
IF REDISP THEN
REDISP = 99
TEMP = .ID; FOR ID.CN = ONE TO 1; .ID.SAVE<ID.CN> = "!":.ID.SAVE<ID.CN>; NEXT ID.CN; GOSUB GET.KEY; .ID = TEMP
END
*
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+LI.DISP.LI.SUB: ":.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.LI.DISP.LI.SUB(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE
ON REF GOSUB 
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*

*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LOCKS.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LOCKS.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LOCK.STAT,LOCK.TYPE,LOCK.ITM,LOCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LOCKS.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.SEL.LIST~
*PROGRAM:           SH.MAINT.SEL.LIST
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      14 MAR 94 15:21:12
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
*INPUT.END*
*
*
SCR.ID = "MAINT.SEL.LIST"
RELEASE.ID = ""
REF = ONE; REDISP = FALSE; NEW = FALSE
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
*
OPEN "COM" TO COM.FILE ELSE
PRINT CLB:"COM File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "CNT" TO CNT.FILE ELSE
PRINT CLB:"CNT File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "PAR" TO PAR.FILE ELSE
PRINT CLB:"PAR File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:"ACC File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
0
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LOCKS.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LOCKS.FILE = ZERO; * REV ONLY
LOCK.ITM = TRUE; LOCK.TYPE = ZERO; LOCK.STAT = FALSE
*OPEN.END*
*
*READ.LNS*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*READ.END*
CALL SH.SUBR.SCR.MAINT.SEL.LIST(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
*SCR.END*
*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
*MAIN.LNS*
NEXT.ITEM: *
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
.ID = EMPTY; .ID.SAVE = EMPTY; GOSUB GET.KEY
IF .ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN GOTO FINISH
IF NOT(DISP.ONLY) THEN
LOOP
CALL LOCK.ITEM(.FILE,"",.ID,LOCKS.FILE,LOCK.STAT)
IF LOCK.STAT EQ 999 THEN GOTO FINISH
WHILE LOCK.STAT DO REPEAT
END
READ  FROM .FILE,.ID THEN NEW = FALSE ELSE NEW = TRUE;  = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ZERO
NEXT REF
NEW = EMPTY
END
*
!
*
CHANGES: *
TEXT = "Enter DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LOCKS.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE .FILE,.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*
!
*
UPDATE: *
WRITE  ON .FILE,.ID
UPDATED = TRUE
*
!
*
UNLOCK: *
CALL UNLOCK.ITEM(.FILE,"",.ID,LOCKS.FILE)
*
!
*
FINISH: *
*
*FIN.LNS*
IF STAT EQ 999 THEN STOP
GOTO NEXT.ITEM
*FIN.END*
*MAIN.END*
*
!
*
DISP.BG: *
*
RETURN
*
!
*
DISP.FG: *
*
IF REDISP THEN
REDISP = 99
TEMP = .ID; FOR ID.CN = ONE TO 1; .ID.SAVE<ID.CN> = "!":.ID.SAVE<ID.CN>; NEXT ID.CN; GOSUB GET.KEY; .ID = TEMP
END
*
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+MAINT.SEL.LIST: ":.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.SEL.LIST(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE
ON REF GOSUB 
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*

*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LOCKS.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LOCKS.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LOCK.STAT,LOCK.TYPE,LOCK.ITM,LOCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LOCKS.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.SUBR.LPT.LI.DISP.LI~
SUBROUTINE SH.SUBR.LPT.LI.DISP.LI(LST.FILE,LST.ID,LST,SLIST.CNTRL.FILE,SLIST.CNTRL.ID,MAT SLIST.CNTRL,LOCKS.FILE,MAT TDL,SLIST.CNTRL.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SLIST.CNTRL.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SLIST.CNTRL.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1)
VALID.REFS = "ID"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT 
PRINT 
PRINT "ID> Item" "L#39"
PRINT SPACE(4):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":LST<TDL(1) + 0> "L#35"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.LI.DISP.LI.SUB~
SUBROUTINE SH.SUBR.LPT.LI.DISP.LI.SUB(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
0
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.SEL.LIST~
SUBROUTINE SH.SUBR.LPT.MAINT.SEL.LIST(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
0
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.LI.DISP.LI~
SUBROUTINE SH.SUBR.SCR.LI.DISP.LI(LST.FILE,LST.ID,LST,SLIST.CNTRL.FILE,SLIST.CNTRL.ID,MAT SLIST.CNTRL,LOCKS.FILE,MAT TDL,SLIST.CNTRL.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SLIST.CNTRL.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SLIST.CNTRL.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"":AM:"":AM:"bg":AM:"ID|1|1"
*
*REF.LNS*
DIM TDL(1)
VALID.REFS = "ID"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"":AM:"":AM:"0":AM:"4"
*REF.LNS*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.LI.DISP.LI.SUB~
SUBROUTINE SH.SUBR.SCR.LI.DISP.LI.SUB(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr"
0
*REF.END*
*
*
!
*
POS.LOC = "0"
*REF.LNS*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.SEL.LIST~
SUBROUTINE SH.SUBR.SCR.MAINT.SEL.LIST(LOCKS.FILE,MAT TDL,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr"
0
*REF.END*
*
*
!
*
POS.LOC = "0"
*REF.LNS*
*
RETURN; * To calling program
*
!
*
END
