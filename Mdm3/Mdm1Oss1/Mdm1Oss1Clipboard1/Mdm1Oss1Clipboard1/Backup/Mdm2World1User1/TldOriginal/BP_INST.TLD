~ACS.SEARCH~
*PROGRAM: ACS.SEARCH
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   01 AUG 84
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT: (C) 1984,85,86,87,88,89,90,91,92 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
*
EQU EOS TO CHAR(12)
PHANTOM.FLAG = FALSE; FIRST = TRUE; DONE = FALSE; CONT = FALSE
FIRST.TRY = FALSE; COMMN.FLAG = EMPTY; FOUND = FALSE; PR.FOUND = FALSE
LBL.CN = ZERO; LBL.CN.MAX = ZERO; IN.LBLS = EMPTY; OUT.LBLS = EMPTY
FOUND = FALSE; LIST = EMPTY; LIST.CN = EMPTY
LINE = EMPTY; ORIG.LINE = EMPTY; FLIN = EMPTY; FLIN.CN = ZERO
ITEM.ID = EMPTY; FTXT = EMPTY; FTXT.CN.MAX = EMPTY; FTXT.CN = ZERO
AM.TC.CN = ZERO; THIS = EMPTY; ATTRONE = EMPTY; FIRST.MSG = TRUE
*
LPTR.FL = FALSE; LPTR.FL.SAVE = TWO; LN.CN = ZERO; LN.CN.MAX = 60
FIRST.PG = TRUE; FIRST.PG.TERM = TRUE
LN.CN.TERM = ZERO; LN.CN.MAX.TERM = 20
CL.CN.MAX = 130; CL.CN.MAX.TERM = 78
PG.CN = ZERO; PG.CN.TERM = ZERO
NOPAGE.FL = TRUE; FAST.FL = TRUE; FAST.FF = FALSE
CONT.RSP = EMPTY; STAT = FALSE; LIST.EMPTY = TRUE
*
EXEC.VERB = EMPTY; EXEC.VERB1 = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
TITLE = "Macroscope Design Maxtrix Search Utility"
TITLE1 = EMPTY
*
ITEM.TYPE = EMPTY; OLD.ITEM.TYPE = EMPTY; VALID.ITEM.TYPE = EMPTY
FINDS = EMPTY; VPARAMS = EMPTY; EPARAMS = EMPTY; IPARAMS = EMPTY
LIST.NAME = EMPTY; FILE.ID = EMPTY; OUT.FILE.ID = EMPTY
IN.CODE.TYPE = EMPTY; OUT.CODE.TYPE = EMPTY; CODE.VER = EMPTY
NULLS.FLAG = EMPTY; REM.FLAG = EMPTY; EXISTING.FLAG = EMPTY
USE.TBL.FLAG = EMPTY; ITEM.CLL = EMPTY; SYS.ITEM = EMPTY
STD.FLAG = EMPTY
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
*
PRINT "Enter your user name: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
USER.NAME = RSP
IF USER.NAME EQ EMPTY THEN USER.NAME = "???"
*
!
*
PRINT "Enter the RUN REFERENCE name (to save these parameters): ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
SYS.RUN.NAME = RSP
IF SYS.RUN.NAME EQ EMPTY THEN SYS.RUN.NAME = USER.NAME:"#":ACCT:"#":PORT
*
!
*
FINDS=EMPTY
CN = ZERO
LOOP
CN = CN + ONE
PRINT "ENTER STRING TO SEARCH FOR (RET WHEN DONE) ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
UNTIL RSP EQ EMPTY OR RSP[ONE,ONE] EQ "@" DO
FINDS<ONE,-ONE> = RSP
PRINT "[=| STRING ":CN:" IS: ":RSP
CN = CN + ONE
REPEAT
*
!
*
OPEN "SYS" TO SYS.FILE ELSE PRINT BELL:"SYS MISSSING!"; STOP
OPEN "MD"  TO MD.FILE  ELSE PRINT BELL:"MD MISSING!"; STOP
OPEN "SCR"  TO SCR.FILE  ELSE PRINT BELL:"SCR MISSING!"; STOP
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY.":PORT ELSE
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
END
*
! Search item should be read from disk @????????
*
RUN.TYPE = ONE; SEARCH.ID = "none"
IF RSP[ONE,ONE] EQ "@" THEN
RUN.TYPE = TWO
*SYS.FILE = "SYS"
SYS.ITEM = RSP[TWO,9999]
IF SYS.RUN.NAME EQ EMPTY THEN
SYS.RUN.NAME = FIELD(SYS.ITEM," ",TWO)
IF SYS.RUN.NAME EQ EMPTY THEN SYS.RUN.NAME = USER.NAME:"#":ACCT:"#":PORT
END
SYS.ITEM = FIELD(SYS.ITEM," ",ONE)
SEARCH.ID = SYS.ITEM
SEARCH.ID.OUT = SYS.RUN.NAME
*
READ PROCESS.REC FROM SYS.FILE,"@S@RSP@":SYS.ITEM ELSE
PRINT "[=| "
PRINT "[=| ITEM @S@RSP@":SYS.ITEM:" was not found..."
PRINT "[=| "
*
READ PROCESS.REC FROM SYS.FILE,SYS.ITEM THEN
IF TERM.DISP THEN
PRINT "[=| "
PRINT "[=| ITEM ":SYS.ITEM:" was found and will be used... "
PRINT "[=| "
END
*
END ELSE
PRINT BELL:"[=| ITEM MISSING!"; STOP
END; * of read
*
END; * of read
*
*
LIST.NAME      = PROCESS.REC<3>  ;* PROMPT 6
FINDS          = PROCESS.REC<4>  ;* PROMPT 1
VPARAMS        = PROCESS.REC<5>
EPARAMS        = PROCESS.REC<6>
IPARAMS        = PROCESS.REC<7>
FILE.ID       = PROCESS.REC<8>  ;* PROMPT 4
OUT.FILE.ID   = PROCESS.REC<9>  ;* PROMPT 5
PHANTOM.FLAG   = PROCESS.REC<10> ;* (0/1) * PROMPT 2
LPTR.FL.SAVE   = PROCESS.REC<11> ;* (0,1) * PROMPT 3
*  VERSION CONTROL PARAMETERS *
IN.CODE.TYPE   = PROCESS.REC<12> ;* (*%%^^^%%^)
OUT.CODE.TYPE  = PROCESS.REC<13> ;* (*%%^^^%%^)
NULLS.FLAG     = PROCESS.REC<14> ;* (EQ/NE/NO)
REM.FLAG       = PROCESS.REC<15> ;* (0/1)
EXISTING.FLAG  = PROCESS.REC<16> ;* (0/1)
*  REPETATIVE RUN OPTIMIZER TABLES *
USE.TBL.FLAG   = PROCESS.REC<17> ;* (0 or EMPTY / 1)
*  ITEM LEVEL PROCESSING
ITEM.CLL       = PROCESS.REC<18> ;* (XXX---XXX)
SYS.ITEM       = SYS.RUN.NAME
*  OUTPUT *%%STD%%= LINES
STD.FLAG       = PROCESS.REC<20> ;* (0/1)
VALID.ITEM.TYPE= PROCESS.REC<21> ;* (*XXX---XXX*XXX---XXX*XXX---XXX*)
WRITE PROCESS.REC ON SYS.FILE,"@S@RSP@":FILE.ID:"@":SYS.ITEM
**
*
END ELSE
*
! Search item is not being read from disk
*
PRINT "[=| Run in PHANTOM mode? ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
IF INDEX("*Y*y*YES*yes*ok*OK*","*":RSP:"*",ONE) NE ZERO THEN PHANTOM.FLAG = TRUE
IF PHANTOM.FLAG THEN TERM.DISP = FALSE
**
*
LPTR.FL.SAVE = FALSE
PRINT "[=| Print on the PRINTER? ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
IF INDEX("*YES*Y*y*yes*ok*OK*","*":RSP:"*",ONE) THEN
LPTR.FL.SAVE = TWO
END ELSE
LPTR.FL.SAVE = ONE
END
**
*
10 PRINT "[=| Enter the INPUT FILE to be processed: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
FILE.ID = RSP
**
*
11 PRINT "[=| Enter the OUTPUT FILE to place the results in: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
OUT.FILE.ID = RSP
**
*
12 PRINT "[=| LISTs may be entered in the following formats:"
   PRINT "[=| "
   PRINT "[=|      List_Name"
   PRINT "[=|      .TCL_Statement"
   PRINT "[=|      @File_Name Item_ID"
   PRINT "[=| "
   PRINT "[=| Enter the LIST NAME of the items to be processed: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
LIST.NAME = RSP
**
*
13 PRINT "[=| Enter the ITEM LEVEL conversion call: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
ITEM.CLL = RSP
**
*
VPARAMS = EMPTY
EPARAMS = EMPTY
IPARAMS = EMPTY
IN.CODE.TYPE = "???"
OUT.CODE.TYPE = "???"
NULLS.FLAG    = EMPTY
EXISTING.FLAG = EMPTY
REM.FLAG      = EMPTY
USE.TBL.FLAG  = EMPTY
STD.FLAG      = ONE
*
**
14 PRINT "[=| Enter the VALID ITEM TYPEs separated by *'s: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
VALID.ITEM.TYPE = RSP
IF VALID.ITEM.TYPE EQ EMPTY THEN
*   VALID.ITEM.TYPE = "*PROGRAM*SUBROUTINE*CODE.SEGMENT*"
VALID.ITEM.TYPE = "*PROGRAM*SUBROUTINE*CODE.SEGMENT*PROC*DICT*"
END ELSE IF VALID.ITEM.TYPE NE "ALL" THEN
VALID.ITEM.TYPE = "*":VALID.ITEM.TYPE:"*"
END
**
*
PROCESS.REC = EMPTY
*ROCESS.REC<ZERO>  = SYS.RUN.NAME ;* PROMPT -1
PROCESS.REC<ONE>  = DATE()
PROCESS.REC<TWO>  = USER.NAME ;* PROMPT -2
PROCESS.REC<3>  = LIST.NAME  ;* PROMPT 6
PROCESS.REC<4>  = FINDS  ;* PROMPT 1
PROCESS.REC<5>  = VPARAMS
PROCESS.REC<6>  = EPARAMS
PROCESS.REC<7>  = IPARAMS
PROCESS.REC<8>  = FILE.ID  ;* PROMPT 4
PROCESS.REC<9>  = OUT.FILE.ID  ;* PROMPT 5
PROCESS.REC<10> = PHANTOM.FLAG ;* (0/1) * PROMPT 2
PROCESS.REC<11> = LPTR.FL.SAVE ;* (0,1) * PROMPT 3
*  VERSION CONTROL PARAMETERS *
PROCESS.REC<12> = IN.CODE.TYPE ;* (*%%^^^%%^)
IF OUT.CODE.TYPE EQ EMPTY THEN OUT.CODE = "*%%ALL%%="
PROCESS.REC<13> = OUT.CODE.TYPE ;* (*%%^^^%%^)
PROCESS.REC<14> = NULLS.FLAG ;* (EQ/NE/NO)
PROCESS.REC<15> = REM.FLAG ;* (0/1)
PROCESS.REC<16> = EXISTING.FLAG ;* (0/1)
*  REPETATIVE RUN OPTIMIZER TABLES *
PROCESS.REC<17> = USE.TBL.FLAG ;* (0 or EMPTY / 1)
*  ITEM LEVEL PROCESSING
PROCESS.REC<18> = ITEM.CLL ;* (XXX---XXX)
SYS.ITEM        = SYS.RUN.NAME
PROCESS.REC<19> = SYS.RUN.NAME
PROCESS.REC<20> = STD.FLAG
PROCESS.REC<21> = VALID.ITEM.TYPE
*
WRITE PROCESS.REC ON SYS.FILE,"@S@RSP@":FILE.ID:"@":SYS.ITEM
*
END; * of search item read or input
*
!! Start of Program
*
TITLE1 = "Run:":SYS.RUN.NAME:" List:":LIST.NAME:" In:":FILE.ID:" Out:":OUT.FILE.ID
*
! Open files
*
READ MD.ITEM FROM MD.FILE,FILE.ID ELSE MD.ITEM = AM:AM:"BP"
*
OPEN "",FILE.ID TO IN.FILE ELSE PRINT "CAN'T OPEN ":FILE.ID; STOP
*
IF OUT.FILE.ID EQ "END" OR OUT.FILE.ID EQ CHAR(27) OR OUT.FILE.ID EQ CHAR(251) THEN STOP
IF OUT.FILE.ID NE EMPTY THEN
OPEN "",OUT.FILE.ID TO OUT.FILE ELSE PRINT "CAN'T OPEN ":OUT.FILE.ID;STOP
END ELSE TERM.DISP = TRUE
*
OPEN "","LISTS" TO LISTS.FILE ELSE PRINT "[=| CAN'T OPEN LISTS"; STOP
*
! Print paramaeters
*
LPTR.FL = FALSE
*
FOR LPTR.CN = ONE TO LPTR.FL.SAVE; *# PRINTER WS
*
IF (LPTR.CN EQ ONE AND TERM.DISP) OR (LPTR.CN EQ TWO AND LPTR.FL) THEN
IF LPTR.CN EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE
*
*
LN.DISP = STR("*",70); GOSUB DISP.LINE
LN.DISP = "[=| Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILE.ID; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| Acct....":ACCT:"   Port....":PORT; GOSUB DISP.LINE
LN.DISP = "[=|"; GOSUB DISP.LINE
LN.DISP = "[=| User.name.....":USER.NAME; GOSUB DISP.LINE
LN.DISP = "[=| Run.reference.":SYS.RUN.NAME; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
*
FTXT.CN.MAX = DCOUNT(FINDS,VM)
IF FTXT.CN.MAX THEN
FOR FTXT.CN = ONE TO FTXT.CN.MAX
LN.DISP = "[=| ":CN "R#2":")  F: ":FINDS<ONE,FTXT.CN>; GOSUB DISP.LINE
LN.DISP = "[=| ":"Verify: ":VPARAMS<ONE,FTXT.CN>; GOSUB DISP.LINE
LN.DISP = "[=| ":"Extrct: ":EPARAMS<ONE,FTXT.CN>; GOSUB DISP.LINE
LN.DISP = "[=| ":"Output: ":IPARAMS<ONE,FTXT.CN>; GOSUB DISP.LINE
NEXT FTXT.CN
END ELSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| No strings to search for, continuing..."; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
END
*
! Print run parameters
*
LN.DISP = "[=| ":STR("_",70); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILE.ID; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"Run type: ":FIELD("Variable*Fixed","*",RUN.TYPE); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"Item: ":SEARCH.ID; GOSUB DISP.LINE
LN.DISP = "[=| ":"List: ":LIST.NAME; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":" Input code type: ":IN.CODE.TYPE; GOSUB DISP.LINE
LN.DISP = "[=| ":"Output code type: ":OUT.CODE.TYPE; GOSUB DISP.LINE
LN.DISP = "[=| ":"   Process nulls: ":NULLS.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":"Existing code in: ":EXISTING.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":" Process remarks: ":REM.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":"Use prior tables: ":USE.TBL.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":" Item level call: ":ITEM.CLL; GOSUB DISP.LINE
LN.DISP = "[=| ":"  Output STD's  : ":STD.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":"Valid item types: ":VALID.ITEM.TYPE; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("_",70); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
END; * TERM.DISP
*
IF LPTR.CN EQ TWO THEN LPTR.FL = FALSE
*
NEXT LPTR.CN
*
!! Retrieve List
*
LIST = EMPTY
LIST.CN = ONE
FLIN = EMPTY
FTXT = EMPTY
IF LIST.NAME NE EMPTY THEN
IF LIST.NAME[ONE,ONE] EQ "." THEN
EXEC.VERB1 = LIST.NAME[TWO,9999]
END ELSE IF LIST.NAME[ONE,ONE] EQ "@" THEN
EXEC.VERB1 = "FORM-LIST ":LIST.NAME[TWO,9999]
END ELSE
EXEC.VERB1 = "GET-LIST ":LIST.NAME
END
EXEC.OUT = EMPTY
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB1; GOSUB DISP.LINE
END
*
BEGIN CASE
*
CASE OPSYS EQ "M"
EXEC.OUT = EMPTY
EXECUTE EXEC.VERB1, //SELECT. > ITEM.ID.LIST, //OUT. > EXEC.OUT
*
IF TERM.DISP THEN PRINT EXEC.OUT
*
CASE TRUE
READ ITEM.ID.LIST FROM SYS.FILE,LIST.NAME ELSE ITEM.ID.LIST = EMPTY
*
END CASE
*
END
*
FIRST = ONE
IF NOT(FIRST) THEN
IF LIST.NAME EQ EMPTY AND FILE.ID NE EMPTY THEN
EXEC.VERB = "GET-LIST ":FILE.ID
EXEC.OUT = EMPTY
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB; GOSUB DISP.LINE
END
*
READNEXT ITEM.ID FROM ITEM.ID.LIST ELSE
EXEC.IN = "SAVE-LIST ":FILE.ID
EXEC.VERB = "SSELECT ":FILE.ID
EXEC.OUT = EMPTY
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB; GOSUB DISP.LINE
LN.DISP = "[=| ":">":EXEC.IN; GOSUB DISP.LINE
END
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN, //OUT. > EXEC.OUT
*
IF TERM.DISP THEN LN.DISP = EXEC.OUT; GOSUB DISP.LINE
*
EXEC.VERB = "GET-LIST ":FILE.ID
EXEC.OUT = EMPTY
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB; GOSUB DISP.LINE
EXECUTE EXEC.VERB, //SELECT. > ITEM.ID.LIST, //OUT. > EXEC.OUT
*
END
END
END
DONE = FALSE; ITEM.ID = EMPTY
FIRST.TRY = TRUE
IF LPTR.FL.SAVE EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE
*
!! Main Program
*
LOOP
*
LOOP
*
CONT = TRUE
BEGIN CASE
CASE OPSYS EQ "M"
IF ITEM.ID EQ "@" THEN CONT = FALSE
CASE TRUE
IF NOT(LEN(ITEM.ID.LIST)) THEN CONT = FALSE
END CASE
*
IF NOT(CONT) THEN
IF FIRST.TRY THEN
PRINT
PRINT "Enter item name: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
ITEM.ID = RSP
END ELSE
DONE = TRUE
END
*
* Not cont
*
END ELSE
BEGIN CASE
CASE OPSYS EQ "M"
READNEXT ITEM.ID FROM ITEM.ID.LIST ELSE ITEM.ID = "@"
CASE TRUE
ITEM.ID = ITEM.ID.LIST<ONE>
ITEM.ID.LIST = DELETE(ITEM.ID.LIST,ONE,ZERO,ZERO)
END CASE
END; * of cont
*
FIRST.TRY = EMPTY
*
WHILE NOT(DONE) AND (ITEM.ID EQ "@" OR ITEM.ID EQ EMPTY OR ITEM.ID[ONE,ONE] EQ "*" OR ITEM.ID[ONE,ONE] EQ "$") DO REPEAT
*
! Have another item or am done
*
UNTIL DONE DO
*
*960601*DGH*EXEC.VERB = "MSG PROGRAMS ":PROC.BUFFER<1>:" Gen:":ITEM.ID
EXEC.VERB = "SYS.MSG.SEND PROGRAMS ":PROC.BUFFER<1>:" Gen:":ITEM.ID
EXEC.IN = "PROGRAMS":AM:PROC.BUFFER<1>:" Gen:":ITEM.ID
EXEC.OUT = EMPTY
EXECUTE EXEC.VERB, //IN. < EXEC.IN, //OUT. > EXEC.OUT
*
IF FIRST.MSG THEN
EXEC.VERB = "ACC.UPDATE"
**EXEC.IN = ("S/W Inst ":PROC.BUFFER<TWO>:PROC.BUFFER<ONE>:" GEN") "L#25"
**EXEC.IN = ("+S/W Inst ":PROC.BUFFER<TWO>:"+":PROC.BUFFER<ONE>:" GEN") 
EXEC.IN = ("+Type: ":PROC.BUFFER<ONE>)
IF PROC.BUFFER<TWO> NE EMPTY THEN
EXEC.IN = EXEC.IN:(+Search ":PROC.BUFFER<TWO>)
END
EXECUTE EXEC.VERB, //IN. < EXEC.IN
FIRST.MSG = FALSE
END
*
! LOOP To handle screen items
*
IF TERM.DISP EQ "9" THEN
PRINT CLB:"READY!!!":BELL:; INPUT TMP:
END
*
*
! LOOP To handle screen items
*
ORIG.ID = ITEM.ID; SH.CN = ZERO; SH.CN.MAX = ONE
SUBR.FL = FALSE; INCL.FL = FALSE
IF ORIG.ID[ONE,3] EQ "SH." THEN
PRINT CLB:"Screen present":
SH.CN.MAX = 3
READ SCR.HDR FROM SCR.FILE,ORIG.ID[4,9999]:"*HDR" ELSE
SCR.HDR = EMPTY
PRINT CLB:"Screen Header Missing!":
SCR.HDR<SCR.HDR$SCREEN.TYPE> = "P"
END
IF INDEX(SCR.HDR<SCR.HDR$SCREEN.TYPE>,"S",ONE) THEN
SUBR.FL = TRUE; SH.CN.MAX = 4
PRINT CLB:"Subroutine present":
END
IF INDEX(SCR.HDR<SCR.HDR$SCREEN.TYPE>,"C",ONE) THEN 
INCL.FL = TRUE; SH.CN.MAX = 5
PRINT CLB:"Code Segment present":
END
END
*
!
*
LOOP
*
SH.CN = SH.CN + ONE
*
IF ORIG.ID[ONE,3] EQ "SH." THEN
TMP = EMPTY
IF SH.CN EQ TWO THEN TMP = "SUBR.SCR."
IF SH.CN EQ 3   THEN TMP = "SUBR.LPT."
IF SH.CN EQ 4    THEN TMP = "SUBR."
IF SH.CN EQ 5    THEN TMP = "INCL."
ITEM.ID = "SH.":TMP:ORIG.ID[4,9999]
END ELSE
ITEM.ID = ORIG.ID
END
*
!
*
WHILE (ORIG.ID[ONE,3] EQ "SH." AND SH.CN LE SH.CN.MAX) OR SH.CN LE ONE DO
*
IF SH.CN LE 3 OR (SH.CN EQ 4 AND SUBR.FL) OR (SH.CN EQ 5 AND INCL.FL) THEN
*
EXEC.VERB = "ACC.UPDATE"
**EXEC.IN =("+g":ITEM.ID:" ":FILE.ID) "L#25"
**IF LEN(EXEC.IN) GT 50 THEN EXEC.IN = EXEC.IN "L#50"
**EXEC.IN =("+Trans: ":FILE.ID:"+":ITEM.ID)
* EXEC.IN = ("+":ITEM.ID:"+Trans: ":FILE.ID)
EXEC.IN = ("+Trans: ":ITEM.ID)
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
COMMN.FLAG = EMPTY
FOUND = FALSE
PR.FOUND = FALSE
LBL.CN = ZERO
LBL.CN.MAX = ZERO
IN.LBLS = EMPTY
OUT.LBLS = EMPTY
*
! Perform Screen Generation if necessary
*
IF OUT.FILE.ID NE EMPTY THEN
IF ITEM.ID[ONE,3] EQ "SH." AND SH.CN EQ ONE THEN
*
TMP.ID = ITEM.ID[4,9999]
IF TMP.ID[ONE,5] EQ "SUBR." THEN TMP.ID = TMP.ID[6,9999]
*
EXEC.IN = "1":AM:"SCREENS":AM:MD.ITEM<3>:AM:"IBP":AM:TMP.ID:AM:TERM.DISP + ZERO
*
EXEC.VERB = "SOURCEGEN"
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
END
END
*
*
! Read item
*
READ ITEM FROM IN.FILE,ITEM.ID THEN
*
! Classify item
*
LIST.EMPTY = FALSE
ATTRONE = ITEM<ONE>
ATTRONE = FIELD(ATTRONE," ",ONE)
ATTRONE = FIELD(ATTRONE,":",ONE)
IF ATTRONE[ONE,ONE] EQ "*" THEN ATTRONE = ATTRONE[TWO,999]
IF ATTRONE EQ "PQ" OR ATTRONE EQ "PQN" THEN ATTRONE = "PROC"
ITEM.TYPE = ATTRONE
IF VALID.ITEM.TYPE EQ "ALL" OR INDEX(VALID.ITEM.TYPE,"*":ITEM.TYPE:"*",ONE) THEN
*
! Call for each item
*
IF RUN.TYPE EQ TWO THEN
IF ITEM.TYPE NE OLD.ITEM.TYPE THEN
*
OLD.ITEM.TYPE = ITEM.TYPE
READ PROCESS.REC.TYPE FROM SYS.FILE,"ITEM.TYPE@":ITEM.TYPE:"@":OPSYS THEN PRT.FOUND = TRUE ELSE
READ PROCESS.REC.TYPE FROM SYS.FILE,"ITEM.TYPE@":ITEM.TYPE THEN PRT.FOUND = TRUE ELSE
PRT.FOUND = FALSE
END
END
*
IF PRT.FOUND THEN
FINDS   = PROCESS.REC.TYPE<4>
VPARAMS = PROCESS.REC.TYPE<5>
EPARAMS = PROCESS.REC.TYPE<6>
IPARAMS = PROCESS.REC.TYPE<7>
END ELSE
FINDS   = PROCESS.REC<4>
VPARAMS = PROCESS.REC<5>
EPARAMS = PROCESS.REC<6>
IPARAMS = PROCESS.REC<7>
END
END
END
*
*
IF ITEM.CLL NE EMPTY THEN
*
IF NOT(PR.FOUND) THEN
LN.DISP = "[=| ":"*** FOUND *** ":ITEM.ID; GOSUB DISP.LINE
LN.DISP = "[=| Item type: ":ITEM.TYPE; GOSUB DISP.LINE
END
*
IF ITEM.CLL[ONE,ONE] EQ "@" THEN
CLLNM = "CODE.CONV.":ITEM.CLL[TWO,999]
END ELSE
CLLNM = ITEM.CLL
END
*
VALID = FALSE
CALL @CLLNM(VALID,ITEM,COMMN.FLAG,ITEM.ID)
IF VALID THEN FOUND = TRUE
END; * OF ITEM.CLL
*
!! Loop for FTXT.CN.MAX string locations
*
FTXT.CN.MAX = DCOUNT(FINDS,VM)
*
FOR FTXT.CN = ONE TO FTXT.CN.MAX
*
THIS = FINDS<ONE,FTXT.CN>
AM.TC.CN = INDEX(ITEM,THIS,ONE)
*
IF AM.TC.CN THEN
*
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "[=| "; GOSUB DISP.LINE
IF NOT(PR.FOUND) THEN
LN.DISP = "[=| ":"*** FOUND *** ":ITEM.ID; GOSUB DISP.LINE
LN.DISP = "[=| Item type: ":ITEM.TYPE; GOSUB DISP.LINE
END
LN.DISP = "[=| ":("***":FTXT.CN:"***") "L#10":THIS; GOSUB DISP.LINE
END
*
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
IF NOT(PR.FOUND) THEN
LN.DISP =  RVB:"[=| ":"*** FOUND *** ":ITEM.ID:RVE; GOSUB DISP.LINE
LN.DISP =  RVB:"[=| Item type: ":ITEM.TYPE:RVE; GOSUB DISP.LINE
PR.FOUND = TRUE
END
LN.DISP = RVB:"[=| ":("***":FTXT.CN:"***") "L#10":THIS:RVE; GOSUB DISP.LINE
*
!! Loop to find all occurances of string
FOUND = TRUE
*  FTXT<LIST.CN,FTXT.CN>=THIS
FTXT<ONE,FTXT.CN> = THIS
FLIN.CN = ZERO
*
LOOP
*
FLIN.CN = FLIN.CN + ONE
AM.TC.CN=INDEX(ITEM,THIS,FLIN.CN)
*
WHILE AM.TC.CN DO
*
AM.CN.LOC = DCOUNT(ITEM[ONE,AM.TC.CN],AM)
LINE = ITEM<AM.CN.LOC>
ORIG.LINE = LINE
*
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "[=| ":AM.CN.LOC "R#4":" "
TMP = "*%%":"MDD":"%%="
IF LINE[ONE,9] NE TMP THEN
LN.DISP = LN.DISP:"        "
END
LN.DISP = LN.DISP:LINE; GOSUB DISP.LINE
END
*
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| ":AM.CN.LOC "R#4":" "
TMP = "*%%":"MDD":"%%="
IF LINE[ONE,9] NE TMP THEN
LN.DISP = LN.DISP:"        "
END
LN.DISP = LN.DISP:LINE; GOSUB DISP.LINE
END
*
! Process additional validate parameters if present
*
VALS = VPARAMS<ONE,FTXT.CN>
VALID = TRUE
*
IF LEN(VALS) THEN
CALL SEARCH.VALIDATE(LINE,THIS,VALS,VALID)
END
*
! If code type present *%%???%%= then process it
*
IF VALID AND LEN(IN.CODE.TYPE) THEN
IN.VER     = IN.CODE.TYPE
OUT.VER    = OUT.CODE.TYPE
CODE.VER   = EMPTY
CODE.EXT.C = EMPTY
GEN.OLD.FLAG = EMPTY
CALL SEARCH.VALIDATE.VERSION(ORIG.LINE,LINE,IN.VER,OUT.VER,VALID,CODE.VER,CODE.EXT.C,NULLS.FLAG,EXISTING.FLAG,REM.FLAG,GEN.OLD.FLAG,ITEM.TYPE)
END ELSE CODE.VER = OUT.CODE.TYPE
*
! Perform extractions if present
*
IF VALID THEN
* PRINT "[=| ":AM.CN.LOC "R#4 ":">>> ":
EVALS = EPARAMS<ONE,FTXT.CN>
IF LEN(EVALS) THEN
CALL SEARCH.PARAM.EXTRACT(LINE,THIS,EVALS,VALID,EXT.PARAMS)
END ELSE EXT.PARAMS = EMPTY; * Of EVALS
*
IF VALID THEN
IVALS = IPARAMS<ONE,FTXT.CN>
IN.LINE = LINE
LBL.VERB = THIS
*
* Perform calls (@xxxxxxxxxxxxxxxx)
*
IF IVALS[ONE,ONE] EQ "@" THEN
IF IVALS EQ "@DB.ST.LBLS.NUM" THEN
CALL CODE.CONV.DB.ST.LBLS.NUM(VALID,LBL.VERB,IN.LINE,OUT.LINE,IN.LBLS,OUT.LBLS,LBL.CN,LBL.CN.MAX,COMMN.FLAG,AM.CN.LOC,STD.FLAG,ITEM)
IF VALID THEN LINE = OUT.LINE
END ELSE
CLLNM = "CODE.CONV.":IVALS[TWO,9999]
CALL @CLLNM(VALID,IN.LINE,OUT.LINE,COMMN.FLAG)
IF VALID THEN LINE = OUT.LINE
END
*
* Otherwise perform output parameter processing if present
*
END ELSE IF LEN(IVALS) THEN
CALL SEARCH.PARAM.OUTPUT(LINE,EXT.PARAMS,IVALS,VALID,ORIG.LINE,OUT.LINE)
*
END ELSE
*OUT.LINE = LINE
OUT.LINE = EMPTY
END
*
*ITEM = 
*
IF VALID THEN
*           ITEM.PREF = ITEM[ONE,I]
*           ITEM.SUFF = ITEM[I + ONE,32267]
*           ITEM.PREF<AM.CN.LOC> = EMPTY
*           ITEM.SUFF<ONE> = EMPTY
*           ITEM = ITEM.PREF:OUT.LINE:ITEM.SUFF
*
*            PRINT "[=| "
IF OUT.CODE.TYPE NE EMPTY THEN
TCN = ZERO
LOOP TCN = TCN + ONE WHILE OUT.LINE<TCN> NE EMPTY DO
OUT.LINE<TCN> = "*%%":OUT.CODE.TYPE:"%%=":OUT.LINE<TCN>
REPEAT
END
*
IF STD.FLAG THEN
*
IF CODE.VER EQ EMPTY THEN
CODE.VER = IN.CODE.TYPE
CODE.EXT.C = '='
END
*
IF ORIG.LINE[ONE,3] EQ "*%%" THEN
TEMP.LINE = ORIG.LINE[10,9999]
END ELSE TEMP.LINE = ORIG.LINE
*
IF GEN.OLD.FLAG THEN
OUT.LINE = "*%%":CODE.VER:"%%":CODE.EXT.C:TEMP.LINE:AM:OUT.LINE
END ELSE
IF ORIG.LINE[ONE,6] NE "*%%":OUT.CODE.TYPE[ONE,3] THEN
OUT.LINE = "*%%":CODE.VER:"%%":CODE.EXT.C:TEMP.LINE:AM:OUT.LINE
END
END; * OF GEN.OLD.FLAG
END; * OF STD.FLAG
*
*
TCN = ZERO
LOOP TCN = TCN + ONE WHILE OUT.LINE<TCN> NE EMPTY DO
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "|||> ":TCN "R#3":OUT.LINE<TCN>; GOSUB DISP.LINE
END
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "|||> ":TCN "R#3":OUT.LINE<TCN>; GOSUB DISP.LINE
END
REPEAT
ITEM = REPLACE(ITEM,AM.CN.LOC,ZERO,ZERO,OUT.LINE)
*
**NOTE:A STATEGY WHERE THE NUMBER OF OCCURANCES OF "THIS"
*WITHIN EVALS C/B COUNTED AND APPLIED WETHER THE STANDARD.FLAG WAS
*TURNED ON OR NOT....
*871017
*
**********
TEMP.ADJ = ONE
IF STD.FLAG THEN
ADJ.FLAG = TRUE
END ELSE
IF IVALS[ONE,ONE] NE "@" THEN
IF INDEX(IVALS,THIS,ONE) THEN ADJ.FLAG = TRUE ELSE ADJ.FLAG = FALSE
END ELSE ADJ.FLAG = TRUE
END
*
IF ADJ.FLAG THEN
LOOP WHILE INDEX(OUT.LINE,THIS,TEMP.ADJ) DO TEMP.ADJ = TEMP.ADJ + ONE REPEAT
FLIN.CN = FLIN.CN + TEMP.ADJ - TWO
END ELSE
FLIN.CN = FLIN.CN - ONE
END
*
*
END
*
*
END
*
*
END
*
*
FLIN<ONE,FTXT.CN,FLIN.CN> = AM.CN.LOC:VALID
*
*
REPEAT
*
!  for string location number AM.TC.CN
*
END; * Of AM.TC.CN
*
*
NEXT FTXT.CN
*
!     (next string to look for)
*
END; *# OF ITEM.TYPE MATCH
*
! Check to see if found
*
IF NOT(FOUND) THEN
* IF NOT(PHANTOM.FLAG) THEN
* IF LPTR.FL.SAVE EQ TWO THEN
* LPTR.FL = LPTR.FL.SAVE - ONE
* PRINT "[=| ":ITEM.ID:" not present . . ."
* PRINT "[=| ":"Item type: ":ITEM.TYPE
* END
* LPTR.FL = FALSE
* PRINT "[=| ":ITEM.ID:" not present . . ."
* PRINT "[=| ":"Item type: ":ITEM.TYPE
* END
*
! Found
*
END ELSE
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "[=| "; GOSUB DISP.LINE
END
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
END
*
IN.LBLS.CN.MAX = DCOUNT(IN.LBLS,AM)
*
FOR LPTR.CN = ONE TO TWO UNTIL NOT(IN.LBLS.CN.MAX)
*
IF (LPTR.CN EQ ONE AND TERM.DISP) OR (LPTR.CN EQ TWO AND LPTR.FL.SAVE EQ TWO) THEN
*
IF LPTR.CN EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE ELSE LPTR.FL = FALSE
*
LN.DISP = "[=| ":"X-REF OF STRING TO NUM LABEL"; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
FOR IN.LBLS.CN = ONE TO IN.LBLS.CN.MAX
*
LN.DISP = "[=| ":(IN.LBLS<IN.LBLS.CN>:"....................................") "L#30":" ":OUT.LBLS<IN.LBLS.CN>; GOSUB DISP.LINE
*
NEXT IN.LBLS.CN
*
END
*
NEXT LPTR.CN
*
*
*
LIST<LIST.CN> = ITEM.ID
LIST.CN = LIST.CN + ONE
*
*
END; *# OF FOUND / NOT(FOUND) HANDLING
*
*
IF OUT.FILE.ID NE EMPTY THEN
WRITE ITEM ON OUT.FILE,ITEM.ID
END
*
END; *# OF SUCCESSFUL READ OF ITEM
*
!
*
WRITE FTXT ON LISTS.FILE,"@S@FTXT@":FILE.ID:"@":SYS.RUN.NAME:"@":ITEM.ID
IF LIST NE EMPTY THEN
WRITE LIST ON LISTS.FILE,"@S@LIST@":FILE.ID:"@":SYS.RUN.NAME
END
WRITE FLIN ON LISTS.FILE,"@S@FLIN@":FILE.ID:"@":SYS.RUN.NAME:"@":ITEM.ID
FTXT = EMPTY
FLIN = EMPTY
*
! repeat for SH. loop
*
END; * OF LE 3 (4 & SUBR) (5 & CSEG)
*
REPEAT
*
! repeat for next ITEM.ID loop
*
REPEAT
*
!! END OF PROGRAM
*
IF LPTR.FL.SAVE EQ TWO THEN LPTR.CN.MAX = TWO ELSE LPTR.CN.MAX = ONE
*
FOR LPTR.CN = ONE TO LPTR.CN.MAX
*
IF (LPTR.CN EQ ONE AND TERM.DISP) OR (LPTR.CN EQ TWO AND LPTR.FL.SAVE EQ TWO) THEN
*
IF LPTR.CN EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE ELSE LPTR.FL = FALSE
*
CN = ZERO
LOOP CN = CN + ONE UNTIL LIST<CN> EQ EMPTY DO
*
IF CN EQ ONE THEN
*
IF LPTR.FL THEN
LN.CN = 99999
END ELSE
LN.CN.TERM = 99999
END
*
LN.DISP = "[=| ":STR("*",70); GOSUB DISP.LINE
LN.DISP = "[=| ":"Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILE.ID; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",20); GOSUB DISP.LINE
LN.DISP = "[=| ":"       STRINGS"; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",20); GOSUB DISP.LINE
*
FTXT.CN.MAX = DCOUNT(FINDS,VM)
FOR C = ONE TO FTXT.CN.MAX
LN.DISP = "[=| ":FINDS<ONE,C>; GOSUB DISP.LINE
NEXT C
*
LN.DISP = "[=| ":STR("*",20); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",50); GOSUB DISP.LINE
LN.DISP = "[=| ":"SUMMARY LISTING OF PROGRAMS WHERE STRING(s) FOUND"; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",50); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
END; * Of CN EQ ONE
*
LN.DISP = "[=| ":LIST<CN>; GOSUB DISP.LINE
*
*$INCLUDE DH.IBP SEARCH.PRINT.MAP
*
REPEAT
*
IF LIST NE EMPTY THEN
LN.DISP = "[=| ":"'SELECT.LIST' FILED"; GOSUB DISP.LINE
END
*
END
*
NEXT LPTR.CN 
*
!
*
IF LIST NE EMPTY THEN
WRITE LIST ON LISTS.FILE,"@S@LIST@":FILE.ID:"@":SYS.RUN.NAME
*   WRITE FTXT ON LISTS.FILE,"@S@FTXT@":FILE.ID:"@":SYS.RUN.NAME
*   WRITE FLIN ON LISTS.FILE,"@S@FLIN@":FILE.ID:"@":SYS.RUN.NAME
END ELSE
LN.DISP = "[=| ":"NO ITEMS FOUND"; GOSUB DISP.LINE
*   DELETE LISTS.FILE,"@LIST"
*   DELETE LISTS.FILE,"@FTXT"
*   DELETE LISTS.FILE,"@FLIN"
IF LIST.EMPTY THEN
IF PROC.FL THEN
PROC.BUFFER<ONE> = "ABORT"
* ULT ONLY
PROCWRITE PROC.BUFFER
END
END
END
*
! FINISH
*
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"* * * * *   Type any key to return to TCL . . .    * * * * * * *"; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
* FOR A = ONE TO 5 UNTIL SYSTEM(11)
LN.DISP = "[=| ":CHAR(7); GOSUB DISP.LINE
FOR B = ONE TO 3 UNTIL SYSTEM(11)
LN.DISP = "[=| ":CHAR(7); GOSUB DISP.LINE
EXECUTE "SLEEP 2"
NEXT B
FOR B = ONE TO 3 UNTIL SYSTEM(11)
LN.DISP = CHAR(7); GOSUB DISP.LINE
*      RQM
NEXT B
* NEXT A
*
*
STOP
*
!! SUBROUTINES
*
! LINE DISPLAY
*
DISP.LINE: *
*
IF LPTR.FL THEN
CALL PRINTER.ON(STAT)
END
*
LOOP
*
IF NOT(LPTR.FL) THEN
LN.CN.TERM = LN.CN.TERM + ONE
WDTH = "L#":CL.CN.MAX.TERM
IF LN.CN.TERM GT LN.CN.MAX.TERM THEN GOSUB LPTR.HEADER
PRINT @(ZERO,LN.CN.TERM):CLL:
END ELSE
LN.CN = LN.CN + ONE
WDTH = "L#":CL.CN.MAX
IF LN.CN GT LN.CN.MAX THEN GOSUB LPTR.HEADER
END
*
PRINT LN.DISP WDTH
*
IF LPTR.FL THEN
LN.DISP = LN.DISP[CL.CN.MAX + ONE,99999]
END ELSE
LN.DISP = LN.DISP[CL.CN.MAX.TERM + ONE,99999]
END
*
WHILE LEN(LN.DISP) DO
*
LN.DISP = "[=| ++++ ":LN.DISP
*
REPEAT
*
*
IF LPTR.FL THEN
* PRINT
PRINTER OFF
END
*
RETURN
*
! HEADER HANDLING
*
LPTR.HEADER: *
*
IF LPTR.FL THEN
PG.CN = PG.CN + ONE
LN.CN = 7
END ELSE
PG.CN.TERM = PG.CN.TERM + ONE
LN.CN.TERM = 4
END
*
IF NOT(LPTR.FL) THEN
IF NOT(NOPAGE.FL) THEN
PRINT @(ZERO,22):CLL:"Enter <cr> to continue . . . ":
INPUT CONT.RSP:
PRINT @(ZERO,22):CLL:
IF CONT.RSP EQ "KILL" OR CONT.RSP EQ "END" THEN STOP
IF CONT.RSP EQ "GO" THEN NOPAGE.FL = TRUE
END
FOR TMP = ONE TO 4; PRINT @(ZERO,TMP):CLL:; NEXT TMP
PRINT @(ZERO,ZERO):
FIRST.PG.TERM = FALSE
*
END ELSE
IF NOT(FIRST.PG) THEN
IF FAST.FL THEN PRINTER CLOSE
IF FAST.FF THEN
PRINT EOS:
END
END
FIRST.PG = FALSE
END
*
IF LPTR.FL THEN TMP = PG.CN ELSE TMP = PG.CN.TERM
PRINT OCONV(DATE(),"D2") "L#14":(SPACE(25 - INT(LEN(TITLE) / TWO + .5)):TITLE) "L#50":("Page ":TMP) "R#14"
PRINT OCONV(TIME(),"MTS") "L#14":(SPACE(25 - INT(LEN(TITLE1) / TWO + .5)):TITLE1) "L#50":WHO "R#14"
PRINT
IF LPTR.FL THEN
PRINT STR("*",CL.CN.MAX)
END ELSE
PRINT STR("*",CL.CN.MAX.TERM)
END
PRINT
*
RETURN
*
!
*
END
~BP.FILES~
MACRO.UTILS
BP
BP.UTL
IBP
BP.CONV
BP.INST
MDD.IBP
MDD.BP.UTL
~CODE.CONV.CLS.ROUTINE~
SUBROUTINE CODE.CONV.CLS.ROUTINE(VALID,IN.LINE,OUT.LINE,COMMN.FLAG)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   07 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
*
OUT.LINE = ''
OUT.LINE = OUT.LINE:"!":AM
OUT.LINE = OUT.LINE:"9901: *":AM
OUT.LINE = OUT.LINE:"PRINT @(CLS.COL,CLS.ROW):CLS:":AM
OUT.LINE = OUT.LINE:"RETURN"
*
RETURN
*
END
~CODE.CONV.DB.ST.LBLS.NUM~
SUBROUTINE CODE.CONV.DB.ST.LBLS.NUM(VALID,LBL.VERB,IN.LINE,OUT.LINE,IN.LBLS,OUT.LBLS,LBL.CN,LBL.MAX,COMMN.FLAG,J,STD.FLAG,ITEM)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   20 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
K = J
OUT.LINE = IN.LINE
IF LBL.VERB = ": " THEN
CN = 0
END ELSE
CN = 1
END
VALID = 0
*
LOOP
CN = CN + 1
LBL.TEMP = INDEX(OUT.LINE,LBL.VERB,CN-1)
IF LBL.TEMP THEN
LBL.POS1 = LBL.TEMP
IF LBL.VERB NE ": " AND LBL.POS1 GT 1 THEN
IF NOT(INDEX(" ;",OUT.LINE[LBL.POS1-1,1],1)) THEN
LBL.TEMP = ''
LBL.VAL = ''
LBL.POS1 = ''
LBL.POS2 = ''
END
END
IF LBL.TEMP NE "" THEN
LBL.POS2 = INDEX(OUT.LINE,LBL.VERB,CN)
IF NOT(LBL.POS2) THEN LBL.POS2 = LEN(OUT.LINE)
LBL.VAL = OUT.LINE[LBL.POS1,9999]
END
END ELSE
LBL.VAL = ''
LBL.POS1 = ''
LBL.POS2 = ''
END
*
CONT = LEN(LBL.VAL)
IF LBL.VERB = ": " THEN CONT = ''
WHILE CONT OR CN < 2 DO
IF CN NE 1 OR LBL.VERB = ": " THEN
IF LBL.VERB EQ ": " OR CN = 1 THEN
CN1 = 1
LBL.START = 1
END ELSE
CN1 = LBL.POS1+LEN(LBL.VERB) 
LBL.START = CN1
END
CONT = 1
*PRINT ("[=> ":OUT.LINE[CN1,LBL.POS2-CN1+1]) "L#45":" <=]"
*PRINT "[=>|":
LOOP
*PRINT "^":
TC = OUT.LINE[CN1,1]
IF INDEX(";:* ",TC,1) OR TC EQ "" THEN
LBL.VAL = OUT.LINE[LBL.START,CN1-LBL.START]
CONT = 0
TCN1 = 0
LOOP WHILE TC EQ " " DO
TCN1 = TCN1 + 1
LBL.POS2 = LBL.POS2 + 1
TC = OUT.LINE[CN1+TCN1,1]
*PRINT "b":
REPEAT
END
WHILE TC NE "" AND CONT DO
*PRINT "^":
CN1 = CN1 + 1
LBL.POS2 = LBL.POS2 + 1
REPEAT
*
*PRINT
*PRINT "[=> ":"Label: ":LBL.VAL
*PRINT
*
OUT.LBL.COMMENT = ''
IF LBL.VERB = ": " AND LBL.VAL NE "" THEN
IF OUT.LINE[1,1] EQ "*" AND OUT.LINE[2,2] NE "%%" THEN LBL.VAL = ""; IF TERM.DISP THEN PRINT "<<<NOT LBL>>>"
IF OUT.LINE[CN1,1] NE ":" THEN LBL.VAL = ""; IF TERM.DISP THEN PRINT "<<<NOT LBL>>>"
IF OUT.LINE[CN1+2,1] EQ "*" THEN OUT.LBL.COMMENT = "* ":LBL.VAL
END
*
IF LBL.VAL NE "" THEN
CN1 = CN1 + TCN1
VALID = 1
*
OUT.LBL.VAL = ''
TEMP.LBL = LBL.VAL
OUT.LBL.CN = COUNT(LBL.VAL,",")+1
FOR CN9 = 1 TO OUT.LBL.CN
LBL.VAL = FIELD(TEMP.LBL,",",CN9)
IF LBL.VAL = "" THEN
K = K+1
TEMP1 = ITEM<K>
OUT.LBL.CN = OUT.LBL.CN + COUNT(TEMP1,",")
TEMP.LBL = TEMP.LBL:TRIM(ITEM<K>)
LBL.VAL = FIELD(TEMP.LBL,",",CN9)
ITEM<K> = "*":ITEM<K>
END
LBL.FOUND = 1
LOCATE LBL.VAL IN IN.LBLS,1 BY "AL" SETTING LBL.LOC ELSE LBL.FOUND = ''
IF LBL.FOUND THEN
LBL.NUM = OUT.LBLS<LBL.LOC>
END ELSE IF NOT(NUM(LBL.VAL)) AND LBL.VAL NE "CLS.ROUTINE" THEN
IN.LBLS = INSERT(IN.LBLS,LBL.LOC,0,0,LBL.VAL)
LBL.MAX = LBL.MAX + 100
LBL.NUM = LBL.MAX
OUT.LBLS = INSERT(OUT.LBLS,LBL.LOC,0,0,LBL.NUM)
LBL.CN = LBL.CN + 1
END ELSE
IN.LBLS = INSERT(IN.LBLS,LBL.LOC,0,0,LBL.VAL)
LBL.NUM = LBL.VAL
IF LBL.NUM = "CLS.ROUTINE" THEN LBL.NUM = "9901"
OUT.LBLS = INSERT(OUT.LBLS,LBL.LOC,0,0,LBL.NUM)
LBL.CN = LBL.CN + 1
END
* OF LBL.VAL NOT FOUND
IF OUT.LBL.VAL NE '' THEN OUT.LBL.VAL = OUT.LBL.VAL:","
OUT.LBL.VAL = OUT.LBL.VAL:LBL.NUM
*
NEXT CN9
* LOOP FOR ON GOSUB/GOTO
*
*
IF LBL.VERB NE ": " THEN
*
OUT.LINE = OUT.LINE[1,LBL.POS1-1]:LBL.VERB:OUT.LBL.VAL:" ":OUT.LINE[CN1,9999]
*
*OUT.LINE = OUT.LINE[1,LBL.POS1-1]:OUT.LINE[LBL.POS2,9999]:LBL.VERB:LBL.NUM:" "
END ELSE
OUT.LINE = OUT.LBL.VAL:" ":OUT.LBL.COMMENT:IN.LINE[LBL.POS2+2,9999]
END
IF TERM.DISP THEN PRINT "v"
IF TERM.DISP THEN PRINT "MAX>":LBL.MAX:"c>":LBL.VAL:".r>":LBL.NUM:"<|||"
IF TERM.DISP THEN PRINT IN.LINE
IF TERM.DISP THEN PRINT OUT.LINE
IF TERM.DISP THEN PRINT "^"
END
** OF LBL.VAL NE ""
*
END
** OF CN NE 1 OR LBL.VERB EQ ": "
*
REPEAT
* FOR MULTIPLE LABELS PER LINE  ( ONCE ONLY FOR ': ')
*
*
RETURN
* TO CALLING PROGRAM
*
END
~CODE.CONV.INCLUDE.ROUTINE~
SUBROUTINE CODE.CONV.INCLUDE.ROUTINE(VALID,IN.LINE,OUT.LINE,COMMN.FLAG)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   20 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
*
PARAM.1 = FIELD(IN.LINE," ",2)
PARAM.2 = FIELD(IN.LINE," ",3)
PRINT " >>>1>>> ":PARAM.1:" >>>2>>> ":PARAM.2
OPEN PARAM.1 TO INP.FILE ELSE
PRINT "!!!! INPUT FILE NOT FOUND: ":PARAM.1
PRINT BELL
PRINTER ON
PRINT "!!!! INPUT FILE NOT FOUND: ":PARAM.1
PRINT BELL
PRINTER OFF
VALID = 0
END
*
READ OUT.LINE FROM INP.FILE,PARAM.2 ELSE
PRINT "!!!! INPUT ITEM NOT FOUND: ":PARAM.2
PRINT BELL
PRINTER ON
PRINT "!!!! INPUT ITEM NOT FOUND: ":PARAM.2
PRINT BELL
PRINTER OFF
VALID = 0
END
*
RETURN
*
END
~CODE.CONV.STATEMENTS~
PQN
C
C
C
HEDIT-LIST STATEMENTS.CONV
STON
HDE9999<
HF<
HI<
HSTAT.BEGIN<
HSTAT.CRITERIA<
HSTAT.MAIN.LOOP<
HSTAT.PRINT.95X70<
HSTAT.PRINT.95X73<
HSTAT.PRINT.LINDSAY<
H<
HFI<
P
C
C
C
HGET-LIST STATEMENTS.CONV
STON
HED IN.FILE<
HP9 RU9999/GOTO NXT/GOTO 9731/FRU9999/GOSUB NXT/GOSUB 9731/FRU9999/NXT: */9731: * NXT/F<
HP8 RU9999/GOTO EXDATA/GOTO 9732FRU9999/GOSUB EXDATA/GOSUB 9732/FRU9999/EXDATA: */9732: * EXEC.DATA/F<
HP7 RU9999/GOTO GEN.STMT/GOTO 9733FRU9999/GOSUB GEN.STMT/GOSUB 9733/FRU9999/GEN.STMT: */9733: * GEN.STMT/F<
HP6 RU9999/GOTO GET.ADDRESSES/GOTO 9734FRU9999/GOSUB GET.ADDRESSES/GOSUB 9734/FRU9999/GET.ADDRESSES: */9734: * GET.ADDRESSES/F<
HP5 RU9999/GOTO GET.PO.BOX/GOTO 9735FRU9999/GOSUB GET.PO.BOX/GOSUB 9735/FRU9999/GET.PO.BOX: */9735: * GET.PO.BOX/F<
HP4 RU9999/GOTO CALL.MENU/GOTO 9736FRU9999/GOSUB CALL.MENU/GOSUB 9736/FRU9999/CALL.MENU: */9736: * CALL.MENU/F<
HPD<
HP3 P9P8P7P6P5P4FIP3<
HP3<
P
C
C
HGET-LIST STATEMENTS.CONV
STON
HED IN.FILE<
HP9 RU9999/GOTO GEN.MASK/GOTO 9741/FRU9999/GOSUB GEN.MASK/GOSUB 9741/FRU9999/GEN.MASK: */9741: * GEN.MASK/F<
HP8 RU9999/GOTO SU.PL/GOTO 9742FRU9999/GOSUB SU.PL/GOSUB 9742/FRU9999/SU.PL: */9742: * SU.PL/F<
HP7 RU9999/GOTO MPG/GOTO 9743FRU9999/GOSUB MPG/GOSUB 9743/FRU9999/MPG: */9743: * MPG/F<
HP6 RU9999/GOTO SU.HDR/GOTO 9744FRU9999/GOSUB SU.HDR/GOSUB 9744/FRU9999/SU.HDR: */9744: * SU.HDR/F<
HP5 RU9999/GOTO SU.MG/GOTO 9745FRU9999/GOSUB SU.MG/GOSUB 9745/FRU9999/SU.MG: */9745: * SU.MG/F<
HP4 RU9999/GOTO SU.AD/GOTO 9746FRU9999/GOSUB SU.AD/GOSUB 9746/FRU9999/SU.AD: */9746: * SU.AD/F<
HP3 RU9999/GOTO PSTMTS/GOTO 9747FRU9999/GOSUB PSTMTS/GOSUB 9747/FRU9999/PSTMTS: */9747: * PSTMTS/F<
HPD<
HP2 P9P8P7P6P5P4P3FIP2<
HP2<
P
C
C
RTN
~CODE.CONV.STATEMENTS.RESTORE~
PQN
C
C
C
HEDIT-LIST STATEMENTS.CONV
STON
HDE9999<
HF<
HI<
HSTAT.BEGIN<
HSTAT.CRITERIA<
HSTAT.MAIN.LOOP<
HSTAT.PRINT.95X70<
HSTAT.PRINT.95X73<
HSTAT.PRINT.LINDSAY<
H<
HFI<
P
C
C
C
HGET-LIST STATEMENTS.CONV
STON
HCOPY OLD.FILE (O)<
H(IN.FILE<
P
C
C
RTN
~CODE.CONV.TERMINAL~
SUBROUTINE CODE.CONV.TERMINAL(VALID,ITEM,COMMN.LIST,ID)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   12 SEP 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU CSEG TO 1
EQU SUBR TO 2
EQU PROG TO 3
EQU OTHR TO 4
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
!
*
OPEN "MD" TO MD.FILE ELSE
PRINT "MD FILE MISSING"
STOP
END
*
! Load Special Cases List
*
READ SPEC.LIST FROM MD.FILE,"SPEC" THEN
SPEC.STRING = "*"
CN = ZERO
LOOP
CN = CN + ONE
WHILE SPEC.LIST<CN> NE EMPTY DO
SPEC.STRING = "*":SPEC.LIST<CN>:SPEC.STRING
REPEAT
END ELSE
SPEC.STRING = "*ADD.ID*PRINTER.ON*CALC.CHARGES*CALC.RENT*GET.ICONV*MOD11.DIGIT*AUTO.LOADER*LOCK.ITEM*UNLOCK.ITEM*INPUT.DATA*STANDARD.FUNCTIONS.CALL*STANDARD.FUNCTIONS.CALL1*STANDARD.FUNCTIONS.CALL2*PACK.NUMBER*UNPACK.NUMBER*"
END
*
! Read string to insert into calls
*
READ STD.LIST FROM MD.FILE,"STD.STRING" THEN
STD.STRING = EMPTY
CN = ZERO
LOOP
CN = CN + ONE
WHILE STD.LIST<CN> NE EMPTY DO
STD.STRING = STD.STRING:",":STD.LIST<CN>
REPEAT
IF STD.STRING[ONE,ONE] EQ "," THEN STD.STRING = STD.STRING[2,999]
END ELSE
STD.STRING = "BELL,LF,FF,CR,AM,VM,SVM,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLB,RVB,RVE,RVH,AUX.ON,AUX.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE,TT"
END
*
! Set routine type
*
VALID = CSEG
ITEM.LINE1 = ITEM<ONE>
IF ITEM.LINE1[2,12] EQ "CODE.SEGMENT" THEN VALID = CSEG ELSE
IF ITEM.LINE1[1,10] EQ "SUBROUTINE" THEN VALID = SUBR ELSE
IF ITEM.LINE1[2,7] EQ "PROGRAM" THEN VALID = PROG ELSE
VALID = OTHR
END
END
END
*
! Is this a special routine?
*
IF INDEX(SPEC.STRING,"*":ID:"*",ONE) THEN SPEC.FLAG = ONE ELSE SPEC.FLAG = ZERO
*
! Locate standard.functions
*
STD.FLAG = INDEX(ITEM,"STANDARD.FUNCTIONS",1)
STD.LOC = DCOUNT(ITEM[1,STD.FLAG],AM)
*
IF STD.LOC EQ ONE THEN
STD.FLAG = INDEX(ITEM,"STANDARD.FUNCTIONS",2)
END
*
IF STD.FLAG THEN
STD.LOC = DCOUNT(ITEM[1,STD.FLAG],AM)
IF INDEX(ITEM<STD.LOC + ONE>,"STANDARD.FUNCTIONS",1) THEN STD.LOC = STD.LOC + ONE
END ELSE
STD.LOC = ZERO
END
*
* 35 line limit on standard.functions
IF STD.LOC GT 35 THEN STD.LOC = ZERO
*
! See if COMMON is in this item
*
COMMN.FLAG = INDEX(ITEM,"COMMON",1)
COM.LOC = ZERO
*PRINT "COMMN.FLAG IS ":COMMN.FLAG
*
IF COMMN.FLAG THEN
IF TERM.DISP THEN PRINT "COMMON WORD DETECTED"
COM.LOC = DCOUNT(ITEM[1,COMMN.FLAG],AM)
COM.LINE = ITEM<COM.LOC>
IF TERM.DISP THEN PRINT "LINE IS ":COM.LINE
COMMN.FLAG = INDEX(COM.LINE,".COMMON",1)
COM.LINE = COM.LINE[ONE,COMMN.FLAG-ONE]
TMP = COUNT(COM.LINE," ")
COMMN.NAME = FIELD(COM.LINE," ",TMP+ONE)
IF TERM.DISP THEN PRINT "ITEM ID IS ":COMMN.NAME:".LIST"
READ COMMN.LIST FROM MD.FILE,COMMN.NAME:".LIST" THEN PRINT "FOUND" ELSE COMMN.LIST = EMPTY; COMMN.FLAG = FALSE
END ELSE
COM.LOC = ZERO
COMMN.NAME = EMPTY
END
*
IF COM.LOC GT 35 THEN COM.LOC = ZERO; COMMN.FLAG = ZERO
*
IF (ID[ONE,4] EQ "GET." OR ID[ONE,3] EQ "SH.") AND NOT(COM.LOC) THEN COM.LOC = TWO
*
!! Process items
*
! Code Segment
*
IF VALID EQ CSEG THEN
*
IF STD.LOC THEN
IF ITEM<STD.LOC + ONE> NE "*OVERRIDE" THEN ITEM = DELETE(ITEM,STD.LOC,ZERO,ZERO)
VALID = 5
END
*
! Subroutine
*
END ELSE IF VALID EQ SUBR THEN
*
! Subroutine has common
*
IF COM.LOC OR SPEC.FLAG THEN
*
IF STD.LOC THEN
*
IF ITEM<STD.LOC + ONE> EQ "*SETTERM" THEN
ITEM = INSERT(ITEM,STD.LOC - ONE,ZERO,ZERO,'TT = "R"; OPSYS = "':OPSYS:'"')
STD.LOC = STD.LOC + ONE
END
*
! No over-ride or over-ride with an include
*
IF ITEM<STD.LOC + ONE> NE "*OVERRIDE" AND ITEM<STD.LOC + ONE> NE "*OVERINCL" THEN
*
* put a call in
IF ITEM<STD.LOC + ONE> EQ "*OVERCALL" THEN
ITEM<STD.LOC> = "CALL STANDARD.FUNCTIONS.CALL4(":STD.STRING:")"
END ELSE
* just delete the line
ITEM = DELETE(ITEM,STD.LOC,ZERO,ZERO)
END; * OF *OVERCALL
*
END ELSE
*
! Over ride
*
IF ITEM<STD.LOC + 2> EQ "*SETTERM" THEN
ITEM = INSERT(ITEM,STD.LOC - ONE,ZERO,ZERO,"INCLUDE STANDARD.FUNCTIONS.READ FROM OUT.IBP")
ITEM = INSERT(ITEM,STD.LOC - ONE,ZERO,ZERO,'TT = "R"')
STD.LOC = STD.LOC + ONE
STD.LOC = STD.LOC + ONE
*
END ELSE IF ITEM<STD.LOC + 2> NE "*NOTERM" THEN
ITEM = INSERT(ITEM,STD.LOC - ONE,ZERO,ZERO,"INCLUDE STANDARD.FUNCTIONS.READ FROM OUT.IBP")
STD.LOC = STD.LOC + ONE
END; * OF *SETTERM
*
END; * OF *OVERRIDE
*
VALID = 6
*
END ELSE
*
* No standard functions
*
VALID = 7
*
END; * OF STD.FLAG
*
END; * OF COM.LOC OR SPEC
*
! For a subroutine, modify line one if not common or special
*
IF NOT(COM.LOC OR SPEC.FLAG) OR ID[1,23] = "STANDARD.FUNCTIONS.CALL" THEN
*
ITEM.LINE1.LEN = LEN(ITEM.LINE1)
*
IF ITEM.LINE1[ITEM.LINE1.LEN,1] NE ")" THEN
ITEM.LINE1 = ITEM.LINE1:"(":STD.STRING:")"
END ELSE
ITEM.LINE1 = ITEM.LINE1[ONE,ITEM.LINE1.LEN - ONE]:",":STD.STRING:")"
END
*
ITEM<ONE> = ITEM.LINE1
*
IF STD.LOC THEN
IF ITEM<STD.LOC + ONE> NE "*OVERRIDE" AND ITEM<STD.LOC + ONE> NE "*OVERCALL" THEN ITEM = DELETE(ITEM,STD.LOC,ZERO,ZERO)
VALID = 9
END ELSE
VALID = 10
END
*
END; *# OF NOT(COM.LOC)
*
! Program
*
END ELSE IF VALID EQ PROG THEN
*
*
IF STD.LOC THEN
*
*PRINT "STANDARD.FLAG"
*
IF COM.LOC THEN
*
*PRINT "COMMN.FLAG"
*
IF ITEM<STD.LOC + ONE> EQ "*OVERRIDE" THEN ITEM = DELETE(ITEM,STD.LOC,ZERO,ZERO) ELSE
*
IF ITEM<STD.LOC + ONE> EQ "*OVERINCL" THEN NULL ELSE
ITEM<STD.LOC> = "CALL STANDARD.FUNCTIONS.CALL4(":STD.STRING:")"
END
*
END; * Of not over-ride
*
! Set to 4 (OTHR)
*
VALID = OTHR
*
END ELSE
*
* No common
*
IF ITEM<STD.LOC + ONE> NE "*OVERRIDE" THEN ITEM<STD.LOC> = "CALL STANDARD.FUNCTIONS.CALL4(":STD.STRING:")"
*
END; * Of common or no common
*
! No standard functions
*
END ELSE
VALID = ZERO
END
*
* end of prog area
*
END; * OF VALID VALUES
*
!
*
*PRINT "[=| "
*PRINT "[=| ":ITEM<ONE>
*IF STD.LOC THEN PRINT "[=| ":ITEM<STD.LOC>
*IF COM.LOC THEN PRINT "[=| ":ITEM<COM.LOC>
*PRINT "[=| V:":VALID:" S:":STD.LOC:" C:":COM.LOC:" SPEC:":SPEC.FLAG
*PRINT "[=| "
*
*
RETURN
*
*
END
~CODE.CONV.TERMINAL.CALL~
SUBROUTINE CODE.CONV.TERMINAL.CALL(VALID,IN.LINE,OUT.LINE,COMMN.LIST)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   10 SEP 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
*
OPEN "MD" TO MD.FILE ELSE
PRINT "MD FILE MISSING!"
STOP
END
*
*
READ SPEC.LIST FROM MD.FILE,"SPEC" THEN
SPEC.STRING = "*"
CN = ZERO
LOOP
CN = CN + ONE
WHILE SPEC.LIST<CN> NE EMPTY DO
SPEC.STRING = "*":SPEC.LIST<CN>:SPEC.STRING
REPEAT
END ELSE
SPEC.STRING = "*ADD.ID*PRINTER.ON*CALC.CHARGES*CALC.RENT*GET.ICONV*MOD11.DIGIT*AUTO.LOADER*LOCK.ITEM*UNLOCK.ITEM*INPUT.DATA*STANDARD.FUNCTIONS.CALL*STANDARD.FUNCTIONS.CALL1*STANDARD.FUNCTIONS.CALL2*PACK.NUMBER*UNPACK.NUMBER*"
END
*
*
*
READ STD.LIST FROM MD.FILE,"STD.STRING" THEN
STD.STRING = EMPTY
CN = ZERO
LOOP
CN = CN + ONE
WHILE STD.LIST<CN> NE EMPTY DO
STD.STRING = STD.STRING:",":STD.LIST<CN>
REPEAT
IF STD.STRING[ONE,ONE] EQ "," THEN STD.STRING = STD.STRING[TWO,999]
END ELSE
STD.STRING = "BELL,LF,FF,CR,AM,VM,SVM,WHO,PORT,ACCT,OPSYS,GENERIC,CLS,CLL,CLR,RVB,RVE,RVH,AUX.ON,AUX.OFF,ZERO,ONE,TWO,EMPTY,TRUE,FALSE,TT"
END
*
*
IF LEN(COMMN.LIST) THEN
IF TERM.DISP THEN PRINT "COMMN FLAG IS ON......."
*VALID = ZERO
*OUT.LINE = IN.LINE
*RETURN
END
*
OUT.LINE = EMPTY
CLL.CN = ZERO
*
LOOP
CLL.CN = CLL.CN + ONE
CLL.LOC = INDEX(IN.LINE,"CALL ",CLL.CN)
WHILE CLL.LOC DO
*
SKIP.FLAG = ZERO
*
*
*
IF CLL.LOC EQ ONE THEN NULL ELSE
TC = IN.LINE[CLL.LOC - ONE,ONE]
IF INDEX(";: ",TC,ONE) THEN NULL ELSE
IF TERM.DISP THEN PRINT "NOT A TRUE CLL......"
SKIP.FLAG = ONE
END
END
*
IF NOT(SKIP.FLAG) THEN
*
CLL.NAME = EMPTY
*
BRACKET.LOC = ZERO
BRACKET.LEFT = ZERO
LINE.LEN = LEN(IN.LINE)
*
END.OF.CLL = CLL.LOC + 5
LOOP
END.OF.CLL = END.OF.CLL + ONE
TC = IN.LINE[END.OF.CLL,ONE]
*
IF TC EQ "'" OR TC EQ '"' THEN
ETC = TC
LOOP
END.OF.CLL = END.OF.CLL + ONE
TC = IN.LINE[END.OF.CLL,ONE]
WHILE END.OF.CLL LE LINE.LEN AND TC NE ETC DO REPEAT
END
*
IF TC EQ "(" THEN BRACKET.LEFT = BRACKET.LEFT + ONE; IF TERM.DISP THEN PRINT "LEFT ( IS NOW ":BRACKET.LEFT
IF TC EQ ")" THEN
*>>IF BRACKET.LEFT GT ONE THEN
IF BRACKET.LEFT GT ZERO THEN
IF BRACKET.LEFT EQ ONE THEN BRACKET.LOC = END.OF.CLL
BRACKET.LEFT = BRACKET.LEFT - ONE
IF TERM.DISP THEN PRINT "LEFT ( IS NOW ":BRACKET.LEFT
END ELSE
IF BRACKET.LEFT EQ ONE THEN BRACKET.LOC = END.OF.CLL
END
END
CONT.END = INDEX(";: ",TC,ONE)
IF CONT.END AND BRACKET.LEFT THEN CONT.END = ZERO
*
IF CONT.END OR BRACKET.LEFT OR BRACKET.LOC AND CLL.NAME EQ EMPTY THEN
*
CLL.NAME = IN.LINE[CLL.LOC + 5,END.OF.CLL-CLL.LOC-5]
IF TERM.DISP THEN PRINT CLL.NAME:" .... IS A CALL"
*
IF INDEX(SPEC.STRING,"*":CLL.NAME:"*",ONE) THEN
IF TERM.DISP THEN PRINT CLL.NAME:" .... CLL IS A SPEC CASE"
SKIP.FLAG = ONE
END ELSE
IF TERM.DISP THEN PRINT CLL.NAME:" .... CLL IS NOT A SPEC CASE"
END
*
IF LEN(COMMN.LIST) THEN
LOCATE CLL.NAME IN COMMN.LIST SETTING COMMN.LOC THEN
IF TERM.DISP THEN PRINT CLL.NAME:" .... CLL IS A COMMN ITEM"
SKIP.FLAG = ONE
END ELSE
IF TERM.DISP THEN PRINT CLL.NAME:" .... CLL NOT A COMMN ITEM"
END
END; * OF COMMN
*
END; * OF BRACKET
*
IF (CLL.NAME[ONE,4] EQ "GET." OR CLL.NAME[ONE,3] EQ "SH.") THEN SKIP.FLAG = TRUE
*
!
*
WHILE NOT(CONT.END) AND END.OF.CLL LE LINE.LEN AND NOT(SKIP.FLAG) DO REPEAT
*
IF NOT(SKIP.FLAG) THEN
IF NOT(BRACKET.LOC) THEN
OUT.LINE = IN.LINE[ONE,END.OF.CLL - ONE]:"(":STD.STRING:")":IN.LINE[END.OF.CLL,9999]
END ELSE
*
OUT.LINE = IN.LINE[ONE,BRACKET.LOC - ONE]:",":STD.STRING:IN.LINE[BRACKET.LOC,9999]
END
END ELSE
OUT.LINE = IN.LINE
END
END ELSE
OUT.LINE = IN.LINE
END
REPEAT
*
*
RETURN
*
END
~DATE~
PZ
3033
~FILE.LIST~
ACG
ACM
ACT
ACX
ADD
ASH
ATH
ATR
CAJ
CNT
DLQ
DVC
EFT
LBL
PAP
PAR
REV
RTE
STT
STX
SVC
SVS
TAX
TPL
WKH
WKO
WKP
~FILES~
ACGýACMýACTýACXýADDýASHýATHýATRýCAJýCNTýDLQýDVCýEFTýLBLýPAPýPARýREVýRTEýSTTýSTXýSVCýSVSýTAXýTPLýWKHýWKOýWKP
CABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLEýCABLE
46ý27ý242ý16ý114ý49ý45ý40ý54ý71ý25ý62ý47ý21ý6ý69ý78ý22ý25ý18ý38ý38ý34ý23ý150ý150ý29
56ý39ý765ý472ý870ý69ý678ý760ý6ý31ý7ý657ý27ý2ý4ý112ý15ý37ý27ý32ý57ý12ý4ý36ý33ý357ý35
90ý1300ý200ý30ý90ý50ý450ý180ý2000ý350ý30ý80ý75ý40ý1464ý110ý1000ý50ý22ý10ý50ý50ý50ý50ý170ý250ý10
95ý230ý348ý42ý79ý179ý296ý120ý108ý249ý84ý83ý73ý42ý1357ý186ý609ý48ý35ý142ý61ý131ý59ý20ý208ý186ý31
25ý45ý100ý25ý100ý100ý100ý100ý2ý20ý100ý20ý20ý20ý100ý90ý5ý5ý30ý25ý11ý11ý11ý11ý11ý11ý11
4ý3ý19ý3ý9ý4ý4ý3ý4ý6ý3ý5ý4ý3ý3ý6ý6ý3ý3ý3ý3ý3ý3ý3ý12ý12ý3
11ý117ý306ý28ý157ý11ý610ý274ý24ý22ý11ý105ý11ý11ý293ý25ý30ý11ý11ý11ý11ý11ý11ý11ý11ý179ý11
~GENERAL.LIST~
ABORT.UPDATE
CALC.WKO.CHANGES
CANCEL.WORK.ORDER
CONFIRM.WORK.ORDER
DISPLAY.ALLOWED
DISPLAY.BACKGROUND
DISPLAY.BASIC.DATA
DISPLAY.CODES
DISPLAY.COMMENTS
DISPLAY.MAIL.ADDRESS
DISPLAY.RATE.HISTORY
DISPLAY.SERVICES
DISPLAY.TRANS
DISPLAY.WORK.ORDER.ACTIVS
DISPLAY.WORK.ORDER.BGROUND
DISPLAY.WORK.ORDER.CALCS
DISPLAY.WORK.ORDER.DETAIL
DISPLAY.WORK.ORDER.FGROUND
DISPLAY.WORK.ORDER.TITLE
DISPLAY.WORK.ORDERS
ENTER.WORK.ORDER.ACTIVITIES
FIND.TENANT
GENERAL
GENERAL.OPEN
GENERATE.DEVICE.MOVEMENTS
MAINT.ADDTL.DATA.STANDARD
MAINT.BASIC.DATA
MAINT.BY
MAINT.COMMENTS
MAINT.DELINQ
MAINT.EFT
MAINT.MAIL.ADDRESS
MAINT.WO.BULK.ADDRESSES
MAINT.WORK.ORDER
PRINT.BASIC.DATA
PRINT.TRANS
PRINT.WORK.ORDER.DETAIL
SCHEDULE.WORK.ORDER
UPDATE.FILES
UPDATE.LOCK
UPDATE.TRANS
~INST~
BP.FILES
CODE.CONV.CLS.ROUTINE
CODE.CONV.DB.ST.LBLS.NUM
CODE.CONV.INCLUDE.ROUTINE
CODE.CONV.TERMINAL
CODE.CONV.TERMINAL.CALL
CODE.CONVERT.TLD
DATE
FILE.LIST
FILES
INST
INST.1
INST.2
INST.3
INST.FILES
KBIL-INSTALL
KBIL-INSTALL-1
KBIL-INSTALL-2
KBIL-INSTALL-3
KBIL-INSTALL-4
KBIL-INSTALL.MD
KBIL-LOAD
KBIL.FILES
KBIL.IN.AC.PR
KBIL.IN.AC.PR.1
KBIL.IN.AC.PR.2
KBIL.IN.AC.PR.3
KBIL.IN.AC.PR.4
KBIL.IN.AC.PR.ADDTL
KBIL.IN.AC.SE
KBIL.IN.AC.SE.1
KBIL.IN.AC.SE.2
KBIL.IN.AC.SE.3
KBIL.IN.AC.SE.4
KBIL.IN.AC.SE.5
KBIL.IN.AC.SE.6
KBIL.IN.AC.SE.ADDTL
KBIL.SYSTEM
MDD.CAT.ALL
MDD.COM.CAT.ALL
MDD.DICT.COPY
MDD.FILES
MDD.FROM.TAPE.PROCWRITE
MDD.OLD
MDD.OLD.1
MDD.QPT.WRITE
NO-OP
QFILE
SEARCH
SEARCH.BATCH.FLAG
SEARCH.PARAM.EXTRACT
SEARCH.PARAM.OUTPUT
SEARCH.VALIDATE
SEARCH.VALIDATE.VERSION
SPEC
STD.STRING
TAPE.FLAG.MDD.ACCT
TAPE.LOAD.MDD.ACCT
ULT.QPT.WRITE
ULT.TO.TAPE.PROCWRITE
~INST.1~
KBIL-LOAD
KBIL-INSTALL
KBIL-INSTALL-1
KBIL-INSTALL-2
KBIL-INSTALL-3
KBIL-INSTALL-4
KBIL.IN.AC.PR
KBIL.IN.AC.PR.1
KBIL.IN.AC.PR.2
KBIL.IN.AC.PR.3
KBIL.IN.AC.PR.4
KBIL.IN.AC.PR.ADDTL
KBIL.IN.AC.SE
KBIL.IN.AC.SE.1
KBIL.IN.AC.SE.2
KBIL.IN.AC.SE.3
KBIL.IN.AC.SE.4
KBIL.IN.AC.SE.5
KBIL.IN.AC.SE.6
KBIL.IN.AC.SE.ADDTL
NO-OP
DATE
KBIL-INSTALL.MD
KBIL.INSTALL
KBIL.INSTALL.LIST
IN.FILE
OUT.FILE
OLD.FILE
IN.PL
OUT.PL
OLD.PL
~INST.2~
CODE.CONV.CLS.ROUTINE
CODE.CONV.DB.ST.LBLS.NUM
CODE.CONV.INCLUDE.ROUTINE
CODE.CONV.TERMINAL
CODE.CONV.TERMINAL.CALL
SEARCH
SEARCH.BATCH.FLAG
SEARCH.PARAM.EXTRACT
SEARCH.PARAM.OUTPUT
SEARCH.VALIDATE
SEARCH.VALIDATE.VERSION
SPEC
STD.STRING
~INST.3~
KBIL.INSTALL
KBIL.INSTALL.LIST
IN.FILE
OUT.FILE
OLD.FILE
IN.PL
OUT.PL
OLD.PL
KBIL-INSTALL.MD
~INST.FILES~
RTE
PAR
CNT
SVS
SVC
TAX
~KBIL-AUTORUNNER~
PQN
[OUT.PL KBIL-AUTORUNNER]
RTN
~KBIL-AUTORUNNER-1~
PQN
C
C
HAUTO.RUNNER
STON
H0<
P
C
C
HLOGTO KBIL-AUTORUNNER-2,KA2-15892
P
C
C
HZZOFF
P
C
C
RTN
~KBIL-AUTORUNNER-2~
PQN
C
C
HAUTO.RUNNER
STON
H0<
P
C
C
HLOGTO KBIL-AUTORUNNER-3,KA3-15892
P
C
C
HZZOFF
P
C
C
RTN
~KBIL-AUTORUNNER-3~
PQN
C
C
HAUTO.RUNNER
STON
H0<
P
C
C
HLOGTO KBIL-AUTORUNNER-4,KA4-15892
P
C
C
HZZOFF
P
C
C
RTN
~KBIL-AUTORUNNER-4~
PQN
C
C
HAUTO.RUNNER
STON
H0<
P
C
C
CCCCHLOGTO KBIL-AUTORUNNER-5,KA5-15892
CCCCP
C
C
HZZOFF
P
C
C
RTN
~KBIL-AUTORUNNER-5~
PQN
C
C
HAUTO.RUNNER
STON
H0<
P
C
C
CCCCHLOGTO KBIL-AUTORUNNER-2,KA2-15892
CCCCP
C
C
HZZOFF
P
C
C
RTN
~KBIL-INSTALL~
PQN
C
HTIMESLICE 63
P
C
C
HSYS.MSG.SEND PROGRAMS Install Queue Starting
STON
HPROGRAMS<
HInstall Queue Starting<
P
C
RI
RO
C
C
C
O Terminal being temporarily used for software installation
C
C
O Branch based on port number and type of run (List based or single)
C
HACC.UPDATE
STON
HS/W Installation<
P
O
O
HSEARCH.RUNTYPE
P
O
O Type of run is +
D0
C
C
C%%ULT%%=IF A1 = 'SINGLE' GO 5
C%%ULT%%=IF A1 = 'INSTALL' GO 10
C%%ULT%%=IF A1 = 'END' GO 800
C%%ULT%%=IF A1 = 'DEV' GO 800
C%%ULT%%=IF A1 = 'DONE' GO 800
C%%ULT%%=IF A1 = 'OK' GO 800
C%%ULT%%=IF A1 = 'REMOTE' GO 800
C%%ULT%%=CCCIF A1 = 'END' GO 999
C
CCCCCCC
C%%MDD%%=IF A1 = SINGLE GO 5
C%%MDD%%=IF A1 = INSTALL GO 10
C%%MDD%%=IF A1 = END GO 800
C%%MDD%%=IF A1 = DEV GO 800
C%%MDD%%=IF A1 = DONE GO 800
C%%MDD%%=IF A1 = OK GO 800
C%%MDD%%=IF A1 = REMOTE GO 800
C%%MDD%%=CCCIF A1 = END GO 999
C
CCCCCCC
C
C
CC
C
GO 999
C
CCCC
C
5 C
C
HSYS.LOCK.ID
STON
H1<
HSYS<
A\1
H<
CH<
P
C
O SINGLE QUEUE
C
[BP.INST KBIL-SINGLE]
C
C
GO 30
C
C
10 CHSLEEP 10
CP
C
HSYS.LOCK.ID
STON
H1<
HSYS<
A\1
H<
CH<
P
C
HSYS.MSG.SEND PROGRAMS INSTALL BATCH STARTED
STON
HPROGRAMS<
HINSTALL BATCH STARTED<
P
C
C
20 O Perform secondary procedure (translation)
C
[BP.INST KBIL.IN.AC.SE]
C
C
30 C Check run type
C
HSYS.RTNTYPE
P
C
IF A1 = 'DEV' GO 900
IF A1 = 'COMM' GO 900
IF A1 = 'INSTALL' GO 900
IF A1 = 'ABORT' GO 999
IF A1 = 'TAPE' GO 900
C
IF A1 = 'PROG' GO 40
IF A1 = 'SUBR' GO 40
C
IF A1 = 'CSEG' GO 800
IF A1 = 'PROC' GO 800
IF A1 = 'OTHER' GO 900
GO 999
C
C
40 O Transfer file pointers to other accounts
C
[BP.INST KBIL.IN.AC.PROC]
C
C
50 C
C
HSYS.MSG.SEND PROGRAMS LOGGIN TO INSTALL-1
STON
HPROGRAMS<
HLOGGIN TO INSTALL-1<
P
C
HLOGTO KBIL-INSTALL-1,KI1-9201
P
C
800 CCCC
C
HSYS.MSG.SEND PROGRAMS LOGGIN TO INSTALL-9
STON
HPROGRAMS<
HLOGGIN TO INSTALL-9<
P
C
HLOGTO KBIL-INSTALL-9,KI6-9201
P
C
GO 999
900 C
C
HSYS.MSG.SEND PROGRAMS INSTALL FINISHED
STON
HPROGRAMS<
HINSTALL FINISHED<
P
C
GO 990
C
999 C ABORT
C
HSYS.MSG.SEND PROGRAMS INSTALL ABORTED
STON
HPROGRAMS<
HINSTALL ABORTED<
P
C
990 O  Finished with terminal, thank you.
HZZOFF
P
C
XC
RTN
~KBIL-INSTALL-1~
PQN
RI
RO
C HSYS.MSG.SEND PROGRAMS BATCH 1 STARTED
C STON
C HPROGRAMS<
C HBATCH 1 STARTED<
C P
C
C HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST (O)
C STON
C H(MD<
C P
C
O Branch based on port number and type of run (List based or single)
C
HSYS.PORTTYPE
P
C
O Type of run is +
D0
C
C
C%%=ULT%%=IF A1 = 'SINGLE' GO 5
C%%=MDD%%=IF A1 = SINGLE GO 5
GO 10
5 [BP.INST KBIL.SINGLE.LIST.CATALOG]
C
GO 20
10 [BP.INST KBIL.INSTALL.LIST.CATALOG]
C
20 HLOGTO KBIL-INSTALL-2,KI2-9201
P
C
C
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH FINISHED
CSTON
CHPROGRAMS<
CHBATCH FINISHED<
CP
C
C
C
C
C
C
O
O Finished with terminal, thank you very much . . .
C
C
C
HSLEEP 10
P
C
C
CHBLOCK-PRINT OFF
P
C
HZZOFF
P
X
~KBIL-INSTALL-1.MD~
Q
DEMO
~KBIL-INSTALL-2~
PQN
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH 2 STARTED
CSTON
CHPROGRAMS<
CHBATCH 2 STARTED<
CP
C
C HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST.COMPILE KBIL.INSTALL.LIST (O)
C STON
C H(MD<
C P
C
[BP.INST KBIL.SYSTEM]
C
C
C
RI
RO
C
C
O Branch based on port number and type of run (List based or single)
C
HSYS.PORTTYPE
P
C
O Type of run is +
D0
C
C
C%%=ULT%%=IF A1 = 'SINGLE' GO 5
C%%=MDD%%=IF A1 = SINGLE GO 5
GO 10
5 [BP.INST KBIL.SINGLE.LIST.CATALOG]
C
GO 20
10 [BP.INST KBIL.INSTALL.LIST.CATALOG]
C
20 C
HLOGTO KBIL-INSTALL-3,KI3-9201
P
C
C
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH FINISHED
CSTON
CHPROGRAMS<
CHBATCH FINISHED<
CP
C
C
C
C
C
C
O
O Finished with terminal, thank you very much . . .
C
C
C
HSLEEP 10
P
C
C
CHBLOCK-PRINT OFF
P
C
HZZOFF
P
X
~KBIL-INSTALL-2.MD~
Q
FC
~KBIL-INSTALL-3~
PQN
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH 3 STARTED
CSTON
CHPROGRAMS<
CHBATCH 3 STARTED<
CP
C
C HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST.COMPILE KBIL.INSTALL.LIST (O)
C STON
C H(MD<
C P
C
[BP.INST KBIL.SYSTEM]
C
C
C
RI
RO
C
O Branch based on port number and type of run (List based or single)
C
HSYS.PORTTYPE
P
C
O Type of run is +
D0
C
C
C%%=ULT%%=IF A1 = 'SINGLE' GO 5
C%%=MDD%%=IF A1 = SINGLE GO 5
GO 10
5 [BP.INST KBIL.SINGLE.LIST.CATALOG]
C
GO 20
10 [BP.INST KBIL.INSTALL.LIST.CATALOG]
C
20 C
HLOGTO KBIL-INSTALL-4,KI4-9201
P
C
C
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH FINISHED
CSTON
CHPROGRAMS<
CHBATCH FINISHED<
CP
C
C
C
C
C
C
O
O Finished with terminal, thank you very much . . .
C
C
C
HSLEEP 10
P
C
C
CHBLOCK-PRINT OFF
P
C
HZZOFF
P
X
~KBIL-INSTALL-3.MD~
Q
CR
~KBIL-INSTALL-4~
PQN
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH 4 STARTED
CSTON
CHPROGRAMS<
CHBATCH 4 STARTED<
CP
C
C HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST (O)
C STON
C H(MD<
C P
C
O Branch based on port number and type of run (List based or single)
C
HSYS.PORTTYPE
P
C
O Type of run is +
D0
C
C
C%%=ULT%%=IF A1 = 'SINGLE' GO 5
C%%=MDD%%=IF A1 = SINGLE GO 5
GO 10
C
5 CCCC
C
[BP.INST KBIL.SINGLE.LIST.CATALOG]
C
GO 20
C
10 CCCC
C
[BP.INST KBIL.INSTALL.LIST.CATALOG]
C
20 C
HLOGTO KBIL-INSTALL-5,KI5-9201
P
C
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH FINISHED
CSTON
CHPROGRAMS<
CHBATCH FINISHED<
CP
C
O
O Finished with terminal, thank you very much . . .
C
C
C
HSLEEP 2
P
C
C
CHBLOCK-PRINT OFF
CP
C
HZZOFF
P
X
~KBIL-INSTALL-4.MD~
Q
GS
~KBIL-INSTALL-5~
PQN
RI
RO
CHSYS.MSG.SEND PROGRAMS BATCH 5 STARTED
CSTON
CHPROGRAMS<
CHBATCH 5 STARTED<
CP
C
C HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST.COMPILE KBIL.INSTALL.LIST (O)
C STON
C H(MD<
C P
C
[BP.INST KBIL.SYSTEM]
C
C
C
RI
RO
C
O Branch based on port number and type of run (List based or single)
C
HSYS.PORTTYPE
P
C
O Type of run is +
D0
C
C
C%%=ULT%%=IF A1 = 'SINGLE' GO 5
C%%=MDD%%=IF A1 = SINGLE GO 5
GO 10
5 [BP.INST KBIL.SINGLE.LIST.CATALOG]
C
GO 20
10 [BP.INST KBIL.INSTALL.LIST.CATALOG]
C
20 C
HLOGTO KBIL-INSTALL-9,KI6-9201
P
C
C
RI
RO
CHMSG PROGRAMS BATCH FINISHED
CP
C
C
C
C
C
C
O
O Finished with terminal, thank you very much . . .
C
C
C
HSLEEP 10
P
C
C
CHBLOCK-PRINT OFF
P
C
HZZOFF
P
X
~KBIL-INSTALL-5.MD~
Q
UT
~KBIL-INSTALL-6~
PQN
RI
RO
C
HSYS.MSG.SEND PROGRAMS BATCH 5 STARTED
STON
HPROGRAMS<
HBATCH 5 STARTED<
P
O
HWHO
P
O
C
O Branch based on previously run or not (OK).
O
HSYS.PORTTYPE
P
O
O Type of run is +
D0
O
C
C%%=ULT%%=IF A1 # 'OK' GO 900
C%%=MDD%%=IF A1 # OK GO 900
O
[BP.INST KBIL.REMOTE]
O
900 C MULTI ITEM/FILE PROCESSING
C
HSYS.PORTTYPE
P
C
C   CLEAR LOCK ON JOB STREAM
C
HSYS.UNLOCK.ID
STON
H1<
HSYS<
A\1
H<
P
C
C
[BP.INST KBIL.INSTALL.NEXT]
C
999 C
C
HLOGTO KBIL-INSTALL-7,KI7-9201
P
C
RI
RO
HSYS.MSG.SEND PROGRAMS BATCH FINISHED
STON
HPROGRAMS<
HBATCH FINISHED<
P
C
O Finished with terminal, thank you very much . . .
C
HSLEEP 5
P
C
CHBLOCK-PRINT OFF
CP
C
HZZOFF
P
C
CX
RTN
~KBIL-INSTALL-6.MD~
Q
PROGRAMS
~KBIL-INSTALL-DICT~
PQN
C
C
C  PROC TO COPY NEW DICTIONARIES TO ACCOUNTS
C
C
O  DEMO
C[BP.INST KBIL-INSTALL-DICT-DEMO]
C
O  FC
[BP.INST KBIL-INSTALL-DICT-FC]
C
O  CR
[BP.INST KBIL-INSTALL-DICT-CR]
C
O  GS
[BP.INST KBIL-INSTALL-DICT-GS]
C
O  KBIL-DEMO
C[BP.INST KBIL-INSTALL-DICT-KBIL-DEMO]
C
O  FINISHED DICT COPY
O
C
RTN
~KBIL-INSTALL-DICT-CR~
PQN
O
O KBIL-INSTALL-DICT-CR PROGRAMS 
O
C 26 AUG 88
C
O
O
O  ACG
O
HSET.FILE 
STON
HCR<
HACG<
P
HCOPY DICT ACG * (O)
STON
H(DICT QFILE<
P
O
O
O  ACM
O
HSET.FILE 
STON
HCR<
HACM<
P
HCOPY DICT ACM * (O)
STON
H(DICT QFILE<
P
O
O
O  ACT
O
HSET.FILE 
STON
HCR<
HACT<
P
HCOPY DICT ACT * (O)
STON
H(DICT QFILE<
P
O
O
O  ACX
O
HSET.FILE 
STON
HCR<
HACX<
P
HCOPY DICT ACX * (O)
STON
H(DICT QFILE<
P
O
O
O  ADD
O
HSET.FILE 
STON
HCR<
HADD<
P
HCOPY DICT ADD * (O)
STON
H(DICT QFILE<
P
O
O
O  ASH
O
HSET.FILE 
STON
HCR<
HASH<
P
HCOPY DICT ASH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATH
O
HSET.FILE 
STON
HCR<
HATH<
P
HCOPY DICT ATH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATR
O
HSET.FILE 
STON
HCR<
HATR<
P
HCOPY DICT ATR * (O)
STON
H(DICT QFILE<
P
O
O
O  CAJ
O
HSET.FILE 
STON
HCR<
HCAJ<
P
HCOPY DICT CAJ * (O)
STON
H(DICT QFILE<
P
O
O
O  CNT
O
HSET.FILE 
STON
HCR<
HCNT<
P
HCOPY DICT CNT * (O)
STON
H(DICT QFILE<
P
O
O
O  DLQ
O
HSET.FILE 
STON
HCR<
HDLQ<
P
HCOPY DICT DLQ * (O)
STON
H(DICT QFILE<
P
O
O
O  DVC
O
HSET.FILE 
STON
HCR<
HDVC<
P
HCOPY DICT DVC * (O)
STON
H(DICT QFILE<
P
O
O
O  EFT
O
HSET.FILE 
STON
HCR<
HEFT<
P
HCOPY DICT EFT * (O)
STON
H(DICT QFILE<
P
O
O
O  LBL
O
HSET.FILE 
STON
HCR<
HLBL<
P
HCOPY DICT LBL * (O)
STON
H(DICT QFILE<
P
O
O
O  PAP
O
HSET.FILE 
STON
HCR<
HPAP<
P
HCOPY DICT PAP * (O)
STON
H(DICT QFILE<
P
O
O
O  PAR
O
HSET.FILE 
STON
HCR<
HPAR<
P
HCOPY DICT PAR * (O)
STON
H(DICT QFILE<
P
O
O
O  REV
O
HSET.FILE 
STON
HCR<
HREV<
P
HCOPY DICT REV * (O)
STON
H(DICT QFILE<
P
O
O
O  RTE
O
HSET.FILE 
STON
HCR<
HRTE<
P
HCOPY DICT RTE * (O)
STON
H(DICT QFILE<
P
O
O
O  STT
O
HSET.FILE 
STON
HCR<
HSTT<
P
HCOPY DICT STT * (O)
STON
H(DICT QFILE<
P
O
O
O  STX
O
HSET.FILE 
STON
HCR<
HSTX<
P
HCOPY DICT STX * (O)
STON
H(DICT QFILE<
P
O
O
O  SVC
O
HSET.FILE 
STON
HCR<
HSVC<
P
HCOPY DICT SVC * (O)
STON
H(DICT QFILE<
P
O
O
O  SVS
O
HSET.FILE 
STON
HCR<
HSVS<
P
HCOPY DICT SVS * (O)
STON
H(DICT QFILE<
P
O
O
O  TAX
O
HSET.FILE 
STON
HCR<
HTAX<
P
HCOPY DICT TAX * (O)
STON
H(DICT QFILE<
P
O
O
O  TPL
O
HSET.FILE 
STON
HCR<
HTPL<
P
HCOPY DICT TPL * (O)
STON
H(DICT QFILE<
P
O
O
O  WKH
O
HSET.FILE 
STON
HCR<
HWKH<
P
HCOPY DICT WKH * (O)
STON
H(DICT QFILE<
P
O
O
O  WKO
O
HSET.FILE 
STON
HCR<
HWKO<
P
HCOPY DICT WKO * (O)
STON
H(DICT QFILE<
P
O
O
O  WKP
O
HSET.FILE 
STON
HCR<
HWKP<
P
HCOPY DICT WKP * (O)
STON
H(DICT QFILE<
P
C
C
C
RTN

~KBIL-INSTALL-DICT-DEMO~
PQN
O
O KBIL-INSTALL-DICT-DEMO PROGRAMS 
O
C 26 AUG 88
C
O
O
O  ACG
O
HSET.FILE 
STON
HDEMO<
HACG<
P
HCOPY DICT ACG * (O)
STON
H(DICT QFILE<
P
O
O
O  ACM
O
HSET.FILE 
STON
HDEMO<
HACM<
P
HCOPY DICT ACM * (O)
STON
H(DICT QFILE<
P
O
O
O  ACT
O
HSET.FILE 
STON
HDEMO<
HACT<
P
HCOPY DICT ACT * (O)
STON
H(DICT QFILE<
P
O
O
O  ACX
O
HSET.FILE 
STON
HDEMO<
HACX<
P
HCOPY DICT ACX * (O)
STON
H(DICT QFILE<
P
O
O
O  ADD
O
HSET.FILE 
STON
HDEMO<
HADD<
P
HCOPY DICT ADD * (O)
STON
H(DICT QFILE<
P
O
O
O  ASH
O
HSET.FILE 
STON
HDEMO<
HASH<
P
HCOPY DICT ASH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATH
O
HSET.FILE 
STON
HDEMO<
HATH<
P
HCOPY DICT ATH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATR
O
HSET.FILE 
STON
HDEMO<
HATR<
P
HCOPY DICT ATR * (O)
STON
H(DICT QFILE<
P
O
O
O  CAJ
O
HSET.FILE 
STON
HDEMO<
HCAJ<
P
HCOPY DICT CAJ * (O)
STON
H(DICT QFILE<
P
O
O
O  CNT
O
HSET.FILE 
STON
HDEMO<
HCNT<
P
HCOPY DICT CNT * (O)
STON
H(DICT QFILE<
P
O
O
O  DLQ
O
HSET.FILE 
STON
HDEMO<
HDLQ<
P
HCOPY DICT DLQ * (O)
STON
H(DICT QFILE<
P
O
O
O  DVC
O
HSET.FILE 
STON
HDEMO<
HDVC<
P
HCOPY DICT DVC * (O)
STON
H(DICT QFILE<
P
O
O
O  EFT
O
HSET.FILE 
STON
HDEMO<
HEFT<
P
HCOPY DICT EFT * (O)
STON
H(DICT QFILE<
P
O
O
O  LBL
O
HSET.FILE 
STON
HDEMO<
HLBL<
P
HCOPY DICT LBL * (O)
STON
H(DICT QFILE<
P
O
O
O  PAP
O
HSET.FILE 
STON
HDEMO<
HPAP<
P
HCOPY DICT PAP * (O)
STON
H(DICT QFILE<
P
O
O
O  PAR
O
HSET.FILE 
STON
HDEMO<
HPAR<
P
HCOPY DICT PAR * (O)
STON
H(DICT QFILE<
P
O
O
O  REV
O
HSET.FILE 
STON
HDEMO<
HREV<
P
HCOPY DICT REV * (O)
STON
H(DICT QFILE<
P
O
O
O  RTE
O
HSET.FILE 
STON
HDEMO<
HRTE<
P
HCOPY DICT RTE * (O)
STON
H(DICT QFILE<
P
O
O
O  STT
O
HSET.FILE 
STON
HDEMO<
HSTT<
P
HCOPY DICT STT * (O)
STON
H(DICT QFILE<
P
O
O
O  STX
O
HSET.FILE 
STON
HDEMO<
HSTX<
P
HCOPY DICT STX * (O)
STON
H(DICT QFILE<
P
O
O
O  SVC
O
HSET.FILE 
STON
HDEMO<
HSVC<
P
HCOPY DICT SVC * (O)
STON
H(DICT QFILE<
P
O
O
O  SVS
O
HSET.FILE 
STON
HDEMO<
HSVS<
P
HCOPY DICT SVS * (O)
STON
H(DICT QFILE<
P
O
O
O  TAX
O
HSET.FILE 
STON
HDEMO<
HTAX<
P
HCOPY DICT TAX * (O)
STON
H(DICT QFILE<
P
O
O
O  TPL
O
HSET.FILE 
STON
HDEMO<
HTPL<
P
HCOPY DICT TPL * (O)
STON
H(DICT QFILE<
P
O
O
O  WKH
O
HSET.FILE 
STON
HDEMO<
HWKH<
P
HCOPY DICT WKH * (O)
STON
H(DICT QFILE<
P
O
O
O  WKO
O
HSET.FILE 
STON
HDEMO<
HWKO<
P
HCOPY DICT WKO * (O)
STON
H(DICT QFILE<
P
O
O
O  WKP
O
HSET.FILE 
STON
HDEMO<
HWKP<
P
HCOPY DICT WKP * (O)
STON
H(DICT QFILE<
P
C
C
C
RTN

~KBIL-INSTALL-DICT-FC~
PQN
O
O KBIL-INSTALL-DICT-FC PROGRAMS 
O
C 26 AUG 88
C
O
O
O  ACG
O
HSET.FILE 
STON
HFC<
HACG<
P
HCOPY DICT ACG * (O)
STON
H(DICT QFILE<
P
O
O
O  ACM
O
HSET.FILE 
STON
HFC<
HACM<
P
HCOPY DICT ACM * (O)
STON
H(DICT QFILE<
P
O
O
O  ACT
O
HSET.FILE 
STON
HFC<
HACT<
P
HCOPY DICT ACT * (O)
STON
H(DICT QFILE<
P
O
O
O  ACX
O
HSET.FILE 
STON
HFC<
HACX<
P
HCOPY DICT ACX * (O)
STON
H(DICT QFILE<
P
O
O
O  ADD
O
HSET.FILE 
STON
HFC<
HADD<
P
HCOPY DICT ADD * (O)
STON
H(DICT QFILE<
P
O
O
O  ASH
O
HSET.FILE 
STON
HFC<
HASH<
P
HCOPY DICT ASH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATH
O
HSET.FILE 
STON
HFC<
HATH<
P
HCOPY DICT ATH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATR
O
HSET.FILE 
STON
HFC<
HATR<
P
HCOPY DICT ATR * (O)
STON
H(DICT QFILE<
P
O
O
O  CAJ
O
HSET.FILE 
STON
HFC<
HCAJ<
P
HCOPY DICT CAJ * (O)
STON
H(DICT QFILE<
P
O
O
O  CNT
O
HSET.FILE 
STON
HFC<
HCNT<
P
HCOPY DICT CNT * (O)
STON
H(DICT QFILE<
P
O
O
O  DLQ
O
HSET.FILE 
STON
HFC<
HDLQ<
P
HCOPY DICT DLQ * (O)
STON
H(DICT QFILE<
P
O
O
O  DVC
O
HSET.FILE 
STON
HFC<
HDVC<
P
HCOPY DICT DVC * (O)
STON
H(DICT QFILE<
P
O
O
O  EFT
O
HSET.FILE 
STON
HFC<
HEFT<
P
HCOPY DICT EFT * (O)
STON
H(DICT QFILE<
P
O
O
O  LBL
O
HSET.FILE 
STON
HFC<
HLBL<
P
HCOPY DICT LBL * (O)
STON
H(DICT QFILE<
P
O
O
O  PAP
O
HSET.FILE 
STON
HFC<
HPAP<
P
HCOPY DICT PAP * (O)
STON
H(DICT QFILE<
P
O
O
O  PAR
O
HSET.FILE 
STON
HFC<
HPAR<
P
HCOPY DICT PAR * (O)
STON
H(DICT QFILE<
P
O
O
O  REV
O
HSET.FILE 
STON
HFC<
HREV<
P
HCOPY DICT REV * (O)
STON
H(DICT QFILE<
P
O
O
O  RTE
O
HSET.FILE 
STON
HFC<
HRTE<
P
HCOPY DICT RTE * (O)
STON
H(DICT QFILE<
P
O
O
O  STT
O
HSET.FILE 
STON
HFC<
HSTT<
P
HCOPY DICT STT * (O)
STON
H(DICT QFILE<
P
O
O
O  STX
O
HSET.FILE 
STON
HFC<
HSTX<
P
HCOPY DICT STX * (O)
STON
H(DICT QFILE<
P
O
O
O  SVC
O
HSET.FILE 
STON
HFC<
HSVC<
P
HCOPY DICT SVC * (O)
STON
H(DICT QFILE<
P
O
O
O  SVS
O
HSET.FILE 
STON
HFC<
HSVS<
P
HCOPY DICT SVS * (O)
STON
H(DICT QFILE<
P
O
O
O  TAX
O
HSET.FILE 
STON
HFC<
HTAX<
P
HCOPY DICT TAX * (O)
STON
H(DICT QFILE<
P
O
O
O  TPL
O
HSET.FILE 
STON
HFC<
HTPL<
P
HCOPY DICT TPL * (O)
STON
H(DICT QFILE<
P
O
O
O  WKH
O
HSET.FILE 
STON
HFC<
HWKH<
P
HCOPY DICT WKH * (O)
STON
H(DICT QFILE<
P
O
O
O  WKO
O
HSET.FILE 
STON
HFC<
HWKO<
P
HCOPY DICT WKO * (O)
STON
H(DICT QFILE<
P
O
O
O  WKP
O
HSET.FILE 
STON
HFC<
HWKP<
P
HCOPY DICT WKP * (O)
STON
H(DICT QFILE<
P
C
C
C
RTN

~KBIL-INSTALL-DICT-GS~
PQN
O
O KBIL-INSTALL-DICT-GS PROGRAMS 
O
C 26 AUG 88
C
O
O
O  ACG
O
HSET.FILE 
STON
HGS<
HACG<
P
HCOPY DICT ACG * (O)
STON
H(DICT QFILE<
P
O
O
O  ACM
O
HSET.FILE 
STON
HGS<
HACM<
P
HCOPY DICT ACM * (O)
STON
H(DICT QFILE<
P
O
O
O  ACT
O
HSET.FILE 
STON
HGS<
HACT<
P
HCOPY DICT ACT * (O)
STON
H(DICT QFILE<
P
O
O
O  ACX
O
HSET.FILE 
STON
HGS<
HACX<
P
HCOPY DICT ACX * (O)
STON
H(DICT QFILE<
P
O
O
O  ADD
O
HSET.FILE 
STON
HGS<
HADD<
P
HCOPY DICT ADD * (O)
STON
H(DICT QFILE<
P
O
O
O  ASH
O
HSET.FILE 
STON
HGS<
HASH<
P
HCOPY DICT ASH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATH
O
HSET.FILE 
STON
HGS<
HATH<
P
HCOPY DICT ATH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATR
O
HSET.FILE 
STON
HGS<
HATR<
P
HCOPY DICT ATR * (O)
STON
H(DICT QFILE<
P
O
O
O  CAJ
O
HSET.FILE 
STON
HGS<
HCAJ<
P
HCOPY DICT CAJ * (O)
STON
H(DICT QFILE<
P
O
O
O  CNT
O
HSET.FILE 
STON
HGS<
HCNT<
P
HCOPY DICT CNT * (O)
STON
H(DICT QFILE<
P
O
O
O  DLQ
O
HSET.FILE 
STON
HGS<
HDLQ<
P
HCOPY DICT DLQ * (O)
STON
H(DICT QFILE<
P
O
O
O  DVC
O
HSET.FILE 
STON
HGS<
HDVC<
P
HCOPY DICT DVC * (O)
STON
H(DICT QFILE<
P
O
O
O  EFT
O
HSET.FILE 
STON
HGS<
HEFT<
P
HCOPY DICT EFT * (O)
STON
H(DICT QFILE<
P
O
O
O  LBL
O
HSET.FILE 
STON
HGS<
HLBL<
P
HCOPY DICT LBL * (O)
STON
H(DICT QFILE<
P
O
O
O  PAP
O
HSET.FILE 
STON
HGS<
HPAP<
P
HCOPY DICT PAP * (O)
STON
H(DICT QFILE<
P
O
O
O  PAR
O
HSET.FILE 
STON
HGS<
HPAR<
P
HCOPY DICT PAR * (O)
STON
H(DICT QFILE<
P
O
O
O  REV
O
HSET.FILE 
STON
HGS<
HREV<
P
HCOPY DICT REV * (O)
STON
H(DICT QFILE<
P
O
O
O  RTE
O
HSET.FILE 
STON
HGS<
HRTE<
P
HCOPY DICT RTE * (O)
STON
H(DICT QFILE<
P
O
O
O  STT
O
HSET.FILE 
STON
HGS<
HSTT<
P
HCOPY DICT STT * (O)
STON
H(DICT QFILE<
P
O
O
O  STX
O
HSET.FILE 
STON
HGS<
HSTX<
P
HCOPY DICT STX * (O)
STON
H(DICT QFILE<
P
O
O
O  SVC
O
HSET.FILE 
STON
HGS<
HSVC<
P
HCOPY DICT SVC * (O)
STON
H(DICT QFILE<
P
O
O
O  SVS
O
HSET.FILE 
STON
HGS<
HSVS<
P
HCOPY DICT SVS * (O)
STON
H(DICT QFILE<
P
O
O
O  TAX
O
HSET.FILE 
STON
HGS<
HTAX<
P
HCOPY DICT TAX * (O)
STON
H(DICT QFILE<
P
O
O
O  TPL
O
HSET.FILE 
STON
HGS<
HTPL<
P
HCOPY DICT TPL * (O)
STON
H(DICT QFILE<
P
O
O
O  WKH
O
HSET.FILE 
STON
HGS<
HWKH<
P
HCOPY DICT WKH * (O)
STON
H(DICT QFILE<
P
O
O
O  WKO
O
HSET.FILE 
STON
HGS<
HWKO<
P
HCOPY DICT WKO * (O)
STON
H(DICT QFILE<
P
O
O
O  WKP
O
HSET.FILE 
STON
HGS<
HWKP<
P
HCOPY DICT WKP * (O)
STON
H(DICT QFILE<
P
C
C
C
RTN

~KBIL-INSTALL-DICT-KBIL-DEMO~
PQN
O
O KBIL-INSTALL-DICT-KBIL-DEMO PROGRAMS 
O
C 26 AUG 88
C
O
O
O  ACG
O
HSET.FILE 
STON
HKBIL-DEMO<
HACG<
P
HCOPY DICT ACG * (O)
STON
H(DICT QFILE<
P
O
O
O  ACM
O
HSET.FILE 
STON
HKBIL-DEMO<
HACM<
P
HCOPY DICT ACM * (O)
STON
H(DICT QFILE<
P
O
O
O  ACT
O
HSET.FILE 
STON
HKBIL-DEMO<
HACT<
P
HCOPY DICT ACT * (O)
STON
H(DICT QFILE<
P
O
O
O  ACX
O
HSET.FILE 
STON
HKBIL-DEMO<
HACX<
P
HCOPY DICT ACX * (O)
STON
H(DICT QFILE<
P
O
O
O  ADD
O
HSET.FILE 
STON
HKBIL-DEMO<
HADD<
P
HCOPY DICT ADD * (O)
STON
H(DICT QFILE<
P
O
O
O  ASH
O
HSET.FILE 
STON
HKBIL-DEMO<
HASH<
P
HCOPY DICT ASH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATH
O
HSET.FILE 
STON
HKBIL-DEMO<
HATH<
P
HCOPY DICT ATH * (O)
STON
H(DICT QFILE<
P
O
O
O  ATR
O
HSET.FILE 
STON
HKBIL-DEMO<
HATR<
P
HCOPY DICT ATR * (O)
STON
H(DICT QFILE<
P
O
O
O  CAJ
O
HSET.FILE 
STON
HKBIL-DEMO<
HCAJ<
P
HCOPY DICT CAJ * (O)
STON
H(DICT QFILE<
P
O
O
O  CNT
O
HSET.FILE 
STON
HKBIL-DEMO<
HCNT<
P
HCOPY DICT CNT * (O)
STON
H(DICT QFILE<
P
O
O
O  DLQ
O
HSET.FILE 
STON
HKBIL-DEMO<
HDLQ<
P
HCOPY DICT DLQ * (O)
STON
H(DICT QFILE<
P
O
O
O  DVC
O
HSET.FILE 
STON
HKBIL-DEMO<
HDVC<
P
HCOPY DICT DVC * (O)
STON
H(DICT QFILE<
P
O
O
O  EFT
O
HSET.FILE 
STON
HKBIL-DEMO<
HEFT<
P
HCOPY DICT EFT * (O)
STON
H(DICT QFILE<
P
O
O
O  LBL
O
HSET.FILE 
STON
HKBIL-DEMO<
HLBL<
P
HCOPY DICT LBL * (O)
STON
H(DICT QFILE<
P
O
O
O  PAP
O
HSET.FILE 
STON
HKBIL-DEMO<
HPAP<
P
HCOPY DICT PAP * (O)
STON
H(DICT QFILE<
P
O
O
O  PAR
O
HSET.FILE 
STON
HKBIL-DEMO<
HPAR<
P
HCOPY DICT PAR * (O)
STON
H(DICT QFILE<
P
O
O
O  REV
O
HSET.FILE 
STON
HKBIL-DEMO<
HREV<
P
HCOPY DICT REV * (O)
STON
H(DICT QFILE<
P
O
O
O  RTE
O
HSET.FILE 
STON
HKBIL-DEMO<
HRTE<
P
HCOPY DICT RTE * (O)
STON
H(DICT QFILE<
P
O
O
O  STT
O
HSET.FILE 
STON
HKBIL-DEMO<
HSTT<
P
HCOPY DICT STT * (O)
STON
H(DICT QFILE<
P
O
O
O  STX
O
HSET.FILE 
STON
HKBIL-DEMO<
HSTX<
P
HCOPY DICT STX * (O)
STON
H(DICT QFILE<
P
O
O
O  SVC
O
HSET.FILE 
STON
HKBIL-DEMO<
HSVC<
P
HCOPY DICT SVC * (O)
STON
H(DICT QFILE<
P
O
O
O  SVS
O
HSET.FILE 
STON
HKBIL-DEMO<
HSVS<
P
HCOPY DICT SVS * (O)
STON
H(DICT QFILE<
P
O
O
O  TAX
O
HSET.FILE 
STON
HKBIL-DEMO<
HTAX<
P
HCOPY DICT TAX * (O)
STON
H(DICT QFILE<
P
O
O
O  TPL
O
HSET.FILE 
STON
HKBIL-DEMO<
HTPL<
P
HCOPY DICT TPL * (O)
STON
H(DICT QFILE<
P
O
O
O  WKH
O
HSET.FILE 
STON
HKBIL-DEMO<
HWKH<
P
HCOPY DICT WKH * (O)
STON
H(DICT QFILE<
P
O
O
O  WKO
O
HSET.FILE 
STON
HKBIL-DEMO<
HWKO<
P
HCOPY DICT WKO * (O)
STON
H(DICT QFILE<
P
O
O
O  WKP
O
HSET.FILE 
STON
HKBIL-DEMO<
HWKP<
P
HCOPY DICT WKP * (O)
STON
H(DICT QFILE<
P
C
C
C
RTN

~KBIL-INSTALL-MD~
PQN
HCOPY IN.BP.INST KBIL-INSTALL-
A\2
H (O
STON
H(
A\3
H.MD
PP
X
~KBIL-INSTALL-UT~
PQN
RI
RO
C
C
C
O Terminal being temporarily used for software installation
C
C
O Branch based on port number and type of run (List based or single)
C
HACC.UPDATE
STON
HS/W Installation<
P
C
C
HSEARCH.RUNTYPE
P
C
O Type of run is +
D0
C
C
C%%=ULT%%=IF A1 = 'END' GO 999
C%%=ULT%%=IF A1 = 'END' GO 999
C%%=MDD%%=IF A1 = SINGLE GO 5
C%%=MDD%%=IF A1 = SINGLE GO 5
GO 10
C
C
5 [BP.INST KBIL-SINGLE]
C
C
10 CHSLEEP 10
CP
C
C
C
CHSYS.MSG.SEND PROGRAMS BATCH STARTED
CSTON
CHPROGRAMS<
CHBATCH STARTED<
CP
C
C
20 O Perform secondary procedure (translation)
C
[BP.INST KBIL.IN.AC.SE.UT]
C
C
30 C Check run type
C
HSYS.RTNTYPE
P
C
C%%=ULT%%=IF A1 = 'DEV' GO 900
C%%=ULT%%=IF A1 = 'COMM' GO 900
C%%=ULT%%=IF A1 = 'INSTALL' GO 900
C%%=ULT%%=IF A1 = 'ABORT' GO 999
C%%=ULT%%=IF A1 = 'TAPE' GO 900
CCCCC
C%%=MDD%%=IF A1 = DEV GO 900
C%%=MDD%%=IF A1 = COMM GO 900
C%%=MDD%%=IF A1 = INSTALL GO 900
C%%=MDD%%=IF A1 = ABORT GO 999
C%%=MDD%%=IF A1 = TAPE GO 900
C
C%%=ULT%%=IF A1 = 'PROG' GO 40
C%%=ULT%%=IF A1 = 'SUBR' GO 40
C%%=MDD%%=IF A1 = PROG GO 40
C%%=MDD%%=IF A1 = SUBR GO 40
C
C%%=ULT%%=IF A1 = 'CSEG' GO 900
C%%=ULT%%=IF A1 = 'PROC' GO 900
C%%=ULT%%=IF A1 = 'OTHER' GO 900
CCCC
C%%=MDD%%=IF A1 = CSEG GO 900
C%%=MDD%%=IF A1 = PROC GO 900
C%%=MDD%%=IF A1 = OTHER GO 900
GO 999
C
C
40 O Transfer file pointers to other accounts
C
[BP.INST KBIL.IN.AC.PROC]
C
C
50 CCCC
C
CHSYS.MSG.SEND PROGRAMS LOGGIN TO INSTALL-5
CSTON
CHPROGRAMS<
CHLOGGIN TO INSTALL-5<
CP
C
HLOGTO KBIL-INSTALL-5,KI5-9201
P
C
GO 999
900 C
C
HSYS.MSG.SEND PROGRAMS INSTALL FINISHED
STON
HPROGRAMS<
HINSTALL FINISHED<
P
C
GO 990
C
999 C ABORT
C
HSYS.MSG.SEND PROGRAMS INSTALL ABORTED
STON
HPROGRAMS<
HINSTALL ABORTED<
P
C
990 O  Finished with terminal, thank you.
HZZOFF
P
C
XC
RTN
~KBIL-INSTALL.MD~
Q
PROGRAMS
~KBIL-INSTALL.TEMP~
PQN
CPROCEDURE: KBIL.SINGLE.AC.SE
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C               10 MAY 92  Vs 2.0
C
C
CCOPYRIGHT    : (C) 1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the Installation Procedure . . . 
C
O               STAGE 0
C
O There are a total of ? primary steps
O                  and ? secondary steps.
C
O Starting . . . 
C
O Stage 0
C
HSP-ASSIGN HS
P
C
10 O Step 0.1
C
CHBLOCK-PRINT KBIL ISS0 (P)
CP
C
C
CHSYS.MSG.SEND PROGRAMS KBIL ISS0
CSTON
CHPROGRAMS<
CHKBIL ISS0<
CP
C
O             Default type of run is +
IHINSTALL
D0
C
20 HSEARCH.RUNTYPE
P
C
O          Type of run being done is +
D0
C
IF A1 = 'TAPE' GO 30
IF A1 = 'COMM' GO 30
IF A1 = 'DEV' GO 30
IF A1 = 'PROG' GO 30
IF A1 = 'SUBR' GO 30
IF A1 = 'CSEG' GO 30
IF A1 = 'PROC' GO 30
IF A1 = 'OTHER' GO 30
GO 40
30 O Create KBIL.SINGLE.LIST and move item(s) from BP.IMPORT
C
[BP.INST KBIL.SINGLE.AC.SE.0.1]
C
40 O Stage 0 completed . . . 
C
HSLEEP 2
P
100 C BACKUP OLD
C
O Backup old and transfer list
[BP.INST KBIL.SINGLE.AC.SE.1]
HSEARCH.RUNTYPE
P
C
C Branch to handle item types
C
IF A1 = 'INSTALL' GO 200
IF A1 = 'DEV' GO 200
IF A1 = 'COMM' GO 200
C
CF A1 = 'TAPE'
IF A1 = 'PROG' G 200
IF A1 = 'SUBR' G 200
IF A1 = 'CSEG' G 300
IF A1 = 'PROC' G 300
IF A1 = 'OTHER' G 300
GO 900
C
C
200 O Create Procs
C
[BP.INST KBIL.SINGLE.AC.SE.2]
HSEARCH.RUNTYPE
P
C
C Branch to handle item types
C
IF A1 = 'INSTALL' GO 300
IF A1 = 'DEV' GO 300
IF A1 = 'COMM' GO 300
C
CF A1 = 'TAPE'
IF A1 = 'PROG' G 300
IF A1 = 'SUBR' G 300
IF A1 = 'CSEG' G 300
IF A1 = 'PROC' G 600
IF A1 = 'OTHER' G 500
GO 900
C
300 C   PROGRAMS AND SUBROUTINES
C
O Search - Code conversion
C[BP.INST KBIL.SINGLE.AC.SE.3]
HSEARCH.RUNTYPE
P
C
IF A1 = 'CSEG' GO 450
C
400 C    COMPILE & CAT
C
C
O Compile and catalog
[BP.INST KBIL.SINGLE.AC.SE.4]
HSEARCH.RUNTYPE
P
C
GO 500
C
450 C   REMOVE MDD'S FROM IBP
C
C
[BP.INST KBIL.SINGLE.AC.SE.4.1]
HSEARCH.RUNTYPE
P
C
GO 500
C
600 C   PROCEDURES
C
O Install procs to proclib
[BP.INST KBIL.SINGLE.AC.SE.6]
HSEARCH.RUNTYPE
P
C
C
500 C   FEEDBACK
C
O Archive user feedback
[BP.INST KBIL.SINGLE.AC.SE.5]
HSEARCH.RUNTYPE
P
C
C
700 C   ADDITIONAL STEPS
C
O Additional batch processes
[BP.INST KBIL.SINGLE.AC.SE.ADDTL]
HSEARCH.RUNTYPE
P
C
C
GO 999
900 C
C
O Process aborted!!!
C
999 C
HCOPY SYS KBIL.SINGLE.RUNTYPE.HOLD (O)
STON
HKBIL.INSTALL.RUNTYPE
P
C
O End of KBIL Installation Process.
C
RTN
~KBIL-INSTALL.TEMP0~
PQN
CPROCEDURE: KBIL.IN.AC.SE
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C               10 MAY 92  Vs 2.0
C
C
CCOPYRIGHT    : (C) 1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O
O
O This is the Installation Procedure . . . 
O
O               STAGE 0
O
O There are a total of ? primary steps
O                  and ? secondary steps.
O
O Starting . . . 
O
O Stage 0
O
HSP-ASSIGN HS
P
O
10 O Step 0.1
O
HBLOCK-PRINT KBIL ISS0 (P)
P
C
O
CHSYS.MSG.SEND PROGRAMS KBIL ISS0
CSTON
CHPROGRAMS<
CHKBIL ISS0<
CP
O
O             Default type of run is +
IHINSTALL
D0
C
20 HSEARCH.RUNTYPE
P
O
O          Type of run being done is +
D0
O
IF A1 = 'TAPE' GO 30
IF A1 = 'COMM' GO 30
IF A1 = 'DEV' GO 30
IF A1 = 'PROG' GO 30
IF A1 = 'SUBR' GO 30
IF A1 = 'CSEG' GO 30
IF A1 = 'PROC' GO 30
IF A1 = 'OTHER' GO 30
GO 40
30 O Create KBIL.INSTALL.LIST and move item(s) from BP.IMPORT
O
C [BP.INST KBIL.IN.AC.SE.0.1]
C O
C 40 O Stage 0 completed . . . 
C O
C HSLEEP 2
C P
C 100 C BACKUP OLD
C O
C O Backup old and transfer list
C [BP.INST KBIL.IN.AC.SE.1]
C HSEARCH.RUNTYPE
C P
C O
C C Branch to handle item types
C C
C IF A1 = 'INSTALL' GO 200
C IF A1 = 'DEV' GO 200
C IF A1 = 'COMM' GO 200
C C
C CF A1 = 'TAPE'
C IF A1 = 'PROG' G 200
C IF A1 = 'SUBR' G 200
C IF A1 = 'CSEG' G 300
C IF A1 = 'PROC' G 300
C IF A1 = 'OTHER' G 300
C GO 900
C C
C C
C 200 O Create Procs
C O
C [BP.INST KBIL.IN.AC.SE.2]
C HSEARCH.RUNTYPE
C P
C O
C C Branch to handle item types
C C
C IF A1 = 'INSTALL' GO 300
C IF A1 = 'DEV' GO 300
C IF A1 = 'COMM' GO 300
C C
C CF A1 = 'TAPE'
C IF A1 = 'PROG' G 300
C IF A1 = 'SUBR' G 300
C IF A1 = 'CSEG' G 300
C IF A1 = 'PROC' G 600
C IF A1 = 'OTHER' G 500
C GO 900
C C
C 300 C   PROGRAMS AND SUBROUTINES
C C
C O Search - Code conversion
C [BP.INST KBIL.IN.AC.SE.3]
HSEARCH.RUNTYPE
P
O
IF A1 = 'CSEG' GO 450
C
400 C    COMPILE & CAT
C
O
O Compile and catalog
[BP.INST KBIL.IN.AC.SE.4]
HSEARCH.RUNTYPE
P
O
GO 500
C
450 C   REMOVE MDD'S FROM IBP
C
C
[BP.INST KBIL.IN.AC.SE.4.1]
HSEARCH.RUNTYPE
P
O
GO 500
C
600 C   PROCEDURES
C
O Install procs to proclib
[BP.INST KBIL.IN.AC.SE.6]
HSEARCH.RUNTYPE
P
O
C
500 C   FEEDBACK
O
O Archive user feedback
[BP.INST KBIL.IN.AC.SE.5]
HSEARCH.RUNTYPE
P
O
C
700 C   ADDITIONAL STEPS
O
O Additional batch processes
[BP.INST KBIL.IN.AC.SE.ADDTL]
HSEARCH.RUNTYPE
P
O
O
GO 999
900 C
O
O Process aborted!!!
O
999 C
HCOPY SYS KBIL.INSTALL.RUNTYPE.HOLD (O)
STON
HKBIL.INSTALL.RUNTYPE
P
O
O End of KBIL Installation Process.
O
RTN
~KBIL-INSTALL.TEMP1~
PQN
CPROCEDURE: KBIL.IN.AC.SE
HSEARCH.RUNTYPE
P
O
IF A1 = 'CSEG' GO 500
O
O Compile and catalog
[BP.INST KBIL-INSTALL.TEMP2]
HSEARCH.RUNTYPE
P
O
GO 700
C
600 C   PROCEDURES
C
O Install procs to proclib
[BP.INST KBIL.IN.AC.SE.6]
HSEARCH.RUNTYPE
P
O
C
500 C   FEEDBACK
O
O Archive user feedback
[BP.INST KBIL.IN.AC.SE.5]
HSEARCH.RUNTYPE
P
O
C
700 C   ADDITIONAL STEPS
O
O Additional batch processes
[BP.INST KBIL.IN.AC.SE.ADDTL]
HSEARCH.RUNTYPE
P
O
O
GO 999
900 C
O
O Process aborted!!!
O
999 C
O
O End of KBIL Installation Process.
O
RTN
~KBIL-INSTALL.TEMP2~
PQN
RI
RO
C
50 C
C
CHSYS.MSG.SEND PROGRAMS LOGGIN TO INSTALL-2
CSTON
CHPROGRAMS<
CHLOGGIN TO INSTALL-2<
CP
C
HLOGTO KBIL-INSTALL-1,KI1-9201
P
C
C
999 C
HZZOFF
P
C
XC
RTN
~KBIL-INSTALL.TEMP3~
PQN
RI
RO
C
O
O
O Terminal being temporarily used for software installation
O
O
O
O
10 CHSLEEP 10
CP
O
O
C
CHSYS.MSG.SEND PROGRAMS BATCH STARTED
CSTON
CHPROGRAMS<
CHBATCH STARTED<
CP
C
C
20 C Perform secondary procedure (translation)
C
C [BP.INST KBIL.IN.AC.SE]
C
C
30 C Check run type
C
HSEARCH.RUNTYPE
P
C
IF A1 = 'DEV' GO 40
IF A1 = 'COMM' GO 40
IF A1 = 'INSTALL' GO 40
IF A1 = 'ABORT' GO 999
C
IF A1 = 'TAPE' GO 40
IF A1 = 'PROG' GO 40
IF A1 = 'SUBR' GO 40
IF A1 = 'CSEG' GO 999
IF A1 = 'OTHER' GO 999
C
C
40 C Transfer file pointers to other accounts
C
[BP.INST KBIL.IN.AC.PROC]
C
C
50 CCCC
C
CHSYS.MSG.SEND PROGRAMS LOGGIN TO INSTALL-2
CSTON
CHPROGRAMS<
CHLOGGIN TO INSTALL-2<
CP
C
HLOGTO KBIL-INSTALL-1,KI1-9201
P
C
C
999 C
C
XC
RTN
~KBIL-LOAD~
PQN
RI
RO
C
O
O
O Terminal being temporarily used for software installation
O
O
O
O
HSLEEP 10
P
O
O
C
HSYS.MSG.SEND PROGRAMS BATCH STARTED
STON
HPROGRAMS<
HBATCH STARTED<
P
C
[BP.INST KBIL.IN.AC.PR]
C
C
C
C
X
~KBIL.FILES~
ACG
ACM
ACT
ACX
ADD
ASH
ATH
ATR
CAJ
CNT
DLQ
DVC
EFT
LBL
PAP
PAR
REV
RTE
STT
STX
SVC
SVS
TAX
TPL
WKH
WKO
WKP
~KBIL.IN.AC.PR~
PQN
CPROCEDURE: KBIL.IN.AC.PR
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O
O
O This is the KBIL Installation Procedure . . . 
O
O               STAGE 0
O
O There are a total of ? primary steps
O                  and ? secondary steps.
O
O Starting . . . 
O
O Stage 0
O
HSP-ASSIGN HS
P
O
100 O
O
O Step 0.1
O
O Enter (T)ape or (D)ial-up for a run type: +
S2
IP
IF # A2 GO 100
IF A2 = END GO 900
IF A2 = T GO 120
IF A2 # D GO 100
120 O
O
O Step 0.2
O
HBLOCK-PRINT KBIL IS0 (P)
P
O
HSYS.MSG.SEND PROGRAMS KBIL IS0
STON
HPROGRAMS<
HKBIL IS0<
P
O
O Stage 0 completed . . . 
O
[BP.INST KBIL.IN.AC.PR.1]
O
[BP.INST KBIL.IN.AC.PR.2]
O
[BP.INST KBIL.IN.AC.PR.3]
O
[BP.INST KBIL.IN.AC.PR.4]
O
[BP.INST KBIL.IN.AC.PR.ADDTL]
O
HLOGON
STON
H0,KBIL-INSTALL<
P
O
GO 999
900 C
O
O Process aborted!!!
O
999 C
O
O End of KBIL Installation Process.
O
RTN
~KBIL.IN.AC.PR.1~
PQN
CPROCEDURE: KBIL.IN.AC.PR.1
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O
O
O This is the KBIL Installation Procedure . . . 
O
O
O           STAGE 1
O
O
O
O Step 1.1
O
IF A2 # T GO 121
O
O    Tape Version
O Attach Tape Unit
HT-ATT 8192 (U)
P
O
O Step 1.2
O Rewind Tape
HT-REW
P
O
O Step 1.3
O Space Tape past dictionary file
HT-FWD 1
P
O
O Step 1.4
O Load the following items:
O
O       KBIL.INSTALL.LIST...........List of item to be installed
O       KBIL.INSTALL................Conversion parameter item
O       KBIL.IN.AC.PR.ADDTL.........Additional primary (on-line) processes
O       KBIL.IN.AC.SE.ADDTL.........Additional batch processes
O
HT-LOAD SYS (O)
P
O
O Step 1.5
GO 190
C
121 O
O
O Step 1.1
O
RI
RO
IHPC-PICK KBILPARM.TLD TO "SYS" (T)
[BP.INST PC-PICK]
O
O Transmission of items for stage 1 complete
O
O Step 1.2
190 O
O
RI
RO
HBLOCK-PRINT KBIL IS1 (P)
P
O
HSYS.MSG.SEND PROGRAMS KBIL IS1
STON
HPROGRAMS<
HKBIL IS1<
P
O
O Stage 1 completed.
O
RTN
~KBIL.IN.AC.PR.2~
PQN
CPROCEDURE: KBIL.IN.AC.PR.2
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O
O
O This is the KBIL Installation Procedure . . . 
O
O
O           STAGE 2
O
O
IF A2 # T GO 121
O    Tape Version
O Step 2.1
O Space Tape past dictionary file
HT-FWD 1
P
O
O Step 2.2
O Load the changed items in to the file SYS.
O
HT-LOAD SYS (O)
P
O
O Step 2.3
GO 190
C
121 O
O
O Transmit the changed items to the file SYS.
O
O Step 2.1
O
RI
RO
IHPC-PICK KBILCHNG.TLD TO "SYS" (T)
[BP.INST PC-PICK]
O
O Transmission of items for stage 2 complete
O
O Step 2.2
190 O
O
RI
RO
HBLOCK-PRINT KBIL IS2 (P)
P
O
HSYS.MSG.SEND PROGRAMS KBIL IS2
STON
HPROGRAMS<
HKBIL IS2<
P
O
O Stage 2 completed.
O
RTN
~KBIL.IN.AC.PR.3~
PQN
CPROCEDURE: KBIL.IN.AC.PR.3
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O
O
O This is the KBIL Installation Procedure . . . 
O
O
O           STAGE 3
O
O
IF A2 # T GO 121
O    Tape Version
O Step 3.1
O Space Tape past dictionary file
HT-FWD 1
P
O
O Step 3.2
O Load the user feedback data into the file USER.FEEDBACK.
O
HT-LOAD USER.FEEDBACK (O)
P
O
O Step 3.3
GO 190
C
121 O
O
O Transmit the user feedback items to the file USER.FEEDBACK.
O
O Step 3.1
O
RI
RO
IHPC-PICK KBILDEFB.TLD TO "USER.FEEDBACK" (T)
[BP.INST PC-PICK]
O
O Transmission of items for stage 3 complete
O
O Step 3.2
190 O
O
RI
RO
HBLOCK-PRINT KBIL IS3 (P)
P
O
HSYS.MSG.SEND PROGRAMS KBIL IS3
STON
HPROGRAMS<
HKBIL IS3<
P
O
O Stage 3 completed.
O
RTN
~KBIL.IN.AC.PR.4~
PQN
CPROCEDURE: KBIL.IN.AC.PR.4
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O
O
O This is the KBIL Installation Procedure . . . 
O
O
O           STAGE 4
O
O
IF A2 # T GO 121
O    Tape Version
O Step 4.1
O Dump the user feedback data onto the tape (from USER.FEEDBACK).
O
HS-DUMP USER.INFO *
P
O
O Step 4.2
GO 190
C
121 O
O
O Transmit the user feedback items to the file KBILSOFB.TLD.
O
O Step 4.1
O
RI
RO
IHPICK-PC USER.FEEDBACK TO "KBILSOFB.TLD" (T)
[BP.INST PICK-PC]
O
O Transmission of items for stage 4 complete
O
O Step 4.2
190 O
O
RI
RO
HBLOCK-PRINT KBIL IS4 (P)
P
O
HSYS.MSG.SEND PROGRAMS KBIL IS4
STON
HPROGRAMS<
HKBIL IS4<
P
O
O Stage 4 completed.
O
RTN
~KBIL.IN.AC.PR.ADDTL~
PQN
C[BP.INST NO-OP]
C
C
RTN
~KBIL.IN.AC.PROC~
PQN
RI
RO
C
C
C
O Terminal being temporarily used for software installation
C
C
C
C
HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST (O)
STON
H(KBIL-INSTALL-1.MD<
P
C
HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST (O)
STON
H(KBIL-INSTALL-2.MD<
P
C
HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST (O)
STON
H(KBIL-INSTALL-3.MD<
P
C
HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST (O)
STON
H(KBIL-INSTALL-4.MD<
P
C
C
HCOPY KBIL-INSTALL.MD IN.FILE OUT.FILE OLD.FILE KBIL.INSTALL.LIST.CATALOG KBIL.INSTALL.LIST (O)
STON
H(KBIL-INSTALL-5.MD<
P
C
C
C
RTN
~KBIL.IN.AC.SE~
PQN
CPROCEDURE: KBIL.IN.AC.SE
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C               10 MAY 92  Vs 2.0
C
CCOPYRIGHT    : (C) 1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the Installation Procedure . . . 
O
C
O Starting . . . 
C
O Stage 0
C
HSP-ASSIGN HS
P
C
10 CCCCCCCCC 10
C
O Step 0.1
C
CHBLOCK-PRINT KBIL ISS0 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL ISS0
STON
HPROGRAMS<
HKBIL ISS0<
P
C
O             Default type of run is +
S1
IHINSTALL
D0
C
20 CCCCCCCCCCCCCC 20
C
HSEARCH.RUNTYPE
P
O          Type of run being done is +
D0
C
O Validate run type
IF A1 = 'INSTALL' GO 30
IF A1 = 'SINGLE' GO 30
C
IF A1 = 'TAPE' GO 30
IF A1 = 'COMM' GO 30
IF A1 = 'DEV' GO 30
C
IF A1 = 'PROG' GO 30
IF A1 = 'SUBR' GO 30
IF A1 = 'CSEG' GO 30
IF A1 = 'PROC' GO 30
IF A1 = 'OTHER' GO 30
GO 999
C
30 CCCCCCCCCCCCCC 30
C
O Classify items, set file pointers 
[BP.INST KBIL.IN.AC.SE.0.1]
C
40 CCCCCCCCCCCC 40
C
CHSLEEP 2
CP
100 CCCCCCCCCCCC 100
C
O Move file pointers to MD & save list 
[BP.INST KBIL.IN.AC.SE.1]
HSYS.RTNTYPE
P
C
O Branch to handle item types
IF A1 = 'INSTALL' GO 200
IF A1 = 'DEV' GO 200
IF A1 = 'COMM' GO 200
C
IF A1 = 'TAPE' GO 200
IF A1 = 'PROG' G 200
IF A1 = 'SUBR' G 200
IF A1 = 'CSEG' G 200
IF A1 = 'PROC' G 200
IF A1 = 'OTHER' G 300
GO 900
C
C
200 CCCCCCCCCCCCC 200
C
O Create Procs
[BP.INST KBIL.IN.AC.SE.2]
HSYS.RTNTYPE
P
C
O Branch to handle item types
IF A1 = 'INSTALL' GO 300
IF A1 = 'DEV' GO 300
IF A1 = 'COMM' GO 300
C
IF A1 = 'TAPE' GO 300
IF A1 = 'PROG' GO 300
IF A1 = 'SUBR' GO 300
IF A1 = 'CSEG' GO 300
IF A1 = 'PROC' GO 300
IF A1 = 'OTHER' GO 500
GO 900
C
300 CCCCCCCCCCC 300
C
O Convert Code (Search)
CHSYS.MSG.SEND PROGRAMS KBIL ISS3 Translate
CSTON
CHPROGRAMS<
CHKBIL ISS3 Translate<
CP
C
[BP.INST KBIL.IN.AC.SE.3]
HSYS.RTNTYPE
P
C
IF A1 = 'CSEG' GO 450
IF A1 = 'PROC' GO 450
IF A1 = 'OTHER' GO 450
C
400 CCCCCCCCCCCCC 400
C
O Compile and catalog
[BP.INST KBIL.IN.AC.SE.4]
HSYS.RTNTYPE
P
C
GO 500
C
450 CCCCCCCCCCCC 450
C
O Remove opsys conversion flags
[BP.INST KBIL.IN.AC.SE.4.1]
HSYS.RTNTYPE
P
C
500 CCCCCCCCCCCC 500
C
O Archive user feedback
[BP.INST KBIL.IN.AC.SE.5]
HSYS.RTNTYPE
P
C
700 CCCCCCCCCCC 700
C
O Additional batch processes
[BP.INST KBIL.IN.AC.SE.ADDTL]
HSYS.RTNTYPE
P
C
GO 999
C
900 CCCCCCCCCC 900
C
O Process aborted!!!
C
999 CCCCCCCCCCCCC 999
C
O Reset Port type (overwrite TAPE)
HCOPY SYS KBIL.INSTALL.RUNTYPE.HOLD (O)
STON
HKBIL.INSTALL.RUNTYPE
P
C
O End of KBIL Installation Process.
C
RTN
~KBIL.IN.AC.SE.0.1~
PQN
CPROCEDURE: KBIL.IN.AC.SE.0.1
C
CAUTHOR:    DAVID HORSMAN
CCOMPANY:   MACROSCOPE DESIGN MATRIX
CDATE WRITEN: 10 MAY 92
CDATE RELEASED:  10 MAY 92
C
C
CCOPYWRIGHT     : (C) 1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MATRIX
C                 All rights reserved
C
C
O    This is the Install Procedure
C
O    Stage 0
O     Step 0.1
C
C
HTAPE.LISTWRITE
STON
HKBIL.INSTALL<
P
C
O     STEP 0.1.2
C
HCOPY SYS
H KBIL.INSTALL
H.LIST (T,N)
P
C
O     STEP 0.1.3
C
HFORM-LIST SYS
H KBIL.INSTALL
H.LIST
STON
HSAVE-LIST
H KBIL.INSTALL
H.LIST
P
C
O     End of step 0.1
C
CX
RTN
~KBIL.IN.AC.SE.1~
PQN
CPROCEDURE: KBIL.IN.AC.SE.1
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the KBIL Installation Procedure . . . 
C
O           STAGE 1
C
O Step 1.1
C
HFORM-LIST SYS "KBIL.INSTALL.LIST"
STON
HSAVE-LIST KBIL.INSTALL.LIST<
P
C
O Step 1.2
C
HCOPY SYS KBIL.INSTALL.LIST IN.FILE OUT.FILE OLD.FILE (O)
STON
H(MD<
P
C
IF A1 = "DEV" GO 300
GO 400
C
300 CCCCCCCC 300
C
O Step 1.3
C
C HGET-LIST KBIL.INSTALL.LIST
C STON
C HCOPY IN.FILE (O)<
C H(OLD.FILE<
C P
C
400 CCCCCC 400
C
CHBLOCK-PRINT KBIL ISS1 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL ISS1 List
STON
HPROGRAMS<
HKBIL ISS1 List<
P
C
O Stage 1 completed.
C
RTN
~KBIL.IN.AC.SE.2~
PQN
CPROCEDURE: KBIL.IN.AC.SE.2
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C COPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the KBIL Installation Procedure . . . 
C
O           STAGE 2
C
O Step 2.1
C
HMDD.COM.CAT.ALL
STON
HKBIL.INSTALL.LIST<
CCHFILE<
HKBIL.INSTALL.FILE<
HY<
HN<
HN<
H<
P
C
O Step 2.2
C
HMDD.CAT.ALL
STON
HKBIL.INSTALL.LIST<
CCHFILE<
HKBIL.INSTALL.FILE<
HN<
P
C
RI
RO
CHBLOCK-PRINT KBIL ISS2 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL ISS2 Procs
STON
HPROGRAMS<
HKBIL ISS2 Procs<
P
C
O Stage 2 completed.
C
RTN
~KBIL.IN.AC.SE.3~
PQN
CPROCEDURE: KBIL.IN.AC.SE.3
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the KBIL Installation Procedure . . . 
C
O           STAGE 3
C
O Step 3.1
C
C
C
HSEARCH.RUNTYPE
P
C
O Type of run is +
D0
C
C
HACS.SEARCH
STON
HAXION<
HINST<
H@KBIL.INSTALL<
P
C
RI
RO
CHBLOCK-PRINT KBIL SINGLE ISS3 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL SINGLE ISS3 Translate
STON
HPROGRAMS<
HKBIL SINGLE ISS3 Translate<
P
C
O Stage 3 completed.
C
CX
RTN
~KBIL.IN.AC.SE.4~
PQN
CPROCEDURE: KBIL.IN.AC.SE.4
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the KBIL Installation Procedure . . . 
C
O           STAGE 4
C
O Step 4.1.1
C
[BP.INST KBIL.INSTALL.LIST.MDD.LOCK]
C
C
HSYS.RTNTYPE
P
C
C                IF A1 = "CSEG" GO 490
IF A1 = "PROC" GO 490
C
O Step 4.1.2
C
[BP.INST KBIL.INSTALL.LIST.COMPILE]
C
490 CCCCCCCCC 490
O
RI
RO
CHBLOCK-PRINT KBIL ISS4 (P)
P
C
HSYS.MSG.SEND PROGRAMS KBIL ISS4 Compile
STON
HPROGRAMS<
HKBIL ISS4 Compile<
P
C
O Stage 4 completed.
C
CX
RTN
~KBIL.IN.AC.SE.4.1~
PQN
C
O        REMOVE *%%MDD%%= AND *%%ALL%%=  FROM CODE SEGMENTS
C
[BP.INST KBIL.SYSTEM]
C
HDATE
P
C
HWHO
P
C
O       ACTIVATE MDD 
C
HFORM-LIST SYS KBIL.INSTALL.LIST
STON
HED OUT.FILE<
C%%MDD%%=HP9 R9999/^%%MD
C%%MDD%%=HD%%^//FR9999/^%%AL
C%%MDD%%=HL%%^//FIP9<
C%%ULT%%=HP9 R9999/^%%UL
C%%ULT%%=T%%^//FR9999/^%%AL
C%%ULT%%=HL%%^//FIP9<
C%%PCK%%=HP9 R9999/^%%PC
C%%PCK%%=HK%%^//FR9999/^%%AL
C%%PCK%%=HL%%^//FIP9<
HPD<
HP9<
P
C
C%%MDD%%=RTN
C%%ULT%%=X
C%%PCK%%=X
~KBIL.IN.AC.SE.5~
PQN
CPROCEDURE: KBIL.IN.AC.SE.5
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the KBIL Installation Procedure . . . 
C
O           STAGE 5
C
O Step 5.1
C
HCOPY USER.FEEDBACK * (O,D)
STON
H(USER.FEEDBACK.ARCHIVE<
P
C
RI
RO
CHBLOCK-PRINT KBIL ISS5 (P)
CP
C
CHSYS.MSG.SEND PROGRAMS KBIL ISS5
CSTON
CHPROGRAMS<
CHKBIL ISS5<
CP
C
O Stage 5 completed.
C
CX
RTN
~KBIL.IN.AC.SE.6~
PQN
CPROCEDURE: KBIL.IN.AC.SE.6
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   11 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the KBIL Installation Procedure . . . 
C
C
O           STAGE 6
C
C
O Step 6.1
C
O Identify procs
C
HGET-LIST KBIL.INSTALL.LIST
STON
HSELECT OUT.FILE WITH *A1 EQ "PQ]"<
HSAVE-LIST KBIL.INSTALL.LIST.PROC<
P
C
O Step 6.2
C
O Save old procs
C
HGET-LIST KBIL.INSTALL.LIST.PROC
STON
HCOPY IN.PL (O)<
H(OLD.PL<
P
C
O Step 6.3
C
O Install new procs
C
HGET-LIST KBIL.INSTALL.LIST.PROC
STON
HCOPY OUT.FILE (O)<
H(IN.PL<
P
C
O Step 6.4
C
690 O
C
RI
RO
CHBLOCK-PRINT KBIL ISS6 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL ISS6 Move Procs
STON
HPROGRAMS<
HKBIL ISS6 Move Procs<
P
C
O Stage 6 completed.
C
RTN
~KBIL.IN.AC.SE.ADDTL~
PQN
C
C[BP.INST NO-OP]
C
CX
RTN
~KBIL.IN.AC.SE.UT~
PQN
CPROCEDURE: KBIL.IN.AC.SE
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C               10 MAY 92  Vs 2.0
C
CCOPYRIGHT    : (C) 1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the Installation Procedure . . . 
O
C
O Starting . . . 
C
O Stage 0
C
HSP-ASSIGN HS
P
C
10 CCCCCCCCC 10
C
O Step 0.1
C
CHBLOCK-PRINT KBIL ISS0 (P)
CP
C
CHSYS.MSG.SEND PROGRAMS KBIL ISS0
CSTON
CHPROGRAMS<
CHKBIL ISS0<
CP
C
O             Default type of run is +
S1
IHINSTALL
D0
C
20 CCCCCCCCCCCCCC 20
C
HSEARCH.RUNTYPE
P
O          Type of run being done is +
D0
C
O Validate run type
IF A1 = 'INSTALL' GO 30
IF A1 = 'SINGLE' GO 30
C
IF A1 = 'TAPE' GO 30
IF A1 = 'COMM' GO 30
IF A1 = 'DEV' GO 30
C
IF A1 = 'PROG' GO 30
IF A1 = 'SUBR' GO 30
IF A1 = 'CSEG' GO 30
IF A1 = 'PROC' GO 30
IF A1 = 'OTHER' GO 30
GO 999
C
30 CCCCCCCCCCCCCC 30
C
O Classify items, set file pointers 
[BP.INST KBIL.IN.AC.SE.0.1]
C
40 CCCCCCCCCCCC 40
C
CHSLEEP 2
CP
100 CCCCCCCCCCCC 100
C
O Move file pointers to MD & save list 
[BP.INST KBIL.IN.AC.SE.1]
HSYS.RTNTYPE
P
C
O Branch to handle item types
IF A1 = 'INSTALL' GO 200
IF A1 = 'DEV' GO 200
IF A1 = 'COMM' GO 200
C
IF A1 = 'TAPE' GO 200
IF A1 = 'PROG' G 200
IF A1 = 'SUBR' G 200
IF A1 = 'CSEG' G 200
IF A1 = 'PROC' G 200
IF A1 = 'OTHER' G 300
GO 900
C
C
200 CCCCCCCCCCCCC 200
C
O Create Procs
[BP.INST KBIL.IN.AC.SE.2]
HSYS.RTNTYPE
P
C
O Branch to handle item types
IF A1 = 'INSTALL' GO 300
IF A1 = 'DEV' GO 300
IF A1 = 'COMM' GO 300
C
IF A1 = 'TAPE' GO 300
IF A1 = 'PROG' GO 300
IF A1 = 'SUBR' GO 300
IF A1 = 'CSEG' GO 300
IF A1 = 'PROC' GO 300
IF A1 = 'OTHER' GO 500
GO 900
C
300 CCCCCCCCCCC 300
C
CO Convert Code (Search)
C[BP.INST KBIL.IN.AC.SE.3]
CHSYS.RTNTYPE
CP
C
C IF A1 = 'CSEG' GO 450
C IF A1 = 'PROC' GO 450
C IF A1 = 'OTHER' GO 450
C
400 CCCCCCCCCCCCC 400
C
CO Compile and catalog
C[BP.INST KBIL.IN.AC.SE.4]
CHSYS.RTNTYPE
CP
C
GO 500
C
450 CCCCCCCCCCCC 450
C
O Remove opsys conversion flags
[BP.INST KBIL.IN.AC.SE.4.1]
HSYS.RTNTYPE
P
C
500 CCCCCCCCCCCC 500
C
O Archive user feedback
[BP.INST KBIL.IN.AC.SE.5]
HSYS.RTNTYPE
P
C
700 CCCCCCCCCCC 700
C
O Additional batch processes
[BP.INST KBIL.IN.AC.SE.ADDTL]
HSYS.RTNTYPE
P
C
GO 999
C
900 CCCCCCCCCC 900
C
O Process aborted!!!
C
999 CCCCCCCCCCCCC 999
C
O Reset Port type (overwrite TAPE)
HCOPY SYS KBIL.INSTALL.RUNTYPE.HOLD (O)
STON
HKBIL.INSTALL.RUNTYPE
P
C
O End of KBIL Installation Process.
C
RTN
~KBIL.INSTALL.LIST.MDD.LOCK~
PQN
O       PERFORM MDD LOCK.ITEM CONVERSION
O
O
C
[BP.INST KBIL.SYSTEM]
C
HDATE
P
O
HWHO
P
O
O
O       ACTIVATE MDD 
O
O
HGET-LIST KBIL.INSTALL.LIST
STON
HMDD.SEARCH IN.FILE<
HGENERAL.COMMON.AREA<
H<
HED OUT.FILE<
HP9 FR9999/ LOCK.ITEM(^^^.FILE,/ MDD.LOCK.ITEM(/FR9999/ UNLOCK.ITEM(^^^.FILE,/ MDD.UNLOCK.ITEM(/<
HP4 FR9999/ LOCK.ITEM(^^^^.FILE,/ MDD.LOCK.ITEM(/FR9999/ UNLOCK.ITEM(^^^^.FILE,/ MDD.UNLOCK.ITEM(/<
HP8 FR9999/ UPDATE.LOCK(^^^^^^^^)/ MDD.UPDATE.LOCK/<
HP6 FR9999/LOCK.IT(/LOCK.ITEM(/<
HP5 FR999/ UPDATE.LOCK(^^^^^^^^^)/ MDD.UPDATE.LOCK/<
HP7 P4P5P6P8P9FIP7<
HPD<
HP7<
P
C
C
C
C
C
O
O
C
RTN
~KBIL.SINGLE.AC.PROC~
PQN
RI
RO
C
C
C
O Terminal being temporarily used for software installation
C
C
C
C
HCOPY KBIL-INSTALL.MD IN.FILE.SINGLE OUT.FILE.SINGLE OLD.FILE.SINGLE KBIL.SINGLE.LIST.CATALOG KBIL.SINGLE.LIST (O)
STON
H(KBIL-INSTALL-1.MD<
P
C
HCOPY KBIL-INSTALL.MD IN.FILE.SINGLE OUT.FILE.SINGLE OLD.FILE.SINGLE KBIL.SINGLE.LIST.CATALOG KBIL.SINGLE.LIST (O)
STON
H(KBIL-INSTALL-2.MD<
P
C
HCOPY KBIL-INSTALL.MD IN.FILE.SINGLE OUT.FILE.SINGLE OLD.FILE.SINGLE KBIL.SINGLE.LIST.CATALOG KBIL.SINGLE.LIST (O)
STON
H(KBIL-INSTALL-3.MD<
P
C
HCOPY KBIL-INSTALL.MD IN.FILE.SINGLE OUT.FILE.SINGLE OLD.FILE.SINGLE KBIL.SINGLE.LIST.CATALOG KBIL.SINGLE.LIST (O)
STON
H(KBIL-INSTALL-4.MD<
P
C
C
HCOPY KBIL-INSTALL.MD IN.FILE.SINGLE OUT.FILE.SINGLE OLD.FILE.SINGLE KBIL.SINGLE.LIST.CATALOG KBIL.SINGLE.LIST (O)
STON
H(KBIL-INSTALL-5.MD<
P
C
C
C
C
RTN
~KBIL.SINGLE.AC.SE~
PQN
CPROCEDURE: KBIL.SINGLE.AC.SE
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C               10 MAY 92  Vs 2.0
C
C
CCOPYRIGHT    : (C) 1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the Installation Procedure . . . 
C
O               STAGE 0
C
O There are a total of ? primary steps
O                  and ? secondary steps.
C
O Starting . . . 
C
O Stage 0
C
HSP-ASSIGN HS
P
C
10 O Step 0.1
C
CHBLOCK-PRINT KBIL ISS0 (P)
CP
C
C
HSYS.MSG.SEND PROGRAMS KBIL ISS0
STON
HPROGRAMS<
HKBIL ISS0<
P
C
O             Default type of run is +
S1
IHINSTALL
D0
C
20 HSEARCH.RUNTYPE
P
C
O          Type of run being done is +
D0
C
C%%MDD%%=IF A1 = 'INSTALL' GO 30
C%%ULT%%=IF A1 = 'INSTALL' GO 30
C%%PCK%%=IF A1 = INSTALL GO 30
C
IF A1 = 'SINGLE' GO 30
C
C
IF A1 = 'TAPE' GO 30
IF A1 = 'COMM' GO 30
IF A1 = 'DEV' GO 30
IF A1 = 'PROG' GO 30
IF A1 = 'SUBR' GO 30
IF A1 = 'CSEG' GO 30
IF A1 = 'PROC' GO 30
IF A1 = 'OTHER' GO 30
GO 40
30 O Create KBIL.INSTALL.LIST and move item(s) from BP.IMPORT
C
[BP.INST KBIL.SINGLE.AC.SE.0.1]
C
40 O Stage 0 completed . . . 
C
HSLEEP 2
P
100 C BACKUP OLD
C
O Backup old and transfer list
[BP.INST KBIL.SINGLE.AC.SE.1]
HSYS.RTNTYPE
P
C
C Branch to handle item types
C
IF A1 = 'INSTALL' GO 200
IF A1 = 'DEV' GO 200
IF A1 = 'COMM' GO 200
IF A1 = 'TAPE' GO 200
C
IF A1 = 'PROG' GO 200
IF A1 = 'SUBR' GO 200
IF A1 = 'CSEG' GO 200
IF A1 = 'PROC' GO 200
IF A1 = 'OTHER' G 300
GO 900
C
C
200 O Create Procs
C
[BP.INST KBIL.SINGLE.AC.SE.2]
HSYS.RTNTYPE
P
C
C Branch to handle item types
C
IF A1 = 'INSTALL' GO 300
IF A1 = 'DEV' GO 300
IF A1 = 'COMM' GO 300
C
IF A1 = 'TAPE' GO 300
IF A1 = 'PROG' G 300
IF A1 = 'SUBR' G 300
IF A1 = 'CSEG' G 300
IF A1 = 'PROC' G 300
IF A1 = 'OTHER' G 500
GO 900
C
300 C   PROGRAMS AND SUBROUTINES
C
O Search - Code conversion
[BP.INST KBIL.SINGLE.AC.SE.3]
HSYS.RTNTYPE
P
C
C%%MDD%%=IF A1 = 'CSEG' GO 450
C%%ULT%%=IF A1 = 'CSEG' GO 450
C%%PCK%%=IF A1 = CSEG GO 450
C
C%%MDD%%=IF A1 = 'PROC' GO 450
C%%ULT%%=IF A1 = 'PROC' GO 450
C%%PCK%%=IF A1 = PROC GO 450
C
C%%MDD%%=IF A1 = 'OTHER' GO 450
C%%ULT%%=IF A1 = 'OTHER' GO 450
C%%PCK%%=IF A1 = OTHER GO 450
C
400 C    COMPILE & CAT
C
C
O Compile and catalog
[BP.INST KBIL.SINGLE.AC.SE.4]
HSYS.RTNTYPE
P
C
GO 500
C
450 C   REMOVE MDD'S FROM IBP
C
C
[BP.INST KBIL.SINGLE.AC.SE.4.1]
HSYS.RTNTYPE
P
C
GO 500
C
600 C   PROCEDURES
C
O Install procs to proclib
[BP.INST KBIL.SINGLE.AC.SE.6]
HSYS.RTNTYPE
P
C
C
500 C   FEEDBACK
C
O Archive user feedback
[BP.INST KBIL.SINGLE.AC.SE.5]
HSYS.RTNTYPE
P
C
C
700 C   ADDITIONAL STEPS
C
O Additional batch processes
[BP.INST KBIL.SINGLE.AC.SE.ADDTL]
HSYS.RTNTYPE
P
C
C
GO 999
900 C
C
O Process aborted!!!
C
999 C
HCOPY SYS KBIL.INSTALL.RUNTYPE.HOLD (O)
STON
HKBIL.INSTALL.RUNTYPE
P
C
O End of KBIL Installation Process.
C
RTN
~KBIL.SINGLE.AC.SE.0.1~
PQN
CPROCEDURE: KBIL.IN.AC.SE.0.1
C
CAUTHOR:    DAVID HORSMAN
CCOMPANY:   MACROSCOPE DESIGN MATRIX
CDATE WRITEN: 10 MAY 92
CDATE RELEASED:  10 MAY 92
C
C
CCOPYWRIGHT     : (C) 1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MATRIX
C                 All rights reserved
C
C
O    This is the Install Procedure
C
O    Stage 0
O     Step 0.1
C
C
HTAPE.LISTWRITE
STON
HKBIL.SINGLE<
P
C
O     STEP 0.1.2
C
HCOPY SYS
H KBIL.SINGLE
H.LIST (T,N)
P
C
O     STEP 0.1.3
C
HFORM-LIST SYS
H KBIL.SINGLE
H.LIST
STON
HSAVE-LIST
H KBIL.SINGLE
H.LIST
P
C
O     End of step 0.1
C
CX
RTN
~KBIL.SINGLE.AC.SE.1~
PQN
CPROCEDURE: KBIL.IN.AC.SE.1
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the KBIL Installation Procedure . . . 
C
C
O           STAGE 1
C
C
100 O Step 1.1
C
HFORM-LIST SYS "KBIL.SINGLE.LIST"
STON
HSAVE-LIST KBIL.SINGLE.LIST<
P
C
200 O Step 1.2
C
HCOPY SYS KBIL.SINGLE.LIST IN.FILE.SINGLE OUT.FILE.SINGLE OLD.FILE.SINGLE (O)
STON
H(MD<
P
C
IF A1 = "DEV" GO 300
GO 400
C
C
300 O Step 1.3
C
C HGET-LIST KBIL.SINGLE.LIST
C STON
C HCOPY IN.FILE.SINGLE (O)<
C H(OLD.FILE.SINGLE<
C P
C
400 O Step 1.4
C
190 O
C
RI
RO
CHBLOCK-PRINT KBIL ISS1 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL ISS1 List
STON
HPROGRAMS<
HKBIL ISS1 List<
P
C
O Stage 1 completed.
C
RTN
~KBIL.SINGLE.AC.SE.2~
PQN
CPROCEDURE: KBIL.IN.AC.SE.2
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the KBIL Installation Procedure . . . 
C
C
O           STAGE 2
C
C
O Step 2.1
C
HMDD.COM.CAT.ALL
STON
HKBIL.SINGLE.LIST<
CCHFILE.SINGLE<
HKBIL.SINGLE.FILE<
HY<
HN<
HN<
H(M,N,L)<
P
C
O Step 2.2
C
HMDD.CAT.ALL
STON
HKBIL.SINGLE.LIST<
HFILE.SINGLE<
CCHKBIL.SINGLE.FILE<
HN<
P
C
O Step 2.3
C
290 O
C
RI
RO
CHBLOCK-PRINT KBIL ISS2 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL ISS2 Procs
STON
HPROGRAMS<
HKBIL ISS2 Procs<
P
C
O Stage 2 completed.
C
RTN
~KBIL.SINGLE.AC.SE.3~
PQN
CPROCEDURE: KBIL.SINGLE.AC.SE.3
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the KBIL Installation Procedure . . . 
C
C
O           STAGE 3
C
C
O Step 3.1
C
HACS.SEARCH
STON
HAXION<
HINST.SINGLE<
H@KBIL.SINGLE<
P
C
O Step 3.2
C
390 O
C
RI
RO
CHBLOCK-PRINT KBIL ISS3 (P)
P
C
HSYS.MSG.SEND PROGRAMS KBIL ISS3 Translate
STON
HPROGRAMS<
HKBIL ISS3 Translate<
P
C
O Stage 3 completed.
C
RTN
~KBIL.SINGLE.AC.SE.4~
PQN
CPROCEDURE: KBIL.SINGLE.AC.SE.4
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
O This is the KBIL Installation Procedure . . . 
C
O           STAGE 4
C
O Step 4.1.1
C
[BP.INST KBIL.SINGLE.LIST.MDD.LOCK]
C
C
HSYS.RTNTYPE
P
C
C                IF A1 = "CSEG" GO 490
IF A1 = "PROC" GO 490
C
O Step 4.1.2
C
[BP.INST KBIL.SINGLE.LIST.COMPILE]
C
490 CCCCCCCCC 490
O
RI
RO
CHBLOCK-PRINT KBIL ISS4 (P)
P
C
HSYS.MSG.SEND PROGRAMS KBIL ISS4 Compile
STON
HPROGRAMS<
HKBIL ISS4 Compile<
P
C
O Stage 4 completed.
C
CX
RTN
~KBIL.SINGLE.AC.SE.4.1~
PQN
C
O        REMOVE *%%MDD%%= AND *%%ALL%%=  FROM CODE SEGMENTS
C
[BP.INST KBIL.SYSTEM]
C
HDATE
P
C
HWHO
P
C
C
O       ACTIVATE MDD 
C
HFORM-LIST SYS KBIL.SINGLE.LIST
STON
HED OUT.FILE.SINGLE<
C%%MDD%%=HP9 R9999:^%%M
C%%MDD%%=HDD%%^::FR9999:
C%%MDD%%=H^%%ALL%%^::FIP9<
C%%ULT%%=HP9 R9999:^%%U
C%%ULT%%=HLT%%^::FR9999:
C%%ULT%%=H^%%ALL%%^::FIP9<
C%%PCK%%=HP9 R9999:^%%P
C%%PCK%%=HCK%%^::FR9999:
C%%PCK%%=H^%%ALL%%^::FIP9<
HPD<
HP9<
P
C
C
C%%MDD%%=RTN
C%%ULT%%=X
C%%PCK%%=X
~KBIL.SINGLE.AC.SE.5~
PQN
CPROCEDURE: KBIL.IN.AC.SE.5
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   08 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the KBIL Installation Procedure . . . 
C
C
O           STAGE 5
C
C
O Step 5.1
C
HCOPY USER.FEEDBACK * (O,D)
STON
H(USER.FEEDBACK.ARCHIVE<
P
C
O Step 5.2
C
590 O
C
RI
RO
CHBLOCK-PRINT KBIL ISS5 (P)
CP
C
CHSYS.MSG.SEND PROGRAMS KBIL ISS5
CSTON
CHPROGRAMS<
CHKBIL ISS5<
CP
C
O Stage 5 completed.
C
RTN
~KBIL.SINGLE.AC.SE.6~
PQN
CPROCEDURE: KBIL.IN.AC.SE.6
C
CAUTHOR:        DAVID HORSMAN
CCOMPANY:       MACROSCOPE DESIGN MAXTRIX
CDATE WRITEN:   11 NOV 87
CDATE RELEASED: 15 NOV 87  Vs 0.1
C               01 DEC 87  Vs 1.0
C
C
CCOPYRIGHT    : (C) 1987 MACROSCOPE DESIGN MAXTRIX
C                       All rights reserved.
C
C
C
O This is the KBIL Installation Procedure . . . 
C
C
O           STAGE 6
C
C
O Step 6.1
C
O Identify procs
C
HGET-LIST KBIL.SINGLE.LIST
STON
HSELECT OUT.FILE.SINGLE WITH *A1 EQ "PQ]"<
HSAVE-LIST KBIL.SINGLE.LIST.PROC<
P
C
O Step 6.2
C
O Save old procs
C
HGET-LIST KBIL.SINGLE.LIST.PROC
STON
HCOPY IN.PL (O)<
H(OLD.PL<
P
C
O Step 6.3
C
O Install new procs
C
HGET-LIST KBIL.SINGLE.LIST.PROC
STON
HCOPY OUT.FILE.SINGLE (O)<
H(IN.PL<
P
C
O Step 6.4
C
690 O
C
RI
RO
CHBLOCK-PRINT KBIL ISS6 (P)
CP
C
HSYS.MSG.SEND PROGRAMS KBIL ISS6 Move Procs
STON
HPROGRAMS<
HKBIL ISS6 Move Procs<
P
C
O Stage 6 completed.
C
RTN
~KBIL.SINGLE.AC.SE.ADDTL~
PQN
C[BP.INST NO-OP]
C
C
RTN
~KBIL.SINGLE.LIST~
KBIL-AUTORUNNER
KBIL-INSTALL
KBIL-INSTALL-1
KBIL-INSTALL-2
KBIL-INSTALL-3
KBIL-INSTALL-4
KBIL-INSTALL-5
KBIL-INSTALL-9
KBIL-INSTALL-DICT
KBIL-INSTALL-DICT-CR
KBIL-INSTALL-DICT-DEMO
KBIL-INSTALL-DICT-FC
KBIL-INSTALL-DICT-GS
KBIL-INSTALL-DICT-KBIL-DEMO
KBIL-INSTALL-MD
KBIL-INSTALL.TEMP
KBIL-INSTALL.TEMP1
KBIL-INSTALL.TEMP2
KBIL-INSTALL.TEMP3
KBIL-LOAD
KBIL.IN.AC.PR
KBIL.IN.AC.PR.1
KBIL.IN.AC.PR.2
KBIL.IN.AC.PR.3
KBIL.IN.AC.PR.4
KBIL.IN.AC.PR.ADDTL
KBIL.IN.AC.PROC
KBIL.IN.AC.SE
KBIL.IN.AC.SE.0.1
KBIL.IN.AC.SE.1
KBIL.IN.AC.SE.2
KBIL.IN.AC.SE.3
KBIL.IN.AC.SE.4
KBIL.IN.AC.SE.4.1
KBIL.IN.AC.SE.5
KBIL.IN.AC.SE.6
KBIL.IN.AC.SE.ADDTL
KBIL.INSTALL.LIST.MDD.LOCK
KBIL.SYSTEM
~KBIL.SINGLE.LIST.CATALOG~
PQN
O       CATALOG items in OUT.FILE.SINGLE for the list KBIL.SINGLE.LIST 
C
C
C
[BP.INST KBIL.SYSTEM]
C
HDATE
P
C
HWHO
P
C
C
HACC.UPDATE
STON
HS/W Inst CATALOG<
P
C
O     TAX.INCREASE
C
HCATALOG OUT.FILE.SINGLE TAX.INCREASE
P
C
C
C
RTN

~KBIL.SINGLE.LIST.COMPILE~
PQN
O       COMPILE & CATALOG items in OUT.FILE.SINGLE for the list KBIL.SINGLE.LIST 
C
C
C
[BP.INST KBIL.SYSTEM]
C
HDATE
P
C
HWHO
P
C
C
O       ACTIVATE MDD 
C
C
HGET-LIST KBIL.SINGLE.LIST
STON
HED OUT.FILE.SINGLE<
HP9 R9999/*%%MDD%%=//FR9999/*%%ALL%%=//FIP9<
HPD<
HP9<
P
C
C
C
C
O     TAX.INCREASE
HACC.UPDATE
STON
HS/W Inst BP TAX.INCREASE<
P
HBASIC OUT.FILE.SINGLE TAX.INCREASE (M,N,L)
P
HCATALOG OUT.FILE.SINGLE TAX.INCREASE
P
C
C
C
RTN

~KBIL.SINGLE.LIST.MDD.LOCK~
PQN
O       PERFORM MDD LOCK.ITEM CONVERSION
O
O
C
[BP.INST KBIL.SYSTEM]
C
HDATE
P
O
HWHO
P
O
O
O       ACTIVATE MDD 
O
O
HGET-LIST KBIL.SINGLE.LIST
STON
HMDD.SEARCH IN.FILE.SINGLE<
HGENERAL.COMMON.AREA<
H<
HED OUT.FILE.SINGLE<
HP9 FR9999/ LOCK.ITEM(^^^.FILE,/ MDD.LOCK.ITEM(/FR9999/ UNLOCK.ITEM(^^^.FILE,/ MDD.UNLOCK.ITEM(/<
HP4 FR9999/ LOCK.ITEM(^^^^.FILE,/ MDD.LOCK.ITEM(/FR9999/ UNLOCK.ITEM(^^^^.FILE,/ MDD.UNLOCK.ITEM(/<
HP8 FR9999/ UPDATE.LOCK(^^^^^^^^)/ MDD.UPDATE.LOCK/<
HP6 FR9999/LCK.IT(/LOCK.ITEM(/<
HP5 FR999/ UPDATE.LOCK(^^^^^^^^^)/ MDD.UPDATE.LOCK/<
HP7 P4P5P6P8P9FIP7<
HPD<
HP7<
P
C
C
C
C
C
O
O
C
RTN
~KBIL.SYSTEM~
PQN
O
O Frederick Cablevision, Inc.
O
RTN
~MDD.CAT.ALL~
*PROGRAM: MDD.CAT.ALL
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   15 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PROMPT EMPTY; CRLF = CR:LF; DOSNUM = 47; DOSLTH = ZERO; DOSITEM = EMPTY
PROC1 = EMPTY
*
OPEN EMPTY,"MD" TO MDI.FILE ELSE STOP
OPEN EMPTY,"SYS" TO SYS.FILE ELSE STOP
OPEN EMPTY,"OUT.BP.INST" TO BP.INST.FILE ELSE STOP
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
*
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY.":PORT,ONE ELSE
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY",ONE ELSE TERM.DISP = TRUE
END
TMP = ("000":PORT) "R#3"
READ RUN.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":TMP ELSE RUN.TYPE = "NONE"
READ RUN.FILE FROM SYS.FILE,"KBIL.":RUN.TYPE:".FILE" ELSE RUN.FILE = EMPTY
*
PRINT
PRINT "Enter list name in SYS: ":
INPUT LIST.NAME:
IF LIST.NAME EQ "KILL" THEN STOP
IF LIST.NAME EQ EMPTY THEN STOP
PRINT
*
PRINT "Enter file name: ":
INPUT FILE.NAME:
IF FILE.NAME EQ "KILL" THEN STOP
IF FILE.NAME EQ EMPTY THEN STOP
PRINT
*
READ TMP1 FROM SYS.FILE,FILE.NAME THEN
FILE.NAME = TMP1<ONE>
END
*
FILE.AVAIL = TRUE
OPEN "IN.":FILE.NAME TO ITEM.FILE ELSE FILE.AVAIL = FALSE
*
PRINT "Decatalog the old code first (Y/N): ":
INPUT DECAT:
IF DECAT EQ "KILL" THEN STOP
IF DECAT EQ EMPTY THEN STOP
PRINT
*
READ ITEM.ID.LIST FROM SYS.FILE,LIST.NAME ELSE STOP
*
PROG.LIST = EMPTY; SUBR.LIST = EMPTY; CSEG.LIST = EMPTY; OTHER.LIST = EMPTY
PROC.LIST = EMPTY; CODE.LIST = EMPTY; DICT.LIST = EMPTY
LIST.TYPE = "ABORT"; ITEM.TYPE = "ABORT"; RTN.TYPE = EMPTY
*
PROC1 = "PQN":AM
PROC1 = PROC1:"O       CATALOG items in OUT.":FILE.NAME:" for the list ":LIST.NAME:" ":AM:"C":AM:"C":AM
PROC1 = PROC1:"C":AM:"[MD KBIL.SYSTEM]":AM:"C":AM
PROC1 = PROC1:"HDATE":AM:"P":AM:"C":AM:"HWHO":AM:"P":AM:"C":AM:"C":AM
* PROC1 = PROC1:"C":AM:"C":AM:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" CAT ":LIST.NAME:"<":AM:"P":AM
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
*
PROC1 = PROC1:"HACC.UPDATE":AM:"STON":AM:"H+S/W Inst CATALOG<":AM:"P":AM
*
!
*
PRINT
*
LOOP
*
LOOP
*
PROG.OK = TRUE; ATTR1 = EMPTY; RTN.TYPE = "OTHER"
*
IF ITEM.ID.LIST NE EMPTY THEN
*
ITEM.ID = ITEM.ID.LIST<ONE>
PRINT ITEM.ID "L#30":" ":
*
IF FILE.AVAIL AND ITEM.ID.LIST[ONE,ONE] NE "*" THEN
*
READV ATTR1 FROM ITEM.FILE,ITEM.ID,ONE ELSE PROG.OK = FALSE
*
IF ITEM.ID[ONE,8] EQ "SH.SUBR." THEN
ATTR1 = "SUBROUTINE ":ITEM.ID:"(?)"
*PROG.OK = TRUE
PROG.OK = FALSE
END ELSE IF ITEM.ID[ONE,3] EQ "SH." THEN
ATTR1 = "*PROGRAM: ":ITEM.ID
PROG.OK = TRUE
END
*
$INCLUDE IBP SYS.INCL.ITEM.TYPE
*
IF RTN.TYPE = "CSEG" AND RTN.TYPE NE "DICT" AND RTN.TYPE NE "PROC" THEN PROG.OK = FALSE
*
END
*
END
*
WHILE (ITEM.ID.LIST[ONE,ONE] EQ "*" OR NOT(PROG.OK)) AND ITEM.ID.LIST NE EMPTY DO
*
DEL ITEM.ID.LIST<ONE>
*
PRINT
*
REPEAT
*
*
WHILE ITEM.ID.LIST NE EMPTY DO
*
PROC1 = PROC1:"C":AM:"O     ":ITEM.ID:AM:"C":AM
*
*PROC1 = PROC1:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" CAT OUT.":FILE.NAME:" ":ITEM.ID:"<":AM:"P":AM:"C":AM
*
IF LEN(RUN.FILE) THEN TMP = RUN.FILE ELSE TMP = FILE.NAME
PROC1 = PROC1:"HACC.UPDATE":AM:"STON":AM:"H+":ITEM.ID:"<":AM:"P":AM
*
IF RTN.TYPE EQ "DICT" THEN
*
PROC1 = PROC1:"RI":AM:"RO":AM:"IH":OPSYS:" ":FILE.NAME:" ":ITEM.ID:AM
PROC1 = PROC1:"HSYS.PROC.INSTALL ":FILE.NAME:" ":ITEM.NAME:AM:"P":AM
*
END ELSE IF RTN.TYPE EQ "PROC" THEN
*
PROC1 = PROC1:"RI":AM:"RO":AM:"IH":OPSYS:" ":FILE.NAME:" ":ITEM.ID:AM
PROC1 = PROC1:"HSYS.PROC.INSTALL ":FILE.NAME:" ":ITEM.NAME:AM:"P":AM
*
*
END ELSE
*
IF OPSYS EQ "M" AND DECAT EQ "Y" THEN
PROC1 = PROC1:"HDELETE-CATALOG ":ITEM.ID:AM:"P":AM
IF ITEM.ID[ONE,3] EQ "SH." THEN
PROC1 = PROC1:"HDELETE-CATALOG ":"SH.SUBR.":ITEM.ID[4,9999]:AM:"P":AM
PROC1 = PROC1:"HDELETE-CATALOG ":"SH.SUBR.SCR.":ITEM.ID[4,9999]:AM:"P":AM
PROC1 = PROC1:"HDELETE-CATALOG ":"SH.SUBR.LPT.":ITEM.ID[4,9999]:AM:"P":AM
END
END
*
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":ITEM.ID:AM:"P":AM
IF ITEM.ID[ONE,3] EQ "SH." THEN
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":"SH.SUBR.":ITEM.ID[4,9999]:AM:"P":AM
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":"SH.SUBR.SCR.":ITEM.ID[4,9999]:AM:"P":AM
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":"SH.SUBR.LPT.":ITEM.ID[4,9999]:AM:"P":AM
END
*
END; * OF RTN.TYPE "DICT"
*
DEL ITEM.ID.LIST<ONE>
*
PRINT
*
REPEAT
*
!
*
* PROC1 = PROC1:"C":AM:"C":AM:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" CAT ":LIST.NAME:" done!":"<":AM:"P":AM
*
BEGIN CASE
CASE OPSYS EQ "M"
PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"RTN":AM
CASE TRUE
PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"X":AM
END CASE
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".CATALOG"
WRITE PROC1 ON SYS.FILE,LIST.NAME:".CATALOG"
WRITE PROC1 ON BP.INST.FILE,LIST.NAME:".CATALOG"
*
STOP
*
END
~MDD.COM.CAT.ALL~
*PROGRAM: MDD.COM.CAT.ALL
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   08 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*               13 MAY 92  Vs 3.0
*
*
*COPYRIGHT    : (C) 1984,1985,1986,1987,1988,1989,1990,1991,1992 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
PROMPT EMPTY; CRLF = CR:LF; DOSNUM = 47; DOSLTH = ZERO; DOSITEM = EMPTY
PROC1 = EMPTY
PROG.LIST = EMPTY; SUBR.LIST = EMPTY; CSEG.LIST = EMPTY; OTHER.LIST = EMPTY
PROC.LIST = EMPTY; CODE.LIST = EMPTY; DICT.LIST = EMPTY
LIST.TYPE = "ABORT"; RTN.TYPE = "ABORT"
*
OPEN EMPTY,"MD" TO MDI.FILE ELSE STOP
OPEN EMPTY,"SYS" TO SYS.FILE ELSE STOP
OPEN EMPTY,"OUT.BP.INST" TO BP.INST.FILE ELSE STOP
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
TMP = ("000":PORT) "R#3"
READ RUN.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":TMP ELSE RUN.TYPE = "NONE"
READ RUN.FILE FROM SYS.FILE,"KBIL.":RUN.TYPE:".FILE" ELSE RUN.FILE = EMPTY
*
*
PRINT
PRINT "Enter list name in SYS: ":
INPUT LIST.NAME:
IF LIST.NAME EQ "KILL" THEN STOP
IF LIST.NAME EQ EMPTY THEN STOP
PRINT
*
PRINT "Enter file name: ":
INPUT FILE.NAME:
IF FILE.NAME EQ "KILL" THEN STOP
IF FILE.NAME EQ EMPTY THEN STOP
PRINT
FILE.AVAIL = TRUE
TMP = FILE.NAME
READ TMP1 FROM SYS.FILE,FILE.NAME THEN
FILE.NAME = TMP1<ONE>
END
*
OPEN "IN.":FILE.NAME TO ITEM.FILE ELSE FILE.AVAIL = FALSE
*
PRINT "Activate code this run (Y/N) ":
INPUT CODE.ACTIVATE:
IF CODE.ACTIVATE EQ "KILL" THEN STOP
IF CODE.ACTIVATE EQ EMPTY THEN STOP
PRINT
*
PRINT "Enter prestore: ":
INPUT PRESTORE:
IF PRESTORE EQ "KILL" THEN STOP
PRINT
*
PRINT "Decatalog first (Y/N): ":
INPUT DECAT:
IF DECAT EQ "KILL" THEN STOP
IF DECAT EQ EMPTY THEN STOP
PRINT
*
PRINT "Enter options if any in ()'s: ":
INPUT OPTS:
IF OPTS EQ "KILL" THEN STOP
IF OPTS EQ EMPTY THEN OPTS = "(M,N)"
PRINT
*
READ ITEM.ID.LIST FROM SYS.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:"O       COMPILE & CATALOG items in OUT.":FILE.NAME:" for the list ":LIST.NAME:" ":AM:"C":AM:"C":AM
PROC1 = PROC1:"C":AM:"[MD KBIL.SYSTEM]":AM:"C":AM
PROC1 = PROC1:"HDATE":AM:"P":AM:"C":AM:"HWHO":AM:"P":AM:"C":AM:"C":AM
PROC1 = PROC1:"C":AM:"C":AM:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" COM-CAT ":LIST.NAME:"<":AM:"P":AM
PROC1 = PROC1:"O       ACTIVATE MDD ":AM:"C":AM:"C":AM
IF LEN(RUN.FILE) THEN TMP = RUN.FILE ELSE TMP = FILE.NAME
PROC1 = PROC1:"HACC.UPDATE":AM:"STON":AM:"H+Compile ":TMP:"<":AM:"P":AM
*
IF CODE.ACTIVATE EQ "Y" THEN
**PROC1 = PROC1:"HGET-LIST ":LIST.NAME:AM:"STON":AM:"HED OUT.":FILE.NAME:"<":AM
PROC1 = PROC1:"HFROM-LIST SYS ":LIST.NAME:AM:"STON":AM:"HED OUT.":FILE.NAME:"<":AM
*
BEGIN CASE
*
CASE OPSYS EQ "M"
PROC1 = PROC1:"HP9 R9999:^%%MD"
PROC1 = PROC1:AM:"H"
PROC1 = PROC1:"D%%^::":CHAR(27):"F":CHAR(27)
PROC1 = PROC1:"R9999:^%%AL"
PROC1 = PROC1:AM:"H"
PROC1 = PROC1:"L%%^::":CHAR(27):"FI":CHAR(27):"P9<":AM
*
CASE TRUE
PROC1 = PROC1:"HP9 R9999:^%%MDD"
PROC1 = PROC1:"%%^::":SVM:"F":SVM
PROC1 = PROC1:"R9999:^%%ALL"
PROC1 = PROC1:"%%^::":SVM:"FI":SVM:"P9<":AM
*
END CASE
*
PROC1 = PROC1:"HPD<":AM:"HP9<":AM:"P":AM:"C":AM:"C":AM:"C":AM
*
END
*
!
*
PRINT
*
LOOP
*
LOOP
*
PROG.OK = TRUE; ATTR1 = EMPTY; RTN.TYPE = "OTHER"
*
IF ITEM.ID.LIST NE EMPTY THEN
*
ITEM.ID = ITEM.ID.LIST<ONE>
PRINT ITEM.ID "L#30":" ":
*
IF FILE.AVAIL AND ITEM.ID.LIST[ONE,ONE] NE "*" THEN
*
READV ATTR1 FROM ITEM.FILE,ITEM.ID,ONE ELSE PROG.OK = FALSE
*
IF ITEM.ID[ONE,8] EQ "SH.SUBR." THEN
ATTR1 = "SUBROUTINE ":ITEM.ID:"(?)"
* PROG.OK = TRUE
PROG.OK = FALSE
END ELSE IF ITEM.ID[ONE,3] EQ "SH." THEN
ATTR1 = "*PROGRAM: ":ITEM.ID
PROG.OK = TRUE
END
*
$INCLUDE IBP SYS.INCL.ITEM.TYPE
*
IF RTN.TYPE NE "PROG" AND RTN.TYPE = "CSEG" AND RTN.TYPE NE "PROC" THEN PROG.OK = FALSE
*
END
*
END
*
WHILE (ITEM.ID.LIST[ONE,ONE] EQ "*" OR NOT(PROG.OK)) AND ITEM.ID.LIST NE EMPTY DO
*
DEL ITEM.ID.LIST<ONE>
*
PRINT
*
REPEAT
*
*
WHILE ITEM.ID.LIST NE EMPTY DO
*
IF RTN.TYPE NE "DICT" THEN
IF PRESTORE NE "N" AND PRESTORE NE "n" THEN
PROC1 = PROC1:"C":AM:"C":AM:"HED OUT.":FILE.NAME:" ":ITEM.ID:AM:"STON":AM:"HP9 ":PRESTORE:"<":AM:"HPD<":AM:"HP9<":AM:"P":AM
END
END
*
PROC1 = PROC1:"C":AM:"O     ":ITEM.ID:AM
*
PROC1 = PROC1:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" ":ITEM.ID:"<":AM:"P":AM
*
IF LEN(RUN.FILE) THEN TMP = RUN.FILE ELSE TMP = FILE.NAME
PROC1 = PROC1:"HACC.UPDATE":AM:"STON":AM:"H+":ITEM.ID:"<":AM:"P":AM
*
*
IF RTN.TYPE EQ "DICT" THEN
*
PROC1 = PROC1:"RI":AM:"RO":AM:"IH":OPSYS:" ":FILE.NAME:" ":ITEM.ID:AM
PROC1 = PROC1:"HSYS.PROC.INSTALL ":FILE.NAME:" ":ITEM.NAME:AM:"P":AM
*
END ELSE
*
*
IF OPSYS EQ "M" AND DECAT EQ "Y" THEN
PROC1 = PROC1:"HDELETE-CATALOG ":ITEM.ID:AM:"P":AM
END
*
PROC1 = PROC1:"HBASIC OUT.":FILE.NAME:" ":ITEM.ID:" ":OPTS:AM:"P":AM
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":ITEM.ID:AM:"P":AM
*
IF ITEM.ID[ONE,3] EQ "SH." THEN
PROC1 = PROC1:"HBASIC OUT.":FILE.NAME:" ":"SH.SUBR.":ITEM.ID[4,9999]:" ":OPTS:AM:"P":AM
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":"SH.SUBR.":ITEM.ID[4,9999]:AM:"P":AM
PROC1 = PROC1:"HBASIC OUT.":FILE.NAME:" ":"SH.SUBR.SCR.":ITEM.ID[4,9999]:" ":OPTS:AM:"P":AM
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":"SH.SUBR.SCR.":ITEM.ID[4,9999]:AM:"P":AM
PROC1 = PROC1:"HBASIC OUT.":FILE.NAME:" ":"SH.SUBR.LPT.":ITEM.ID[4,9999]:" ":OPTS:AM:"P":AM
PROC1 = PROC1:"HCATALOG OUT.":FILE.NAME:" ":"SH.SUBR.LPT.":ITEM.ID[4,9999]:AM:"P":AM
END
*
END; * OF RTN.TYPE "DICT"
*
*
DEL ITEM.ID.LIST<ONE>
*
*
PRINT
*
REPEAT
*
!
*
PROC1 = PROC1:"C":AM:"C":AM:"HSYS.MSG.SEND":AM:"STON":AM:"HPROGRAMS<":AM:"H":PROC.BUFFER<ONE>:" COM-CAT ":LIST.NAME:" done.":"<":AM:"P":AM
*
BEGIN CASE
*
CASE OPSYS EQ "M"
PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"RTN":AM
*
CASE TRUE
PROC1 = PROC1:"C":AM:"C":AM:"C":AM:"X":AM
*
END CASE
*
*
WRITE PROC1 ON MDI.FILE,LIST.NAME:".COMPILE"
WRITE PROC1 ON SYS.FILE,LIST.NAME:".COMPILE"
WRITE PROC1 ON BP.INST.FILE,LIST.NAME:".COMPILE"
*
STOP
*
END
~MDD.DICT.COPY~
*PROGRAM: MDD.DICT.COPY
*
*
*AUTHOR: DAVID HORSMAN
*
* McDonnell Douglas only
*
* PROGRAM WRITE A PROC OF THE FOLLOWING FORMAT:
*
*        C
*        C fname
*        C
*        HSET-FILE account.name fname
*        PP
*        C
*        HCOPY DICT QFILE * (O)
*        STON
*        H(DICT filenameprefix+fname
*        PP
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PRINT
PRINT "ENTER BP FILE NAME (BP.UTL): ":; INPUT BP.FILE.NAME
IF BP.FILE.NAME EQ "" THEN BP.FILE.NAME = "BP.UTL"
*
PRINT "ENTER LIST NAME IN MD (FILES): ":; INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "FILES"
*
PRINT
PRINT "ENTER PROC NAME (DICTCOPYALLF): ":; INPUT PROC.NAME
IF PROC.NAME EQ "" THEN PROC.NAME = "DICTCOPYALLF"
*
PRINT
PRINT "ENTER ACCOUNT TO COPY FROM (PROGRAMS): ":; INPUT ACCOUNT.NAME
IF ACCOUNT.NAME EQ "" THEN ACCOUNT.NAME = "PROGRAMS"
*
FILE.NAME.PREFIX = ACCT:"."
PRINT "ENTER FILE NAME PREFIX (":FILE.NAME.PREFIX:", NONE for blank)": ":; INPUT FILE.NAME.PREFIX
IF FILE.NAME.PREFIX EQ "" THEN FILE.NAME.PREFIX = ACCT:"."
IF FILE.NAME.PREFIX EQ "NONE" THEN FILE.NAME.PREFIX = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "",BP.FILE.NAME TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM:"C":AM:"C ":PROC.NAME:" ":ACCT:" ":FILE.NAME.PREFIX:AM:"C":AM:"C ":OCONV(DATE(),"D2"):AM:"C":AM
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
*FNAME = FIELD(FILE.LIST<1>," ",3)
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF FILE.NAME[1,1] NE "*" THEN
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'C':AM:'C  ':FNAME:AM:'C':AM:'HSET-FILE ':ACCOUNT.NAME:' ':FNAME:AM:'PP':AM
PROC1 = PROC1:'HCOPY DICT QFILE * (O)':AM:'STON':AM
PROC1 = PROC1:'H(DICT ':FILE.NAME.PREFIX:FNAME:'<':AM:'PP':AM
END
END
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'RTN':AM
*
WRITE PROC1 ON MDI.FILE,PROC.NAME
WRITE PROC1 ON BP.FILE,PROC.NAME
*
STOP
END
*
~MDD.FILES~
MACRO.UTILS.INT
BP.INT
BP.UTL.INT
BP.CONV.INT
BP.INST.INT
~MDD.FROM.TAPE.PROCWRITE~
*PROGRAM: MDD.FROM.TAPE.PROCWRITE
*
$INCLUDE IBP STANDARD.FUNCTIONS
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PROC2 = ""
PROC3 = ""
PROC4 = ""
*
OPEN "","MD" TO MD.FILE ELSE STOP
OPEN "","PL" TO PL.FILE ELSE STOP
*
PRINT
PRINT "Enter the name of the list to use (EXPORT.FILES): ":
INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "EXPORT.FILES"
*
PRINT
PRINT "Enter the file name that contains the list (LISTS): ":
INPUT FILE.NAME
IF FILE.NAME EQ "" THEN FILE.NAME = "LISTS"
*
PRINT
PRINT "Clear destination files before loading? (Y/<cr>): ":
INPUT CLEAR.DEST.FLAG
IF CLEAR.DEST.FLAG NE "Y" THEN CLEAR.DEST.FLAG = "" ELSE CLEAR.DEST.FLAG = 1
*
PRINT
PRINT "Activate T-FWD commands in procs? (Y/<cr>): ":
INPUT TFWD.FLAG
IF TFWD.FLAG EQ "Y" THEN
TFWD.FLAG = 1
*PRINT
PRINT "Dicts too? (<cr>/N): ":
INPUT TFWD.DICT.FLAG
IF TFWD.DICT.FLAG EQ "N" THEN TFWD.DICT.FLAG = "" ELSE TFWD.DICT.FLAG = 1
END ELSE TFWD.FLAG = FALSE; TFWD.DICT.FLAG = FALSE
*
PRINT
PRINT "Enter proc names prefix (blank): ":
INPUT PROC.NAME.PREFIX
IF PROC.NAME.PREFIX[LEN(PROC.NAME.PREFIX),1] NE '.' AND LEN(PROC.NAME.PREFIX) THEN PROC.NAME.PREFIX = PROC.NAME.PREFIX:"."
*
PRINT
PRINT "Use the suppress item names option on data areas (Y/N)? ":
INPUT S.OPTION.FLAG
IF S.OPTION.FLAG EQ "Y" THEN S.OPTION.FLAG = 1 ELSE S.OPTION.FLAG = ""
*
OPEN "","MACRO.UTILS" TO BP.FILE ELSE STOP
OPEN "",FILE.NAME TO LST.FILE ELSE STOP
READ FILE.LIST FROM LST.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-ATT 8192':AM:'PP':AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-LOAD MD (O)':AM:'PP':AM:'C':AM
PROC1 = PROC1:'C':AM:'C':AM:'HT-LOAD ':FILE.NAME:' (O)':AM:'PP':AM:'C':AM
PROC2 = "PQN":AM
PROC3 = "PQN":AM
PROC3 = PROC3:'C':AM:'C':AM:'HT-ATT 8192':AM:'PP':AM
PROC3 = PROC3:'C':AM:'C':AM:'HSELECT MD "':PROC.NAME.PREFIX:'TLOADALLF" "':PROC.NAME.PREFIX:'LISTALLF" "':PROC.NAME.PREFIX:'TDUMPALLF" "':PROC.NAME.PREFIX:'TCREALLF.MIN"':AM:'STON':AM:'HT-DUMP MD<':AM:'PP':AM:'C':AM
PROC3 = PROC3:'C':AM:'C':AM:'HSELECT ':FILE.NAME:' "':LIST.NAME:'"':AM:'STON':AM:'HT-DUMP ':FILE.NAME:'<':AM:'PP':AM:'C':AM
PROC4 = "PQN":AM
*
*FILE.LIST = DELETE(FILE.LIST,1,0,0)
CN = 0
*
LOOP
*
FNAME = FILE.LIST<1>
CN = CN + 1
*
IF FNAME[1,1] NE "*" THEN
*
IF FNAME[1,5] EQ "DICT " OR FNAME[1,5] EQ "DICT." THEN
FDICT = "DICT"
FNAME = TRIM(FNAME)
FNAME = FIELD(FNAME," ",2)
DATA.FLAG = ""
END ELSE
FDICT = ""
DATA.FLAG = 1
END
*
END
*
WHILE FILE.LIST NE "" DO
*
IF FILE.NAME[1,1] NE "*" THEN
*
DMOD = '37,1'
PROC1 = PROC1:'C':AM:'C    ':OCONV(DATE(),"D2"):AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM:'C@HT-FWD 1':AM:'C@PP':AM
PROC2 = PROC2:'C':AM:'C    ':OCONV(DATE(),"D2"):AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
PROC3 = PROC3:'C':AM:'C    ':OCONV(DATE(),"D2"):AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
PROC4 = PROC4:'C':AM:'C    ':OCONV(DATE(),"D2"):AM:'C':AM:'C   ':ACCT:' ':FNAME:AM:'C':AM
*
IF INDEX(FNAME,"BP",1) OR INDEX(FNAME,"MACRO",1) THEN BP.FLAG = 1 ELSE BP.FLAG = ""
IF INDEX(FNAME,"MODEL",1) THEN MODEL.FLAG = 1 ELSE MODEL.FLAG = ""
IF INDEX(FNAME,"PL",1) THEN PL.FLAG = 1 ELSE PL.FLAG = ""
IF INDEX(FNAME,"MENUS",1) OR INDEX(FNAME,"SYS",1) OR INDEX(FNAME,"HLP",1) THEN SYS.FLAG = 1 ELSE SYS.FLAG = ""
DICT.FLAG = 1
IF INDEX(FNAME,"MD",1) OR INDEX(FNAME,"SYSTEM",1) OR INDEX(FNAME,"ACC",1) THEN DICT.FLAG = ""; SYS.FLAG = 1
*
IF DICT.FLAG THEN
IF CLEAR.DEST.FLAG AND NOT(SYS.FLAG) THEN
PROC1 = PROC1:'C':AM:'HCLEAR-FILE DICT ':FNAME:AM:'PP':AM
END
IF TFWD.DICT.FLAG THEN
PROC1 = PROC1:'C':AM:'HT-FWD 1':AM:'PP':AM
END ELSE
PROC1 = PROC1:'C':AM:'CHT-FWD 1':AM:'CPP':AM
END
PROC1 = PROC1:'C':AM:'HT-LOAD DICT ':FNAME:' (O)':AM:'PP':AM
IF BP.FLAG THEN
PROC3 = PROC3:'C':AM:'HSSELECT DICT ':FNAME:' USING MD WITH *A1 EQ "A" "X" "S"':AM:'STON':AM
PROC3 = PROC3:'HT-DUMP DICT ':FNAME:'<':AM:'PP':AM
END ELSE
PROC3 = PROC3:'C':AM:'HS-DUMP DICT ':FNAME:AM:'PP':AM
END
PROC4 = PROC4:'C':AM:'HSORT ONLY DICT ':FNAME:' (P)':AM:'PP':AM
PROC4 = PROC4:'C':AM:'HLISTDICT ':FNAME:' (P)':AM:'PP':AM
END
*
IF NOT(DATA.FLAG) THEN
PROC2 = PROC2:'C':AM:'HCREATE-FILE (DICT ':FNAME:' 19,1 )':AM:'PP':AM:'C':AM
END ELSE
DMOD = '103,1'
END
*
IF DATA.FLAG THEN
IF CLEAR.DEST.FLAG AND NOT(SYS.FLAG) THEN
* IF DICT.FLAG THEN
* PROC1 = PROC1:'C':AM:'HCLEAR-FILE DICT ':FNAME:AM:'PP':AM
* END
PROC1 = PROC1:'C':AM:'HCLEAR-FILE DATA ':FNAME:AM:'PP':AM
END
IF TFWD.FLAG THEN
PROC1 = PROC1:'C':AM:'HT-FWD 1':AM:'PP':AM
END ELSE
PROC1 = PROC1:'C':AM:'CHT-FWD 1':AM:'CPP':AM
END
PROC1 = PROC1:'C':AM:'HT-LOAD ':FNAME:' (O'
IF S.OPTION.FLAG THEN PROC1 = PROC1:',S'
PROC1 = PROC1:')':AM:'PP':AM:'C':AM:'C':AM
PROC2 = PROC2:'C':AM:'HCREATE-FILE (':FNAME:' 19,1 ':DMOD:')':AM:'PP':AM:'C':AM
IF BP.FLAG THEN
PROC3 = PROC3:'C':AM:'HSSELECT ':FNAME:' NE "*]"':AM:'STON':AM
PROC3 = PROC3:'HSELECT ':FNAME:' NE "$]"<':AM
PROC3 = PROC3:'HT-DUMP ':FNAME:'<':AM:'PP':AM:'C':AM:'C':AM
END ELSE
PROC3 = PROC3:'C':AM:'HS-DUMP ':FNAME:AM:'PP':AM:'C':AM:'C':AM
END
PROC4 = PROC4:'C':AM:'HSORT ONLY ':FNAME:' (P)':AM:'PP':AM:'C':AM:'C':AM
END
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
*
END; *# OF FNAME[1,1] NE "*"
*
PRINT
PRINT CN "R#3":") ":FDICT:" ":FNAME
*
REPEAT
*
BEGIN CASE
CASE OPSYS EQ 'M'
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC3 = PROC3:'C':AM:'C':AM:'C':AM:'RTN':AM
PROC4 = PROC4:'C':AM:'C':AM:'C':AM:'RTN':AM
CASE 1
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'C@X':AM:'RTN':AM
PROC2 = PROC2:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
PROC3 = PROC3:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
PROC4 = PROC4:'C':AM:'C':AM:'C':AM:'X':AM:'C@RTN':AM
END CASE
*
WRITE PROC1 ON MD.FILE,PROC.NAME.PREFIX:"TLOADALLF"
WRITE PROC1 ON BP.FILE,PROC.NAME.PREFIX:"TLOADALLF"
WRITE PROC1 ON PL.FILE,PROC.NAME.PREFIX:"TLOADALLF"
WRITE PROC2 ON MD.FILE,PROC.NAME.PREFIX:"TCREALLF.MIN"
WRITE PROC2 ON BP.FILE,PROC.NAME.PREFIX:"TCREALLF.MIN"
WRITE PROC2 ON PL.FILE,PROC.NAME.PREFIX:"TCREALLF.MIN"
WRITE PROC3 ON MD.FILE,PROC.NAME.PREFIX:"TDUMPALLF"
WRITE PROC3 ON BP.FILE,PROC.NAME.PREFIX:"TDUMPALLF"
WRITE PROC3 ON PL.FILE,PROC.NAME.PREFIX:"TDUMPALLF"
WRITE PROC4 ON MD.FILE,PROC.NAME.PREFIX:"LISTALLF"
WRITE PROC4 ON BP.FILE,PROC.NAME.PREFIX:"LISTALLF"
WRITE PROC4 ON PL.FILE,PROC.NAME.PREFIX:"LISTALLF"
*
STOP
END
*
~MDD.OLD~
A
A
PKHARMONY.PROGRAMS
DCOUNT}ECHO ON}ECHO OFF}READ}OPEN}LOCATE}LOCATE
N=(}}}FLELSE}FLELSE}FLELSE}}
.|=|DCOUNT(|,|)}}}}}}LOCATE(|,|,|;|;|)|THEN|ELSE}
'*%%STD%%*STDv'A|LA|'*%%MDO%%'P001" = COUNT("P003","P004")"P005|A|'*%%MDO%%'"IF "P003' EQ "" THEN NULL ELSE 'P001' = 'P001' + 1'}'*%%STD%%*STDv'A|LA|'*%%MDD%%ECHOT=OCONV(0,"U70E0")'}'*%%STD%%*STDv'A|LA|'*%%MDD%%ECHOT=OCONV(0,"U80E0")'}'*%%STD%%*STDv'A|LA|'*%%MDO%%RTEMP = TRUE'A|'*%%%MDO%%'L' RTEMP = FALSE'A|'*%%MDO%%IF NOT(RTEMP) THEN '}'*%%STD%%*STDv'A|LA|'*%%MDO%%OTEMP = TRUE'A|'*%%%MDO%%'L' OTEMP = FALSE'A|'*%%MDO%%IF NOT(OTEMP) THEN '}'*%%STD%%*STDv'ALA'*%%MDO%%LOCTEMP = TRUE'A'*%%%MDO%%'L' LOCTEMP = F
ALSE'A'*%%MDO%%IF NOT(LOCTEMP) THEN '}'*%%STD%%*STDv'A|LA|'*%%MDO%%LOCATE 'P001' IN 'P002'<'P003|C003','P003|'>,1 '|C004' BY 'P005' SETTING 'P004' '|N004' SETTING 'P005' '|C007'THEN 'P007' '|C008'ELSE 'P008|N008' ELSE '|C009' 'P009}
~MDD.OLD.1~
A
A
PKHARMONY.PROGRAMS
ABORT}DCOUNT}ECHO ON}ECHO OFF}READ}OPEN}LOCATE}READ}OPEN}LOCATE}LOCATE
}N=(}}}FLELSE}FLELSE}FLELSE}FLTHEN}FLTHEN}FLTHEN}}
.|ABORT}.|=|DCOUNT(|,|)}}}}}}}}}LOCATE(|,|,|;|;|)|THEN|ELSE}
P001'STOP'P002}P001" = COUNT("P003","P004")"P005|A|"IF "P003' EQ "" THEN NULL ELSE 'P001' = 'P001' + 1'}'ECHOT=OCONV(0,"U70E0")'}'ECHOT=OCONV(0,"U80E0")'}'RTEMP = TRUE'A|L' RTEMP = FALSE'A|'IF NOT(RTEMP) THEN '}'OTEMP = TRUE'A|L' OTEMP = FALSE'A|'IF NOT(OTEMP) THEN '}'LOCTEMP = TRUE'AL' LOCTEMP = FALSE'A'IF NOT(LOCTEMP) THEN '}'RTEMP = TRUE'A|L' NULL ELSE RTEMP = FALSE'A|'IF RTEMP THEN '}'OTEMP = TRUE'A|L' NULL ELSE OTEMP = FALSE'A|'IF OTEMP THEN '}'LOCTEMP = TRUE'AL' NULL ELSE LOCTEMP = FALSE'A'IF LOCTEMP
 THEN '}'LOCATE 'P001' IN 'P002'<'P003|C003','P003|'>,1 '|C004' BY 'P005' SETTING 'P004' '|N004' SETTING 'P005' '|C007'THEN 'P007' '|C008'ELSE 'P008|N008' ELSE '|C009' 'P009}
PKHARMONY
MDD.OUT.1
0
1
STD
MDD
EQ
0
0
~MDD.QPT.WRITE~
*PROGRAM: MDD.QPT.WRITE
*
*
*AUTHOR: DAVID HORSMAN
*
* McDonnell Douglas only
*
* PROGRAM WRITES A PROC THAT EDITS MD FILE ENTRY DL/ID AND POINTS BACK
*   INTO THE ACCOUNT AT accountname.filename FOR THE DATA AREA
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PRINT
PRINT "ENTER BP FILE NAME (BP.UTL): ":; INPUT BP.FILE.NAME
IF BP.FILE.NAME EQ "" THEN BP.FILE.NAME = "BP.UTL"
*
PRINT "ENTER LIST NAME IN MD (FILES): ":; INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "FILES"
*
PRINT
PRINT "ENTER PROC NAME (QPNTALLF): ":; INPUT PROC.NAME
IF PROC.NAME EQ "" THEN PROC.NAME = "QPNTALLF"
*
PRINT
PRINT "ENTER ACCOUNT TO POINT AT (PROGRAMS): ":; INPUT ACCOUNT.NAME
IF ACCOUNT.NAME EQ "" THEN ACCOUNT.NAME = "PROGRAMS"
*
FILE.NAME.PREFIX = ACCT:"."
PRINT "ENTER FILE NAME PREFIX (":FILE.NAME.PREFIX:", NONE for blank)": ":; INPUT FILE.NAME.PREFIX
IF FILE.NAME.PREFIX EQ "" THEN FILE.NAME.PREFIX = ACCT:"."
IF FILE.NAME.PREFIX EQ "NONE" THEN FILE.NAME.PREFIX = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "",BP.FILE.NAME TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM:"C":AM:"C ":PROC.NAME:" ":ACCT:" ":FILE.NAME.PREFIX:AM:"C":AM:"C ":OCONV(DATE(),"D2"):AM:"C":AM
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
*FNAME = FIELD(FILE.LIST<1>," ",3)
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF FILE.NAME[1,1] NE "*" THEN
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HED DICT ':FNAME:' ':"DL/ID":AM:'HSTON':AM
PROC1 = PROC1:'HDE999<':AM:'HF<':AM
PROC1 = PROC1:'HI<':AM:'HQ<':AM:'H':ACCOUNT.NAME:'<':AM:'H':FILE.NAME.PREFIX:FNAME:'<':AM:'H<':AM:'HFI<':AM:'PP':AM
END
END
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,PROC.NAME
WRITE PROC1 ON BP.FILE,PROC.NAME
*
STOP
END
*
~NO-OP~
PQN
O
O
O NO ADDITIONAL OPERATION TO BE DONE
O
O
RTN
~QFILE~
Q
PROGRAMS
~REMOTE.ENTRY~
PQN
CSTOFF
C
C
HSET.REMOTE
P
C
IF A2 = "ABORT" GO 999
O
[DH.PL REMOTE.START]
C
IF A2 = "ABORT" X PROGRAM ABORTED
C
X
C
C
999 C
X PROGRAM ABORTED
~SEARCH~
*PROGRAM: SEARCH
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   01 AUG 84
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT: (C) 1984,85,86,87,88,89,90,91,92 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SCR.HDR.VAR.EQUATES
*
*
EQU EOS TO CHAR(12)
PHANTOM.FLAG = FALSE; FIRST = TRUE; DONE = FALSE; CONT = FALSE
FIRST.TRY = FALSE; COMMN.FLAG = EMPTY; FOUND = FALSE; PR.FOUND = FALSE
LBL.CN = ZERO; LBL.CN.MAX = ZERO; IN.LBLS = EMPTY; OUT.LBLS = EMPTY
FOUND = FALSE; LIST = EMPTY; LIST.CN = EMPTY
LINE = EMPTY; ORIG.LINE = EMPTY; FLIN = EMPTY; FLIN.CN = ZERO
ITEM.ID = EMPTY; FTXT = EMPTY; FTXT.CN.MAX = EMPTY; FTXT.CN = ZERO
AM.TC.CN = ZERO; THIS = EMPTY; ATTRONE = EMPTY
*
LPTR.FL = FALSE; LPTR.FL.SAVE = TWO; LN.CN = ZERO; LN.CN.MAX = 60
FIRST.PG = TRUE; FIRST.PG.TERM = TRUE
LN.CN.TERM = ZERO; LN.CN.MAX.TERM = 20
CL.CN.MAX = 130; CL.CN.MAX.TERM = 78
PG.CN = ZERO; PG.CN.TERM = ZERO
NOPAGE.FL = TRUE; FAST.FL = TRUE; FAST.FF = FALSE
CONT.RSP = EMPTY; STAT = FALSE; LIST.EMPTY = TRUE
*
EXEC.VERB = EMPTY; EXEC.VERB1 = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
TITLE = "Macroscope Design Maxtrix Search Utility"
TITLE1 = EMPTY
*
ITEM.TYPE = EMPTY; OLD.ITEM.TYPE = EMPTY; VALID.ITEM.TYPE = EMPTY
FINDS = EMPTY; VPARAMS = EMPTY; EPARAMS = EMPTY; IPARAMS = EMPTY
LIST.NAME = EMPTY; FILE.ID = EMPTY; OUT.FILE.ID = EMPTY
IN.CODE.TYPE = EMPTY; OUT.CODE.TYPE = EMPTY; CODE.VER = EMPTY
NULLS.FLAG = EMPTY; REM.FLAG = EMPTY; EXISTING.FLAG = EMPTY
USE.TBL.FLAG = EMPTY; ITEM.CLL = EMPTY; SYS.ITEM = EMPTY
STD.FLAG = EMPTY
OPSYS.TYPE = "MDD"; CODE.CHAR = "*"
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
!
*
PRINT "Enter your user name: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
USER.NAME = RSP
IF USER.NAME EQ EMPTY THEN USER.NAME = "???"
*
!
*
PRINT "Enter the RUN REFERENCE name (to save these parameters): ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
SYS.RUN.NAME = RSP
IF SYS.RUN.NAME EQ EMPTY THEN SYS.RUN.NAME = USER.NAME:"#":ACCT:"#":PORT
*
!
*
FINDS=EMPTY
CN = ZERO
LOOP
CN = CN + ONE
PRINT "ENTER STRING TO SEARCH FOR (RET WHEN DONE) ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
UNTIL RSP EQ EMPTY OR RSP[ONE,ONE] EQ "@" DO
FINDS<ONE,-ONE> = RSP
PRINT "[=| STRING ":CN:" IS: ":RSP
CN = CN + ONE
REPEAT
*
!
*
OPEN "SYS" TO SYS.FILE ELSE PRINT BELL:"SYS MISSSING!"; STOP
OPEN "MD"  TO MD.FILE  ELSE PRINT BELL:"MD MISSING!"; STOP
OPEN "SCR"  TO SCR.FILE  ELSE PRINT BELL:"SCR MISSING!"; STOP
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
! Search item should be read from disk @????????
*
RUN.TYPE = ONE; SEARCH.ID = "none"
IF RSP[ONE,ONE] EQ "@" THEN
RUN.TYPE = TWO
*SYS.FILE = "SYS"
SYS.ITEM = RSP[TWO,9999]
IF SYS.RUN.NAME EQ EMPTY THEN
SYS.RUN.NAME = FIELD(SYS.ITEM," ",TWO)
IF SYS.RUN.NAME EQ EMPTY THEN SYS.RUN.NAME = USER.NAME:"#":ACCT:"#":PORT
END
SYS.ITEM = FIELD(SYS.ITEM," ",ONE)
SEARCH.ID = SYS.ITEM
SEARCH.ID.OUT = SYS.RUN.NAME
*
READ PROCESS.REC FROM SYS.FILE,"@S@RSP@":SYS.ITEM ELSE
PRINT "[=| "
PRINT "[=| ITEM @S@RSP@":SYS.ITEM:" was not found..."
PRINT "[=| "
*
READ PROCESS.REC FROM SYS.FILE,SYS.ITEM THEN
IF TERM.DISP THEN
PRINT "[=| "
PRINT "[=| ITEM ":SYS.ITEM:" was found and will be used... "
PRINT "[=| "
END
*
END ELSE
PRINT BELL:"[=| ITEM MISSING!"; STOP
END; * of read
*
END; * of read
*
*
LIST.NAME      = PROCESS.REC<3>  ;* PROMPT 6
FINDS          = PROCESS.REC<4>  ;* PROMPT 1
VPARAMS        = PROCESS.REC<5>
EPARAMS        = PROCESS.REC<6>
IPARAMS        = PROCESS.REC<7>
FILE.ID       = PROCESS.REC<8>  ;* PROMPT 4
OUT.FILE.ID   = PROCESS.REC<9>  ;* PROMPT 5
PHANTOM.FLAG   = PROCESS.REC<10> ;* (0/1) * PROMPT 2
LPTR.FL.SAVE   = PROCESS.REC<11> ;* (0,1) * PROMPT 3
*  VERSION CONTROL PARAMETERS *
IN.CODE.TYPE   = PROCESS.REC<12> ;* (*%%^^^%%^)
OUT.CODE.TYPE  = PROCESS.REC<13> ;* (*%%^^^%%^)
NULLS.FLAG     = PROCESS.REC<14> ;* (EQ/NE/NO)
REM.FLAG       = PROCESS.REC<15> ;* (0/1)
EXISTING.FLAG  = PROCESS.REC<16> ;* (0/1)
*  REPETATIVE RUN OPTIMIZER TABLES *
USE.TBL.FLAG   = PROCESS.REC<17> ;* (0 or EMPTY / 1)
*  ITEM LEVEL PROCESSING
ITEM.CLL       = PROCESS.REC<18> ;* (XXX---XXX)
SYS.ITEM       = SYS.RUN.NAME
*  OUTPUT *%%STD%%= LINES
STD.FLAG       = PROCESS.REC<20> ;* (0/1)
VALID.ITEM.TYPE= PROCESS.REC<21> ;* (*XXX---XXX*XXX---XXX*XXX---XXX*)
WRITE PROCESS.REC ON SYS.FILE,"@S@RSP@":FILE.ID:"@":SYS.ITEM
**
*
END ELSE
*
! Search item is not being read from disk
*
PRINT "[=| Run in PHANTOM mode? ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
IF INDEX("*Y*y*YES*yes*ok*OK*","*":RSP:"*",ONE) NE ZERO THEN PHANTOM.FLAG = TRUE
IF PHANTOM.FLAG THEN TERM.DISP = FALSE
**
*
LPTR.FL.SAVE = FALSE
PRINT "[=| Print on the PRINTER? ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
IF INDEX("*YES*Y*y*yes*ok*OK*","*":RSP:"*",ONE) THEN
LPTR.FL.SAVE = TWO
END ELSE
LPTR.FL.SAVE = ONE
END
**
*
10 PRINT "[=| Enter the INPUT FILE to be processed: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
FILE.ID = RSP
**
*
11 PRINT "[=| Enter the OUTPUT FILE to place the results in: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
OUT.FILE.ID = RSP
**
*
12 PRINT "[=| LISTs may be entered in the following formats:"
   PRINT "[=| "
   PRINT "[=|      List_Name"
   PRINT "[=|      .TCL_Statement"
   PRINT "[=|      @File_Name Item_ID"
   PRINT "[=| "
   PRINT "[=| Enter the LIST NAME of the items to be processed: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
LIST.NAME = RSP
**
*
13 PRINT "[=| Enter the ITEM LEVEL conversion call: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
ITEM.CLL = RSP
**
*
VPARAMS = EMPTY
EPARAMS = EMPTY
IPARAMS = EMPTY
IN.CODE.TYPE = "???"
OUT.CODE.TYPE = "???"
NULLS.FLAG    = EMPTY
EXISTING.FLAG = EMPTY
REM.FLAG      = EMPTY
USE.TBL.FLAG  = EMPTY
STD.FLAG      = ONE
*
**
14 PRINT "[=| Enter the VALID ITEM TYPEs separated by *'s: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
VALID.ITEM.TYPE = RSP
IF VALID.ITEM.TYPE EQ EMPTY THEN
*   VALID.ITEM.TYPE = "*PROGRAM*SUBROUTINE*CODE.SEGMENT*"
VALID.ITEM.TYPE = "*PROGRAM*SUBROUTINE*CODE.SEGMENT*PROC*"
END ELSE IF VALID.ITEM.TYPE NE "ALL" THEN
VALID.ITEM.TYPE = "*":VALID.ITEM.TYPE:"*"
END
**
*
PROCESS.REC = EMPTY
*ROCESS.REC<ZERO>  = SYS.RUN.NAME ;* PROMPT -1
PROCESS.REC<ONE>  = DATE()
PROCESS.REC<TWO>  = USER.NAME ;* PROMPT -2
PROCESS.REC<3>  = LIST.NAME  ;* PROMPT 6
PROCESS.REC<4>  = FINDS  ;* PROMPT 1
PROCESS.REC<5>  = VPARAMS
PROCESS.REC<6>  = EPARAMS
PROCESS.REC<7>  = IPARAMS
PROCESS.REC<8>  = FILE.ID  ;* PROMPT 4
PROCESS.REC<9>  = OUT.FILE.ID  ;* PROMPT 5
PROCESS.REC<10> = PHANTOM.FLAG ;* (0/1) * PROMPT 2
PROCESS.REC<11> = LPTR.FL.SAVE ;* (0,1) * PROMPT 3
*  VERSION CONTROL PARAMETERS *
PROCESS.REC<12> = IN.CODE.TYPE ;* (*%%^^^%%^)
IF OUT.CODE.TYPE EQ EMPTY THEN OUT.CODE = CODE.CHAR:"%%ALL%%="
PROCESS.REC<13> = OUT.CODE.TYPE ;* (*%%^^^%%^)
PROCESS.REC<14> = NULLS.FLAG ;* (EQ/NE/NO)
PROCESS.REC<15> = REM.FLAG ;* (0/1)
PROCESS.REC<16> = EXISTING.FLAG ;* (0/1)
*  REPETATIVE RUN OPTIMIZER TABLES *
PROCESS.REC<17> = USE.TBL.FLAG ;* (0 or EMPTY / 1)
*  ITEM LEVEL PROCESSING
PROCESS.REC<18> = ITEM.CLL ;* (XXX---XXX)
SYS.ITEM        = SYS.RUN.NAME
PROCESS.REC<19> = SYS.RUN.NAME
PROCESS.REC<20> = STD.FLAG
PROCESS.REC<21> = VALID.ITEM.TYPE
*
WRITE PROCESS.REC ON SYS.FILE,"@S@RSP@":FILE.ID:"@":SYS.ITEM
*
END; * of search item read or input
*
!! Start of Program
*
TITLE1 = "Run:":SYS.RUN.NAME:" List:":LIST.NAME:" In:":FILE.ID:" Out:":OUT.FILE.ID
*
! Open files
*
READ MD.ITEM FROM MD.FILE,FILE.ID ELSE MD.ITEM = AM:AM:"BP"
TRUE.FILE.ID = MD.ITEM<3>
TMP = FIELD(TRUE.FILE.ID,".",1)
IF TMP EQ "IN" OR TMP EQ "OUT" OR TMP EQ "OLD" THEN
TRUE.FILE.ID = TRUE.FILE.ID[COL2()+1,99999]
END
OUT.FILE.ID = "OUT.":TRUE.FILE.ID
IN.FILE.ID = "IN.":TRUE.FILE.ID
OLD.FILE.ID = "OLD.":TRUE.FILE.ID
*
OPEN "",FILE.ID TO IN.FILE ELSE PRINT "CAN'T OPEN ":FILE.ID; STOP
*
IF OUT.FILE.ID EQ "END" OR OUT.FILE.ID EQ CHAR(27) OR OUT.FILE.ID EQ CHAR(251) THEN STOP
IF OUT.FILE.ID NE EMPTY THEN
OPEN "",OUT.FILE.ID TO OUT.FILE ELSE PRINT "CAN'T OPEN ":OUT.FILE.ID;STOP
END ELSE TERM.DISP = TRUE
*
OPEN "","LISTS" TO LISTS.FILE ELSE PRINT "[=| CAN'T OPEN LISTS"; STOP
*
! Print paramaeters
*
LPTR.FL = FALSE
*
FOR LPTR.CN = ONE TO LPTR.FL.SAVE; *# PRINTER WS
*
IF (LPTR.CN EQ ONE AND TERM.DISP) OR (LPTR.CN EQ TWO AND LPTR.FL) THEN
IF LPTR.CN EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE
*
*
LN.DISP = STR("*",70); GOSUB DISP.LINE
LN.DISP = "[=| Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILE.ID; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| Acct....":ACCT:"   Port....":PORT; GOSUB DISP.LINE
LN.DISP = "[=|"; GOSUB DISP.LINE
LN.DISP = "[=| User.name.....":USER.NAME; GOSUB DISP.LINE
LN.DISP = "[=| Run.reference.":SYS.RUN.NAME; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
*
FTXT.CN.MAX = DCOUNT(FINDS,VM)
IF FTXT.CN.MAX THEN
FOR FTXT.CN = ONE TO FTXT.CN.MAX
LN.DISP = "[=| ":CN "R#2":")  F: ":FINDS<ONE,FTXT.CN>; GOSUB DISP.LINE
LN.DISP = "[=| ":"Verify: ":VPARAMS<ONE,FTXT.CN>; GOSUB DISP.LINE
LN.DISP = "[=| ":"Extrct: ":EPARAMS<ONE,FTXT.CN>; GOSUB DISP.LINE
LN.DISP = "[=| ":"Output: ":IPARAMS<ONE,FTXT.CN>; GOSUB DISP.LINE
NEXT FTXT.CN
END ELSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| No strings to search for, continuing..."; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
END
*
! Print run parameters
*
LN.DISP = "[=| ":STR("_",70); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILE.ID; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"Run type: ":FIELD("Variable*Fixed","*",RUN.TYPE); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"Item: ":SEARCH.ID; GOSUB DISP.LINE
LN.DISP = "[=| ":"List: ":LIST.NAME; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":" Input code type: ":IN.CODE.TYPE; GOSUB DISP.LINE
LN.DISP = "[=| ":"Output code type: ":OUT.CODE.TYPE; GOSUB DISP.LINE
LN.DISP = "[=| ":"   Process nulls: ":NULLS.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":"Existing code in: ":EXISTING.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":" Process remarks: ":REM.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":"Use prior tables: ":USE.TBL.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":" Item level call: ":ITEM.CLL; GOSUB DISP.LINE
LN.DISP = "[=| ":"  Output STD's  : ":STD.FLAG; GOSUB DISP.LINE
LN.DISP = "[=| ":"Valid item types: ":VALID.ITEM.TYPE; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("_",70); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
END; * TERM.DISP
*
IF LPTR.CN EQ TWO THEN LPTR.FL = FALSE
*
NEXT LPTR.CN
*
!! Retrieve List
*
LIST = EMPTY
LIST.CN = ONE
FLIN = EMPTY
FTXT = EMPTY
IF LIST.NAME NE EMPTY THEN
IF LIST.NAME[ONE,ONE] EQ "." THEN
EXEC.VERB1 = LIST.NAME[TWO,9999]
END ELSE IF LIST.NAME[ONE,ONE] EQ "@" THEN
EXEC.VERB1 = "FORM-LIST ":LIST.NAME[TWO,9999]
END ELSE
EXEC.VERB1 = "GET-LIST ":LIST.NAME
END
EXEC.OUT = EMPTY
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB1; GOSUB DISP.LINE
END
*
BEGIN CASE
*
CASE OPSYS EQ "M"
EXEC.OUT = EMPTY
EXECUTE EXEC.VERB1, //SELECT. > ITEM.ID.LIST, //OUT. > EXEC.OUT
*
IF TERM.DISP THEN PRINT EXEC.OUT
*
CASE TRUE
READ ITEM.ID.LIST FROM SYS.FILE,LIST.NAME ELSE ITEM.ID.LIST = EMPTY
*
END CASE
*
END
*
FIRST = ONE
IF NOT(FIRST) THEN
IF LIST.NAME EQ EMPTY AND FILE.ID NE EMPTY THEN
EXEC.VERB = "GET-LIST ":FILE.ID
EXEC.OUT = EMPTY
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB; GOSUB DISP.LINE
END
*
READNEXT ITEM.ID FROM ITEM.ID.LIST ELSE
EXEC.PARAM = "SAVE-LIST ":FILE.ID
EXEC.VERB = "SSELECT ":FILE.ID
EXEC.OUT = EMPTY
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB; GOSUB DISP.LINE
LN.DISP = "[=| ":">":EXEC.PARAM; GOSUB DISP.LINE
END
*
EXECUTE EXEC.VERB, //IN. < EXEC.PARAM, //OUT. > EXEC.OUT
*
IF TERM.DISP THEN LN.DISP = EXEC.OUT; GOSUB DISP.LINE
*
EXEC.VERB = "GET-LIST ":FILE.ID
EXEC.OUT = EMPTY
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":EXEC.VERB; GOSUB DISP.LINE
EXECUTE EXEC.VERB, //SELECT. > ITEM.ID.LIST, //OUT. > EXEC.OUT
*
END
END
END
DONE = FALSE; ITEM.ID = EMPTY
FIRST.TRY = TRUE
IF LPTR.FL.SAVE EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE
*
!! Main Program
*
LOOP
*
LOOP
*
CONT = TRUE
BEGIN CASE
CASE OPSYS EQ "M"
IF ITEM.ID EQ "@" THEN CONT = FALSE
CASE TRUE
IF NOT(LEN(ITEM.ID.LIST)) THEN CONT = FALSE
END CASE
*
IF NOT(CONT) THEN
IF FIRST.TRY THEN
PRINT
PRINT "Enter item name: ":
INPUT RSP:
IF RSP EQ "KILL" THEN STOP
PRINT
ITEM.ID = RSP
END ELSE
DONE = TRUE
END
*
* Not cont
*
END ELSE
BEGIN CASE
CASE OPSYS EQ "M"
READNEXT ITEM.ID FROM ITEM.ID.LIST ELSE ITEM.ID = "@"
CASE TRUE
ITEM.ID = ITEM.ID.LIST<ONE>
ITEM.ID.LIST = DELETE(ITEM.ID.LIST,ONE,ZERO,ZERO)
END CASE
END; * of cont
*
FIRST.TRY = EMPTY
*
WHILE NOT(DONE) AND (ITEM.ID EQ "@" OR ITEM.ID EQ EMPTY OR ITEM.ID[ONE,ONE] EQ "*" OR ITEM.ID[ONE,ONE] EQ "$") DO REPEAT
*
! Have another item or am done
*
UNTIL DONE DO
*
EXEC.VERB = "MSG PROGRAMS ":PROC.BUFFER<1>:" Gen:":ITEM.ID
EXECUTE EXEC.VERB
*
EXEC.VERB = "ACC.UPDATE"
EXEC.IN = (",S/W Trans ":PROC.BUFFER<TWO>:PROC.BUFFER<ONE>) "L#25"
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
! LOOP To handle screen items
*
ORIG.ID = ITEM.ID; SH.CN = ZERO; SH.CN.MAX = ONE
SUBR.FL = FALSE; INCL.FL = FALSE
IF ORIG.ID[ONE,3] EQ "SH." THEN
PRINT CLB:"Screen present":
SH.CN.MAX = 3
READ SCR.HDR FROM SCR.FILE,ORIG.ID[4,9999]:"*HDR" ELSE
SCR.HDR = EMPTY
PRINT CLB:"Screen Header Missing!":
SCR.HDR<SCR.HDR$SCREEN.TYPE> = "P"
END
IF INDEX(SCR.HDR<SCR.HDR$SCREEN.TYPE>,"S",ONE) THEN
SUBR.FL = TRUE; SH.CN.MAX = 4
PRINT CLB:"Subroutine present":
END
IF INDEX(SCR.HDR<SCR.HDR$SCREEN.TYPE>,"C",ONE) THEN 
INCL.FL = TRUE; SH.CN.MAX = 5
PRINT CLB:"Code Segment present":
END
END
*
!
*
LOOP
*
SH.CN = SH.CN + ONE
*
IF ORIG.ID[ONE,3] EQ "SH." THEN
TMP = EMPTY
IF SH.CN EQ TWO THEN TMP = "SUBR.SCR."
IF SH.CN EQ 3   THEN TMP = "SUBR.LPT."
IF SH.CN EQ 4    THEN TMP = "SUBR."
IF SH.CN EQ 5    THEN TMP = "INCL."
ITEM.ID = "SH.":TMP:ORIG.ID[4,9999]
END ELSE
ITEM.ID = ORIG.ID
END
*
!
*
WHILE (ORIG.ID[ONE,4] EQ "SH." AND SH.CN LE SH.CN.MAX) OR SH.CN LE ONE DO
*
IF SH.CN LE 3 OR (SH.CN EQ 4 AND SUBR.FL) OR (SH.CN EQ 5 AND INCL.FL) THEN
*
EXEC.VERB = "ACC.UPDATE"
EXEC.IN =(",S/W Gen":ITEM.ID:" ":FILE.ID) "L#25"
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
COMMN.FLAG = EMPTY
FOUND = FALSE
PR.FOUND = FALSE
LBL.CN = ZERO
LBL.CN.MAX = ZERO
IN.LBLS = EMPTY
OUT.LBLS = EMPTY
*
! Perform Screen Generation if necessary
*
IF OUT.FILE.ID NE EMPTY THEN
IF ITEM.ID[ONE,3] EQ "SH." AND SH.CN EQ ONE THEN
*
TMP.ID = ITEM.ID[4,9999]
IF TMP.ID[ONE,5] EQ "SUBR." THEN TMP.ID = TMP.ID[6,9999]
*
EXEC.IN = "1":AM:"SCREENS":AM:TRUE.FILE.ID:AM:"IBP":AM:TMP.ID:AM:TERM.DISP + ZERO
*
EXEC.VERB = "SOURCEGEN"
*
EXECUTE EXEC.VERB, //IN. < EXEC.IN
*
END
END
*
*
! Read item
*
READ ITEM FROM IN.FILE,ITEM.ID THEN
*
! Classify item
*
LIST.EMPTY = FALSE
ATTRONE = ITEM<ONE>
ATTRONE = FIELD(ATTRONE," ",ONE)
ATTRONE = FIELD(ATTRONE,":",ONE)
IF ATTRONE[ONE,ONE] EQ "*" THEN ATTRONE = ATTRONE[TWO,999]
IF ATTRONE EQ "PQ" OR ATTRONE EQ "PQN" THEN ATTRONE = "PROC"
ITEM.TYPE = ATTRONE
IF VALID.ITEM.TYPE EQ "ALL" OR INDEX(VALID.ITEM.TYPE,"*":ITEM.TYPE:"*",ONE) THEN
*
! Call for each item
*
IF RUN.TYPE EQ TWO THEN
IF ITEM.TYPE NE OLD.ITEM.TYPE THEN
OLD.ITEM.TYPE = ITEM.TYPE
READ PROCESS.REC.TYPE FROM SYS.FILE,"ITEM.TYPE@":ITEM.TYPE THEN
FINDS   = PROCESS.REC.TYPE<4>
VPARAMS = PROCESS.REC.TYPE<5>
EPARAMS = PROCESS.REC.TYPE<6>
IPARAMS = PROCESS.REC.TYPE<7>
END ELSE
FINDS   = PROCESS.REC<4>
VPARAMS = PROCESS.REC<5>
EPARAMS = PROCESS.REC<6>
IPARAMS = PROCESS.REC<7>
END
END
END
*
*
IF ITEM.CLL NE EMPTY THEN
*
IF NOT(PR.FOUND) THEN
LN.DISP = "[=| ":"*** FOUND *** ":ITEM.ID; GOSUB DISP.LINE
LN.DISP = "[=| Item type: ":ITEM.TYPE; GOSUB DISP.LINE
END
*
IF ITEM.CLL[ONE,ONE] EQ "@" THEN
CLLNM = "CODE.CONV.":ITEM.CLL[TWO,999]
END ELSE
CLLNM = ITEM.CLL
END
*
VALID = FALSE
CALL @CLLNM(VALID,ITEM,COMMN.FLAG,ITEM.ID)
IF VALID THEN FOUND = TRUE
END; * OF ITEM.CLL
*
!! Loop for FTXT.CN.MAX string locations
*
FTXT.CN.MAX = COUNT(FINDS,VM)
IF FINDS NE EMPTY THEN FTXT.CN.MAX = FTXT.CN.MAX + ONE
*
FOR FTXT.CN = ONE TO FTXT.CN.MAX
*
THIS = FINDS<ONE,FTXT.CN>
AM.TC.CN = INDEX(ITEM,THIS,ONE)
*
IF AM.TC.CN THEN
*
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "[=| "; GOSUB DISP.LINE
IF NOT(PR.FOUND) THEN
LN.DISP = "[=| ":"*** FOUND *** ":ITEM.ID; GOSUB DISP.LINE
LN.DISP = "[=| Item type: ":ITEM.TYPE; GOSUB DISP.LINE
END
LN.DISP = "[=| ":("***":FTXT.CN:"***") "L#10":THIS; GOSUB DISP.LINE
END
*
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
IF NOT(PR.FOUND) THEN
LN.DISP =  RVB:"[=| ":"*** FOUND *** ":ITEM.ID:RVE; GOSUB DISP.LINE
LN.DISP =  RVB:"[=| Item type: ":ITEM.TYPE:RVE; GOSUB DISP.LINE
PR.FOUND = TRUE
END
LN.DISP = RVB:"[=| ":("***":FTXT.CN:"***") "L#10":THIS:RVE; GOSUB DISP.LINE
*
!! Loop to find all occurances of string
FOUND = TRUE
*  FTXT<LIST.CN,FTXT.CN>=THIS
FTXT<ONE,FTXT.CN> = THIS
FLIN.CN = ZERO
*
LOOP
*
FLIN.CN = FLIN.CN + ONE
AM.TC.CN=INDEX(ITEM,THIS,FLIN.CN)
*
WHILE AM.TC.CN DO
*
AM.CN.LOC = DCOUNT(ITEM[ONE,AM.TC.CN],AM)
LINE = ITEM<AM.CN.LOC>
ORIG.LINE = LINE
*
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "[=| ":AM.CN.LOC "R#4":" "
TMP = CODE.CHAR:"%%":OPSYS.TYPE:"%%="
IF LINE[ONE,9] NE TMP THEN
LN.DISP = LN.DISP:"        "
END
LN.DISP = LN.DISP:LINE; GOSUB DISP.LINE
END
*
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| ":AM.CN.LOC "R#4":" "
TMP = CODE.CHAR:"%%":OPSYS.TYPE:"%%="
IF LINE[ONE,9] NE TMP THEN
LN.DISP = LN.DISP:"        "
END
LN.DISP = LN.DISP:LINE; GOSUB DISP.LINE
END
*
! Process additional validate parameters if present
*
VALS = VPARAMS<ONE,FTXT.CN>
VALID = TRUE
*
IF LEN(VALS) THEN
CALL SEARCH.VALIDATE(LINE,THIS,VALS,VALID)
END
*
! If code type present *%%???%%= then process it
*
IF VALID AND LEN(IN.CODE.TYPE) THEN
IN.VER     = IN.CODE.TYPE
OUT.VER    = OUT.CODE.TYPE
CODE.VER   = EMPTY
CODE.EXT.C = EMPTY
GEN.OLD.FLAG = EMPTY
CALL SEARCH.VALIDATE.VERSION(ORIG.LINE,LINE,IN.VER,OUT.VER,VALID,CODE.VER,CODE.EXT.C,NULLS.FLAG,EXISTING.FLAG,REM.FLAG,GEN.OLD.FLAG,ITEM.TYPE)
END ELSE CODE.VER = OUT.CODE.TYPE
*
! Perform extractions if present
*
IF VALID THEN
* PRINT "[=| ":AM.CN.LOC "R#4 ":">>> ":
EVALS = EPARAMS<ONE,FTXT.CN>
IF LEN(EVALS) THEN
CALL SEARCH.PARAM.EXTRACT(LINE,THIS,EVALS,VALID,EXT.PARAMS)
END ELSE EXT.PARAMS = EMPTY; * Of EVALS
*
IF VALID THEN
IVALS = IPARAMS<ONE,FTXT.CN>
IN.LINE = LINE
LBL.VERB = THIS
*
* Perform calls (@xxxxxxxxxxxxxxxx)
*
IF IVALS[ONE,ONE] EQ "@" THEN
IF IVALS EQ "@DB.ST.LBLS.NUM" THEN
CALL CODE.CONV.DB.ST.LBLS.NUM(VALID,LBL.VERB,IN.LINE,OUT.LINE,IN.LBLS,OUT.LBLS,LBL.CN,LBL.CN.MAX,COMMN.FLAG,AM.CN.LOC,STD.FLAG,ITEM)
IF VALID THEN LINE = OUT.LINE
END ELSE
CLLNM = "CODE.CONV.":IVALS[TWO,9999]
CALL @CLLNM(VALID,IN.LINE,OUT.LINE,COMMN.FLAG)
IF VALID THEN LINE = OUT.LINE
END
*
* Otherwise perform output parameter processing if present
*
END ELSE IF LEN(IVALS) THEN
CALL SEARCH.PARAM.OUTPUT(LINE,EXT.PARAMS,IVALS,VALID,ORIG.LINE,OUT.LINE)
*
END ELSE
*OUT.LINE = LINE
OUT.LINE = EMPTY
END
*
*ITEM = 
*
IF VALID THEN
*           ITEM.PREF = ITEM[ONE,I]
*           ITEM.SUFF = ITEM[I + ONE,32267]
*           ITEM.PREF<AM.CN.LOC> = EMPTY
*           ITEM.SUFF<ONE> = EMPTY
*           ITEM = ITEM.PREF:OUT.LINE:ITEM.SUFF
*
*            PRINT "[=| "
IF OUT.CODE.TYPE NE EMPTY THEN
TCN = ZERO
LOOP TCN = TCN + ONE WHILE OUT.LINE<TCN> NE EMPTY DO
OUT.LINE<TCN> = CODE.CHAR:"%%":OUT.CODE.TYPE:"%%=":OUT.LINE<TCN>
REPEAT
END
*
IF STD.FLAG THEN
*
IF CODE.VER EQ EMPTY THEN
CODE.VER = IN.CODE.TYPE
CODE.EXT.C = '='
END
*
IF ORIG.LINE[ONE,3] EQ CODE.CHAR:"%%" THEN
TEMP.LINE = ORIG.LINE[10,9999]
END ELSE TEMP.LINE = ORIG.LINE
*
IF GEN.OLD.FLAG THEN
OUT.LINE = CODE.CHAR:"%%":CODE.VER:"%%":CODE.EXT.C:TEMP.LINE:AM:OUT.LINE
END ELSE
IF ORIG.LINE[ONE,6] NE CODE.CHAR:"%%":OUT.CODE.TYPE[ONE,3] THEN
OUT.LINE = ORIG.LINE[ONE,ONE]:"%%":CODE.VER:"%%":CODE.EXT.C:TEMP.LINE:AM:OUT.LINE
END
END; * OF GEN.OLD.FLAG
END; * OF STD.FLAG
*
*
TCN = ZERO
LOOP TCN = TCN + ONE WHILE OUT.LINE<TCN> NE EMPTY DO
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "|||> ":TCN "R#3":OUT.LINE<TCN>; GOSUB DISP.LINE
END
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "|||> ":TCN "R#3":OUT.LINE<TCN>; GOSUB DISP.LINE
END
REPEAT
ITEM = REPLACE(ITEM,AM.CN.LOC,ZERO,ZERO,OUT.LINE)
*
**NOTE:A STATEGY WHERE THE NUMBER OF OCCURANCES OF "THIS"
*WITHIN EVALS C/B COUNTED AND APPLIED WETHER THE STANDARD.FLAG WAS
*TURNED ON OR NOT....
*871017
*
**********
TEMP.ADJ = ONE
IF STD.FLAG THEN
ADJ.FLAG = TRUE
END ELSE
IF IVALS[ONE,ONE] NE "@" THEN
IF INDEX(IVALS,THIS,ONE) THEN ADJ.FLAG = TRUE ELSE ADJ.FLAG = FALSE
END ELSE ADJ.FLAG = TRUE
END
*
IF ADJ.FLAG THEN
LOOP WHILE INDEX(OUT.LINE,THIS,TEMP.ADJ) DO TEMP.ADJ = TEMP.ADJ + ONE REPEAT
FLIN.CN = FLIN.CN + TEMP.ADJ - TWO
END ELSE
FLIN.CN = FLIN.CN - ONE
END
*
*
END
*
*
END
*
*
END
*
*
FLIN<ONE,FTXT.CN,FLIN.CN> = AM.CN.LOC:VALID
*
*
REPEAT
*
!  for string location number AM.TC.CN
*
END; * Of AM.TC.CN
*
*
NEXT FTXT.CN
*
!     (next string to look for)
*
END; *# OF ITEM.TYPE MATCH
*
! Check to see if found
*
IF NOT(FOUND) THEN
* IF NOT(PHANTOM.FLAG) THEN
* IF LPTR.FL.SAVE EQ TWO THEN
* LPTR.FL = LPTR.FL.SAVE - ONE
* PRINT "[=| ":ITEM.ID:" not present . . ."
* PRINT "[=| ":"Item type: ":ITEM.TYPE
* END
* LPTR.FL = FALSE
* PRINT "[=| ":ITEM.ID:" not present . . ."
* PRINT "[=| ":"Item type: ":ITEM.TYPE
* END
*
! Found
*
END ELSE
IF LPTR.FL.SAVE EQ TWO THEN
LPTR.FL = LPTR.FL.SAVE - ONE
LN.DISP = "[=| "; GOSUB DISP.LINE
END
IF TERM.DISP THEN
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
END
*
IN.LBLS.CN.MAX = DCOUNT(IN.LBLS,AM)
*
FOR LPTR.CN = ONE TO TWO UNTIL NOT(IN.LBLS.CN.MAX)
*
IF (LPTR.CN EQ ONE AND TERM.DISP) OR (LPTR.CN EQ TWO AND LPTR.FL.SAVE EQ TWO) THEN
*
IF LPTR.CN EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE ELSE LPTR.FL = FALSE
*
LN.DISP = "[=| ":"X-REF OF STRING TO NUM LABEL"; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
FOR IN.LBLS.CN = ONE TO IN.LBLS.CN.MAX
*
LN.DISP = "[=| ":(IN.LBLS<IN.LBLS.CN>:"....................................") "L#30":" ":OUT.LBLS<IN.LBLS.CN>; GOSUB DISP.LINE
*
NEXT IN.LBLS.CN
*
END
*
NEXT LPTR.CN
*
*
*
LIST<LIST.CN> = ITEM.ID
LIST.CN = LIST.CN + ONE
*
*
END; *# OF FOUND / NOT(FOUND) HANDLING
*
*
IF OUT.FILE.ID NE EMPTY THEN
WRITE ITEM ON OUT.FILE,ITEM.ID
END
*
END; *# OF SUCCESSFUL READ OF ITEM
*
!
*
WRITE FTXT ON LISTS.FILE,"@S@FTXT@":FILE.ID:"@":SYS.RUN.NAME:"@":ITEM.ID
IF LIST NE EMPTY THEN
WRITE LIST ON LISTS.FILE,"@S@LIST@":FILE.ID:"@":SYS.RUN.NAME
END
WRITE FLIN ON LISTS.FILE,"@S@FLIN@":FILE.ID:"@":SYS.RUN.NAME:"@":ITEM.ID
FTXT = EMPTY
FLIN = EMPTY
*
! repeat for SH. loop
*
END; * of LE 3 OR (4 & SUBR.FL) OR (5 & INCL.FL)
*
REPEAT
*
! repeat for next ITEM.ID loop
*
REPEAT
*
!! END OF PROGRAM
*
IF LPTR.FL.SAVE EQ TWO THEN LPTR.CN.MAX = TWO ELSE LPTR.CN.MAX = ONE
*
FOR LPTR.CN = ONE TO LPTR.CN.MAX
*
IF (LPTR.CN EQ ONE AND TERM.DISP) OR (LPTR.CN EQ TWO AND LPTR.FL.SAVE EQ TWO) THEN
*
IF LPTR.CN EQ TWO THEN LPTR.FL = LPTR.FL.SAVE - ONE ELSE LPTR.FL = FALSE
*
CN = ZERO
LOOP CN = CN + ONE UNTIL LIST<CN> EQ EMPTY DO
*
IF CN EQ ONE THEN
*
IF LPTR.FL THEN
LN.CN = 99999
END ELSE
LN.CN.TERM = 99999
END
*
LN.DISP = "[=| ":STR("*",70); GOSUB DISP.LINE
LN.DISP = "[=| ":"Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILE.ID; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",20); GOSUB DISP.LINE
LN.DISP = "[=| ":"       STRINGS"; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",20); GOSUB DISP.LINE
*
FOR C = ONE TO (ONE + COUNT(FINDS,VM))
LN.DISP = "[=| ":FINDS<ONE,C>; GOSUB DISP.LINE
NEXT C
*
LN.DISP = "[=| ":STR("*",20); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",50); GOSUB DISP.LINE
LN.DISP = "[=| ":"SUMMARY LISTING OF PROGRAMS WHERE STRING(s) FOUND"; GOSUB DISP.LINE
LN.DISP = "[=| ":STR("*",50); GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
*
END; * Of CN EQ ONE
*
LN.DISP = "[=| ":LIST<CN>; GOSUB DISP.LINE
*
*$INCLUDE DH.IBP SEARCH.PRINT.MAP
*
REPEAT
*
IF LIST NE EMPTY THEN
LN.DISP = "[=| ":"'SELECT.LIST' FILED"; GOSUB DISP.LINE
END
*
END
*
NEXT LPTR.CN 
*
!
*
IF LIST NE EMPTY THEN
WRITE LIST ON LISTS.FILE,"@S@LIST@":FILE.ID:"@":SYS.RUN.NAME
*   WRITE FTXT ON LISTS.FILE,"@S@FTXT@":FILE.ID:"@":SYS.RUN.NAME
*   WRITE FLIN ON LISTS.FILE,"@S@FLIN@":FILE.ID:"@":SYS.RUN.NAME
END ELSE
LN.DISP = "[=| ":"NO ITEMS FOUND"; GOSUB DISP.LINE
*   DELETE LISTS.FILE,"@LIST"
*   DELETE LISTS.FILE,"@FTXT"
*   DELETE LISTS.FILE,"@FLIN"
IF LIST.EMPTY THEN
IF PROC.FL THEN
PROC.BUFFER<ONE> = "ABORT"
* ULT ONLY
PROCWRITE PROC.BUFFER
END
END
END
*
! FINISH
*
LPTR.FL = FALSE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| ":"* * * * *   Type any key to return to TCL . . .    * * * * * * *"; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
LN.DISP = "[=| "; GOSUB DISP.LINE
* FOR A = ONE TO 5 UNTIL SYSTEM(11)
LN.DISP = "[=| ":CHAR(7); GOSUB DISP.LINE
FOR B = ONE TO 3 UNTIL SYSTEM(11)
LN.DISP = "[=| ":CHAR(7); GOSUB DISP.LINE
EXECUTE "SLEEP 2"
NEXT B
FOR B = ONE TO 3 UNTIL SYSTEM(11)
LN.DISP = CHAR(7); GOSUB DISP.LINE
*      RQM
NEXT B
* NEXT A
*
*
STOP
*
!! SUBROUTINES
*
! LINE DISPLAY
*
DISP.LINE: *
*
IF LPTR.FL THEN
CALL PRINTER.ON(STAT)
END
*
LOOP
*
IF NOT(LPTR.FL) THEN
LN.CN.TERM = LN.CN.TERM + ONE
WDTH = "L#":CL.CN.MAX.TERM
IF LN.CN.TERM GT LN.CN.MAX.TERM THEN GOSUB LPTR.HEADER
PRINT @(ZERO,LN.CN.TERM):CLL:
END ELSE
LN.CN = LN.CN + ONE
WDTH = "L#":CL.CN.MAX
IF LN.CN GT LN.CN.MAX THEN GOSUB LPTR.HEADER
END
*
PRINT LN.DISP WDTH
*
IF LPTR.FL THEN
LN.DISP = LN.DISP[CL.CN.MAX + ONE,99999]
END ELSE
LN.DISP = LN.DISP[CL.CN.MAX.TERM + ONE,99999]
END
*
WHILE LEN(LN.DISP) DO
*
LN.DISP = "[=| ++++ ":LN.DISP
*
REPEAT
*
*
IF LPTR.FL THEN
* PRINT
PRINTER OFF
END
*
RETURN
*
! HEADER HANDLING
*
LPTR.HEADER: *
*
IF LPTR.FL THEN
PG.CN = PG.CN + ONE
LN.CN = 7
END ELSE
PG.CN.TERM = PG.CN.TERM + ONE
LN.CN.TERM = 4
END
*
IF NOT(LPTR.FL) THEN
IF NOT(NOPAGE.FL) THEN
PRINT @(ZERO,22):CLL:"Enter <cr> to continue . . . ":
INPUT CONT.RSP:
PRINT @(ZERO,22):CLL:
IF CONT.RSP EQ "KILL" OR CONT.RSP EQ "END" THEN STOP
IF CONT.RSP EQ "GO" THEN NOPAGE.FL = TRUE
END
FOR TMP = ONE TO 4; PRINT @(ZERO,TMP):CLL:; NEXT TMP
PRINT @(ZERO,ZERO):
FIRST.PG.TERM = FALSE
*
END ELSE
IF NOT(FIRST.PG) THEN
IF FAST.FL THEN PRINTER CLOSE
IF FAST.FF THEN
PRINT EOS:
END
END
FIRST.PG = FALSE
END
*
IF LPTR.FL THEN TMP = PG.CN ELSE TMP = PG.CN.TERM
PRINT OCONV(DATE(),"D2") "L#14":(SPACE(25 - INT(LEN(TITLE) / TWO + .5)):TITLE) "L#50":("Page ":TMP) "R#14"
PRINT OCONV(TIME(),"MTS") "L#14":(SPACE(25 - INT(LEN(TITLE1) / TWO + .5)):TITLE1) "L#50":WHO "R#14"
PRINT
IF LPTR.FL THEN
PRINT STR("*",CL.CN.MAX)
END ELSE
PRINT STR("*",CL.CN.MAX.TERM)
END
PRINT
*
RETURN
*
!
*
END
~SEARCH.BATCH.FLAG~
1
~SEARCH.OVERRIDE~
ADD.ID
AUTO.LOADER
CALC.RENT
INPUT.DATA
LOCK.ITEM
UNLOCK.ITEM
WORK.ORDERS.8511FCI
WORK.ORDERS.LINDSAY
WORK.ORDERS.STANDARD
WORK.ORDERS.VANILLA
WORK.ORDERS.WESTCOAST
~SEARCH.PARAM.EXTRACT~
SUBROUTINE SEARCH.PARAM.EXTRACT(LINE,THIS,PARAMS,VALID,OUT.PARAMS)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   01 AUG 84
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
*
OUT.PARAMS= ""
VALID = 1
CN = 0
START.POS = 1
VMAX = DCOUNT(PARAMS<1,1>,SVM)
LOOP CN = CN + 1 WHILE CN LE VMAX+1 DO
PC = ''
VSTRING = PARAMS<1,1,CN>
IF VSTRING = "@CLEAR@" THEN
START.POS = 1
END ELSE
VSTRING.LEN = LEN(VSTRING)
IF CN NE VMAX+1 THEN
CN1 = 0
LOOP
CN1 = CN1 + 1
VSTRING.START = INDEX(LINE,VSTRING,CN1)
WHILE VSTRING.START LT START.POS AND VSTRING.START DO REPEAT
END ELSE
VSTRING.START = LEN(LINE)+1
END
IF VSTRING.START THEN
VSTRING1 = LINE[START.POS,VSTRING.START-START.POS]
*###PRINT
*###PRINT CN:"e":LINE
*###PRINT CN:"p - ":
IF VSTRING1 NE "" THEN
OUT.PARAMS<CN> = VSTRING1
*IF NOT(INDEX(OUT.PARAMS<CN>,'"',1)) AND NOT(INDEX(OUT.PARAMS<CN>,"'",1)) THEN
*OUT.PARAMS<CN> = TRIM(OUT.PARAMS<CN>)
*END
*###PRINT OUT.PARAMS<CN>:"^"
END ELSE
*###PRINT "^#^"
END; * OF VSTRING1 NE ''
START.POS = VSTRING.START + VSTRING.LEN
END; * OF VSTRING.START
END; * OF VSTRING = "@CLEAR@"
REPEAT
TEMP = OUT.PARAMS
CN3 = 1
LOOP
TEMP1 = TEMP<1>
CN3 = CN3 + 1
WHILE LEN(TEMP) DO
* PRINT TEMP1:" <|||*|||":CN3:"> ":
TEMP = DELETE(TEMP,1,0,0)
REPEAT
* PRINT
*
*
RETURN
*
END
~SEARCH.PARAM.OUTPUT~
SUBROUTINE SEARCH.PARAM.OUTPUT(LINE,EXT.PARAMS,PARAMS,VALID,ORIG.LINE,OUT.LINE)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   03 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
*
OUT.LINE= ""
VALID = 1
CN = 0
OUT.LINE = ''
*
LOOP CN = CN + 1 WHILE PARAMS<1,1,CN> NE '' DO
TEMP=PARAMS<1,1,CN>
CN1 = 0
LOOP
CN1 = CN1 + 1
WHILE TEMP NE "" DO
TC = TEMP[1,1]
*
IF TC EQ "'" OR TC = '"' THEN
TEMP1 = INDEX(TEMP,TC,2)
IF NOT(TEMP1) THEN TEMP1 = LEN(TEMP)
OUT.LINE = OUT.LINE:TEMP[2,TEMP1-2]
TEMP = TEMP[TEMP1+1,9999]
*###PRINT '"':OUT.LINE
*
END ELSE IF TC EQ "L" THEN
OUT.LINE = OUT.LINE:ORIG.LINE
*###PRINT "l":OUT.LINE
TEMP = TEMP[2,9999]
*
END ELSE IF TC EQ "N" THEN
LOOP
TC = TEMP[1,1]
WHILE TC EQ "N" DO
TEMP2 = TEMP[2,3]
TEMP = TEMP[5,999]
IF NUM(TEMP2) THEN
IF EXT.PARAMS<TEMP2> EQ "" THEN
*OUT.LINE = OUT.LINE:EXT.PARAMS<TEMP2>
*###PRINT "y":
END ELSE
TEMP = ''
*###PRINT "n":
END
*###PRINT TC:OUT.LINE
END
REPEAT
*
END ELSE IF TC EQ "C" THEN
LOOP
TC = TEMP[1,1]
WHILE TC EQ "C" DO
TEMP2 = TEMP[2,3]
TEMP = TEMP[5,999]
*
IF NUM(TEMP2) THEN
*
IF EXT.PARAMS<TEMP2> NE "" THEN
*
TEMP3 = TEMP[1,1]
IF TEMP3 EQ "=" OR TEMP3 = "#" OR TEMP3 = "^" THEN
*
TEMP = TEMP[2,999]
TEMP4 = FIELD(TEMP,"<",1)
TEMP = TEMP[COL2()+1,999]
VAL.FOUND = INDEX(EXT.PARAMS<TEMP2>,TEMP4,1)
IF TEMP3 = "=" AND TEMP4 = EXT.PARAMS<TEMP2> THEN VAL.FOUND = 1 ELSE VAL.FOUND = 0
*
IF (VAL.FOUND AND (TEMP3 = "=" OR TEMP3 = "^")) OR (NOT(VAL.FOUND) AND TEMP3 = "#") THEN
!!!!!DO IT
*
END ELSE
*C??? CONDITION FALSE
TEMP = ''
END
*
END ELSE
*PARAMETER EMPTY
END
*
END ELSE
*TEMP2 NOT NUMERIC
TEMP = ''
END
*
END
REPEAT
*
END ELSE IF TC EQ "P" THEN
TEMP2 = TEMP[2,3]
TEMP = TEMP[5,999]
IF NUM(TEMP2) THEN
IF EXT.PARAMS<TEMP2> NE "" THEN
OUT.LINE = OUT.LINE:EXT.PARAMS<TEMP2>
*###PRINT "y":
END ELSE
*###PRINT "n":
END
*###PRINT TC:OUT.LINE
END
*
END ELSE IF TC EQ "-" THEN
TEMP2 = TEMP[2,3]
TEMP3 = TEMP[5,1]
TEMP = TEMP[5,999]
IF NUM(TEMP2) THEN
IF (OUT.LINE[LEN(OUT.LINE),1] EQ TEMP3 OR TEMP3 EQ "^") AND TEMP3 NE "" THEN
OUT.LINE = OUT.LINE[1,LEN(OUT.LINE)-TEMP2]
END
END
*
END ELSE IF TC EQ "a" THEN
OUT.LINE = OUT.LINE:AM
TEMP = TEMP[2,9999]
*###PRINT "a":
*
END ELSE IF TC EQ "V" THEN
OUT.LINE = OUT.LINE:VM
TEMP = TEMP[2,9999]
*###PRINT "v":
*
END ELSE IF TC EQ "S" THEN
OUT.LINE = OUT.LINE:SVM
TEMP = TEMP[2,9999]
*###PRINT "s":
*
*
END ELSE
TEMP = TEMP[2,9999]
END
*
REPEAT
*
REPEAT
*
RETURN
*
END
~SEARCH.RUNTYPE~
*PROGRAM: SEARCH.RUNTYPE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
OPEN "BP.IMPORT" TO ITEM.FILE ELSE STOP
OPEN "LISTS" TO LISTS.FILE ELSE STOP
OPEN "SYS" TO SYS.FILE ELSE STOP
*
RTN.TYPE = EMPTY
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD RTN.TYPE ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
*
IF NOT(PROC.FL) THEN
DELETE SYS.FILE,"KBIL.RUNTYPE@":PORT
END
*
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY.":PORT,ONE ELSE
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY",ONE ELSE TERM.DISP = TRUE
END
*
!
*
READ PORT.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":PORT ELSE PORT.TYPE = "INSTALL"
IF TERM.DISP THEN PRINT "Type of port is ":PORT.TYPE
*
*
!
*
READ RUN.TYPE FROM SYS.FILE,"KBIL.":PORT.TYPE:".RUNTYPE" ELSE
READ RUN.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":PORT ELSE
LOOP
PRINT
PRINT "Enter run type (DEV,TAPE,COMM,OTHER,ABORT): ":
INPUT RUN.TYPE:
WHILE NOT(INDEX("**KILL*DEV*TAPE*COMM*OTHER*ABORT*","*":RUN.TYPE:"*",ONE)) DO REPEAT
IF NOT(INDEX("**KILL*","*":RUN.TYPE:"*",ONE)) THEN
WRITE RUN.TYPE ON SYS.FILE,"KBIL.RUNTYPE@":PORT
WRITE RUN.TYPE ON SYS.FILE,"KBIL.":PORT.TYPE:".RUNTYPE"
END
END
END
*
IF RUN.TYPE EQ EMPTY THEN RUN.TYPE = "ABORT"
IF RUN.TYPE EQ "KILL" THEN RUN.TYPE = "ABORT"
IF TERM.DISP THEN PRINT "Type of run: ":RUN.TYPE
*
!
*
IF PROC.FL THEN
PROC.BUFFER<ONE> = PORT.TYPE
* ULT ONLY
PROCWRITE PROC.BUFFER
END
*
STOP
*
END
~SEARCH.VALIDATE~
SUBROUTINE SEARCH.VALIDATE(LINE,THIS,PARAMS,VALID)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   04 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
TEMP.LINE = LINE
IF TEMP.LINE[TWO,TWO] EQ "%%" AND TEMP.LINE[7,TWO] = "%%" THEN
TEMP.LINE = TEMP.LINE[10,999]
END
*
IF TEMP.LINE[1,1] EQ "*" OR TEMP.LINE[1,1] EQ "!" THEN
VALID = 8
*950124*DGH*RETURN
END ELSE
VALID = 1
END
*
FOUND = 1
CN = 0
LOOP CN = CN + 1 WHILE PARAMS<1,1,CN> NE '' DO
PC = ''
VPARAM = PARAMS<1,1,CN>[1,1]
VFUNCT = PARAMS<1,1,CN>[2,1]
VSTRNG = PARAMS<1,1,CN>[3,999]
*
IF VPARAM EQ "V" THEN
*set valid to
VALID = VFUNCT
*
END ELSE IF VPARAM EQ "T" THEN
* Trim
TEMP.LINE = TRIM(TEMP.LINE)
*
END ELSE IF VPARAM EQ "C" THEN
* line must {not} only Contain
IF TEMP.LINE EQ VSTRNG THEN
IF VFUNCT EQ "=" THEN VALID = 1 ELSE VALID = 0
END ELSE
IF VFUNCT EQ "#" THEN VALID = 1 ELSE VALID = 0
END
*
END ELSE IF VPARAM EQ "L" THEN
* Locate a string
FOUND = INDEX(TEMP.LINE,VSTRNG,1)
*
IF VFUNCT EQ "=" THEN
IF NOT(FOUND) THEN VALID = 0
END ELSE IF VFUNCT EQ "#" THEN
IF FOUND THEN VALID = 0
END ELSE IF VFUNCT EQ "@" THEN
IF FOUND THEN VALID = 1
END
*
END ELSE IF VPARAM EQ "P" THEN
* Plus an additional find function
TEMP = FIELD(TEMP.LINE,THIS,1)
PC = TEMP.LINE[COL1()-1,LEN(VSTRNG)]
IF PC EQ VSTRNG THEN FOUND = 1 ELSE FOUND = ''
*
IF VFUNCT EQ "=" THEN
IF NOT(FOUND) THEN VALID = 0
END ELSE IF VFUNCT EQ "#" THEN
IF FOUND THEN VALID = 0
END ELSE IF VFUNCT EQ "@" THEN
IF FOUND THEN VALID = 1
END
*
END ELSE IF VPARAM EQ "E" THEN
* Exclude character
* EF First Characters in line
* EL Last Charaters in line
VSTRNG.LEN = LEN(VSTRNG)
IF VFUNCT EQ "F" THEN
*FIRST
IF TEMP.LINE[1,VSTRNG.LEN] EQ VSTRNG THEN VALID = 0 ELSE VALID = 1
END ELSE IF VFUNCT EQ "L" THEN
*LAST
*IF TEMP.LINE[LEN(TEMP.LINE)-VSTRNG.LEN,VSTRNG.LEN] EQ VSTRNG THEN VALID = 0 ELSE VALID = 1
TEMP1 = LEN(TEMP.LINE)-VSTRNG.LEN+1
TEMP2 = TEMP.LINE[TEMP1,VSTRNG.LEN]
IF TEMP2 EQ VSTRNG THEN VALID = 0 ELSE VALID = 1
END
*
END ELSE IF VPARAM EQ "F" THEN
* Find character
* FF First Characters in line
* FL Last Charaters in line
VSTRNG.LEN = LEN(VSTRNG)
IF VFUNCT EQ "F" THEN
*FIRST
IF TEMP.LINE[1,VSTRNG.LEN] EQ VSTRNG THEN VALID = 1 ELSE VALID = 0
END ELSE IF VFUNCT EQ "L" THEN
*LAST
*IF TEMP.LINE[LEN(TEMP.LINE)-VSTRNG.LEN,VSTRNG.LEN] EQ VSTRNG THEN VALID = 1 ELSE VALID = 0
TEMP1 = LEN(TEMP.LINE)-VSTRNG.LEN+1
TEMP2 = TEMP.LINE[TEMP1,VSTRNG.LEN]
IF TEMP2 EQ VSTRNG THEN VALID = 1 ELSE VALID = 0
END
*
END ELSE IF VPARAM EQ "N" THEN
* Next Characters to THIS
FOUND = INDEX(TEMP.LINE,THIS,1)
IF TEMP.LINE[FOUND+LEN(THIS),LEN(VSTRNG)] EQ VSTRNG THEN FOUND = 1 ELSE FOUND = 0
IF VFUNCT EQ "=" THEN
IF NOT(FOUND) THEN VALID = 0
END ELSE IF VFUNCT EQ "#" THEN
IF FOUND THEN VALID = 0
END ELSE IF VFUNCT EQ "@" THEN
IF FOUND THEN VALID = 1
END
*
*
END
*
*###PRINT @(0,23):THIS "L#10":CN "L#5":VALID "L#5":FOUND "L#5":PC "L#5":TEMP.LINE "L#50":
* PRINT ">v<":
*
REPEAT
*
RETURN
END
~SEARCH.VALIDATE.VERSION~
SUBROUTINE SEARCH.VALIDATE.VERSION(ORIG.LINE,LINE,IN.VER,OUT.VER,VALID,CODE.VER,CODE.EXT.C,NULLS.FLAG,EXISTING.FLAG,REM.FLAG,GEN.OLD.FLAG,ITEM.TYPE)
*
*AUTHOR:        DAVID HORSMAN
*COMPANY:       MACROSCOPE DESIGN MAXTRIX
*DATE WRITEN:   04 JUL 87
*DATE RELEASED: 15 AUG 84  Vs 0.1
*               25 JUL 87  Vs 1.0
*               23 AUG 87  Vs 1.1
*               18 OCT 87  Vs 1.3
*               06 NOV 87  Vs 2.0
*
*COPYRIGHT    : (C) 1984,1985,1986,1987 MACROSCOPE DESIGN MAXTRIX
*                       All rights reserved.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
*
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,9999] REPEAT
REM.VALID = ""
IF (ITEM.TYPE = "PROC" AND LINE[1,1] = "C") OR (ITEM.TYPE = "PROGRAM" AND ( LINE[1,1] = "*" OR LINE[1,1] EQ "!" OR LINE[1,4] EQ "REM ")) THEN
TEMP = INDEX(LINE,"%%",2)
IF TEMP THEN TEMP = TEMP + 3 ELSE TEMP = 1
LOOP WHILE LINE[TEMP,1] EQ " " AND LEN(LINE) > TEMP DO
LINE = LINE[1,TEMP-1]:LINE[TEMP+1,9999]
REPEAT
IF ((ITEM.TYPE = "PROC" AND LINE[TEMP,1] EQ "C") OR (ITEM.TYPE EQ "PROGRAM" AND (LINE[TEMP,1] EQ "*" OR LINE[TEMP,1] EQ "!" OR LINE[TEMP,4] EQ "REM " )) AND TEMP) THEN
REM.VALID = 1
END ELSE IF NOT(TEMP) THEN
REM.VALID = 1
END
END
IF NOT(REM.FLAG) AND REM.VALID THEN
 VALID = ""
*### PRINT ">rem<":
END
*
*
GEN.OLD.FLAG = ""
IF VALID THEN
IF COUNT(LINE,"%%") EQ 2 THEN
CODE.VER = FIELD(LINE,"%%",3)
*###PRINT "ccc":CODE.VER
CODE.EXT.C = FIELD(LINE,"%%",5)
*###PRINT "eee":CODE.EXT.C
CODE.EXT.C = CODE.EXT.C[1,1]
LINE = LINE[COL1()+2,9999]
*###PRINT ">ver<":CODE.VER:">":LINE
IF NOT(EXISTING.FLAG) AND CODE.VER = IN.VER THEN
VALID = ''
PRINT "!!skip!!"
END
END ELSE IF NULLS.FLAG EQ "EQ" THEN
GEN.OLD.FLAG = 1; CODE.VER = IN.VER; CODE.EXT.C = "="
*###PRINT ">eq<":
END ELSE IF NULLS.FLAG EQ "NE" THEN
GEN.OLD.FLAG = 1; CODE.VER = IN.VER; CODE.EXT.C = "#"
*###PRINT ">ne<":
END ELSE
CODE.VER = ""
CODE.EXT.C = ""
VALID = ""
*###PRINT ">not<":
END
IF CODE.VER NE "" THEN
IF CODE.VER NE IN.VER AND CODE.VER NE OUT.VER THEN
VALID = ""
END
END
*
*###PRINT
END; * OF VALID
*###PRINT "i>":IN.VER:"o>":OUT.VER:"v>":VALID:"c>":CODE.VER:".>":CODE.EXT.C:"g>":GEN.OLD.FLAG
*###PRINT "^^^^^^^^^^^^^^^"
*###PRINT
*
RETURN
END
~SET.PORTTYPE~
*PROGRAM: SET.PORTTYPE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PROC.FL = TRUE
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
IF PROC.BUFFER[ONE,3] EQ "SET" THEN PROC.FL = FALSE
IF PROC.BUFFER EQ EMPTY THEN PROC.FL = FALSE
*
*
!
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO OFF
END
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT "Enter port number: ":
END
*
INPUT PORT.NUM:
IF NOT(NUM(PORT.NUM)) THEN PORT.NUM = PORT
IF PORT.NUM EQ EMPTY THEN PORT.NUM = PORT
IF PORT.NUM EQ "KILL" THEN STOP
PORT.NUM = ("000":PORT.NUM) "R#3"
*
IF TERM.DISP AND PROC.FL THEN PRINT PORT.NUM:
*
!
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT "Enter port type: ":
END
*
INPUT PORT.TYPE:
IF PORT.TYPE EQ "KILL" THEN STOP
*
IF TERM.DISP AND PROC.FL THEN PRINT PORT.TYPE:
*
!
*
IF NOT(TERM.DISP) AND PROC.FL THEN
ECHO ON
END
*
WRITE PORT.TYPE ON SYS.FILE,"KBIL.RUNTYPE@":PORT.NUM
*
IF TERM.DISP OR NOT(PROC.FL) THEN
PRINT
PRINT
PRINT " Port number: ":PORT.NUM
PRINT "Type of port: ":PORT.TYPE
END
*
STOP
*
END
~SPEC~
STANDARD.FUNCTIONS.CALL
STANDARD.FUNCTIONS.CALL1
STANDARD.FUNCTIONS.CALL2
STANDARD.FUNCTIONS.CALL3
STANDARD.FUNCTIONS.CALL4
@ROUTINE.NAME
WORK.ORDERS.STANDARD
WORK.ORDERS.LINDSAY
WORK.ORDERS.VANILLA
ADD.ID
PRINTER.ON
CALC.CHARGES
CALC.RENT
GET.ICONV
MOD11.DIGIT
AUTO.LOADER
LOCK.ITEM
UNLOCK.ITEM
MDD.LOCK.ITEM
MDD.UNLOCK.ITEM
INPUT.DATA
PACK.NUMBER
UNPACK.NUMBER
~SPEC1~
DELINQ.CYCLE.SELECT
ASSIGN.GEO.DATA
DELINQ.MEMO
DELINQ.ACTION
LIST.DISC.MEMOS
STANDARD.FUNCTIONS.CALL
STANDARD.FUNCTIONS.CALL1
STANDARD.FUNCTIONS.CALL2
@ROUTINE.NAME
WORK.ORDERS.LINDSAY
WORK.ORDERS.8511FCI
WORK.ORDERS.STANDARD
WORK.ORDERS.WESTCOAST
WORK.ORDERS.VANILLA
PRINTER.ON
CALC.CHARGES
CALC.WKO.CHANGES
CALC.RENT
GET.ICONV
MOD11.DIGIT
AUTO.LOADER
LOCK.ITEM
UNLOCK.ITEM
MDD.LOCK.ITEM
MDD.UNLOCK.ITEM
INPUT.DATA
INPUT.DATA.SG
PACK.NUMBER
UNPACK.NUMBER
DELETE.ID
BILL.OTHER.ACT
ADD.ID
UPDATE.INDEXES
~STD.STRING~
BELL
LF
FF
CR
AM
VM
SVM
ESC
WHO
PORT
ACCT
OPSYS
GENERIC
CLS
CLL
CLB
RVB
RVE
RVH
AUX.ON
AUX.OFF
REC.ON
REC.OFF
COL.ON
COL.OFF
ZERO
ONE
TWO
EMPTY
TRUE
FALSE
TT
RSP
RSPBUF
PHANTOM.RUN
AUTO.RUNNER
~STD.STRING1~
BELL
LF
FF
CR
AM
VM
SVM
WHO
PORT
ACCT
OPSYS
GENERIC
CLS
CLL
CLB
RVB
RVE
RVH
AUX.ON
AUX.OFF
ZERO
ONE
TWO
EMPTY
TRUE
FALSE
TT
~STD.STRING2~
BELL
LF
FF
CR
AM
VM
SVM
WHO
PORT
ACCT
OPSYS
GENERIC
CLS
CLL
CLB
RVB
RVE
RVH
AUX.ON
AUX.OFF
~STD.STRING3~
BELL
LF
FF
CR
AM
VM
SVM
ESC
WHO
PORT
ACCT
OPSYS
GENERIC
CLS
CLL
CLB
RVB
RVE
RVH
AUX.ON
AUX.OFF
REC.ON
REC.OFF
COL.ON
COL.OFF
ZERO
ONE
TWO
EMPTY
TRUE
FALSE
TT
RSP
RSPBUF
PHANTOM.RUN
AUTO.RUNNER
~SYS.NEXT.INSTALL~
*PROGRAM: SYS.NEXT.INSTALL
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
OPEN "LOCKS" TO LCK.FILE ELSE STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.ID = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY; LCK.STAT = FALSE
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.ELP.MAX = 3600; LCK.TYPE = -8
*
SYS.PROG = "SYS.NEXT.INSTALL"; SYS.LOCT = "INSTALL"; EXP.LCK.TM = EMPTY
OPER = "SYS"
*
*
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PORT.TYPE = EMPTY; PROC.FL = TRUE
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PORT.TYPE ELSE PROC.FL = FALSE
IF TERM.DISP THEN PRINT PORT.TYPE
*
IF NOT(PROC.FL) THEN
DELETE SYS.FILE,"KBIL.RUNTYPE@":PORT
END
*
*
PORT.NUM = ("000":PORT) "R#3"
SYS.ID = "KBIL.RUNTYPE@":PORT.NUM
*
*
LOOP
LCK.FIL.ID = "SYS"; LCK.ITM.ID = SYS.ID
SAVE.SYS.ID = SYS.ID
$INCLUDE IBP SYS.INCL.LCK.ITM
WHILE LCK.STAT DO
IF SYSTEM(11) THEN LCK.TYPE = ZERO
REPEAT
*
READ PORT.TYPE FROM SYS.FILE,SYS.ID ELSE
READ PORT.TYPE FROM SYS.FILE,"KBIL.RUNTYPE" ELSE
LOOP
PRINT
PRINT "Enter port type (INSTALL or SINGLE): ":
INPUT PORT.TYPE:
WHILE NOT(INDEX("**KILL*INSTALL*SINGLE*","*":PORT.TYPE:"*",ONE)) DO REPEAT
IF NOT(INDEX("**KILL*","*":PORT.TYPE:"*",ONE)) THEN
WRITE PORT.TYPE ON SYS.FILE,SYS.ID
END
END
END
*
LOOP
LCK.FIL.ID = "SYS"; LCK.ITM.ID = "KBIL.":PORT.TYPE:".NEXT"
SAVE.PORT.ID = LCK.ITM.ID
$INCLUDE IBP SYS.INCL.LCK.ITM
WHILE LCK.STAT DO 
IF SYSTEM(11) THEN LCK.TYPE = ZERO
REPEAT
*
IF PORT.TYPE EQ EMPTY THEN PORT.TYPE = "INSTALL"
IF PORT.TYPE EQ "KILL" THEN PORT.TYPE = "INSTALL"
IF TERM.DISP THEN PRINT "Type of search run: ":PORT.TYPE
*
!
*
READ INSTALL.LIST FROM SYS.FILE,"KBIL.":PORT.TYPE:".NEXT" ELSE INSTALL.LIST = EMPTY
CONT = TRUE
*
* LIST NAME (LOADED FROM LISTS FILE)
* FILE NAME TO INSTALL TO/FROM
* RUN TYPE (DEV,TAPE,....)
* TAPE INSTALL RECORD
* BATCH STREAM TO SWITCH TO (INSTALL TO SINGLE, SINGLE TO INSTALL)
*
!
*
READ INST.LIST FROM SYS.FILE,"KBIL.":PORT.TYPE:".LIST" ELSE INST.LIST = EMPTY
READ INST.RUNT FROM SYS.FILE,"KBIL.":PORT.TYPE:".RUNTYPE" ELSE INST.RUNT = EMPTY
READ INST.TAPE FROM SYS.FILE,"KBIL.":PORT.TYPE:".TAPE" ELSE INST.TAPE = EMPTY
READ INST.FILE FROM SYS.FILE,"KBIL.":PORT.TYPE:".FILE" ELSE INST.FILE = EMPTY
*
NEXT.LIST = INSTALL.LIST<ONE,ONE>
NEXT.RUNT = INSTALL.LIST<ONE,3>
NEXT.TAPE = INSTALL.LIST<ONE,4>
NEXT.FILE = INSTALL.LIST<ONE,2>
NEXT.STRM = INSTALL.LIST<ONE,5>
IF NEXT.STRM EQ EMPTY THEN NEXT.STRM = PORT.TYPE
*
IF INSTALL.LIST EQ EMPTY THEN CONT = FALSE
*
DEL INSTALL.LIST<ONE>
WRITE INSTALL.LIST ON SYS.FILE,"KBIL.":PORT.TYPE:".NEXT"
*
!
*
* WRITE ITEM LIST
IF CONT THEN
*
IF NEXT.LIST NE EMPTY THEN
IF NEXT.LIST[ONE,ONE] EQ '"' THEN
NEXT.LIST = FIELD(NEXT.LIST,'"',TWO)
WRITE NEXT.LIST ON SYS.FILE,"KBIL.":NEXT.STRM:".LIST"
END ELSE
EXEC.VERB = "COPY LISTS ":NEXT.LIST:" (O)"
EXEC.IN = "(SYS KBIL.":NEXT.STRM:".LIST"
EXECUTE EXEC.VERB, //IN. < EXEC.IN
END
END
*
IF NEXT.RUNT NE EMPTY THEN
WRITE NEXT.RUNT ON SYS.FILE,"KBIL.":NEXT.STRM:".RUNTYPE"
END
*
IF NEXT.TAPE NE EMPTY THEN
WRITE NEXT.TAPE ON SYS.FILE,"KBIL.":NEXT.STRM:".TAPE"
END
*
IF NEXT.FILE NE EMPTY THEN
WRITE NEXT.FILE ON SYS.FILE,"KBIL.":NEXT.STRM:".FILE"
END
*
IF NEXT.STRM NE EMPTY THEN
PORT.TYPE = NEXT.STRM
WRITE PORT.TYPE ON SYS.FILE,"KBIL.RUNTYPE@":PORT.NUM
END
*
!
*
* NOT CONT
END ELSE
PORT.TYPE = "END"
WRITE PORT.TYPE ON SYS.FILE,"KBIL.RUNTYPE@":PORT.NUM
END
*
LCK.FIL.ID = "SYS"; LCK.ITM.ID = SAVE.PORT.ID
$INCLUDE IBP SYS.INCL.LCK.RELS
LCK.FIL.ID = "SYS"; LCK.ITM.ID = SYS.ID
$INCLUDE IBP SYS.INCL.LCK.RELS
*
IF PROC.FL THEN
* ULT ONLY
PROCWRITE PORT.TYPE
IF TERM.DISP THEN PRINT PORT.TYPE
END
*
STOP
*
END
~SYS.PORTTYPE~
*PROGRAM: SYS.PORTTYPE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PORT.TYPE = EMPTY; PROC.FL = TRUE
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PORT.TYPE ELSE PROC.FL = FALSE
IF TERM.DISP THEN PRINT PORT.TYPE
*
IF NOT(PROC.FL) THEN
DELETE SYS.FILE,"KBIL.RUNTYPE@":PORT
END
*
*
PORT.NUM = ("000":PORT) "R#3"
READ PORT.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":PORT.NUM ELSE
READ PORT.TYPE FROM SYS.FILE,"KBIL.RUNTYPE" ELSE
LOOP
PRINT
PRINT "Enter port type (INSTALL or SINGLE): ":
INPUT PORT.TYPE:
WHILE NOT(INDEX("**KILL*INSTALL*SINGLE*","*":PORT.TYPE:"*",ONE)) DO REPEAT
IF NOT(INDEX("**KILL*","*":PORT.TYPE:"*",ONE)) THEN
WRITE PORT.TYPE ON SYS.FILE,"KBIL.RUNTYPE@":PORT.NUM
END
END
END
*
IF PORT.TYPE EQ EMPTY THEN PORT.TYPE = "INSTALL"
IF PORT.TYPE EQ "KILL" THEN PORT.TYPE = "INSTALL"
IF TERM.DISP THEN PRINT "Type of search run: ":PORT.TYPE
*
!
*
IF PROC.FL THEN
* ULT ONLY
PROCWRITE PORT.TYPE
IF TERM.DISP THEN PRINT PORT.TYPE
END
*
STOP
*
END
~SYS.PROC.INSTALL~
*PROGRAM: SYS.PROC.INSTALL
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "SYS" TO SYS.FILE ELSE STOP
OPEN "MD" TO MDI.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PROC.BUFF = EMPTY; PROC.FL = TRUE
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFF ELSE PROC.FL = FALSE
*
IF TERM.DISP THEN PRINT PROC.BUFF
*
IF PROC.FL THEN
BEGIN CASE
CASE OPSYS EQ "U"
PROC.BUFF = TRIM(PROC.BUFF)
PROC.FILE = FIELD(PROC.BUFF," ",TWO)
PROC.NAME = FIELD(PROC.BUFF," ",3)
CASE OPSYS EQ "M"
PROC.FILE = PROC.BUFF<TWO>
PROC.NAME = PROC.BUFF<3>
CASE TRUE
PROC.BUFF = TRIM(PROC.BUFF)
PROC.FILE = FIELD(PROC.BUFF," ",TWO)
PROC.NAME = FIELD(PROC.BUFF," ",3)
END CASE
END ELSE
IF TERM.DISP THEN PRINT "Not from proc"
END
*
PORT.NUM = ("000":PORT) "R#3"
*
IF NOT(PROC.FL) THEN
PRINT
PRINT "Enter file name: ":; INPUT PROC.FILE
IF PROC.FILE EQ EMPTY THEN STOP
IF PROC.FILE EQ "KILL" THEN STOP
PRINT
PRINT "Enter Proc name: ":; INPUT PROC.NAME
IF PROC.NAME EQ EMPTY THEN STOP
IF PROC.NAME EQ "KILL" THEN STOP
END
IF PROC.FILE EQ EMPTY THEN STOP
IF PROC.FILE EQ "KILL" THEN STOP
IF PROC.NAME EQ EMPTY THEN STOP
IF PROC.NAME EQ "KILL" THEN STOP
*
PROC.VALID = TRUE
*
IF TERM.DISP THEN PRINT PROC.NAME:" in ":PROC.FILE:" ":
READ PROC.REC FROM MDI.FILE,PROC.NAME THEN
IF TERM.DISP THEN PRINT " on file ":
IF PROC.REC<ONE> NE "PQ" AND PROC.REC<ONE> NE "PQN" THEN
IF TERM.DISP THEN PRINT " not valid!"
PROC.VALID = FALSE
END ELSE
IF TERM.DISP THEN PRINT " valid."
END
PROC.ON.FILE = TRUE
END ELSE
PROC.ON.FILE = FALSE
PRINT " not on file."
END
*
IF PROC.VALID THEN
PROC.OUT = "PQN":AM:"[OUT.":PROC.FILE:" ":PROC.NAME:"]":AM
IF OPSYS EQ "M" THEN
PROC.OUT = PROC.OUT:"CX":AM:"RTN"
END ELSE
PROC.OUT = PROC.OUT:"X"
END
WRITE PROC.OUT ON MDI.FILE,PROC.NAME
END ELSE
PRINT "PROC is not valid!!!":BELL:
END
*
IF TERM.DISP THEN PRINT "Install ":PROC.NAME:" in ":PROC.FILE
*
!
*
IF PROC.FL THEN
BEGIN CASE
CASE OPSYS EQ "U"
PROC.BUFF = OPSYS:" ":PROC.FILE:" ":PROC.NAME
CASE OPSYS EQ "M"
PROC.BUFF<TWO> = PROC.FILE
PROC.BUFF<3>   = PROC.NAME
CASE TRUE
PROC.BUFF = OPSYS:" ":PROC.FILE:" ":PROC.NAME
END CASE
* ULT ONLY
PROCWRITE PROC.BUFF
IF TERM.DISP THEN PRINT PROC.BUFF
END
*
STOP
*
END
~SYS.RTNTYPE~
*PROGRAM: SYS.RTNTYPE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "SYS" TO SYS.FILE ELSE STOP
*
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY.":PORT,ONE ELSE
READV TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY",ONE ELSE TERM.DISP = TRUE
END
*
RTN.TYPE = EMPTY; PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD RTN.TYPE ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
IF TERM.DISP THEN PRINT RTN.TYPE
*
PORT.NUM = ("000":PORT) "R#3"
*
*
* IF NOT(PROC.FL) THEN
* DELETE SYS.FILE,"KBIL.RTNTYPE@":PORT.NUM
* END
*
*
READ RTN.TYPE FROM SYS.FILE,"KBIL.RTNTYPE@":PORT.NUM ELSE
PRINT
PRINT "Enter routine type: ":
INPUT RTN.TYPE:
IF NOT(INDEX("**KILL*","*":RTN.TYPE:"*",ONE)) THEN
WRITE RTN.TYPE ON SYS.FILE,"KBIL.RTNTYPE@":PORT.NUM
END
END
*
IF RTN.TYPE EQ EMPTY THEN RTN.TYPE = "ABORT"
IF RTN.TYPE EQ "KILL" THEN RTN.TYPE = "ABORT"
IF TERM.DISP THEN PRINT "Type of routine: ":RTN.TYPE
*
!
*
IF PROC.FL THEN
PROC.BUFFER<ONE> = RTN.TYPE
* ULT ONLY
PROCWRITE PROC.BUFFER
END
*
STOP
*
END
~TAPE.FLAG.MDD.ACCT~
*PROGRAM: TAPE.FLAG.MNDD.ACCT
*#
TERM = "R"
$INCLUDE IBP STANDARD.FUNCTIONS
*#
OPEN "MD" TO MDI.FILE ELSE STOP
*#
PRINT "ENTER TAPE.NUMBER: ":; INPUT TAPE.NUMBER
*#
READ TAPE.FILES FROM MDI.FILE,TAPE.NUMBER:"@":"TAPE.FILE.NUMBERS" ELSE STOP
*#
CONT1 =1 
LOOP
*#
CONT = 0
LOOP
PRINT "ENTER FILE NUMBER: ":; INPUT FILE.NUMBER
FILE.NUMBER = STR("0",4-LEN(FILE.NUMBER)):FILE.NUMBER
*#
LOCATE(FILE.NUMBER,TAPE.FILES,1;P.LOC;"AR") THEN
CONT = 0
END ELSE
CONT = 1
PRINT BELL:"FILE ":FILE.NUMBER:" WAS NOT FOUND!"
PRINT
END
WHILE CONT AND FILE.NUMBER NE "0000" DO REPEAT
*#
IF FILE.NUMBER EQ "" OR FILE.NUMBER EQ "0000" THEN CONT1 = 0
WHILE CONT1 DO
*#
OLD.P.FILE = "MD"
TAPE.CN = 2
CURR.CN = 0
*CURR.CN.MAX = DCOUNT(TAPE.FILE<1>,VM)
*#
PRINT
PRINT
PRINT "File.Name...... .Num * Items Tape.Name....."
PRINT
LOOP
CURR.CN.MAX = DCOUNT(TAPE.FILES<1>,VM)
CURR.CN = CURR.CN + 1
WHILE CURR.CN LE CURR.CN.MAX AND NOT(SYSTEM(11)) DO
FILE.NUM = TAPE.FILES<1,CURR.CN>
FILE.NAME = TAPE.FILES<2,CURR.CN>
FILE.OPTIONS = TAPE.FILES<3,CURR.CN>
FILE.ITEMS   = TAPE.FILES<4,CURR.CN>
FILE.TRUE    = TAPE.FILES<5,CURR.CN>
TEMP = FILE.OPTIONS
IF FILE.OPTIONS EQ "N" THEN TEMP = "-"
TEMP1 = FILE.TRUE
IF TEMP1 EQ FILE.NAME THEN TEMP1 = ""
PRINT FILE.NAME "L#15":" ":FILE.NUM "R#4":" ":TEMP:" ":FILE.ITEMS "R#5":" ":TEMP1 "L#15"
*#
REPEAT
PRINT
PRINT
CURR.CN = P.LOC
FILE.NUM = TAPE.FILES<1,CURR.CN>
FILE.NAME = TAPE.FILES<2,CURR.CN>
FILE.OPTIONS = TAPE.FILES<3,CURR.CN>
FILE.ITEMS   = TAPE.FILES<4,CURR.CN>
FILE.TRUE    = TAPE.FILES<5,CURR.CN>
TEMP = FILE.OPTIONS
IF FILE.OPTIONS EQ "N" THEN TEMP = "-"
TEMP1 = FILE.TRUE
IF TEMP1 EQ FILE.NAME THEN TEMP1 = ""
PRINT FILE.NAME "L#15":" ":FILE.NUM "R#4":" ":TEMP:" ":FILE.ITEMS "R#5":" ":TEMP1 "L#15"
PRINT
PRINT "ENTER OPTION (Y/N): ":; INPUT FILE.OPTIONS
*#
IF FILE.OPTIONS EQ "Y" OR FILE.OPTIONS EQ "N" THEN
IF FILE.OPTIONS EQ "Y" THEN
PRINT "ENTER DESTINATION:  ":; INPUT RSP
IF RSP EQ "" THEN RSP = FILE.NAME
IF RSP EQ "" THEN RSP = FILE.TRUE
TAPE.FILES<2,CURR.CN> = RSP
IF TAPE.FILES<5,CURR.CN> EQ "" THEN TAPE.FILES<5,CURR.CN> = RSP
END
TAPE.FILES<3,CURR.CN> = FILE.OPTIONS
WRITE TAPE.FILES ON MDI.FILE,TAPE.NUMBER:"@":"TAPE.FILE.NUMBERS"
END
*#
REPEAT
*#
END
*#
~TAPE.LISTWRITE~
*PROGRAM: TAPE.LISTWRITE
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "LISTS" TO LISTS.FILE ELSE STOP
OPEN "SYS" TO SYS.FILE ELSE STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
PROC.FL = TRUE; PROC.BUFFER = EMPTY
* PROC.FL = FALSE; * REV ONLY
* ULT ONLY
PROCREAD PROC.BUFFER ELSE PROC.FL = FALSE; PROC.BUFFER = EMPTY
IF NOT(PROC.FL) THEN
DELETE SYS.FILE,"KBIL.RUNTYPE"
DELETE SYS.FILE,"KBIL.TAPE"
DELETE SYS.FILE,"KBIL.FILE"
END
*
!
*
PRINT
PRINT "Enter the name of the list: ":
INPUT LIST.NAME:
PRINT
IF TERM.DISP THEN PRINT "The list name is ":LIST.NAME
*
!
*
PORT.NUM = ("000":PORT) "R#3"
*
READ PORT.TYPE FROM SYS.FILE,"KBIL.RUNTYPE@":PORT.NUM ELSE PORT.TYPE = "INSTALL"
IF TERM.DISP THEN PRINT "Port type is ":PORT.TYPE
*
READ RTN.TYPE FROM SYS.FILE,LIST.NAME:".RUNTYPE" ELSE RTN.TYPE = "PROG"
IF TERM.DISP THEN PRINT "Routine type is ":RTN.TYPE
*
!
*
READ RUN.TYPE FROM SYS.FILE,LIST.NAME:".RUNTYPE" ELSE
PRINT
PRINT "Enter the type of run (TAPE,COMM,DEV,OTHER,ABORT): ":
INPUT RUN.TYPE:
IF RUN.TYPE EQ EMPTY THEN STOP
IF RUN.TYPE EQ "KILL" THEN STOP
PRINT
WRITE RUN.TYPE ON SYS.FILE,LIST.NAME:".RUNTYPE"
END
*
IF TERM.DISP THEN PRINT "Type of run: ":RUN.TYPE
LIST.TYPE = "ABORT"
*
!
*
READ TAPE.ID FROM SYS.FILE,LIST.NAME:".TAPE" ELSE
PRINT
PRINT "Enter name of tape: ":
INPUT TAPE.ID:
IF TAPE.ID EQ EMPTY THEN STOP
IF TAPE.ID EQ "KILL" THEN STOP
PRINT
WRITE TAPE.ID ON SYS.FILE,LIST.NAME:".TAPE"
END
*
IF TERM.DISP THEN PRINT "Tape being processed: ":TAPE.ID
*
!
*
READ FILE.NAME FROM SYS.FILE,LIST.NAME:".FILE" ELSE
PRINT
PRINT "Enter the file to be processed: ":
INPUT FILE.NAME:
IF FILE.NAME EQ EMPTY THEN STOP
IF FILE.NAME EQ "KILL" THEN STOP
PRINT
WRITE FILE.NAME ON SYS.FILE,LIST.NAME:".FILE"
END
*
IF TERM.DISP THEN PRINT "File being processed: ":FILE.NAME
*
OPEN FILE.NAME TO ITEM.FILE ELSE
PRINT FILE.NAME:" file not found!":BELL
STOP
END
*
!
*
OPEN "IN.":FILE.NAME TO ININP.FILE ELSE STOP
OPEN "OUT.":FILE.NAME TO OUTINP.FILE ELSE STOP
OPEN "OLD.":FILE.NAME TO OLDINP.FILE ELSE STOP
*
BEGIN CASE
*
CASE PORT.TYPE EQ "SINGLE"
WRITE "Q":AM:"PROGRAMS":AM:"OUT.":FILE.NAME ON SYS.FILE,"OUT.FILE.":PORT.TYPE
WRITE "Q":AM:"PROGRAMS":AM:"IN.":FILE.NAME ON SYS.FILE,"IN.FILE.":PORT.TYPE
WRITE "Q":AM:"PROGRAMS":AM:"OLD.":FILE.NAME ON SYS.FILE,"OLD.FILE.":PORT.TYPE
*
CASE TRUE
*
WRITE "Q":AM:"PROGRAMS":AM:"OUT.":FILE.NAME ON SYS.FILE,"OUT.FILE"
WRITE "Q":AM:"PROGRAMS":AM:"IN.":FILE.NAME ON SYS.FILE,"IN.FILE"
WRITE "Q":AM:"PROGRAMS":AM:"OLD.":FILE.NAME ON SYS.FILE,"OLD.FILE"
*
END CASE
*
!
*
IF RUN.TYPE EQ "DEV" THEN
READ FILE.LIST FROM SYS.FILE,LIST.NAME:".LIST" ELSE 
READ FILE.LIST FROM LISTS.FILE,FILE.NAME THEN
WRITE FILE.LIST ON SYS.FILE,LIST.NAME:".LIST"
END ELSE FILE.LIST = EMPTY
END
WRITE FILE.LIST ON LISTS.FILE,TAPE.ID
END ELSE
READ FILE.LIST FROM LISTS.FILE,TAPE.ID ELSE FILE.LIST = EMPTY
END
*
IF FILE.LIST EQ EMPTY THEN
IF TERM.DISP THEN PRINT "The list is empty!"
END
*
!
*
PROG.LIST = EMPTY
CSEG.LIST = EMPTY
SUBR.LIST = EMPTY
PROC.LIST = EMPTY
OTHER.LIST = EMPTY
ITEM.LIST = EMPTY
CODE.LIST = EMPTY
DICT.LIST = EMPTY
RTN.TYPE = EMPTY
*
*
IF (RUN.TYPE EQ "TAPE" OR RUN.TYPE EQ "COMM") THEN
OPEN "BP.IMPORT" TO ITEM.FILE ELSE STOP
EXEC.VERB = "SSELECT BP.IMPORT"
END ELSE
IF FILE.LIST EQ EMPTY THEN
EXEC.VERB = "FORM-LIST LISTS ":FILE.NAME
END ELSE
EXEC.VERB = "FORM-LIST SYS ":LIST.NAME:".LIST"
END
END
*
IF TERM.DISP THEN PRINT EXEC.VERB
EXEC.TEXT = EMPTY; EXEC.PARAMS = ""
SEL.ERROR = ''
EXECUTE EXEC.VERB, //SELECT. > ITEM.ID.LIST, //OUT. > EXEC.TEXT
*
!
*
PRINT
LOOP
*
READNEXT ITEM.ID FROM ITEM.ID.LIST ELSE ITEM.ID = "@@@"
PRINT ITEM.ID "L#25":" ":
*
WHILE ITEM.ID NE "@@@" DO
*
ITEM.LIST<-ONE> = ITEM.ID
*
*
READV ATTR1 FROM ITEM.FILE,ITEM.ID,ONE THEN
ITEM.ON.FILE = TRUE
END ELSE
ITEM.ON.FILE = FALSE
ATTR1 = EMPTY
IF ITEM.ID[ONE,3] EQ "SH." THEN
ITEM.ON.FILE = TRUE
IF ITEM.ID[4,5] EQ "SUBR." THEN
ATTR1 = "SUBROUTINE ":ITEM.ID
END ELSE
ATTR1 = "*PROGRAM: ":ITEM.ID
END
END
END
*
IF ITEM.ON.FILE THEN
*
WRITE.FLAG = FALSE
*
***********
*
* ATTR1 = ITEM<1>
*
IF ATTR1[1,2] EQ "* " THEN
LOOP WHILE ATTR1[1,2] EQ "* " DO
ATTR1 = "*":ATTR1[3,9999]
REPEAT
WRITEV ATTR1 ON ITEM.FILE,ITEM.ID,ONE
END
*
RTN.TYPE = EMPTY
*
$INCLUDE IBP SYS.INCL.ITEM.TYPE
*
IF WRITE.FLAG THEN
*
EXEC.VERB = "COPY IN.":FILE.NAME:" ":ITEM.ID:" (O)"
EXEC.PARAMS = "(OLD.":FILE.NAME
EXEC.OUT = EMPTY
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS, //OUT. > EXEC.OUT
*
IF RUN.TYPE EQ "TAPE" OR RUN.TYPE EQ "COMM" THEN
EXEC.VERB = "COPY BP.IMPORT ":ITEM.ID:" (O)"
EXEC.PARAMS = "(IN.":FILE.NAME
EXEC.OUT = EMPTY
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS, //OUT. > EXEC.OUT
END
*
END
*
END; * Of read
*
PRINT
*
***********
*
REPEAT
*
*
PRINT
IF PROG.LIST NE EMPTY THEN CODE.LIST<-ONE> = PROG.LIST
IF SUBR.LIST NE EMPTY THEN CODE.LIST<-ONE> = SUBR.LIST
WRITE CODE.LIST ON LISTS.FILE,TAPE.ID:".RTNS"
IF CSEG.LIST NE EMPTY THEN CODE.LIST<-ONE> = CSEG.LIST
IF PROC.LIST NE EMPTY THEN CODE.LIST<-ONE> = PROC.LIST
*
WRITE CODE.LIST ON LISTS.FILE,TAPE.ID:".CODE"
WRITE ITEM.LIST ON LISTS.FILE,TAPE.ID:".LIST"
WRITE PROG.LIST ON LISTS.FILE,TAPE.ID:".PROG"
WRITE SUBR.LIST ON LISTS.FILE,TAPE.ID:".SUBR"
WRITE PROC.LIST ON LISTS.FILE,TAPE.ID:".PROC"
WRITE CSEG.LIST ON LISTS.FILE,TAPE.ID:".CSEG"
WRITE DICT.LIST ON LISTS.FILE,TAPE.ID:".DICT"
WRITE OTHER.LIST ON LISTS.FILE,TAPE.ID:".OTHER"
*
WRITE CODE.LIST ON SYS.FILE,LIST.NAME:".LIST"
*
WRITE LIST.TYPE ON SYS.FILE,LIST.NAME:".RTNTYPE"
WRITE LIST.TYPE ON SYS.FILE,"KBIL.RTNTYPE@":PORT.NUM
IF PROC.FL THEN
PROC.BUFFER<ONE> = LIST.TYPE
* ULT ONLY
PROCWRITE PROC.BUFFER
IF TERM.DISP THEN PRINT LIST.TYPE
END
*
*
STOP
*
END
~TAPE.LOAD.MDD.ACCT~
*PROGRAM: TAPE.LOAD.MDD.ACCT
*#
TEMP = "R"
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*
*#
OPEN "MD" TO MDI.FILE ELSE STOP
*#
PRINT "ENTER TAPE NUMBER: ":; INPUT TAPE.NUMBER
*#
READ TAPE.FILES FROM MDI.FILE,TAPE.NUMBER:"@":"TAPE.FILE.NUMBERS" ELSE STOP
*#
OLD.NUM = 0
EXECUTE "T-ATT 8192", //OUT. > EXEC.ATT
*#
EXECUTE "T-REW", //OUT. > EXEC.REW
*#
EXECUTE "T-FWD (1)", //OUT. > EXEC.FWD
*#
OLD.P.FILE = "MD"
TAPE.CN = 2
CURR.CN = 0
CURR.CN.MAX = DCOUNT(TAPE.FILES<1>,VM)
FOR A = 1 TO CURR.CN.MAX
TAPE.FILES<1,A> = STR("0",4-LEN(TAPE.FILES<1,A>)):TAPE.FILES<1,A>
NEXT A
*#
PRINT
PRINT
*#
LOOP
*#
CURR.CN = CURR.CN + 1
*#
WHILE CURR.CN LE CURR.CN.MAX DO
FILE.NUM = TAPE.FILES<1,CURR.CN>
FILE.NUM = STR("0",4-LEN(FILE.NUM)):FILE.NUM
FILE.NAME = TAPE.FILES<2,CURR.CN>
FILE.OPTIONS = TAPE.FILES<3,CURR.CN>
FILE.ITEMS   = TAPE.FILES<4,CURR.CN>
FILE.TRUE    = TAPE.FILES<5,CURR.CN>
TEMP = FILE.OPTIONS
IF TEMP NE "Y" THEN TEMP = "-"
TEMP1 = FILE.TRUE
IF TEMP1 = FILE.NAME THEN TEMP1 = ""
READ MD.ITEM FROM MDI.FILE,FILE.NAME ELSE MD.ITEM = "D"
IF MD.ITEM<1> EQ "Q" THEN TEMP1 = MD.ITEM<3>
PRINT FILE.NAME "L#15":" ":FILE.NUM "R#4":" ":TEMP:" ":FILE.ITEMS "R#5":" ":TEMP1 "L#15"
*#
IF FILE.OPTIONS EQ "Y" THEN
*#
EXECUTE "T-ATT 8192", //OUT. > EXEC.BCK
*#
IF FILE.NUM = OLD.NUM+1 THEN
*#
EXECUTE "T-REW", //OUT. > EXEC.REW
*#
EXECUTE "T-FWD (1)", //OUT. > EXEC.FWD
END
*#
PRINT
*TEMP = TRUE.NAME
TEMP = FILE.TRUE
IF TEMP EQ "" THEN TEMP = FILE.NAME
READ MD.ITEM FROM MDI.FILE,FILE.NAME ELSE MD.ITEM = "D"
IF MD.ITEM<1> EQ "Q" THEN TEMP = MD.ITEM<3>
EXEC.LINE = 'SEL-RESTORE ':FILE.NAME:' NE "':TEMP:'" (A,N,I,O)'
OLD.NUM = FILE.NUM
*#
EXEC.PARAMS = FILE.NUM
*#
EXEC.RESULTS = ""
*#
PRINT
PRINT EXEC.LINE
PRINT "File number: ":EXEC.PARAMS
PRINT "------------------------------------"
EXECUTE EXEC.LINE, //IN. < EXEC.PARAMS, //OUT. > EXEC.RESULTS
*#
LOOP WHILE LEN(EXEC.RESULTS) DO
*#
P.LINE = TRIM(EXEC.RESULTS<1>)
EXEC.RESULTS = DELETE(EXEC.RESULTS,1)
*#
P.FILE = FIELD(P.LINE," ",1)
P.NUM  = FIELD(P.LINE," ",2)
P.TEST = FIELD(P.LINE," ",3)
*#
NON.LINE = 1
IF NUM(P.NUM) AND NOT(LEN(P.TEST)) THEN
IF P.NUM GT 0 THEN
*#
NON.LINE = 0
P.NUM = STR("0",4-LEN(P.NUM)):P.NUM
LOCATE(P.NUM,TAPE.FILES,1;P.LOC;"AR") ELSE
FOR A = 1 TO 5
TAPE.FILES = INSERT(TAPE.FILES,A,P.LOC;"")
NEXT A
TAPE.FILES<1,P.LOC> = P.NUM
TAPE.FILES<3,P.LOC> = "N"
TAPE.FILE<4,P.LOC>  = 0
IF P.LOC LE CURR.CN THEN CURR.CN = CURR.CN + 1
CURR.CN.MAX = CURR.CN.MAX + 1
END
*#
TEMP = P.FILE
IF TEMP = "DL/ID" THEN
TEMP = OLD.P.FILE
END ELSE
TEMP = "DICT ":P.FILE
END
OLD.P.FILE = P.FILE
TAPE.FILES<5,P.LOC> = TEMP
FILE.TRUE = TEMP
IF TAPE.FILES<2,P.LOC> = "" THEN TAPE.FILES<2,P.LOC> = TEMP; FILE.NAME = TEMP
*#
END; *# OF P.NUM GT 0
END; *# OF NUM P.NUM
*#
IF NON.LINE THEN
IF P.LINE[1,1] EQ "[" THEN
TEMP = TRIM(FIELD(P.LINE,"]",2))
TEMP = FIELD(TEMP," ",1)
IF NUM(TEMP) THEN TAPE.FILES<4,CURR.CN> = TEMP
END
END
*#
*PRINT P.LINE
*#
WRITE TAPE.FILES ON MDI.FILE,TAPE.NUMBER:"@":"TAPE.FILE.NUMBERS"
*#
REPEAT
*#
WRITE TAPE.FILES ON MDI.FILE,TAPE.NUMBER:"@":"TAPE.FILE.NUMBERS"
END; *# OF OPTIONS IS 'Y'
*#
REPEAT
*#
END
~ULT.QPT.WRITE~
*PROGRAM: MDD.QPT.WRITE
*
*
*AUTHOR: DAVID HORSMAN
*
* ULTIMATE ONLY
*
* PROGRAM WRITES A PROC THAT EDITS MD FILE ENTRY (FILE.NAME) AND POINTS INTO
*   filename,accoutname.filename FOR THE DATA AREA
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
PRINT
PRINT "ENTER BP FILE NAME (BP.UTL): ":; INPUT BP.FILE.NAME
IF BP.FILE.NAME EQ "" THEN BP.FILE.NAME = "BP.UTL"
*
PRINT "ENTER LIST NAME IN MD (FILES): ":; INPUT LIST.NAME
IF LIST.NAME EQ "" THEN LIST.NAME = "FILES"
*
PRINT
PRINT "ENTER PROC NAME (QPNTALLF): ":; INPUT PROC.NAME
IF PROC.NAME EQ "" THEN PROC.NAME = "QPNTALLF"
*
PRINT
PRINT "ENTER ACCOUNT TO POINT AT (PROGRAMS): ":; INPUT ACCOUNT.NAME
IF ACCOUNT.NAME EQ "" THEN ACCOUNT.NAME = "PROGRAMS"
*
FILE.NAME.PREFIX = ACCT:"."
PRINT "ENTER FILE NAME PREFIX (":FILE.NAME.PREFIX:", NONE for blank)": ":; INPUT FILE.NAME.PREFIX
IF FILE.NAME.PREFIX EQ "" THEN FILE.NAME.PREFIX = ACCT:"."
IF FILE.NAME.PREFIX EQ "NONE" THEN FILE.NAME.PREFIX = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
OPEN "",BP.FILE.NAME TO BP.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,LIST.NAME ELSE STOP
*
PROC1 = "PQN":AM:"C":AM:"C ":PROC.NAME:" ":ACCT:" ":FILE.NAME.PREFIX:AM:"C":AM:"C ":OCONV(DATE(),"D2"):AM:"C":AM
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
*FNAME = FIELD(FILE.LIST<1>," ",3)
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF FILE.NAME[1,1] NE "*" THEN
IF INDEX(FNAME,"BP",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HED DICT ':FNAME:' ':FNAME:AM:'HSTON':AM
PROC1 = PROC1:'HDE999<':AM:'HF<':AM
PROC1 = PROC1:'HI<':AM:'HQ<':AM:'H':ACCOUNT.NAME:'<':AM:'H':FNAME:",":FILE.NAME.PREFIX:FNAME:'<':AM:'H<':AM:'HFI<':AM:'PP':AM
END
END
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,PROC.NAME
WRITE PROC1 ON BP.FILE,PROC.NAME
*
STOP
END
*
~ULT.TO.TAPE.PROCWRITE~
*PROGRAM: ULT.TO.TAPE.PROCWRITE
*
$INCLUDE IBP STANDARD.FUNCTIONS
PROMPT ""; CRLF = CR:LF; DOSNUM = 47; DOSLTH = 0; DOSITEM = ""
PROC1 = ""
*
OPEN "","MD" TO MDI.FILE ELSE STOP
READ FILE.LIST FROM MDI.FILE,"FILES" ELSE STOP
*
PROC1 = "PQN":AM
*
FILE.LIST = DELETE(FILE.LIST,1,0,0)
LOOP
FNAME = FILE.LIST<1>
WHILE FILE.LIST NE "" DO
*
IF FNAME[1,1] NE "*" THEN
IF INDEX(FNAME,"BP",1) EQ 0 AND INDEX(FNAME,"MACRO",1) EQ 0 THEN
PROC1 = PROC1:'C':AM:'HT-DUMP DICT ':FNAME:AM
PROC1 = PROC1 :'PP':AM
END
PROC1 = PROC1:'C':AM:'HT-DUMP ':FNAME:AM:'PP':AM:'C':AM:'C':AM
END
FILE.LIST = DELETE(FILE.LIST,1,0,0)
REPEAT
*
PROC1 = PROC1:'C':AM:'C':AM:'C':AM:'X':AM
*
WRITE PROC1 ON MDI.FILE,"TDUMPALLF"
*
STOP
END
*
~~
ADD.ID
AUTO.LOADER
CALC.RENT
INPUT.DATA
LOCK.ITEM
UNLOCK.ITEM
WORK.ORDERS.8511FCI
WORK.ORDERS.LINDSAY
WORK.ORDERS.STANDARD
WORK.ORDERS.VANILLA
WORK.ORDERS.WESTCOAST
