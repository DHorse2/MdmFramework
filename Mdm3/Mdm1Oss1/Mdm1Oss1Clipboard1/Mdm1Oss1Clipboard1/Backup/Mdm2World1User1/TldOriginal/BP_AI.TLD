~AI.ADD.BOX~
SUBROUTINE AI.ADD.BOX(AIX.FILE,LCK.FILE,CNT.FILE,PAR.FILE,SVC.FILE,DVC$ADDRESS,DVC.ID,DVC$FUNCS,SERVICES,SVC.CHANNELS,TEXT,HANDLER.DOWN,SYS.PRNT,LCK.STAT)
*
*      Add an address to the addressable interface cross reference...
*
!
SRC.BEG="@_@:BEG"
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
SRC.SYS="@_@:SYS"
*
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.ADD.BOX"; SYS.LOCT = EMPTY
LCK.CLASS = 1; LCK.TYPE = -3
LCK.ID = ""; LCK = ""; LCK.STAT = ""
*
SYS.EQU="@_@:EQU"
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
*
!
*
RETURN
*
SRC.VAR="@_@:VAR"
*
SYS.ID = FIELD(DVC$ADDRESS,"*",1)
GROUP = FIELD(DVC$ADDRESS,"*",2)
BOXNUM = FIELD(DVC$ADDRESS,"*",3)
AIX.ID = SYS.ID:"*":GROUP
*
!
*
SRC.START = "@_@:START"
*
START: *
*
LCK.TYPE = 0
CALL SYS.ITM.LCK("AIX",AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
LCK.STAT = LCK.STAT
IF LCK.STAT THEN TEXT = "file locking failure"; RETURN
*
DVC.SVC.ID = ""; DVC.BOX.FLAG = ""; DVC.CHANNELS = ""; DVC.PARENTALS = ""
DVC.EVENT.FLAG = ""; DVC.REMOTE.FLAG = ""; DVC.STEREO.FLAG = ""; DVC.RESERVED.FLAG = ""
*
SRC.MAIN = "@_@:MAIN"
*
MAIN: *
*
SV = 1
LOOP SERVICE = SERVICES<1,1,SV> UNTIL SERVICE = "" DO
IF SVC.CHANNELS = "" THEN
READ SVC.CHANNELS FROM PAR.FILE,"SVC.CHANNELS" ELSE
PRINT @(0,23):CLL:"building table of services and channel numbers...":
CALL LOAD.CHANNEL.NUMBERS(PAR.FILE,SVC.FILE,SVC.CHANNELS,SYS.PROG,LCK.STAT)
PRINT @(0,23):CLL:
END
IF SVC.CHANNELS = "" THEN SVC.CHANNELS = "???"
END
LOCATE SERVICE IN SVC.CHANNELS<1> BY "AL" SETTING LOC THEN
DVC.SVC.ID<1,1,-1> = SERVICE
SV1 = 1
LOOP CHANNEL = SVC.CHANNELS<3,LOC,SV1> UNTIL CHANNEL = "" DO
PARENTAL = SVC.CHANNELS<4,LOC,SV1>
IF PARENTAL = "Y" THEN
LOCATE "P" IN DVC$FUNCS<1> SETTING FUNC.LOC ELSE PARENTAL = ""
END
LOCATE CHANNEL IN DVC.CHANNELS<1,1> BY "AR" SETTING SV2 ELSE
IF NOT(DVC.BOX.FLAG) THEN
DVC.BOX.FLAG = 1
LOCATE "R" IN DVC$FUNCS<1> SETTING FUNC.LOC THEN DVC.REMOTE.FLAG = 1
LOCATE "S" IN DVC$FUNCS<1> SETTING FUNC.LOC THEN DVC.STEREO.FLAG = 1
LOCATE "X" IN DVC$FUNCS<1> SETTING FUNC.LOC THEN DVC.RESERVED.FLAG = 1
END
INS CHANNEL BEFORE DVC.CHANNELS<1,1,SV2>
INS PARENTAL BEFORE DVC.PARENTALS<1,1,SV2>
END
SV1 = SV1+1
REPEAT
END
SV = SV+1
REPEAT
*
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
LOCATE BOXNUM IN AIX$BOX<1> BY "AR" SETTING VC ELSE
INS "" BEFORE AIX$BOX<1,VC>
INS "" BEFORE AIX$DVC.ID<1,VC>
INS "" BEFORE AIX$SVC.ID<1,VC>
INS "" BEFORE AIX$BOX.FLAG<1,VC>
INS "" BEFORE AIX$CHAN.FLAG<1,VC>
INS "" BEFORE AIX$PC.FLAG<1,VC>
INS "" BEFORE AIX$EVENT.FLAG<1,VC>
INS "" BEFORE AIX$REMOTE.FLAG<1,VC>
INS "" BEFORE AIX$STEREO.FLAG<1,VC>
INS "" BEFORE AIX$RESERVED.FLAG<1,VC>
END
IF AIX$DVC.ID<1,VC> # "" AND AIX$DVC.ID<1,VC> # DVC.ID THEN
TEXT = "address in use"; RETURN
END
AIX$BOX<1,VC> = BOXNUM
AIX$DVC.ID<1,VC> = DVC.ID
AIX$SVC.ID<1,VC> = DVC.SVC.ID
AIX$BOX.FLAG<1,VC> = DVC.BOX.FLAG
AIX$CHAN.FLAG<1,VC> = DVC.CHANNELS
AIX$PC.FLAG<1,VC> = DVC.PARENTALS
AIX$EVENT.FLAG<1,VC> = DVC.EVENT.FLAG
AIX$REMOTE.FLAG<1,VC> = DVC.REMOTE.FLAG
AIX$STEREO.FLAG<1,VC> = DVC.STEREO.FLAG
AIX$RESERVED.FLAG<1,VC> = DVC.RESERVED.FLAG
MATWRITE AIX ON AIX.FILE,AIX.ID
AIW.ID = ""
CALL SYS.ITM.RLS("AIX",AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
* CALL AI.BOX.COMMAND(AIX.FILE,CNT.FILE,PAR.FILE,DVC$ADDRESS,AIW.ID,HANDLER.DOWN,SYS.PROG,LCK.STAT)
RETURN
!
END
~AI.ASSIGN.PROM~
SUBROUTINE AI.ASSIGN.PROM(AIX.FILE,LCK.FILE,CNT.FILE,PAR.FILE,DVC.ID,NUM.DEVICES,ADDRESS.LIST,TEXT,SYS.PRNT,STAT)
*
*      Add addresses for new inventory devices to the addressable interface
*      cross reference...
*
!
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.ASSIGN.PROM"; SYS.LOCT = EMPTY
!
STAT = 0
LCK.TYPE = 0
CALL SYS.ITM.LCK("CNT","AI.HIGH",LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
STAT = LCK.STAT
IF STAT THEN TEXT = "file locking failure"; RETURN
READ AI.MISC FROM PAR.FILE,"AI.MISCELLANEOUS" ELSE
TEXT = "miscellaneous addr interface parameters missing"; GOTO UNLOCK
END
READ AI.HIGH FROM CNT.FILE,"AI.HIGH" ELSE AI.HIGH = AI.MISC<2>; AI.HIGH<1,3> = AI.HIGH<1,3>-1
SYS.ID = AI.HIGH<1,1>
GROUP = AI.HIGH<1,2>
BOXNUM = AI.HIGH<1,3>
PRIOR.AIX.ID = ""
ADDRESS.LIST = ""
REPETITIONS = NUM.DEVICES
DVC.ID.LNG = LEN(NUM.DEVICES)
DVC.ID.PRE = DVC.ID[1,LEN(DVC.ID)-DVC.ID.LNG]
DVC.ID.NUM = DVC.ID[LEN(DVC.ID.PRE)+1,DVC.ID.LNG]
TMP = DVC.ID.PRE[LEN(DVC.ID.PRE),1]
IF TMP MATCHES "1N" THEN
DVC.ID.NUM = TMP:DVC.ID.NUM
DVC.ID.LNG = DVC.ID.LNG+1
DVC.ID.PRE = DVC.ID.PRE[1,LEN(DVC.ID.PRE)-1]
END
LOOP
BOXNUM = BOXNUM+1
MOD8 = REM(BOXNUM,8)
IF NOT(MOD8) THEN BOXNUM = BOXNUM+1; * do not allow every 8th box number
IF BOXNUM > 144 THEN BOXNUM = 1; GROUP = GROUP+1
IF GROUP > 1023 THEN SYS.ID = SYS.ID+1; GROUP = 0
AIX.ID = SYS.ID:"*":GROUP
IF AIX.ID # PRIOR.AIX.ID THEN
IF PRIOR.AIX.ID # "" THEN MATWRITE AIX ON AIX.FILE,PRIOR.AIX.ID
PRIOR.AIX.ID = AIX.ID
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
END
LOCATE BOXNUM IN AIX$BOX<1> BY "AR" SETTING VC ELSE
INS BOXNUM BEFORE AIX$BOX<1,VC>
INS "" BEFORE AIX$DVC.ID<1,VC>
INS "" BEFORE AIX$SVC.ID<1,VC>
INS "" BEFORE AIX$BOX.FLAG<1,VC>
INS "" BEFORE AIX$CHAN.FLAG<1,VC>
INS "" BEFORE AIX$PC.FLAG<1,VC>
INS "" BEFORE AIX$EVENT.FLAG<1,VC>
END
AIX$DVC.ID<1,VC> = DVC.ID
ADDRESS.LIST<-1> = SYS.ID:"*":GROUP:"*":BOXNUM
REPETITIONS = REPETITIONS-1
WHILE REPETITIONS > 0 DO
DVC.ID.NUM = DVC.ID.NUM+1
LOOP UNTIL LEN(DVC.ID.NUM) = DVC.ID.LNG DO DVC.ID.NUM = "0":DVC.ID.NUM REPEAT
DVC.ID = DVC.ID.PRE:DVC.ID.NUM
REPEAT
IF PRIOR.AIX.ID # "" THEN MATWRITE AIX ON AIX.FILE,PRIOR.AIX.ID
AI.HIGH<1,1> = SYS.ID
AI.HIGH<1,2> = GROUP
AI.HIGH<1,3> = BOXNUM
WRITE AI.HIGH ON CNT.FILE,"AI.HIGH"
*
UNLOCK: *
CALL SYS.ITM.LCK("CNT","AI.HIGH",LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
RETURN
!
END
~AI.BOX.COMMAND~
SUBROUTINE AI.BOX.COMMAND(AIX.FILE,CNT.FILE,PAR.FILE,BOX.ADDRESS,AIW.ID,HANDLER.DOWN,SYS.PRNT,STAT)
*
*      Send the box status to the encoder...
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP AIW.DIM
$INCLUDE IBP AIW.EQUATES
*
VS = "(1.0)"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.BOX.COMMAND"; SYS.LOCT = EMPTY
*
SYS.ID = FIELD(BOX.ADDRESS,"*",1)
GROUP = FIELD(BOX.ADDRESS,"*",2)
BOXNUM = FIELD(BOX.ADDRESS,"*",3)
AIX.ID = SYS.ID:"*":GROUP
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
MAT AIW = ""
BOX.FLAG = 0; CHAN.FLAG = ""; PC.FLAG = ""; EVENT.FLAG = ""
REMOTE.FLAG = 0; STEREO.FLAG = 0; RESERVED.FLAG = 0
SVC.ID = ""; DVC.ID = ""
LOCATE BOXNUM IN AIX$BOX<1> BY "AR" SETTING VC THEN
BOX.FLAG = AIX$BOX.FLAG<1,VC>
CHAN.FLAG = AIX$CHAN.FLAG<1,VC>
PC.FLAG = AIX$PC.FLAG<1,VC>
EVENT.FLAG = AIX$EVENT.FLAG<1,VC>
REMOTE.FLAG = AIX$REMOTE.FLAG<1,VC> * 2
STEREO.FLAG = AIX$STEREO.FLAG<1,VC> * 4
RESERVED.FLAG = AIX$RESERVED.FLAG<1,VC> * 8
SVC.ID = AIX$SVC.ID<1,VC>
DVC.ID = AIX$DVC.ID<1,VC>
END
*
PAR.ID = "BARKER.CHANNELS"; BARKER.REFRESH = 1; OVC = 1; MAT AIW = ""
LOOP
READ COMPONENTS FROM PAR.FILE,PAR.ID ELSE COMPONENTS = ""
CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PROG,STAT)
MLE.COMM = 4
VC = 1
LOOP MLE.NUM = CHANNEL.MLES<1,VC> UNTIL MLE.NUM = "" DO
CHANNEL = 0; PARENTAL = 0; EVENT = 0
IF BARKER.REFRESH THEN BOX.COMM = BOX.FLAG+REMOTE.FLAG+STEREO.FLAG+RESERVED.FLAG ELSE
LOCATE MLE.NUM IN CHAN.FLAG<1,1> BY "AR" SETTING SV THEN
CHANNEL = 2
PARENTAL = PC.FLAG<1,1,SV>
IF PARENTAL = "Y" THEN PARENTAL = 4 ELSE PARENTAL = 0
EVENT = EVENT.FLAG<1,1,SV>
IF EVENT = "Y" THEN EVENT = 8 ELSE EVENT = 0
END
BOX.COMM = BOX.FLAG+CHANNEL+PARENTAL+EVENT
END
AIW$MLE.NUM<1,OVC> = MLE.NUM
AIW$MLE.COMM<1,OVC> = MLE.COMM
AIW$BOX.COMM<1,OVC> = BOX.COMM
AIW$SYS.ID<1,OVC> = SYS.ID
AIW$GROUP<1,OVC> = GROUP
AIW$BOX<1,OVC> = BOXNUM
AIW$DVC.ID<1,OVC> = DVC.ID
AIW$SVC.ID<1,OVC> = SVC.ID
OVC = OVC+1
VC = VC+1
REPEAT
WHILE BARKER.REFRESH  DO
BARKER.REFRESH = ""
PAR.ID = "COMPONENTS"
REPEAT
CALL AI.WRITE.COMMAND(MAT AIW,AIW.ID,HANDLER.DOWN,SYS.PROG,STAT)
RETURN
!
END
~AI.CHANNEL.DN~
SUBROUTINE AI.CHANNEL.DN(TEXT,ERR.DISP.ONLY,ERR.CLB,COM.FILE,CNT.FILE,PAR.FILE,LCK.FILE,CO.DATA,CHANNEL.MLES,DOWNED.CHANNELS.CHANGED,AI.CODE,MAT COM.AI,MAT CNT.TST,UP.ALL.CHANNELS,OPER,FAST.DISPLAY,RUN.TYPE,LCK.TYPE,STL,MAT COM.AIHERR,SYS.PRNT,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "920412 NEW"
VS = "920412 NEW (1.0)"
*
! System Control
*
* System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CHANNEL.DN"; SYS.LOCT = EMPTY
SYS.APPL.LOC = ONE
AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE; DISP.ONLY = FALSE
FUNC = "DC"
CO.NAME = CO.DATA<ONE,ONE,ONE>
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.ERR.INIT
*
**FAST.DISPLAY = FALSE
CHAN.ALL = TRUE
* IF OPER.STAT THEN STOP
OPER.DISP = TRUE
OPER.LN = 3; OPER.CL = 31; OPER.DESC.LN = 3; OPER.DESC.CL = 49
OPER.DESC.FMT = "L#15"; OPER.STAT = EMPTY; OPER.DISP = TRUE
OPER.RVB = TRUE; OPER.TEXT = "Operator: "
OPER.POSN = EMPTY
*
!
*
DOWN.CHANNELS: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Down Channels" "L#19":
*
LCK.ITM = TRUE; LCK.RELS = FALSE
*
!
*
ALREADY.DISPLAYED = EMPTY
HEADEND = EMPTY; COMPONENTS.DFLT = EMPTY
*
*960510*DGH**: * Start of LOOP * Main 1
*960510*DGH**
*960510*DGH*LOOP
*
GOSUB LOAD.TITLE; * : *
*
GOSUB READ.STL; * : *
*
!
*
LOOP
*
STATUS.CYCLE = FALSE
GOSUB DISPLAY.STATUS; * : *
*
GOSUB INTFC.MESSAGES
*
*
ERR.TEXT = "Enter channel number(s) to down (<cr> to end): "
PRINT @(ZERO,21):CLL:ERR.TEXT:
OVC = ONE; COLM = LEN(ERR.TEXT) + 3
ERR.TEXT = "Enter the reason: "
PRINT @(ZERO,22):CLL:@(COLM - LEN(ERR.TEXT) - 3,22):ERR.TEXT:
*
LOOP
*
PRINT @(COLM,21):CLL:
INPUT CHANNEL:
*
IF CHANNEL NE EMPTY THEN
IF CHANNEL EQ "KILL" THEN STAT = 999; RETURN
*
IF CHANNEL EQ "RE" THEN
***STATUS.CYCLE = FALSE
***GOSUB DISPLAY.STATUS; * : *
GOTO DOWN.CHANNELS; * : *
*
END ELSE
* not "RE"
*
HEADEND = FIELD(CHANNEL,"*",ONE)
CHANNEL = FIELD(CHANNEL,"*",TWO)
IF NUM(HEADEND) AND CHANNEL EQ EMPTY THEN CHANNEL = HEADEND; HEADEND = EMPTY
CHANNEL = ("000":CHANNEL) "R#3"
CHANNEL = HEADEND:"*":CHANNEL
IF HEADEND EQ EMPTY THEN
TEXT<-ONE> = "You did not enter a Headend (HE*Ch#)."
TEXT<-ONE> = "Valid Headend are (":HEADENDS:") for HE*Ch#..."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
END; * Of channel not empty
*
IF CHANNEL NE EMPTY THEN
*
* LOCATE CHANNEL IN CHANNEL.MLES<ONE> BY "AR" SETTING CHAN.LOC THEN CHANNEL.FOUND = TRUE ELSE CHANNEL.FOUND = FALSE
*
LOCATE CHANNEL IN STL<STATUS.CHANNEL> BY "AR" SETTING CHAN.LOC THEN CHANNEL.FOUND = TRUE ELSE CHANNEL.FOUND = FALSE
*
IF NOT(CHANNEL.FOUND) THEN
TEXT<-ONE> = CHANNEL:" is not a valid channel number."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END ELSE
*
LOCATE CHANNEL IN STL<STATUS.CHANNEL> BY "AL" SETTING CHAN.LOC THEN CHANNEL.FOUND = TRUE ELSE CHANNEL.FOUND = FALSE
*
IF CHANNEL.FOUND THEN
IF STL<STATUS.CHAN.STAT,CHAN.LOC> NE EMPTY THEN
TEXT<-ONE> = CHANNEL:" is already down."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
PRINT @(COLM,22):; INPUT REASON:
* AIW$MLE.NUM<ONE,OVC> = CHANNEL
STL<STATUS.CHAN.STAT,CHAN.LOC> = REASON
STL<STATUS.CHECKED,CHAN.LOC> = DATE():"*":TIME()
DOWNED.CHANNELS.CHANGED = ONE
OVC = OVC + ONE
* HANDLER.COMMAND<-ONE> = FUNC
COLM = COLM + 7
END; * found
*
END; * found
*
END; * not empty
*
END; * not "RE"
*
UNTIL CHANNEL EQ EMPTY OR COLM GT 75 OR CHANNEL EQ "RE" DO
*
REPEAT
*
UNTIL CHANNEL EQ EMPTY DO
*
REPEAT
*
*
WRITE STL ON COM.FILE,STL.ID
*
CALL SYS.ITM.RLS("COM",STL.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
*
*960510*DGH*UNTIL CHANNEL EQ EMPTY DO
*960510*DGH**
*960510*DGH*REPEAT
*960510*DGH**
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN
*
!
*
READ.STL: *
*
$INCLUDE IBP AI.INCL.INTFC.STL
*
RETURN
*
!
*
DISPLAY.STATUS: *
*
!
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Display Status" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.INCL.INTFC.DISPLAY
*
RETURN
*
!
*
*DISPLAY.TITLE: *
*
$INCLUDE IBP AI.CNTRL.UTIL.DISP.HDR
*
!
*
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
IF STAT EQ 999 THEN AI.STATUS = 999
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
END
~AI.CHANNEL.UP~
SUBROUTINE AI.CHANNEL.UP(TEXT,ERR.DISP.ONLY,ERR.CLB,COM.FILE,CNT.FILE,PAR.FILE,LCK.FILE,CO.DATA,CHANNEL.MLES,DOWNED.CHANNELS.CHANGED,AI.CODE,MAT COM.AI,MAT CNT.TST,UP.ALL.CHANNELS,OPER,FAST.DISPLAY,RUN.TYPE,LCK.TYPE,STL,MAT COM.AIHERR,SYS.PRNT,STAT)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "920412 NEW"
VS = "920412 NEW (1.0)"
*
! System Control
*
* System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CHANNEL.UP"; SYS.LOCT = EMPTY
SYS.APPL.LOC = ONE
AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE; DISP.ONLY = FALSE
FUNC = "UC"
CO.NAME = CO.DATA<ONE,ONE,ONE>
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.ERR.INIT
*
**FAST.DISPLAY = FALSE
CHAN.ALL = TRUE
* IF OPER.STAT THEN STOP
OPER.DISP = TRUE
OPER.LN = 3; OPER.CL = 31; OPER.DESC.LN = 3; OPER.DESC.CL = 49
OPER.DESC.FMT = "L#15"; OPER.STAT = EMPTY; OPER.DISP = TRUE
OPER.RVB = TRUE; OPER.TEXT = "Operator: "
OPER.POSN = EMPTY
*
!
*
UP.CHANNELS: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Up Channels" "L#19":
*
LCK.ITM = TRUE; LCK.RELS = FALSE
*
!
*
ALREADY.DISPLAYED = EMPTY
HEADEND = EMPTY; COMPONENTS.DFLT = EMPTY
*
*960510*DGH**: * Start of LOOP * Main 1
*960510*DGH**
*960510*DGH*LOOP
*
GOSUB LOAD.TITLE; * : *
*
GOSUB READ.STL; * : *
*
!
*
LOOP
*
STATUS.CYCLE = FALSE
GOSUB DISPLAY.STATUS; * : *
*
GOSUB INTFC.MESSAGES
*
*
IF NOT(UP.ALL.CHANNELS) THEN
ERR.TEXT = "Enter channel number(s) to up (<cr> to end): "
PRINT @(ZERO,22):CLL:ERR.TEXT:
END
OVC = ONE; COLM = LEN(ERR.TEXT) + 3
*
!
*
LOOP
*
IF UP.ALL.CHANNELS THEN
LOOP
CHANNEL = STL<STATUS.CHANNEL,UP.ALL.CHANNELS>
TMP = STL<STATUS.CHAN.STAT,UP.ALL.CHANNELS>
UP.ALL.CHANNELS = UP.ALL.CHANNELS + ONE
UNTIL (CHANNEL EQ EMPTY) OR (TMP) DO
REPEAT
END ELSE
*
PRINT @(COLM,22):CLL:
INPUT CHANNEL:
IF CHANNEL NE EMPTY THEN
IF CHANNEL EQ "KILL" THEN STAT = 999; RETURN
*
IF CHANNEL EQ "RE" THEN
***STATUS.CYCLE = FALSE
***GOSUB DISPLAY.STATUS; * : *
GOTO UP.CHANNELS; * : *
*
END ELSE
* not "RE"
*
HEADEND = FIELD(CHANNEL,"*",ONE)
CHANNEL = FIELD(CHANNEL,"*",TWO)
IF NUM(HEADEND) AND CHANNEL EQ EMPTY THEN CHANNEL = HEADEND; HEADEND = EMPTY
CHANNEL = ("000":CHANNEL) "R#3"
CHANNEL = HEADEND:"*":CHANNEL
*
IF HEADEND EQ EMPTY THEN
TEXT<-ONE> = "You did not enter a Headend (HE*Ch#)."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
END; * of not "RE"
END; * of not empty
* END
END; * Of not up all
*
IF CHANNEL NE EMPTY AND CHANNEL NE "RE" THEN
*
LOCATE CHANNEL IN STL<STATUS.CHANNEL> BY "AR" SETTING CHAN.LOC THEN CHANNEL.FOUND = TRUE ELSE CHANNEL.FOUND = FALSE
*
IF CHANNEL.FOUND THEN
IF NOT(UP.ALL.CHANNELS) AND STL<STATUS.CHAN.STAT,CHAN.LOC> EQ EMPTY THEN
TEXT<-ONE> = CHANNEL:" is not down."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END ELSE
STL<STATUS.CHAN.STAT,CHAN.LOC> = EMPTY
COLM = COLM + 7
STL<STATUS.CHECKED,CHAN.LOC> = DATE():"*":TIME()
* HANDLER.COMMAND<-ONE> = FUNC
DOWNED.CHANNELS.CHANGED = ONE
OVC = OVC + ONE
* AIW$MLE.NUM<ONE,OVC> = CHANNEL
END
*
END ELSE
TEXT<-ONE> = CHANNEL:" is not in system."
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
*
END; * not "RE"
*
UNTIL CHANNEL EQ EMPTY OR COLM GT 75 OR CHANNEL EQ "RE" DO
*
REPEAT
*
UNTIL CHANNEL EQ EMPTY DO
*
REPEAT
*
*
WRITE STL ON COM.FILE,STL.ID
*
CALL SYS.ITM.RLS("COM",STL.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
*
*960510*DGH*UNTIL CHANNEL EQ EMPTY DO
*960510*DGH**
*960510*DGH*REPEAT
*960510*DGH**
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN
*
!
*
READ.STL: *
*
$INCLUDE IBP AI.INCL.INTFC.STL
*
RETURN
*
!
*
DISPLAY.STATUS: *
*
!
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Display Status" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.INCL.INTFC.DISPLAY
*
RETURN
*
!
*
*DISPLAY.TITLE: *
*
$INCLUDE IBP AI.CNTRL.UTIL.DISP.HDR
*
!
*
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
IF STAT EQ 999 THEN AI.STATUS = 999
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
END
~AI.CHECK.HANDLER~
SUBROUTINE AI.CHECK.HANDLER(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.STATUS,SEND.STATUS,SYS.PRNT,STAT)
*
*@@@
*LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,
*PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,
*CHECK.FMT,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,
*FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEST,OUTPUT,
*ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,
*ERR,CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,
*MAT COM.AIHERR,
*MAT COM.AIP,COM.AIP.ID,
*COM.AIP.PORT,COM.AIP.PORT.FIRST,
*COM.AIP.ELP,COM.AIP.ON.FILE,
*MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,
*COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,
*COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.CHK.ERR,AI.SCAN,
*COM.ID,
** * * COM.ID.LIST *,
*MAT CNT.TST,CNT.TST.ID,
*CO.DATA,
** * * CO.NAME,CO.DATE,
*OFF.FLAG,DISP.ONLY,AUTO.RUN,REDISP,STAT)
*@@@
*PROGRAM: AI.CHECK.HANDLER
*              Eagle addressable interface HANDLER.
*    __________
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "920409 NEW"
VS = "920409 NEW (1.0)"
*
* * * ! Input Parameters
* * * *
* * * INPUT COMMPORT:
* * * LOOP WHILE LEN(COMMPORT) LT 3 DO COMMPORT = ZERO:COMMPORT REPEAT
* * * *
*
! System Control
*
* System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CHECK.HANDLER"; SYS.LOCT = EMPTY
SYS.APPL.LOC = ONE
* * * AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE
*
* * * PORTS.LIST.BUILD = 9; 
* * * PORTS.LIST = EMPTY; 
* * * PORTS.LIST.PREV = EMPTY
PORT.CONT = FALSE; 
* * * PORT.KEY = PORT; *
* * * FAST.DISPLAY = FALSE
* * * LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
PORT.NUM = PORT.KEY
LOOP WHILE LEN(PORT.NUM) LT 3 DO PORT.NUM = "0":PORT.NUM REPEAT
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
*
* * * LCK.TYPE = -5
* * * LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.STAT = LCK.TYPE
*
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
* Control Flags
* $INCLUDE IBP TST.VAR.EQUATES
* EQU TST$AM TO 12, TST$VM TO 9
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
* IF SYS.TST EQ EMPTY THEN
* READ SYS.TST FROM COM.FILE,"SYSTEM.TEST" ELSE SYS.TST = ""
* END
* * * CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
* * * GOSUB LOAD.TST
*
SYS.LOCT = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*SYS.LOCT = "?"; IF CNT.TST$LBL THEN PRINT @(60,20):(SYS.LOCT:" ?") "L#18":; IF CNT.TST$CR THEN INPUT TMP:
* * * CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
*
*
! Application Records
SYS.LOCT = "AR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Records" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
COM.ID = EMPTY; * ???
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
* * * MAT COM.AI = EMPTY; COM.AI.ID = EMPTY
* * * COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY; COM.AI.ERR.TYPE = EMPTY
* * * COM.AI.ERR.FUNC = EMPTY; COM.AI.ERR.DISP = FALSE
* * * COM.AI.RUN.ELP = ZERO; COM.AI.ON = EMPTY; COM.AI.UP = EMPTY
* * * COM.AI.ON.OFF.ELP = ZERO; COM.AI.UP.DN.ELP = ZERO
* * * COM.AI.ON.FILE = FALSE
*
COM.AI.PORT.REC = EMPTY
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
* * * MAT COM.AIP = EMPTY; COM.AIP.ID = EMPTY
* * * COM.ID.LIST = EMPTY; COM.AIP.PORT.FIRST = EMPTY
* * * COM.AIP.PORT = EMPTY; COM.AIP.ON.FILE = FALSE; COM.AIP.ELP = ZERO
* * * NEXT.COM.AIP.ID = EMPTY
*
** $INCLUDE IBP AIL.DIM
** $INCLUDE IBP AIL.EQUATES
** AIL.SEQ.ID = EMPTY; AIL.SEQ = EMPTY; AIL.ID = EMPTY
** *
** * $INCLUDE IBP AIX.DIM
** * $INCLUDE IBP AIX.EQUATES
** *
** * $INCLUDE IBP DVC.DIM
** * $INCLUDE IBP DVC.EQUATES
** *
*
! Application Parameters and Tables
SYS.LOCT = "APT"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Parameters and Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
INTFC.CODE = "?"
*
* * * COMPONENTS = EMPTY; CHANNEL.MLES = EMPTY; CHAN.ALL = FALSE
* * * STATUS.LOC = ONE; 
STATUS.CYCLE = FALSE
* * * STVC = ZERO; BVC = ZERO; ACTIONS = EMPTY; PRIOR.CHANNEL.MLES = EMPTY
* * * STL = EMPTY; PORT.VC = ONE; LOG.REQUIRED = FALSE
*
*
! System Files
SYS.LOCT = "SF"; IF CNT.TST$LBL THEN PRINT @(60,20):"System Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "COM" TO COM.FILE ELSE CHAIN "FREEZE.PORT"
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE CHAIN "FREEZE.PORT"
* LCK.FILE = ZERO; * REV ONLY
*
* * * OPEN "DICT","ACC" TO ACC.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "PAR" TO PAR.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "CNT" TO CNT.FILE ELSE CHAIN "FREEZE.PORT"
* * * READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN 
CO.NAME = CO.DATA<ONE,ONE>
* * *  ELSE CO.NAME = EMPTY; CO.DATA = EMPTY
*
*
! Application Files
SYS.LOCT = "AF"; IF CNT.TST$LBL THEN PRINT @(60,20):"Appl Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
* * * OPEN "AIX" TO AIX.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "DVC" TO DVC.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "ACT" TO ACT.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "AIL" TO AIL.FILE ELSE CHAIN "FREEZE.PORT"
*
*
! : * Init INternal VARiables
SYS.LOCT = "VAR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Variables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
* * * AI.RESET = FALSE; AI.STATUS = FALSE; AI.DOWN = EMPTY; AI.SLEEP = ZERO
* AI.SCAN = TRUE; *
* * * AI.SCAN.DT = EMPTY; AI.SCAN.TM = EMPTY; AI.SRCE = "H"
*
* * * SEND.STATUS = FALSE; SEND.COMM = TRUE; SEND.RETRY = TRUE; SEND.WAIT = ZERO
* * * SEND.DONE = FALSE; SEND.UP.DN = EMPTY
*
* * * DISP.ONLY = FALSE; ERR.DISP.ONLY = FALSE; ERR.BELL = TRUE
* * * ERR.LN.MIN = 5; ERR.LN = ERR.LN.MIN; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
* * * TEXT = EMPTY; OUTPUTS = EMPTY
** ERROR
* * * LAST.ERROR = EMPTY; ERR.LEN = EMPTY; ERR.FMT = EMPTY
* * * ERR.CLB = EMPTY; ERR.CLS = EMPTY; ERR.CL = EMPTY; ERR.HDR = EMPTY
* * * ERR.CR = EMPTY
*
* * * CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 28
* * * CHECK.LEN = 30; CHECK.LN.HI = ZERO
* * * IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
IF ERR.DISP.ONLY THEN STATUS.CYCLE = ERR.DISP.ONLY
DT = DATE(); TM = TIME(); ELP = ZERO
*
*
! : * Init Tables
SYS.LOCT = "TBL"; IF CNT.TST$LBL THEN PRINT @(60,20):"Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
* * * MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
*
* * * READ COMPONENTS FROM PAR.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
* * * CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PROG,STAT)
*
* * * READ STL FROM COM.FILE,"AI.STATUS.CHANNEL.":COMMPORT ELSE STL = EMPTY
*
*
! Start Program
*
*
SYS.LOCT = "START"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
CHECK.HANDLER: *
*
SYS.LOCT = "INTFC.CHECK"; IF CNT.TST$LBL THEN PRINT @(60,20):"Check Handler" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.INTFC.CHECK
*
RETURN
*
!
*
ERROR: *
*
LAST.ERROR = TEXT
*
RETURN
*
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
!
*
RETURN
!
END
~AI.CHECK.PROM~
SUBROUTINE AI.CHECK.PROM(AIX.FILE,LCK.FILE,CNT.FILE,PAR.FILE,DVC.ID,DVC$ADDRESS,TEXT,SYS.PRNT,STAT)
*
*      Verify that an entered address is valid and NOT already in use...
*
!
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CHECK.PROM"; SYS.LOCT = EMPTY
!
IF DVC$ADDRESS = "" THEN TEXT = "address may not be blank"; RETURN
TMP = COUNT(DVC$ADDRESS,"*")
SYS.ID = FIELD(DVC$ADDRESS,"*",1)
GROUP = FIELD(DVC$ADDRESS,"*",2)
BOXNUM = FIELD(DVC$ADDRESS,"*",3)
IF TMP # 2 OR NOT(SYS.ID MATCHES "0N") OR NOT(GROUP MATCHES "0N") OR NOT(BOXNUM MATCHES "0N") THEN TEXT = "format must be 999*9999*999"; RETURN
IF SYS.ID > 60 THEN TEXT = "system id must not exceed 60"; RETURN
IF GROUP > 1023 THEN TEXT = "group address must not exceed 1023"; RETURN
IF BOXNUM < 1 OR BOXNUM > 144 THEN TEXT = "box # must be 1 to 144"; RETURN
MOD8 = REM(BOXNUM,8)
IF NOT(MOD8) THEN TEXT = "box # may not be divisible by 8"; RETURN
SINGLE.VALUE = ((SYS.ID * 1024) + GROUP) * 144 + BOXNUM
READ AI.MISC FROM PAR.FILE,"AI.MISCELLANEOUS" ELSE
TEXT = "miscellaneous addr interface parameters missing"; RETURN
END
LOW.VALUE = ((AI.MISC<2,1> * 1024) + AI.MISC<2,2>) * 144 + AI.MISC<2,3>
IF SINGLE.VALUE < LOW.VALUE THEN
TEXT = "may not be lower than ":AI.MISC<2,1>:"*":AI.MISC<2,2>:"*":AI.MISC<2,3>
RETURN
END
READ AI.HIGH FROM CNT.FILE,"AI.HIGH" ELSE
TEXT = "no addressable devices on file"; RETURN
END
HIGH.VALUE = ((AI.HIGH<1,1> * 1024) + AI.HIGH<1,2>) * 144 + AI.HIGH<1,3>
IF SINGLE.VALUE > HIGH.VALUE THEN
TEXT = "may not be higher than ":AI.HIGH<1,1>:"*":AI.HIGH<1,2>:"*":AI.HIGH<1,3>
RETURN
END
AIX.ID = SYS.ID:"*":GROUP
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
LOCATE BOXNUM IN AIX$BOX<1> BY "AR" SETTING LOC THEN
IF AIX$DVC.ID<1,LOC> # DVC.ID THEN
TEXT = "address is in use by serial # ":AIX$DVC.ID<1,LOC>; RETURN
END
END
RETURN
!
END
~AI.CLEAR.LOG~
*PROGRAM: AI.CLEAR.LOG
*
*      Clear addressable interface handler log...
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CLEAR.LOG"; SYS.LOCT = EMPTY
SYS.PRNT = EMPTY
*
!
*
OPEN "AIL" TO AIL.FILE ELSE PRINT "Can't open AIL"; INPUT RSP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR"; INPUT RSP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT"; INPUT RSP:; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM"; INPUT RSP:; STOP
OPEN "AIL" TO AIL.FILE ELSE PRINT "Can't open AIL"; INPUT RSP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open LOCKS"; INPUT RSP:; STOP
*
INPUT AUTO.RUN
IF AUTO.RUN THEN READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
*
!
*
$INCLUDE IBP AI.INCL.ERR.INIT
*
!
*
IF AUTO.RUN THEN
AI.CODE = CURRENT.RUN<ONE,TWO>
END ELSE
$INCLUDE IBP AI.INCL.GET.CODE
END
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<ONE,ONE> ELSE CO.NAME = ""
*
PRINT @(ZERO,ZERO):CLS:
PRINT @(ZERO,ZERO):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28 - (((LEN(CO.NAME) + ONE) / TWO))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(ZERO,ONE):RVB:"                   Addressable Interface - Clear Handler Log                    ":RVE:
*
IF NOT(AUTO.RUN) THEN
LOOP
PRINT @(0,10):CLL:"Are you sure you want to clear the log? ":; INPUT RSP:
UNTIL RSP EQ "Y" OR RSP EQ "N" OR RSP EQ "KILL" DO REPEAT
*
IF RSP EQ "N" OR RSP EQ "KILL" THEN STOP
END
*
INPUTS = AI.CODE
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("RUN BP.AI AI.CLEAR.LOG",INPUTS,"Clear AI Log")
*
PRINT @(ZERO,10):CLL:@(10):"Clearing logged items...":
*
PGS = ZERO; LNS = 99
*
!
*
EXEC.VERB = "CLEAR-FILE DATA AIL"
EXEC.RESULT = EMPTY
*
EXECUTE EXEC.VERB, //OUT. > EXEC.RESULT
*
!
*
PRINT @(ZERO,10):CLL:@(10):"Resetting log counter...":
*
COM.ID = "AI.LOG*":AI.CODE
*
LOOP
LCK.TYPE = -5
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
*
READ COM.REC FROM COM.FILE,COM.ID ELSE COM.REC = EMPTY
*
COM.REC = ONE
*
WRITE COM.REC ON COM.FILE,COM.ID
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","B","",LCK.STAT)
*
STOP
*
!
*
READ.COM.AI: *
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
*
END
~AI.CNTRL.FUNC~
SUBROUTINE AI.CNTRL.FUNC(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,SYS.PRNT,STAT)
*
* AUTHOR: DAVID G. HORSMAN
* COMPANY: Written for AXION COMPUTER SYSTEMS LTD.
*
* DATE RELEASED: ?? DEC 90
*
*   Write a special command to the port's work file for transmission...
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CNTRL.FUNC"; SYS.LOCT = EMPTY
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP SAVE.COM.AIP.DIM
!
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
!
OPEN "COM" TO COM.FILE ELSE PRINT @(0,23):CLL:"Can't open COM":; INPUT RSP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT @(0,23):CLL:"Can't open LOCKS":; INPUT RSP:; STOP
*
!
*
*
*
*
PRINT CLB:"FUNCTION SENT":; INPUT TMP:
*
*
RETURN
*
END
~AI.COMMAND.SENDER~
SUBROUTINE AI.COMMAND.SENDER(MAT COM.AIP,MAT COM.AI,COM.AIP.ID,AI.CODE,ACTIONS,COM.FILE,LCK.FILE,LCK.TYPE,AI.STATUS,SEND.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,MAT CNT.TST,OPER,EXP.TM,SYS.PRNT,STAT)
*SUBROUTINE: AI.COMMAND.SENDER
* VERSION: 940220 1.1  BYPASS DVC.TYPE CHECK, UPDATE NEXT TRANS, PASS COM.AIIERR.
* USED BY AI.HANDLER
*
* AUTHOR:    DAVID G. HORSMAN
* COMPANY:   WRITTEN FOR AXION COMPUTER SYSTEMS LTD.
*
* DATE RELEASED: ?? DEC 90
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AI.DIM
* PAUSE.CHAR   (INCR'S)
* PAUSE.LINE   (INCR'S)
* PAUSE.RESP   (SEC.S)
$INCLUDE IBP AIX.DIM
$INCLUDE IBP ADD.DIM
!
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AIICMD.VAR.EQUATES
*
EQU VERSION TO "(3.0)"
VS = "(1.0)"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.HANDLER"; SYS.LOCT = EMPTY
*
* OPEN "CNT" TO CNT.FILE ELSE STOP
* SYS.APPL.SUB = "AI"
* GOSUB LOAD.TST
*
IF CNT.TST$LBL THEN PRINT @(ZERO,23):RVB:" * Subroutine AI.COMMAND.SENDER * ":RVE
!
DT = DATE(); TM = TIME()
PAUSE.CN.MAX = COM.AI$PAUSE.CHAR
* TC.LAST.FL = FALSE; TC.LAST = EMPTY
SEND.STATUS = FALSE; SEND.CN = ZERO
COM.AI.MIN.PKT = 6
PAUSE.RESP.MAX = COM.AI$PAUSE.RESP
COM.AI.MAX.BUF = 10
*
* FORMAT RECORD
*
IF CNT.TST$LBL THEN PRINT RVB:"Formatting Record":RVE
*
OUTPUT.PACKET = EMPTY
*
*
IF COM.AIP$DVC.TYPE NE "SYS" THEN
IF COM.AIP$DVC.TYPE NE "" THEN
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC THEN
*
BEGIN CASE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "EA"; EXEC.VALID = TRUE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "HA"; EXEC.VALID = TRUE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "JE"; EXEC.VALID = TRUE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "PA"; EXEC.VALID = TRUE
CASE TRUE; EXEC.VALID = FALSE; SEND.STATUS = ERR$TYPE.NOT.POC
END CASE
*
END ELSE EXEC.VALID = FALSE; SEND.STATUS = ERR$TYPE.NOT.POC
*END ELSE EXEC.VALID = TRUE; DVC.LOC = ONE
END ELSE EXEC.VALID = FALSE; SEND.STATUS = ERR$NO.DVC.TYPE; DVC.LOC = ONE
END ELSE EXEC.VALID = TRUE; DVC.LOC = ONE
*
IF NOT(EXEC.VALID) THEN
IF NOT(SEND.STATUS) THEN SEND.STATUS = 555
IF CNT.TST$LBL THEN PRINT RVB:"Format Error: ":SEND.STATUS:RVE
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
RETURN
END
*
** * * Loop to send packet up to 3 times
** * LOOP
*
TC.START.SYS11 = SYSTEM(11)
*
EXEC.ROUTINE = "AI.PARSE.OUTPUT.":COM.AI$DB.PREFIX<ONE,DVC.LOC>
*
*960626*DGH*IF TC.START.SYS11 LT COM.AI.MAX.BUF THEN
*960626*DGH** COM.AI.MAX.BUF S/B A PARAMETER
*
****IF NOT(NUM(COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>)) THEN COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = ZERO
****COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> + ONE
*
*
CALL @EXEC.ROUTINE(MAT COM.AIP,OUTPUT.PACKET,MAT CNT.TST,COM.FILE,LCK.FILE,LCK.TYPE,SEND.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE,OPER,EXP.TM,SYS.PROG,STAT)
*
!
*
LOCATE COM.AIP$COMM.RSLT<ONE,SEND.COMM.CN,ONE> IN COM.AIICMD<COM.AIICMD$RCVD> SETTING COM.AIICMD.LOC THEN
*
IF COM.AIICMD<COM.AIICMD$LOG,COM.AIICMD.LOC> EQ "Y" THEN
COM.AIP$LOG.REQD = 33333
END
*
TMP = COM.AIICMD<COM.AIICMD$PAUSE,COM.AIICMD.LOC>
IF TMP NE "" THEN
PAUSE.RESP.MAX = COM.AI$PAUSE.RESP + TMP
IF TMP GT COM.AIP$MAX.PAUSE THEN
COM.AIP$MAX.PAUSE = TMP
* COM.AIP.ID = "AI*":AI.CODE:"*":PORT.NUM
* MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
END; * of tmp ne ""
*
* LOOP WHILE PAUSE.RESP.MAX GT COM.AIP$MAX.PAUSE / 3 DO
* COM.AIP$MAX.PAUSE = COM.AIP$MAX.PAUSE + PAUSE.RESP.MAX
* REPEAT
*
TMP = COM.AIICMD<COM.AIICMD$RETRY,COM.AIICMD.LOC>
IF TMP NE EMPTY THEN
IF TMP LT COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> THEN COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> = TMP
END
*
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
END; * OF LOCATE
*
!
*
IF TC.START.SYS11 LT COM.AI.MAX.BUF THEN
* COM.AI.MAX.BUF S/B A PARAMETER
*
IF SEND.STATUS EQ "0" THEN SEND.STATUS = EMPTY
IF SEND.STATUS EQ "00" THEN SEND.STATUS = EMPTY
*
IF NOT(NUM(COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>)) THEN
INS ERR$BAD.RSP BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
SEND.STATUS = ERR$BAD.RSP
END
*
IF COM.AI$LOGGING EQ "Y" OR COM.AI$TEST.MODE OR COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> OR SEND.STATUS NE EMPTY THEN
* COM.AIP$HEX.COMM =  OUTPUT.PACKET; COM.AIP$HEX.COMM<ONE,TWO> = OCONV(OUTPUT.PACKET,"HEX")
IF LEN(COM.AIP$HEX.COMM) GT 300 THEN
TMP = INDEX(COM.AIP$HEX.COMM,SVM,5)
IF TMP GT 300 THEN TMP = INDEX(COM.AIP$HEX.COMM,SVM,5)
IF TMP THEN COM.AIP$HEX.COMM = COM.AIP$HEX.COMM[ONE,TMP - ONE]
TMP = INDEX(COM.AIP$HEX.RSLT,SVM,5)
IF TMP THEN COM.AIP$HEX.RSLT = COM.AIP$HEX.RSLT[ONE,TMP - ONE]
TMP = INDEX(COM.AIP$ERR,SVM,5)
IF TMP THEN COM.AIP$ERR = COM.AIP$ERR[ONE,TMP - ONE]
TMP = INDEX(COM.AIP$INTFC.ERR,SVM,5)
IF TMP THEN COM.AIP$INTFC.ERR = COM.AIP$INTFC.ERR[ONE,TMP - ONE]
END
*@@*INS OCONV(OUTPUT.PACKET,"HEX") BEFORE COM.AIP$HEX.COMM<ONE,ONE>
*@@*INS EMPTY BEFORE COM.AIP$HEX.RSLT<ONE,ONE>
*@@*INS EMPTY BEFORE COM.AIP$ERR<ONE,ONE>
*@@*INS EMPTY BEFORE COM.AIP$INTFC.ERR<ONE,ONE>
INS OCONV(OUTPUT.PACKET,"HEX") BEFORE COM.AIP$HEX.COMM<ONE,SEND.COMM.CN,ONE>
END
*
IF SEND.STATUS NE EMPTY THEN NULL
*
*960626*DGH*END; * of START.SYS11
*
!
*
* SEND RECORD TO COM.AI$DB.PREFIX DEVICE
*
IF CNT.TST$LBL THEN PRINT RVB:"Sending Record":RVE
*
*960626*DGH*IF TC.START.SYS11 LT COM.AI.MAX.BUF THEN
*960626*DGH** COM.AI.MAX.BUF S/B A PARAMETER
*
** * SEND.RETRY = FALSE
TC.CN = 0
TC.CN.MAX = LEN(OUTPUT.PACKET)
TC.LAST.FL = TRUE; TC.LAST = OUTPUT.PACKET[TC.CN.MAX,ONE]
TC.CN.MAX = TC.CN.MAX - ONE
OUTPUT.PACKET = OUTPUT.PACKET[ONE,TC.CN.MAX]
*
IF PAUSE.CN.MAX THEN
LOOP TC.CN = TC.CN + ONE WHILE TC.CN LE TC.CN.MAX DO
PAUSE.CN = 0
LOOP WHILE PAUSE.CN LT PAUSE.CN.MAX DO PAUSE.CN = PAUSE.CN + ONE REPEAT
TC = OUTPUT.PACKET[TC.CN,ONE]
PRINT TC:
REPEAT ; * SEND NEXT CHARACTER
END ELSE
PRINT OUTPUT.PACKET:
END
*
IF COM.AI$PAUSE.LINE THEN
IF TC.LAST.FL THEN
PRINT TC.LAST:; TC.LAST.FL = FALSE
END
TC.START.SYS11 = SYSTEM(11)
IF COM.AI$PAUSE.LINE THEN
IF NOT(TC.START.SYS11) THEN
PAUSE.CN = 0
LOOP WHILE PAUSE.CN LT COM.AI$PAUSE.LINE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
END
END
END
*
END; * of START.SYS11
*
IF CNT.TST$LBL THEN PRINT; PRINT; PRINT
*
!
*
* RECEIVE RESPONSE FROM COM.AI$DB.PREFIX DEVICE
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Receiving Response From Headend . . . ":RVE
ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY; TC.CHAR = EMPTY
*
*
* Process any characters that are available
*
LOOP
*
*
PAUSE.CHAR = COM.AI$PAUSE.CHAR
*
PAUSE.RESP = COM.AI$PAUSE.RESP
* IF COM.AIP$MAX.PAUSE GT PAUSE.RESP THEN
* PAUSE.RESP = COM.AIP$MAX.PAUSE
* END
** IF PAUSE.RESP.MAX GT PAUSE.RESP THEN
** PAUSE.RESP = PAUSE.RESP.MAX
** END
*
**PAUSE.TOUT = COM.AI$MAX.PAUSE
PAUSE.TOUT = ZERO
IF COM.AIP$MAX.PAUSE NE 0 THEN
PAUSE.RESP = PAUSE.RESP + COM.AIP$MAX.PAUSE
END
PAUSE.LINE = COM.AI$PAUSE.LINE
*
!
*
IF CNT.TST$LBL NE "2" THEN
*
**** AI.RESP.INPUT(PAUSE.CHAR,PAUSE.RESP,PAUSE.TOUT,PAUSE.LINE,INPUT.PACKET,TC.LAST.FL,TC.LAST,OPER,EXP.TM,SYS.PROG,STAT)
*
$INCLUDE IBP AI.INCL.INP.RSP
*
END
*
* TMP = EMPTY
* INPUT TMP,170: FOR 50 ELSE TMP = EMPTY
* INPUT.PACKET = INPUT.PACKET:TMP
*
! Process the charaters in this packet
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Process buffered response/characters":RVE
*
*21AUG94* ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY
* Validate Headend response
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Validate Response From Headend Device":RVE
*
*24AUG94* IF CNT.TST$LBL OR TC.END.SYS11 THEN
IF CNT.TST$LBL OR LEN(INPUT.PACKET) THEN
*
EXEC.ROUTINE = "AI.PARSE.INPUT.":COM.AI$DB.PREFIX<ONE,DVC.LOC>
*
*21AUG94* ECHO OFF
CALL @EXEC.ROUTINE(MAT COM.AIP,INPUT.PACKET,ORIG.PACKET,MAT CNT.TST,COM.FILE,LCK.FILE,LCK.TYPE,SEND.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE,OPER,EXP.TM,SYS.PROG,STAT)
*21AUG94* ECHO ON
*
IF SEND.STATUS EQ "0" THEN SEND.STATUS = EMPTY
IF SEND.STATUS EQ "00" THEN SEND.STATUS = EMPTY
IF NOT(NUM(COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>)) THEN
INS ERR$BAD.RSP BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
SEND.STATUS = ERR$BAD.RSP
END
*
END ELSE
INS ERR$NO.RSP BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
SEND.STATUS = ERR$NO.RSP
END
*
IF COM.AI$LOGGING EQ "Y" OR COM.AI$TEST.MODE OR COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> OR SEND.STATUS NE EMPTY THEN
* COM.AIP$HEX.RSLT = ORIG.PACKET; COM.AIP$HEX.RSLT<ONE,ONE,TWO> = OCONV(ORIG.PACKET,"HEX")
INS OCONV(ORIG.PACKET,"HEX") BEFORE COM.AIP$HEX.RSLT<ONE,SEND.COMM.CN,ONE>
* COM.AIP$HEX.RSLT<ONE,TWO> = INPUT.PACKET; COM.AIP$HEX.RSLT<ONE,TWO,TWO> = OCONV(INPUT.PACKET,"HEX")
* INS OCONV(INPUT.PACKET,"HEX") BEFORE COM.AIP$HEX.RSLT<ONE,SEND.COMM.CN,ONE>
IF SEND.STATUS NE EMPTY THEN COM.AIP$LOG.REQD = 22222
END
*
TC.END.SYS11 = SYSTEM(11)
*
WHILE NOT(CNT.TST$LBL) AND TC.END.SYS11 GT COM.AI.MIN.PKT DO REPEAT
*
** * SEND.CN = SEND.CN + ONE
** * *
** * WHILE SEND.CN LT 3 AND SEND.RETRY = TRUE DO REPEAT
*
!
*
* Load information into COM.AIP Record
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Update Port Control Record":RVE
*
* COM.AIP$??? = ?
*
!
*
!
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"AI.COMMAND.SENDER processing complete":RVE; PRINT
* Return to calling program
*
RETURN
*
!
*
LOAD.TST: *
*
* $INCLUDE IBP TST.INCL.LOAD
*
RETURN
!
END
~AI.CONTROL.UTILITY~
*PROGRAM: AI.CONTROL.UTILITY
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
*
$INCLUDE IBP AI.CNTRL.UTIL.DOC.TOP
*
*: * INIT
*: * FUNC
* System Info
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "901018 NEW (1.0)"
VS = "901018 NEW (1.0)"
*
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CONTROL.UTILITY"; SYS.LOCT = EMPTY
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AI.ERR.INIT
*
AI.TALK = EMPTY
COM.AI.PORT.REC = EMPTY
FUNC.SUB = EMPTY; OLD.FUNC.SUB = EMPTY; CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
$INCLUDE IBP AI.CU.TOP
*
*: * Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
SAVE.FUNC.SUB = ""; CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
SYS.LOCT = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
*
!: * Application Records
SYS.LOCT = "AR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Records" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
*
*     AIL
AIL.NEXT.ID = EMPTY
LOG.REQUIRED = FALSE
*
*
$INCLUDE IBP DVC.DIM
$INCLUDE IBP DVC.EQUATES
MAT DVC = EMPTY; DVC.ID = EMPTY
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
MAT AIX = EMPTY; AIX.ID = EMPTY; AIX.RESET = FALSE
*
*
$INCLUDE IBP WKO.DIM
$INCLUDE IBP WKO.EQUATES
MAT WKO = EMPTY; WKO.ID = EMPTY
*
*
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
MAT ADD = EMPTY; ADD.ID = EMPTY
*
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
MAT ACT = EMPTY; ACT.ID = EMPTY
*
*
!: * Application Parameters and Tables
SYS.LOCT = "APT"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Parameters and Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.CU.TOP.A
*
$INCLUDE IBP AI.INCL.GET.CODE
*
$INCLUDE IBP AI.CU.TOP.B
*
$INCLUDE IBP AI.CNTRL.UTIL.DOC.START
*
*
LOOP
*
ALREADY.DISPLAYED = EMPTY
*
*: * Start of LOOP * Main 1
*
LOOP
*
GOSUB LOAD.TITLE; * : *
GOSUB READ.STL; * : *
GOSUB DISPLAY.STATUS; * : *
*
GOSUB INTFC.MESSAGES
*
IF NOT(LEN(FUNC.CHNG)) AND LEN(COM.AI.ERR.FUNC) THEN
*
IF FUNC NE COM.AI.ERR.FUNC<ONE,ONE,ONE> AND COM.AI.ERR.FUNC NE EMPTY THEN
*
LOOP
*
FUNC.OK = TRUE
*IF COM.AI.ERR.FUNC<ONE,ONE,ONE> EQ ORIG.FUNC OR COM.AI.ERR.FUNC<ONE,ONE,ONE> EQ OLD.FUNC<ONE,ONE,ONE> THEN FUNC.OK = FALSE
IF COM.AI.ERR.FUNC<ONE,ONE,ONE> EQ OLD.FUNC<ONE,ONE,ONE> THEN FUNC.OK = FALSE
IF COM.AI.ERR.FUNC<ONE,ONE,ONE> EQ COM.AI$ON.OFF.STAT THEN FUNC.OK = FALSE
IF COM.AI.ERR.FUNC<ONE,ONE,ONE> EQ COM.AI$UP.DN.STAT  THEN FUNC.OK = FALSE
*
IF FUNC.OK THEN
INS COM.AI.ERR.FUNC<ONE> BEFORE FUNC.CHNG<ONE>
TEXT<-ONE> = "[":AI.STATUS:"] Function change ":COM.AI.ERR.FUNC<ONE,ONE,ONE>:" accepted."; GOSUB ERROR; * : *
END ELSE
TEXT<-ONE> = "[":AI.STATUS:"] Function change ":COM.AI.ERR.FUNC<ONE,ONE,ONE>:" rejected!!!"; GOSUB ERROR; * : *
EXECUTE "SLEEP 2"
DEL COM.AI.ERR<ONE>
DEL COM.AI.ERR.FUNC<ONE>
DEL COM.AI.ERR.FUNC<ONE>
DEL COM.AI.ERR.TEXT<ONE>
DEL COM.AI.ERR.TYPE<ONE>
END
*
*
WHILE NOT(FUNC.OK) AND LEN(COM.AI.ERR.FUNC) DO REPEAT
*
END; * err.func present
*
END; * status msgs
*
IF LEN(FUNC.CHNG) AND FUNC.CHNG<ONE,ONE,ONE> EQ EMPTY THEN DEL FUNC.CHNG<ONE,ONE,ONE>
IF LEN(FUNC.CHNG) AND FUNC.CHNG<ONE,ONE> EQ EMPTY THEN DEL FUNC.CHNG<ONE,ONE>
IF LEN(FUNC.CHNG) AND FUNC.CHNG<ONE> EQ EMPTY THEN DEL FUNC.CHNG<ONE>
IF LEN(FUNC.CHNG) THEN
*
ERR.DISP.ONLY = FALSE
IF RUN.TYPE EQ TWO THEN ERR.DISP.ONLY = 5; ERR.BELL = TRUE
GOSUB ERROR; * : * 
TEXT<-ONE> = "[":AI.STATUS:"] The function is being changed from ":FUNC:" to ":FUNC.CHNG<ONE,ONE,ONE>
ERR.DISP.ONLY = 3
IF RUN.TYPE EQ TWO THEN ERR.DISP.ONLY = 10; ERR.BELL = TRUE
GOSUB ERROR; * : * 
IF FUNC.CHNG<ONE,ONE,ONE> NE "DI" THEN
SAVE.FUNC = FUNC:AM:SAVE.FUNC
SAVE.FUNC.SUB = FUNC.SUB:AM:SAVE.FUNC.SUB
IF FUNC.CHNG<ONE,ONE,ONE> NE "DN" THEN RUN.TYPE = TWO
END
FUNC = FUNC.CHNG<ONE,ONE,ONE>
DEL FUNC.CHNG<ONE,ONE,ONE>
SUB.FUNC = FUNC.SUB<ONE,ONE,ONE>
DEL FUNC.SUB<ONE,ONE,ONE>
*
END; * func.chng
*
GOSUB LOAD.TITLE; * : * 
ERR.BELL = TRUE
IF LEN(TEXT) THEN GOSUB ERROR; * : * 
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
*
*
* EXECute function / subject : *
FUNC.WRITE = FALSE; DISP.ONLY = FALSE; SEND.STATUS = EMPTY
BEGIN CASE
CASE FUNC EQ "DI"; DISP.ONLY = TRUE
CASE FUNC EQ AI.ON; GOSUB START.HANDLER; * : *
CASE FUNC EQ AI.OFF; FUNC.WRITE = TRUE;  GOSUB STOP.HANDLER; * : *
CASE FUNC EQ AI.DN; FUNC.WRITE = TRUE; GOSUB DOWN.HANDLER; * : *
CASE FUNC EQ AI.UP; FUNC.WRITE = TRUE; GOSUB UP.HANDLER; * : *
CASE FUNC EQ "DC"; GOSUB DOWN.CHANNELS; * : *
CASE FUNC EQ "UC"; GOSUB UP.CHANNELS; * : *
* CASE FUNC[ONE,ONE] EQ "S"; GOSUB SPECIAL.FUNC; * : *
CASE FUNC[ONE,ONE] EQ "S"; FUNC.WRITE = TRUE; TEXT<-ONE> = "Special command ":FUNC:",":FUNC.SUB:" present!"; * : *
CASE TRUE; TEXT<-ONE> = "[":AI.STATUS:"] No AI function requested!"; GOSUB ERROR; * : *
END CASE
*
IF FUNC.WRITE THEN
SEND.STATUS = FALSE
GOSUB WRITE.COM.AI; * : *
END
*
IF FUNC[ONE,ONE] EQ "S" THEN
GOSUB SPECIAL.FUNC; * : *
END
*
*: * do any stacked functions *
OLD.FUNC = FUNC:AM:OLD.FUNC
OLD.FUNC.SUB = FUNC.SUB:AM:OLD.FUNC.SUB
FUNC = SAVE.FUNC<ONE>
FUNC.SUB = SAVE.FUNC.SUB<ONE>
WHILE SAVE.FUNC NE EMPTY AND NOT(STAT) DO
DEL SAVE.FUNC<ONE>
DEL SAVE.FUNC.SUB<ONE>
REPEAT
IF FUNC EQ EMPTY THEN FUNC = "DI"
*
$INCLUDE IBP AI.CNTRL.UTIL.DOC.SCNDRY
*
NUM.DISPS = ZERO; DISP.ONLY = TRUE; ERR.DISP.ONLY = TWO
NUM.SLPS = COM.AI$STD.PAUSE
STATUS.CYCLE = TRUE
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
*
*: * Start of DISPlay LOOP * Main 2
LOOP
*
NUM.DISPS = NUM.DISPS + ONE
DT = DATE(); TM = TIME()
IF ABS(TM - AI.SCAN.TM) GT TWO * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
PORTS.LIST.BUILD = 9; PORTS.LIST.PREV = PORTS.LIST; PORTS.LIST = EMPTY
AI.RESET = TRUE; AI.SCAN.DT = DT; AI.SCAN.TM = TM
AI.SCAN = TRUE; SCAN.CONT = TRUE; SCAN.FREQ = -COM.AI$SCAN.FREQ; PORT.VC = ONE
GOSUB RESET.HANDLER; * : *
END
*
LCK.ITM = TRUE; LCK.RELS = TRUE; GOSUB READ.COM.AI; * : Main 2
GOSUB READ.STL; * : *
*
SYS11.TMP = SYSTEM(11); * ULT ONLY
IF NOT(SYS11.TMP) THEN
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB DISPLAY.STATUS; * : Main 2
*
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES
*IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; * : *
*
END
*
ERR.TEXT = "Press any key to get back to menu . . . "
PRINT @(31,23):CLL:ERR.TEXT:
*
** * : SLP cycle * Main 2
SLP.CN = ZERO
SLP.CN.MAX = NUM.DISPS + NUM.SLPS; * SLP.CN.MAX = (NUM.DISPS * 3) + NUM.SLPS
IF SLP.CN.MAX GT COM.AI$MAX.PAUSE / 4 THEN SLP.CN.MAX = COM.AI$MAX.PAUSE / 7
PRINT @(72,23):SLP.CN.MAX "R#3":
*
LOOP
*
SLP.CN = SLP.CN + COM.AI$STD.PAUSE
*
SYS11.TMP = SYSTEM(11); * ULT ONLY
*SYS11.TMP = TRUE; * REV ONLY
*
* Check end of DISP - keyboard buffer * Main 2
IF NOT(SYS11.TMP OR SLP.CN GT SLP.CN.MAX) THEN
*
PRINT @(76,23):SLP.CN "R#3":
EXEC.VERB = "SLEEP ":COM.AI$STD.PAUSE
*
*ULT ONLY
EXECUTE EXEC.VERB
*PERFORM EXEC.VERB; * ULT ONLY
*
END
*
* Check end of DISP - keyboard buffer * Main 2
*
SYS11.TMP = SYSTEM(11); * ULT ONLY
*SYS11.TMP = TRUE; * REV ONLY
IF NOT(SYS11.TMP) THEN
*
IF FAST.DISPLAY THEN
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * : *
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES
SYS11.TMP = SYSTEM(11); * ULT ONLY
*SYS11.TMP = TRUE; * REV ONLY
IF NOT(SYS11.TMP) THEN
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; * : *
END ELSE TEXT = EMPTY
IF NOT(NUM(SEND.STATUS)) THEN
PRINT CLB:BELL:SEND.STATUS:"!!!!!!":; INPUT TMP:
SEND.STATUS = FALSE
END
IF SEND.STATUS THEN PRINT BELL:; SEND.STATUS = FALSE
*
END; * OF FAST.DISPLAY
*
END; * OF SYS11.TMP
*
* Check end of DISP - keyboard buffer * Main 2
*
SYS11.TMP = SYSTEM(11); * ULT ONLY
*SYS11.TMP = TRUE; * REV ONLY
*
* Clear keyboard buffer * (continue) * Main 2
IF SYS11.TMP THEN
TEXT<-ONE> = "Keyboard interupt being cleared."; GOSUB ERROR; * : *
LOOP
TMP1 = SYSTEM(11); * ULT ONLY
*TMP1 = TRUE; * REV ONLY
*
UNTIL NOT(TMP1) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
END
*
*
UNTIL SYS11.TMP OR OFF.FLAG OR LEN(COM.AI.ERR.FUNC<ONE>) OR SLP.CN GT SLP.CN.MAX DO
*
NULL
*
*end of SLP cycle
*
REPEAT
*
* Check end of DISP - keyboard buffer * Main 2
UNTIL SYS11.TMP OR OFF.FLAG OR LEN(COM.AI.ERR.FUNC<ONE>) DO 
IF LEN(COM.AI.ERR.FUNC<ONE>) THEN
TEXT<-ONE> = "[":AI.STATUS:"] Interface needs to do a ":COM.AI.ERR.FUNC:"!":BELL; GOSUB ERROR; * : *
EXECUTE "SLEEP 2"
END
REPEAT
*
* end of DISPLAY * (keyboard entry present) * Main 2
*  secondary function 
** SYS11.TMP = SYSTEM(11); * ULT ONLY
** *SYS11.TMP = TRUE; * REV ONLY
*
*
*
*21AUG94* WHILE (NOT(SYS11.TMP) AND NOT(OFF.FLAG)) OR (COM.AI$FUNC.PORT NE EMPTY OR LEN(COM.AI.ERR.FUNC<ONE>)) DO REPEAT
*
****WHILE (NOT(SYS11.TMP) AND NOT(OFF.FLAG)) OR ((COM.AI$FUNC.PORT NE EMPTY AND COM.AI.ON AND COM.AI.UP) OR LEN(COM.AI.ERR.FUNC<ONE>)) DO
WHILE (NOT(SYS11.TMP) AND NOT(OFF.FLAG)) OR LEN(COM.AI.ERR.FUNC<ONE>) DO
*
*
IF LEN(COM.AI$FUNC.PORT) THEN
TEXT<-ONE> = "[":AI.STATUS:"] Interface needs to do work on port(s) ":COM.AI$FUNC.PORT:"!":BELL; GOSUB ERROR; * : *
EXECUTE "SLEEP 2"
END
IF LEN(COM.AI.ERR.FUNC<ONE>) THEN
TEXT<-ONE> = "[":AI.STATUS:"] Interface needs to do a ":COM.AI.ERR.FUNC:"!":BELL; GOSUB ERROR; * : *
EXECUTE "SLEEP 2"
END
IF SYS11.TMP THEN
TEXT<-ONE> = "Keyboard interupt ignored."; GOSUB ERROR; * : *
END
REPEAT
* REPEAT FOR LOOP BACK ON ERROR
*
** *
** * Clear keyboard buffer * (continue) * Main 2
** LOOP
** TMP1 = SYSTEM(11); * ULT ONLY
** *TMP1 = TRUE; * REV ONLY
** *
** UNTIL NOT(TMP1) DO
** RSP = EMPTY
** RSP = OCONV(RSP,"U51EA")
** REPEAT
* end of MAIN
* finished
*
STOP; * : end of ROUTINE
*
!!
*
* START OF PROGRAM FUNCTIONS
*
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Read Com Ai" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
*
READ.STL: *
*
$INCLUDE IBP AI.INCL.INTFC.STL
*
RETURN
*
!
*
RESET.HANDLER: *
*
SYS.LOCT = "INTFC.RESET"; IF CNT.TST$LBL THEN PRINT @(60,20):"Intfc Reset" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
DT = DATE(); TM = TIME()
*
$INCLUDE IBP AI.INCL.LOAD.CODE
*
AI.STATUS = FALSE; HEADEND = EMPTY; COMPONENTS.DFLT = EMPTY
LCK.ITM = FALSE; LCK.RELS = FALSE
GOSUB READ.STL
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
*
LCK.ITM = TRUE; LCK.RELS = FALSE
GOSUB READ.COM.AI; * : @
*
* MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE NULL
END
*
IF ABS(TM - AI.SCAN.TM) GT TWO * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
PORTS.LIST.BUILD = 9; PORTS.LIST.PREV = PORTS.LIST; PORTS.LIST = EMPTY
AI.RESET = TRUE; AI.SCAN.DT = DT; AI.SCAN.TM = TM
AI.SCAN = TRUE; SCAN.CONT = TRUE; SCAN.FREQ = -COM.AI$SCAN.FREQ; PORT.VC = ONE
END
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
COM.AI.ERR.DISP = FALSE
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * : @
*
IF PORTS.LIST NE PORTS.LIST.PREV THEN
IF PORTS.LIST NE EMPTY THEN
COM.AI$FUNC.PORT<ONE,-ONE> = PORTS.LIST
END
PORTS.LIST.PREV = PORTS.LIST
END
*
DT = DATE(); TM = TIME()
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
* GOSUB FULL.STATUS.CHECK; * : @
*
DT = DATE(); TM = TIME()
AI.RESET = FALSE; RESET.FREQ = TM
*
RETURN
*
!
*
FULL.STATUS.CHECK: *
*
SYS.LOCT = "INTFC.CHECK.1"; IF CNT.TST$LBL THEN PRINT @(60,20):"Intfc Check" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
IF COM.AI$CHAN.DN.BRDCST EQ "Y" THEN
IF BROADCAST.REQUIRED THEN
* GOSUB BROADCAST.DN; * : @
END
END
*
RESET.FREQ = TIME()
*
RETURN
*
!
*
WRITE.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Write Com Ai" "L#19":RVE:; RQM
*
IF DISP.ONLY THEN RETURN
*
COM.AI.NOT.ON.FILE = TRUE
COM.AI.ID = "AI.TYPE.":AI.CODE
LCK.STAT = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","B","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LE 300 DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE ELSE
IF LCK.STAT LT 900 THEN AI.STATUS = LCK.STAT + 1000 ELSE AI.STATUS = LCK.STAT
RETURN
END
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN COM.AI.ON.FILE = TRUE ELSE COM.AI.ON.FILE = FALSE; LCK.STAT = 998; MAT COM.AI = EMPTY
*
COM.AI.NOT.ON.FILE = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
BEGIN CASE
*
CASE FUNC EQ AI.ON
COM.AI$ON.OFF = AI.ON
COM.AI$ON.OFF.DT = DT
COM.AI$ON.OFF.TM = TM
COM.AI$ON.OFF.C.DT = COM.AI$ON.OFF.DT
COM.AI$ON.OFF.C.TM = COM.AI$ON.OFF.TM
COM.AI$ON.OFF.BY   = OPER
*
CASE FUNC EQ AI.OFF
COM.AI$ON.OFF = AI.OFF
COM.AI$ON.OFF.DT = DT
COM.AI$ON.OFF.TM = TM
COM.AI$ON.OFF.C.DT = COM.AI$ON.OFF.DT
COM.AI$ON.OFF.C.TM = COM.AI$ON.OFF.TM
COM.AI$ON.OFF.BY   = OPER
*
CASE FUNC EQ AI.UP
COM.AI$UP.DN = AI.UP
COM.AI$UP.DN.DT = DT
COM.AI$UP.DN.TM = TM
COM.AI$UP.DN.C.DT = COM.AI$UP.DN.DT
COM.AI$UP.DN.C.TM = COM.AI$UP.DN.TM
COM.AI$UP.DN.BY   = OPER
*
CASE FUNC EQ AI.DN
COM.AI$UP.DN = AI.DN
COM.AI$UP.DN.DT = DT
COM.AI$UP.DN.TM = TM
COM.AI$UP.DN.C.DT = COM.AI$UP.DN.DT
COM.AI$UP.DN.C.TM = COM.AI$UP.DN.TM
COM.AI$UP.DN.BY   = OPER
*
CASE FUNC EQ "UC" OR FUNC EQ "DC" OR FUNC EQ "DI"
*
CASE TRUE; TEXT<-ONE> = "[":AI.STATUS:"] No AI function requested!"; GOSUB ERROR; * : *
*
END CASE
*
IF FUNC NE "UC" AND FUNC NE "DC" AND FUNC NE "DI" THEN
COM.AI$COMMAND = FUNC
COM.AI$COMMAND.DT = DATE()
COM.AI$COMMAND.TM = TIME()
COM.AI$OPER = OPER
END
*
COM.ID = "AI.TYPE.":AI.CODE
COM.AI.ID = COM.ID
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Write Com Ai" "L#19":RVE:; RQM
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
*
!
*
WRITE.COM.AI.UNLOCK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Unlock Com Ai (write)" "L#19":RVE:; RQM
*
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","C","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
IF HANDLER.COMMAND<ONE> EQ EMPTY THEN
*
IF LEN(HANDLER.COMMAND) THEN DEL HANDLER.COMMAND<ONE>
*
END ELSE
*
*COMMAND PRESENT
AI.STATUS = FALSE; SEND.STATUS = FALSE
SEND.COMM.CN = ONE
GOSUB WRITE.COMMAND; * : *
*
* IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) THEN
IF FUNC NE AI.ON THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND; * : *
END
* END
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
**AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * : *
*
* COM.AI.ERR.CN.MAX = DCOUNT(COM.AI.ERR,AM)
* COM.AI.ERR.CN = ONE; AI.STATUS = FALSE; SEND.STATUS = FALSE
* LOOP WHILE COM.AI.ERR.CN LE COM.AI.ERR.CN.MAX DO
* TMP = COM.AI.ERR<ONE>
* IF LEN(TMP) THEN
* IF NUM(TMP) THEN
* IF TMP LT 200 AND TMP GT AI.STATUS THEN AI.STATUS = TMP
* IF TMP GE 200 AND TMP GT SEND.STATUS THEN SEND.STATUS = TMP
* END
* END
* COM.AI.ERR.CN = COM.AI.ERR.CN + ONE
* REPEAT
*
*IF AI.STATUS GE 100 AND AI.STATUS NE 300 THEN
IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) AND AI.STATUS NE ERR$NOT.SENT THEN
*
BEGIN CASE
*
CASE FUNC EQ AI.ON
*DEALT WITH IN ON AREA
*
CASE FUNC EQ AI.OFF
*
IF AI.STATUS NE 121 THEN
*
TEXT<-ONE> = "[":AI.STATUS:"] Your attempt to OFF the HANDLER failed!"; GOSUB ERROR; * : *
*
ERR.TEXT = "Do you want to LOGOFF the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
**IF OFF.TRIED GT ONE THEN RSP = "Y" ELSE RSP = "N"
IF OFF.TRIED GT 2 THEN RSP = "N" ELSE RSP = "Y"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB LOGOFF.PORT; * : *
END ELSE
*
ERR.TEXT = "Do you want to RESTART the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF OFF.TRIED GT 4 THEN RSP = "N" ELSE RSP = "Y"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB RESTART.PORT; * : *
END
END; * no logoff
END; * 111 OR 181
*
IF COM.AI$ON.OFF.STAT NE AI.OFF OR INDEX(COM.AI.ERR,"111",ONE) OR INDEX(COM.AI.ERR,"181",ONE) THEN
*
ERR.TEXT = "Do you want the HANDLER flagged as OFF anyway (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF OFF.TRIED GT 6 THEN RSP = "Y" ELSE RSP = "N"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
LCK.ITM = TRUE; LCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF NOT(LCK.STAT) THEN
IF AI.STATUS GE 100 AND AI.STATUS LT 200 THEN COM.AI$ERR = COM.AI.ERR<ONE>:VM:DT:VM:TM:VM:WHO:VM:AI.STATUS:VM:SEND.STATUS
COM.AI$ON.OFF.STAT = AI.OFF
COM.AI$ON.OFF.C.DT = DATE()
COM.AI$ON.OFF.C.TM = TIME()
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","D","",LCK.STAT)
LCK.COM.AI = FALSE
END
END
END
*
END ELSE
TEXT<-ONE> = "[":AI.STATUS:"] Your attempt to OFF the Handler was successful."
END; * COM.AI.ERR
*
CASE FUNC EQ AI.UP
TEXT<-ONE> = "[":AI.STATUS:"] ":COM.AI.ERR:" - Handler is being flagged as Down!"; GOSUB ERROR; * : *
LCK.ITM = TRUE; LCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF LCK.COM.AI THEN
COM.AI$UP.DN.STAT = AI.DN
COM.AI$UP.DN.C.DT = DATE()
COM.AI$UP.DN.C.TM = TIME()
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","E","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
CASE FUNC EQ AI.DN
TEXT<-ONE> = "[":AI.STATUS:"] ":COM.AI.ERR:" - Handler is being flagged as Down anyway!"; GOSUB ERROR; * : *
LCK.ITM = TRUE; LCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF LCK.COM.AI THEN
COM.AI$UP.DN.STAT = AI.DN
COM.AI$UP.DN.C.DT = DATE()
COM.AI$UP.DN.C.TM = TIME()
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","F","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
CASE FUNC EQ "DI" OR FUNC EQ "UC" OR FUNC EQ "UC"
*
CASE TRUE; TEXT<-ONE> = "[":AI.STATUS:"] No AI function requested!"; GOSUB ERROR; * : *
*
END CASE
*
END; * COM.AI.ERR
END; * HANDLER.COMMAND
*
RETURN
*
!
*
WRITE.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Write Command" "L#19":RVE:; RQM
*
INS FUNC BEFORE HANDLER.COMMAND<ONE,ONE>
*
IF HANDLER.COMMAND EQ EMPTY THEN RETURN
*
*@@@ COM.AIP REC LOAD
WKO$OPERATOR = OPER; OPT.DT = DATE(); OPT.TM = TIME(); OPT.PORT = PORT
OPT.COMM = HANDLER.COMMAND<ONE,ONE>; WOF = "SYS"; LOG.REQUIRED = 11001
*
AIX.RESET = FALSE; IF WKO.ID EQ EMPTY THEN AIX.RESET = TRUE
MAT COM.AIP = EMPTY
*
*INCLUDE IBP AI.LOAD.COM.AIP.TIERS
$INCLUDE IBP AI.LOAD.COM.AIP
*CALL AI.SUBR.WRITE.LOG: *
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.AIP.ID,AI.CODE,AI.SRCE,LOG.REQUIRED,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PROG,STAT)
*
HANDLER.COMMAND = OPT.COMM<ONE,ONE>; AI.STATUS = FALSE; SEND.STATUS = FALSE
AI.DVC.NEXT.CN = ONE
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
*
*CALL AI.SUBR.WRITE.COMMAND: *
CALL AI.SUBR.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,1,SYS.PROG,STAT)
IF AI.STATUS EQ "999" THEN STAT = AI.STATUS
*MAT COM.AIP = EMPTY
*
RETURN
*
!
*
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"WAIT FOR COMMAND" "L#19":RVE:; RQM
*
AI.DVC.NEXT.CN = ONE
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
*
*INCLUDE IBP AI.INCL.WAITFOR.COMMAND
CALL AI.SUBR.WAITFOR.COMMAND(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
*CALL AI.UPDT.COM.AIP: *
SEND.COMM.CN = ONE
CALL AI.SUBR.UPDT.COM.AIP.UTL(LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,SEND.COMM.CN,SYS.PROG,STAT)
*
* Clear keyboard buffer * (continue) *
LOOP
TMP = SYSTEM(11); * ULT ONLY
*TMP = TRUE; * REV ONLY
*
UNTIL NOT(TMP) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
*
RETURN
*
*
START.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"START Handler" "L#19":RVE:; RQM
*
UP.ALL.CHANNELS = FALSE
ERR.TEXT = "Do you want to UP any CHANNELS (Y/ALL/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED GT TWO THEN RSP = EMPTY ELSE RSP = EMPTY
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ "KILL" THEN STAT = TRUE; RETURN
IF RSP EQ "Y" OR RSP EQ "ALL" THEN
IF RSP EQ "ALL" THEN UP.ALL.CHANNELS = TRUE
GOSUB UP.CHANNELS; UP.ALL.CHANNELS = FALSE; * : *
END
*
STATUS.CYCLE = TRUE
HANDLER.COMMAND<ONE,-ONE> = FUNC
*
IF ON.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * : *
END
ON.TRIED = ON.TRIED + ONE
IF LEN(COM.AI.ERR) THEN
*?
END
*
GOSUB WRITE.COM.AI; * : *
*
*OUTPUTS = EMPTY
*
FOR PORT.TYPE = ONE TO TWO
*Turn on monitor and handler
*
OUTPUTS = EMPTY; 
NUM.EXECS = ZERO; START.CONT = TRUE
*
LOOP
*
IF START.CONT THEN
*
NUM.EXECS = NUM.EXECS + ONE
IF LEN(TEXT) THEN ERR.DISP.ONLY = TWO; GOSUB ERROR; * : *
IF PORT.TYPE EQ ONE THEN ERR.TMP = "MONITOR" ELSE ERR.TMP = "HANDLER"
ERR.TEXT = "Starting ":ERR.TMP:". Enter N to cancel or <cr>: "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED GT 10 THEN RSP = "N" ELSE RSP = EMPTY
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ "KILL" THEN STAT = TRUE; RETURN
IF RSP EQ "N" THEN START.CONT = 3
*
IF PORT.TYPE EQ ONE THEN PORT.ON = COM.AI$MONITOR.PORT ELSE PORT.ON = COM.AI$COMMPORT
* IF RSP MATCHES "3N" THEN PORT.ON = RSP
* LOOP WHILE LEN(PORT.ON) LT 3 DO PORT.ON = ZERO:PORT.ON REPEAT
*
IF START.CONT AND START.CONT NE 3 THEN
*
PRINT @(ZERO,16):(AI.CODE:" ":ERR.TMP:" on ":PORT.ON:".") "L#30"
OUTPUTS<-ONE> = ""; *PRINT " " "L#30"
OUTPUTS<-ONE> = "Now attempting start-up . . ." "L#30"
EXEC.IN = PORT.ON + ZERO:",AI.":ERR.TMP:".":AI.CODE
IF COM.AI$PORT.PASS NE EMPTY THEN
EXEC.IN = EXEC.IN:",":COM.AI$PORT.PASS
END
EXEC.VERB = "LOGON"
EXEC.OUT = EMPTY
OUTPUTS<-ONE> = " " "L#30"
OUTPUTS<-ONE> = EXEC.VERB "L#30"
OUTPUTS<-ONE> = EXEC.IN "L#30"
OUTPUTS<-ONE> = " " "L#30"
*
*ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN, //OUT. > EXEC.OUT
*
LOOP WHILE LEN(EXEC.OUT) AND EXEC.OUT<ONE> EQ EMPTY DO DEL EXEC.OUT<ONE> REPEAT
OUTPUTS<-ONE> = EXEC.OUT
*
START.CONT = NOT(INDEX(EXEC.OUT,"uccessful",ONE) + INDEX(EXEC.OUT,"lready",ONE)) * TWO
IF START.CONT EQ TWO THEN
START.CONT = NOT(INDEX(EXEC.OUT,"UCCESSFUL",ONE) + INDEX(EXEC.OUT,"LREADY",ONE)) * TWO
END
*
END; * cont
END; * cont
*
IF RUN.TYPE EQ TWO THEN ERR.CR = FALSE; ERR.DISP.ONLY = TWO
ERR.BELL = FALSE; TEXT = OUTPUTS:AM:TEXT; GOSUB ERROR; ERR.BELL = TRUE
*
UNTIL NOT(START.CONT) OR START.CONT GE TWO OR NUM.EXECS GE 3 DO REPEAT
*
NEXT PORT.TYPE
*
!
*
IF NOT(START.CONT) OR START.CONT EQ TWO THEN
*
IF NOT(START.CONT) THEN
* AI.STATUS = FALSE; SEND.STATUS = FALSE; WF.C.FUNC = PORT.KEY
WF.C.FUNC = PORT.KEY
GOSUB WAITFOR.COMMAND; * : *
*IF AI.STATUS GE 100 AND AI.STATUS NE 121 THEN START.CONT = AI.STATUS
IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) AND AI.STATUS NE 121 THEN START.CONT = AI.STATUS
END
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
***AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * : *
*
IF LEN(COM.AI.ERR) THEN
*
COM.AI.ERR.CN.MAX = DCOUNT(COM.AI.ERR,AM)
COM.AI.ERR.CN = ONE
TEXT<-ONE> = EMPTY
*
LOOP WHILE COM.AI.ERR.CN LE COM.AI.ERR.CN.MAX DO
*
IF NUM(COM.AI.ERR<COM.AI.ERR.CN>) THEN
IF COM.AI.ERR<COM.AI.ERR.CN> THEN
IF COM.AI.ERR<COM.AI.ERR.CN> NE ERR$NOT.SENT THEN
IF NOT(COM.AI.ERR<COM.AI.ERR.CN> LT 100 OR COM.AI.ERR<COM.AI.ERR.CN> GE 600) AND COM.AI.ERR<COM.AI.ERR.CN> GT START.CONT THEN START.CONT = COM.AI.ERR<COM.AI.ERR.CN>; AI.STATUS = START.CONT
END
TEXT<-ONE> = "[":INTFC.CODE:("000":COM.AI.ERR<COM.AI.ERR.CN>) "R#3":"] ":COM.AI.ERR.TEXT<COM.AI.ERR.CN>
TEMP = FALSE
END ELSE TEMP = TRUE
END ELSE TEMP = TRUE
IF TEMP THEN TEXT<-ONE> = "[":INTFC.CODE:"   ] ":COM.AI.ERR.TEXT<COM.AI.ERR.CN>
*
COM.AI.ERR.CN = COM.AI.ERR.CN + ONE
*
REPEAT
*
END; * cnt.ai.err
*
END; * start.cont
*
!
*
*IF START.CONT THEN
IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) OR START.CONT THEN
*
DT = DATE(); TM = TIME()
FUNC.RELOOP = FALSE; IF RUN.TYPE EQ TWO THEN ERR.CR = FALSE; ERR.DISP.ONLY = TWO
*
TEXT = OUTPUTS:AM:TEXT
*
TEXT<-ONE> = "[":AI.STATUS:"] Your attempt to ":FUNC:" the HANDLER failed!"; GOSUB ERROR; * : *
!
*
IF ON.TRIED GT ONE THEN
*
ERR.TEXT = "Do you want to LOGOFF the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED LE TWO THEN RSP = "Y" ELSE RSP = "N"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB LOGOFF.PORT; * : *
FUNC.RELOOP = TRUE
END ELSE
*
ERR.TEXT = "Do you want to RESTART the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF UP.TRIED LE 4 THEN RSP = "Y" ELSE RSP = "N"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB RESTART.PORT; * : *
FUNC.RELOOP = TRUE
END
END; * no logoff, ? restart
*
!
*
IF NOT(FUNC.RELOOP) THEN
*
ERR.TEXT = "Do you want the HANDLER flagged as ":FUNC:" anyway (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF UP.TRIED GT 6 THEN RSP = "Y" ELSE RSP = "N"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
LCK.ITM = TRUE; LCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF LCK.COM.AI THEN
IF FUNC EQ AI.ON OR FUNC EQ AI.OFF THEN
COM.AI$ON.OFF.STAT = FUNC
COM.AI$ON.OFF.C.DT = DT
COM.AI$ON.OFF.C.TM = TM
COM.AI$ON.OFF.BY   = OPER:".SYS"
END ELSE IF FUNC EQ AI.UP OR FUNC EQ AI.DN THEN
COM.AI$UP.DN.STAT = FUNC
COM.AI$UP.DN.C.DT = DT
COM.AI$UP.DN.C.TM = TM
COM.AI$UP.DN.BY   = OPER:".SYS"
END
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","G","",LCK.STAT)
LCK.COM.AI = FALSE
END
END; * 'Y' to flag
*
!
*
ERR.TEXT = "Do you want to try the START again (<cr>/N): "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED GT 10 THEN RSP = "N" ELSE RSP = "Y"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "Y"
IF RSP EQ "Y" THEN FUNC.RELOOP = TRUE
*
END; * start.cont gt 1
*
END; * func.reloop
*
ON.TRIED = ON.TRIED + ONE
*
IF FUNC.RELOOP THEN GOTO START.HANDLER
*
END; * start.cont
*
*
RETURN
*
!
*
LOGOFF.PORT: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"LOGOFF Port" "L#19":RVE:; RQM
*
EXEC.VERB = "LOGOFF"
TEMP.PORT = COM.AI$COMMPORT
LOOP WHILE LEN(TEMP.PORT) LT 3 DO TEMP.PORT = "0":TEMP.PORT REPEAT
EXEC.IN = TEMP.PORT
EXEC.OUT = EMPTY
*
*ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN, //OUT. > EXEC.OUT
*
LOOP WHILE LEN(EXEC.OUT) AND EXEC.OUT<ONE> EQ EMPTY DO DEL EXEC.OUT<ONE> REPEAT
IF LEN(EXEC.OUT) THEN
TEXT<-ONE> = EXEC.VERB
TEXT<-ONE> = EXEC.IN
TEXT<-ONE> = EXEC.OUT
OUTPUTS<-ONE> = "":AM:TEXT
ERR.DISP.ONLY = 3; GOSUB ERROR
END
*
RETURN
*
*
RESTART.PORT: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"RESTART Port" "L#19":RVE:; RQM
*
EXEC.VERB = ":RESTARTLINE"
TEMP.PORT = COM.AI$COMMPORT
LOOP WHILE LEN(TEMP.PORT) LT 3 DO TEMP.PORT = ZERO:TEMP.PORT REPEAT
EXEC.VERB = EXEC.VERB:" ":TEMP.PORT
EXEC.IN = EMPTY
EXEC.OUT = EMPTY
*
* ULT ONLY
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
*
LOOP WHILE LEN(EXEC.OUT) AND EXEC.OUT<ONE> EQ EMPTY DO DEL EXEC.OUT<ONE> REPEAT
IF LEN(EXEC.OUT) THEN
TEXT<-ONE> = EXEC.VERB
TEXT<-ONE> = EXEC.OUT
OUTPUTS<-ONE> = "":AM:TEXT
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
*
RETURN
*
*
STOP.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"STOP Handler" "L#19":RVE:; RQM
*
HANDLER.COMMAND<ONE,-ONE> = FUNC
*
WRITE "1" ON COM.FILE,"AI.OFF.":COM.AI$MONITOR.PORT
WRITE "1" ON COM.FILE,"AI.OFF.":COM.AI$COMMPORT
*
IF OFF.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * :
END
OFF.TRIED = OFF.TRIED + ONE
*
*@@@
RETURN
*
*
UP.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Up Handler" "L#19":RVE:; RQM
*
HANDLER.COMMAND<ONE,-ONE> = FUNC
IF UP.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * :
END
UP.TRIED = UP.TRIED + ONE
*
*@@@
RETURN
*
*
DOWN.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Down Handler" "L#19":RVE:; RQM
*
HANDLER.COMMAND<ONE,-ONE> = FUNC
IF DN.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
GOSUB INTFC.CHECK; * :
END
DN.TRIED = DN.TRIED + ONE
*
*@@@
RETURN
*
!
*
UP.CHANNELS: *
*
*CALL AI.CHANNEL.UP: *
CALL AI.CHANNEL.UP(TEXT,ERR.DISP.ONLY,ERR.CLB,COM.FILE,CNT.FILE,PAR.FILE,LCK.FILE,CO.DATA,CHANNEL.MLES,DOWNED.CHANNELS.CHANGED,AI.CODE,MAT COM.AI,MAT CNT.TST,UP.ALL.CHANNELS,OPER,FAST.DISPLAY,RUN.TYPE,LCK.TYPE,STL,MAT COM.AIHERR,SYS.PROG,STAT)
IF STAT EQ 999 THEN AI.STATUS = STAT
*
RETURN
*
!
*
DOWN.CHANNELS: *
*
*CALL AI.CHANNEL.DN: *
CALL AI.CHANNEL.DN(TEXT,ERR.DISP.ONLY,ERR.CLB,COM.FILE,CNT.FILE,PAR.FILE,LCK.FILE,CO.DATA,CHANNEL.MLES,DOWNED.CHANNELS.CHANGED,AI.CODE,MAT COM.AI,MAT CNT.TST,UP.ALL.CHANNELS,OPER,FAST.DISPLAY,RUN.TYPE,LCK.TYPE,STL,MAT COM.AIHERR,SYS.PROG,STAT)
IF STAT EQ 999 THEN AI.STATUS = STAT
*
RETURN
*
!
*
SPECIAL.FUNC: *
*
CALL AI.CNTRL.FUNC(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
RETURN
*
!
*
DISPLAY.STATUS: *
*
!
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Display Status" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.INCL.INTFC.DISPLAY
*
RETURN
*
!
*
*LOAD.TITLE: *
*DISPLAY.TITLE: *
$INCLUDE IBP AI.CNTRL.UTIL.DISP.HDR
*
!
*
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,CHECK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
IF STAT EQ 999 THEN AI.STATUS = 999
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
*
RETURN
*
END
~AI.DELETE.BOX~
SUBROUTINE AI.DELETE.BOX(AIX.FILE,LCK.FILE,CNT.FILE,PAR.FILE,PRIOR.ADDRESS,TEXT,HANDLER.DOWN,SYS.PRNT,STAT)
*
*      Delete an address from the addressable interface cross reference...
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.DELETE.BOX"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
!
RETURN
!
SYS.ID = FIELD(PRIOR.ADDRESS,"*",1)
GROUP = FIELD(PRIOR.ADDRESS,"*",2)
BOXNUM = FIELD(PRIOR.ADDRESS,"*",3)
AIX.ID = SYS.ID:"*":GROUP
STAT = 0
LCK.TYPE = STAT
CALL SYS.ITM.LCK("AIX",AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
STAT = LCK.STAT
IF STAT THEN TEXT = "file locking failure"; RETURN
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
LOCATE BOXNUM IN AIX$BOX<1> BY "AR" SETTING VC THEN
DEL AIX$BOX<1,VC>
DEL AIX$DVC.ID<1,VC>
DEL AIX$SVC.ID<1,VC>
DEL AIX$BOX.FLAG<1,VC>
DEL AIX$CHAN.FLAG<1,VC>
DEL AIX$PC.FLAG<1,VC>
DEL AIX$EVENT.FLAG<1,VC>
DEL AIX$REMOTE.FLAG<1,VC>
DEL AIX$STEREO.FLAG<1,VC>
DEL AIX$RESERVED.FLAG<1,VC>
MATWRITE AIX ON AIX.FILE,AIX.ID
AIW.ID = ""
* CALL AI.BOX.COMMAND(AIX.FILE,CNT.FILE,PAR.FILE,PRIOR.ADDRESS,AIW.ID,HANDLER.DOWN,SYS.PROG,STAT)
END
CALL SYS.ITM.RLS("AIX",AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
RETURN
!
END
~AI.HANDLER~
*PROGRAM: AI.HANDLER
* VERSION: 940130 1.1  AIL.SEQ.ID CHANGED, COM.AI.ID CHANGED.
* CNT.TST$Z SETS CNT.TST$CR TO FALSE (13JAN94).
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   1990         ALL RIGHTS RESERVED
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "901028 NEW"
VS = "901028 NEW (1.0)"
*
* : * System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.HANDLER"; SYS.LOCT = EMPTY
SYS.PRNT = EMPTY; SYS.APPL.LOC = ONE
AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE; DISP.ONLY = FALSE
OPER = "SYS"; EXP.TM = EMPTY
*              Addressable Interface HANDLER.
*    __________
*
*    COM.AI$LOGGING      nothing will be logged if null
*
*  COM.AI$TEST.MODE 2    hexadecimal command/result fields will
*                        be returned and every command (including
*                        routine status checks) will be logged.
*                   1    hexadecimal result fields will be returned
*                        and every command (as for TEST.MODE = 2) will be
*                        logged.
*                   ""   no hexadecimal command/result fields will
*                        be returned (in the interest of speed) and routine
*                        status checks which return no errors will not
*                        be logged.
*
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AIL.DIM
$INCLUDE IBP AIL.EQUATES
*
! Input Parameters
*
$INCLUDE IBP AI.ERR.INIT
*
AI.TALK = EMPTY
INPUT AI.CODE:; COM.AI.ID = "AI.TYPE.":AI.CODE
OPER = AI.CODE
*
! : * System Control
*
PORTS.LIST.BUILD = 9; PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY
FAST.DISPLAY = FALSE; AI.SCAN = TRUE
DT = DATE(): TM = TIME()
*
LCK.TYPE = -5
LCK.ELP = ZERO; LCK.ELP.MAX = 120
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.STAT = LCK.TYPE
*
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
* : * Control Flags
* $INCLUDE IBP TST.VAR.EQUATES
* EQU TST$AM TO 12, TST$VM TO 9
*
OPEN "CNT" TO CNT.FILE ELSE CHAIN "FREEZE.PORT"
READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.DATA<ONE,ONE> ELSE CO.NAME = EMPTY; CO.DATA = EMPTY
OPEN "PAR" TO PAR.FILE ELSE CHAIN "FREEZE.PORT"
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE CHAIN "FREEZE.PORT"
* LCK.FILE = ZERO; * REV ONLY
*
* IF SYS.TST EQ EMPTY THEN
* READ SYS.TST FROM CNT.FILE,"SYS.TST":SYS.APPL.SUB ELSE SYS.TST = ""
* END
CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
SYS.LOCT = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*SYS.LOCT = "?"; IF CNT.TST$LBL THEN PRINT @(50,20):(SYS.LOCT:" ?") "L#28":; IF CNT.TST$CR THEN INPUT TMP:
CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
*
*
! : * Application Records
SYS.LOCT = "AR"; IF CNT.TST$LBL THEN PRINT @(50,20):"Application Records" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
COM.AI.PORT.REC = EMPTY
WRITE.REQUIRED = TRUE
*
AIL.SEQ.ID = EMPTY; AIL.SEQ = EMPTY; AIL.ID = EMPTY
*
* $INCLUDE IBP AIX.DIM
* $INCLUDE IBP AIX.EQUATES
*
* $INCLUDE IBP DVC.DIM
* $INCLUDE IBP DVC.EQUATES
*
*
! : * Application Parameters and Tables
SYS.LOCT = "APT"; IF CNT.TST$LBL THEN PRINT @(50,20):"Application Parameters and Tables" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
MAT COM.AIHERR = EMPTY
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
MAT COM.AIIERR = EMPTY
*
COMPONENTS = EMPTY; CHANNEL.MLES = EMPTY; CHAN.ALL = FALSE
STATUS.LOC = ONE; STATUS.CYCLE = FALSE
STVC = ZERO; BVC = ZERO; ACTIONS = EMPTY; PRIOR.CHANNEL.MLES = EMPTY
STL = EMPTY; LOG.REQUIRED = 22001
SYS11 = ZERO; SYS11.PREV = ZERO
*
*
! : * System Files
SYS.LOCT = "SF"; IF CNT.TST$LBL THEN PRINT @(50,20):"System Files" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "COM" TO COM.FILE ELSE CHAIN "FREEZE.PORT"
*
OPEN "DICT","ACC" TO ACC.FILE ELSE CHAIN "FREEZE.PORT"
*
*
! : * Application Files
SYS.LOCT = "AF"; IF CNT.TST$LBL THEN PRINT @(50,20):"Appl Files" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "AIX" TO AIX.FILE ELSE CHAIN "FREEZE.PORT"
*
OPEN "DVC" TO DVC.FILE ELSE CHAIN "FREEZE.PORT"
*
OPEN "ACT" TO ACT.FILE ELSE CHAIN "FREEZE.PORT"
*
OPEN "AIL" TO AIL.FILE ELSE CHAIN "FREEZE.PORT"
*
*
! : * Init INternal VARiables
SYS.LOCT = "VAR"; IF CNT.TST$LBL THEN PRINT @(50,20):"Variables" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
AI.SRCE = "H"
*
SEND.STATUS = EMPTY; SEND.COMM = TRUE; SEND.RETRY = TRUE; SEND.WAIT = ZERO
SEND.DONE = FALSE; SEND.UP.DN = EMPTY; SEND.CN = ZERO; SEND.CN.MAX = 3
SEND.RETRY.PAUSE = ONE
SEND.NO.RSP = ZERO
*
COM.AI.ERR.DISP = FALSE; ERR.DISP.ONLY = FALSE; ERR.CLB = FALSE
*
CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 28
CHECK.LEN = 30; CHECK.LN.HI = ZERO; CHECK.ELP.MAX = LCK.ELP.MAX
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
*
! : * Init Tables
SYS.LOCT = "TBL"; IF CNT.TST$LBL THEN PRINT @(50,20):"Tables" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
*
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
READ COM.AIICMD FROM COM.FILE,"AI.COMMANDS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE COM.AIICMD = EMPTY
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE MAT COM.AIIERR = EMPTY
*
HEADEND = EMPTY; COMPONENTS.DFLT = EMPTY; INTFC.CODE = EMPTY
LCK.ITM = TRUE; LCK.RELS = TRUE
GOSUB READ.STL
*
*
! : * Start Program
*
*
SYS.LOCT = "START"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
DT = DATE(); TM = TIME(); ELP = ZERO; LCK.ELP.MAX = 120
*
* : * Read COM.AI
LOOP
*
LCK.STAT = FALSE; LCK.ITM = TRUE; LCK.RELS = FALSE
GOSUB READ.COM.AI; * : *
* IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
*
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
UNTIL NOT(LCK.STAT) OR ELP GT LCK.ELP.MAX DO REPEAT
IF LCK.STAT THEN AI.RESET = TRUE ELSE LCK.COM.AI = TRUE
*
DT = DATE(); TM = TIME()
*
* : * Record that the handler is in an ON state
COM.AI$ON.OFF = AI.ON; COM.AI$ON.OFF.DT = DT; COM.AI$ON.OFF.TM = TM
COM.AI$COMMAND = AI.ON
AI.TS = 8
IF NUM(COM.AI$FUNC.TS) THEN
IF COM.AI$FUNC.TS GT ZERO THEN
AI.TS = COM.AI$FUNC.TS
EXEC.VERB = "TIMESLICE ":AI.TS + 0
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
END
END
LOCATE PORT.NUM IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
END
** INS PORT.NUM BEFORE COM.AI$FUNC.PORT<ONE,ONE>
WRITE.REQUIRED = TRUE; PORT.LOC = ONE
** IF WRITE.REQUIRED THEN
** IF NOT(LCK.STAT) THEN
IF LCK.COM.AI THEN
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
SYS.LOCT = "WR.COM.AI"; IF CNT.TST$LBL THEN PRINT @(20,20):("Write Com Ai ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
* PRINT OCONV(DT,"D2"):" ":OCONV(TM,"MTS")
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
LCK.COM.AI = FALSE
* WRITE.REQUIRED = FALSE
END
* WRITE.REQUIRED = TRUE; PORT.LOC = ONE
*
* : * Clear the input buffer
GOSUB BUF.CLEAR
*
* : * Reset this port
GOSUB RESET.HANDLER; * : *
* GOSUB FULL.STATUS.CHECK; * : *
*
PRIOR.CHANNEL.MLES = CHANNEL.MLES
* This will trigger a complete system status check
RESET.FREQ = -COM.AI$RESET.FREQ
SCAN.FREQ = -COM.AI$SCAN.FREQ; FIRST.LOOP = TRUE
FUNC.TS.FL = FALSE
PAUSE.TS.FL = FALSE
BROADCAST.REQUIRED = TRUE; PORT.REQUIRED = TRUE
*
* * : * Record that the handler is in an ON state
* COM.AI$ON.OFF = AI.ON; COM.AI$ON.OFF.DT = DT; COM.AI$ON.OFF.TM = TM
* COM.AI$COMMAND = AI.ON
* LOCATE PORT.NUM IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
* DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
* END
* INS PORT.NUM BEFORE COM.AI$FUNC.PORT<ONE,ONE>
* WRITE.REQUIRED = TRUE; PORT.LOC = ONE
WRITE.REQUIRED = TRUE
* *
* !
*
* : * Record a successful start up
OFFED = FALSE
DOWNED = FALSE
PORT.NUM = PORT.KEY
LOG.REQUIRED = 22002
GOSUB WRITE.LOG; * : *
*
*
*
! : * MAIN LOOP
*
*
LOOP UNTIL OFFED AND COM.AI$FUNC.PORT EQ EMPTY DO
*
DT = DATE(); TM = TIME()
*
IF NOT(LCK.COM.AI) THEN
*
IF FIRST.LOOP THEN AI.RESET = TRUE ELSE
*
SYS11 = SYSTEM(11)
IF SYS11 GT 10 THEN GOSUB BUF.CLEAR; * : *
*
IF SYS11 EQ SYS11.PREV AND NOT(OFFED) AND COM.AI$FUNC.PORT EQ EMPTY THEN
*
IF NOT(FIRST.LOOP) AND NOT(PAUSE.TS.FL) THEN
AI.TS = 4
IF NUM(COM.AI$PAUSE.TS) THEN
IF COM.AI$PAUSE.TS GT ZERO THEN
AI.TS = COM.AI$PAUSE.TS
END
END
EXEC.VERB = "TIMESLICE ":AI.TS + 0
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
SYS.LOCT = "STD.PAUSE.TS"; IF CNT.TST$LBL THEN PRINT @(20,20):("Pause set timeslice ":COM.AI$PAUSE.TS) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
PAUSE.TS.FL = TRUE; FUNC.TS.FL = FALSE
END
*
EXEC.VERB = "SLEEP ":COM.AI$STD.PAUSE
SYS.LOCT = "STD.PAUSE.1"; IF CNT.TST$LBL THEN PRINT @(20,20):("Standard Pause ":COM.AI$STD.PAUSE) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
EXECUTE EXEC.VERB
*
END
SYS11.PREV = SYS11
*
END; * of FIRST.LOOP
*
LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.ELP.MAX = 120
GOSUB READ.COM.AI; * : *
* IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
*
END; * of not(LCK.COM.AI)
*
IF LCK.COM.AI THEN
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
IF (COM.AI$MAX.PAUSE / 8 LE COM.AI.RUN.ELP) THEN WRITE.REQUIRED = TRUE
*
!
*
* : * Do all CNTRL commands
LOOP WHILE INDEX("#ON#OFF#UP#DN#","#":COM.AI$COMMAND:"#",ONE) DO
*
DT = DATE(); TM = TIME(); WRITE.REQUIRED = TRUE
*
COM.AI$COMMAND.DT = DT
COM.AI$COMMAND.TM = TM
* LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
* DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
* END
*
IF COM.AI$COMMAND EQ AI.ON OR COM.AI$COMMAND EQ AI.OFF THEN
*
SYS.LOCT = "INTFC.ON.OFF"; IF CNT.TST$LBL THEN PRINT @(20,20):(COM.AI$COMMAND:" Intfc") "L#28":; IF CNT.TST$CR THEN INPUT TMP:
COM.AI$ON.OFF.STAT = COM.AI$ON.OFF
COM.AI$ON.OFF.C.DT = DT
COM.AI$ON.OFF.C.TM = TM
IF COM.AI$ON.OFF EQ AI.OFF THEN OFFED = TRUE; DOWNED = TRUE; COM.AI$UP.DN = AI.DN
LOG.REQUIRED = 23003
* WRITE.REQUIRED = TRUE
*
END
*
IF COM.AI$COMMAND EQ AI.DN OR COM.AI$COMMAND EQ AI.UP THEN
*
SYS.LOCT = "INTFC.UP.DN"; IF CNT.TST$LBL THEN PRINT @(20,20):(COM.AI$COMMAND:" Intfc") "L#28":; IF CNT.TST$CR THEN INPUT TMP:
COM.AI$UP.DN.STAT = COM.AI$UP.DN
COM.AI$UP.DN.C.DT = DT
COM.AI$UP.DN.C.TM = TM
IF COM.AI$UP.DN EQ AI.DN THEN DOWNED = TRUE
LOG.REQUIRED = 23004
* WRITE.REQUIRED = TRUE
*
END
*
IF WRITE.REQUIRED AND COM.AI$COMMAND[ONE,ONE] NE "*" THEN COM.AI$COMMAND = "*":COM.AI$COMMAND
*
REPEAT ; * for FUNC.PORT eq a command on,off,up,dn
*
DT = DATE(); TM = TIME()
*
*
!
* of LCK.COM.AI
*
IF WRITE.REQUIRED AND LCK.COM.AI THEN
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
SYS.LOCT = "WR.COM.AI"; IF CNT.TST$LBL THEN PRINT @(20,20):("Write Com Ai ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
* PRINT OCONV(DT,"D2"):" ":OCONV(TM,"MTS")
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
WRITE.REQUIRED = FALSE
END
*
IF LOG.REQUIRED THEN
GOSUB WRITE.LOG; * : *
END
*
IF LCK.COM.AI THEN
SYS.LOCT = "UN.COM.AI.1"; IF CNT.TST$LBL THEN PRINT @(20,20):("Unlock Com  Ai (1) ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*CALL UNLCK.ITEM COM.AI.ID: *
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","B","",LCK.STAT)
LCK.COM.AI = FALSE
END
* EXECUTE "SLEEP 2"
END
*
!
* : * periodic RESET
*
IF NOT(SEND.WAIT) AND (ABS(TM - RESET.FREQ) GT COM.AI$RESET.FREQ OR AI.RESET) THEN
*
* IF AI.RESET THEN
GOSUB RESET.HANDLER; * : *
* END ELSE
* GOSUB FULL.STATUS.CHECK; * : *
* END
*
*
IF LCK.COM.AI THEN
SYS.LOCT = "UN.COM.AI.2"; IF CNT.TST$LBL THEN PRINT @(20,20):("Unlock Com  Ai (2) ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*CALL UNLCK.ITEM COM.AI.ID: *
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","C","",LCK.STAT)
LCK.COM.AI = FALSE
END
* EXECUTE "SLEEP 2"
END
*
END; * of RESET
*
!
*
*
SCAN.CONT = TRUE; FIRST.PORT = TRUE
IF SEND.WAIT AND (TM GT SEND.WAIT) THEN
SEND.WAIT = ZERO; COM.AI$UP.DN.STAT = SEND.UP.DN; SEND.UP.DN = EMPTY
WRITE.REQUIRED = TRUE
END
*
!
*
*
* IF COM.AI$UP.DN.STAT EQ AI.DN THEN SCAN.CONT = FALSE
* ^ NOT VALID BECAUSE UP/DN ON/OFF MAY BE SENT TO COMMPORT
*
!
* : * PORT LOOP
*
IF NOT(SEND.WAIT) THEN
*
*
* IF NOT(FIRST.LOOP) AND NOT(FUNC.TS.FL) THEN
* AI.TS = 16
* IF NUM(COM.AI$FUNC.TS) THEN
* IF COM.AI$FUNC.TS GT ZERO THEN
* AI.TS = COM.AI$FUNC.TS
* END
* END
* EXEC.VERB = "TIMESLICE ":AI.TS + 0
* EXEC.IN = EMPTY; EXEC.OUT = EMPTY
* SYS.LOCT = "STD.FUNC.TS"; IF CNT.TST$LBL THEN PRINT @(20,20):("Pause set timeslice ":COM.AI$FUNC.TS) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
* EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
* FUNC.TS.FL = TRUE; PAUSE.TS.FL = FALSE
* END
* *
* !
* *
LOOP WHILE (ABS(TIME() - SCAN.FREQ) GT COM.AI$SCAN.FREQ OR COM.AI$FUNC.PORT NE EMPTY OR CNT.TST$LBL EQ TWO) AND SCAN.CONT AND NOT(SEND.WAIT) DO
*
SYS.LOCT = "PORT.PROC"; IF CNT.TST$LBL THEN PRINT @(20,20):"Process Ports" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
IF NOT(FIRST.PORT) OR NOT(LCK.COM.AI) THEN
LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.ELP.MAX = 120
GOSUB READ.COM.AI; * : *
* IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
END
*
DT = DATE(); TM = TIME()
*
IF NOT(PORT.REQUIRED) THEN PORT.REQUIRED = TRUE
*
LOOP WHILE LEN(COM.AI$FUNC.PORT) AND COM.AI$FUNC.PORT<ONE,ONE> EQ EMPTY DO
DEL COM.AI$FUNC.PORT<ONE,ONE>
WRITE.REQUIRED = TRUE
REPEAT
*
IF CNT.TST$LBL EQ TWO THEN
READV TMP FROM COM.FILE,"AI.RSP.STACK",ONE THEN
TMP1 = "AI*":AI.CODE:"*":TMP<ONE,TWO>:"*LOG"
MATREAD COM.AIP FROM AIL.FILE,TMP1 THEN
DEL COM.AIP$INTFC.STAT<ONE,ONE,ONE>
COM.AIP$COMM.PORT<ONE,ONE> = "TEST"
TMP2 = COM.AIP$LOG.PORT<ONE,ONE,ONE>
IF TMP2 EQ EMPTY THEN TMP2 = "AI*":AI.CODE:"*911*1"
TMP3 = FIELD(TMP2,"*",3)
COM.AI$FUNC.PORT<ONE,-ONE> = TMP3
MATWRITE COM.AIP ON COM.FILE,TMP2
END ELSE NULL
END ELSE
CNT.TST$LBL = ONE
END
END
*
IF LEN(COM.AI$FUNC.PORT) THEN
PORT.NUM = COM.AI$FUNC.PORT<ONE,ONE>
* DEL COM.AI$FUNC.PORT<ONE,ONE>
WRITE.REQUIRED = TRUE
END ELSE
PORT.NUM = PORTS.LIST<ONE,PORT.VC>
PORT.VC = PORT.VC + ONE
END
*
IF LEN(PORT.NUM) THEN
IF NUM(PORT.NUM) THEN
*
LOOP WHILE LEN(PORT.NUM) LT 3 DO PORT.NUM = ZERO:PORT.NUM REPEAT
AI.DVC.NEXT.FOUND = TRUE; AI.DVC.DONE = TRUE
*
!
*
IF NOT(FIRST.LOOP) AND NOT(FUNC.TS.FL) THEN
AI.TS = 16
IF NUM(COM.AI$FUNC.TS) THEN
IF COM.AI$FUNC.TS GT ZERO THEN
AI.TS = COM.AI$FUNC.TS
END
END
EXEC.VERB = "TIMESLICE ":AI.TS + 0
EXEC.IN = EMPTY; EXEC.OUT = EMPTY
SYS.LOCT = "STD.FUNC.TS"; IF CNT.TST$LBL THEN PRINT @(20,20):("Pause set timeslice ":COM.AI$FUNC.TS) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
FUNC.TS.FL = TRUE; PAUSE.TS.FL = FALSE
END
*
!
*
FOR AI.DVC.NEXT.CN = ONE TO 10 UNTIL NOT(AI.DVC.NEXT.FOUND)
*
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.NUM:"*":AI.DVC.NEXT.CN
SEND.COMM.CN = ZERO; SEND.COMM.CN.MAX = ZERO
*
SYS.LOCT = "LO.COM.AIP"; IF CNT.TST$LBL THEN PRINT @(20,20):("Lock Com Aip ":COM.AIP.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
DT = DATE(); TM = TIME(); LCK.ELP.MAX = 60; ELP = ZERO
LOOP
LCK.STAT = LCK.TYPE
*CALL LCK.ITEM COM.AIP.ID: *
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","D","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
UNTIL NOT(LCK.STAT) OR ELP GT LCK.ELP.MAX DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
*
IF LCK.COM.AIP THEN
*
* LOCATE PORT.NUM IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
* DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
* END
*
SEND.STATUS = EMPTY; SEND.COMM = TRUE; SEND.RETRY = FALSE; SEND.DONE = TRUE
*
SYS.LOCT = "RE.COM.AIP"; IF CNT.TST$LBL THEN PRINT @(20,20):("Read Com Aip ":COM.AIP.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
*
AI.STATUS = FALSE
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
SEND.COMM.CN = ZERO
LOOP
SEND.COMM.CN = SEND.COMM.CN + ONE; * : *
SYS.LOCT = "NXT.COMM"; IF CNT.TST$LBL THEN PRINT @(20,20):("Next Aip Comm ":SEND.COMM.CN:"-":COM.AIP.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*WHILE COM.AIP$COMM<ONE,SEND.COMM.CN> NE "" DO; * : *
WHILE SEND.COMM.CN LE SEND.COMM.CN.MAX DO; * : *
*
SEND.STATUS = EMPTY; SEND.COMM = TRUE; SEND.RETRY = FALSE; SEND.DONE = TRUE
*
*
*
***IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> NE EMPTY AND INDEX("*WAIT*RVRS*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"*",ONE) THEN
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> NE EMPTY OR INDEX("*WAIT*RVRS*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"*",ONE) THEN
*
WRITE.REQUIRED = TRUE; SCAN.CONT = FALSE
*
BEGIN CASE; * : *
*
CASE COM.AIP$COMM<ONE,SEND.COMM.CN,ONE> EQ AI.ON
IF COM.AI$SEND.ON EQ "N" THEN SEND.COMM = FALSE
LOG.REQUIRED = 23006
*
CASE COM.AIP$COMM<ONE,SEND.COMM.CN,ONE> EQ AI.OFF
IF COM.AI$SEND.OFF EQ "N" THEN SEND.COMM = FALSE
LOG.REQUIRED = 23007
*
CASE COM.AIP$COMM<ONE,SEND.COMM.CN,ONE> EQ AI.DN OR COM.AIP$COMM<ONE,SEND.COMM.CN,ONE> EQ AI.UP
SEND.COMM = FALSE
LOG.REQUIRED = 23008
*
CASE COM.AI$UP.DN.STAT EQ AI.DN
SEND.COMM = FALSE
LOG.REQUIRED = 23009
*30MAR94* SEND.STATUS = ERR$NOT.SENT
*
CASE TRUE
*
END CASE; * : *
*
IF SEND.COMM THEN
GOSUB SEND.COMMAND; * : *
IF SEND.STATUS EQ "0" THEN SEND.STATUS = EMPTY
IF SEND.STATUS EQ "00" THEN SEND.STATUS = EMPTY
IF AI.STATUS OR SEND.STATUS NE EMPTY THEN
AI.DVC.DONE = FALSE
LOG.REQUIRED = 27001
END
END ELSE
SYS.LOCT = "NOT.COMM.SEND"; IF CNT.TST$LBL THEN PRINT @(50,20):("Not Sent ":OPT.COMM:" ":SEND.COMM.CN:" ":SEND.CN) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
**AI.DVC.DONE = TRUE
**SEND.STATUS = ERR$NOT.SENT
SEND.STATUS = EMPTY
**INS ERR$NOT.SENT    BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
**INS ERR$HANDLER.MSG BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
*
* COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
* COM.AIP$COMM.C.DT = DT
* COM.AIP$COMM.C.TM = TM
IF NOT(NUM(COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>)) THEN COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = ZERO
***COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> + ONE
IF SEND.CN GT COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> THEN COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = SEND.CN
*
IF AI.STATUS THEN
INS AI.STATUS BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
LOG.REQUIRED = 27002
END
*
* Command was not sent; * : *
IF NOT(SEND.COMM) THEN
*
IF NOT(LEN(SEND.STATUS)) THEN
*
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
COM.AIP$COMM.C.DT = DT
COM.AIP$COMM.C.TM = TM
INS ERR$NOT.SENT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.MSG BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
*
END ELSE
*
**IF COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT" THEN
**INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
**INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
**COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
**COM.AIP$COMM.C.DT = DT
**COM.AIP$COMM.C.TM = TM
**END
*@@@*INS ERR$NOT.SENT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS SEND.STATUS     BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
**IF AI.STATUS OR SEND.STATUS NE EMPTY THEN AI.DVC.DONE = FALSE
LOG.REQUIRED = 27010
*
BEGIN CASE; * : *
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
LOOP
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
WHILE SEND.COMM.CN LE SEND.COMM.CN.MAX DO SEND.COMM.CN = SEND.COMM.CN + ONE REPEAT
COM.AIP$COMM.C.DT = DT
COM.AIP$COMM.C.TM = TM
LOG.REQUIRED = 27011
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
LOOP
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
WHILE SEND.COMM.CN LE SEND.COMM.CN.MAX DO SEND.COMM.CN = SEND.COMM.CN + ONE REPEAT
AI.DVC.DONE = FALSE
LOG.REQUIRED = 27012
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
* INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
* INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
LOG.REQUIRED = 27013
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
AI.DVC.DONE = FALSE
LOG.REQUIRED = 27014
**NULL
*
CASE TRUE
LOOP
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
WHILE SEND.COMM.CN LE SEND.COMM.CN.MAX DO SEND.COMM.CN = SEND.COMM.CN + ONE REPEAT
COM.AIP$COMM.C.DT = DT
COM.AIP$COMM.C.TM = TM
LOG.REQUIRED = 27019
*
END CASE; * : *
*
AI.DVC.DONE = FALSE
*
END; * of SEND.STATUS
*
END ELSE
*
!
*
* Command was sent; * : *
*
IF (AI.STATUS LE 100 OR AI.STATUS GE 600) AND NOT(LEN(SEND.STATUS)) THEN
*
* Send was successful
*
BEGIN CASE; * : *
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
INS "DONE" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
*
CASE TRUE
*Should not happen
NULL; * DONE XCEL COMP
*
END CASE; * : *
*
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
*@@@@@*COM.AIP$COMM.C.DT = DT
*@@@@@*COM.AIP$COMM.C.TM = TM
*
* END ELSE IF NOT(SEND.RETRY OR SEND.WAIT) THEN
END ELSE IF NOT(SEND.WAIT) THEN; * : *
*
* sent but not successful
*
AI.DVC.DONE = FALSE
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
LOG.REQUIRED = 24110; * 
*
BEGIN CASE; * : *
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> = "RVRS"
SEND.DONE = FALSE
LOG.REQUIRED = 24111
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> = "WAIT"
**IF NOT(SEND.RETRY AND SEND.CN LT SEND.CN.MAX) THEN
***IF NOT(SEND.CN LT SEND.CN.MAX) THEN
IF NOT(SEND.RETRY) OR SEND.CN GE SEND.CN.MAX THEN
LOOP
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
WHILE SEND.COMM.CN LT SEND.COMM.CN.MAX DO SEND.COMM.CN = SEND.COMM.CN + ONE REPEAT
**LOG.REQUIRED = 28112
COM.AIP$COMM.C.DT = DT
COM.AIP$COMM.C.TM = TM
END ELSE SEND.DONE = FALSE
LOG.REQUIRED = 28112
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> = "DONE"
**IF NOT(SEND.RETRY AND SEND.CN LT SEND.CN.MAX) THEN
IF NOT(SEND.RETRY) OR SEND.CN GE SEND.CN.MAX THEN
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
**LOG.REQUIRED = 28113
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = PORT
COM.AIP$COMM.C.DT = EMPTY
COM.AIP$COMM.C.TM = EMPTY
*@@@@@*COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
*@@@@@*COM.AIP$COMM.C.DT = DT
*@@@@@*COM.AIP$COMM.C.TM = TM
END ELSE SEND.DONE = FALSE
LOG.REQUIRED = 28113
*
CASE TRUE
*Should not happen
LOG.REQUIRED = 28114
NULL; * DONE XCEL COMP
*
END CASE; * : *
*
IF NOT(SEND.DONE) THEN AI.DVC.DONE = FALSE
*
*
*
END ELSE; * : *
*
AI.DVC.DONE = FALSE
SEND.DONE = FALSE
LOG.REQUIRED = 24115
*
END; * of ai.status; * : *
*
END; * of send.comm
*
!
!!!
*
*
BEGIN CASE; * : *
CASE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE EMPTY AND COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE ERR$HANDLER.MSG AND COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE ERR$OK; LOG.REQUIRED = 24014
CASE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> NE EMPTY AND COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> NE ERR$HANDLER.MSG AND COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> NE ERR$OK; LOG.REQUIRED = 24015
CASE COM.AI$TEST.MODE; LOG.REQUIRED = 29016
CASE COM.AI$LOGGING EQ "Y"; LOG.REQUIRED = 25017
CASE TRUE; NULL; * LOG.REQUIRED = 2X018
END CASE; * : *
*
END ELSE
SCAN.CONT = FALSE
SYS.LOCT = "SK.COM.AIP"; IF CNT.TST$LBL THEN PRINT @(20,20):("Skip Port ":COM.AIP.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
END; * of comm.port not empty
*
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> EQ EMPTY AND INDEX("*WAIT*????*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"*",ONE) THEN COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = PORT; AI.DVC.DONE = FALSE
*
IF LOG.REQUIRED THEN COM.AIP$LOG.REQD = 22333
*
REPEAT; * for SEND.COMM.CN; * : *
*
*
SEND.COMM.CN = ONE
*
END ELSE
MAT COM.AIP = EMPTY
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
INS ERR$DATA.BAD BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
* SEND.COMM = FALSE; SCAN.CONT = FALSE
**IF AI.DVC.NEXT.CN = ONE THEN LOG.REQUIRED = 26019
AI.DVC.NEXT.FOUND = FALSE
END; * of read
*
!
*
IF AI.DVC.NEXT.FOUND THEN; * : *
*
WRITE.REQUIRED = TRUE
IF AI.STATUS THEN
SCAN.CONT = FALSE
* INS AI.STATUS BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
* INS ERR$HANDLER.ERR BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
IF NOT(LOG.REQUIRED) THEN LOG.REQUIRED = 24201
END
IF SEND.STATUS THEN
SCAN.CONT = FALSE
* INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
* INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
IF NOT(LOG.REQUIRED) THEN LOG.REQUIRED = 24202
END
*
*
END ELSE
*NOT FOUND; * : *
*
*
IF AI.DVC.DONE THEN
LOCATE PORT.NUM IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
WRITE.REQUIRED = TRUE
END
END
*
END; * of NOT FOUND
*
!
*
IF AI.DVC.NEXT.FOUND THEN; * : *
*
IF (SEND.RETRY OR SEND.WAIT) AND SEND.CN LT SEND.CN.MAX THEN
**IF SEND.RETRY THEN
*
IF NOT(AI.DVC.DONE) THEN
LOCATE PORT.NUM IN COM.AI$FUNC.PORT<ONE> SETTING TMP ELSE
*COM.AI$FUNC.PORT<ONE,-ONE> = PORT.NUM
INS PORT.NUM BEFORE COM.AI$FUNC.PORT<ONE,ONE>
WRITE.REQUIRED = TRUE
END
END
*
*
END ELSE
*
*
*****SEND.COMM.CN = 1; TMP = FALSE
*****LOOP WHILE SEND.COMM.CN LE SEND.COMM.CN.MAX DO
*****IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> NE EMPTY OR INDEX("*WAIT*RVRS*","*":COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>:"*",ONE) THEN TMP = TRUE
*****SEND.COMM.CN = SEND.COMM.CN + ONE
*****REPEAT
******
*****IF TMP THEN
*****SEND.COMM.CN = 1
*****LOOP WHILE SEND.COMM.CN LE SEND.COMM.CN.MAX DO
*****COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = PORT
*****SEND.COMM.CN = SEND.COMM.CN + ONE
*****REPEAT
*****END
*
*
****IF AI.STATUS OR LEN(SEND.STATUS) THEN
****INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
****INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
****END ELSE
****INS "DONE" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
****INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
****END
*****
****INS SEND.STATUS     BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
****INS ERR$HANDLER.MSG BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
*
*
END
*
!
*
END; * of AI.DVC.NEXT.FOUND; * : *
*
IF AI.DVC.NEXT.FOUND THEN
*
SYS.LOCT = "WR.COM.AIP"; IF CNT.TST$LBL THEN PRINT @(20,20):("Write Com Aip ":COM.AIP.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
DT = DATE(); TM = TIME()
* COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
WRITE.REQUIRED = TRUE
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
*
END; * of AI.DVC.NEXT.FOUND
*
*
*
SYS.LOCT = "UN.COM.AIP"; IF CNT.TST$LBL THEN PRINT @(20,20):("Unlock Com Aip ":COM.AIP.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*CALL UNLCK.ITEM COM.AIP.ID: *
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","E","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
* END ELSE
* SEND.COMM = FALSE; SCAN.CONT = FALSE
END; * of not(stat)    ????LOCKED????
*
DT = DATE(); TM = TIME()
IF WRITE.REQUIRED THEN
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
IF LCK.COM.AI THEN
SYS.LOCT = "WR.COM.AI"; IF CNT.TST$LBL THEN PRINT @(20,20):("Write Com Ai ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
END
WRITE.REQUIRED = FALSE
END
*
IF LOG.REQUIRED OR COM.AIP$LOG.REQD THEN
GOSUB WRITE.LOG; * : *
END
**
**
*END; * of AI.DVC.NEXT.FOUND
**
**
NEXT AI.DVC.NEXT.CN; * : *
*
*
* END ELSE
* SEND.COMM = FALSE; SCAN.CONT = FALSE
END; * of port.num is numeric
*
END ELSE
SEND.COMM = FALSE; SCAN.CONT = FALSE
PORT.VC = ONE; SCAN.FREQ = TM
END; * of port.num empty
*
* IF PORT.NUM NE EMPTY THEN
DT = DATE(); TM = TIME()
*
IF WRITE.REQUIRED THEN
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
SYS.LOCT = "WR.COM.AI"; IF CNT.TST$LBL THEN PRINT @(20,20):("Write Com Ai ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
WRITE.REQUIRED = FALSE
END
*
IF LOG.REQUIRED THEN
GOSUB WRITE.LOG; * : *
END
*
* END
*
IF SCAN.CONT OR LCK.COM.AI THEN
SYS.LOCT = "UN.COM.AI.3"; IF CNT.TST$LBL THEN PRINT @(20,20):("Unlock Com  Ai Main (3) ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*CALL UNLCK.ITEM COM.AI.ID: *
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","F","",LCK.STAT)
LCK.COM.AI = FALSE
END
* EXECUTE "SLEEP 2"
END
*
FIRST.PORT = FALSE
*
REPEAT
* : * end of PORT LOOP
*
!
*
END; * of STAT
*
END; * of SEND.WAIT
*
IF LCK.COM.AI THEN
SYS.LOCT = "UN.COM.AI.4"; IF CNT.TST$LBL THEN PRINT @(20,20):("Unlock Com Ai (4) ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*CALL UNLCK.ITEM COM.AI.ID: *
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","G","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
FIRST.LOOP = FALSE
*
SYS.LOCT = "RELOOP"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" RUN") "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
REPEAT
* : * end of MAIN LOOP
*
SYS.LOCT = "END"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" END") "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
STOP; * shut down at operator request
* : * end of RTN
*
!
*
INTFC.CHECK: *
*
SYS.LOCT = "INTFC.CHECK"; IF CNT.TST$LBL THEN PRINT @(50,20):"Check Handler" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
LCK.ELP.MAX = 5
*
$INCLUDE IBP AI.INCL.INTFC.CHECK
$INCLUDE IBP AI.HERROR.XREF
*
LCK.ELP.MAX = 120
RETURN
*
!
*
READ.COM.AI: *
*
SYS.LOCT = "RE.COM.AI.1"; IF CNT.TST$LBL THEN PRINT @(50,20):("Read Com Ai ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
DISP.ONLY = TRUE
*
$INCLUDE IBP AI.READ.COM.AI
*
* IF NOT(LCK.STAT) AND NOT(LCK.RELS) THEN LCK.COM.AI = TRUE
*
RETURN
*
!
*
READ.STL: *
*
$INCLUDE IBP AI.INTFC.STL
*
RETURN
*
!
*
RESET.HANDLER: *
*
SYS.LOCT = "INTFC.RESET"; IF CNT.TST$LBL THEN PRINT @(50,20):"Intfc Reset" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
DT = DATE(); TM = TIME()
AI.STATUS = FALSE; HEADEND = EMPTY; COMPONENTS.DFLT = EMPTY
LCK.ITM = FALSE; LCK.RELS = FALSE
GOSUB READ.STL
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
*
LCK.ITM = TRUE; LCK.RELS = FALSE
GOSUB READ.COM.AI; * : *
* IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
*
* MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE NULL
READ    COM.AIICMD FROM COM.FILE,"AI.COMMANDS.":INTFC.CODE ELSE NULL
END
*
IF ABS(TM - AI.SCAN.TM) GT 5 * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
PORTS.LIST.BUILD = 9; PORTS.LIST.PREV = PORTS.LIST; PORTS.LIST = EMPTY
AI.SCAN.DT = DT AI.SCAN.TM = TM
AI.SCAN = TRUE; SCAN.CONT = TRUE; SCAN.FREQ = -COM.AI$SCAN.FREQ; PORT.VC = ONE
END
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
COM.AI.ERR.DISP = FALSE
GOSUB INTFC.CHECK; * : *
*
IF PORTS.LIST NE PORTS.LIST.PREV THEN
IF PORTS.LIST NE EMPTY THEN
TMP = DCOUNT(PORTS.LIST,AM)
FOR TMP1 = ONE TO TMP
TMP2 = PORTS.LIST<TMP1>
LOCATE TMP2 IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
COM.AI$FUNC.PORT<ONE,-ONE> = PORTS.LIST
END
NEXT TMP1
END
PORTS.LIST.PREV = PORTS.LIST
END
*
DT = DATE(); TM = TIME()
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","H","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
GOSUB FULL.STATUS.CHECK; * : *
*
DT = DATE(); TM = TIME()
AI.RESET = FALSE; RESET.FREQ = TM
*
RETURN
*
!
*
FULL.STATUS.CHECK: *
*
SYS.LOCT = "INTFC.CHECK.1"; IF CNT.TST$LBL THEN PRINT @(50,20):"Intfc Check" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
IF COM.AI$CHAN.DN.BRDCST EQ "Y" THEN
IF BROADCAST.REQUIRED THEN
GOSUB BROADCAST.DN; * : *
END
END
*
RESET.FREQ = TIME()
*
RETURN
*
!
*
BUF.CLEAR: *
*
SYS.LOCT = "BUF.CLEAR"; IF CNT.TST$LBL THEN PRINT @(50,20):"Buffer Clear" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
* : * Clear the input buffer
ECHO OFF
LOOP
LOOP WHILE SYSTEM(11) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
EXEC.VERB = "SLEEP ":COM.AI$STD.PAUSE
SYS.LOCT = "STD.PAUSE"; IF CNT.TST$LBL THEN PRINT @(20,20):("Standard Pause ":COM.AI$STD.PAUSE) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
EXECUTE EXEC.VERB
WHILE SYSTEM(11) DO REPEAT
ECHO ON
*
RETURN
*
!
*
SEND.COMMAND: * send a command to the Control Computer and receive reply...
*
SYS.LOCT = "COMM.SEND.ST"; IF CNT.TST$LBL THEN PRINT @(50,20):("Send Subr ":SEND.COMM.CN) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
*
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE OR COM.AIICMD EQ EMPTY THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE NULL
READ    COM.AIICMD FROM COM.FILE,"AI.COMMANDS.":INTFC.CODE ELSE NULL
END
*
IF COM.AI$LOGGING EQ "Y" THEN LOG.REQUIRED = 25020
*
*
HANDLER.COMMANDS = COM.AIP$COMM
OPT.COMM.CN = ONE
*
*@@*LOOP
*@@**
*@@*OPT.COMM = HANDLER.COMMANDS<ONE,ONE>
*@@*DEL HANDLER.COMMANDS<ONE,ONE>
OPT.COMM = COM.AIP$COMM<ONE,SEND.COMM.CN>
*
SEND.CN = ZERO; SEND.CN.MAX = 3; SEND.RETRY.PAUSE = ONE
IF COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> NE EMPTY THEN
IF COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> NE SEND.CN.MAX THEN
SEND.CN.MAX = COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE>
END
END
*
SEND.AGAIN: * send command again (maximum of 3 tries)
*
LOOP
*
SEND.CN = SEND.CN + ONE
IF NOT(NUM(COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>)) THEN COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = ZERO
COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> + ONE
IF SEND.CN GT COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> THEN COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = SEND.CN
SYS.LOCT = "COMM.SEND"; IF CNT.TST$LBL THEN PRINT @(50,20):("Send Comm ":OPT.COMM:" ":SEND.COMM.CN:" ":SEND.CN) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
DT = DATE(); TM = TIME()
IF LCK.COM.AI THEN
TMP = TM
IF COM.AIP$MAX.PAUSE NE 0 THEN
TMP = TMP + COM.AIP$MAX.PAUSE
END
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TMP
SYS.LOCT = "WR.COM.AI"; IF CNT.TST$LBL THEN PRINT @(20,20):("Write Com Ai ":COM.AI.ID) "L#28":; IF CNT.TST$CR THEN INPUT TMP:
* PRINT OCONV(DT,"D2"):" ":OCONV(TM,"MTS")
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
*** CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
*** LCK.COM.AI = FALSE
*** * WRITE.REQUIRED = FALSE
END
*** * WRITE.REQUIRED = TRUE; PORT.LOC = ONE
*
SEND.STATUS = EMPTY; SEND.RETRY = FALSE
NEXT.COM.AIP.ID = EMPTY
*
IF SEND.COMM THEN
*
*CALL AI.COMMAND.SENDER: *
CALL AI.COMMAND.SENDER(MAT COM.AIP,MAT COM.AI,COM.AIP.ID,AI.CODE,ACTIONS,COM.FILE,LCK.FILE,LCK.TYPE,AI.STATUS,SEND.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,MAT CNT.TST,OPER,EXP.TM,SYS.PROG,STAT)
*
LOCATE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> IN COM.AIIERR$STD<ONE> SETTING ERR.LOC ELSE
LOCATE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> IN COM.AIIERR$RCVD<ONE> SETTING ERR.LOC ELSE
ERR.LOC = ONE
*SEND.STATUS = ERR$UNKNOWN
END
END; * of LOCATE INTFC.ERR
*
!
*
IF COM.AIIERR$RETRY<ONE,ERR.LOC> NE EMPTY THEN
*
SEND.CN.MAX = COM.AIIERR$RETRY<ONE,ERR.LOC>; SEND.RETRY = SEND.CN.MAX
*960612*DGH*IF SEND.CN.MAX LT COM.AIP$RETRY THEN COM.AIP$RETRY = SEND.CN.MAX
**IF SEND.CN.MAX NE COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> THEN COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> = SEND.CN.MAX
IF SEND.CN.MAX NE COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE> THEN
INS SEND.CN.MAX BEFORE COM.AIP$RETRY<ONE,SEND.COMM.CN,ONE>
END
*
END
*
* IF COM.AIIERR$STD.ERR<ONE,ERR.LOC> EQ ERR$OK THEN SEND.RETRY = FALSE; SEND.STATUS = EMPTY
*
IF COM.AIIERR$LOG<ONE,ERR.LOC> EQ "Y" THEN LOG.REQUIRED = 25021
*
*@@@COM.AIP$PAUSE????
IF COM.AIIERR$PAUSE<ONE,ERR.LOC> THEN
SEND.RETRY.PAUSE  = COM.AIIERR$PAUSE<ONE,ERR.LOC>
IF SEND.RETRY.PAUSE GT COM.AIP$MAX.PAUSE THEN COM.AIP$MAX.PAUSE = SEND.RETRY.PAUSE
END
*
END ELSE
INS ERR$NOT.SENT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
SEND.STATUS = EMPTY; SEND.RETRY = FALSE; SEND.CN.MAX = ZERO
END
*
IF COM.AIP$COMM.RSLT<ONE,SEND.COMM.CN> EQ EMPTY THEN
INS ERR$NO.CMD BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
SEND.STATUS = EMPTY; SEND.RETRY = FALSE; SEND.CN.MAX = ZERO
END
*
BEGIN CASE
CASE COM.AI$TEST.MODE; LOG.REQUIRED = 29022
CASE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE EMPTY AND COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE ERR$HANDLER.MSG AND COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE ERR$OK; LOG.REQUIRED = 24023
CASE COM.AI$LOGGING EQ "Y"; LOG.REQUIRED = 25024
CASE TRUE; NULL; * LOG.REQUIRED = 2X025
END CASE
*
!
*
LOCATE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> IN COM.AIIERR$STD<ONE> SETTING ERR.LOC ELSE
LOCATE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE> IN COM.AIIERR$RCVD<ONE> SETTING ERR.LOC ELSE
ERR.LOC = ONE
*SEND.STATUS = ERR$UNKNOWN
END
END; * of LOCATE INTFC.ERR
*
BEGIN CASE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$OK
SEND.STATUS = EMPTY; SEND.RETRY = FALSE
SEND.NO.RSP = ZERO
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$TRANS.NEXT; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$TRANS.NEXT.RECV; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$SYSTEM.BAD
AI.STATUS = ERR$SYSTEM.BAD; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$TABLE.FULL; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$COMMPORT.BAD; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$CMD.FUTR; SEND.RETRY = FALSE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$DVC.MISSING; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$DVC.EXISTS; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$NO.UNIT; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$EVNT.BAD; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$EVNT.EXISTS; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$PPV.DATA.BAD; SEND.RETRY = FALSE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$CMD.BAD; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$PCK.END; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$SEND.LRC; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$SEND.PCK.STX; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$RECV.PCK.STX; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$RECV.LRC; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$BUF.OVFL; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$CMD.LEN; SEND.RETRY = TRUE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$ENBL.BAD; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$COLL; SEND.RETRY = TRUE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$BAD.RSP; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$RSP.LEN; SEND.RETRY = TRUE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$DATA.BAD; SEND.RETRY = TRUE
* CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$UNKNOWN; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$UNKNOWN; SEND.RETRY = TRUE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$HE.BUSY OR COM.AIP$INTFC.ERR<ONE,ONE,ONE> EQ ERR$POC.BUSY
SEND.RETRY = TRUE; SEND.UP.DN = COM.AI$UP.DN.STAT
SEND.WAIT = TIME() + 120
IF SEND.WAIT GT 86400 THEN SEND.WAIT = SEND.WAIT - 86400
COM.AI$UP.DN.STAT = AI.DN
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$CHAN.DN
LOCATE COM.AIP$SVC.CHAN<ONE,ONE> IN STL<STATUS.CHANNEL> BY "AR" SETTING STATUS.LOC THEN
STL<STATUS.CHAN.STAT,STATUS.LOC> = COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
IF COM.AI$CHAN.DN.BRDCST EQ "Y" THEN BROADCAST.REQUIRED = TRUE
END
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$CHAN.UP
LOCATE COM.AIP$SVC.CHAN<ONE,ONE> IN STL<STATUS.CHANNEL> BY "AR" SETTING STATUS.LOC THEN
STL<STATUS.CHAN.STAT,STATUS.LOC> = EMPTY
IF COM.AI$CHAN.DN.BRDCST EQ "Y" THEN BROADCAST.REQUIRED = TRUE
END
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$NOT.SENT; SEND.RETRY = FALSE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$CHECK.TOUT OR COM.AIP$INTFC.ERR<ONE,ONE,ONE> EQ ERR$TOUT
IF COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS" AND SEND.CN LT SEND.CN.MAX THEN
*?????
END
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$RETRY.MAX; SEND.RETRY = FALSE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$NO.RSP
SEND.RETRY = TRUE
SEND.NO.RSP = SEND.NO.RSP + ONE
IF SEND.NO.RSP GT 20 THEN
***?????**** POC HUNG
COM.AI$COMMAND = AI.DN
SEND.RETRY = FALSE
WRITE.REQUIRED = TRUE
END
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$FAILED; SEND.RETRY = FALSE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$OPER.KILL; SEND.RETRY = FALSE
*
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$HANDLER.ERR; SEND.RETRY = FALSE
CASE COM.AIIERR$STD<ONE,ERR.LOC> EQ ERR$HANDLER.MSG; SEND.RETRY = TRUE
*
CASE TRUE
*
END CASE
*
* AI.STATUS = COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
* *
!
*
WHILE (SEND.RETRY AND NOT(SEND.WAIT)) AND SEND.CN LT SEND.CN.MAX DO
**WHILE (SEND.RETRY AND NOT(SEND.WAIT)) AND SEND.CN LT SEND.CN.MAX DO
* LOG.REQUIRED = 2X026
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
REPEAT
*
!
*
IF (SEND.RETRY AND NOT(SEND.WAIT)) AND SEND.CN GE SEND.CN.MAX THEN
****INS ERR$RETRY.MAX BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
****INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
SEND.STATUS = ERR$RETRY.MAX
SEND.RETRY = FALSE
*****END ELSE
****SEND.RETRY = TRUE
END
*
*
*@@*WHILE SEND.RETRY AND LEN(HANDLER.COMMANDS) DO
IF LOG.REQUIRED THEN
GOSUB WRITE.LOG; * : *
END
OPT.COMM.CN = OPT.COMM.CN + ONE
*@@*REPEAT
*
* IF LOG.REQUIRED THEN
* GOSUB WRITE.LOG; * : *
* END
*
SYS.LOCT = "COMM.SEND.END"; IF CNT.TST$LBL THEN PRINT @(50,20):"Send Done" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
RETURN
*
!
*
BROADCAST.DN.BUILD: *
*
SYS.LOCT = "BLD.ACTN"; IF CNT.TST$LBL THEN PRINT @(50,20):"Build Actions" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
LCK.ITM = TRUE; LCK.RELS = TRUE
GOSUB READ.STL
*
ACTIONS = EMPTY; OVC = ZERO; STVC = ONE; * build list of downed Channels...
*
LOOP UNTIL STL<STATUS.CHANNEL,STVC> EQ EMPTY DO
IF STL<STATUS.CHAN.STAT,STVC> NE EMPTY THEN
OVC = OVC + ONE
ACTIONS<ONE,OVC> = STL<STATUS.CHANNEL,STVC>
ACTIONS<TWO,OVC> = STL<STATUS.CHAN.STAT,STVC>
END
STVC = STVC + ONE
REPEAT
RETURN
!
WRITE.LOG: *
*
SYS.LOCT = "WR.LOG"; IF CNT.TST$LBL THEN PRINT @(50,20):"Write Log" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
IF LOG.REQUIRED THEN
$INCLUDE IBP AI.INCL.WRITE.LOG
LOG.REQUIRED = FALSE
END
*
RETURN
!
BROADCAST.DN: *
*
SYS.LOCT = "BRDCST"; IF CNT.TST$LBL THEN PRINT @(50,20):"Broadcast" "L#28":; IF CNT.TST$CR THEN INPUT TMP:
*
IF BROADCAST.REQUIRED THEN
BROADCAST.REQUIRED = FALSE
GOSUB BROADCAST.DN.BUILD; * : *
*
IF ACTIONS<ONE,ONE> NE EMPTY THEN
BVC = ONE
MSG.LINE = EMPTY
*
LOOP UNTIL ACTIONS<ONE,BVC> EQ EMPTY DO
IF MSG.LINE NE EMPTY THEN MSG.LINE = MSG.LINE:","
MSG.LINE = MSG.LINE:ACTIONS<ONE,BVC>
BVC = BVC + ONE
REPEAT
*
IF BVC GT ONE THEN
*
IF STL<STATUS.CHANNEL,BVC> EQ EMPTY THEN
MSG.LINE = "No response from any MLE.  Rectify, then START HANDLER."
*?* OFFED = ONE; * down the handler if no response from any MLE
END ELSE
IF BVC GT TWO THEN MSG.LINE = "The following encoders are down: ":MSG.LINE ELSE
MSG.LINE = "The following encoder is down: ":MSG.LINE
END
END
*
PORT.NUM = PORT.KEY
*; AIL$FLAG = "B"; AIL$TEXT = MSG.LINE; 
***1SEP94*** LOG.REQUIRED = 2X027; GOSUB WRITE.LOG; * : *
PORT.VC = ONE
LOOP
PORT.NUM = PORTS.LIST<ONE,PORT.VC>
UNTIL PORT.NUM EQ EMPTY DO
PORT.NUM = PORT.NUM + ZERO
TMP = "MSG !":PORT.NUM:" ":MSG.LINE
EXECUTE TMP, //OUT. > TMP.OUT
PORT.VC = PORT.VC + ONE
REPEAT
PORT.NUM = PORT.KEY
END; * of BVC GT ONE
*
END; * of ACTIONS ne empty
*
END; * of BROADCAST.REQUIRED
*
RETURN
*
!
*
ERROR: *
*
LAST.ERROR = TEXT
*
RETURN
*
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
*
RETURN
!
END
~AI.INTFC.CHECK.920224~
*CODE.SEGMENT: AI.INTFC.CHECK
*
* DAVID HORSMAN
* FOR AXION COMPUTER SYSTEMS
*
* COM.AI.ERR.DISP
*
* COM.AI.ERR = EMPTY
* * COM.AI.ERR.TEXT<-ONE> = "The AI Handler is ok."
* COM.AI.ERR.TEXT = EMPTY
* COM.AI.ERR.TYPE = EMPTY
* COM.AI.ERR.FUNC = EMPTY
DT = DATE(); TM = TIME()
*
COM.AI.RUN.ELP = ((DT - COM.AI$FUNC.DT) * 86400) + (TM - COM.AI$FUNC.TM)
*   8640 86200     8641 01000  CURR DT/TM
*   8640 86000     8640 86200  FUNC DT/TM
*   ---- -----     ---- -----
*      0   200        1 85200-
*                 86400
*                 85200-
*                  1200
*
*
BEGIN CASE
*
CASE COM.AI$ON.OFF.STAT EQ AI.ON
COM.AI.ON = TRUE
!
*
IF COM.AI$MAX.PAUSE + 4 * COM.AI$STD.PAUSE LE COM.AI.RUN.ELP THEN
COM.AI.ERR<-ONE> = 101
COM.AI.ERR.TEXT<-ONE> = "Failure, AI hung for ":OCONV(COM.AI.RUN.ELP,"MTS"):" hours!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
IF COM.AI$UP.DN.STAT EQ AI.UP THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
*COM.AI.ON = FALSE
END
COM.AI.UP = FALSE
END ELSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.UP = TRUE
COM.AI.ERR<-ONE> = ZERO
COM.AI.ERR.TEXT<-ONE> = "The AI is ON and UP."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.UP = FALSE
COM.AI.ERR<-ONE> = 3
COM.AI.ERR.TEXT<-ONE> = "The AI is ON and DN."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.ERR<-ONE> = 191
COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
COM.AI.ERR.TYPE<-ONE> = "DATA"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
END CASE
*
END
*
!
*
CASE COM.AI$ON.OFF.STAT EQ AI.OFF
COM.AI.ON = FALSE
COM.AI.UP = FALSE
*
BEGIN CASE
CASE COM.AI$UP.DN.STAT  EQ AI.UP
COM.AI.ERR<-ONE> = 102
COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and UP!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
CASE COM.AI$UP.DN.STAT  EQ AI.DN
COM.AI.ERR<-ONE> = TWO
COM.AI.ERR.TEXT<-ONE> = "The AI is OFF and DN."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
*
CASE TRUE
COM.AI.ERR<-ONE> = 192
COM.AI.ERR.TEXT<-ONE> = "The AI is neither UP nor DN!"
COM.AI.ERR.TYPE<-ONE> = "DATA"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
CASE TRUE
COM.AI.ERR<-ONE> = 181
COM.AI.ERR.TEXT<-ONE> = "The AI is neither ON nor OFF!"
COM.AI.ERR.TYPE<-ONE> = "DATA"
IF COM.AI$ON.OFF.STAT NE AI.OFF THEN COM.AI.ERR.FUNC<-ONE> = AI.OFF ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
BEGIN CASE
*
CASE COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE LE COM.AI.RUN.ELP AND COM.AI$ON.OFF.STAT EQ AI.ON AND COM.AI$UP.DN.STAT EQ AI.UP
COM.AI.ERR<-ONE> = 101
COM.AI.ERR.TEXT<-ONE> = "Failure, No (":COM.AI.RUN.ELP:") Acknowledgment!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$ON.OFF.STAT NE COM.AI$ON.OFF
COM.AI.ON.OFF.ELP = ((DT - COM.AI$ON.OFF.DT) * 86400) + (TM - COM.AI$ON.OFF.TM)
IF COM.AI.ON.OFF.ELP GT COM.AI$MAX.PAUSE + 3 * COM.AI$STD.PAUSE THEN
COM.AI.ERR<-ONE> = 111
COM.AI.ERR.TEXT<-ONE> = "Failure logging ":COM.AI$ON.OFF:"! (":COM.AI.ON.OFF.ELP:")"
COM.AI.ERR.TYPE<-ONE> = "TOUT"
COM.AI.ERR.FUNC<-ONE> = COM.AI$ON.OFF
END ELSE
COM.AI.ERR<-ONE> = 11
COM.AI.ERR.TEXT<-ONE> = "The AI is logging ":COM.AI$ON.OFF:"."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
!
*
CASE COM.AI$UP.DN.STAT NE COM.AI$UP.DN
COM.AI.UP.DN.ELP = ((DT - COM.AI$UP.DN.DT) * 86400) + (TM - COM.AI$UP.DN.TM)
IF COM.AI.UP.DN.ELP GT COM.AI$MAX.PAUSE + 2 * COM.AI$STD.PAUSE THEN
COM.AI.ERR<-ONE> = 121
COM.AI.ERR.TEXT<-ONE> = "Failure going ":COM.AI$UP.DN:"! (":COM.AI.UP.DN.ELP:")"
COM.AI.ERR.TYPE<-ONE> = "TOUT"
* COM.AI.ERR.FUNC<-ONE> = COM.AI$UP.DN
IF COM.AI$UP.DN.STAT NE AI.DN THEN COM.AI.ERR.FUNC<-ONE> = AI.DN ELSE
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
END ELSE
COM.AI.ERR<-ONE> = 12
COM.AI.ERR.TEXT<-ONE> = "The AI is going ":COM.AI$UP.DN:"."
COM.AI.ERR.TYPE<-ONE> = "STAT"; COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
END CASE
*
!
*
TMP = "AI.OFF.":PORT.KEY
READV OFF.FLAG FROM CNT.FILE,TMP,ONE ELSE
TMP = "AI.OFF.ALL"
READV OFF.FLAG FROM CNT.FILE,TMP,ONE ELSE OFF.FLAG = FALSE
END
*
IF OFF.FLAG THEN
WRITEV "Done ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS") ON CNT.FILE,TMP,TWO
COM.AI.ERR<-ONE> = 131
COM.AI.ERR.TEXT<-ONE> = "Interface Off Flag is set!"
COM.AI.ERR.TYPE<-ONE> = "PORT"
COM.AI.ERR.FUNC<-ONE> = EMPTY
END
*
*  IF NOT(LEN(COM.AI.ERR)) THEN
*
CHECK.FMT = "L#":CHECK.LEN
*
*
EXEC.IN = EMPTY; EXEC.OUT = EMPTY; EXEC.VERB = EMPTY
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
EXEC.VERB = 'SSELECT CNT EQ "AI*]" BY COMM.DT BY COMM.TM'
*
IF COM.AI.ERR.DISP THEN
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Selecting Active Ports" CHECK.FMT:RVE
END
*
* ULT ONLY
EXECUTE EXEC.VERB, //SELECT. > CNT.ID.LIST, //OUT. > EXEC.OUT
*
* REV ONLY
* PERFORM EXEC.VERB
*
END ELSE
*
CNT.ID.LIST = COM.AI$FUNC.PORT
IF CNT.ID.LIST EQ EMPTY THEN CNT.ID.LIST = PORTS.LIST
*
END; * of fast disp
*
IF COM.AI.ERR.DISP THEN
*
CHECK.LN = CHECK.LN.MIN
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT EXEC.VERB CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF LEN(EXEC.OUT) THEN
LOOP WHILE LEN(EXEC.OUT) DO
PRINT EXEC.OUT<ONE> CHECK.FMT; CHECK.LN = CHECK.LN + ONE
DEL EXEC.OUT<ONE>
REPEAT
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
PRINT " " CHECK.FMT; CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END
END; * of fast disp
*
IF CHECK.LN.HI GT CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT
NEXT TMP
END
*
CHECK.LN.HI = CHECK.LN; CHECK.LN = CHECK.LN.MIN
*
RQM
*
END; * cnt.ai.err.disp
*
*
COM.AI.PORT.REC = EMPTY
COM.AIP.PORT.FIRST = TRUE; PORT.CONT = TRUE
* PORTS.LIST = EMPTY
*
LOOP
*
IF FAST.DISPLAY OR PORTS.LIST.BUILD THEN
*
* ULT ONLY
READNEXT CNT.ID FROM CNT.ID.LIST ELSE CNT.ID = "@@@"
*
* REV ONLY
* READNEXT CNT.ID ELSE CNT.ID = "@@@"
*
COM.AIP.ID = CNT.ID
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
*
*
END ELSE
*
IF CNT.ID.LIST EQ EMPTY THEN CNT.ID = "@@@" ELSE
CNT.ID = "AI*":HEADEND:"*":CNT.ID.LIST<ONE,ONE>
COM.AIP.ID = CNT.ID
COM.AIP.PORT = CNT.ID.LIST<ONE,ONE>
DEL CNT.ID.LIST<ONE,ONE>
LOCATE COM.AIP.PORT IN PORTS.LIST.PREV<ONE> SETTING TMP ELSE
PORTS.LIST.PREV<ONE,-ONE> = COM.AIP.PORT
IF COM.AI.ERR.DISP THEN PRINT BELL:
END
END
*
END; * of fast disp
*
WHILE CNT.ID NE "@@@" DO
*
IF COM.AIP.ID MATCHES '"AI*"2X"*"3N' THEN
*
IF AI.SCAN THEN
LOOP
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(CNT.FILE,"CNT",COM.AIP.ID,LCK.FILE,LCK.STAT)
UNTIL NOT(LCK.STAT) DO REPEAT
END ELSE LCK.STAT = FALSE
*
MATREAD COM.AIP FROM CNT.FILE,COM.AIP.ID THEN
*
COM.AIP.ON.FILE = TRUE
*
IF TF THEN PRINT @(60,20):"Cnt Aip ":COM.AIP.ID "L#18":
*
*@@@ BUILD PORT RECORD
*
TMP = FALSE
IF FAST.DISPLAY OR COM.AIP$COMM.PORT NE EMPTY OR NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN TMP = TRUE
IF ((COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) AND ((((DT - COM.AIP$COMM.C.DT) * 86400) + (TM - COM.AIP$COMM.C.TM)) LT 300)) THEN TMP = TRUE
IF TMP THEN
*
IF PORT.CONT AND COM.AI.ERR.DISP THEN
*
IF PORTS.LIST.BUILD OR COM.AIP.PORT.FIRST OR CHECK.LN GE CHECK.LN.MAX THEN
COM.AIP.PORT.FIRST = FALSE
PRINT @(ZERO,CHECK.LN.MIN - ONE):RVB:"Oper. Po Typ Stat A/I Dvc. Fnc" CHECK.FMT:RVE:
END
*
*
IF CHECK.LN GE CHECK.LN.MAX THEN
CHECK.LN = CHECK.LN.MIN
IF STATUS.CYCLE THEN
RQM; RQM; RQM
END ELSE
LOOP
PRINT @(ZERO,23):CLL:"Display more (Y/<cr>)? ":; INPUT RSP:
IF RSP EQ "KILL" THEN STOP
UNTIL RSP EQ "Y" OR RSP EQ "y" OR RSP EQ EMPTY DO
REPEAT
PRINT @(ZERO,23):" " CHECK.FMT:
IF RSP EQ EMPTY THEN PORT.CONT = FALSE ELSE ALREADY.DISPLAYED = TRUE
END; * OF STATUS CYCLE
END; * OF CHECK.LN GT CHECK.LN.MAX
*
*
IF PORT.CONT THEN
TMP = COM.AIP$OPER "R#5":" ":FIELD(COM.AIP.ID,"*",3) "R#2":" ":COM.AIP$COMM "R#3":" ":COM.AIP$INTFC.STAT<ONE,ONE> "L#4":" ":COM.AIP$INTFC.CODE "L#2":COM.AIP$INTFC.TYPE "L#1":" ":COM.AIP$DVC.TYPE "L#4":" ":COM.AIP$SVC.FUNC "L#3"
PRINT @(ZERO,CHECK.LN):TMP CHECK.FMT:
CHECK.LN = CHECK.LN + ONE
IF CHECK.LN GT CHECK.LN.HI THEN CHECK.LN.HI = CHECK.LN
END; * OF PORT.CONT
*
END; * OF PORT.CONT AND ERR.DISP
*
*
COM.AIP.ELP = ((DT - COM.AIP$COMM.DT) * 86400) + (TM - COM.AIP$COMM.TM)
*
IF NOT(COM.AIP$COMM.C.DT OR COM.AIP$COMM.C.TM) OR NOT(INDEX("*COMP*RVRS*XCEL*","*":COM.AIP$INTFC.STAT<ONE,ONE>:"*",ONE)) THEN
*
IF COM.AIP.ELP GT TWO * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
*
IF AI.SCAN THEN
*
LCK.STAT = LCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE,LCK.STAT)
*
IF NOT(LCK.STAT) THEN
*
COM.AI.ERR<-ONE> = 371
COM.AI.ERR.TYPE<-ONE> = "TOUT"
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "DONE"
COM.AIP$INTFC.STAT = "RVRS":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = COM.AIP.PORT; COM.AIP$COMM.C.DT = EMPTY; COM.AIP$COMM.C.TM = EMPTY
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "WAIT"
COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "RVRS"
COM.AIP$COMM.PORT = COM.AIP.PORT
*
CASE COM.AIP$INTFC.STAT EQ "COMP":VM:COM.AIP$INTFC.STAT
* Should never happen
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "XCEL"
COM.AIP$COMM.PORT = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE TRUE
*
END CASE
*
COM.AI.ERR.TEXT<-ONE> = "Failure at (":COM.AIP.ELP:") Port ":COM.AIP.PORT:" ":COM.AIP$INTFC.STAT<ONE,ONE>:"!"
*
COM.AIP$COMM.DT = DT; COM.AIP$COMM.TM = TM
COM.AIP$ERR = "371":VM:COM.AIP$ERR
CALL AI.WRITE.LOG(CNT.FILE,MAT COM.AIP,HEADEND,AI.SRCE)
MATWRITE COM.AIP ON CNT.FILE,COM.AIP.ID
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",COM.AIP$ACCT.ID,LCK.FILE)
*
END; * OF LCK.STAT
*
END ; * OF AI.SCAN
*
END; * OF ELP
END; * OF NO C.DT OR C.TM
*
*
LOCATE COM.AIP.PORT IN PORTS.LIST<ONE> SETTING TMP ELSE
PORTS.LIST<ONE,-ONE> = COM.AIP.PORT
END
*
END; * OF NO C.DT OR C.TM
*
*
END ELSE
* NOT ON FILE
COM.AIP.ON.FILE = FALSE
MAT COM.AIP = EMPTY
END
*
IF AI.SCAN AND NOT(LCK.STAT) THEN
CALL UNLOCK.ITEM(CNT.FILE,"CNT",COM.AIP.ID,LCK.FILE)
END
*
END; * OF MATCHES AI*XX*999
*
REPEAT
*
IF COM.AI.ERR.DISP THEN
IF CHECK.LN.HI GE CHECK.LN THEN
FOR TMP = CHECK.LN TO CHECK.LN.HI
PRINT @(ZERO,TMP):" " CHECK.FMT:
NEXT TMP
CHECK.LN.HI = CHECK.LN
END
END
*
*  END; * OF NOT(COM.AI.ERR)
*
PORTS.LIST.BUILD = FALSE
*
*
~AI.LOG.PACKET~
*PROGRAM: AI.LOG.PACKET
EQU VS TO "901028 NEW"
*
*              Eagle addressable interface HANDLER.
*
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
$INCLUDE IBP TST.EQUATES
EQU TST$AM TO 12, TST$VM TO 9
VERSION = VS
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
OPEN "AIL" TO AIL.FILE ELSE PRINT "No AIL file!"; STOP
*
PRINT
LOOP
PRINT
PRINT "Enter (L)ist or (I)D's: ":; INPUT REP.TYPE
IF REP.TYPE EQ "KILL" THEN STOP
WHILE REP.TYPE NE "L" AND REP.TYPE NE "I" DO REPEAT
*
PRINT
LOOP
PRINT
PRINT "Output to (P)rinter of (S)creen/<CR>: ":; INPUT REP.LPTR
IF REP.LPTR EQ "KILL" THEN STOP
IF REP.LPTR EQ "" THEN REP.LPTR = "S"
WHILE REP.LPTR NE "P" AND REP.LPTR NE "S" DO REPEAT
*
IF REP.LPTR EQ "P" THEN PRINTER ON
*
*
IF REP.TYPE EQ "L" THEN
EXECUTE "GET-LIST AIL", //SELECT. > AIL.ID.LIST
END
*
10 * MAIN LOOP
*
IF REP.TYPE EQ "L" THEN
READNEXT AIL.ID FROM AIL.ID.LIST ELSE STOP
END ELSE
IF REP.LPTR EQ "P" THEN PRINTER OFF
PRINT
PRINT "Enter log ID: ":; INPUT AIL.ID
IF AIL.ID EQ "KILL" THEN STOP
IF AIL.ID EQ "" THEN STOP
IF REP.LPTR EQ "P" THEN PRINTER ON
END
*
MATREAD COM.AIP FROM AIL.FILE,AIL.ID ELSE GOTO 10
*
PRINT AIL.ID
PRINT ICONV(COM.AIP$HEX.COMM,"MX")
PRINT; PRINT
*
GOTO 10
*
END
~AI.PARSE.INPUT.EA~
SUBROUTINE AI.PARSE.INPUT.EA(MAT COM.AIP,INPUT.PACKET,ORIG.PACKET,CNT.TST$LBL,COM.FILE,LCK.FILE,LCK.TYPE,SEND.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE,OPER,EXP.TM,SYS.PRNT,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.PARSE.INPUT.EA"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
PROMPT CHAR(13)
STXC = CHAR(02)
IF CNT.TST$LBL THEN
COM.AIP.TEST = "00":AM:"03":AM:"05":AM:"11":AM:"19":AM:"22":AM:"31":AM:"33":AM:"32":AM:"60":AM:"71":AM:"78":AM:"79":AM:"85":AM:"100":AM:"200":AM:"371"
*
*SEND.STATUS = 14
*SEND.STATUS = RND(30) + ONE
SEND.STATUS = RND(17)
IF SEND.STATUS GT 17 THEN SEND.STATUS = ONE ELSE
PRINT
PRINT "**** ":SEND.STATUS:" ****"
PRINT
END
SEND.STATUS = COM.AIP.TEST<SEND.STATUS>
RETURN
END
*
* TC.MAX = SYSTEM(11)
* *
* IF TC.MAX THEN
* INPUT INPUT.PACKET,TC.MAX:
* END ELSE
* INPUT.PACKET = EMPTY
* END
*
*21AUG94* ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY; TC.CHAR = EMPTY
*21AUG94* LOOP UNTIL NOT(SYSTEM(11)) OR TC.CHAR EQ CR DO
*21AUG94* TC.CHAR = EMPTY
*21AUG94* TC.CHAR = OCONV(TC.CHAR,"U51EA")
*21AUG94* INPUT.PACKET = INPUT.PACKET:TC.CHAR
*21AUG94* REPEAT
*
ORIG.PACKET = INPUT.PACKET
*
IF LEN(INPUT.PACKET) THEN
*
LOOP TC = INPUT.PACKET[ONE,ONE]; TC.SEQ = SEQ(TC) UNTIL NOT(LEN(INPUT.PACKET)) OR TC.SEQ EQ TWO DO INPUT.PACKET = INPUT.PACKET[TWO,9999] REPEAT
*
IF NOT(LEN(INPUT.PACKET)) THEN
* no stx in packet
*
SEND.STATUS = ERR$RECV.PCK.STX
*
END ELSE
* stx found
*
TC.PACKET = INPUT.PACKET[TWO,4]
*
$INCLUDE IBP SYS.INCL.CALC.LRC
*
INPUT.LRC = INPUT.PACKET[6,TWO]
*
IF INPUT.LRC NE TC.HEX THEN
* lrc error
*
SEND.STATUS = ERR$RECV.LRC
*
END ELSE
*
SEND.STATUS = ("00":INPUT.PACKET[TWO,TWO]) "R#2"
*
END; * of pkt ok
*
END; * of stx found
*
END ELSE
*
SEND.STATUS = ERR$NO.RSP
*
END; * of pck/no pck
*
INS SEND.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
IF SEND.STATUS THEN
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS "801" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
*
RETURN
*
END
~AI.PARSE.INPUT.PA~
SUBROUTINE AI.PARSE.INPUT.PA(MAT COM.AIP,INPUT.PACKET,ORIG.PACKET,MAT CNT.TST,COM.FILE,LCK.FILE,LCK.TYPE,RECV.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE,OPER,EXP.TM,SYS.PRNT,STAT)
* VERSION: 940221 1.1  ADDED MAT CNT.TST/MAT COM.AIIERR/COM.AIICMD.
* CALLED BY AI.COMMAND.SENDER
*
* COPYRIGHT    AXION COMPUTER SYSTEMS LTD.
*    1990          ALL RIGHTS RESERVED
*
* TEST MODE:  $LBL AND NOT $ID* - GENERATES A RANDOM FATAL ERROR AND RETURNS
*             $ID* - DISPLAYS INPUT PACKET
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.PARSE.INPUT.PA"; SYS.LOCT = EMPTY
*
!
*
* DESCRIPTION: PROCESSES RESPONSES TO THE FOLLOWING M5000 TRANSACTIONS:
*
* P   = program to load COM.AIP is completed.
*  O  = Code for the PARSE.OUTPUT transaction is completed
*   I = Code for PARSE.INPUT for transaction is completed.
*
* POI 12 - Resequence
*  OI 2A - Global Force Tune
*  O  2B - Set Date/Time/Day of Week
*   I 2E - DLL Extended Tiers
*     30 - Inq On EBA Parameters
*     36 - Inq Extended Tiers
*     44 - Inq on PPV Event
* POI 45 - Define PPV Master Record by DOWNLOAD.PPV.EVENTS.PA
*   I 46 - Delete  "    "      "
*   I 47 - Order  PPV Event
*   I 48 - Cancel PPV Event
*   I 49 - DLL    PPV Master Records 
*   I 4E - Set Encoder Parameters
*     4F - Inq   ""        ""
*     4M - Multiple Order PPV Event
*     57 - Resend upload
*  O  59 - Clear Collections
* POI 5B - IPPV Installation by AI.UPD.AIX.PA
*   I 5C - One Shot Collection
* POI 5D - IPPV downgrade by AI.UPD.AIX.PA
*   I 5R - Calibrate Pulse Response
* POI 5U - Upload Collections by UPLOAD.PPV.BUYS.PA
*   I 64 - Start Group Collections
*   I 65 - Stop Collections
*   I 6A - Clear Upload Group Collections
*     73 - Inquire BA-6000 Normal/Quick Poll Record
* POI 7B - Define      "      "     "    "      "   by AI.TALKER
*   I 7C - DLL        "      "      "    "      "  s
*     7U - Upload     "      "      "    "      "  s
*    
*    
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
*
$INCLUDE IBP XPV.DIM
$INCLUDE IBP XPV.EQUATES
*
* FILE EQUATES FOR MNFG TO STD ERROR CONVERSION
*     $INCLUDE IBP AI.CERR.EQUATES
*
PROMPT CHAR(0)
STXC = CHAR(02)
FATAL.ERROR = 1; * IF FATAL.ERROR TRANS.NUM IS NOT INCREMENTED (POC RULE).
RESPONSE.STATUS = EMPTY; COLL.STATUS = EMPTY; RECV.STATUS = EMPTY
*
* COM.AIP.FAIL = "00":AM:"01":AM:"02":AM:"03":AM:"04":AM:"05":AM:"07":AM:"08":AM:"09":AM:"0A":AM:"0B":AM:"0C":AM:"0D":AM:"0E"
* COM.AIP.WARN = "81":AM:"82":AM:"83":AM:"84":AM:"85":AM:"86":AM:"87":AM:"88":AM:"89":AM:"8A":AM:"8B":AM:"8C":AM:"8E":AM:"8F":AM:"8G":AM:"8H":AM:"B1"
COLL.STATUSES =  "00":VM:"03":VM:"0D":VM:"0E":VM:"0F":VM:"11":VM:"13":VM:"14":VM:"16":VM:"17":VM:"20"
*
*29MAR94*IF CNT.TST$LBL AND NOT(CNT.TST$ID) THEN
IF CNT.TST$LBL EQ 2 THEN
READ RSP.STACK FROM COM.FILE,"AI.RSP.STACK" ELSE RSP.STACK = EMPTY
IF RSP.STACK EQ EMPTY THEN
RECV.LOC.MAX = DCOUNT(COM.AIIERR$STD,VM)
TMP = 4 * RECV.LOC.MAX
RECV.LOC = RND(TMP)
PRINT "**** No.: ":RECV.LOC "L#5":" ****"
PRINT
IF RECV.LOC GT RECV.LOC.MAX THEN
* RECV.LOC = ONE
RESPONSE.CODE = "00"
LOCATE RESPONSE.CODE IN COM.AIIERR$RCVD<ONE> SETTING RECV.LOC ELSE RECV.LOC = ONE
PRINT "** OK **"
END
PRINT
PRINT "**** No.: ":RECV.LOC "L#5":" ****"
PRINT "**** PAI: ":COM.AIIERR$RCVD<ONE,RECV.LOC> "L#5":" ****"
PRINT "**** STD: ":COM.AIIERR$STD<ONE,RECV.LOC> "L#5":" ****"
PRINT
* RECV.STATUS = COM.AIP.FAIL<RECV.LOC>
RECV.STATUS = COM.AIIERR$STD<ONE,RECV.LOC>
PKT.STATUS = COM.AIIERR$RCVD<ONE,RECV.LOC>
INS RECV.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
IF RECV.STATUS THEN
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS "801" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
INS PKT.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
IF PKT.STATUS THEN
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS "801" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
RETURN
END ELSE
INPUT.PACKET = RSP.STACK<ONE,ONE,ONE>
PRINT "**** RESPONSE STACK ****"
PRINT INPUT.PACKET
INPUT.PACKET = ICONV(INPUT.PACKET,"HEX")
TMP = LEN(INPUT.PACKET)
IF INPUT.PACKET[TMP,ONE] EQ CR THEN
INPUT.PACKET = INPUT.PACKET[ONE,TMP - ONE]
END
DEL RSP.STACK<ONE>
WRITE RSP.STACK ON COM.FILE,"AI.RSP.STACK"
END
END
*
*
*21AUG94* ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY; TC.CHAR = EMPTY
*21AUG94* * ULT ONLY
*21AUG94* LOOP
*21AUG94* IF TC.CHAR NE CR THEN
*21AUG94* IF NOT(SYSTEM(11)) THEN
*21AUG94* B = ZERO
*21AUG94* FOR A = ONE TO 1000
*21AUG94* B = B + ONE
*21AUG94* NEXT A
*21AUG94* END
*21AUG94* END
*21AUG94* * ULT ONLY
*21AUG94* UNTIL NOT(SYSTEM(11)) OR TC.CHAR EQ CR DO
*21AUG94* * REV ONLY
*21AUG94* * LOOP UNTIL TC.CHAR EQ EMPTY OR TC.CHAR EQ CR DO
*21AUG94* TC.CHAR = EMPTY
*21AUG94* * ULT ONLY
*21AUG94* TC.CHAR = OCONV(TC.CHAR,"U51EA")
*21AUG94* * REV ONLY
*21AUG94* * INPUT TC,ONE:
*21AUG94* * INPUT TC,ONE:-
*21AUG94* IF TC.CHAR NE CR THEN
*21AUG94* INPUT.PACKET = INPUT.PACKET:TC.CHAR
*21AUG94* END
*21AUG94* REPEAT
*
ORIG.PACKET = INPUT.PACKET
RESPONSE.CODE = EMPTY
*
*29MAR94*IF CNT.TST$ID OR CNT.TST$LBL THEN
*29MAR94*PRINT @(0,18):INPUT.PACKET[1,50]:
*29MAR94*PRINT @(0,19):INPUT.PACKET[51,50]:
*29MAR94*PRINT @(0,20):INPUT.PACKET[101,50]:
*29MAR94*PRINT @(0,21):INPUT.PACKET[151,50]:
*29MAR94*IF CNT.TST$CR THEN PRINT CLB:"Enter <cr>: ":; INPUT TMP:
*29MAR94*END
*
!
*
TC.LEN = LEN(INPUT.PACKET)
IF TC.LEN THEN
*
TC.CN = ZERO
LOOP
TC = INPUT.PACKET[ONE,ONE]
TC.SEQ = SEQ(TC)
* 22 IS SYN CHARACTER
UNTIL TC.CN GE TC.LEN OR TC EQ STXC DO
INPUT.PACKET = INPUT.PACKET[TWO,9999]
TC.CN = TC.CN + ONE
REPEAT
*
IF TC.CN THEN
INS ERR$BAD.RSP BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
*
TC.LEN = LEN(INPUT.PACKET)
IF NOT(TC.LEN) AND LEN(ORIG.PACKET) THEN
* no SYN in packet
*
RECV.STATUS = ERR$RECV.PCK.STX
*
END ELSE
* SYN found
*
PKT.TYPE = COM.AIP$COMM.RSLT<ONE,SEND.COMM.CN,ONE>
* IF (TC.LEN NE 10 AND (PKT.TYPE NE "5B" AND PKT.TYPE NE "5U" AND PKT.TYPE NE "57")) OR (TC.LEN NE 166 AND (PKT.TYPE EQ "5B" OR PKT.TYPE EQ "5U" OR PKT.TYPE EQ "57")) THEN
**IF NOT(TC.LEN EQ 10 OR TC.LEN EQ 14 OR ((TC.LEN EQ 28 OR TC.LEN EQ 166) AND (PKT.TYPE EQ "5B" OR PKT.TYPE EQ "5U" OR PKT.TYPE EQ "57" OR PKT.TYPE EQ "5C"))) THEN
*9606*DGH*IF NOT(TC.LEN EQ 10 OR TC.LEN EQ 14 OR (TC.LEN EQ 166 AND (PKT.TYPE EQ "5B" OR PKT.TYPE EQ "5U" OR PKT.TYPE EQ "57" OR PKT.TYPE EQ "5C"))) THEN
IF NOT(TC.LEN EQ 10 OR TC.LEN EQ 14 OR (TC.LEN EQ 166 AND INDEX("*57*5B*5C*5D*5U*","*":PKT.TYPE:"*",ONE))) THEN
*
RECV.STATUS = ERR$RSP.LEN
*
END ELSE
*
* len is OK
*
TRAN.POC = INPUT.PACKET[TWO,ONE]
* INPUT.PACKET = INPUT.PACKET[3,9999]
* TC.LEN = TC.LEN - TWO
* INPUT.BCC = INPUT.PACKET[TC.LEN - ONE,TWO]
* INPUT.PACKET = INPUT.PACKET[ONE,TC.LEN - TWO]
* TC.LEN = TC.LEN - TWO
* TC.PACKET = INPUT.PACKET[3,TC.LEN-2]
*
* $INCLUDE IBP SYS.INCL.CALC.XOR.COMPL
*
GOSUB VALIDATE.PACKET
*
*
* IF INPUT.BCC NE TC.HEX THEN
* lrc error
*
* RECV.STATUS = ERR$RECV.LRC
IF LRC.INVALID OR BCC.INVALID THEN
TRAN.POC = EMPTY
*
END ELSE
*
*
READ AI.NEXT.TRANS FROM COM.FILE,"AI.NEXT.TRANS.":AI.CODE ELSE AI.NEXT.TRANS = -ONE
PKT.TYPE = COM.AIP$COMM.RSLT<ONE,SEND.COMM.CN,ONE>
OUT.TRANS.NEXT.SEQ = COM.AIP$HEX.COMM<ONE,SEND.COMM.CN,ONE>[5,8]
OUT.TRANS.NEXT.SEQ = ICONV(OUT.TRANS.NEXT.SEQ,"HEX")
IN.TRANS.NEXT.HEX = INPUT.PACKET[3,4]
TMP = IN.TRANS.NEXT.HEX; GOSUB CONV.FR.HEX; IN.TRANS.NEXT.SEQ = TMP1
*
* IF TRANS.NEXT.SEQ NE COM.AIP$TRANS.NEXT THEN
* IF OUT.TRANS.NEXT.SEQ NE IN.TRANS.NEXT.HEX THEN
IF AI.NEXT.TRANS NE IN.TRANS.NEXT.SEQ AND PKT.TYPE NE "12" AND NOT(CNT.TST$LBL) THEN
* PRINT CLB:AI.NEXT.TRANS:" # ":IN.TRANS.NEXT.SEQ:; INPUT TMP:
* transaction sequence error
*
RECV.STATUS = ERR$TRANS.NEXT.RECV
*
END ELSE
*
RESPONSE.CODE = ("00":INPUT.PACKET[7,TWO]) "R#2"
*
*
LOCATE RESPONSE.CODE IN COM.AIIERR$RCVD<ONE> SETTING RECV.LOC ELSE 
LOCATE ERR$BAD.RSP IN COM.AIIERR$STD<ONE> SETTING RECV.LOC ELSE RECV.LOC = 3
END
RECV.STATUS = COM.AIIERR$STD<ONE,RECV.LOC>
RECV.STATUS.TYPE = COM.AIIERR$TYPE<ONE,RECV.LOC>
* IF RECV.STATUS = "" THEN RECV.STATUS = RESPONSE.CODE
*
*
**** IF RECV.LOC GT ONE THEN
*
IF RECV.STATUS.TYPE NE "OK" AND RECV.STATUS.TYPE NE "WARN" THEN
* Fatal Error from POC
RECV.STATUS = COM.AIIERR$STD<ONE,RECV.LOC>
FATAL.ERROR = 1
END ELSE
*
*
FATAL.ERROR = 0
PKT.TYPE = COM.AIP$COMM.RSLT<ONE,SEND.COMM.CN,ONE>
*
BEGIN CASE
*
CASE PKT.TYPE = "12"
! Resequence
* Echo back of trans seq num.
* Load it in COM.AIP for comparison by originating program.
ECHO.TRANS.NEXT.HEX = INPUT.PACKET[3,4]
TMP = ECHO.TRANS.NEXT.HEX; GOSUB CONV.FR.HEX; ECHO.TRANS.NEXT.SEQ = TMP1
COM.AIP$TRANS.NEXT = ECHO.TRANS.NEXT.SEQ
* 05
*
CASE PKT.TYPE = "2A"
! Global Force Tune
* Response Code only
* 05
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "2B"
! Set Date/Time/Day of Week
* Response Code only
* 05
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "2E"
! DLL Extended Tiers
* Response Code only
* 05
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "45"
! Define PPV Event Master Record
* Response Code only
* 05 0D 86
*
CASE PKT.TYPE = "46"
! Delete PPV Master Record
* Response Code only
* 05 0E 87 89
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "47"
! Order PPV Event
* Response Code only
* 05 0B 0D 87 89 8E
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "48"
! Cancel PPV Event
* Response Code only
* 05 0B 0D 87 88 89 8E
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "49"
! DLL    PPV Master Records
* Response Code only
* 05 0D
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "4E"
! Set Encode Parameters
* Response Code only
* 05 40 41 42 43
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "4F"
! Enquire Encoder Parameters
* Extended Response
* 05 40 41 42 43
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "4M"
! Multiple Order PPV Event
* Extended Response
* 05 0B 87 89 8E
RECV.STATUS = ERR$CMD.BAD
*
*** CASE PKT.TYPE = "57"
*** ! Resend Upload
*** * Response Code only
*** * 05 0D
*** RECV.STATUS = ERR$CMD.BAD
*** *
CASE PKT.TYPE = "59"
! Clear Collections
* Response Code only
* 05 0D 82
RECV.STATUS = ERR$CMD.BAD
*
*@@@   CASE PKT.TYPE = "5B"
! IPPV Installation
* Selectable Response
* Collection Mode 0 - (USED) Response Code only
*     "       "   1 - do test collection do not clear terminal
*     "       "   2 - "   "       "      clear terminal
* 05 07
*
*@@@   CASE PKT.TYPE = "5C"
! One Shot Collection
* Extended Response
* 05 07
*@@@   RECV.STATUS = ERR$CMD.BAD
*
*@@@  CASE PKT.TYPE = "5D"
! IPPV downgrade
* See 5C - Extended Response not used
* 05 07 82
*
CASE PKT.TYPE = "5R"
! Calibrate Pulse Response
* Response Code only
* 05
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "5U" OR PKT.TYPE = "57" OR (PKT.TYPE EQ "5B" OR PKT.TYPE EQ "5D" OR PKT.TYPE EQ "5C")
! Upload PPV Collections
* Extended Response
* 05 07
*
COLL.STATUS = INPUT.PACKET[9,TWO]; DVC.ID = INPUT.PACKET[11,6]
IF COLL.STATUS EQ "z0" THEN
* end of upload.
COM.AIP$END.UPL = "z"
END ELSE
*
LOCATE COLL.STATUS IN COLL.STATUSES<ONE> SETTING CS.LOC THEN
*
IF CS.LOC NE ONE THEN
COM.AIP$GROUP.RSLT = COLL.STATUS
* * RECV.STATUS = ERR$COLL
END; * of collection status ne 1 (error)
*
END ELSE
* invalid collections status
CS.LOC = 99
COLL.STATUS = "99"; * Unkown
COM.AIP$GROUP.RSLT = COLL.STATUS
END; * of invalid collection status
*
*
*950324*DGH*IF CS.LOC EQ ONE THEN
*950324*DGHv
IF CS.LOC NE ONE THEN
COM.AIP$GROUP.RSLT = COLL.STATUS
* * RECV.STATUS = ERR$COLL
END; * of collection status ne 1 (error)
*950324*DGH^
*
* PROCESS PPV BUYS
*
DVC.ID = INPUT.PACKET[11,6]; * COM.AIP$DVC.ID
VIEW.TIMES = ""; PPV.BUYS = ""; TMP.EVENTS = INPUT.PACKET[41,120]; * VIEW.TIME:EVENT.NUM X 20
EV.CTR = 1; BUY.VC = 1; EV.LOC = 1
LOOP UNTIL EV.CTR = 21 DO
VIEW.TIME = TMP.EVENTS[EV.LOC,1]
TMP = VIEW.TIME; GOSUB CONV.FR.HEX; VIEW.TIME = TMP1
PPV.BUY = TMP.EVENTS[EV.LOC+1,5]
TMP = PPV.BUY; GOSUB CONV.FR.HEX; PPV.BUY = TMP1
IF PPV.BUY NE "00000" THEN 
PPV.BUYS<1,BUY.VC> = PPV.BUY "R#4"; * COM.AIP$EVENT
VIEW.TIMES<1,BUY.VC> = VIEW.TIME; * COM.AIP$EVENT.DUR
BUY.VC = BUY.VC +1
END
EV.CTR = EV.CTR+1; EV.LOC = EV.LOC+6
REPEAT
*
COM.AIP$DVC.ID =        DVC.ID
COM.AIP$EVENT  =    PPV.BUYS
COM.AIP$EVENT.DUR = VIEW.TIMES
*
IF COM.AIP$COMM.SRCE NE "U" THEN
OPEN "AIL" TO AIL.FILE THEN
MATWRITE COM.AIP ON AIL.FILE,"GENIE*":DATE():"*":TIME():"*":PORT
END ELSE NULL
END
*
* of not coll.status.loc = 1 (no error)
*950324*DGH*END ELSE
*950324*DGH*COM.AIP$GROUP.RSLT = COLL.STATUS
*950324*DGH** * RECV.STATUS = ERR$COLL
*950324*DGH**
*950324*DGH*END; * of collection status ne 1 (error)
** *
** END ELSE
** * invalid collections status
** COLL.STATUS = "99"; * Unkown
** END; * of invalid collection status
** *
COM.AIP$GROUP.RSLT = COLL.STATUS
*
END; * of not z0 end of file
*
CASE PKT.TYPE = "64"
! Start Group Collections
* Response Code only
* 05 8D
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "65"
! Stop Collections
* Response Code only
* 05
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "6A"
! Clear Upload Group Collections
* Response Code only
* 05 8D
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "73"
! Inquire BA-6000 Normal/Quick Poll Record
* Extended Response
*
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "7B"
! Define BA-6000 Normal/Quick Poll Record
* Extended Response
* 05 0D 81 82 83 84
*
CASE PKT.TYPE = "7C"
! DLL BA-6000 Normal/Quick Poll Records
* Extended Response
*
RECV.STATUS = ERR$CMD.BAD
*
CASE PKT.TYPE = "7U"
! Upload BA-6000 Normal/Quick Poll Records
* Extended Response
*
RECV.STATUS = ERR$CMD.BAD
*
END CASE
*
END; * of not fatal error
*
****END; * of locate response.code
*
END; * of Trans Seq OK
*
END; * of BCC OK
*
END; * of LEN OK
*
END; * of SYN OK
*
IF NOT(FATAL.ERROR) THEN
LOOP
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
READ AI.NEXT.TRANS FROM COM.FILE,"AI.NEXT.TRANS.":AI.CODE ELSE AI.NEXT.TRANS = -ONE
*
AI.NEXT.TRANS = AI.NEXT.TRANS + ONE
IF AI.NEXT.TRANS GT 65535 THEN AI.NEXT.TRANS = ZERO
AI.NEXT.TRANS = ("0000":AI.NEXT.TRANS) "R#4"
WRITE AI.NEXT.TRANS ON COM.FILE,"AI.NEXT.TRANS.":AI.CODE
CALL SYS.ITM.RLS("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
END
*
*
END ELSE
*
IF NOT(RECV.STATUS) THEN RECV.STATUS = ERR$NO.RSP
*
END; * of pck/no pck
*
INS RECV.STATUS BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
IF RECV.STATUS THEN
INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS "801" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
* INS RESPONSE.CODE BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
* IF RESPONSE.CODE THEN
* INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
* END ELSE
* INS "801" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
* END
*
RETURN
*
!
VALIDATE.PACKET: *
*
BCC.INVALID = 0; LRC.INVALID = 0
TMP = LEN(INPUT.PACKET)
*
* IF INPUT.PACKET[TMP,ONE] EQ CR THEN
BCC = INPUT.PACKET[TMP - ONE,TWO]
*
TC.PACKET = INPUT.PACKET[3,TMP - TWO - TWO]
$INCLUDE IBP SYS.INCL.CALC.XOR.COMPL
*
IF TC.HEX NE BCC THEN
* INS ERR$RECV.LRC BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
* INS "800" BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
RECV.STATUS = ERR$RECV.LRC
BCC.INVALID = ONE
END
*
* END ELSE COM.AIP$ERR<ONE,ONE,-ONE> = ERR$PCK.END; LRC.INVALID = 1
*
RETURN
*
!
*
CONV.FR.HEX: *
*
TMP1 = EMPTY; TMP2 = 16
*
$INCLUDE IBP SYS.INCL.CONV.NUM.FROM.HEX
*
RETURN
*
!
*
HX.CONV: *
*
*
TMP1 = EMPTY; TMP2 = 16
*
$INCLUDE IBP SYS.INCL.CONV.NUM.TO.HEX
*
RETURN
*
!
*
WRITE.XPV: *
*
READ AI.COS FROM COM.FILE,"AI.COS" ELSE AI.COS = ""
*
NODATA.CTR = ZERO; NOCALL.CTR = ZERO; OTHER.CTR = ZERO; OKCOLL.CTR = ZERO; UPLOADED.CTR = ZERO
EMPEV.CTR = ZERO; DUPE.CTR = ZERO; PREV.DVC.ID = EMPTY; TMP.ID = EMPTY
* AI.STATUS = EMPTY; SEND.STATUS = EMPTY; COLL.STATUS = EMPTY
VALID.CTR = ZERO; EVENT.CTR = ZERO
ERROR.CTR = ZERO; ERROR.EVENT.CTR = ZERO
COMM.CTR = ZERO
OVER = FALSE; OVER.SKIP = ZERO
* AI.COS
*
$INCLUDE IBP AI.INCL.WRITE.XPV
*
RETURN
*
!
*
END
~AI.PARSE.OUTPUT.EA~
SUBROUTINE AI.PARSE.OUTPUT.EA(MAT COM.AIP,OUTPUT.PACKET,CNT.TST$LBL,COM.FILE,LCK.FILE,LCK.TYPE,SEND.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE,OPER,EXP.TM,SYS.PRNT,STAT)
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(3.0)"
VS = "(3.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.PARSE.OUTPUT.EA"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
* FORMAT DEVICE ID WITH
*  AIX DEVICE NUMBER
*  AND DEVICE LETTER FOR MULTI ADDR DEVICES (EAI8 & EAI4)
*
* HANDLE BASIC HERE
* LOOP THROUGH SERVICES
*     CHECKING TIER STATUS
*     AND IF TIER THEN FORMAT "00":TIER "R#2"
*     IF NO TIER AND BASIC THEN "14"
*
*
*
STXC = CHAR(02)
OUTPUT.PACKET = EMPTY
*
IF CNT.TST$LBL THEN
* AM.CN = 1
* AM.CN.MAX = 40
PRINT OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
PRINT COM.AIP$COMM.PORT
* LOOP UNTIL AM.CN GT AM.CN.MAX DO
* IF COM.AIP(AM.CN) NE EMPTY THEN
* OUTPUT.PACKET = OUTPUT.PACKET:"(":AM.CN:") ":COM.AIP(AM.CN):CR:LF
* END
* AM.CN = AM.CN + ONE
* REPEAT
END
*
* OUTPUT.PACKET = OUTPUT.PACKET:STXC:"01"
OUTPUT.PACKET = OUTPUT.PACKET:"01"
*
DVC.TYPE = COM.AIP$DVC.TYPE[ONE,3]
DVC.SUB.TYPE = COM.AIP$DVC.TYPE[4,ONE]
IF DVC.SUB.TYPE EQ EMPTY THEN DVC.SUB.TYPE = ONE
*
* COM.AIP.SVC.FUNC = COM.AIP$SVC.FUNC
*
IF COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> NE "RVRS" THEN
COM.AIP.SVCS = COM.AIP$SVC.ID
COM.AIP.TIERS = COM.AIP$TIERS.FUTR
COM.AIP.TSTAT = COM.AIP$TSTAT.FUTR
END ELSE
COM.AIP.SVCS  = COM.AIP$SVC.ID.FUTR
COM.AIP.TIERS = COM.AIP$TIERS
COM.AIP.TSTAT = COM.AIP$TSTAT
END
*
IF DVC.TYPE EQ "EAI" OR (DVC.TYPE EQ "ATS" AND DVC.SUB.TYPE EQ ONE) THEN
TMP.ID = (STR("0",9):FIELD(COM.AIP$AIX.ID,"*",TWO)) "R#9"
END ELSE IF DVC.TYPE EQ "ATS" THEN
TMP.LOCATION = "ABCDEFGH"[COM.AIP$AIX.LOCATION,ONE]
TMP.ID = (STR("0",9):FIELD(COM.AIP$AIX.ID,"*",TWO):TMP.LOCATION) "R#9"
END ELSE
TMP.ID = STR("0",9)
SEND.STATUS = 301
END
*
OUTPUT.PACKET = OUTPUT.PACKET:TMP.ID:"SD":"0000000":"00":"00000"
*
TMP.ENABLE = EMPTY; TMP.AUTHOS = EMPTY
*
IF DVC.TYPE EQ "EAI" OR DVC.TYPE EQ "ATS" THEN
*
BASIC.FLAG = FALSE
CN.MAX = DCOUNT(COM.AIP.TIERS,SVM)
FOR CN = ONE TO CN.MAX
IF COM.AIP.TSTAT<ONE,ONE,CN> THEN
BASIC.FLAG = TRUE
IF COM.AIP.TIERS<ONE,ONE,CN> AND COM.AIP.SVCS<ONE,ONE,CN> NE "(BASIC)" THEN
IF DVC.TYPE NE "ATS" OR DVC.SUB.TYPE NE "8" THEN TMP.AUTHOS = TMP.AUTHOS:("00":COM.AIP.TIERS<ONE,ONE,CN>) "R#2"
END
END
NEXT CN
*
IF NOT(BASIC.FLAG) THEN
TMP.ENABLE = "01"
* TMP.AUTHOS = EMPTY:TMP.AUTHOS
END ELSE
TMP.ENABLE = "01"
TMP.AUTHOS = "14":TMP.AUTHOS
END
*
END ELSE IF DVC.TYPE EQ "ATS" THEN
*
TMP.ENABLE = "99"
TMP.AUTHOS = "99":TMP.AUTHOS
SEND.STATUS = 301
*
END
*
OUTPUT.PACKET = OUTPUT.PACKET:TMP.ENABLE:TMP.AUTHOS:"  "
*
TC.PACKET = OUTPUT.PACKET
*
$INCLUDE IBP SYS.INCL.CALC.LRC
*
OUTPUT.PACKET = STXC:OUTPUT.PACKET:TC.HEX:CR
*
RETURN
END
~AI.PARSE.OUTPUT.PA~
SUBROUTINE AI.PARSE.OUTPUT.PA(MAT COM.AIP,OUTPUT.PACKET,MAT CNT.TST,COM.FILE,LCK.FILE,LCK.TYPE,SEND.STATUS,SEND.COMM.CN,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE,OPER,EXP.TM,SYS.PRNT,STAT)
* VERSION: 940221 1.1  UPDATE OF AI.NEXT.TRANS MOVED TO PARSE.INPUT.
* PRIOR: 940220 1.1  ADDED MAT CNT.TST, MAT COM.AIIERR, COM.AIICMD.
*
* CALLED BY AI.COMMAND.SENDER
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.PARSE.OUTPUT.PA"; SYS.LOCT = EMPTY
* DESCRIPTION: TO SUPPORT THE FOLLOWING RECOMMENDED M5000 TRANSACTIONS:
*
* P   = program to load COM.AIP is completed.
*  C  = Code for the transaction is present
*   I = PARSE.INPUT for transaction is completed.
* PCI 12 - Resequence
*  C  2A - Global Force Tune
*  C  2B - Set Date/Time/Day of Week
*     2E - DLL Extended Tiers
*     30 - Inq On EBA Parameters
*     36 - Inq Extended Tiers
*     44 - Inq on PPV Event
* PCI 45 - Define PPV Master Record by DOWNLOAD.PPV.EVENTS.PA
*     46 - Delete  "    "      "
*     47 - Order  PPV Event
*     48 - Cancel PPV Event
*     49 - DLL    PPV Master Records 
*     4E - Set Encoder Parameters
*     4F - Inq   ""        ""
*     4M - Multiple Order PPV Event
*     57 - Resend upload
*  C  59 - Clear Collections
* PCI 5B - IPPV Installation by AI.TALKER
*  C  5C - One Shot Collection
* PCI 5D - IPPV downgrade by AI.TALKER
*     5R - Calibrate Pulse Response
* PCI 5U - Upload Collections by UPLOAD.PPV.BUYS.PA
*     64 - Start Group Collections
*     65 - Stop Collections
*     6A - Clear Upload Group Collections
*     73 - Inquire BA-6000 Normal/Quick Poll Record
* PCI 7B - Define      "      "     "    "      "   by AI.TALKER
*     7C - DLL        "      "      "    "      "  s
*     7U - Upload     "      "      "    "      "  s
*    
*    
!  
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP COM.AIICMD.VAR.EQUATES
*
*
* $INCLUDE IBP COM.PAI.EQUATES
DIM COM.PAI(20)
EQU COM.PAI$PORT    TO COM.PAI(1); * 0 = ?1
EQU COM.PAI$SSYS    TO COM.PAI(2); * 1
EQU COM.PAI$SPOC    TO COM.PAI(3); * 0
EQU COM.PAI$FCABLE  TO COM.PAI(4); * A B C = ?C
EQU COM.PAI$FCHAN   TO COM.PAI(5); * 00 TO 99 = ??45
EQU COM.PAI$FINDX   TO COM.PAI(6); * 0 1 2 3  = ?0
EQU COM.PAI$POC     TO COM.PAI(7); * 0 - 9, A - F = 0
*
OPEN "COM" TO COM.FILE ELSE STOP
MATREAD COM.PAI FROM COM.FILE,"AI.MNFT.SPEC.PA" ELSE
MAT COM.PAI = EMPTY
COM.PAI$PORT = 1
COM.PAI$SSYS = 1
COM.PAI$SPOC = 0
COM.PAI$FCABLE = "C"
COM.PAI$FCHAN = "45"
COM.PAI$FINDX = "0"
COM.PAI$POC = "0"
END
*
* FORMAT DEVICE ID WITH
*  AIX DEVICE NUMBER
*  AND DEVICE LETTER FOR MULTI ADDR DEVICES (EAI8 & EAI4)
*
* HANDLE BASIC HERE
* LOOP THROUGH SERVICES
*     CHECKING TIER STATUS
*     AND IF TIER THEN FORMAT "00":TIER "R#2"
*     IF NO TIER AND BASIC THEN "14"
*
* FORMAT MAIN PORTION OF OUTPUT.PACKET AND ADD PASSED DATA AREAS; USE A
*  CASE STATEMENTS TO DEAL WITH EACH TRANS TYPE.
*
*
*
* STXC = CHAR(13):CHAR(02); * STXC = CHAR(0):CHAR(13):CHAR(02)
* STXC = CHAR(0):CHAR(0):CHAR(02)
STXC = CHAR(2)
* STXC = CHAR(13):CHAR(02)
OUTPUT.PACKET = EMPTY
OUTPUT.PACKET.HDR = EMPTY
*
IF CNT.TST$LBL THEN
* AM.CN = 1
* AM.CN.MAX = 40
PRINT OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS")
PRINT COM.AIP$COMM.PORT
* LOOP UNTIL AM.CN GT AM.CN.MAX DO
* IF COM.AIP(AM.CN) NE EMPTY THEN
* OUTPUT.PACKET = OUTPUT.PACKET:"(":AM.CN:") ":COM.AIP(AM.CN):CR:LF
* END
* AM.CN = AM.CN + ONE
* REPEAT
END
*
! FORMAT THE TRANSACTION HEADER (CHECK SUM NOT PERFORMED ON THIS)
*
* STX
OUTPUT.PACKET.HDR = OUTPUT.PACKET.HDR:STXC
*
* POC NO.
OUTPUT.PACKET.HDR = OUTPUT.PACKET.HDR:("0":COM.PAI$POC) "R#1"
*
*
! Load Output Packet
*
! Transaction Sequence Number
* Incremented if no AI fatal error, and Unlocked by AI.PARSE.INPUT
*
LOOP
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
READ AI.NEXT.TRANS FROM COM.FILE,"AI.NEXT.TRANS.":AI.CODE ELSE AI.NEXT.TRANS = -ONE
CALL SYS.ITM.RLS("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
*
IF OPT.COMM = "SEQ" THEN AI.NEXT.TRANS = COM.AIP$TRAN.SEQ ELSE COM.AIP$TRAN.SEQ = AI.NEXT.TRANS
*
TMP = AI.NEXT.TRANS; GOSUB HX.CONV; AI.NEXT.TRANS.OUT = TMP1
*
AI.NEXT.TRANS.OUT = ("0000":AI.NEXT.TRANS.OUT) "R#4"
OUTPUT.PACKET = AI.NEXT.TRANS.OUT; * OUTPUT.PACKET = OCONV(AI.NEXT.TRANS.OUT,"HEX")
*
! Transaction type
*
*
*23MAR94*PKT.TYPE = COM.AIP$COMM
PKT.TYPE = OPT.COMM
FUNC.STATUS = COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
*23MAR94*IF INDEX("CRSD",COM.AIP$SVC.FUNC,ONE) THEN PKT.TYPE = "7B"
IF PKT.TYPE EQ "AIDVC" AND INDEX("CRSD",COM.AIP$SVC.FUNC,ONE) THEN PKT.TYPE = "7B"
IF FUNC.STATUS EQ "RVRS" THEN
IF PKT.TYPE EQ "IVI" THEN PKT.TYPE = "5D"
IF PKT.TYPE EQ "IVD" THEN PKT.TYPE = "5B"
IF PKT.TYPE EQ "PVI" THEN PKT.TYPE = "5D"
IF PKT.TYPE EQ "PVD" THEN PKT.TYPE = "5B"
END ELSE
IF PKT.TYPE EQ "IVI" THEN PKT.TYPE = "5B"
IF PKT.TYPE EQ "IVD" THEN PKT.TYPE = "5D"
IF PKT.TYPE EQ "PVI" THEN PKT.TYPE = "5B"
IF PKT.TYPE EQ "PVD" THEN PKT.TYPE = "5D"
END
IF PKT.TYPE EQ "SEQ" THEN PKT.TYPE = "12"
IF PKT.TYPE EQ "SET" THEN PKT.TYPE = "2B" 
* IF PKT.TYPE EQ "PVI" THEN PKT.TYPE = "5?"
* IF PKT.TYPE EQ "PVD" THEN PKT.TYPE = "5?"
IF PKT.TYPE EQ "COL" THEN PKT.TYPE = "5C"
IF PKT.TYPE EQ "DLE" THEN PKT.TYPE = "45"
IF PKT.TYPE EQ "UPB" THEN PKT.TYPE = "5U"
IF PKT.TYPE EQ "CLR" THEN PKT.TYPE = "59"
*
IF NOT(NUM(COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE>)) THEN COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = ZERO
*9606*DGH*IF INDEX("*57*5B*5C*5D*58*5U*","*":PKT.TYPE:"*",ONE) THEN
IF INDEX("*57*5C*5U*","*":PKT.TYPE:"*",ONE) THEN
***IF COM.AIP$END.UPL EQ EMPTY THEN
IF COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> GT ONE THEN PKT.TYPE = "57"
***END
END
*
!
*
LOCATE PKT.TYPE IN COM.AIICMD<COM.AIICMD$RCVD> SETTING LOC THEN
*
PKT.DESC = COM.AIICMD<COM.AIICMD$DESC,LOC>
IF CNT.TST$LBL THEN PRINT PKT.DESC:
*
IF COM.AIICMD<COM.AIICMD$LOG,LOC> EQ "Y" THEN
COM.AIP$LOG.REQD = 33333
END
*
**** PLACE TO PUT PAUSE & RETRY IN *****
IF COM.AIICMD<COM.AIICMD$PAUSE,LOC> NE "" THEN
IF COM.AIP$MAX.PAUSE LT COM.AIICMD<COM.AIICMD$PAUSE,LOC> THEN COM.AIP$MAX.PAUSE = COM.AIICMD<COM.AIICMD$PAUSE,LOC>
END
*
IF COM.AIICMD<COM.AIICMD$RETRY,LOC> NE "" THEN
IF COM.AIICMD<COM.AIICMD$RETRY,LOC> LT COM.AIP$RETRY THEN COM.AIP$RETRY = COM.AIICMD<COM.AIICMD$RETRY,LOC>
END
*
END
*
*
OUTPUT.PACKET = OUTPUT.PACKET:PKT.TYPE
*
!
*
! Rest of output packet according to PKT.TYPE
*
***********
BEGIN CASE
*
* ALL TRANSACTIONS ***NOT RECOMMENDED*** BY PIONEER HAVE BEEN REMOVED.
*
*
*
CASE PKT.TYPE EQ "12"
! Synchronize and Reset (Resequence)
*
* See above. OUTPUT.PACKET loaded with new trans num.
*
CASE PKT.TYPE EQ "2A"
! Set Force Tune Index
*
OUTPUT.PACKET = OUTPUT.PACKET:"0"
*
* Cable index with Force tune index (2 chars)
OUTPUT.PACKET = OUTPUT.PACKET:("C":COM.PAI$FCABLE) "R#1":("00":COM.PAI$FCHAN) "R#2"
*
*
CASE PKT.TYPE EQ "2B"
! Set Date/Time/Day of Week
*
CONV.DT = DATE(); CONV.TM = TIME()
GOSUB DT.CONVERT
*
OUTPUT.PACKET = OUTPUT.PACKET:("0000":HX.YY4) "R#4":("00":HX.MM) "R#2":("00":HX.DD) "R#2":("00":HX.HR) "R#2":("00":HX.MIN) "R#2":("00":HX.SEC) "R#2":("00":HX.DAY) "R#2"
*
*
*
*
CASE PKT.TYPE = "45"
! Define PPV Master Record
*
*
OUTPUT.PACKET = OUTPUT.PACKET:("0000":COM.AIP$EVENT) "R#4"
OUTPUT.PACKET = OUTPUT.PACKET:COM.AIP$EVENT.CH "R#4"
PPV.CONTROL.FLAGS = COM.AIP$SVC.EXTR
* 00000010 = disable/change PPV encoder code
* 0 - reserved
*  0 - disable tier linked PPV
*   0 - disable scramble/standy control with PPV
*    0 - (n/a) cyclic PPV type
*     0 - disable cyclic PPV indicator
*      0 - enable PPV channel
*       1 - disable change PPV encoder code
*        0 - disable change encoder tag value
OUTPUT.PACKET = OUTPUT.PACKET:PPV.CONTROL.FLAGS
CONV.DT = COM.AIP$EVENT.DT
CONV.TM = COM.AIP$EVENT.TM
GOSUB DT.CONVERT
OUT.DT = ("0000":YY4) "R#4":("00":MM) "R#2":("00":DD) "R#2"
OUT.TM = ("00":HR) "R#2":("00":MIN) "R#2"
OUTPUT.PACKET = OUTPUT.PACKET:OUT.DT:OUT.TM
CONV.DT = ""; CONV.TM = COM.AIP$EVENT.DUR
GOSUB DT.CONVERT
DUR.TM = ("00":HR) "R#2":("00":MIN) "R#2"
OUTPUT.PACKET = OUTPUT.PACKET:DUR.TM
ENCODER.GROUP  = ("XXXX":COM.AIP$WKO.SCH.DT) "R#2"
ENCODER.MEMBER = ("XXXX":COM.AIP$WKO.SCH.TM) "R#2"
OUTPUT.PACKET = OUTPUT.PACKET:ENCODER.GROUP:ENCODER.MEMBER
OUTPUT.PACKET = OUTPUT.PACKET:("0000":COM.AIP$EVENT) "R#4"
OUTPUT.PACKET = OUTPUT.PACKET:"XXXX"
*
*
*
*** CASE PKT.TYPE EQ "57"
*** ! Resend Upload
*** * Pkt 57 - empty
*** *
*** NULL
*** *
CASE PKT.TYPE EQ "59"
! Clear Collections
*
* SEE Manual. Get clarification of record format (ie loc of z).
TMP = COM.AIP$DVC.ID
FOR DVC.CN = ONE TO 40 UNTIL NOT(LEN(TMP))
IF TMP[1,1] NE "z" THEN
OUTPUT.PACKET = OUTPUT.PACKET:("000000":TMP<ONE,ONE>) "R#6"
END ELSE
OUTPUT.PACKET = OUTPUT.PACKET:"z0"
END
DEL TMP<ONE,ONE>
NEXT DVC.CN
*
*
*
CASE PKT.TYPE EQ "5B" OR PKT.TYPE EQ "5D" OR PKT.TYPE = "5C" OR PKT.TYPE EQ "5U" OR PKT.TYPE = "57"
! Installation or Downgrade
* 5B - IPPV Installation
* 5D - IPPV Downgrade
* 5C - One Shot Collection
* 5U - Upload Collections 
* 57 - Reupload packet after error
*
********************************************
*
IF PKT.TYPE NE "57" THEN
*
IF (PKT.TYPE = "5B" OR PKT.TYPE = "5D") THEN
UPLOAD.MODE = "D1" "L#2"; *   Do collection/Clear IPPV data
*D2....
END
*
IF PKT.TYPE EQ "5U" OR PKT.TYPE EQ "57" THEN
UPLOAD.MODE = ("0":COM.AIP$SVC.EXTR:"0") "R#2"
*                                    0     - upload not previously uploaded only
*                                    1     - upload all buys.
END
*
IF PKT.TYPE EQ "5C" THEN
*UPLOAD.MODE = "A1"; * Acknowledge only/IPPV data not cleared
UPLOAD.MODE = "D1"; * Upload transactions/IPPV data cleared
*D2
END
*
GOSUB GET.TERMINAL.ID
OUTPUT.PACKET = OUTPUT.PACKET:UPLOAD.MODE "L#2":TMP
*
END
*
IF (PKT.TYPE EQ "5B" OR PKT.TYPE EQ "5D") THEN
CG = "00" "R#2"; * Collection Group Number (all)
PO = "1" "R#1"; * POC port number
IT = "1" "R#1"; * phone return with BA6000
CL = "0" "R#1"; * for RF cable return
HX.CL = OCONV(CL,"HEX") "R#1"
DEFALTS   = "XXXXXXXXXXXXXXX" "R#15"
OUTPUT.PACKET = OUTPUT.PACKET:CG:PO:IT:HX.CL:DEFALTS
*
END ELSE IF PKT.TYPE EQ "5C" THEN
OUTPUT.PACKET = OUTPUT.PACKET:"00000000" "L#8"
*
END ELSE IF PKT.TYPE EQ "5U" THEN
IF PKT.TYPE = "5U" THEN TMP = COM.AIP$GROUP "R#2" ; GOSUB HX.CONV; CG = TMP1 "R#2" ELSE CG = "00"
OUTPUT.PACKET = OUTPUT.PACKET:CG:"00000000" "L#8"
END
*
*
*
*
CASE PKT.TYPE EQ "64"
! Start Group Collections
*
NULL
*
CASE PKT.TYPE EQ "65"
! Stop Collections
*
NULL
*
CASE PKT.TYPE EQ "6A"
! Clear Upload Group Collections
*
NULL
*
CASE PKT.TYPE EQ "73"
! Enquire BA-6000 Normal & Quick Poll Record
*
NULL
*
*
CASE PKT.TYPE EQ "7B"
! Define BA-6000 Normal & Quick Poll Record
*
DVC.ID.FLAG = TRUE
FUNC.PACKET = EMPTY
FUNC.STATUS = COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
GOSUB GET.TERMINAL.ID
OUTPUT.PACKET = OUTPUT.PACKET:TMP
TMP.FUNC = "3"
*
* Function code
*
IF COM.AIP$SVC.FUNC EQ "R" OR COM.AIP$SVC.FUNC EQ "C" THEN
*
*960620*DGH*IF FUNC.STATUS NE "RVRS" THEN
*960620*DGH*FUNC = "00"; * Add
*960620*DGH*END ELSE FUNC = "FF"; * Delete
IF FUNC.STATUS NE "RVRS" THEN
TMP.FUNC = "3"; * Enable
END ELSE TMP.FUNC = "4"; * Disable
*
END ELSE IF COM.AIP$SVC.FUNC EQ "S" THEN
*
* FUNC = "TR"; * Tier Replace
*960620*DGH*FUNC = "00"; * Add
TMP.FUNC = "3"; * Enable
* TA = Tier Add
* TD = Tier Del
*
END ELSE IF COM.AIP$SVC.FUNC EQ "D" THEN
*
*960620*DGH*IF FUNC.STATUS NE "RVRS" THEN
*960620*DGH*FUNC = "FF"; * Delete
*960620*DGH*END ELSE FUNC = "00"; * Add
IF FUNC.STATUS NE "RVRS" THEN
TMP.FUNC = "4"; * Disable
END ELSE TMP.FUNC = "3"; * Enable
*
END ELSE
*
*960620*DGH*FUNC = "11"; * Ignore
TMP.FUNC = "3"; * Enable
*
END
*
FUNC = "00"; * Add
FUNC.PACKET = FUNC.PACKET:FUNC
IF CNT.TST$LBL THEN PRINT "FUNC: ":FUNC
*
* Terminal Type
DVC.TYPE = COM.AIP$DVC.TYPE[ONE,3]
DVC.SUB.TYPE = COM.AIP$DVC.TYPE[4,9999]
IF DVC.SUB.TYPE EQ "CONV" THEN
IF (DVC.TYPE EQ "DES" OR DVC.TYPE EQ "IMP") AND DVC.SUB.TYPE EQ "CONV" THEN
FUNC.PACKET = FUNC.PACKET:"3"
END ELSE FUNC.PACKET = FUNC.PACKET:"3"
END ELSE FUNC.PACKET = FUNC.PACKET:"3"
IF CNT.TST$LBL THEN PRINT FUNC.PACKET
*
* Port Number
FUNC.PACKET = FUNC.PACKET:("0":COM.PAI$PORT) "R#1"
*
* Special functions
TMP = INDEX(COM.AIP$SVC.EXTR,"S",ONE)
*960620*DGH*IF TMP THEN
*960620*DGH*FUNC.PACKET = FUNC.PACKET:("0":COM.AIP$SVC.EXTR[TMP+ONE,ONE]) "R#1"
*960620*DGH*END ELSE
*960620*DGH*FUNC.PACKET = FUNC.PACKET:"0"
*960620*DGH*END
FUNC.PACKET = FUNC.PACKET:("1":TMP.FUNC) "R#1"
IF CNT.TST$LBL THEN PRINT FUNC.PACKET
*
* Reserved
FUNC.PACKET = FUNC.PACKET:"0"
IF CNT.TST$LBL THEN PRINT FUNC.PACKET
*
* Terminal Control Bits and Functions
TERM.BITS = EMPTY; FUNC.MULT = "1248"; TMP.FUNC = COM.AIP$DVC.FUNC
TMP.FUNC<ONE,-ONE> = "X"
TMP.FUNC<ONE,-ONE> = "X"
*
FOR CHAR.CN = 1 TO 2
IF CHAR.CN EQ ONE THEN
FUNC.INDX = "FTPR"
END ELSE FUNC.INDX = "XXWV"
TERM.CHAR = 0
*
FOR FUNC.CN = ONE TO 4
*
FUNC.TC = FUNC.INDX[FUNC.CN,ONE]
FUNC.MULT = FUNC.MULT[FUNC.CN,ONE]
IF FUNC.TC NE "F" THEN
LOCATE FUNC.TC IN TMP.FUNC<ONE> SETTING FUNC.LOC THEN
TERM.BITS = TERM.BITS:"0"
END ELSE TERM.BITS = TERM.BITS:"1"; TERM.CHAR = TERM.CHAR + FUNC.MULT
END ELSE TERM.BITS = TERM.BITS:"0"; TERM.CHAR = TERM.CHAR + FUNC.MULT
*
NEXT FUNC.CN
*
TERM.CHAR = OCONV(CHAR(TERM.CHAR),"HEX")
FUNC.PACKET = FUNC.PACKET:("0":TERM.CHAR) "R#1"
IF CNT.TST$LBL THEN PRINT "TERM.CHAR: ":TERM.CHAR
IF CNT.TST$LBL THEN PRINT "TERM.BITS: ":TERM.BITS
*
NEXT CHAR.CN
IF CNT.TST$LBL THEN PRINT FUNC.PACKET
*
* Infrared (R)emote
* (P)arental Control
* (T)imer
* VCR (F)ilter
* (V)olume Control
* Two (W)ay Active Control
* (X) Reserved
*
!
*
* Get Tiers
*
DVC.TIER.FLAG = TRUE
GOSUB GET.TIERS
FUNC.PACKET = FUNC.PACKET:("00000000":TIER.STRING) "R#8"
IF CNT.TST$LBL THEN PRINT "TIERS: ":TIER.STRING
IF CNT.TST$LBL THEN PRINT FUNC.PACKET
DVC.TIER.FLAG = FALSE
*
* Force Tune Index
*
FUNC.PACKET = FUNC.PACKET:("00":COM.PAI$FINDX) "R#2"
*
*
* Load Quick or Normal Poll Record
*
IF INDEX(COM.AIP$SVC.EXTR,"Q",ONE) THEN
*
IF CNT.TST$LBL THEN PRINT "QUICK"
OUTPUT.PACKET = OUTPUT.PACKET:FUNC.PACKET; * Load the Quick data
*                                          * Dummy up Normal data
* OUTPUT.PACKET = OUTPUT.PACKET:("0":COM.PAI$SSYS) "R#1":OCONV((("0":COM.PAI$SPOC) "R#1"),"HEX")
OUTPUT.PACKET = OUTPUT.PACKET:"11":STR("0",18)
*
END ELSE
*
IF CNT.TST$LBL THEN PRINT "NORMAL"
OUTPUT.PACKET = OUTPUT.PACKET:"11":STR("0",16); * Dummy up Quick data
*                                               * Load the Normal data
TMP = COM.PAI$SPOC; GOSUB HX.CONV
OUTPUT.PACKET = OUTPUT.PACKET:("0":COM.PAI$SSYS) "R#1":TMP1 "R#1"
OUTPUT.PACKET = OUTPUT.PACKET:FUNC.PACKET
OUTPUT.PACKET = OUTPUT.PACKET:"00"; * Events (not used)
*
END; * OF NORMAL
*
*
*
CASE PKT.TYPE EQ "7C"
! DLL BA-6000 Normal & Quick Poll Records
*
NULL
*
*
CASE PKT.TYPE EQ "7U"
! Upload BA-6000 Normal & Quick Poll Records
*
NULL
*
*
! ERROR ****
*
CASE TRUE
*
* *** ERROR - COMMAND NOT SUPPORTED FOR THIS INTERFACE
*
NULL
*
*
END CASE
*
COM.AIP$COMM.RSLT<ONE,SEND.COMM.CN,ONE> = PKT.TYPE
*
GOSUB GET.CHECK.SUM
*
RETURN
!
*
! Perform other packet functions
*
! Tiers
*
*IF DVC.TIER.FLAG THEN
*DVC.TYPE = COM.AIP$DVC.TYPE[ONE,3]
*DVC.SUB.TYPE = COM.AIP$DVC.TYPE[4,9999]
*GOSUB GET.TIERS
*OUTPUT.PACKET = OUTPUT.PACKET:("00000000":TIER.STRING) "R#8"
*END
*
GET.TERMINAL.ID: *
! Get Terminal Id
*
TMP = ("000000":COM.AIP$DVC.ID) "R#6"
*
RETURN
GET.CHECK.SUM: *
! Get Check sum
*
TC.PACKET = OUTPUT.PACKET
*
$INCLUDE IBP SYS.INCL.CALC.XOR.COMPL
*
OUTPUT.PACKET = OUTPUT.PACKET.HDR:OUTPUT.PACKET:TC.HEX:CR
*
*960626*DGH*COM.AIP$COMM.RSLT = PKT.TYPE
*
RETURN
*
GET.TIERS: *
! Load tiers
*
IF CNT.TST$LBL THEN PRINT "BUILD TIERS "
*
TIER.STRING = EMPTY
TIER.LOC = COM.AIP$AIX.LOCATION
IF NOT(TIER.LOC) THEN TIER.LOC = ONE
*
IF DVC.TIER.FLAG THEN
* 
DVC.TYPE = COM.AIP$DVC.TYPE[ONE,3]
DVC.SUB.TYPE = COM.AIP$DVC.TYPE[4,9999]
IF DVC.SUB.TYPE EQ EMPTY THEN DVC.SUB.TYPE = ONE
*
IF COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> NE "RVRS" THEN
COM.AIP.SVCS  = COM.AIP$SVC.ID.FUTR<ONE,TIER.LOC>
COM.AIP.TIERS = COM.AIP$TIERS.FUTR<ONE,TIER.LOC>
COM.AIP.TSTAT = COM.AIP$TSTAT.FUTR<ONE,TIER.LOC>
END ELSE
COM.AIP.SVCS = COM.AIP$SVC.ID<ONE,TIER.LOC>
COM.AIP.TIERS = COM.AIP$TIERS<ONE,TIER.LOC>
COM.AIP.TSTAT = COM.AIP$TSTAT<ONE,TIER.LOC>
END
*
TMP.ENABLE = EMPTY; TMP.AUTHOS = EMPTY
*
IF (DVC.TYPE EQ "DES" OR DVC.TYPE EQ "IMP") AND DVC.SUB.TYPE EQ "CONV" THEN
*
COM.AIP.TIER.ARRAY = EMPTY; BASIC.FLAG = FALSE
CN.MAX = DCOUNT(COM.AIP.TIERS,SVM)
FOR CN = ONE TO CN.MAX
IF CNT.TST$LBL THEN PRINT CN:"=":COM.AIP.TSTAT<ONE,ONE,CN>:", ":
IF COM.AIP.TSTAT<ONE,ONE,CN> THEN
ARRAY.AM = COM.AIP.TIERS<ONE,ONE,CN>
IF ARRAY.AM THEN
COM.AIP.TIER.ARRAY<ARRAY.AM> = 1
END
IF COM.AIP.TIERS<ONE,ONE,CN> AND COM.AIP.SVCS<ONE,ONE,CN> EQ "(BASIC)" THEN
BASIC.FLAG = TRUE
END
END
NEXT CN
IF CNT.TST$LBL THEN PRINT
*
FOR CN = ONE TO 8
TIER.VALUE = ZERO
FOR CN1 = ONE TO 4
*
TIER.STAT = COM.AIP.TIER.ARRAY<((CN - ONE) * 4) + CN1> + 0
IF TIER.STAT THEN
BEGIN CASE
CASE CN1 EQ 1; TIER.VALUE = TIER.VALUE + 1
CASE CN1 EQ 2; TIER.VALUE = TIER.VALUE + 2
CASE CN1 EQ 3; TIER.VALUE = TIER.VALUE + 4
CASE CN1 EQ 4; TIER.VALUE = TIER.VALUE + 8
CASE TRUE; NULL
END CASE
END
*
NEXT CN1
* TIER.STRING = (OCONV(CHAR(TIER.VALUE),"HEX")) "R#1":TIER.STRING
TIER.STRING = TIER.VALUE:TIER.STRING
IF CNT.TST$LBL THEN PRINT CN:"=":TIER.VALUE:"(":OCONV(CHAR(TIER.VALUE),"HEX"):"), ":
NEXT CN
TMP = TIER.STRING; GOSUB HX.CONV; TIER.STRING = TMP1
IF CNT.TST$LBL THEN PRINT
IF CNT.TST$LBL THEN PRINT TIER.STRING
*
* IF NOT(BASIC.FLAG) THEN
* TMP.ENABLE = "01"
* * TMP.AUTHOS = EMPTY:TMP.AUTHOS
* END ELSE
* TMP.ENABLE = "01"
* TMP.AUTHOS = "14":TMP.AUTHOS
* END
*
END; * Of "PAI"
*
END; * Of DVC.TIER.FLAG
*
DVC.TIER.FLAG = FALSE
*
RETURN
*
DT.CONVERT: *
*
*
DISP.DT = OCONV(CONV.DT,"D-")
*
MM = DISP.DT[ONE,TWO]; * HX.MM = OCONV(MM,"HEX")
TMP = MM;  GOSUB HX.CONV; HX.MM = TMP1
*
DD = DISP.DT[4,TWO]; * HX.DD = OCONV(DD,"HEX")
TMP = DD;  GOSUB HX.CONV; HX.DD = TMP1
*
YY = DISP.DT[9,TWO]; YY4 = DISP.DT[7,4]; * HX.YY4 = OCONV(YY4,"HEX")
TMP = YY4; GOSUB HX.CONV; HX.YY4 = TMP1
*
* Days
DAYS = INT(1967 * 365.25) + CONV.DT
DAY = REM(DAYS,7)
*
* Time
DISP.TM = OCONV(CONV.TM,"MTS")
HR = DISP.TM[ONE,TWO]; MIN = DISP.TM[4,TWO]; SEC = DISP.TM[7,TWO]
*
TMP = HR;  GOSUB HX.CONV; HX.HR = TMP1
TMP = MIN; GOSUB HX.CONV; HX.MIN = TMP1
TMP = SEC; GOSUB HX.CONV; HX.SEC = TMP1
* HX.HR = OCONV(HR,"HEX"); HX.MIN = OCONV(MIN,"HEX"); HX.SEC = OCONV(SEC,"HEX")
*
* YYYYMMDDHHMMSS       EEMM   (EE is 0 - 168)
*
RETURN
*
!
*
HX.CONV: * CONVERT NUMBERS TO HEX
*
* TMP = DATA TO CONVERT. TMP1 = HEX RESULT.
TMP1 = EMPTY; TMP2 = 16
*
$INCLUDE IBP SYS.INCL.CONV.NUM.TO.HEX
*
*
RETURN
*
*
END
~AI.PRINT.LOG~
*PROGRAM: AI.PRINT.LOG
*
*      Print addressable interface handler log...
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.PRINT.LOG"; SYS.LOCT = EMPTY
SYS.PRNT = EMPTY
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP AIL.DIM
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP AIL.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
MAT COM.AIIERR = EMPTY
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
MAT COM.AIHERR = EMPTY
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
!
INPUT AUTO.RUN
INPUT FILE.RUN
INPUT RUN.TYPE
INPUT SEQ.FL
IF FILE.RUN THEN
OPEN "COM" TO COM.FILE ELSE TEXT = "Can't open COM"; GOSUB ERROR; STOP
END ELSE
OPEN "AIL" TO AIL.FILE ELSE TEXT = "Can't open AIL"; GOSUB ERROR; STOP
END
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "COM" TO COM.FILE ELSE TEXT = "Can't open COM"; GOSUB ERROR; STOP
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<ONE,ONE> ELSE CO.NAME = ""
HEADEND = EMPTY; INTFC.TYPE = "?"
SEQ = EMPTY; TRAN.SEQ = EMPTY; PREV.TRAN.SEQ = "@@@"
**SEQ.FL = TRUE
PRINT @(ZERO,ZERO):CLS:
PRINT @(ZERO,ZERO):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28 - (((LEN(CO.NAME) + ONE) / TWO))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(ZERO,ONE):RVB:"                   Addressable Interface - Print handler log                    ":RVE:
*
LPT.FLAG = FALSE
* HDR = "LSeq Oper. Port Comm. Acct.Id Src Requested... Completed... CL"
HDR =  "LSeq Oper. Port TrSeq Acct.Id Src Requested... Completed... CL"
HDR0 = "                                  ..Date. Time ..Date. Time"
HDR1 = "Log## Location.. S Routine.Name............. ..Account........... Addr.Intfc "
HDR2 =  "Service T S Futr.Svc T S"
HDR3 = "### Stat Command Mt At Std Message................ Dvc Message....................." "L#79"
HDR4 =  "Ev# W.O.No.. .Device. Event Dur EventDate EventTime"
HDR5A = "         1         2         3         4         5"
HDR5B = "12345678901234567890123456789012345678901234567890"
* AUTO
IF AUTO.RUN THEN
READ AUTO.INPUTS FROM PAR.FILE,"CURRENT.RUN" ELSE AUTO.INPUTS = VM:"P":VM:"1":VM:"NONE":VM:"1"
END ELSE AUTO.INPUTS = EMPTY
*
!
*
GET.RSP: *
*
LOOP
PRINT @(ZERO,8):"Enter interface port: ":
IF NOT(AUTO.RUN) THEN
INPUT AI.CODE:
IF AI.CODE EQ "KILL" THEN STOP
END ELSE
AI.CODE = AUTO.INPUTS<ONE,4>
* VALIDATE
PRINT AI.CODE:
END
COM.AI.ID = "AI.TYPE.":AI.CODE
MATREAD COM.AI FROM COM.FILE,COM.AI.ID ELSE AI.CODE = EMPTY
WHILE AI.CODE EQ EMPTY DO PRINT BELL: REPEAT
*
AIL.SEQ.ID = "AI.LOG*":AI.CODE
**READ AIL.SEQ FROM COM.FILE,AIL.SEQ.ID ELSE AIL.SEQ = ZERO
READ AIL.CNTRL FROM COM.FILE,AIL.SEQ.ID ELSE 
AIL.CNTRL<ONE> = ZERO
AIL.CNTRL<TWO> = 999
END
*
AIL.SEQ = AIL.CNTRL<ONE>
AIL.SEQ.MAX = AIL.CNTRL<TWO>
*
!
*
LOOP
PRINT @(ZERO,10):"Enter option (T)erminal, (<cr>/P)rinter: ":
IF NOT(AUTO.RUN) THEN
INPUT OPT.RSP:
IF OPT.RSP EQ "KILL" THEN STOP
END ELSE
OPT.RSP = AUTO.INPUTS<ONE,TWO>
IF OPT.RSP NE "T" AND AUTO.RSP NE "P" THEN AUTO.RSP = "P"
PRINT OPT.RSP:
END
WHILE OPT.RSP NE "P" AND OPT.RSP NE "T" DO PRINT BELL: REPEAT
IF OPT.RSP EQ "P" THEN LPT.FLAG = TRUE
*
!
*
IF FILE.RUN THEN OPT.MODE = ONE ELSE
*
IF RUN.TYPE EQ 2 THEN
OPT.MODE = 2
LOOP
PRINT @(ZERO,12):"Enter the starting sequence number: ":
INPUT SEQ.BEG:
IF SEQ.BEG EQ "KILL" THEN STOP
IF NOT(NUM(SEQ.BEG)) THEN SEQ.BEG = AIL.CNTRL<ONE>
WHILE SEQ.BEG EQ EMPTY DO REPEAT
LOOP
PRINT @(ZERO,13):"Enter the ending sequence number: ":
INPUT SEQ.END:
IF SEQ.END EQ "KILL" THEN STOP
IF NOT(NUM(SEQ.END)) THEN SEQ.END = AIL.CNTRL<ONE> + ONE
WHILE SEQ.END EQ EMPTY DO REPEAT
*
END ELSE
*
LOOP
PRINT @(ZERO,12):"Enter mode (1) All sequential, (2) Counting back, ":
PRINT @(ZERO,13):"           (3) Previous twenty entries: ":
IF NOT(AUTO.RUN) THEN
INPUT OPT.MODE:
IF OPT.MODE EQ "KILL" THEN STOP
END ELSE
OPT.MODE = AUTO.INPUTS<ONE,3>
IF OPT.MODE NE "1" AND OPT.MODE NE "2" AND OPT.MODE NE "3" THEN OPT.MODE = "1"
PRINT OPT.MODE:
END
IF NOT(NUM(OPT.MODE)) THEN OPT.MODE = EMPTY
WHILE OPT.MODE NE ONE AND OPT.MODE NE TWO AND OPT.MODE NE 3 DO PRINT BELL: REPEAT
SEQ.BEG = AIL.SEQ
SEQ.END = AIL.SEQ + ONE
END; * of FILE.RUN
END; * of RUN.TYPE
*
!
*
LOOP
PRINT @(ZERO,15):"Do you want to view the packets in hex (Y/N=<CR>): ":
IF NOT(AUTO.RUN) THEN
INPUT PCK.FLAG:
IF PCK.FLAG EQ "KILL" THEN STOP
IF PCK.FLAG EQ "" THEN PCK.FLAG = "N"
END ELSE
PCK.FLAG = AUTO.INPUTS<ONE,5>
IF PCK.FLAG NE "N" AND PCK.FLAG NE "Y" THEN PCK.FLAG = "N"
PRINT PCK.FLAG:
END
WHILE PCK.FLAG NE "N" AND PCK.FLAG NE "Y" DO PRINT BELL: REPEAT
*
!
*
LOOP
PRINT @(ZERO,17):"Do you want to convert packets for testing (Y/N=<CR>): ":
IF NOT(AUTO.RUN) THEN
INPUT RSP.FLAG:
IF RSP.FLAG EQ "KILL" THEN STOP
IF RSP.FLAG EQ "" THEN RSP.FLAG = "N"
END ELSE
RSP.FLAG = AUTO.INPUTS<ONE,6>
IF RSP.FLAG NE "N" AND RSP.FLAG NE "Y" THEN RSP.FLAG = "N"
PRINT RSP.FLAG:
END
WHILE RSP.FLAG NE "N" AND RSP.FLAG NE "Y" DO PRINT BELL: REPEAT
*
!
!
*
AUTO.LOAD: *
*
IF NOT(AUTO.RUN) THEN
* AUTO
AUTO.INPUTS = OPT.RSP:VM:OPT.MODE:VM:AI.CODE:VM:PCK.FLAG:VM:RSP.FLAG
CALL AUTO.LOADER("AI.PRINT.LOG",AUTO.INPUTS,"Handler Log")
END
*
!
*
READ.INIT: *
*
READ AI.COMMANDS FROM PAR.FILE,"AI.COMMANDS" ELSE AI.COMMANDS = ""
*
READ AI.ERRORS FROM PAR.FILE,"AI.HERRORS" ELSE AI.ERRORS = ""
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = ""
*
*
AIL.SEQ = SEQ.BEG
ORIG.SEQ = AIL.SEQ
IF PCK.FLAG EQ "Y" THEN PCK.FLAG = TRUE ELSE PCK.FLAG = FALSE
IF RSP.FLAG EQ "Y" THEN RSP.FLAG = TRUE ELSE RSP.FLAG = FALSE
RSP.STACK = EMPTY
*
!
*
FILE.SELECT: *
*
IF OPT.MODE EQ ONE THEN
IF FILE.RUN THEN
FILE.NAME = 'COM'
END ELSE FILE.NAME = "AIL"
PRINT @(30,10):CLL:"Selecting ":FILE.NAME:" items...":
IF FILE.RUN THEN
EXEC.TEXT = 'EQ "AI*]" WITH AI.CODE EQ "':AI.CODE:'" BY COMM.DT BY COMM.TM BY SEQ'
*
EXECUTE 'SSELECT COM ':EXEC.TEXT, //SELECT. > AIL.ID.LIST
*
END ELSE
*
EXEC.TEXT = 'WITH AI.CODE EQ "':AI.CODE:'" BY COMM.DT BY COMM.TM BY SEQ'
*
EXECUTE 'SSELECT AIL ':EXEC.TEXT, //SELECT. > AIL.ID.LIST
*
END
END
*
!
*
MAIN: *
PRINT @(30,10):CLL:"Printing report...":
*
PGS = ZERO; LNS = 99
* CURR.SEQ = ZERO; ORIG.SEQ = ZERO
CURR.SEQ = AIL.SEQ + ONE
IF NOT(LPT.FLAG) THEN
PRINT CLB
PRINT
PRINT
END
*
!
*
LOOP
*
IF SYSTEM(11) THEN AIL.ID = "@" ELSE
*
IF OPT.MODE EQ ONE THEN
*
READNEXT AIL.ID FROM AIL.ID.LIST ELSE AIL.ID = "@"
CURR.SEQ = FIELD(AIL.ID,"*",3)
*
END ELSE
*
CURR.SEQ = CURR.SEQ - ONE
IF CURR.SEQ LT ZERO THEN CURR.SEQ = AIL.SEQ.MAX
IF CURR.SEQ GE ZERO THEN
AIL.ID = "AI*":AI.CODE:"*":("0000":CURR.SEQ) "R#4":"*LOG"
END ELSE AIL.ID = "@"
IF OPT.MODE EQ 3 THEN
IF ((ORIG.SEQ LT CURR.SEQ) * AIL.SEQ.MAX) + ORIG.SEQ - CURR.SEQ GT 10 THEN AIL.ID = "@"
END
*
END; * OF OPT.MODE 1 or 2/3
*
END; * OF SYSTEM(11)
*
UNTIL AIL.ID EQ "@" DO
*
!
*
MATREAD AIL FROM AIL.FILE,AIL.ID THEN
*
*
HEADEND = FIELD(AIL.ID,"*",TWO)
SEQ     = FIELD(AIL.ID,"*",3)
TRAN.SEQ = AIL$TRAN.SEQ
*
!
*
IF TRAN.SEQ NE PREV.TRAN.SEQ OR NOT(SEQ.FL) THEN
*
PREV.TRAN.SEQ = TRAN.SEQ
*
*
IF RSP.FLAG THEN
*
IF LEN(RSP.STACK) LT 30000 THEN
TMP = AIL$HEX.RSLT
TMP.CN = ONE
LOOP WHILE LEN(TMP) DO
TMP1 = TMP<ONE,ONE,ONE>:VM:CURR.SEQ:VM:TMP.CN
INS TMP1 BEFORE RSP.STACK<ONE>
DEL TMP<ONE,ONE,ONE>
IF TMP<ONE,ONE> EQ EMPTY THEN
DEL TMP<ONE,ONE>
END
TMP.CN = TMP.CN + ONE
REPEAT
*
END ELSE
WRITE RSP.STACK ON COM.FILE,"AI.RSP.STACK"
RSP.FLAG = FALSE
END
*
END; * of RSP.FLAG
*
!
*
LOCATE AIL$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
IF INTFC.TYPE NE COM.AI$DB.PREFIX<ONE,DVC.LOC> THEN
INTFC.TYPE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.TYPE ELSE NULL
END
*
RDATE = OCONV(AIL$COMM.DT,"D2")
RDATE = RDATE[ONE,TWO]:RDATE[4,3]:RDATE[8,TWO]
RTIME = OCONV(AIL$COMM.TM,"MT")
RTIME = RTIME[ONE,TWO]:RTIME[4,TWO]
*
CDATE = OCONV(AIL$COMM.C.DT,"D2")
CDATE = CDATE[ONE,TWO]:CDATE[4,3]:CDATE[8,TWO]
CTIME = OCONV(AIL$COMM.C.TM,"MT")
CTIME = CTIME[ONE,TWO]:CTIME[4,TWO]
*
AIX.LOC = AIL$AIX.LOCATION
OSVC.MAX = DCOUNT(AIL$SVC.ID<ONE,AIX.LOC>,SVM)
FSVC.MAX = DCOUNT(AIL$SVC.ID.FUTR<ONE,AIX.LOC>,SVM)
*
LOG.MAX = DCOUNT(AIL$LOG.LOC<ONE,ONE>,SVM)
*
EVENT.MAX = DCOUNT(AIL$EVENT,VM)
*
VC.MAX = ONE; SC.MAX = ONE
VC.MAX = DCOUNT(AIL$COMM<ONE>,VM)
*
!
*
FOR VC = ONE TO VC.MAX
*
SVC.MAX = ONE
*
STAT.MAX = DCOUNT(AIL$INTFC.STAT<ONE,VC>,SVM)
IF STAT.MAX GT SVC.MAX THEN SVC.MAX = STAT.MAX
*
PCK.MAX = DCOUNT(AIL$HEX.COMM<ONE,VC>,SVM)
TMP = DCOUNT(AIL$HEX.RSLT<ONE,VC>,SVM)
IF TMP GT PCK.MAX THEN PCK.MAX = TMP
IF PCK.MAX GT SVC.MAX THEN SVC.MAX = PCK.MAX
*
SEND.CN.MAX = AIL$COMM.CN<ONE,VC,ONE>
RTRY.CN.MAX = AIL$RETRY<ONE,VC>
IF SEND.CN.MAX GT SVC.MAX THEN SVC.MAX = SEND.CN.MAX
*
ERR.MAX = DCOUNT(AIL$ERR<ONE>,VM)
ERR.SVC.MAX = DCOUNT(AIL$ERR<ONE,VC>,SVM)
***IF ERR.SVC.MAX GT SVC.MAX THEN SVC.MAX = ERR.SVC.MAX
*
INTFC.ERR.MAX = DCOUNT(AIL$INTFC.ERR<ONE>,VM)
INTFC.ERR.SVC.MAX = DCOUNT(AIL$INTFC.ERR<ONE,VC>,SVM)
IF INTFC.ERR.SVC.MAX GT SVC.MAX THEN SVC.MAX = INTFC.ERR.SVC.MAX
*
!
*
LOG.MAX = DCOUNT(AIL$LOG.LOC<ONE,ONE>,SVM)
*
!
*
SEND.MAX = AIL$COMM.CN<ONE,VC,ONE>
IF SEND.MAX LE ZERO THEN SEND.MAX = ONE
*
LN = ZERO; LINES = EMPTY
*
!
*
SC = ONE; CONT = TRUE
RTY = ONE
*
FOR RTY = ONE TO 4
*
*
*
** @ *LOOP
** @ **
** @ *LINE = EMPTY
** @ **
** @ *IF RTY GT 3 THEN CONT = FALSE
** @ **
** @ *IF VC GT 3 THEN
** @ ** IF VC GT FSVC.MAX THEN
** @ ** IF VC GT OSVC.MAX THEN
** @ ** IF VC GT STAT.MAX THEN
** @ ** IF VC GT ERR.MAX THEN
** @ *CONT = FALSE
** @ ** END
** @ ** END
** @ ** END
** @ ** END
** @ *END
** @ **
** @ *WHILE CONT DO
** @ **
*
*
LINE = EMPTY
*
IF RTY EQ ONE THEN
*
LINE<-ONE> = HDR "L#78"; LN = LN + ONE
LINE<-ONE> = HDR0 "L#78"; LN = LN + ONE
*
LINE<-ONE> = (SEQ "R#4":" ":AIL$OPER "L#5":" ":AIL$PORT "R#4":" ":AIL$TRAN.SEQ "R#5":" ":AIL$ACCT.ID "R#7":"  ":AIL$COMM.SRCE "L#1":"  ":RDATE "R#7":" ":RTIME "L#4":" ":CDATE "R#7":" ":CTIME "L#4":" ":AIL$GROUP.RSLT "L#2") "L#78"; LN = LN + ONE
**LINE<-ONE> = (SEQ "R#4":" ":AIL$OPER "L#5":" ":AIL$PORT "R#4":" ":AIL$COMM<ONE,VC,ONE> "R#5") "L#78"; LN = LN + ONE
*
BEGIN CASE
*
CASE AIL$SVC.FUNC EQ "SYS"
*
BEGIN CASE
*
CASE AIL$COMM EQ AI.ON; PMESSAGE = "Handler Start'ed *****************************"
CASE AIL$COMM EQ AI.UP; PMESSAGE = "Handler Up'ed ********************************"
CASE AIL$COMM EQ AI.DN; PMESSAGE = "Handler down'ed ******************************"
CASE AIL$COMM EQ AI.OFF; PMESSAGE = "Handler Off'ed *******************************"
CASE TRUE; PMESSAGE = AIL$COMM
*
END CASE
*
LINE<-ONE> = PMESSAGE; LN = LN + ONE
*
CASE AIL$SVC.FUNC EQ "CHAN"
*
BEGIN CASE
CASE TMP = "D"; PMESSAGE = "Channels down'ed *****************************"
CASE TMP = "U"; PMESSAGE = "Channels up'ed *******************************"
CASE TRUE; PMESSAGE = EMPTY
END CASE
*
LINE<-ONE> = PMESSAGE; LN = LN + ONE
*
CASE TRUE
*
PMESSAGE = EMPTY
*
END CASE
*
!
*
FOR LOG.SVC = ONE TO LOG.MAX
*
IF LOG.SVC EQ ONE THEN
LINE<-ONE> = HDR1 "L#78"; LN = LN + ONE
END
*
TMP = "L# ":LOG.SVC "R#2":" ":AIL$LOG.LOC<ONE,VC,LOG.SVC> "L#10":" ":AIL$LOG.SRCE<ONE,VC,LOG.SVC> "L#1":" "
TMP = TMP:AIL$LOG.PROG<ONE,VC,LOG.SVC> "L#25":" ":AIL$LOG.ACCT<ONE,VC,LOG.SVC> "L#20":" "
TMP = TMP:AIL$LOG.PORT<ONE,VC,LOG.SVC> "R#10":" "
LINE<-ONE> = TMP "L#78"; LN = LN + ONE
*
NEXT LOG.SVC
*
END; * of RTY eq 1
*
!
*
IF RTY EQ TWO THEN
*
** @ *TMP = DCOUNT(AIL$EVENT,VM)
** @ *IF NOT(EVENT.MAX) THEN EVENT.MAX = 1
** @ *LINE = ""
** @ *IF AIL$COMM<ONE,VC> NE EMPTY THEN
** @ *LINE<-ONE> = (SEQ "R#4":" ":AIL$OPER "L#5":" ":AIL$PORT "R#4":" ":AIL$COMM<ONE,VC> "R#5") "L#78"
** @ *END
*
IF EVENT.MAX THEN
*
LINE<-ONE> = HDR4; LN = LN + ONE
*
FOR EVENT.VC = 1 TO EVENT.MAX
LINE<-ONE> = ("E":EVENT.VC "R#2":" ":AIL$WKO.ID "R#8":" ":AIL$DVC.ID "R#8":" ":AIL$EVENT<1,EVENT.VC> "R#5":" ":AIL$EVENT.DUR<1,EVENT.VC> "L#3":" ":OCONV(AIL$EVENT.DT<1,EVENT.VC>,"D2") "L#9":" ":OCONV(AIL$EVENT.TM<1,EVENT.VC>,"MTS") "L#9") "L#78"; LN = LN + ONE
****IF EVENT.VC GT 1 THEN LN = LN + 1
NEXT EVENT.VC
*
END; * of EVENT.MAX
*
END; * of RTY eq 2
*
!
*
IF RTY EQ 4 THEN
*
IF PCK.FLAG THEN
*
FOR PCK.SVC = ONE TO PCK.MAX
*
*@@*LINE = "."; LN = LN + ONE
*
TMP = "C## ERR  "
LINE<-ONE> = TMP:HDR5A "L#30":" ":TMP:HDR5A "L#30"; LN = LN + ONE
LINE<-ONE> = TMP:HDR5B "L#30":" ":TMP:HDR5B "L#30"; LN = LN + ONE
CN = 0
TMP2 = ("C":PCK.SVC "R#2":" ":AIL$ERR<ONE,VC,PCK.SVC> "R#3")
TMP3 = ("C":PCK.SVC "R#2":" ":AIL$INTFC.ERR<ONE,VC,PCK.SVC> "R#3")
LOOP
TMP = AIL$HEX.COMM<ONE,VC,PCK.SVC>[CN * 30 + ONE,30]
TMP1 = AIL$HEX.RSLT<ONE,VC,PCK.SVC>[CN * 30 + ONE,30]
WHILE TMP NE "" OR TMP1 NE "" DO
LINE<-ONE> = (TMP2 "L#9":TMP "L#30":" ":TMP3 "L#9":TMP1 "L#30") "L#79"; LN = LN + ONE
CN = CN + 1
TMP2 = ("++":CN:" ") "R#9"
TMP3 = ("++":CN:" ") "R#9"
REPEAT
*
NEXT PCK.SVC
*
!
*
** @ ***@@*LINE<-ONE> = "."; LN = LN + ONE
** @ **LINE = EMPTY
** @ **LINE<-ONE> = "        1         2         3         4         5"; LN = LN + ONE
** @ **LINE<-ONE> = "1234567801234567890123456789012345678901234567890"; LN = LN + ONE
** @ **CN = 0
** @ **LOOP
** @ **TMP = AIL$HEX.RSLT[CN*50+1,50]
** @ **WHILE TMP NE "" DO
** @ **LINE<-ONE> = TMP; LN = LN + ONE
** @ **CN = CN + 1
** @ **REPEAT
** @ ***
** @ ***@@*LINE<-ONE> = "."; LN = LN + ONE
** @ **** @ **LINE = EMPTY
** @ ***
** @ **END ELSE
** @ **LINE = EMPTY
*
END; * of PCK.FLAG
*
END; * of RTY eq 4
*
!
*
** @ *END ELSE
** @ *IF LPT.FLAG THEN
** @ *LINE = SPACE(78)
** @ *END ELSE LINE = EMPTY
** @ *END
** @ **
** @ *!
** @ **
** @ *VC = VC + ONE; LN = LN + ONE
** @ **
** @ *LINES<-ONE> = LINE
** @ **
** @ *REPEAT
** @ **
** @ *!
** @ **
** @ *VC = ONE; SC = ONE; CONT = TRUE
** @ **
** @ *LOOP
** @ ***
** @ **LINE = EMPTY
** @ ***
** @ ***@@*IF VC GT STAT.MAX THEN
** @ ***@@*IF VC GT ERR.MAX THEN
** @ **IF VC GT VC.MAX THEN
** @ **CONT = FALSE
** @ **END
** @ ***@@*END
** @ ***@@*END
** @ ***
** @ **WHILE CONT DO
** @ ***
*
!
*
IF RTY EQ 3 THEN
*
*
*@@*IF VC EQ ONE THEN
LINE<-ONE> = HDR3; LN = LN + ONE
SVC = ONE
*@@*END
*
IF SVC LE STAT.MAX THEN
TMPL = VC:".":SVC:" ":AIL$INTFC.STAT<ONE,VC,SVC> "L#4":" ":AIL$COMM<ONE,VC,SVC> "L#7"
TMPL = TMPL:" ":AIL$RETRY<ONE,VC,SVC> "R#2":" ":AIL$COMM.CN<ONE,VC,SVC> "R#2"
END ELSE
TMPL = SPACE(8):SPACE(8):SPACE(6)
END
*
** ?? **IF VC LE ERR.MAX OR VC LE INTFC.ERR.MAX THEN
IF ERR.MAX OR INTFC.ERR.MAX OR STAT.MAX GT ONE THEN
*
** ERR.SVC.MAX = DCOUNT(AIL$ERR<ONE,VC>,SVM)
** INTFC.ERR.SVC.MAX = DCOUNT(AIL$INTFC.ERR<ONE,VC>,SVM)
*
*
SVC = ONE
*
LOOP
*
IF SVC GT ONE THEN
IF AIL$INTFC.STAT<ONE,VC,SVC> NE "" THEN TMPL = VC:".":SVC:" ":AIL$INTFC.STAT<ONE,VC,SVC> "L#4":SPACE(8):SPACE(6) ELSE
TMPL = VC:".":SVC:SPACE(5):SPACE(8):SPACE(6)
END
END
*
** ?? **IF VC LE ERR.MAX AND SVC LE ERR.SVC.MAX THEN
IF SVC LE ERR.SVC.MAX THEN
*
TMP = AIL$ERR<ONE,VC,SVC>
LOCATE TMP IN COM.AIHERR$STD<ONE> SETTING TMP.LOC THEN
TMP1 = COM.AIHERR$DESC<ONE,TMP.LOC>
END ELSE
TMP1 = "Unknown"
END
TMPL = TMPL:" ":TMP "R#3":" ":TMP1 "L#23"
*
END ELSE TMPL = TMPL:SPACE(28)
*
*
** ?? **IF VC LE INTFC.ERR.MAX AND SVC LE INTFC.ERR.SVC.MAX THEN
IF SVC LE INTFC.ERR.SVC.MAX THEN
*
TMP = AIL$INTFC.ERR<ONE,VC,SVC>
LOCATE TMP IN COM.AIIERR$STD<ONE> SETTING TMP.LOC THEN
TMP1 = COM.AIIERR$DESC<ONE,TMP.LOC>
END ELSE
TMP1 = "Unknown"
END
TMPL = TMPL:" ":TMP "R#3":" ":TMP1 "L#23"
*
END ELSE TMPL = TMPL:SPACE(28)
*
*
**WHILE (VC LE ERR.MAX AND VC LE INTFC.ERR.MAX) AND (SVC LE ERR.SVC.MAX AND SVC LE INTFC.ERR.SVC.MAX) DO
WHILE (VC LE ERR.MAX AND SVC LE ERR.SVC.MAX) OR (VC LE INTFC.ERR.MAX AND SVC LE INTFC.ERR.SVC.MAX) OR SVC LE STAT.MAX DO
*
SVC = SVC + ONE
*
LINE<-ONE> = TMPL; LN = LN + ONE
*
REPEAT
*
LINES<-ONE> = LINE
LINE = EMPTY
*
END ELSE
LINES<-ONE> = LINE; LN = LN + ONE
LINE = EMPTY
END
*
*
END; * of RTY eq 3
*
!
*
IF LINE NE EMPTY THEN
LINES<-ONE> = LINE
END
*
*
NEXT RTY
*
NEXT VC
*
!
*
** @ **** END ELSE
** @ **** *
** @ **** LINE = LINE:SPACE(70)
** @ **** *
** @ **END ELSE
** @ **LN = LN + ONE
** @ **LINES<-ONE> = LINE
** @ **END
** @ ***
** @ **VC = VC + ONE
** @ *** VC = VC + ONE; LN = LN + ONE
** @ ***
** @ *** LINES<-ONE> = LINE
** @ ***
** @ **REPEAT
*
!
*
SVC = ONE; CONT = TRUE
LOOP
*
LINE = EMPTY
*
IF SVC GT FSVC.MAX THEN
IF SVC GT OSVC.MAX THEN
CONT = FALSE
END
END
*
WHILE CONT DO
*
IF SVC = ONE THEN
LINES<-ONE> = HDR2; LN = LN + ONE
END
*
IF SVC LE OSVC.MAX THEN
LINE = LINE:" ":AIL$SVC.ID<ONE,AIX.LOC,SVC> "R#7":" ":AIL$TIERS<ONE,AIX.LOC,SVC> "R#1":" ":AIL$TSTAT<ONE,AIX.LOC,SVC> "R#1"
END ELSE
LINE = LINE:SPACE(12)
END
*
IF SVC LE FSVC.MAX THEN
LINE = LINE:" ":AIL$SVC.ID.FUTR<ONE,AIX.LOC,SVC> "R#7":" ":AIL$TIERS.FUTR<ONE,AIX.LOC,SVC> "R#1":" ":AIL$TSTAT.FUTR<ONE,AIX.LOC,SVC> "R#1"
END ELSE
LINE = LINE:SPACE(12)
END
*
*
SVC = SVC + ONE 
*
LINES<-ONE> = LINE; LN = LN + ONE
*
REPEAT
*
!
*
IF LN THEN
IF LPT.FLAG THEN PRINTER ON
LNS = LNS + LN + ONE
IF LNS > 60 THEN GOSUB HEADING; LNS = LNS + LN + ONE
*
FOR I = ONE TO LN
* IF LPT.FLAG OR LEN(LINES<I>) LE 78 THEN
PRINT LINES<I>
* END ELSE
* PRINT LINES<I>[ONE,78]
* PRINT LINES<I>[69,9999]
* LNS = LNS + ONE
* END
NEXT I
*
PRINT
IF LPT.FLAG THEN PRINTER OFF
END; * of LN
*
* DELETE AIL.FILE,AIL.ID
*
!
*
END; * of change in TRANS.SEQ
*
END; * of READ AIL on file...
*
REPEAT; * for READNEXT loop
*
!
*
IF RSP.FLAG THEN
WRITE RSP.STACK ON COM.FILE,"AI.RSP.STACK"
END
*
*
STOP
!
HEADING: *
PGS = PGS + ONE
LNS = 5
IF LPT.FLAG THEN
PRINT FF:
PRINT CO.NAME "L#40":" ":HEADEND:" Addressable Interface - Handler Log" "L#60":TIMEDATE():"   Page ":PGS
END ELSE
PRINT
PRINT CO.NAME "L#20":" ":HEADEND:" Addr. Intfc. - Log" "L#25":TIMEDATE():" Page ":PGS
END
** @ **PRINT
** @ ***
** @ **PRINT HDR
** @ *** PRINT HDR2
** @ *** PRINT HDR3
** @ **PRINT HDR4
*
PRINT
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:@(ZERO,23):TEXT:" - Hit <cr> to continue ":
TEXT = ""; INPUT RSP:; PRINT @(ZERO,23):CLL:
RETURN
!
END
~AI.PURGE.PPV.EVENTS~
*PROGRAM: AI.PURGE.PPV.EVENTS
* VERSION: 950604 1.2  CHANGED TO PURGE BY SELECT OF PVE ON PVM.ID.
* PRIOR: 940703 1.1  CHANGED TO PURGE BY PURGE DATE ON ITEMS OF EACH FILE.
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:  PURGE PVE ITEMS BY PURGE.DATE OF THE PVM ITEM.
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "(1.2)"
VS = "(1.2)"
*
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CHANNEL.DN"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
*
!
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open PVM":; INPUT RSP; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT "Can't open PVE":; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM":; INPUT RSP; STOP
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
*
READ SYS.TST FROM CNT.FILE,"AI.PURGE.TEST" ELSE SYS.TST = ""
*
TITLE = "Purge PPV Masters and Details":VERSION
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
PVM.CTR = 0; PVE.CTR = 0
!
INPUT A.RUN
IF A.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
PURGE.DT = CURRENT.RUN<1,2>
END ELSE
*
LOOP
PRINT @(0,10):CLS:
PRINT @(10,10):CLL:"Enter the 'prior to' purge date: ":; INPUT PURGE.DT
IF PURGE.DT = "KILL" THEN STOP
CALL GET.ICONV(PURGE.DT,"D")
WHILE PURGE.DT = "" DO REPEAT
*
PURGE.DT = OCONV(PURGE.DT,"D2")
*
CALL AUTO.LOADER("AI.PURGE.PPV.EVENTS",PURGE.DT,"PPV Purge")
END
*
IF NOT(A.RUN) THEN
PRINT @(10,12):"Enter 'KILL' or, <cr> if 'prior to' purge date is OK: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
END
!
EXLN = 'WITH PURGE.DT LT "':PURGE.DT:'"'
* EXECUTE 'SSELECT PVM ':EXLN; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
EXECUTE 'SSELECT PVM ':EXLN, //SELECT. > PVM.ID.LIST
*
*
LOOP
* READNEXT PVM.ID ELSE PVM.ID = "@@@"; * REV ONLY
* ULT ONLY
READNEXT PVM.ID FROM PVM.ID.LIST ELSE PVM.ID = "@@@"
UNTIL PVM.ID = "@@@" DO
*
MATREAD PVM FROM PVM.FILE,PVM.ID ELSE MAT PVM = ""
PVM.CTR = PVM.CTR+1
PRINT @(5,15):"Processing Masters: ":PVM.CTR "R#4":"  ":PVM.ID:"  ":OCONV(PVM$PURGE.DT,"D2"):"  ":PVM$DESC "L#30":
*
*
*
EXLN = 'WITH PVM.ID = "':PVM.ID:'"'
*
* EXECUTE 'SSELECT PVE ':EXLN; * REV ONLY
*
EXECUTE 'SSELECT PVE ':EXLN, //SELECT. > PVE.ID.LIST
*
PVE.CTR = 0
LOOP
* READNEXT PVE.ID ELSE PVE.ID = "@@@"; * REV ONLY
* ULT ONLY
READNEXT PVE.ID FROM PVE.ID.LIST ELSE PVE.ID = "@@@"
UNTIL PVE.ID = "@@@" DO
PVE.CTR = PVE.CTR+1
PRINT @(5,18):"Deleting Event Details: ":PVE.CTR "R#4":"  ":PVM.ID:"  ":PVE.ID:"  ":
*
IF SYS.TST THEN
PRINT CLB:"Enter <cr>: ":; INPUT TMP:
END ELSE
DELETE PVE.FILE,PVE.ID
END
*
REPEAT
*
IF SYS.TST THEN
PRINT CLB:"Enter <cr>: ":; INPUT TMP:
END ELSE
DELETE PVM.FILE,PVM.ID
END
*
PVE.ID = ""
PRINT @(0,17):CLS:
REPEAT
*
!
FINISH: *
STOP
!
END
~AI.RECREATE.AIX~
*PROGRAM:         RECREATE.AIX
* VERSION: 940724 3.1  CHANGED READNEXT TO ELSE AIX.ID = "END".
* PRIOR: 940203 3.0  ADDED AI.CODE, POC PORT NUM, CONN DATE, DISC DATE.
* PRIOR: 930729 2.?  NEW
*  
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1993               ALL RIGHTS RESERVED
*  
* AUTHOR:          H HORSMAN
* DESCRIPTION:     SETS UP AIX INDEX FOR ADDRESSABLE DEVICES
*                  Q POINTERS ARE REQUIRED BY COMPANY FOR:
*                  PAR (DEVICE.TYPES) AND DVC
*                  COM AIX.COS CONTAINS ADDRESSABLE COMPANIES
*                  CNT AIX.CO  CONTAINS ONE COMPANY TO BE PROCESSED.
*
*                  TEST.FLAG IS SET BY CNT 'AIX.TEST'.
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "(3.1)"
VS = "(3.1)"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.AI.RECREATE.AIX"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP DVC.DIM
$INCLUDE IBP DVC.EQUATES
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*
INPUT AUTO.RUN
INPUT RUN.TYPE
*
OPEN "AIX" TO AIX.FILE ELSE TEXT = "Can't open AIX"; GOTO ERROR
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOTO ERROR
OPEN "COM" TO COM.FILE ELSE TEXT = "Can't open COM"; GOTO ERROR
OPEN "ACT" TO ACT.FILE ELSE TEXT = "Can't open ACT"; GOTO ERROR
OPEN "ADD" TO ADD.FILE ELSE TEXT = "Can't open ADD"; GOTO ERROR
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOTO ERROR; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
READ SYS.TST FROM CNT.FILE,"AIX.TEST" ELSE SYS.TST = 0
$INCLUDE IBP SYSTEM.TEST
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE TEXT = "AI Types are not defined"; GOTO ERROR
IF RUN.TYPE THEN
READ COS FROM COM.FILE,"AI.COS" ELSE TEXT = "Can't find COM AI.COS"; GOTO ERROR
RUN.LIT = "All Companies"
END ELSE
READ COS FROM CNT.FILE,"AI.CO" ELSE TEXT = "Can't find CNT AI.CO"; GOTO ERROR
RUN.LIT = COS<2>
END
*
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28-((LEN(CO.NAME)/2)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":
TITLE = "Recreate Addressable Device Index for ":RUN.LIT:VERSION
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
AIX.ERROR = ""; DVC.ID = ""; AIX.ID = ""; DVC.CTR = 0; AIX.CTR = 0; ERR.CTR = 0
AIX.ERRORS = RUNLIT:" - Duplicate Device Serial Numbers detected on ":OCONV(DATE(),"D2")
*
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("RECREATE.AIX","","Index AI Dvcs")
DELETE COM.FILE,"RECREATE.AIX.ERRORS"
!
CO.VC = 1
LOOP CO = COS<2,CO.VC> UNTIL CO = "" DO
*
IF OPSYS = "U" THEN
OPEN "DVC" TO DVC.FILE ELSE TEXT = "Can't open DVC"; GOTO ERROR
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOTO ERROR
END ELSE
OPEN CO:".":"DVC" TO DVC.FILE ELSE TEXT = "Can't open ":CO:".DVC"; GOTO ERROR
OPEN CO:".":"PAR" TO PAR.FILE ELSE TEXT = "Can't open ":CO:".PAR"; GOTO ERROR
END
*
READ DEVICE.TYPES FROM PAR.FILE,"DEVICE.TYPES" ELSE DEVICE.TYPES = ""
CLS.COL = 0; CLS.ROW = 5; GOSUB CLS.ROUTINE
*
PRINT @(10,5):"Clearing prior indexes for ":CO:
PRINT:
EXLN = 'SELECT AIX WITH CO = ':'"':CO:'"'
IF TEST.FL THEN
PRINT @(0,6):CLL:EXLN:
PRINT CLB:"Press 'Enter': ":; INPUT TMP:
END
* ULT ONLY
EXECUTE EXLN, //SELECT. > AIX.ID.LIST
* EXECUTE EXLN; * REV ONLY
LOOP
* ULT ONLY
READNEXT AIX.ID FROM AIX.ID.LIST ELSE AIX.ID = "END"
* READNEXT AIX.ID ELSE AIX.ID = ""; * REV ONLY
UNTIL AIX.ID = "END" DO
DELETE AIX.FILE,AIX.ID
REPEAT
!
CLS.COL = 0; CLS.ROW = 10; GOSUB CLS.ROUTINE
*
PRINT @(10,8):"Selecting devices...":
PRINT
*
IF TEST.FL AND LIST.NAME NE "" THEN
EXECUTE 'GET-LIST ':LIST.NAME
END
EXLN = 'WITH FUNCS = "I"'
* ULT ONLY
EXECUTE 'SELECT DVC ':EXLN, //SELECT. > DVC.ID.LIST
* EXECUTE EXLN; * REV ONLY
*
!
PRINT @(10,12):"Creating Index....":
*
LOOP
UNTIL DVC.ID = "END" DO
MAT AIX = ""
* READNEXT DVC.ID ELSE DVC.ID = "END"; * REV ONLY
*
* ULT ONLY
READNEXT DVC.ID FROM DVC.ID.LIST ELSE DVC.ID = "END"
IF DVC.ID # "END" THEN
*
CUR.ACT.ID = ""; CUR.CO = ""; CUR.CONN.DATE = ""; CUR.DISC.DATE = ""; CUR.AI.CODE = ""; CUR.GROUP = ""
*
MATREAD DVC FROM DVC.FILE,DVC.ID ELSE MAT DVC = ""
DVC.CTR = DVC.CTR+1
*
LOCATE DVC$TYPE IN DEVICE.TYPES<1> SETTING LOC THEN
IF DEVICE.TYPES<5,LOC> = "A" THEN
SERVICE = DVC$SERVICE
*
*
IF DVC$STAT<1,1> EQ "B" OR DVC$STAT<1,1> EQ "I" THEN
*
ACT.ID = DVC$ACT.ID<1,1>
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = ""
*
*
READV ADD.GEO FROM ADD.FILE,DVC$ADD.ID<1,1>,12 ELSE ADD.GEO = ""
HEADEND = FIELD(ADD.GEO,"*",10)
*
AI.CODE = EMPTY
**HEND = ""; VC = 0; SVC = 1
**LOOP
**VC = VC+1; AI.CODE = AI.TYPES<1,VC>
**LOOP HEND = AI.TYPES<4,VC,SVC> UNTIL HEND = "" OR HEND EQ HEADEND DO SVC = SVC+1 REPEAT
**UNTIL AI.CODE = "" OR HEND = HEADEND DO REPEAT
*
$INCLUDE IBP AI.INCL.LOAD.CODE
*
* TEMPORARY 12APR94 IF HEND NE "" THEN
IF AI.CODE EQ EMPTY THEN
***ERROR
PRINT CLB:"Headend ":HEADEND:" not found!":BELL:
END
*
*
CUR.ACT.ID = ACT.ID
LOCATE SERVICE IN ACT$SERVICES<1> BY "AL" SETTING LOC THEN
CUR.CONN.DATE = ACT$SVC.START.DATES<1,LOC,1>
END
*
* THE DEVICE IS PENDING RETURN
IF DVC$STAT<1,1> EQ "I" THEN
IF ACT$ADD.ID = DVC$ADD.ID<1,1> THEN
CUR.DISC.DATE = DVC$EFF.DATE<1,1>
END
END
*
* THE DEVICE IS INSTALLED AND BILLABLE
IF DVC$STAT<1,1> EQ "B" THEN
END
*
*
MATREAD AIX FROM AIX.FILE,DVC.ID THEN
AIX$ERROR = AI.CODE:"  ":CO:"  ":CUR.ACT.ID:"  Conn. ":OCONV(CUR.CONN.DATE,"D2"):"  Disc. ":OCONV(CUR.DISC.DATE,"D2")
CUR.AIX = DVC.ID:"   Current: ":AIX$AI.CODE:"  ":AIX$CO:"   ":AIX$ACT.ID:"  Conn. ":OCONV(AIX$START.DATE,"D2"):"  Disc. ":OCONV(AIX$STOP.DATE,"D2"):"  Duplicate:  "
AIX.ERRORS<-1> = CUR.AIX:AIX$ERROR
IF LEN(AIX.ERRORS) GT 500 THEN GOSUB PRINT.ERRORS
ERR.CTR = ERR.CTR+1
END ELSE
AIX$ACT.ID = CUR.ACT.ID
AIX$CO = CO
AIX$START.DATE = CUR.CONN.DATE
AIX$STOP.DATE = CUR.DISC.DATE
AIX$AI.CODE = AI.CODE
AIX$GROUP = DVC$ADDRESS
AIX$ERROR = ""
AIX.CTR = AIX.CTR+1
END
*
MATWRITE AIX ON AIX.FILE,DVC.ID
*
* TEMPORARY 12APR94 END; * of the address is for an addressable headend
*
END; * of dvc.stat is I or B
*
END; * of dvc is addressable
*
END; * of locate dvc.type
*
PRINT @(5,13+CO.VC):CLL:"Company: ":CO:"  Devices: ":DVC.CTR "R#6":"  Indexed: ":AIX.CTR "R#6":"  Duplicates: ":ERR.CTR "R#6"
*
END; * of not dvc.id = 'END'
*
REPEAT
IF AIX.ERRORS NE "" THEN GOSUB PRINT.ERRORS
CO.VC = CO.VC+1
REPEAT
*
STOP
!
PRINT.ERRORS: *
* IF ERR.CTR THEN
* WRITE AIX.ERRORS ON COM.FILE,"RECREATE.AIX.ERRORS"
CALL PRINTER.ON(STAT)
PRINT AIX.ERRORS<1>
PRINT
PRINT
AC = 2
LOOP PRINT.ERROR = AIX.ERRORS<AC> UNTIL PRINT.ERROR = "" DO
PRINT PRINT.ERROR
PRINT
AC = AC+1
REPEAT
PRINTER OFF
*
* END
*
AIX.ERRORS = ""
RETURN
*
!
$INCLUDE IBP CLS.ROUTINE
!
ERROR:
PRINT CLB:TEXT:". Press 'Enter': ":; INPUT TMP:; STOP
!
END
~AI.RESP.INPUT~
SUBROUTINE AI.RESP.INPUT(PAUSE.CHAR,PAUSE.RESP,PAUSE.TOUT,PAUSE.LINE,INPUT.PACKET,TC.LAST.FL,TC.LAST,OPER,EXP.TM,SYS.PRNT,STAT)
*SUBROUTINE: AI.RESP.INPUT
* VERSION 940828 1.0
* USED BY AI.COMMAND.SENDER
*
* AUTHOR:    DAVID G. HORSMAN
* COMPANY:   WRITTEN FOR AXION COMPUTER SYSTEMS LTD.
*
* DATE RELEASED: ?? DEC 94
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.RESP.INPUT"; SYS.LOCT = EMPTY
*
!
*
* $INCLUDE IBP COM.AIP.DIM
* $INCLUDE IBP COM.AI.DIM
* PAUSE.CHAR   (INCR'S)
* PAUSE.LINE   (INCR'S)
* PAUSE.RESP   (SEC.S)
!
* $INCLUDE IBP COM.AIP.EQUATES
* $INCLUDE IBP COM.AI.EQUATES
*
* $INCLUDE IBP AI.ERR.VAR.EQUATES
*
* $INCLUDE IBP AI.STATUS.VAR.EQUATES
*
* $INCLUDE IBP CNT.TST.DIM
* $INCLUDE IBP CNT.TST.EQUATES
*
*
* IF CNT.TST$LBL THEN PRINT @(ZERO,23):RVB:" * Subroutine AI.RESP.INPUT * ":RVE
*
!
*
* DT = DATE(); TM = TIME()
* PAUSE.CN.MAX = COM.AI$PAUSE.CHAR
PAUSE.CN.MAX = PAUSE.CHAR
* TC.LAST.FL = FALSE; TC.LAST = EMPTY
* SEND.STATUS = FALSE; SEND.CN = ZERO
COM.AI.MIN.PKT = 6
* PAUSE.RESP.MAX = COM.AI$PAUSE.RESP
PAUSE.RESP.MAX = PAUSE.RESP
COM.AI.MAX.BUF = 10
*
*
* RECEIVE RESPONSE FROM COM.AI$DB.PREFIX DEVICE
*
* IF CNT.TST$LBL THEN PRINT CLL:RVB:"Receiving Response From Headend . . . ":RVE
* ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY; TC.CHAR = EMPTY
*
*
* Process any characters that are available
*
* LOOP
*
* IF CNT.TST$LBL THEN PRINT CLL:RVB:"Wait for characters in buffer":RVE
*
* WAIT FOR CHARACTERS IN THE BUFFER
** ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY; TC.CHAR = EMPTY
PAUSE.CN1 = 0
* PAUSE.CN.MAX1 = COM.AI$PAUSE.LINE
PAUSE.CN.MAX1 = PAUSE.LINE
IF PAUSE.CN.MAX1 LT 100 THEN PAUSE.CN.MAX1 = 100
TC.CONT = TRUE; TC.CONT1 = FALSE
STM = TIME(); QSTM = STM; ETM = ZERO; QTM = ZERO
WSTM = STM; WTM = ZERO
ECHO OFF
IF TC.LAST.FL THEN
PRINT TC.LAST:; TC.LAST.FL = FALSE
END
*
*
LOOP
*
TC.END.SYS11 = SYSTEM(11)
*
IF TC.END.SYS11 THEN
*
* Input characters that are waiting
*
TC.CHAR = EMPTY
LOOP
* ULT ONLY
FOR A = ONE TO TC.END.SYS11 UNTIL TC.CHAR EQ CR
* REV ONLY
* FOR A = ONE TO 200 UNTIL TC.CHAR EQ EMPTY OR TC.CHAR EQ CR
TC.CHAR = EMPTY
* ULT ONLY
TC.CHAR = OCONV(TC.CHAR,"U51EA")
* REV ONLY
* INPUT TC.ONE:
* * REV ONLY
* * INPUT TC,ONE:-
IF TC.CHAR NE CR THEN
INPUT.PACKET = INPUT.PACKET:TC.CHAR
END
NEXT A
TC.END.SYS11 = SYSTEM(11)
* ULT ONLY
UNTIL NOT(TC.END.SYS11) OR TC.CHAR EQ CR DO REPEAT
* REV ONLY
* UNTIL TC.CHAR EQ EMPTY OR TC.CHAR EQ CR DO REPEAT
*
*
*
QSTM = ZERO; QTM = ZERO; ETM = ZERO
*
*
END ELSE
*
* No character waiting
*
*
CTM = TIME()
IF NOT(QSTM) THEN QSTM = CTM
ETM = ABS(CTM - STM)
QTM = ABS(CTM - QSTM)
WTM = ABS(CTM - WSTM)
*
*
END; * of SYS11
*
*
*
*
WHILE TC.END.SYS11 OR (INPUT.PACKET EQ EMPTY AND ETM LE PAUSE.RESP.MAX) OR (INPUT.PACKET NE EMPTY AND QTM LE PAUSE.RESP.MAX / 4) DO
*
PAUSE.CN1 = PAUSE.CN1 + ONE
* IF CNT.TST$LBL THEN PRINT CLL:RVB:"Process more buffered response/characters":RVE
*
REPEAT
*
ECHO ON
* TC.CONT means packet CR has been received
*
RETURN
*
END
~AI.SEND.WKO~
*PROGRAM: AI.SEND.WKO
* VERSION 910814 REV
* PRIOR: 901120 NEW
* DESCRIPTION:     SEND SCHEDULED AI WORK ORDERS TO THE INTERFACE
*                  RUN.TYPE IS INPUT FROM MENU:
*                    1 = NO MONITORING
*                    2 = MONITORING BY OPERATOR
*                        WITH OPTIONS BY WORK ORDER:
*                             E = End processing
*                             N = Go to next Work Order
*                          <cr> = Process the Work Order
* COPYRIGHT:       AXION COMPUTER SYSTEMS LTD.
*   1990               ALL RIGHTS RESERVED
!
$INCLUDE IBP GENERAL.COMMON.AREA
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "(2.7)"
VS = "(2.7)"
*
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SEND.WKO"; SYS.LOCT = EMPTY
SYS.PRNT = EMPTY
*
!
*
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP WKO.EQUATES
$INCLUDE IBP STT.EQUATES
$INCLUDE IBP WOT.DIM
$INCLUDE IBP WOT.EQUATES
*
OPEN "ACG" TO ACG.FILE ELSE PRINT "Can't open file ACG"; INPUT RSP; STOP
OPEN "AIX" TO AIX.FILE ELSE PRINT "Can't open file AIX"; INPUT RSP; STOP
OPEN "ASH" TO ASH.FILE ELSE PRINT "Can't open file ASH"; INPUT RSP; STOP
OPEN "ATR" TO ATR.FILE ELSE PRINT "Can't open file ATR"; INPUT RSP; STOP
OPEN "ATH" TO ATH.FILE ELSE PRINT "Can't open file ATH"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "DLQ" TO DLQ.FILE ELSE PRINT "Can't open file DLQ"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT "Can't open file ADD"; INPUT RSP; STOP
OPEN "ACT" TO ACT.FILE ELSE PRINT "Can't open file ACT"; INPUT RSP; STOP
OPEN "EFT" TO EFT.FILE ELSE PRINT "Can't open file EFT"; INPUT RSP; STOP
OPEN "WKO" TO WKO.FILE ELSE PRINT "Can't open file WKO"; INPUT RSP; STOP
OPEN "RTE" TO RTE.FILE ELSE PRINT "Can't open file RTE"; INPUT RSP; STOP
OPEN "STT" TO STT.FILE ELSE PRINT "Can't open file STT"; INPUT RSP; STOP
OPEN "SVC" TO SVC.FILE ELSE PRINT "Can't open file SVC"; INPUT RSP; STOP
OPEN "SVS" TO SVS.FILE ELSE PRINT "Can't open file SVS"; INPUT RSP; STOP
OPEN "TPL" TO TPL.FILE ELSE PRINT "Can't open file TPL"; INPUT RSP; STOP
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = -3
MAT ACG = ""; LAST.AI.SEND.WKO = ""
*
INPUT AUTO.RUN
IF AUTO.RUN THEN READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
*
READ SYS.TST FROM CNT.FILE,"SYSTEM.TEST" ELSE SYS.TST = 0
$INCLUDE IBP SYSTEM.TEST
*
START.ID = ""; HIT = 1; OP.TALK = ""; SEND.ERROR = 0; SELECTED = 0
GOOD.SEND = 0; FAIL.SEND = 0; PROCESSED = 0; COMPLETED = 0; OVER = 0
CANCELLED = 0; PREVIOUS = 0; BYPASSED = 0; LEFTOVER = 0; ITEM.LOCKED = 0
*** VERSION = " (R:2.7)"; REMAINING = 0
*
MATREAD WOT FROM PAR.FILE,"WORK.ORDER.TYPES" ELSE MAT WOT = ""
READ TROUBLE.CODES FROM PAR.FILE,"TROUBLE.CODES" ELSE TROUBLE.CODES = ""
READ OUTCOME.CODES FROM PAR.FILE,"OUTCOME.CODES" ELSE OUTCOME.CODES = ""
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = ""
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DT = CO.DATA<2,1,1>
READ LAST.SEND FROM CNT.FILE,"LAST.AI.SEND.WKO" ELSE LAST.SEND = ""
LAST.SEND.DATE = LAST.SEND<1>
LAST.SCH.DATE = LAST.SEND<2>
LAST.SEND.STATUS = LAST.SEND<3>
LAST.SEND.SELECTED = LAST.SEND<4>
LAST.SEND.CANCELLED = LAST.SEND<5>
LAST.SEND.FAILED = LAST.SEND<6>
LAST.SEND.GOOD = LAST.SEND<7>
IF LAST.SEND.SELECTED THEN REMAINING = LAST.SEND.SELECTED-LAST.SEND.GOOD-LAST.SEND.CANCELLED
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Send Scheduled Work Orders to the Addressable Interface"
TITLE = TITLE:VERSION; IF TEST.FL THEN TITLE = TITLE:" ** TEST MODE **"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
IF NOT(AUTO.RUN) THEN INPUT RUN.TYPE
!
START: *
IF NOT(AUTO.RUN) THEN
PRINT @(0,2):CLS
IF RUN.TYPE = 2 THEN
TITLE.B = "With Progress Monitoring"
PRINT @(0,2):(SPACE(40-LEN(TITLE.B)/2):TITLE.B) "L#80":RVE:
END
*
PRINT @(9,6):CLL:"The last run was on  ":OCONV(LAST.SEND.DATE,"D2"):"  for Schedule Date  ":OCONV(LAST.SCH.DATE,"D2"):
IF REMAINING THEN
PRINT @(5,8):CLL:"*** WARNING!  All work orders were not completed in the last session ***":
PRINT @(13,9):CLL:"The number of Work Orders remaining to be processed is ":REMAINING:
PRINT @(6,11):CLL:"The uncompleted orders will be included with your new Schedule Date.":
LOOP
PRINT @(15,13):CLL:"Enter KILL to end or <cr> to proceed: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
UNTIL TMP = "" DO PRINT BELL: REPEAT
LINE = "Enter NEW schedule date or <cr> to process LAST schedule date: "
END ELSE
LINE = SPACE(12):"Enter the schedule date to be processed: "
END
*
LOOP
PRINT @(3,15):CLL:LINE:
INPUT SCH.DATE:
IF SCH.DATE = "KILL" THEN STOP
IF REMAINING THEN IF SCH.DATE = "" THEN SCH.DATE = OCONV(LAST.SCH.DATE,"D2")
CALL GET.ICONV(SCH.DATE,"D")
WHILE SCH.DATE = "" DO PRINT BELL: REPEAT
PRINT @(66,15):CLL:OCONV(SCH.DATE,"D2"):; SD = SCH.DATE
*
PRINT @(10,17):CLL:"Please enter your operator code: ":
OPER = ""
CALL INPUT.DATA(OPER,46,17,3,"1,,,*1","","EQ":SVM:"@":OPERATORS:"@","",RSP,STAT)
IF STAT = 999 THEN STOP 
LOCATE OPER IN OPERATORS BY "AL" SETTING LOC ELSE NULL
IF LOC THEN OPER.NAME = OPERATORS<2,LOC> ELSE OPER.NAME = ""
PRINT @(50,17):CLL:OPER.NAME:
OPER.NAME = "by ":OPER.NAME
*
LOOP
PRINT @(15,19):CLL:"Enter A(bandon) or <cr> to commence: ":
INPUT RSP:; IF RSP = "A" OR RSP = "KILL" THEN STOP
UNTIL RSP = "" DO PRINT BELL: REPEAT
*
IF RUN.TYPE = 1 THEN CALL AUTO.LOADER("AI.SEND.WKO",SCH.DATE,"Send AI WKOs")
END ELSE
RUN.TYPE = 1
SCH.DATE = CURRENT.RUN<1,2>
OPER = CURRENT.RUN<1,3>
END
PRINT @(0,3):CLS
IF RUN.TYPE = 2 THEN PRINT @(0,3):(SPACE(40-LEN(OPER.NAME)/2):OPER.NAME) "L#80":RVE:
TOTAL.LINE = "for Schedule Date ":OCONV(SCH.DATE,"D2")
!
RESELECT: *
IF SCH.DATE NE LAST.SCH.DATE THEN
EXLN = 'DELETE-LIST ':"AI*":LAST.SCH.DATE
LAST.AI.SEND.WKO = ""
PRINT @(0,22):
EXECUTE EXLN
END
*
*****  CHECK IF PREVIOUSLY SELECTED
*
LIST.NAME = "AI*":SCH.DATE
PRINT @(0,22):
EXLN = "GET-LIST ":LIST.NAME
* ULT ONLY
EXECUTE EXLN, //SELECT. > WKO.ID.LIST
* EXECUTE EXLN; * REV ONLY
* IF TEST.FL THEN PRINT CLB:@LAST.ERROR<2>:" ":@LAST.ERROR:; INPUT TMP:; * REV ONLY
*
*****  DO A NEW SELECT BECAUSE NOT PREVIOUSLY SELECTED
*
* IF @LAST.ERROR = "202" THEN; * REV ONLY
* ULT ONLY
IF WKO.ID.LIST = "" THEN
CLS.COL = 10; CLS.ROW = 13; GOSUB CLS.ROUTINE
PRINT "Selecting ":OCONV(SCH.DATE,"D2"):" work orders for processing...":
PRINT @(0,22):
*
* REV SELECT
*
* EXECUTE 'SSELECT WKO WITH SCH.TYPE = "AI" AND WITH NO PRINT.DATE AND WITH STAT = "P" AND WITH SCH.DATE AND WITH SCH.DATE <= "':OCONV(SCH.DATE,"D2"):'"'; * REV ONLY
* IF @LAST.ERROR = 401 THEN PRINT CLB:"There were no Work Orders to be processed":; STOP; * REV ONLY
* IF TEST.FL THEN PRINT CLB:@LAST.ERROR<2>:" ":@LAST.ERROR:; INPUT TMP:; * REV ONLY
*
* ULT/MDD SELECTS
*
* ULT ONLY
EXECUTE 'SSELECT WKO WITH SCH.TYPE = "AI" AND WITH STAT # "C""X" AND WITH NO PD AND WITH SD AND WITH SD <= "':OCONV(SD,"D2"):'" ', //SELECT. > WKO.ID.LIST
*%%MDD%%=PRINT
*%%MDD%%=PRINT SEL.ERROR
*
*****  THERE WERE NO ORDERS FOR THE SCH.DATE ENTERED
*
* IF @LAST.ERROR = "202" THEN; * REV ONLY
* ULT ONLY
IF WKO.ID.LIST = "" THEN
IF AUTO.RUN THEN STOP
PRINT CLB:"There are no Work Orders for ":OCONV(SCH.DATE,"D2"):". Enter <cr> ":; INPUT TMP:; STOP
END
*
*****  SAVE THE SELECTED WORK ORDERS
*
EXECUTE "SAVE-LIST AI*":SCH.DATE
END
PRINT @(0,22):
*
*****  GET THE SAVED WORK ORDER LIST
*
* ULT ONLY
EXECUTE "GET-LIST AI*":SCH.DATE, //SELECT. > WKO.ID.LIST
* EXECUTE "GET-LIST AI*":SCH.DATE; * REV ONLY
* IF TEST.FL THEN PRINT CLB:@LAST.ERROR<2>:" ":@LAST.ERROR:; INPUT TMP:; * REV ONLY
*
IF NOT(AUTO.RUN) AND RUN.TYPE = 2 THEN
LOOP
PRINT @(5,10):CLL:"Enter a starting Work Order no. or <cr> for the 1st Work Order: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
IF TMP = "" THEN HIT = 1 ELSE HIT = 0
IF TMP NE "" THEN START.ID = TMP; TMP = ""
UNTIL TMP = "" DO PRINT BELL: REPEAT
END
!
LOOP
NEXT.WKO: *
* ULT ONLY
READNEXT WKO.ID FROM WKO.ID.LIST ELSE OVER = 1
* READNEXT WKO.ID ELSE OVER = 1; * REV ONLY
UNTIL OVER DO
SELECTED = SELECTED+1
IF START.ID NE "" THEN IF WKO.ID = START.ID THEN HIT = 1
IF NOT(HIT) THEN BYPASSED = BYPASSED+1; GOSUB NOT.DONE ELSE
* LOOP
CALL SYS.ITM.LCK("WKO",WKO.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
* WHILE LCK.STAT DO REPEAT
IF LCK.STAT GT 0 THEN ITEM.LOCKED = ITEM.LOCKED+1 ELSE
MATREAD WKO FROM WKO.FILE,WKO.ID THEN
IF DIS.ITEM THEN PRINT CLB:"Processing WKO: ":WKO.ID:; INPUT TMP:
IF WKO$STAT = "C" THEN PREVIOUS = PREVIOUS+1; GOSUB NOT.DONE ELSE
IF WKO$STAT = "X" THEN CANCELLED = CANCELLED+1; GOSUB NOT.DONE ELSE
LOCATE WKO$TYPE IN WOT$TYPE<1> SETTING LOC THEN WOF = WOT$FUNC<1,LOC> ELSE WOF = ""
*
ACT.ID = WKO$ACT.ID
* LOOP
CALL SYS.ITM.LCK("ACT",ACT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","B","",LCK.STAT)
* WHILE LCK.STAT DO REPEAT
IF LCK.STAT THEN ITEM.LOCKED = ITEM.LOCKED+1; GOSUB NOT.DONE
IF NOT(LCK.STAT) THEN
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = ""
PEND.WO.NUMS = ACT(47)
ADD.ID = ACT$ADD.ID
* LOOP
CALL SYS.ITM.LCK("ADD",ADD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","C","",LCK.STAT)
* WHILE LCK.STAT DO REPEAT
IF LCK.STAT THEN ITEM.LOCKED = ITEM.LOCKED+1 ELSE
MATREAD ADD FROM ADD.FILE,ADD.ID ELSE MAT ADD = ""
MATREAD EFT FROM EFT.FILE,ACT.ID ELSE MAT EFT = ""
MATREAD DLQ FROM DLQ.FILE,ACT.ID ELSE MAT DLQ = ""
MATREAD ASH FROM ASH.FILE,ACT.ID ELSE MAT ASH = ""
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = ""
AIX.ID = FIELD(ADD$OP.ID,"*",1):"*":FIELD(ADD$OP.ID,"*",2); OP.TALK<1> = FIELD(ADD$OP.ID,"*",3)
TPL.ID = ADD$DROP
IF ADD$LINE # "" THEN TPL.ID = TPL.ID:"/":ADD$LINE
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
*
IF RUN.TYPE = 2 THEN
CALL DISPLAY.BACKGROUND; CALL DISPLAY.BASIC.DATA
SERVICE.TOP = ""; CALL DISPLAY.SERVICES
CALL DISPLAY.WORK.ORDER.DETAIL(MAT WOT)
PRINT CLB:"Count: ":SELECTED:". Enter E(nd), N(ext WKO), or <cr> to proceed: ":; INPUT TMP:
END
IF TMP = "E" THEN
LEFTOVER = LEFTOVER+1
LOOP
* ULT ONLY
READNEXT WKO.ID FROM WKO.ID.LIST ELSE OVER = 1
* READNEXT WKO.ID ELSE OVER = 1; * REV ONLY
UNTIL OVER DO
LEFTOVER = LEFTOVER +1; SELECTED = SELECTED+1
REPEAT
END ELSE
IF TMP = "N" THEN BYPASSED = BYPASSED+1; GOSUB NOT.DONE ELSE
BEGIN CASE
CASE WOF = "R"; * RECONNECT
CASE WOF = "D"; * DISCONNECT
CASE WOF = "S"; * SERVICE CHANGE
CASE 1; PRINT CLB:"Not a valid WO type.":; INPUT TMP:; STOP
END CASE
IF RUN.TYPE = 1 THEN OPA = 81 ELSE OPA = 82
IF RUN.TYPE = 1 THEN OP.STAT = 1 ELSE OP.STAT = 0
NEW.ADD = ""; OP.RSLT = OPER; PRIOR.ADD.ID = ""; PRIOR.TNT.ID = ""
CALL AI.TALKER(OPA,OP.RSLT,OP.STAT,WOF,SYS.PROG)
IF NOT(OP.TALK<11>) THEN
FAIL.SEND = FAIL.SEND+1
END ELSE
GOOD.SEND = GOOD.SEND+1
END
IF TEST.FL THEN PRINT CLB:WKO.ID:" ":WKO$STAT:" ":WKO$SCH.TYPE:" ":OCONV(WKO$SCH.DATE,"D2"):" ":WKO$TYPE:; INPUT TMP:
END
END
CALL SYS.ITM.RLS("WKO",WKO.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","D","",LCK.STAT)
CALL SYS.ITM.RLS("ADD",ADD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","E","",LCK.STAT)
CALL SYS.ITM.RL
CALL SYS.ITM.RLS("ACT",ACT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","F","",LCK.STAT)
END
GOSUB NOT.DONE
END
END
END
END
END
END
REPEAT
IF OVER THEN
GOSUB FINISH; STOP
END
!
NOT.DONE: *
IF DIS.ITEM = 2 THEN PRINT CLB:"WKO ":WKO.ID:" not processed.":; INPUT TMP:
RETURN
!
FINISH: *
PRINT @(0,1):RVB:(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
IF RUN.TYPE = 2 THEN
PRINT @(0,2):(SPACE(40-LEN(TITLE.B)/2):TITLE.B) "L#80":RVE:
IF RUN.TYPE = 2 THEN PRINT @(0,3):CLS:(SPACE(40-LEN(OPER.NAME)/2):OPER.NAME) "L#80":
PRINT @(15,5):CLL:"Processing completed":" ":TOTAL.LINE
PRINT @(19,7):CLL:"Not processed:":
LN = 8
IF PREVIOUS GT 0 THEN PRINT @(21,LN):CLL:"Bypassed, already completed   ":PREVIOUS "R#6":; LN = LN+1
IF BYPASSED GT 0 THEN PRINT @(21,LN):CLL:"Bypassed by the operator      ":BYPASSED "R#6":; LN = LN+1
IF CANCELLED GT 0 THEN PRINT @(21,LN):CLL:"Cancelled prior to processing ":CANCELLED "R#6":; LN = LN+1
IF ITEM.LOCKED GT 0 THEN PRINT @(21,LN):CLL:"Locked by another operator    ":ITEM.LOCKED "R#6":; LN = LN+1
PRINT @(21,LN):CLL:"Total not processed           ":(PREVIOUS+BYPASSED+CANCELLED "R#6"):"*":; LN = LN+1
LN = LN+1; PROCESSED = FAIL.SEND+GOOD.SEND
IF PROCESSED GT 0 THEN PRINT @(19,LN):CLL:"Processed:":; LN = LN+1
IF FAIL.SEND GT 0 THEN PRINT @(21,LN):CLL:"Interface processing failed   ":FAIL.SEND "R#6":; LN = LN+1
* IF SUSPEND.CTR GT 0 THEN PRINT @(21,LN):CLL:"Further action suspended      ":SUSPEND.CTR "R#6":; LN = LN+1
IF GOOD.SEND GT 0 THEN PRINT @(21,LN):CLL:"Successfuly processed         ":GOOD.SEND "R#6":; LN = LN+1
IF PROCESSED GT 0 THEN PRINT @(21,LN):CLL:"Total processed               ":PROCESSED "R#6":"*":; LN = LN+1
IF LEFTOVER GT 0 THEN LN = LN+1; PRINT @(19,LN):CLL:"Remaining to be processed       ":LEFTOVER "R#6":"*":
END
*
IF START.ID AND NOT(HIT) THEN
PRINT CLB:"Your starting Work Order number of ":START.ID:" was not found. Enter <cr>":; INPUT TMP:
PRINT @(0,4):CLS:
BYPASSED = 0; START.ID = ""; GOTO RESELECT
END ELSE
LOOP
CALL SYS.ITM.LCK("PAR","LAST.AI.SEND.WKO",LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","G","",LCK.STAT)
WHILE LCK.STAT DO
PRINT @(0,22):CLL:"You must unlock PAR file - item ":LAST.AI.SEND.WKO:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
IF LAST.AI.SEND.WKO NE "" THEN READ LAST.AI.SEND.WKO FROM CNT.FILE,"LAST.AI.SEND.WKO" ELSE LAST.AI.SEND.WKO = ""
TMP = LAST.AI.SEND.WKO
TMP<1> = DATE()
TMP<2> = SCH.DATE
IF NOT(FAIL.SEND) THEN TMP<3> = 0 ELSE TMP<3> = 1
TMP<4> = SELECTED
TMP<5> = TMP<5>+CANCELLED
TMP<6> = FAIL.SEND
TMP<7> = TMP<7>+GOOD.SEND
WRITE TMP ON CNT.FILE,"LAST.AI.SEND.WKO"
* CALL UNLCK.ITEM(CNT.FILE,"CNT","LAST.AI.SEND.WKO",LCK.FILE); * REV ONLY
* CALL SYS.ITM.RLS("CNT","LAST.AI.SEND.WKO",LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","H","",LCK.STAT)
* ULT ONLY
RELEASE CNT.FILE,"LAST.AI.SEND.WKO"
PRINT CLB:"Enter <cr>...":; INPUT TMP:
END
*
RETURN
!
$INCLUDE IBP CLS.ROUTINE
!
$INCLUDE IBP GET.TEST.ITEM
END
~AI.SET.DT.TM.DAY.PA~

~AI.SET.TRANS.SEQ.PA~
*PROGRAM: AI.SET.TRANS.SEQ.PA
* VERSION: 940614 1.1  SET SEQ TO 0001 NOT 0000
* PRIOR: 940331 1.0  NEW
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
* DESCRIPTION:  SET THE TRANS SEQ ON THE POC TO CURRENT OR NEW SEQ NUM.
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(1.0)"
VS = "(1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SET.TRANS.SEQ.PA"; SYS.LOCT = EMPTY
SYS.PRNT = EMPTY
*
!
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:; STOP
* LCK.FILE = 0; * REV ONLY
!
*
REDISP = FALSE; STAT = FALSE
$INCLUDE IBP AI.ERR.INIT
*
AI.TALK = EMPTY
DISP.ONLY = FALSE; MSG.DISP = FALSE; DO.PROMPT = TRUE
LCK.TYPE = -8; LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.STAT = FALSE
TRANS.NUM = ""
COM.AI.ERR.DISP = 2
ERR.DISP.ONLY = 3
*
LN = 3; CHECK.LN.MIN = 14; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
OPT.COMM = ""; CHECK.LEN = 49; CHECK.LN.HI = ZERO
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
LAST.PVM.ID =""; MASTER.CTR = 0; CHAN.ALL = FALSE; OPER = ""
*
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "S"; LOG.REQUIRED = FALSE
MAT COM.AIHERR = ""
*
!
*
GOSUB LOAD.TST
IF CNT.TST$ON THEN VS = VS:" **** TEST MODE ****"
FAST.DISPLAY = FALSE; PORTS.LIST.BUILD = 9; AI.SCAN = TRUE
*
IF CNT.TST$RTN THEN PRINT @(60,20):"AI.SET.TRANS.SEQ.PA" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.NAME = "Unknown"
CO.NAME = CO.DATA<1>
*
OVER = FALSE; DETAIL.CTR = 0; ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
*
VALID.CTR = 0; UPLOAD.DATE = DATE()
*
PRINT @(0,0):CLS:
TITLE = "Set the Transaction Sequence Number on the POC ":VS
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
IF CNT.TST$X THEN
PRINT @(18,LN):"*** TEST MODE - Interface will be bypassed ***"; LN = LN+2
END ELSE
PRINT @(10,4):"Downloading thru the Interface.":
END
!
GET.INPUT: *
*
LN = 5
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
IF NOT(COUNT(AI.TYPES<1>,VM)) THEN AI.CODE = AI.TYPES<1> ELSE AI.CODE = ""
*
LOOP
IF AI.CODE = "" THEN PRINT @(10,LN):CLL:"Enter the Addressable Interface Code: ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP
LCK.ITM = FALSE; LCK.RELS = TRUE
GOSUB READ.COM.AI
IF NOT(COM.AI.ON.FILE) THEN 
AI.CODE = ""
MSG.P = "That Addressable Interface has not been defined. Enter <cr>: "; GOSUB DISPLAY.PROMPT
END
UNTIL AI.CODE NE "" DO REPEAT
IF AI.ERROR AND NOT(CNT.TST$X) THEN
PRINT @(10,LN+2):"The AI is ":COM.AI$ON.OFF.STAT:" and ":COM.AI$UP.DN.STAT:"  Do want to try another AI? (Y/<cr>): ":; INPUT RESP:
AI.ERROR = 0
IF RESP = "Y" THEN PRINT @(10,LN):CLL:; RESP = ""; AI.CODE = ""; GOTO GET.INPUT
STOP
PRINT @(10,LN+2):CLL:
END
*
LCK.ITM = TRUE; LCK.RELS = TRUE
COMMPORT = COM.AI$COMMPORT; COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY
*
LOCATE AI.CODE IN AI.TYPES<1> BY "AL" SETTING LOC THEN AI.DESC = AI.TYPES<2,LOC>
PRINT @(10,LN):AI.DESC:
LN = LN+2
*
* LOOP
*
LOOP
CALL SYS.ITM.LCK("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
*
READ NEXT.TRANS.NUM FROM COM.FILE,"AI.NEXT.TRANS.":AI.CODE ELSE NEXT.TRANS.NUM = "0001"
PRINT @(0,LN):CLL:"Current Transaction Number of ":NEXT.TRANS.NUM:" will be reset to '0001'":
* INPUT NEXT.TRANS.NUM:
* IF NEXT.TRANS.NUM = "KILL" THEN STOP
* IF NOT(NUM(NEXT.TRANS.NUM)) THEN NEXT.TRANS.NUM = ""
* WHILE NEXT.TRANS.NUM EQ "" DO REPEAT
*
NEXT.TRANS.NUM = ("0001") "R#4"
*
CALL SYS.ITM.RLS("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","B","",LCK.STAT)
*
LOOP
PRINT @(10,20):"Enter <cr> to proceed or 'KILL' to end: ":; INPUT RESP:
IF RESP = "KILL" THEN GOTO FINISH
UNTIL RESP = "" DO PRINT BELL: REPEAT
*
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
TRANS.TYPE = "SEQ"; OPT.COMM<ONE> = TRANS.TYPE; HANDLER.COMMAND = OPT.COMM<ONE>
OPT.PORT = PORT.KEY; OPT.DT = DATE(); OPT.TM = TIME(); AI.TALK = ""
MAT COM.AIP = ""; COM.AIP$INTFC.STAT = ""; COM.AIP$ERR = ""
*
$INCLUDE IBP AI.LOAD.COM.AIP
*
COM.AIP$SVC.FUNC = "SEQ"
COM.AIP$DVC.TYPE = AI.CODE
COM.AIP$TRAN.SEQ = NEXT.TRANS.NUM
*
AI.DVC.NEXT.CN = ONE
COM.ID = "AI*":AI.CODE:"*":PORT:"*":AI.DVC.NEXT.CN
GOSUB WRITE.COMMAND
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND
END
*
$INCLUDE IBP AI.INCL.UPDT.COM.AIP
*
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*
LOOP
LCK.STAT = LCK.TYPE
CALL SYS.ITM.LCK("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","C","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
NEXT.TRANS.NUM = ("0001") "R#4"
WRITE NEXT.TRANS.NUM ON COM.FILE,"AI.NEXT.TRANS.":AI.CODE
CALL SYS.ITM.RLS("COM","AI.NEXT.TRANS.":AI.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","D","",LCK.STAT)
MSG.P = "The setting was successful. Enter <cr>: "; GOSUB DISPLAY.PROMPT
*
END ELSE
*
* FOR TMP = 1 TO 65
* PRINT COM.AIP(TMP)
* NEXT TMP
MSG.P = "The setting was not successful (":AI.STATUS:",":SEND.STATUS:"). Enter <cr>: "; GOSUB DISPLAY.PROMPT; GOTO GET.INPUT
*
END
*
!
*
FINISH: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Finish" "L#19":; IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:
*
*
STOP
!
READ.COM.AI: *
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai" "L#19":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:
*
COM.AI.ID = "AI.TYPE.":AI.CODE
*
$INCLUDE IBP AI.READ.COM.AI
*
IF NOT(COM.AI$ON.OFF = "ON" AND COM.AI$UP.DN.STAT = "UP") THEN
AI.ERROR = 1
END ELSE AI.ERROR = 0
RETURN
!
WRITE.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Write Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*
* @@@ COM.AIP REC LOAD
*
DT = DATE(); TM = TIME(); HEADEND = ""
LCK.ITM = TRUE; LCK.RELS = TRUE; STAT = ZERO
*
LOOP
GOSUB READ.COM.AI; * : @
LCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND LCK.STAT NE 998 AND LCK.ELP LE 60 DO REPEAT
*
IF LCK.STAT EQ 998 THEN
MSG.P = "Transaction cancelled - Interface info missing! Enter <cr>: "
END ELSE
IF LCK.STAT THEN
MSG.P = "Transaction cancelled - Interface locks error!! Again (Y/<cr>): "
END
END
IF LCK.STAT THEN
GOSUB DISPLAY.PROMPT
IF RSP EQ "Y" THEN STAT = FALSE; GOTO WRITE.COMMAND
AI.STATUS = LCK.STAT; STAT = 999
END
*
IF NOT(STAT) THEN
*
*
*
CALL AI.SUBR.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,1,SYS.PROG,STAT)
*
END; * OF NOT STAT
*
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:PORT.KEY
END
*
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
*
LCK.ITM = TRUE; LCK.RELS = TRUE
GOSUB READ.COM.AI.UNLOCK
*
RETURN
!
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT CLB:"WAIT FOR COMMAND":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*INCLUDE IBP AI.INCL.WAITFOR.COMMAND
CALL AI.SUBR.WAITFOR.COMMAND(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
*
RETURN
!
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
DISPLAY.PROMPT: * DISPLAY MSG AND PROMPT 'ENTER <cr>' IF DO.PROMPT
LOOP
PRINT CLB:MSG.P:; IF DO.PROMPT THEN INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
PRINT CLB:; MSG.P = ""; DO.PROMPT = 1
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
!
END
~AI.SUBR.INTFC.CHECK~
SUBROUTINE AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,CHECK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PRNT,STAT)
*PROGRAM: AI.SUBR.INTFC.CHECK
*
*              Eagle addressable interface HANDLER.
*    __________
*
*
*INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
* System Info
EQU VERSION TO "920409 NEW"
VS ="920409 NEW (1.0)"
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.INTFC.CHECK"; SYS.LOCT = EMPTY
OPER = ""
SYS.APPL.LOC = ONE
* * * AUTO.RUN = FALSE; REDISP = FALSE; STAT = FALSE
*
!
*
* * * ! Input Parameters
* * * *
* * * INPUT COMMPORT:
* * * LOOP WHILE LEN(COMMPORT) LT 3 DO COMMPORT = ZERO:COMMPORT REPEAT
* * * *
*
! System Control
*
*
* * * PORTS.LIST.BUILD = 9; 
* * * PORTS.LIST = EMPTY; 
* * * PORTS.LIST.PREV = EMPTY
PORT.CONT = FALSE; 
* * * PORT.KEY = PORT; *
* * * FAST.DISPLAY = FALSE
* * * LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
PORT.NUM = PORT.KEY
LOOP WHILE LEN(PORT.NUM) LT 3 DO PORT.NUM = "0":PORT.NUM REPEAT
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
*
* * * LCK.TYPE = -5
* * * LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.STAT = LCK.TYPE
*
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
* Control Flags
* $INCLUDE IBP TST.VAR.EQUATES
* EQU TST$AM TO 12, TST$VM TO 9
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
* IF SYS.TST EQ EMPTY THEN
* READ SYS.TST FROM COM.FILE,"SYSTEM.TEST" ELSE SYS.TST = ""
* END
* * * CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
* * * GOSUB LOAD.TST
*
SYS.LOCT = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*SYS.LOCT = "?"; IF CNT.TST$LBL THEN PRINT @(60,20):(SYS.LOCT:" ?") "L#18":; IF CNT.TST$CR THEN INPUT TMP:
* * * CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
*
*
! Application Records
SYS.LOCT = "AR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Records" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
COM.ID = EMPTY; * ???
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
* * * MAT COM.AI = EMPTY; COM.AI.ID = EMPTY
* * * COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY; COM.AI.ERR.TYPE = EMPTY
* * * COM.AI.ERR.FUNC = EMPTY; COM.AI.ERR.DISP = FALSE
* * * COM.AI.RUN.ELP = ZERO; COM.AI.ON = EMPTY; COM.AI.UP = EMPTY
* * * COM.AI.ON.OFF.ELP = ZERO; COM.AI.UP.DN.ELP = ZERO
* * * COM.AI.ON.FILE = FALSE
*
COM.AI.PORT.REC = EMPTY
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
* * * MAT COM.AIP = EMPTY; COM.AIP.ID = EMPTY
* * * COM.ID.LIST = EMPTY; COM.AIP.PORT.FIRST = EMPTY
* * * COM.AIP.PORT = EMPTY; COM.AIP.ON.FILE = FALSE; COM.AIP.ELP = ZERO
* * * NEXT.COM.AIP.ID = EMPTY
*
LCK.COM.AI = FALSE; LCK.COM.AIP = FALSE
** $INCLUDE IBP AIL.DIM
** $INCLUDE IBP AIL.EQUATES
** AIL.SEQ.ID = EMPTY; AIL.SEQ = EMPTY; AIL.ID = EMPTY
** *
** * $INCLUDE IBP AIX.DIM
** * $INCLUDE IBP AIX.EQUATES
** *
** * $INCLUDE IBP DVC.DIM
** * $INCLUDE IBP DVC.EQUATES
** *
*
! Application Parameters and Tables
SYS.LOCT = "APT"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Parameters and Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
INTFC.CODE = "?"
*
* * * COMPONENTS = EMPTY; CHANNEL.MLES = EMPTY; CHAN.ALL = FALSE
* * * STATUS.LOC = ONE; 
STATUS.CYCLE = FALSE
* * * STVC = ZERO; BVC = ZERO; ACTIONS = EMPTY; PRIOR.CHANNEL.MLES = EMPTY
* * * STL = EMPTY; PORT.VC = ONE; LOG.REQUIRED = FALSE
*
*
! System Files
SYS.LOCT = "SF"; IF CNT.TST$LBL THEN PRINT @(60,20):"System Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "COM" TO COM.FILE ELSE CHAIN "FREEZE.PORT"
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE CHAIN "FREEZE.PORT"
* LCK.FILE = ZERO; * REV ONLY
*
* * * OPEN "DICT","ACC" TO ACC.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "PAR" TO PAR.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "CNT" TO CNT.FILE ELSE CHAIN "FREEZE.PORT"
* * * READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN 
CO.NAME = CO.DATA<ONE,ONE>
* * *  ELSE CO.NAME = EMPTY; CO.DATA = EMPTY
*
*
! Application Files
SYS.LOCT = "AF"; IF CNT.TST$LBL THEN PRINT @(60,20):"Appl Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
* * * OPEN "AIX" TO AIX.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "DVC" TO DVC.FILE ELSE CHAIN "FREEZE.PORT"
*
* * * OPEN "ACT" TO ACT.FILE ELSE CHAIN "FREEZE.PORT"
*
OPEN "AIL" TO AIL.FILE ELSE CHAIN "FREEZE.PORT"
*
*
! : * Init INternal VARiables
SYS.LOCT = "VAR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Variables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
* * * AI.RESET = FALSE; AI.STATUS = FALSE; AI.DOWN = EMPTY; AI.SLEEP = ZERO
* AI.SCAN = TRUE; *
* * * AI.SCAN.DT = EMPTY; AI.SCAN.TM = EMPTY; AI.SRCE = "H"
*
* * * SEND.STATUS = FALSE; SEND.COMM = TRUE; SEND.RETRY = TRUE; SEND.WAIT = ZERO
* * * SEND.DONE = FALSE; SEND.UP.DN = EMPTY
*
* * * DISP.ONLY = FALSE; ERR.DISP.ONLY = FALSE; ERR.BELL = TRUE
* * * ERR.LN.MIN = 5; ERR.LN = ERR.LN.MIN; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
* * * TEXT = EMPTY; OUTPUTS = EMPTY
** ERROR
* * * LAST.ERROR = EMPTY; ERR.LEN = EMPTY; ERR.FMT = EMPTY
* * * ERR.CLB = EMPTY; ERR.CLS = EMPTY; ERR.CL = EMPTY; ERR.HDR = EMPTY
* * * ERR.CR = EMPTY
*
* * * CHECK.LN.MIN = 11; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 28
* * * CHECK.LEN = 30; CHECK.LN.HI = ZERO
* * * IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
IF ERR.DISP.ONLY THEN STATUS.CYCLE = ERR.DISP.ONLY
DT = DATE(); TM = TIME(); ELP = ZERO
*
*
! : * Init Tables
SYS.LOCT = "TBL"; IF CNT.TST$LBL THEN PRINT @(60,20):"Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
* * * MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
*
* * * READ COMPONENTS FROM PAR.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
* * * CALL LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PROG,STAT)
*
* * * READ STL FROM COM.FILE,"AI.STATUS.CHANNEL.":COMMPORT ELSE STL = EMPTY
*
*
! Start Program
*
*
SYS.LOCT = "START"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
INTFC.CHECK: *
*
SYS.LOCT = "INTFC.CHECK"; IF CNT.TST$LBL THEN PRINT @(60,20):"Check Handler" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.INCL.INTFC.CHECK
*
RETURN
*
!
*
ERROR: *
*
LAST.ERROR = TEXT
*
RETURN
*
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
!
*
RETURN
!
END
~AI.SUBR.UPD.COM.AIP.UTL~
SUBROUTINE AI.SUBR.UPD.COM.AIP.UTL(LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,SEND.COMM.CN,SYS.PRNT,STAT)
*
*
* CALLED BY AI.CONTROL.UTILITY
*              Eagle addressable interface HANDLER.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU TST$AM TO 12, TST$VM TO 9
EQU VERSION TO "901028 NEW (1.0)"
VS = "901028 NEW (1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.UPD.COM.AIP.UTL"; SYS.LOCT = EMPTY
OPER = ""
*
!
*
$INCLUDE IBP TST.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
*
AIX.UPDATE: * Update addressable interface file - AIX
*
LCK.ITM = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
IF NUM(COM.AIP.PORT) THEN COM.AIP.PORT = COM.AIP.PORT + 0
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LT 300 DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
*
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
BEGIN CASE
*
CASE LCK.STAT OR ELP GE 300
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
IF COM.AIP$RVRS.FL THEN
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = PORT
END ELSE
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
*COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS 604 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> EQ EMPTY OR NOT(COM.AIP$RVRS.FL) THEN
* IF I AM THE HANDLER PORT THEN
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
NULL
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
NULL
*
CASE TRUE
INS 606 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
*
END CASE
*
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> THEN
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> NE ERR$NOT.SENT THEN
IF NOT(COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> LT 100 OR COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> GE 600) THEN
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> GT AI.STATUS THEN
AI.STATUS = COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
END
IF AI.STATUS EQ ERR$NOT.SENT THEN AI.STATUS = FALSE
END
END
END
*
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> NE EMPTY THEN
SEND.STATUS = COM.AIP$INTFC.ERR<ONE,ONE,ONE>
IF SEND.STATUS EQ ERR$NOT.SENT THEN SEND.STATUS = FALSE
IF PORT EQ COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$CHECK.TOUT THEN SEND.STATUS = FALSE
END
IF PORT NE COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$TOUT THEN SEND.STATUS = FALSE
END
END
*
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
END ELSE NULL
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
*
*
RETURN
*
END
~AI.SUBR.UPDT.COM.AIP~
SUBROUTINE AI.SUBR.UPDT.COM.AIP(LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,SEND.COMM.CN,SYS.PRNT,STAT)
*
*
* CALLED BY AI.CONTROL.UTILITY
*              Eagle addressable interface HANDLER.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU TST$AM TO 12, TST$VM TO 9
EQU VERSION TO "901028 NEW (1.0)"
VS = "901028 NEW (1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.UPDT.COM.AIP"; SYS.LOCT = EMPTY
OPER = ""
*
!
*
$INCLUDE IBP TST.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
*
AIX.UPDATE: * Update addressable interface file - AIX
*
$INCLUDE IBP AI.INCL.UPDT.COM.AIP
*
*
RETURN
*
END
~AI.SUBR.UPDT.COM.AIP.UTL~
SUBROUTINE AI.SUBR.UPDT.COM.AIP.UTL(LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,SEND.COMM.CN,SYS.PRNT,STAT)
*
*
* CALLED BY AI.CONTROL.UTILITY
*              Eagle addressable interface HANDLER.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU TST$AM TO 12, TST$VM TO 9
EQU VERSION TO "901028 NEW (1.0)"
VS = "901028 NEW (1.0)"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.UPDT.COM.AIP.UTL"; SYS.LOCT = EMPTY
OPER = ""
*
!
*
$INCLUDE IBP TST.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
*
AIX.UPDATE: * Update addressable interface file - AIX
*
LCK.ITM = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
*
$INCLUDE IBP AI.INCL.UPDT.COM.AIP.UTL
*
!
*
RETURN
*
END
~AI.SUBR.WAITFOR.COMMAND~
SUBROUTINE AI.SUBR.WAITFOR.COMMAND(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PRNT,STAT)
*
*PROGRAM: AI.SUBR.WAITFOR.COMMAND
*              Eagle addressable interface HANDLER.
*    __________
*
*
*INCLUDE IBP GENERAL.COMMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*OVERRIDE
*
EQU VERSION TO "920409 NEW (1.0)"
VS = VERSION
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.WAITFOR.COMMAND"; SYS.LOCT = EMPTY
OPER = ""
*
!
*
***$INCLUDE IBP STANDARD.FUNCTIONS.DVC.SCR
****OVERRIDE
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
*
*
! System Control
*
* System Info
OPSYS.TYPE = "PICK"; SYS = ""; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.SUBR = "AI.SUBR.WAITFOR.COMMAND"; SYS.LOCT = EMPTY
SYS.APPL.LOC = ONE
PORT.CONT = FALSE; 
PORT.NUM = PORT.KEY
LOOP WHILE LEN(PORT.NUM) LT 3 DO PORT.NUM = "0":PORT.NUM REPEAT
DT = DATE(); TM = TIME(); ELP = ZERO; ID = EMPTY; CN = ZERO
DISP.ONLY = FALSE
EXEC.VERB = EMPTY; EXEC.IN = EMPTY; EXEC.OUT = EMPTY
*
* Control Flags
* $INCLUDE IBP TST.VAR.EQUATES
* EQU TST$AM TO 12, TST$VM TO 9
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
SYS.LOCT = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.SUBR:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*SYS.LOCT = "?"; IF CNT.TST$LBL THEN PRINT @(60,20):(SYS.LOCT:" ?") "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
*
! Application Records
*
SYS.LOCT = "AR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Records" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
COM.ID = EMPTY; * ???
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
COM.AI.PORT.REC = EMPTY
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
! Application Parameters and Tables
*
SYS.LOCT = "APT"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Parameters and Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
INTFC.CODE = "?"
*
STATUS.CYCLE = FALSE
LCK.COM.AI = EMPTY; LCK.COM.AIP = EMPTY
*
*
! System Files
*
SYS.LOCT = "SF"; IF CNT.TST$LBL THEN PRINT @(60,20):"System Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
OPEN "COM" TO COM.FILE ELSE CHAIN "FREEZE.PORT"
*
OPEN "AIL" TO AIL.FILE ELSE CHAIN "FREEZE.PORT"
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE CHAIN "FREEZE.PORT"
* LCK.FILE = ZERO; * REV ONLY
*
CO.NAME = CO.DATA<ONE,ONE>
*
! Application Files
SYS.LOCT = "AF"; IF CNT.TST$LBL THEN PRINT @(60,20):"Appl Files" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
DT = DATE(); TM = TIME(); ELP = ZERO
*
*
! : * Init Tables
SYS.LOCT = "TBL"; IF CNT.TST$LBL THEN PRINT @(60,20):"Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
*
*
*
! Start Program
*
*
SYS.LOCT = "START"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.SUBR:" ":SYS.LOCT) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
WAITFOR.COMMAND: *
*
SYS.LOCT = "WAITFOR.COMMAND"; IF CNT.TST$LBL THEN PRINT @(60,20):"Check Handler" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.INCL.WAITFOR.COMMAND
*
RETURN; * : *
*
!
*
DISP.COM.AIP.STAT: *
*
$INCLUDE IBP AI.INCL.DISP.COM.AIP.STAT
*
RETURN; * : *
*
!
*
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Check Handler":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
* $INCLUDE IBP AI.INCL.INTFC.CHECK
CHECK.ELP.MAX = 0
CHECK.LCK.TYPE = -9
CALL AI.SUBR.INTFC.CHECK(CHECK.LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,CHECK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PRNT,STAT)
*
IF COM.AI.ON THEN AI.TALK<OP.UP> = COM.AI.UP ELSE AI.TALK<OP.UP> = FALSE
* AI.TALK<OP.STAT> = AI.STATUS
AI.TALK<OP.STAT> = NOT(COM.AI.ON AND COM.AI.UP)
*
RETURN; * : *
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN; * : *
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN; * : *
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN; * : *
!
END
~AI.SUBR.WRITE.COMMAND~
SUBROUTINE AI.SUBR.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,LCK.RELS,SYS.PRNT,STAT)
* VERSION: 940130 1.1  COM.AI.ID CHANGED TO 'AI.TYPE':AI.CODE
*SUBROUTINE: AI.WRITE.COMMAND
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   1990         ALL RIGHTS RESERVED
*
* AUTHOR: DAVID G. HORSMAN
*
* DATE RELEASED: ?? DEC 90
*
*      Write a command onto the port's work file record for transmission...
*
* TO IMPLEMENT TESTING MAT CNT.TST SHOULD BE PASSED IN THE CALL.
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(3.0)"
VS = "3.0"
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.WRITE.COMMAND"; SYS.LOCT = EMPTY
EXP.TM = EMPTY; OPER = ""
*
!
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP SAVE.COM.AIP.DIM
!
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
*
!
OPEN "COM" TO COM.FILE ELSE PRINT @(0,23):CLL:"Can't open COM":; INPUT RSP:; STOP
*
OPEN "AIL" TO AIL.FILE ELSE PRINT @(0,23):CLL:"Can't open AIL":; INPUT RSP:; STOP
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT @(0,23):CLL:"Can't open LOCKS":; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
* LCK.ITM = TRUE; LCK.TYPE = -1; LCK.RELS = TRUE
LCK.ITM = TRUE; *@@@@* LCK.RELS = TRUE
LCK.ELP = ZERO; LCK.ELP.MAX = 30
OPT.COMM = HANDLER.COMMAND
SEND.COMM.CN = ONE
AI.DVC.NEXT.CN = FIELD(COM.AIP.ID,"*",4)
COM.AIP.PORT =   FIELD(COM.AIP.ID,"*",3)
COM.AIP.CODE =   FIELD(COM.AIP.ID,"*",TWO)
*
!
*
*IF NOT(NUM(HANDLER.COMMAND<ONE,ONE>)) THEN
*IF HANDLER.COMMAND<ONE,ONE> EQ AI.UP THEN AI.STATUS = FALSE ELSE AI.STATUS = TRUE
*END
*
PREV.DT = DATE(); PREV.TM = TIME()
MAT SAVE.COM.AIP = ""; PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
COM.AI.ID = "AI.TYPE.":AI.CODE
*
*IF HANDLER.COMMAND NE EMPTY THEN AI.STATUS = HANDLER.COMMAND; RETURN
*
IF COM.AIP.ID EQ EMPTY THEN AI.STATUS = 21; RETURN
*
MAT SAVE.COM.AIP = MAT COM.AIP; RETRY = 0
*** LCK.ITM = FALSE; LCK.RELS = TRUE
LCK.ITM = TRUE; *@@@@* LCK.RELS = FALSE
GOSUB READ.COM.AI
LCK.ITM = TRUE; *@@@@* LCK.RELS = TRUE
*
PRINT @(0,23):CLL:@(ZERO):
*
IF COM.AI$UP.DN.STAT NE AI.UP THEN
PRINT @(31,22):BELL:RVB:"The Addressable Interface Handler is down" "L#73":RVE:
IF NOT(INDEX("#":AI.ON:"#":AI.UP:"#":AI.OFF:"#","#":HANDLER.COMMAND<ONE,ONE>:"#",ONE)) THEN
PRINT @(6,23):" -- press <cr>...":
**** DON'T WANT TO ALWAYS TAKE INPUT
INPUT RSP:; PRINT @(6,23):SPACE(73):
*HANDLER.COMMAND = 1; 
*** AI.STATUS = 11; RETURN
AI.STATUS = 11
END
END
*
!
*
* Main program loop
*
RETRY.CONT = TRUE
WRITEN.FLAG = FALSE; OVERWRITE.FLAG = FALSE
*
* IF NOT(AI.STATUS) AND LCK.COM.AI THEN
IF NOT(AI.STATUS) THEN
*
!
*
*OVW.TYPE = FIELD(COM.AIP.ID,"*",ONE)
*OVW.CODE = FIELD(COM.AIP.ID,"*",TWO)
*OVW.PORT = FIELD(COM.AIP.ID,"*",3)
*OVW.DVC.CN = FIELD(COM.AIP.ID,"*",4)
*IF NOT(NUM(OVW.DVC.CN)) THEN OVW.DVC.CN = ONE
*IF OVW.DVC.CN LT ONE THEN OVW.DVC.CN = ONE
*OVW.DVC.NEXT.FOUND = TRUE
*FOR TMP = OVW.DVC.CN TO 10 UNTIL NOT(OVW.DVC.NEXT.FOUND)
*OVW.ID = OVW.TYPE:"*":OVW.CODE:"*":OVW.PORT:"*":TMP
*MATREAD COM.AIP FROM COM.FILE,OVW.ID THEN
** Loop to save old exceptions
*MATWRITE COM.AIP ON COM.FILE,DATE():"@":TIME():"@":OVW.ID
*DELETE COM.FILE,OVW.ID
*PRINT @(6,23):CLL:BELL:RVB:("Handler Command over-ride delete for ":OVW.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
*END ELSE OVW.DVC.NEXT.FOUND = FALSE
*NEXT OVW
*
!
*
LOOP
*
*
* LOCK ITEM
*
IF NOT(LCK.COM.AI) THEN
DT = DATE(); TM = TIME(); ELP = ZERO
TMP1 = COM.AI$MAX.PAUSE
IF NOT(TMP1) THEN TMP1 = 300
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
IF LCK.STAT GE 900 THEN AI.STATUS = LCK.STAT
IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
UNTIL LCK.COM.AI OR ELP GT TMP1 DO REPEAT
*
END; * OF LCK.COM.AI
*
** IF LCK.COM.AI THEN
*
!
*
* LOCK ITEM
*
DT = DATE(); TM = TIME(); ELP = ZERO
TMP1 = COM.AI$MAX.PAUSE
IF NOT(TMP1) THEN TMP1 = 300
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
IF LCK.STAT GE 900 THEN AI.STATUS = LCK.STAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
UNTIL LCK.COM.AIP OR ELP GT TMP1 DO REPEAT
*
*
IF LCK.COM.AIP THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN OVW.ON.FILE = TRUE ELSE OVW.ON.FILE = FALSE; MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
*
**IF LCK.COM.AI AND COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> EQ EMPTY THEN OVERWRITE.FLAG = TRUE
IF LCK.COM.AI THEN
TMP = DCOUNT(COM.AIP$COMM.PORT,VM)
OVERWRITE.FLAG = TRUE
FOR SEND.COMM.CN = ONE TO TMP
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> NE EMPTY THEN OVERWRITE.FLAG = FALSE
NEXT SEND.COMM.CN
END
*
END
*
!
*
UNTIL OVERWRITE.FLAG OR WRITEN.FLAG OR NOT(RETRY.CONT) DO
*
*
RETRY = RETRY + ONE
CURR.ELP = ((DATE() - PREV.DT) * 86400) + (TIME() - PREV.TM)
*
TEMP.MAX.PAUSE = COM.AI$MAX.PAUSE
* HH - THIS IS WHERE WE VARY THE TIME WE WILL WAIT BASED ON 5B OR 7B
** IF COM.AIP$MAX.PAUSE NE "" THEN TEMP.MAX.PAUSE = COM.AIP$MAX.PAUSE
*
IF (CURR.ELP LE TEMP.MAX.PAUSE AND COM.AI$UP.DN.STAT EQ AI.UP) AND SYSTEM(11) LE 3 THEN
*
PRINT @(6,23):RVB:("Handler Command attempt #":RETRY:" at time ":CURR.ELP) "L#73":RVE:
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"C","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
* EXECUTE "SLEEP ":COM.AI$STD.PAUSE
* PRINT @(6,23):SPACE(73):
*
END ELSE
*
*
PREV.DT = DATE(); PREV.TM = TIME()
PRINT BELL:
*
IF COM.AI$UP.DN.STAT EQ AI.UP THEN
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command has not been sent -- wait longer? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
END ELSE RSP = "N"
*
IF RSP EQ "Y" THEN
RETRY.CONT = TRUE
PREV.DT = DATE(); PREV.TM = TIME()
END ELSE
*
PRINT BELL:
*
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command will be lost -- overwrite it? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
*
IF RSP EQ "Y" THEN
* Yes, overwrite item
*
OVW.TYPE = FIELD(COM.AIP.ID,"*",ONE)
OVW.CODE = FIELD(COM.AIP.ID,"*",TWO)
OVW.PORT = FIELD(COM.AIP.ID,"*",3)
OVW.DVC.CN = FIELD(COM.AIP.ID,"*",4)
IF NOT(NUM(OVW.DVC.CN)) THEN OVW.DVC.CN = ONE
IF OVW.DVC.CN LT ONE THEN OVW.DVC.CN = ONE
OVW.DVC.NEXT.FOUND = TRUE
FOR TMP = OVW.DVC.CN TO 10 UNTIL NOT(OVW.DVC.NEXT.FOUND)
OVW.ID = OVW.TYPE:"*":OVW.CODE:"*":OVW.PORT:"*":TMP
MATREAD COM.AIP FROM COM.FILE,OVW.ID THEN
* Loop to save old exceptions
MATWRITE COM.AIP ON COM.FILE,DATE():"@":TIME():"@":OVW.ID
DELETE COM.FILE,OVW.ID
PRINT @(6,23):CLL:BELL:RVB:("Handler Command over-ride delete for ":OVW.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
END ELSE OVW.DVC.NEXT.FOUND = FALSE
NEXT OVW
*
* write new command
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
RETRY.CONT = TRUE
WRITEN.FLAG = TRUE; OVERWRITE.FLAG = TRUE
PRINT @(6,23):CLL:BELL:RVB:("Handler Command over-ride placed for ":COM.AIP.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
*
END ELSE
*
* No, do not overwrite item
*
RETRY.CONT = FALSE
OVERWRITE.FLAG = FALSE
PRINT @(6,23):CLL:BELL:RVB:("Handler Command Request for ":COM.AIP.ID:" denied at ":CURR.ELP) "L#73":RVE:
*
END; * of Y/N to overwrite
*
*
END; * of do not continue to wait for prior command
*
!
*
END; * of more than six waits for the command
*
REPEAT
* for repeated attempts to send the command
*
!
*
IF (OVERWRITE.FLAG AND LCK.COM.AIP) THEN
*
*
*** LOOP
*** LCK.ITM = TRUE; LCK.RELS = FALSE
*** COM.AI.ID = "AI.TYPE.":AI.CODE
*** GOSUB READ.COM.AI
*** WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
*** *
*** IF LCK.STAT NE 999 THEN
** IF LCK.COM.AI THEN
*
LCK.ITM = TRUE; *@@@@* LCK.RELS = TRUE
IF COM.AI$FUNC.PORT NE EMPTY THEN
IF INDEX("#":AI.ON:"#":AI.OFF:"#":AI.UP:"#":AI.DN:"#","#":COM.AIP$COMM:"#",ONE) THEN
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
END ELSE NULL
INS PORT.KEY BEFORE COM.AI$FUNC.PORT<ONE,ONE>
END ELSE
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:PORT.KEY
END; * of locate else
END; * of on/off/up/dn
END ELSE
COM.AI$FUNC.PORT = PORT.KEY
END
*
LOOP WHILE LEN(COM.AI$FUNC.PORT) AND COM.AI$FUNC.PORT<ONE,ONE> EQ EMPTY DO
DEL COM.AI$FUNC.PORT<ONE,ONE>
REPEAT
*
IF LCK.COM.AI THEN
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
END
*
*
IF NOT(WRITEN.FLAG) THEN
*
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
WRITEN.FLAG = TRUE; *
*
IF AI.DVC.NEXT.CN EQ ONE THEN
OVW.TYPE = FIELD(COM.AIP.ID,"*",ONE)
OVW.CODE = FIELD(COM.AIP.ID,"*",TWO)
OVW.PORT = FIELD(COM.AIP.ID,"*",3)
**OVW.DVC.CN = FIELD(COM.AIP.ID,"*",4)
OVW.DVC.CN = AI.DVC.NEXT.CN + ONE
IF NOT(NUM(OVW.DVC.CN)) THEN OVW.DVC.CN = ONE
**IF OVW.DVC.CN LT ONE THEN OVW.DVC.CN = ONE
OVW.DVC.NEXT.FOUND = TRUE
FOR TMP = OVW.DVC.CN TO 10 UNTIL NOT(OVW.DVC.NEXT.FOUND)
OVW.ID = OVW.TYPE:"*":OVW.CODE:"*":OVW.PORT:"*":TMP
MATREAD COM.AIP FROM COM.FILE,OVW.ID THEN
* Loop to save old exceptions
**MATWRITE COM.AIP ON COM.FILE,DATE():"@":TIME():"@":OVW.ID
DELETE COM.FILE,OVW.ID
PRINT @(6,23):CLL:BELL:RVB:("Handler Command clean-up delete for ":OVW.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
END ELSE OVW.DVC.NEXT.FOUND = FALSE
NEXT OVW
END
*
PRINT @(6,23):RVB:"The Handler Command has been submitted." "L#73":RVE:
EXECUTE "SLEEP ":COM.AI$STD.PAUSE
*
END; * of WRITEN
*
*
END; * of overwrite or lock flag
*
!
*
END; * OF AI.STATUS 11 AND LCK.COM.AI
*
IF LCK.COM.AI THEN
IF LCK.RELS THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"D","",LCK.STAT)
LCK.COM.AI = FALSE
END
END
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"E","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
RETURN
*
!
*
READ.COM.AI: *
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
LOAD.TST: *
*
* $INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
*
END
~AI.SUBR.WRITE.LOG~
SUBROUTINE AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.AIP.ID,AI.CODE,AI.SRCE,LOG.REQUIRED,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PRNT,STAT)
* VERSION: 940130 1.1  AIL.SEQ.ID CHANGED.
* PRIOR: 910722 NEW
*
* 22 JUL 91
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "940130 (1.1)"
VS = VERSION
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.SUBR.WRITE.LOG"; SYS.LOCT = EMPTY
OPER = ""; EXP.TM = EMPTY
*
*
$INCLUDE IBP TST.EQUATES
EQU TST$AM TO 12, TST$VM TO 9
*
!
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP AIL.DIM
*
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP AIL.EQUATES
*
OPEN "AIL" TO AIL.FILE ELSE CHAIN "FREEZE.PORT"
*
* ULT ONLY
* OPEN "LOCKS" TO LCK.FILE ELSE CHAIN "FREEZE.PORT"
* LCK.FILE = ZERO; * REV ONLY
*
$INCLUDE IBP AI.INCL.WRITE.LOG
*
*
RETURN
*
END
~AI.SUBR.XCEL.COM.AIP~
SUBROUTINE AI.SUBR.XCEL.COM.AIP(OPER,EXP.TM,COM.AIP.ID,COM.AI.ID,SEND.STATUS,AI.ACTN,AI.RSLT,AI.STATUS,WOF,AIL.ID,SYS.PRNT)
* DESCRIPTION:       ABORT AI COMMAND
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
$INCLUDE IBP WKO.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP AIL.DIM
$INCLUDE IBP AIL.EQUATES
*
!
OPEN "COM" TO COM.FILE ELSE STOP
*
SYS.PROG = "AI.SUBR.XCEL.COM.AIP"
LCK.COM.AIP = FALSE; LCK.COM.AI = FALSE; COM.AI.FLAG = FALSE
MAT COM.AI = EMPTY
DT = DATE(); TM = TIME(); ELP = ZERO
*
!
*
*
!
*
IF (AIX.ID:AI.TALK<ADDRESSABLE>:AI.TALK<PAY.PER.VIEW>:AI.TALK<IMPULSE.PPV>) NE EMPTY THEN
*
LCK.TYPE = -8
AI.SRCE = "A"
HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
**READ AI.TYPES FROM COM.FILE,"AI.TYPE.":HEADEND ELSE AI.TYPES = "10":AM:"UNKNOWN"
**AI.CODE     = AI.TYPES<ONE>
*
$INCLUDE IBP AI.INCL.LOAD.CODE
*
COM.AIP.PORT = PORT
LOOP WHILE LEN(COM.AIP.PORT) LT 3 DO COM.AIP.PORT = ZERO:COM.AIP.PORT REPEAT
COM.AI.ID = "AI.TYPE.":AI.CODE
*
!
*
$INCLUDE IBP AI.INCL.XCEL.COM.AIP
*
*
RETURN
*
END
~AI.TALK.VAR.DISPLAY~
SUBROUTINE AI.TALK.VAR.DIPLAY
*PROGRAM: AI.TALK.VAR.DISPLAY
* VERSION: 951124 1.0
*
* AUTHOR:            DAVID HORMAN
* DESCRIPTION:       DISPLAY AND MAINTAIN ADDRESSABLE INTERFACE TABLE
*
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*
!
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
*****$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*****OVERRIDE
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
!
*
START: *
*
AI.TALK.SAVE = AI.TALK
OPEN "IBP" TO IBP.FILE ELSE
OPEN "MD"  TO IBP.FILE ELSE
RETURN
END
END
*
READ IBP.ITM FROM IBP.FILE,"AI.TALK.VAR.EQUATES" THEN
LOOP WHILE LEN(IBP.ITM) AND IBP.ITM[ONE,3] NE "EQU" DO
DEL IBP.ITM<ONE>
REPEAT
IF IBP.ITM EQ EMPTY THEN RETURN
TMP = DCOUNT(IBP.ITM,AM)
FOR TMP1 = ONE TO TMP
IBP.ITM<TMP1> = TRIM(FIELD(IBP.ITM<TMP1>,";",ONE))
NEXT TMP1
FOR TMP1 = ONE TO TMP
IBP.ITM<TMP1> = FIELD(IBP.ITM<TMP1>," ",4):VM:FIELD(IBP.ITM<TMP1>," ",TWO)
NEXT TMP1
*
END ELSE
IBP.ITM = EMPTY
RETURN
END
*
!
*
IF NEXT.CALL = "" THEN
IF COUNT(ALLOWED,"T*") THEN MORE.MSG = "T#," ELSE MORE.MSG = ""
POS = INDEX(ALLOW.MSG,"T",1); MORE.MSG = ALLOW.MSG[1,POS-1]:MORE.MSG:ALLOW.MSG[POS+2,99]
END ELSE
IF COUNT(ALLOWED,"T*") THEN MORE.MSG = "T# or " ELSE MORE.MSG = ""
MORE.MSG = "Enter ":MORE.MSG:"<cr> to continue: "
END
*
GOSUB DISPLAY
RETURN; ****
!
MORE: *
PRINT CLB:MORE.MSG:
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
ST.RSP = RSP
IF RSP = "TH" OR RSP MATCHES "'T'0N" THEN RSP = "T"
IF RSP = "T" THEN PRINT BELL:; GOTO MORE
IF RSP = "T1" OR RSP = "T2" OR RSP = "T3" THEN
IF COUNT(ALLOWED,"T*") EQ ZERO THEN PRINT BELL:; GOTO MORE
GOSUB MAINT.TABLES
GOSUB DISPLAY
GOTO MORE
END
IF NEXT.CALL # "" THEN IF RSP = "" THEN RETURN ELSE PRINT BELL:; GOTO MORE
IF RSP MATCHES "'S'0N" THEN CALL DISPLAY.SERVICES; IF STAT EQ 999 THEN RETURN ELSE GOTO MORE
IF RSP = "?" THEN REF = MORE.MSG; CALL DISPLAY.ALLOWED; IF STAT = 999 THEN RETURN ELSE GOTO MORE
IF RSP MATCHES "1A" THEN IF COUNT(ALLOWED,RSP[1,1]) THEN NEXT.CALL = RSP[1,1]:AM:NEXT.CALL; RSP = ST.RSP; RETURN
IF RSP = "" THEN RETURN
PRINT BELL:
GOTO MORE
!
DISPLAY: *
CLS.COL = ZERO; CLS.ROW = 10; GOSUB CLS.ROUTINE
HDR1 = "Addressable Control Information (T1)"
*
HDR2 = "Device Loct Address P I IO SRC ..WKO..C"
PRINT RVB:HDR1 "L#40":HDR2 "L#40":
PRINT @(39,11):" ":@(39,12):" ":@(39,13):" ":@(39,14):" ":@(39,15):" ":
PRINT @(39,16):" ":@(39,17):" ":@(39,18):" ":@(39,19):" ":@(39,20):" ":@(39,21):" ":RVE:
PRINT @(ZERO,22):RVB:STR("*",80):RVE:
*
FOR AC = ONE TO 20
PRINT @((ZERO + ((AC GT 10) * 20)),(AC + 10 - ((AC GT 10) * 10))):RVB:IBP.ITM<AC,ONE> "R#2":".":IBP.ITM<AC,TWO> "R#10":RVE:" ":AI.TALK<AC> "L#5":
NEXT AC
*
DVC.MAX = DCOUNT(AI.TALK<AI.DVC.IDS>,VM)
FOR AC = ONE TO DVC.MAX
PRINT @(40,AC + 10):AI.TALK<AI.DVC.IDS,AC> "R#6":
PRINT " ":AI.TALK<AI.DVC.LOCS,AC> "L#4":
PRINT " ":AI.TALK<AI.DVC.ADDR,AC> "L#7":
PRINT " ":AI.TALK<AI.DVC.PPV,AC> "L#1":
PRINT " ":AI.TALK<AI.DVC.IPPV,AC> "L#1":
PRINT " ":AI.TALK<AI.DVC.DIR,AC> "R#2":
PRINT " ":AI.TALK<AI.DVC.SRCE,AC> "L#3":
PRINT " ":AI.TALK<AI.DVC.WKO,AC> "R#7":
IF AI.TALK<AI.DVC.NEXT> EQ AC THEN PRINT RVB:"*":RVE:
NEXT AC
*
* FOR VC = 1 TO 6
* LN = LN+1; VCX = VCX+1
* NEXT VC
*
RETURN
*
!
*
MAINT.TABLES: *
*
TYPE = RSP[2,1]; BEGIN = 11; CHANGED = TRUE
IF TYPE = 1 THEN TABLES = ACT$MESSAGE; LINES = 6; MSG = "Account"; REF = "ACT*":ACT.ID
IF TYPE = 2 THEN TABLES = ADD$MESSAGE; LINES = 1; MSG = "Address"; REF = "ADD*":ADD.ID
IF TYPE = 3 THEN TABLES = ADD$TECH.INFO; BEGIN = 16; LINES = 4; MSG = "Address"; REF = "ADD*":ADD.ID
*
CLS.COL = 0; CLS.ROW = 10; GOSUB CLS.ROUTINE
PRINT RVB:(MSG:" Comment Maintenance") "L#80":@(0,22):STR("*",80):RVE:
*  DISPLAY SECTION
IF TYPE = 2 THEN
PRINT @(20,11):"C2 Directions to Address":
PRINT @(20,13):ADD$MESSAGE:
END
IF TYPE = 3 THEN PRINT @(20,15):"C3 Technical Information":
IF TYPE # 2 THEN
VC = 1
LOOP UNTIL VC = LINES+1 DO PRINT @(20,VC+BEGIN):TABLES<1,VC>:; VC = VC+1 REPEAT
END
* MAINTENANCE SECTION
IF REF[ONE,3] EQ "ADD" THEN
CALL UPDATE.LOCK(ADD.FILE)
END ELSE
CALL UPDATE.LOCK(ACT.FILE)
END
IF STAT > 0 THEN RETURN
*
IF TYPE = 2 THEN
CALL INPUT.DATA(TABLES,20,13,30,1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
ADD$MESSAGE = TABLES
END
IF TYPE # 2 THEN
VC = 1
LOOP
LOOP
CALL INPUT.DATA(TABLES,20,VC+BEGIN,30,"1,":VC,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
WHILE STAT = -1 DO VC = VC-1; IF VC < 1 THEN VC = 1 REPEAT
UNTIL TABLES<1,VC> = "" OR VC = LINES DO VC = VC+1 REPEAT
END
* UPDATE SECTION
VC = 1
IF TYPE = 1 THEN
ACT$MESSAGE = ""
LOOP UNTIL TABLES<1,VC> = "" OR VC = LINES+1 DO ACT$MESSAGE<1,VC> = TABLES<1,VC>; VC = VC+1 REPEAT
RETURN
END
*
IF TYPE = 3 THEN
ADD$TECH.INFO = ""
LOOP UNTIL TABLES<1,VC> = "" OR VC = LINES+1 DO ADD$TECH.INFO<1,VC> = TABLES<1,VC>; VC = VC+1 REPEAT
RETURN
END
RETURN
$INCLUDE IBP CLS.ROUTINE
END
~AI.TALKER~
SUBROUTINE AI.TALKER(AI.ACTN,AI.RSLT,AI.STATUS,WOF,AIL.ID,SYS.PRNT)
*PROGRAM:           AI.TALKER
*EQU VS TO "940216 1.1"
*
* COPYRIGHT AXION COMPUTER SYSTEMS
*
* comments
$INCLUDE IBP AI.TALKER.TOP
*
!
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
*****$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*****OVERRIDE
*
EQU VERSION TO "940216 1.1"
VS = VERSION
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.TALKER"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP WOT.DIM
MAT WOT = ""
*
*
!
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP AIL.DIM
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIIERR.DIM
*
!
*
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP WKO.EQUATES
$INCLUDE IBP DVC.EQUATES
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP SAVE.ACT.EQUATES
$INCLUDE IBP AI.TALK.VAR.EQUATES
$INCLUDE IBP FN.VAR.EQUATES
$INCLUDE IBP AI.STATUS.VAR.EQUATES
$INCLUDE IBP AI.ERR.VAR.EQUATES
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP AIL.EQUATES
$INCLUDE IBP COM.AIHERR.EQUATES
$INCLUDE IBP COM.AIIERR.EQUATES
$INCLUDE IBP DVT.DIM
$INCLUDE IBP DVT.EQUATES
*
!
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STAT = 999; RETURN
OPEN "ACG" TO ACG.FILE ELSE PRINT CLB:"Can't open ACG":; INPUT TMP:; STAT = 999; RETURN
OPEN "AIX" TO AIX.FILE ELSE PRINT CLB:"Can't open AIX":; INPUT TMP:; STAT = 999; RETURN
*
!
*
$INCLUDE IBP AI.ERR.INIT
*
$INCLUDE IBP AI.INCL.TALKER.INIT
*
LCK.COM.AI = FALSE; LCK.COM.AIP = FALSE
CHECK.ELP.MAX = 3
*
MATREAD DVT FROM PAR.FILE,"DEVICE.TYPES" ELSE MAT DVT = EMPTY; PRINT CLB:"DEVICE.TYPES":" is missing!!!":
READ DVC.FUNCS FROM PAR.FILE,"DEVICE.FUNCTIONS" ELSE DVC.FUNCS = EMPTY; PRINT CLB:"DEVICE.FUNCTIONS":" is missing!!!":
*
MATREAD WOT FROM PAR.FILE,"WORK.ORDER.TYPES" ELSE MAT WOT = EMPTY; PRINT CLB:"WORK.ORDER.TYPES":" is missing!!!":
*
IF CNT.TST$RTN EQ 3 THEN
CALL AI.TALK.VAR.DISPLAY
END
*
!
*
START: *
*
LOOP
TYPE = AI.ACTN<1>
IF CNT.TST$RTN THEN PRINT CLB:"AI.TALKER function is (":TYPE:").":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
WHILE TYPE NE EMPTY AND NOT(STAT) DO
BEGIN CASE
*
* GENERAL FUNCTIONS     @@@
*
CASE TYPE EQ FN$CHECK.INTFC; * : * TYPE 2
MSG.N = FN$CHECK.INTFC; GOSUB RTN.CHECK.INTFC; * INTERFACE MSG; * : *
*
CASE TYPE EQ FN$INPUT.TRAN; * : * TYPE 12
* ON PREMISE CHECK
IF INDEX("RC",WOF,1) THEN GOSUB Q12.SERVICES.AS.IS; * WILL SERVICES ON PREMISE BE CHANGED?; * : *
IF (AI.TALK<BUILD.WO> AND (WKO.ID EQ "NEW" OR WKO.ID EQ EMPTY)) THEN GOSUB BUILD.WKO; * : *
*
**** CASE AI.TALK<OP.STAT>; NULL; * THE INTERFACE IS DOWN
*
CASE TYPE EQ FN$CHECK.DISPATCHER; * : * TYPE 1
MSG.N = FN$CHECK.DISPATCHER; GOSUB RTN.CHECK.DISPATCHER; * DISPATCHER MSG; * : *
*
CASE TYPE EQ FN$INPUT.INSTALLER; * : * TYPE 3
IF NOT(ADD$STAT EQ "H" OR ADD$STAT EQ "C") THEN SKIP.FL = TRUE ELSE
IF AI.TALK<OP.MULTI> AND WOF EQ "S" THEN SKIP.FL = TRUE ELSE
IF AI.TALK<TALKING> EQ EMPTY THEN GOSUB RTN.INPUT.INSTALLER; * IS SOMEONE AT SITE? (AVAIL TO TEST); * : *
END
END
*
CASE TYPE EQ FN$COMPR.SVC; * : * TYPE = 4
GOSUB RTN.COMPARE.SVC; * : *
!
* DISC FUNCTIONS     @@@
*
CASE TYPE EQ FN$INPUT.DISC; * : * TYPE = 5
GOSUB RTN.INPUT.DISC; * DEACTIVATE SERVICES NOW?; * : *
*
CASE TYPE EQ FN$INPUT.COLL; * : * TYPE = 14
GOSUB RTN.INPUT.COLL; * COLLECT DEVICES?; * : *
*
CASE TYPE EQ FN$VERIFY.DISC; * : * TYPE = 15
GOSUB RTN.VERIFY.DISC; * HAS SERVICE BEEN STOPPED OK?; * : *
*
CASE TYPE EQ FN$REQRD.WO.DISC; * : * TYPE = 18
GOSUB RTN.REQRD.WO.DISC; * TECHNICIAN MUST BE SENT TO DEACITIVATE SERVICES; * : *
*
CASE TYPE EQ FN$INPUT.PREV.TNT; * : * TYPE = 21
GOSUB RTN.INPUT.PREV.TNT; * DISCONNECT THE PRIOR TENANT?; * : *
*
CASE TYPE EQ FN$INPUT.PREV.ADDR; * : * TYPE = 22
GOSUB RTN.INPUT.PREV.ADDR; * DISCONNECT THE PRIOR.ADDRESS?; * : *
!
* TYPE 6 - ENTERED WORK ORDERS
CASE TYPE EQ FN$INPUT.WO; * : * TYPE 6
*
IF WOF NE "D" THEN 
IF ACT$SERVICES = "" THEN CALL CALC.WKO.CHANGES
GOSUB RTN.COMPARE.SVC; * : *
*END ELSE
*AI.TALK<ADDRESSABLE> = AIX.ID
END
*
*
**IF AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) THEN GOTO INPUT.WO.EXIT
IF NOT(LEN(AI.TALK<AI.DVC.IDS>)) THEN GOTO INPUT.WO.EXIT
IF NOT(AI.TALK<AI.DVC.NEXT>) THEN GOTO INPUT.WO.EXIT
IF AI.TALK<AI.DVC.SRCE,AI.TALK<AI.DVC.NEXT>> NE "WKO" THEN GOTO INPUT.WO.EXIT
*
!
* CONNECT AND RECONNECT W/O FUNCTIONS     @@@
*
*
IF WOF = "R" OR WOF = "C" THEN
*
* COLD CONNECT OR RECONNECT *******************
*
IF ADD$STAT NE "H" THEN 
*
IF AI.TALK<TALKING> THEN
*
IF NOT(AI.TALK<SENT>) THEN
GOSUB RTN.INPUT.WO; * ACTIVATE THE COLD ADDRESS?; * : *
IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
*
IF DVC.ON.FILE THEN
IF AI.TALK<VERIFIED.HOT> THEN 
GOSUB Q10.CONFIRM.WO; * SERVICES ACTIVE. CONFIRM THE WO?; * : *
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO; * : *
END
END
*
END ELSE
* Not talking
*
IF NOT(AI.TALK<SENT>) THEN
GOSUB RTN.INPUT.TRY ; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?; * : *
IF AI.TALK<DO.SEND> THEN
AI.CNTRL.NUM = 1; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
END
*
IF DVC.ON.FILE THEN
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO; * CONFIRM THIS WORK ORDER?; * : *
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO; * : *
END
END
*
END; * of not talking
*
GOTO INPUT.WO.DONE
END; * of NE "H"
*
!
* HOT CONNECT OR RECONNECT *********************
*
IF ADD$STAT EQ "H" THEN
*
IF AI.TALK<TALKING> THEN
*
GOSUB RTN.VERIFY.SVC; * : *
*
IF NOT(AI.TALK<SENT>) THEN
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB RTN.INPUT.WO; * ACTIVATE SERVICES?; * : *
IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
*
IF DVC.ON.FILE THEN
IF AI.TALK<VERIFIED.HOT> THEN 
GOSUB Q10.CONFIRM.WO; * : *
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO; * : *
END
END
*
END ELSE
* not talking
*
IF NOT(AI.TALK<SENT>) THEN
GOSUB RTN.INPUT.TRY ; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?; * : *
IF AI.TALK<DO.SEND> THEN
AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
END
*
IF DVC.ON.FILE THEN
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO; * CONFIRM THIS WORK ORDER?; * : *
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO; * : *
END
END
*
END; * of not talking
*
GOTO INPUT.WO.DONE
END; * of "H"
*
*
END; * of "R" or "C"
*
!
* DISCONNECTS     @@@@
*
IF (WOF EQ "D") THEN
*
IF AI.TALK<TALKING> THEN
*
IF NOT(AI.TALK<SENT>) THEN
IF CO.DATA<15> THEN GOSUB RTN.INPUT.PREV.ADDR ELSE GOSUB RTN.INPUT.DISC; * DEACTIVATE SERVICES NOW?; * : *
IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = TWO; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
*
IF NOT(CO.DATA<15>) AND AI.TALK<VERIFIED.COLD> THEN 
GOSUB Q10.CONFIRM.WO; * CONFIRM THE WORK ORDER?; * : *
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO; * : *
END
*
END ELSE
* not talking
*
IF NOT(AI.TALK<SENT>) THEN
GOSUB RTN.INPUT.TRY; * Do you want to Activate/Deactivate now?; * : *
IF AI.TALK<DO.SEND> THEN 
AI.CNTRL.NUM = TWO; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
END
*
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO; * : *
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO; * : *
END
*
END
*
GOTO INPUT.WO.DONE
END
*
!
*  SERVICE CHANGES    @@@@
*
IF WOF = "S" THEN
*
IF DVC.ON.FILE THEN
*
IF (AI.TALK<TALKING> AND SINGLE AND NOT(WKO$SCH.DATE > DATE())) THEN
*
IF NOT(AI.TALK<SENT>) THEN
GOSUB RTN.INPUT.TRY; * : *
IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = ONE; GOSUB SEND.CHANGE; * : *
* IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
*
IF AI.TALK<VERIFIED.CHANGED> THEN 
GOSUB Q10.CONFIRM.WO; * : *
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO; * : *
END
*
END ELSE
* not talking or sch > dt
*
LOOP UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO
AI.CNTRL.NUM = TWO; GOSUB SEND.CHANGE; * : *
* IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = TWO; GOSUB Q9.ACTIVATE.SERVICES; * : *
REPEAT
*
*
IF AI.TALK<SENT> THEN GOSUB CONFIRM.WKO ELSE; * : *
AI.TALK<PRINT.WO> = TRUE
IF WKO$SCH.TYPE = "AI" THEN
WKO$SCH.TYPE = ""; WKO$SCH.DATE = ""
GOSUB P25.RESCHEDULE.WO; * : *
END
END
*
END; * of talking
*
END; * of dvc.on.file
*
GOTO INPUT.WO.DONE
END; * of "S"
*
INPUT.WO.DONE: *
*
*
IF COM.AI$GENIE.WINDOW EQ "Y" THEN
** CALL DISPLAY.SERVICES
CALL DISPLAY.WORK.ORDER.DETAIL(MAT WOT)
END
*
INPUT.WO.EXIT: *
*
!
*
CASE TYPE EQ FN$VERIFY.SVC; * : * TYPE = 7
GOSUB RTN.VERIFY.SVC; * ARE SERVICES ACTIVE AT THE ADDRESS?; * : *
*
CASE TYPE EQ FN$INPUT.TRY; * : * TYPE = 8
GOSUB RTN.INPUT.TRY; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?; * : *
*
* CASE TYPE EQ 9; GOSUB P9.ACTIVATING.PLS.WAIT; * ACTIVATING SERVICES; * : *
* CASE TYPE EQ 10; GOSUB Q10.CONFIRM.WO; * SERVICES ACTIVATED. CONFIRM NOW?; * : *
* CASE TYPE EQ 11; GOSUB Q11.DO.CHANGE; * DO YOU WANT TO CHANGE SERVICES NOW?
* CASE TYPE EQ 32; GOSUB Q32.RETRY.ACTIVATE; * RESEND ACTIVATE/DEACTIVATE?
* CASE TYPE EQ 16; GOSUB Q16.SEND.AGAIN; * (DE)ACTIVATE WAS NOT SUCCESSFUL. SEND AGAIN?
* CASE TYPE EQ 19; GOSUB P19.CHANGING.PLS.WAIT
* CASE TYPE EQ 20; GOSUB Q20.CHANGED
* CASE TYPE EQ 24; GOSUB P24.ENTER.MAINT.WO
*
!
CASE TYPE EQ 60; * Genie 'I' command
*
AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
IF COM.AI$GENIE.WINDOW EQ "Y" THEN PORTS.LIST.BUILD = 7
GOSUB INTFC.CHECK; * : *
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES; * : *
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; * : *
*@@@*IF COM.AI$GENIE.WINDOW EQ "Y" THEN
** CALL DISPLAY.SERVICES
*@@@*CALL DISPLAY.WORK.ORDER.DETAIL(MAT WOT)
*@@@*END
*
*
!
* FROM AI.SEND.WKO  @@@@
*      TYPE 81 = NO MONITORING. PROCESS WITHOUT PROMPTING
*      TYPE 82 = TO BE MONITORED
*
*
CASE (TYPE EQ 81 OR TYPE EQ 82); * WO'S (WOF R,D,S) (81 NOT TALKING)
*
IF TYPE EQ 81 THEN AI.TALK<TALKING> = 0
CALL CALC.WKO.CHANGES
*
GOSUB RTN.INPUT.WO; * : *
IF AI.TALK<DO.SEND> THEN
*
OPER = AI.RSLT; AI.RSLT = ""
IF WOF EQ "R" THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
IF WOF EQ "D" THEN AI.CNTRL.NUM = TWO; GOSUB Q9.ACTIVATE.SERVICES; * : *
IF WOF EQ "S" THEN
AI.CNTRL.NUM = ONE; GOSUB SEND.CHANGE; * : *
* IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
IF AI.TALK<SENT> THEN GOSUB CONFIRM.WKO; * : *
IF TYPE EQ 82 AND NOT(AI.TALK<NOT.SCHEDULED>) THEN WKO$SCH.DATE = WKO$EFF.DATE
*
END
*
*@@@*RETURN
!
* CANCELLED WORK ORDERS    @@@@
*
CASE TYPE EQ 90; * CANCELLING A CONNECT/RECONNECT. DEACTIVATE SERVICE?
IF AI.TALK<TALKING> THEN
IF ADD$STAT EQ "C" THEN
GOSUB RTN.INPUT.WO; * : *
IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
IF ADD$STAT EQ "H" THEN
GOSUB RTN.VERIFY.SVC; * : *
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB RTN.INPUT.WO; * : *
IF AI.TALK<DO.SEND> THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
END
END
*
CASE TYPE EQ 91; * CANCELLING A DISCONNECT. REACTIVATE SERVICE?
IF AI.TALK<TALKING> THEN GOSUB RTN.VERIFY.SVC; * : *
IF NOT(AI.TALK<VERIFIED.HOT>) THEN AI.CNTRL.NUM = ONE; GOSUB Q9.ACTIVATE.SERVICES; * : *
*
CASE TYPE EQ 92; * CANCELLING A SERVICE CHANGE. CHECK SERVICES?
IF AI.TALK<TALKING> THEN GOSUB P23.VERIFY.SERVICES; * : *
!
*
CASE TRUE; GOSUB TYPE.ERROR; STAT = 999; RETURN; * : *
*
END CASE
*
REPEAT.EXIT: *
DEL AI.ACTN<1>
*
*@@@*IF STAT EQ 999 THEN RETURN
*
REPEAT
*
IF CNT.TST$RTN THEN PRINT CLB:"Exiting from AI.TALKER.":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF LCK.COM.AI THEN
GOSUB UNLCK.COM.AI
END
*
IF LCK.COM.AIP THEN
GOSUB UNLCK.COM.AIP
END
*
IF CNT.TST$RTN EQ 3 THEN
CALL AI.TALK.VAR.DISPLAY
IF CNT.TST$CR THEN INPUT TMP: ELSE
FOR TST.TMP = ONE TO CNT.TST$PAUSE
RQM
NEXT TST.TMP
END
END
*
*
IF AI.TALK<SENT> AND WKO$STAT # "C" THEN
MSG.N = 27; GOSUB DISP.TXT; * NOW DOING REVERSALS; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
END
*
* IF COM.AI$GENIE.WINDOW EQ "Y" THEN
* ** CALL DISPLAY.SERVICES
* CALL DISPLAY.WORK.ORDER.DETAIL(MAT WOT)
* END
*
RETURN; * to calling program.     @@@
!
* GENERAL FUNCTIONS     @@@
*
TYPE.ERROR: *
RESULT = 99; STAT = 999
MSG.N = 17
GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
RETURN
!
RTN.CHECK.DISPATCHER: * DISPLAY DISPATCHER MESSAGE IF REQUIRED
*
DT = DATE(); TM = TIME()
*
IF AI.TALK<DISPATCHER.MSG> THEN RETURN
*
READ DISP.MSG FROM COM.FILE,"DISP.MSG" THEN
TEXT = EMPTY
TMP = DISP.MSG<ONE>
IF LEN(TMP) THEN
IF DISP.MSG<2> LT DT OR (DISP.MSG<2> EQ DT AND DISP.MSG<3> LE TM) OR (DISP.MSG<2> EQ EMPTY AND DISP.MSG<3> LE TM) THEN
IF DISP.MSG<4> GT DT OR (DISP.MSG<4> EQ DT AND DISP.MSG<5> LE TM) OR (DISP.MSG<4> EQ EMPTY AND DISP.MSG<5> LE TM) THEN
IF NOT(ERR.CLB) THEN ERR.DISP.ONLY = 4 ELSE ERR.DISP.ONLY = FALSE
LOOP WHILE LEN(TMP) DO
IF ERR.CLB THEN
TEXT = TEXT:TMP<ONE,ONE>:" "
END ELSE
TEXT<-ONE> = TMP<ONE,ONE>
END
DEL TMP<ONE,ONE>
REPEAT
ERR.HDR = "Dispatcher Message"
IF LEN(TEXT) THEN
TEXT = MSG<MSG.N,ONE>:AM:TEXT
GOSUB ERROR; * : *
IF NOT(ERR.CLB) THEN CALL DISPLAY.SERVICES; * : *
END; * of text not empty
END; * of not expired
END; * of past effective
END; * of msg text present
END; * of msg on file
*
AI.TALK<DISPATCHER.MSG> = 1
*
RETURN
*
!
RTN.CHECK.INTFC: * DISPLAY ADDRESS INTERFACE MESSAGE IF REQUIRED
*
DT = DATE(); TM = TIME(); LCK.ELP = ZERO; LCK.ELP.MAX = 15
SAVE.COM.AI.ERR.DISP = COM.AI.ERR.DISP
*
** IF AI.TALK<INTERFACE.MSG> THEN RETURN
*
READ INTFC.MSG FROM COM.FILE,"INTFC.MSG.":AI.CODE THEN
TEXT = EMPTY; ERR.DISP.ONLY = 4
TMP = INTFC.MSG<ONE>
IF LEN(TMP) THEN
IF INTFC.MSG<2> LT DT OR (INTFC.MSG<2> EQ DT AND INTFC.MSG<3> LE TM) OR (INTFC.MSG<2> EQ EMPTY AND INTFC.MSG<3> LE TM) THEN
IF INTFC.MSG<4> GT DT OR (INTFC.MSG<4> EQ DT AND INTFC.MSG<5> LE TM) OR (INTFC.MSG<4> EQ EMPTY AND INTFC.MSG<5> LE TM) THEN
LOOP WHILE LEN(TMP) DO
IF ERR.CLB THEN
TEXT = TEXT:TMP<ONE,ONE>:" "
END ELSE
TEXT<-ONE> = TMP<ONE,ONE>
END
DEL TMP<ONE,ONE>
REPEAT
ERR.HDR = "Addressable Interface Message"
IF LEN(TEXT) THEN
TEXT = MSG<MSG.N,ONE>:AM:TEXT
ERR.DISP.ONLY = FALSE
IF ERR.CLB THEN GOSUB ERROR; * : *
* IF NOT(ERR.CLB) THEN CALL DISPLAY.SERVICES; * : *
AI.TALK<INTERFACE.MSG> = 1
END; * of text not empty
END; * of not expired
END; * of past effective
END; * of msg text present
END; * of msg on file
*
!
*
***IF COM.AI$GENIE.WINDOW EQ "Y" OR (CNT.TST$RTN OR CNT.TST$LBL) THEN COM.AI.ERR.DISP = TWO
LCK.ITM = FALSE; LCK.RELS = TRUE
DT = DATE(); TM = TIME(); LCK.ELP = ZERO; LCK.ELP.MAX = 15
*@*LOOP
GOSUB READ.COM.AI; * : *
*@*LCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*@*IF LCK.STAT EQ 999 THEN STAT = 999; RETURN
*@*WHILE LCK.STAT AND LCK.ELP LE LCK.ELP.MAX DO REPEAT
*
***IF COM.AI$GENIE.WINDOW EQ "Y" OR (CNT.TST$RTN OR CNT.TST$LBL) THEN COM.AI.ERR.DISP = TWO; PORTS.LIST.BUILD = 7
GOSUB INTFC.CHECK; * : *
GOSUB INTFC.MESSAGES; * : *
*
** IF LEN(TEXT) AND AI.STATUS THEN
IF AI.STATUS THEN
* AI.TALK<OP.STAT> = AI.STATUS
** AI.TALK<OP.STAT> = NOT(COM.AI.ON AND COM.AI.UP)
AI.TALK<OP.STAT> = AI.STATUS
** AI.TALK<OP.UP>   = FALSE
AI.TALK<OP.UP> = (COM.AI.ON AND COM.AI.UP)
END
*
IF LEN(TEXT) THEN
GOSUB ERROR; * : *
END
*
* IF NOT(ERR.CLB OR ERR.DISP.ONLY) THEN CALL DISPLAY.SERVICES; * : *
*
COM.AI.ERR.DISP = SAVE.COM.AI.ERR.DISP
AI.TALK<INTERFACE.MSG> = 1
*
RETURN
*
!
RTN.INPUT.INSTALLER: * PROMPT CSR TO SEE IF CUSTOMER/INSTALLER AT SITE
*
MSG.N = FN$INPUT.INSTALLER; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<TALKING> = 0
IF TMP EQ "T" THEN AI.TALK<TALKING> = 1
IF TMP EQ "I" THEN AI.TALK<TALKING> = 2
*
RETURN
*
!
RTN.COMPARE.SVC: * LOAD AIW RECORD FOR THIS PORT
*
EQUAL.SERVICES = 1; EQUAL.OUTLETS = 1; NO.DVCS = 1
*
* IF AI.TALK<ADDRESSABLE> NE EMPTY THEN RETURN
*
WKO.VC = 1; AIX.SV = 1
IF AI.TALK<OP.MULTI> THEN AIX.VC = AI.TALK<OP.MULTI> ELSE AIX.VC = 1
*
LOOP
*
WKO.ACTIV = WKO$ACTIVS<1,WKO.VC>
*
*27MAR94*IF INDEX("AHS",WKO.ACTIV,1) THEN
IF WKO.ACTIV EQ "S" THEN
*
SVC.FOUND = TRUE
IF AIX.ID NE "" THEN
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN DVC$SERVICE<1,AIX.VC> SETTING LOC ELSE SVC.FOUND = FALSE
END ELSE
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN COM.AI$DF.SVCS.ONE<1,DVC.LOC> SETTING LOC ELSE SVC.FOUND = FALSE
END
*
IF SVC.FOUND THEN
*
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN ACT$SERVICES<1> SETTING TMP1 THEN TMP = ACT$QNTYS<1,TMP1> ELSE TMP = 0
*
IF AIX.ID NE "" THEN
*
IF AI.TALK<OP.MULTI> THEN 
IF TMP NE DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC> THEN EQUAL.OUTLETS = 0
END ELSE
IF WKO$ACTIV.QNTYS<1,WKO.VC> LT 0 THEN
IF (NOT(DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC> + WKO$ACTIV.QNTYS<1,WKO.VC> = 0)) THEN EQUAL.OUTLETS = 0
END ELSE
IF (TMP NE DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC>) THEN EQUAL.OUTLETS = 0
END
END
*
END ELSE
NULL; * OUTLETS OK ON ADDRESSABLE (?CHECK ADD?)
END
*
END ELSE
EQUAL.SERVICES = 0
END
*
END; * OF ACTIV AHS
*
WKO.VC = WKO.VC + ONE
UNTIL WKO$ACTIVS<1,WKO.VC> EQ EMPTY OR NOT(EQUAL.SERVICES AND EQUAL.OUTLETS) DO REPEAT
*
IF COUNT(WKO$ACTIVS,"W") THEN EQUAL.OUTLETS = 0
IF COUNT(WKO$ACTIVS,"I") THEN NO.DVCS = 0
*
*SCDR ARE OK
IF NOT(INDEX("MTL",WOF,ONE)) THEN
IF AI.TALK<AI.DVC.NEXT> AND AI.TALK<AI.DVC.IDS> NE EMPTY THEN
IF WKO$STAT NE "P" OR EQUAL.OUTLETS THEN AI.TALK<DO.SEND> = TRUE ELSE AI.TALK<PRINT.WO> = TRUE
END ELSE IF AIX.ID NE EMPTY THEN
* IF EQUAL.SERVICES AND EQUAL.OUTLETS AND NO.DVCS THEN AI.TALK<ADDRESSABLE> = AIX.ID ELSE AI.TALK<PRINT.WO> = TRUE
IF (EQUAL.SERVICES AND EQUAL.OUTLETS AND NO.DVCS) THEN AI.TALK<DO.SEND> = TRUE ELSE AI.TALK<PRINT.WO> = TRUE
END ELSE AI.TALK<PRINT.WO> = TRUE
END; * of wof
*
RETURN
*
!
* DISC PROCESSING     @@@
*
RTN.INPUT.DISC: * DEACTIVATE SERVICES NOW?
*
MSG.N = FN$INPUT.DISC; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
*
RETURN
*
!
RTN.VERIFY.DISC: * HAVE SERVICES BEEN STOPPED OK?
*
MSG.N = FN$VERIFY.DISC; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.COLD> = 0; AI.TALK<SENT> = 0;  RETURN
IF TMP EQ "Y" THEN AI.TALK<VERIFIED.COLD> = 1
*
RETURN
*
!
RTN.REQRD.WO.DISC: * This address will require a premise call
*
MSG.N = FN$REQRD.WO.DISC; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
RETURN
*
!
*
RTN.INPUT.COLL: * Do you want to perform a collection on the devices?
*
MSG.N = FN$INPUT.COLL; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.COLL> = ONE ELSE AI.TALK<DO.COLL> = TWO
*
RETURN
*
!
RTN.INPUT.PREV.TNT: * DEACTIVATE SERVICES OF PRIOR TENANT NOW?
*
MSG.N = FN$INPUT.PREV.TNT; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
*
RETURN
*
!
RTN.INPUT.PREV.ADDR: * DEACTIVATE SERVICES AT PRIOR ADDRESS NOW?
*
MSG.N = FN$INPUT.PREV.ADDR; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
*
RETURN
*
!
* CONN PROCESSING     @@@
*
RTN.INPUT.WO: * DO YOU WANT TO ACTIVATE THE OP SERVICES?
MSG.N = FN$INPUT.WO; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
*
RETURN
!
RTN.VERIFY.SVC: * ARE SERVICES BEING RECEIVED OK AT THIS ADDRESS?
MSG.N = FN$VERIFY.SVC; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.HOT> = 0; AI.TALK<SENT> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<VERIFIED.HOT> = 1
*
RETURN
!
RTN.INPUT.TRY: * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
MSG.N = FN$INPUT.TRY; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1; RETURN
IF TMP EQ "N" THEN AI.TALK<DO.SEND> = 0
*
RETURN
!
P9.ACTIVATING.PLS.WAIT: * ACTIVATING SERVICES. PLEASE WAIT...
MSG.N = 9; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
RETURN
*
!
*
Q9.ACTIVATE.SERVICES: * ACTIVATE SERVICES.
*
IF LEN(AI.TALK<AI.DVC.IDS>) THEN
IF AI.TALK<AI.DVC.NEXT> THEN
*
*
LOOP
*
SAVE.AI.DVC.NEXT = AI.TALK<AI.DVC.NEXT>
AI.DVC.NEXT.MAX = DCOUNT(AI.TALK<AI.DVC.IDS>,VM)
LCK.RELS = FALSE
*
FOR AI.DVC.NEXT.CN = ONE TO AI.DVC.NEXT.MAX
AI.TALK<AI.DVC.NEXT> = AI.DVC.NEXT.CN
IF AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>> NE EMPTY THEN
IF AI.TALK<OP.UP> THEN
DVC.ID = AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>>
MATREAD DVC FROM DVC.FILE,DVC.ID THEN
*
*
IF AI.TALK<AI.DVC.DIR,AI.TALK<AI.DVC.NEXT>> GE ZERO THEN
GOSUB ACTIVATE.SERVICES; * : *
*@@@*GOSUB WRITE.COMMAND; * : *
*@@@*GOSUB ATTEMPT.COMMAND; * : *
END ELSE
GOSUB DEACTIVATE.SERVICES; * : *
*@@@*GOSUB WRITE.COMMAND; * : *
*@@@*GOSUB ATTEMPT.COMMAND; * : *
END
*
END ELSE PRINT CLB:DVC.ID:" is missing!!!":
END ELSE PRINT CLB:"Interface is not UP!":
END ELSE PRINT CLB:"Interface table is corrupt!":
NEXT AI.DVC.NEXT.CN
*
LCK.RELS = TRUE
GOSUB ATTEMPT.COMMAND; * : *
*
IF STAT EQ 999 THEN RETURN
*
*
UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
*
*
AI.DVC.NEXT.CN = ONE
LCK.ELP = ZERO; LCK.ELP.MAX = 10; LCK.RELS = TRUE
GOSUB READ.COM.AIP; * : *
AI.TALK<AI.DVC.NEXT> = SAVE.AI.DVC.NEXT
DVC.ID = AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>>
MATREAD DVC FROM DVC.FILE,DVC.ID ELSE PRINT CLB:DVC.ID:" is missing!!!":
*
END
*
END
*
*
RETURN
*
!
*
Q10.CONFIRM.WO: * CONFIRM THE WORK ORDER?
*
RETURN
*
MSG.N = 10; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN
* IF (WOF EQ "C" OR WOF EQ "R") THEN
* IF AI.TALK<TALKING> THEN
* GOSUB DEACTIVATE.SERVICES
* GOSUB RTN.VERIFY.DISC; * : *
* IF NOT(AI.TALK<VERIFIED.HOT>) THEN
* LOOP
* GOSUB DEACTIVATE.SERVICES; * : *
* IF NOT(AI.TALK<VERIFIED.COLD>) THEN GOSUB Q16.SEND.AGAIN; * : *
* UNTIL AI.TALK<VERIFIED.COLD> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
* END
* IF WOF EQ "D" THEN
* END
* IF WOF EQ "S" THEN
* END
* IF NOT(AI.TALK<VERIFIED.COLD>) THEN GOSUB RTN.REQRD.WO.DISC; * : *
* END ELSE
* IF NOT(AI.TALK<VERIFIED.CHANGED>) THEN GOSUB RTN.REQRD.WO.DISC; * : *
* END
* END
STAT = 999
RETURN
END
*
RETURN
!
Q11.DO.CHANGE: * DO A SERVICE CHANGE?
MSG.N = 11; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN RETURN
IF TMP EQ "Y" THEN
TMP<1> = "S"
CALL MAINT.WORK.ORDER
RETURN
TMP = ""
END
*
RETURN
!
Q12.SERVICES.AS.IS: * WILL THERE BE A CHANGE TO OP SERVICES?
MSG.N = 12; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF INDEX("RC",WOF,1) AND (TMP EQ EMPTY OR TMP EQ "N") THEN AI.TALK<BUILD.WO> = 1; RETURN
IF AIX.ID NE EMPTY AND TMP EQ "Y" THEN AI.TALK<PRINT.WO> = TRUE; RETURN
*
RETURN
!
P13.DEACTIVATING.PLS.WAIT: * DEACTIVATING SERVICES. PLEASE WAIT...
MSG.N = 13; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
RETURN
!
* Q32.RETRY.ACTIVATE: * RETRY ACTIVATING SERVICES
* MSG.N = 32; GOSUB DISP.TXT; * : *
* IF TMP EQ "KILL" THEN STAT = 999; RETURN
* IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
* IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
* *
* RETURN
!
Q16.SEND.AGAIN: * ACTIVATE/DEACTIVATE WAS NOT SUCCESSFUL. SEND AGAIN?
MSG.N = 16; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
*
RETURN
!
P25.RESCHEDULE.WO: * THE WORK ORDER MUST BE RESCHEDULED
MSG.N = 25; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
WKO$SCH.TYPE = ""
WKO$SCH.DATE = ""
*
RETURN
!
P19.CHANGING.PLS.WAIT: *
MSG.N = 19; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
RETURN
!
Q20.CHANGED: *
MSG.N = 20; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.CHANGED> = 0; AI.TALK<SENT> = 0;  RETURN
IF TMP EQ "Y" THEN AI.TALK<VERIFIED.CHANGED> = 1
*
RETURN
!
P23.VERIFY.SERVICES: * PLEASE CHECK CURRENT SERVICES RECEIVED OK.
MSG.N = 23; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
RETURN
!
P24.ENTER.MAINT.WO: *
MSG.N = 24; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
*
RETURN
!
DISP.TXT: * DISPLAY MSG AND PROMPT 'ENTER <cr>' IF DO.PROMPT
LOOP
CONT = FALSE; TMP = EMPTY
PRINT CLB:"[    ]":RVB:MSG<MSG.N,ONE>:RVE:
IF MSG<MSG.N,TWO> THEN
INPUT TMP:
IF TMP EQ "KILL" THEN STAT = 999; RETURN
TMP1 = TMP
IF TMP1 EQ EMPTY THEN TMP1 = "NUL"
LOCATE TMP1 IN MSG<MSG.N,3> SETTING TMP2 ELSE CONT = TRUE
END
WHILE CONT DO PRINT BELL: REPEAT
*
RETURN
!
CONFIRM.WKO: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering CONFIRM.WKO":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
RETURN
*
IF WOF # "D" AND WKO$EFF.DATE LT DATE() THEN WKO$EFF.DATE = DATE()
IF TYPE # 81 AND WOF EQ "D" THEN WKO$EFF.DATE = DATE() ELSE WKO$EFF.DATE = DATE()+1
WKO$STAT = "C"
WKO$INSTALLER = "!AI"
IF TYPE[1,1] = 8 THEN OPER = "!AI"
WKO$OPERATOR = WKO$OPERATOR:"*":OPER
WKO$COMPL.DATE = DATE()
IF WOF EQ "D" THEN ADD$STAT = "C"; ADD$HOT.OUTLETS = 0; WKO$TYPE = "SS" ELSE
* 9JUL91 IF WOF NE "R" THEN
* A PENDING OR FROM AI.SEND.WKO
IF TYPE[1,1] = 8 OR ACT$SERVICES = "" THEN
MAT SAVE.ACT = MAT ACT
IF TYPE = 82 OR TYPE = 91 THEN CALL DISPLAY.WORK.ORDER.CALCS
END
END
MAT SAVE.ACT = MAT ACT
RSP = "C"; CALL CONFIRM.WORK.ORDER
CALL UPDATE.FILES; RSP = "S"; CALL DISPLAY.BASIC.DATA; CALL DISPLAY.SERVICES; AI.TALK<WKO.STAT> = "C"; RSP = "C"
LOOP UNTIL UPDATED = EMPTY DO
ITEM.NAME = UPDATED<ONE>
POS = INDEX(ITEM.NAME,"*",ONE)
FILE.NAME = ITEM.NAME[ONE,POS - ONE]
ITEM.NAME = ITEM.NAME[POS + ONE,999]
CALL SYS.ITM.RLS(FILE.NAME,ITEM.NAME,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
DEL UPDATED<ONE>
REPEAT
RETURN
*
!
*
ACTIVATE.SERVICES: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering ACTIVATE.SERVICES":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF AI.TALK<IMPULSE.PPV> OR AI.TALK<PAY.PER.VIEW> THEN
IF NOT(AI.TALK<DO.COLL>) THEN
GOSUB RTN.INPUT.COLL; * : *
END
END
*
*
AI.CNTRL.NUM = ONE
HANDLER.COMMAND = "AIDVC"
*
IF AI.TALK<DO.COLL> EQ ONE THEN
*
IF AI.TALK<IMPULSE.PPV> THEN
HANDLER.COMMAND<ONE,-ONE> = "IVI"
*
END ELSE IF AI.TALK<PAY.PER.VIEW> THEN
HANDLER.COMMAND<ONE,-ONE> = "PVI"
*
END
*
END; * of do.coll
*
***
*
GOSUB WRITE.COMMAND; * : *
***GOSUB ATTEMPT.COMMAND; * : *
*
RETURN
*
!
*
DEACTIVATE.SERVICES: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Entering DEACTIVATE.SERVICES":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF AI.TALK<IMPULSE.PPV> OR AI.TALK<PAY.PER.VIEW> THEN
IF NOT(AI.TALK<DO.COLL>) THEN
GOSUB RTN.INPUT.COLL; * : *
END
END
*
*
AI.CNTRL.NUM = TWO
HANDLER.COMMAND = "AIDVC"
*
IF AI.TALK<DO.COLL> EQ ONE THEN
*
IF AI.TALK<IMPULSE.PPV> THEN
HANDLER.COMMAND = "IVD":VM:HANDLER.COMMAND
*
END ELSE IF AI.TALK<PAY.PER.VIEW> THEN
HANDLER.COMMAND = "PVD":VM:HANDLER.COMMAND
*
END
*
END; * of do.coll
*
***
*
GOSUB WRITE.COMMAND; * : *
***GOSUB ATTEMPT.COMMAND; * : *
*
RETURN
*
!
*
SEND.CHANGE: *
*
DVC.CHECK.FUNC = "WKO"
$INCLUDE IBP KBIL.INCL.DVC.CHECK.TYPE
*
* TMP.ID = AI.TALK<ADDRESSABLE>
* IF TMP.ID EQ EMPTY THEN TMP.ID = AIX.ID
* LOCATE TMP.ID IN AI.TALK<AI.DVC.IDS> SETTING DVC.LOC THEN
*
IF LEN(AI.TALK<AI.DVC.IDS>) THEN
IF AI.TALK<AI.DVC.NEXT> THEN
IF AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>> NE EMPTY THEN
IF AI.TALK<OP.UP> THEN
DVC.ID = AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>>
MATREAD DVC FROM DVC.FILE,DVC.ID THEN
*
*
LOOP
DVC.LOC = AI.TALK<AI.DVC.NEXT>
AI.DVC.NEXT.CN = ONE
LCK.RELS = TRUE
*@@@*GOSUB SEND.CHANGE.CONT; * : *
IF AI.TALK<AI.DVC.DIR,AI.TALK<AI.DVC.NEXT>> GE ZERO THEN
GOSUB ACTIVATE.SERVICES; * : *
*@@@*GOSUB WRITE.COMMAND; * : *
*@@@*GOSUB ATTEMPT.COMMAND; * : *
END ELSE
GOSUB DEACTIVATE.SERVICES; * : *
*@@@*GOSUB WRITE.COMMAND; * : *
*@@@*GOSUB ATTEMPT.COMMAND; * : *
END
LCK.RELS = TRUE
GOSUB ATTEMPT.COMMAND; * : *
IF STAT EQ 999 THEN RETURN
UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
*
*
END ELSE PRINT CLB:DVC.ID:" is missing!!!":
END; * not up
END ELSE PRINT CLB:"Device pointer is wrong!!!":
END ELSE PRINT CLB:"No pointer to device!!!":
END ELSE PRINT CLB:"No devices found!!!":
*
IF LCK.RELS THEN
IF LCK.COM.AI THEN GOSUB UNLCK.COM.AI; * : *
END
*
RETURN
*
!
*
SEND.CHANGE.CONT: *
*
IF DVC.LOC THEN
*
LOOP
*
AI.CNTRL.NUM = 3
HANDLER.COMMAND = "AIDVC"
*
IF AI.TALK<AI.DVC.IPPV,DVC.LOC> THEN
IF AI.TALK<IMPULSE.PPV> THEN
HANDLER.COMMAND<ONE,-ONE> = "IVI"
END ELSE
HANDLER.COMMAND = "IVD":VM:HANDLER.COMMAND
END
END
*
IF AI.TALK<AI.DVC.PPV,DVC.LOC> THEN
IF AI.TALK<PAY.PER.VIEW> THEN
HANDLER.COMMAND<ONE,-ONE> = "PVI"
END ELSE
HANDLER.COMMAND = "PVD":VM:HANDLER.COMMAND
END
END
*
****END; * OF LOCATE
*
GOSUB WRITE.COMMAND; * : *
GOSUB ATTEMPT.COMMAND; * : *
IF STAT EQ 999 THEN RETURN
*
UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
*
END; * OF LOCATE
*
RETURN
*
!
*
BUILD.WKO: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering BUILD.WKO":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF WKO$ACTIV.SERVICES<1,1> NE "" THEN RETURN
AIX.VC = ADD$AIX.LOCATION; IF AIX.VC = "" THEN AIX.VC = 1
IF DVC$SERVICE<1,AIX.VC> NE "" THEN
AI.TALK<BUILD.WO> = 1; AIX.SV = 1; WKO.VC = 1
LOOP SVC.ID = DVC$SERVICE<1,AIX.VC,AIX.SV> UNTIL SVC.ID EQ EMPTY DO
IF NOT(WKO.VC EQ 1) THEN WKO$ACTIVS<1,WKO.VC> = WKO$ACTIVS<1,WKO.VC>:"!S"
WKO$ACTIV.SERVICES<1,WKO.VC> = WKO$ACTIV.SERVICES<1,WKO.VC>: "!":SVC.ID
WKO$ACTIV.QNTYS<1,WKO.VC> = WKO$ACTIV.QNTYS<1,WKO.VC>: "!":DVC$CONNECTED.OUTLETS<1,AIX.VC,AIX.SV>
AIX.SV = AIX.SV+1; WKO.VC = WKO.VC+1
REPEAT
END
RETURN
*
!
*
ATTEMPT.COMMAND: *
IF CNT.TST$LBL THEN PRINT CLB:"Attempt Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
IF AI.CNTRL.NUM EQ ONE THEN
AI.CNTRL.CHECK = VERIFIED.HOT
END ELSE IF AI.CNTRL.NUM EQ TWO THEN
AI.CNTRL.CHECK = VERIFIED.COLD
END ELSE IF AI.CNTRL.NUM EQ 3 THEN
AI.CNTRL.CHECK = VERIFIED.CHANGED
END ELSE
AI.CNTRL.NUM = 4
AI.CNTRL.CHECK = VERIFIED.CHANGED
END
*
***LOOP
*
ON AI.CNTRL.NUM GOSUB P9.ACTIVATING.PLS.WAIT,P13.DEACTIVATING.PLS.WAIT,P19.CHANGING.PLS.WAIT,P19.CHANGING.PLS.WAIT; * : *
*
* 1 ACTIVATING SERVICES. PLEASE WAIT . . . 
* 2 DEACTIVATING SERVICES
* 3 CHANGING SERVICES
* 4 UNKNOWN (USE CHANGE)
*
AI.TALK<SENT> = FALSE; AI.STATUS = FALSE; SEND.STATUS = FALSE
SAVE.COM.AI.ERR.DISP = COM.AI.ERR.DISP
*@@@*GOSUB WRITE.COMMAND; * : *
LCK.RELS = TRUE
IF LCK.RELS THEN
IF LCK.COM.AI THEN GOSUB UNLCK.COM.AI; * : *
END
*
IF NOT(AI.STATUS OR SEND.STATUS) THEN
IF COM.AI$GENIE.WINDOW EQ "Y" OR (CNT.TST$RTN OR CNT.TST$LBL) THEN COM.AI.ERR.DISP = TWO; PORTS.LIST.BUILD = 7
WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND; * : *
IF NOT(AI.STATUS OR SEND.STATUS) THEN AI.TALK<SENT> = TRUE
END
*
*
IF COM.AI$GENIE.WINDOW EQ "Y" OR NOT(AI.TALK<SENT>) THEN
PORTS.LIST.BUILD = 8
GOSUB INTFC.CHECK; * : *
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES; * : *
* ERR.HDR = "Interface Messages"
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; * : *
END
*
*
*
IF NOT(AI.TALK<SENT>) THEN 
*
*
GOSUB Q16.SEND.AGAIN; * NOT SUCCESSFUL, SEND AGAIN?; * : *
*
IF STAT EQ 999 THEN RETURN
*
*
END ELSE
*
*
IF AI.TALK<TALKING> THEN
*
ON AI.CNTRL.NUM GOSUB RTN.VERIFY.SVC,RTN.VERIFY.DISC,Q20.CHANGED,Q20.CHANGED; * : *
*
IF STAT EQ 999 THEN RETURN
*
* ARE SERVICES BEING RECEIVED OK?
* HAVE SERVICES BEEN STOPPED?
* HAVE SERVICES BEEN CHANGED OK?
*
IF NOT(AI.TALK<AI.CNTRL.CHECK>) THEN GOSUB Q16.SEND.AGAIN; * : *
*
END
*
END
*
IF STAT EQ 999 THEN RETURN
*
***UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO
**GOSUB WRITE.COMMAND
***REPEAT
*
COM.AI.ERR.DISP = SAVE.COM.AI.ERR.DISP
*
RETURN
*
!
*
WRITE.COMMAND: *
IF CNT.TST$LBL THEN PRINT CLB:"Write Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
* @@@ COM.AIP REC LOAD
*
HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
OPT.DT = DATE(); OPT.TM = TIME()
DT = OPT.DT; TM = OPT.TM
OPT.ORIG.SVC.ID = DVC$SERVICE
OPT.COMM = HANDLER.COMMAND
AI.STATUS = FALSE; SEND.STATUS = FALSE
*21MAR94*
IF STAT THEN RETURN
*21MAR94*^
*
*@@@@*LCK.ITM = TRUE; LCK.RELS = TRUE 
LCK.ITM = TRUE; LCK.RELS = FALSE
LCK.ELP = ZERO; LCK.ELP.MAX = 30
LOOP
GOSUB READ.COM.AI; * : *
LCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
* WHILE LCK.STAT AND LCK.STAT NE 998 AND LCK.ELP LE LCK.ELP.MAX DO REPEAT
WHILE LCK.STAT AND LCK.STAT NE 998 AND LCK.ELP LE LCK.ELP.MAX DO REPEAT
*
IF LCK.STAT EQ 998 THEN
MSG.N = 28; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
END ELSE
IF LCK.STAT THEN
MSG.N = 29; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF RSP EQ "Y" THEN STAT = FALSE; GOTO WRITE.COMMAND; * : *
SEND.STATUS = LCK.STAT; STAT = 999
END
*
IF NOT(STAT) THEN
*
MAT COM.AIP = EMPTY
*
$INCLUDE IBP AI.LOAD.COM.AIP.TIERS
$INCLUDE IBP AI.LOAD.COM.AIP
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
*
CALL AI.SUBR.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,LCK.RELS,SYS.PROG,STAT)
* LCK.RELS = TRUE
* IF AI.STATUS EQ 999 THEN STAT = AI.STATUS; RETURN
* IF SEND.STATUS EQ 999 THEN STAT = SEND.STATUS; RETURN
*
END; * OF STAT
*
END; * OF LCK.STAT 998
*
IF LCK.RELS THEN
IF LCK.COM.AI THEN GOSUB UNLCK.COM.AI; * : *
END
*
IF AI.STATUS EQ 999 THEN STAT = AI.STATUS; RETURN
IF SEND.STATUS EQ 999 THEN STAT = SEND.STATUS; RETURN
*
RETURN
*
!
*
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT CLB:"WAIT FOR COMMAND":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
DT = DATE(); TM = TIME(); LCK.ELP = ZERO; LCK.ELP.MAX = 10
*
*INCLUDE IBP AI.INCL.WAITFOR.COMMAND
CALL AI.SUBR.WAITFOR.COMMAND(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
LOCATE ERR$NO.UNIT IN COM.AIP$INTFC.ERR<ONE> SETTING TMP THEN
TMP = FIELD(AIX.ID,"*",2); * NO SUCH SERIAL NUMBER
MSG<30,ONE> = TMP:MSG<26,ONE>
MSG.N = 30; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
MSG<30,ONE> = EMPTY
END
*
RETURN
*
!
*
READ.COM.AIP: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com AIP":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
$INCLUDE IBP AI.READ.COM.AIP
*
RETURN
*
!
*
UNLCK.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Unlock Com Ai" "L#19":RVE:; RQM
*
IF LCK.COM.AI THEN
COM.AI.ID = "AI.TYPE.":AI.CODE
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
LCK.COM.AI = FALSE
END
*
RETURN
*
!
*
UNLCK.COM.AIP: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Unlock Com AIP" "L#19":RVE:; RQM
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"C","",LCK.STAT)
LCK.COM.AIP = FALSE
END
*
RETURN
*
!
*
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
COM.AI.NOT.ON.FILE = FALSE
HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
*
$INCLUDE IBP AI.INCL.LOAD.CODE
*
IF AI.CODE EQ EMPTY THEN
COM.AI.NOT.ON.FILE = TRUE
READ MSG FROM COM.FILE,"AI.TALKER.MSGS.":EQUIP.TYPE ELSE MSG = EMPTY
MSG<30,ONE> = MSG<31,ONE>:HEADEND
MSG.N = 30; GOSUB DISP.TXT; * : *
IF TMP EQ "KILL" THEN STAT = 999; RETURN
MSG<30,ONE> = EMPTY
*
RETURN
* STAT WOULD OTHERWISE BE SET TO 998 ON COM.AI, COM.AIP READS
END
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
*
DVC.TYPE = DVC$TYPE
*
!
*
COM.AI.ID = "AI.TYPE.":AI.CODE
* LCK.ITM = TRUE; LCK.RELS = TRUE
SAVE.DISP.ONLY = DISP.ONLY; DISP.ONLY = FALSE
*
$INCLUDE IBP AI.READ.COM.AI
*
COMMPORT = COM.AI$COMMPORT; AI.TYPE = COM.AI.ID:VM:COM.AI$DB.PREFIX
!
*
LOCATE DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
*
 EQUIP.TYPE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
*
READ MSG FROM COM.FILE,"AI.TALKER.MSGS.":EQUIP.TYPE ELSE
PRINT CLB:"Can't find COM AI.TALKER.MSGS.":EQUIP.TYPE
STAT = 999
RETURN
END
*
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":EQUIP.TYPE ELSE MAT COM.AIIERR = EMPTY
*
*
DISP.ONLY = SAVE.DISP.ONLY
*
IF COM.AI$GENIE.WINDOW EQ "Y" THEN
***COM.AI.ERR.DISP = TWO
***PORTS.LIST.BUILD = 8
ERR.CLB = FALSE
ERR.LN.MIN = TWO; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CL = 43; ERR.LEN = 36
ERR.DISP.ONLY = 3
END ELSE
IF (CNT.TST$RTN OR CNT.TST$LBL) THEN COM.AI.ERR.DISP = TWO ELSE COM.AI.ERR.DISP = FALSE
END
*
RETURN
!
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Check Handler":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
TEXT = EMPTY; OUTPUTS = EMPTY
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
LCK.ELP.MAX = 10
*
*INCLUDE IBP AI.INCL.INTFC.CHECK
CALL AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,CHECK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
IF COM.AI.ON THEN AI.TALK<OP.UP> = COM.AI.UP ELSE AI.TALK<OP.UP> = FALSE
* AI.TALK<OP.STAT> = AI.STATUS
AI.TALK<OP.STAT> = NOT(COM.AI.ON AND COM.AI.UP)
*
RETURN
*
!
WRITE.LOG: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Write Log":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF LOG.REQUIRED THEN
*INCLUDE IBP AI.INCL.WRITE.LOG
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.AIP.ID,AI.CODE,AI.SRCE,LOG.REQUIRED,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PROG,STAT)
LOG.REQUIRED = FALSE
END
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN
*
!
*
ERROR: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Error Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
*INCLUDE IBP SYS.INCL.ERROR
CALL SYS.SUBR.ERROR(TEXT,ERR.LN.MIN,ERR.LN.MAX,ERR.LN.HI,ERR.CL,ERR.LN,ERR.LEN,ERR.CLS,ERR.CLB,ERR.HDR,ERR.FMT,ERR.CR,ERR.BELL,ERR.DISP.ONLY,STAT)
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
!
*
RETURN
!
END
~AI.TEST.LRC~
*PROGRAM: AI.TEST.LRC
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
*
INPUT LBL.DISP:
*
IF NOT(NUM(LBL.DISP)) THEN LBL.DISP = FALSE
10 *
*
INPUT TC.PACKET
PRINT
PRINT TC.PACKET
*
IF TC.PACKET EQ EMPTY THEN STOP
*
$INCLUDE IBP SYS.INCL.CALC.LRC
*
PRINT ">>":TC.HEX:"<<"
PRINT
GOTO 10
*
END
~AI.TEST.XOR~
*PROGRAM: AI.TEST.XOR
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   1990         ALL RIGHTS RESERVED
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
*
INPUT CNT.TST$LBL:
*
IF NOT(NUM(CNT.TST$LBL)) THEN CNT.TST$LBL = FALSE
10 *
*
INPUT TC.PACKET
PRINT
PRINT TC.PACKET
*
IF TC.PACKET EQ EMPTY THEN STOP
*
$INCLUDE IBP SYS.INCL.CALC.XOR.COMPL
*
PRINT ">>":TC.HEX:"<<"
PRINT
GOTO 10
*
END
~AI.UPD.AIX.PA~
SUBROUTINE AI.UPD.AIX.PA(SYS.PRNT)
* VERSION: 940412 1.1  REMOVED AI PROCESSING FOR IVI AND IVD.
* PROGRAM:      AI.UPD.AIX.PA
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
* DESCRIPTION: Update the AIX file and send a terminal transaction to the
*              Pioneer Addressable Interface.
*
* AUTHOR:       H HORSMAN - AXION
*               NOTES:
*               1. RSP 'R' IS A CANCELLED DISCONNECT WORK ORDER.
*
!
$INCLUDE IBP GENERAL.COMMON.AREA
*INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
EQU VERSION TO "(1.1)"
VS = VERSION
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.UPD.AIX.PA"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP CNT.TST.EQUATES
*
*
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP WKO.EQUATES
!
AI.CODE = AI.TYPE<1>; AI.SUFFIX = AI.TYPE<2>
*
CONTROL.DT = CO.DATA<2>
LCK.TYPE = -3; DT = DATE(); TM = TIME()
*
IF WKO(33) EQ "@A" OR WKO(33) = "@R" THEN ACTIV.TRANSFER = 1 ELSE ACTIVE.TRANSFER = 0
*
GOSUB LOAD.TST
*
IF CNT.TST$RTN THEN PRINT @(60,20):"Entering AI.UPD.AIX.PA"; IF CNT.TST$CR THEN PRINT CLB:"Enter <cr>: ":; INPUT TMP:
*
!
BEGIN: *
*
*
LOCATE DVC.ID IN WKO$DVC.IDS<1> SETTING VC THEN
IF WKO$ACTIV.QNTYS LT 0 THEN
STOP.DATE = WKO$EFF.DATE; START.DATE = ""
END ELSE
START.DATE = WKO$EFF.DATE; STOP.DATE = ""
END
*
* Update AIX record
*
LOOP
LCK.STAT = -3
CALL SYS.ITM.LCK("AIX",AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"A","",LCK.STAT)
WHILE LCK.STAT DO REPEAT
*
MATREAD AIX FROM AIX.FILE,DVC.ID ELSE MAT AIX = ""
*
INS ACT.ID         BEFORE AIX$ACT.ID<1,1>
INS ACCT           BEFORE AIX$CO<1,1>
INS START.DATE     BEFORE AIX$START.DATE<1,1>
INS STOP.DATE      BEFORE AIX$STOP.DATE<1,1>
INS AI.CODE        BEFORE AIX$AI.CODE<1,1>
INS GROUP          BEFORE AIX$GROUP<1,1>
END
*
DEL AIX$ACT.ID<1,11>
DEL AIX$CO<1,11>
DEL AIX$START.DATE<1,11>
DEL AIX$STOP.DATE<1,11>
DEL AIX$AI.CODE<1,11>
DEL AIX$GROUP<1,11>
*
MATWRITE AIX ON AIX.FILE,DVC.ID
*
CALL SYS.ITM.RLS("AIX",DVC.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,SYS.PRNT,"B","",LCK.STAT)
*
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
!
END
~AI.UPD.CNT.AIP~
SUBROUTINE AI.UPD.COM.AIP (LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS)
*
EQU VS TO "901028 NEW"
*              Eagle addressable interface HANDLER.
*
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP TST.EQUATES
EQU TST$AM TO 12, TST$VM TO 9
VERSION = VS
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
!
$INCLUDE IBP AI.STATUS.VAR.EQUATES
!
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
AIX.UPDATE: * Update addressable interface file - AIX
*
LOOP
*
LCK.TYPE = 3
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
WHILE LCK.STAT DO REPEAT
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
BEGIN CASE
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "DONE"
COM.AIP$INTFC.STAT = "COMP":VM:COM.AIP$INTFC.STAT
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "WAIT"
COM.AIP$ERR = 371:VM:COM.AIP$ERR
COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
AI.STATUS = TRUE
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "RVRS"
COM.AIP$INTFC.STAT = "XCEL":VM:COM.AIP$INTFC.STAT
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "COMP"
NULL
*
CASE COM.AIP$INTFC.STAT<ONE,ONE> EQ "XCEL"
NULL
*
CASE TRUE
*
END CASE
*
IF NOT(AI.STATUS) THEN
AI.STATUS = COM.AIP$ERR<ONE,ONE>
IF AI.STATUS EQ ERR$NOT.SENT THEN AI.STATUS = FALSE
END
*
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
END ELSE NULL
*
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
*
*
RETURN
*
END
~AI.UPD.COM.AIP~
XSUBROUTINE AI.UPDT.COM.AIP(LCK.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,SEND.COMM.CN,STAT)
* CALLED BY AI.CONTROL.UTILITY
EQU VS TO "901028 NEW"
*              Eagle addressable interface HANDLER.
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
*
$INCLUDE IBP TST.EQUATES
EQU TST$AM TO 12, TST$VM TO 9
VERSION = VS
SYS.PROG = "AI.UPDT.COM.AIP"
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
*
AIX.UPDATE: * Update addressable interface file - AIX
*
LCK.ITM = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
COM.AIP.PORT = FIELD(COM.AIP.ID,"*",3)
IF NUM(COM.AIP.PORT) THEN COM.AIP.PORT = COM.AIP.PORT + 0
SEND.COMM.CN.MAX = DCOUNT(COM.AIP$COMM,VM)
*
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND ELP LT 300 DO REPEAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
*
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID THEN
*
BEGIN CASE
*
CASE LCK.STAT OR ELP GE 300
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS "RVRS" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN,ONE> = PORT
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "DONE"
INS "COMP" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
*COM.AIP$COMM.PORT<ONE,SEND.COMM.CN,ONE> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "WAIT"
IF PORT EQ COM.AIP.PORT THEN
INS ERR$TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END ELSE
INS ERR$CHECK.TOUT BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
END
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS 604 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN,ONE> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "RVRS"
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN,ONE> EQ EMPTY THEN
* IF I AM THE HANDLER PORT THEN
INS "XCEL" BEFORE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE>
INS SYS.PROG BEFORE COM.AIP$INTFC.SET.BY<ONE,SEND.COMM.CN,ONE>
COM.AIP$COMM.PORT<ONE,SEND.COMM.CN,ONE> = EMPTY; COM.AIP$COMM.C.DT = DT; COM.AIP$COMM.C.TM = TM
END
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "COMP"
NULL
*
CASE COM.AIP$INTFC.STAT<ONE,SEND.COMM.CN,ONE> EQ "XCEL"
NULL
*
CASE TRUE
INS 606 BEFORE COM.AIP$INTFC.ERR<ONE,SEND.COMM.CN,ONE>
INS ERR$HANDLER.ERR BEFORE COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
*
END CASE
*
IF COM.AIP$ERR<ONE,SEND.COMM.CN,ONE> THEN
AI.STATUS = COM.AIP$ERR<ONE,SEND.COMM.CN,ONE>
* IF AI.STATUS EQ ERR$NOT.SENT THEN AI.STATUS = FALSE
END
*
IF COM.AIP$INTFC.ERR<ONE,ONE,ONE> NE EMPTY THEN
SEND.STATUS = COM.AIP$INTFC.ERR<ONE,ONE,ONE>
IF SEND.STATUS EQ ERR$NOT.SENT THEN SEND.STATUS = FALSE
IF PORT EQ COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$CHECK.TOUT THEN SEND.STATUS = FALSE
END
IF PORT NE COM.AIP.PORT THEN
IF SEND.STATUS EQ ERR$TOUT THEN SEND.STATUS = FALSE
END
END
*
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
END ELSE NULL
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
LCK.COM.AIP = FALSE
END
*
*
*
RETURN
*
END
~AI.UPDT.COM.AIP~

~AI.WRITE.COMMAND~
SUBROUTINE AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE)
* VERSION: 940130 1.1  COM.AI.ID CHANGED TO 'AI.TYPE':AI.CODE
*SUBROUTINE: AI.WRITE.COMMAND
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*   1990         ALL RIGHTS RESERVED
*
* AUTHOR: DAVID G. HORSMAN
*
* DATE RELEASED: ?? DEC 90
*
*      Write a command onto the port's work file record for transmission...
*
* TO IMPLEMENT TESTING MAT CNT.TST SHOULD BE PASSED IN THE CALL.
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP SAVE.COM.AIP.DIM
!
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
!
OPEN "COM" TO COM.FILE ELSE PRINT @(0,23):CLL:"Can't open COM":; INPUT RSP:; STOP
*
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT @(0,23):CLL:"Can't open LOCKS":; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
* LCK.ITM = TRUE; LCK.TYPE = -1; LCK.RELS = TRUE
LCK.ITM = TRUE; LCK.RELS = TRUE
LCK.ELP = ZERO; LCK.ELP.MAX = 30
OPT.COMM = HANDLER.COMMAND
SEND.COMM.CN = ONE
*
!
*
*IF NOT(NUM(HANDLER.COMMAND<ONE,ONE>)) THEN
*IF HANDLER.COMMAND<ONE,ONE> EQ AI.UP THEN AI.STATUS = FALSE ELSE AI.STATUS = TRUE
*END
*
PREV.DT = DATE(); PREV.TM = TIME()
MAT SAVE.COM.AIP = ""; PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = "0":PORT.KEY REPEAT
COM.AI.ID = "AI.TYPE.":AI.CODE
*
*IF HANDLER.COMMAND NE EMPTY THEN AI.STATUS = HANDLER.COMMAND; RETURN
*
IF COM.AIP.ID EQ EMPTY THEN AI.STATUS = 21; RETURN
*
MAT SAVE.COM.AIP = MAT COM.AIP; RETRY = 0
*** LCK.ITM = FALSE; LCK.RELS = TRUE
LCK.ITM = TRUE; LCK.RELS = FALSE
GOSUB READ.COM.AI
LCK.ITM = TRUE; LCK.RELS = TRUE
*
PRINT @(0,23):CLL:@(ZERO):
*
IF COM.AI$UP.DN.STAT NE AI.UP THEN
PRINT @(31,22):BELL:RVB:"The Addressable Interface Handler is down" "L#73":RVE:
IF NOT(INDEX("#":AI.ON:"#":AI.UP:"#":AI.OFF:"#","#":HANDLER.COMMAND<ONE,ONE>:"#",ONE)) THEN
PRINT @(6,23):" -- press <cr>...":
**** DON'T WANT TO ALWAYS TAKE INPUT
INPUT RSP:; PRINT @(6,23):SPACE(73):
*HANDLER.COMMAND = 1; 
*** AI.STATUS = 11; RETURN
AI.STATUS = 11
END
END
*
!
*
* Main program loop
*
RETRY.CONT = TRUE
WRITEN.FLAG = FALSE; OVERWRITE.FLAG = FALSE
*
IF NOT(AI.STATUS) AND LCK.COM.AI THEN
*
!
*
LOOP
*
*
* LOCK ITEM
*
IF NOT(LCK.COM.AI) THEN
DT = DATE(); TM = TIME(); ELP = ZERO
TMP1 = COM.AI$MAX.PAUSE
IF NOT(TMP1) THEN TMP1 = 300
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
IF LCK.STAT GE 900 THEN AI.STATUS = LCK.STAT
IF NOT(LCK.STAT) THEN LCK.COM.AI = TRUE
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
UNTIL LCK.COM.AIP OR ELP GT TMP1 DO REPEAT
*
END; * OF LCK.COM.AI
*
** IF LCK.COM.AI THEN
*
!
*
* LOCK ITEM
*
DT = DATE(); TM = TIME(); ELP = ZERO
TMP1 = COM.AI$MAX.PAUSE
IF NOT(TMP1) THEN TMP1 = 300
*
LOOP
CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
IF LCK.STAT GE 900 THEN AI.STATUS = LCK.STAT
IF NOT(LCK.STAT) THEN LCK.COM.AIP = TRUE
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
*
UNTIL LCK.COM.AIP OR ELP GT TMP1 DO REPEAT
*
*
IF LCK.COM.AIP THEN
*
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> = EMPTY
*
**IF LCK.COM.AI AND COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> EQ EMPTY THEN OVERWRITE.FLAG = TRUE
IF LCK.COM.AI THEN
TMP = DCOUNT(COM.AIP$COMM.PORT,VM)
OVERWRITE.FLAG = TRUE
FOR SEND.COMM.CN = ONE TO TMP
IF COM.AIP$COMM.PORT<ONE,SEND.COMM.CN> NE EMPTY THEN OVERWRITE.FLAG = FALSE
NEXT SEND.COMM.CN
END
*
END
*
!
*
UNTIL OVERWRITE.FLAG OR WRITEN.FLAG OR NOT(RETRY.CONT) DO
*
*
RETRY = RETRY + ONE
CURR.ELP = ((DATE() - PREV.DT) * 86400) + (TIME() - PREV.TM)
*
TEMP.MAX.PAUSE = COM.AI$MAX.PAUSE
* HH - THIS IS WHERE WE VARY THE TIME WE WILL WAIT BASED ON 5B OR 7B
** IF COM.AIP$MAX.PAUSE NE "" THEN TEMP.MAX.PAUSE = COM.AIP$MAX.PAUSE
*
IF (CURR.ELP LE TEMP.MAX.PAUSE AND COM.AI$UP.DN.STAT EQ AI.UP) AND SYSTEM(11) LE 3 THEN
*
PRINT @(6,23):RVB:("Handler Command attempt #":RETRY:" at time ":CURR.ELP) "L#73":RVE:
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
LCK.COM.AIP = FALSE
END
*
* EXECUTE "SLEEP ":COM.AI$STD.PAUSE
* PRINT @(6,23):SPACE(73):
*
END ELSE
*
*
PREV.DT = DATE(); PREV.TM = TIME()
PRINT BELL:
*
IF COM.AI$UP.DN.STAT EQ AI.UP THEN
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command has not been sent -- wait longer? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
END ELSE RSP = "N"
*
IF RSP EQ "Y" THEN
RETRY.CONT = TRUE
PREV.DT = DATE(); PREV.TM = TIME()
END ELSE
*
PRINT BELL:
*
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command will be lost -- overwrite it? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
*
IF RSP EQ "Y" THEN
* Yes, overwrite item
*
OVW.TYPE = FIELD(COM.AIP.ID,"*",ONE)
OVW.CODE = FIELD(COM.AIP.ID,"*",TWO)
OVW.PORT = FIELD(COM.AIP.ID,"*",3)
OVW.DVC.CN = FIELD(COM.AIP.ID,"*",4)
IF NOT(NUM(OVW.DVC.CN)) THEN OVW.DVC.CN = ONE
IF OVW.DVC.CN LT ONE THEN OVW.DVC.CN = ONE
OVW.DVC.NEXT.FOUND = TRUE
FOR TMP = OVW.DVC.CN TO 10 UNTIL NOT(OVW.DVC.NEXT.FOUND)
OVW.ID = OVW.TYPE:"*":OVW.CODE:"*":OVW.PORT:"*":TMP
MATREAD COM.AIP FROM COM.FILE,OVW.ID THEN
* Loop to save old exceptions
MATWRITE COM.AIP ON COM.FILE,DATE():"@":TIME():"@":OVW.ID
DELETE COM.FILE,OVW.ID
PRINT @(6,23):CLL:BELL:RVB:("Handler Command over-ride delete for ":OVW.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
END ELSE OVW.DVC.NEXT.FOUND = FALSE
NEXT OVW
*
* write new command
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
RETRY.CONT = TRUE
WRITEN.FLAG = TRUE; OVERWRITE.FLAG = TRUE
PRINT @(6,23):CLL:BELL:RVB:("Handler Command over-ride placed for ":COM.AIP.ID:" at ":OCONV(TIME(),"MTS")) "L#73":RVE:
*
END ELSE
*
* No, do not overwrite item
*
RETRY.CONT = FALSE
OVERWRITE.FLAG = FALSE
PRINT @(6,23):CLL:BELL:RVB:("Handler Command Request for ":COM.AIP.ID:" denied at ":CURR.ELP) "L#73":RVE:
*
END; * of Y/N to overwrite
*
*
END; * of do not continue to wait for prior command
*
!
*
END; * of more than six waits for the command
*
REPEAT
* for repeated attempts to send the command
*
!
*
IF (OVERWRITE.FLAG AND LCK.COM.AIP) THEN
*
*
*** LOOP
*** LCK.ITM = TRUE; LCK.RELS = FALSE
*** COM.AI.ID = "AI.TYPE.":AI.CODE
*** GOSUB READ.COM.AI
*** WHILE LCK.STAT AND LCK.STAT NE 999 DO REPEAT
*** *
*** IF LCK.STAT NE 999 THEN
** IF LCK.COM.AI THEN
*
LCK.ITM = TRUE; LCK.RELS = TRUE
IF COM.AI$FUNC.PORT NE EMPTY THEN
IF INDEX("#":AI.ON:"#":AI.OFF:"#":AI.UP:"#":AI.DN:"#","#":COM.AIP$COMM:"#",ONE) THEN
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC THEN
DEL COM.AI$FUNC.PORT<ONE,PORT.LOC>
END ELSE NULL
INS PORT.KEY BEFORE COM.AI$FUNC.PORT<ONE,ONE>
END ELSE
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:PORT.KEY
END; * of locate else
END; * of on/off/up/dn
END ELSE
COM.AI$FUNC.PORT = PORT.KEY
END
*
LOOP WHILE LEN(COM.AI$FUNC.PORT) AND COM.AI$FUNC.PORT<ONE,ONE> EQ EMPTY DO
DEL COM.AI$FUNC.PORT<ONE,ONE>
REPEAT
IF LCK.COM.AI THEN
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
END
*
IF NOT(WRITEN.FLAG) THEN
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
WRITEN.FLAG = TRUE; *
PRINT @(6,23):RVB:"The Handler Command has been submitted." "L#73":RVE:
* EXECUTE "SLEEP ":COM.AI$STD.PAUSE
END; * of WRITEN
*
END; * of overwrite or lock flag
*
!
*
END; * OF AI.STATUS 11 AND LCK.COM.AI
*
IF LCK.RELS THEN
IF LCK.COM.AI THEN
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
LCK.COM.AI = FALSE
END
END
*
IF LCK.COM.AIP THEN
CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
LCK.COM.AIP = FALSE
END
*
RETURN
*
!
*
READ.COM.AI: *
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
LOAD.TST: *
*
* $INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
*
END
~AI.WRITE.LOG~
SUBROUTINE AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LOG.REQUIRED,SYS.PROG,HANDLER.COMMAND,LCK.FILE,LCK.TYPE)
* VERSION: 940130 1.1  AIL.SEQ.ID CHANGED.
* PRIOR: 910722 NEW
EQU VS TO "940130 1.1"
*
* 22 JUL 91
*
*
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
!
$INCLUDE IBP TST.EQUATES
EQU TST$AM TO 12, TST$VM TO 9
VERSION = VS
!
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP AIL.DIM
*
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP AIL.EQUATES
*
OPEN "AIL" TO AIL.FILE ELSE CHAIN "FREEZE.PORT"
*
* ULT ONLY
* OPEN "LOCKS" TO LCK.FILE ELSE CHAIN "FREEZE.PORT"
* LCK.FILE = ZERO; * REV ONLY
*
$INCLUDE IBP AI.LOG.WRITE
*
*
RETURN
*
END
~ASSIGN.PPV.EVENT.NUMS.PA~
*PROGRAM: ASSIGN.PPV.EVENT.NUMS.PA
* VERSION: 940703 1.3  ADDED PVM$PVE.DUR. UPDATE PVE$DUR IF NOT EMTPY &
*                      CALC PROGMO FROM DT (SHOW DATE).
* PRIOR: 940326 1.2  WRITE NEXT.EVEN.NUM AFTER EACH EVENT.
* PRIOR: 940218 1.1  ADDED AI.CODE PREFIX TO PVE.ID.
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
* DESCRIPTION:  ASSIGN EVENT NUMBERS AND WRITE PVE FILE ITEMS.
*
*
* TEST MODE:  CNT.TST$X WILL NOT WRITE PVM FOR EVENT.NUMS
*             CNT.TST$Z WILL NOT WRITE PVE RECORDS
!
*
VERSION = " (1.3)"; VS = VERSION
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
!
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT CLB:"Can't open PVM":; INPUT TMP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:; STOP
* LCK.FILE = 0; * REV ONLY
!
*
LCK.TYPE = -3; LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.STAT = FALSE
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY; LCK.ID = EMPTY
LCK.CLASS = EMPTY
*
OPER = EMPTY; EXP.TM = EMPTY
START.NUM = EMPTY; TMP.EVENT.NUM = EMPTY 
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "A"
*
GOSUB LOAD.TST
IF CNT.TST$ON THEN VERSION = VERSION:" **** TEST MODE ****"
*
*
IF CNT.TST$RTN THEN PRINT CLB:"ASSIGN.PPV.EVENT.NUMS.PA":; IF CNT.TST$CR THEN INPUT TMP:
PRINT CLB:
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = "Unknown"
*
OVER = FALSE; UPLOADED.CTR = 0; ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
*
VALID.CTR = 0; UPLOAD.DATE = DATE()
*
PRINT @(0,0):CLS:
TITLE = "Assign PPV Event Numbers":VERSION
$INCLUDE IBP DISPLAY.SCREEN.HEADER
LN = 4; SAVE.LN = 0
*
IF CNT.TST$X THEN
PRINT @(0,LN):"Update of PVM Master Event will be bypassed.":; LN = LN+1
END
*
IF CNT.TST$Z THEN
PRINT @(0,LN):"Write of PVE records will be bypassed.":; LN = LN+1
END
*
!
GET.INPUT: *
LN = LN+1
GET.LN = LN
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
IF NOT(COUNT(AI.TYPES<1>,VM)) THEN AI.CODE = AI.TYPES<1>; AI.DESC = AI.TYPES<2> ELSE AI.CODE = ""; AI.DESC = ""
*
IF AI.CODE = "" THEN
LOOP
PRINT @(0,LN):CLL:"Enter the Addressable Interface Code: ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP ELSE IF AI.CODE = "" THEN STOP
LOCATE AI.CODE IN AI.TYPES<1> BY "AL" SETTING LOC THEN AI.DESC = AI.TYPES<2,LOC> ELSE
AI.CODE = ""
PRINT CLB:"That Addressable Interface has not been defined. Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
UNTIL AI.CODE NE "" DO REPEAT
END
LN = LN+1
PRINT @(10,LN):AI.DESC:; LN = LN+1
*
COM.ID = "NEXT.PPV.EVENT.NUM.":AI.CODE
!
NEXT.EVENT: *
*
LOOP
PRINT @(0,LN):CLS:"Enter the Master Event Code for assignment: ":; INPUT EVENT.CODE:
IF EVENT.CODE = "KILL" THEN STOP ELSE IF EVENT.CODE = "" THEN STOP
LOOP
*
LCK.STAT = EMPTY
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO REPEAT
READ START.NUM FROM COM.FILE,COM.ID ELSE START.NUM = 1
START.NUM = ("0000":START.NUM) "R#4"
SAVE.LN = LN; GET.NUM = START.NUM
*
LOOP
LCK.TYPE = 0; LCK.STAT = EMPTY
CALL SYS.ITM.LCK("PVM",EVENT.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO REPEAT
MATREAD PVM FROM PVM.FILE,EVENT.CODE ELSE EVENT.CODE = ""
IF EVENT.CODE NE "" THEN
PRINT @(5,LN+1):CLL:EVENT.CODE:" - ":PVM$DESC:" - debuts on ":OCONV(PVM$DEBUT.DT,"D2"):
VC = 1; E.CTR = 0; ECHK.CTR = 0; ENUM.CTR = 0
LOCATE AI.CODE IN PVM$PVE.AI.CODES<1> SETTING AI.SVC ELSE AI.SVC = 1
LOOP EVENT.DT = PVM$PVE.DT<1,VC> UNTIL EVENT.DT = "" DO
E.CTR = E.CTR+1
MATREAD PVE FROM PVE.FILE,AI.CODE:"*":PVM$EVENT.NUMS<1,VC,AI.SVC> THEN
ENUM.CTR = ENUM.CTR+1 
END ELSE
ECHK.CTR = ECHK.CTR+1
END
VC = VC+1
REPEAT
IF NOT(ECHK.CTR) THEN
PRINT CLB:"All showings of the Master Event have been assigned Event Numbers.":; PRINT BELL:; INPUT TMP:; PRINT CLB:
EVENT.CODE = ""
END
END
UNTIL EVENT.CODE NE "" DO PRINT BELL: REPEAT
*
LN = LN+2
PRINT @(0,LN):"Number of Event showings:        ":E.CTR:; LN = LN+1
PRINT @(0,LN):"Number of Event Number assigned: ":ENUM.CTR:; LN = LN+1
PRINT @(0,LN):"Number to be assigned now:       ":ECHK.CTR:; LN = LN+1
*
LOOP
PRINT @(0,LN):"Enter the starting Event Number or <cr> to accept: ":START.NUM:; PRINT @(51,LN):; INPUT TMP.NUM:
IF TMP.NUM = "" THEN TMP.NUM = START.NUM
IF TMP.NUM = "KILL" THEN GOTO UNLOCK
IF NOT(NUM(TMP.NUM)) THEN TMP.NUM = ""
UNTIL TMP.NUM NE "" DO PRINT BELL: REPEAT
NEXT.EVENT.NUM = TMP.NUM; LN = LN+1
*
LN = LN+1; AVAIL.CTR = 0; EUSED.CTR = 0; TMP.EVENT.NUM = ""
PRINT @(0,LN):"Checking availability of Event Numbers":; LN = LN+1
TMP.EVENT.NUM = ("0000":NEXT.EVENT.NUM) "R#4"
LOOP
MATREAD PVE FROM PVE.FILE,AI.CODE:"*":TMP.EVENT.NUM ELSE MAT PVE = ""
IF PVE$PVM.ID NE "" THEN
EUSED.CTR = EUSED.CTR+1
END ELSE
AVAIL.CTR = AVAIL.CTR+1
END
TMP.EVENT.NUM = ("0000":(TMP.EVENT.NUM+1)) "R#4"; IF TMP.EVENT.NUM EQ "0000" THEN TMP.EVENT.NUM = "0001"
UNTIL AVAIL.CTR = ECHK.CTR DO REPEAT
IF EUSED.CTR THEN
PRINT @(0,LN):EUSED.CTR:" Event Number(s) already used.":; LN = LN+1
PRINT @(0,LN):"Will assign on a next available basis.":; LN = LN+1
END
*
PRINT CLB:"Press <cr> to start assignment of event numbers, or 'KILL': ":
INPUT RESP:
IF RESP = "KILL" THEN GOTO UNLOCK
PRINT CLB:
* PRINT @(0,3):CLS:
*
!
MAIN.LOOP: *
LN = LN+2
PRINT @(0,LN):CLL:"Assigning Event Numbers....":; LN = LN+1
*
LCK.TYPE = -4
*
*
INSERT.ON = 0; PREV.CTR = 0; ASSIGNED.CTR = 0; USED.CTR = 0; TMP.EVENT.NUM = ""
TMP.EVENT.NUM = ("0000":NEXT.EVENT.NUM) "R#4"
VC = 1
*
LOCATE AI.CODE IN PVM$PVE.AI.CODES<1> BY "AL" SETTING AI.SVC ELSE
INS AI.CODE BEFORE PVM$PVE.AI.CODES<1,AI.SVC>
INSERT.ON = 1
END
*
VC = 1
LOOP EVENT.DT = PVM$PVE.DT<1,VC> UNTIL EVENT.DT = "" DO
IF INSERT.ON THEN
INS "" BEFORE PVM$EVENT.NUMS<1,VC,AI.SVC>
END
IF PVM$EVENT.NUMS<1,VC,AI.SVC> EQ "" THEN
LOOP
LCK.STAT = FALSE
CALL SYS.ITM.LCK("PVE",AI.CODE:"*":TMP.EVENT.NUM,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT NE EMPTY DO REPEAT
*
IF NOT(LCK.STAT) THEN
*
MATREAD PVE FROM PVE.FILE,AI.CODE:"*":TMP.EVENT.NUM THEN
USER.CTGR = USED.CTR+1
END ELSE
MAT PVE = ""
ASSIGNED.CTR = ASSIGNED.CTR+1
PVE$PVM.ID = EVENT.CODE
PVE$DT = PVM$PVE.DT<1,VC>
PVE$TM = PVM$PVE.TM<1,VC>
TMP.DT = OCONV(PVE$DT,"D2-")
TMP.MO = TMP.DT[1,2]
TMP.YR = TMP.DT[7,2]
PVE$PROGMO = TMP.YR:TMP.MO
PVE$CH.CODE = PVM$CH.CODE
IF PVM$PVE.RATE.CL<1,VC> NE "" THEN PVE$RATE.CL = PVM$PVE.RATE.CL<1,VC> ELSE PVE$RATE.CL = PVM$RATE.CL
IF PVM$PVE.RATE.CL.SUB<1,VC> NE "" THEN PVE$RATE.CL.SUB = PVM$PVE.RATE.CL.SUB<1,VC> ELSE PVE$RATE.CL.SUB = PVM$RATE.CL.SUB
IF PVM$PVE.DUR<1,VC> NE "" THEN PVE$DUR = PVM$PVE.DUR<1,VC> ELSE PVE$DUR = PVM$DUR
PVE$PURGE.DT = PVM$PURGE.DT
PVE$DOWNLOADED = ""
*
PVM$EVENT.NUMS<1,VC,AI.SVC> = TMP.EVENT.NUM
*
IF NOT(CNT.TST$Z) THEN MATWRITE PVE ON PVE.FILE,AI.CODE:"*":TMP.EVENT.NUM
*
END
*
CALL SYS.ITM.RLS("PVE",AI.CODE:"*":TMP.EVENT.NUM,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
END ELSE USED.CTR = USED.CTR+1
*
TMP.EVENT.NUM = ("0000":(TMP.EVENT.NUM+1)) "R#4"; IF TMP.EVENT.NUM EQ "0000" THEN TMP.EVENT.NUM = "0001"
END ELSE PREV.CTR = PREV.CTR+1
VC = VC+1
*
PRINT @(0,LN+1):"Processed: ":VC-1 "R#4":"  Assigned: ":ASSIGNED.CTR "R#4":"  Assigned Prev: ":PREV.CTR "R#4":"  Already used: ":USED.CTR "R#4":
REPEAT
*
IF NOT(CNT.TST$X) THEN MATWRITE PVM ON PVM.FILE,EVENT.CODE
*
PRINT @(0,SAVE.LN):CLS:
LN = SAVE.LN
START.NUM = TMP.EVENT.NUM
IF (TMP.EVENT.NUM NE GET.NUM) AND (TMP.EVENT.NUM NE "") THEN WRITE TMP.EVENT.NUM ON COM.FILE,COM.ID
*
UNLOCK:
CALL SYS.ITM.RLS("PVM",EVENT.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
LN = SAVE.LN
GOTO NEXT.EVENT
!
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai":; RQM; PRINT CLB:
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
END
~BU.AI.COMMAND.SENDER~
SUBROUTINE AI.COMMAND.SENDER(MAT COM.AIP,MAT COM.AI,CNT.NEXT.ID,AI.CODE,ACTIONS,COM.FILE,LOCKS.FILE,LOCK.TYPE,AI.STATUS,SEND.STATUS,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,MAT CNT.TST)
*SUBROUTINE: AI.COMMAND.SENDER
* VERSION: 940220 1.1  BYPASS DVC.TYPE CHECK, UPDATE NEXT TRANS, PASS COM.AIIERR.
* USED BY AI.HANDLER
*
* AUTHOR:    DAVID G. HORSMAN
* COMPANY:   WRITTEN FOR AXION COMPUTER SYSTEMS LTD.
*
* DATE RELEASED: ?? DEC 90
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AI.DIM
* PAUSE.CHAR   (INCR'S)
* PAUSE.LINE   (INCR'S)
* PAUSE.RESP   (SEC.S)
$INCLUDE IBP AIX.DIM
$INCLUDE IBP ADD.DIM
!
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AIICMD.VAR.EQUATES
*
* OPEN "CNT" TO CNT.FILE ELSE STOP
* SYS.APPL.SUB = "AI"
* GOSUB LOAD.TST
*
IF CNT.TST$LBL THEN PRINT @(ZERO,23):RVB:" * Subroutine AI.COMMAND.SENDER * ":RVE
!
DT = DATE(); TM = TIME()
PAUSE.CN.MAX = COM.AI$PAUSE.CHAR
SEND.STATUS = FALSE; SEND.CN = ZERO
COM.AI.MAX.PKT = 6
PAUSE.RESP.MAX = COM.AI$PAUSE.RESP
*
* FORMAT RECORD
*
IF CNT.TST$LBL THEN PRINT RVB:"Formatting Record":RVE
*
OUTPUT.PACKET = EMPTY
*
*
IF COM.AIP$DVC.TYPE NE "" THEN
LOCATE COM.AIP$DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC THEN
*
BEGIN CASE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "EA"; EXEC.VALID = TRUE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "HA"; EXEC.VALID = TRUE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "JE"; EXEC.VALID = TRUE
CASE COM.AI$DB.PREFIX<ONE,DVC.LOC> EQ "PA"; EXEC.VALID = TRUE
CASE TRUE; EXEC.VALID = FALSE; SEND.STATUS = TRUE
END CASE
*
END ELSE EXEC.VALID = FALSE; SEND.STATUS = TRUE
END ELSE EXEC.VALID = TRUE; DVC.LOC = ONE
*
IF NOT(EXEC.VALID) THEN SEND.STATUS = TRUE; RETURN
*
** * * Loop to send packet up to 3 times
** * LOOP
*
TC.START.SYS11 = SYSTEM(11)
*
EXEC.ROUTINE = "AI.PARSE.OUTPUT.":COM.AI$DB.PREFIX<ONE,DVC.LOC>
*
CALL @EXEC.ROUTINE(MAT COM.AIP,OUTPUT.PACKET,MAT CNT.TST,COM.FILE,LOCKS.FILE,LOCK.TYPE,SEND.STATUS,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE)
*
LOCATE COM.AIP$COMM.RSLT IN COM.AIICMD<COM.AIICMD$RCVD> SETTING COM.AIICMD.LOC THEN
TMP = COM.AIICMD<COM.AIICMD$PAUSE,COM.AIICMD.LOC>
IF TMP GT PAUSE.RESP.MAX THEN
PAUSE.RESP.MAX = COM.AIICMD<COM.AIICMD$PAUSE,COM.AIICMD.LOC>
END
IF TMP GT COM.AIP$MAX.PAUSE THEN
COM.AIP$MAX.PAUSE = TMP
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.NUM
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
END
* LOOP WHILE PAUSE.RESP.MAX GT COM.AIP$MAX.PAUSE / 3 DO
* COM.AIP$MAX.PAUSE = COM.AIP$MAX.PAUSE + PAUSE.RESP.MAX
* REPEAT
TMP = COM.AIICMD<COM.AIICMD$RETRY,COM.AIICMD.LOC>
IF TMP NE EMPTY THEN
IF TMP LT COM.AIP$RETRY THEN COM.AIP$RETRY = TMP
END
END; * OF LOCATE
*
IF SEND.STATUS EQ "0" THEN SEND.STATUS = EMPTY
IF SEND.STATUS EQ "00" THEN SEND.STATUS = EMPTY
IF NOT(NUM(COM.AIP$INTFC.ERR<ONE,ONE,ONE>)) THEN
INS ERR$BAD.RSP BEFORE COM.AIP$INTFC.ERR<ONE,ONE,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,ONE,ONE>
SEND.STATUS = ERR$BAD.RSP
END
IF COM.AI$LOGGING EQ "Y" OR COM.AI$TEST.MODE OR COM.AIP$INTFC.ERR<ONE,ONE,ONE> OR SEND.STATUS NE EMPTY THEN
* COM.AIP$HEX.COMM =  OUTPUT.PACKET; COM.AIP$HEX.COMM<ONE,TWO> = OCONV(OUTPUT.PACKET,"HEX")
IF LEN(COM.AIP$HEX.COMM) GT 300 THEN
TMP = INDEX(COM.AIP$HEX.COMM,VM,10)
IF TMP GT 300 THEN TMP = INDEX(COM.AIP$HEX.COMM,VM,5)
IF TMP GT 300 THEN TMP = INDEX(COM.AIP$HEX.COMM,VM,3)
IF TMP THEN COM.AIP$HEX.COMM = COM.AIP$HEX.COMM[ONE,TMP - ONE]
TMP = INDEX(COM.AIP$HEX.RSLT,VM,30)
IF TMP THEN COM.AIP$HEX.RSLT = COM.AIP$HEX.RSLT[ONE,TMP - ONE]
TMP = INDEX(COM.AIP$ERR,VM,30)
IF TMP THEN COM.AIP$ERR = COM.AIP$ERR[ONE,TMP - ONE]
TMP = INDEX(COM.AIP$INTFC.ERR,VM,30)
IF TMP THEN COM.AIP$INTFC.ERR = COM.AIP$INTFC.ERR[ONE,TMP - ONE]
END
INS OCONV(OUTPUT.PACKET,"HEX") BEFORE COM.AIP$HEX.COMM<ONE,ONE>
INS EMPTY BEFORE COM.AIP$HEX.RSLT<ONE,ONE>
INS EMPTY BEFORE COM.AIP$ERR<ONE,ONE>
INS EMPTY BEFORE COM.AIP$INTFC.ERR<ONE,ONE>
END
*
IF SEND.STATUS NE EMPTY THEN NULL
*
!
*
* SEND RECORD TO COM.AI$DB.PREFIX DEVICE
*
IF CNT.TST$LBL THEN PRINT RVB:"Sending Record":RVE
*
** * SEND.RETRY = FALSE
TC.CN = 0
TC.CN.MAX = LEN(OUTPUT.PACKET)
*
IF PAUSE.CN.MAX THEN
LOOP TC.CN = TC.CN + ONE WHILE TC.CN LE TC.CN.MAX DO
PAUSE.CN = 0
LOOP WHILE PAUSE.CN LT PAUSE.CN.MAX DO PAUSE.CN = PAUSE.CN + ONE REPEAT
TC = OUTPUT.PACKET[TC.CN,ONE]
PRINT TC:
REPEAT ; * SEND NEXT CHARACTER
END ELSE
PRINT CLL:OUTPUT.PACKET:
END
*
TC.END.SYS11 = SYSTEM(11)
IF TC.END.SYS11 LT 10 THEN
PAUSE.CN = 0
LOOP WHILE PAUSE.CN LT COM.AI$PAUSE.LINE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
END
*
IF CNT.TST$LBL THEN PRINT; PRINT; PRINT
*
!
*
* RECEIVE RESPONSE FROM COM.AI$DB.PREFIX DEVICE
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Receiving Response From Headend . . . ":RVE
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Wait for characters in buffer":RVE
*
* WAIT FOR CHARACTERS IN THE BUFFER
PAUSE.CN1 = 0
TC.CONT = TRUE
TM = TIME()
LOOP
TC.END.SYS11 = SYSTEM(11)
CTM = TIME()
IF CTM LT TM THEN CTM = CTM + 86400
UNTIL CNT.TST$LBL OR (TC.END.SYS11 GT TC.START.SYS11 OR ABS(CTM - TM) GT PAUSE.RESP.MAX) OR TC.END.SYS11 GE 25 DO
PAUSE.CN1 = PAUSE.CN1 + ONE
REPEAT
*
IF TC.END.SYS11 GT TC.START.SYS11 AND TC.END.SYS11 LT 25 THEN
TC.START.SYS11 = SYSTEM(11)
LOOP
FOR TMP = ONE TO TWO UNTIL SYSTEM(11) GT 25
PAUSE.CN = ZERO
LOOP WHILE PAUSE.CN LT COM.AI$PAUSE.LINE DO PAUSE.CN = PAUSE.CN + ONE REPEAT
NEXT TMP
TC.END.SYS11 = SYSTEM(11)
WHILE TC.START.SYS11 NE TC.END.SYS11 AND TC.END.SYS11 LT 25 DO TC.START.SYS11 = TC.END.SYS11 REPEAT
END
*
!
*
* INPUT any characters that are available
*
LOOP
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Input next buffered response/characters":RVE
*
ORIG.PACKET = EMPTY; INPUT.PACKET = EMPTY
* Input & Validate Headend response
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Validate Response From Headend Device":RVE
*
IF CNT.TST$LBL OR TC.END.SYS11 THEN
*
EXEC.ROUTINE = "AI.PARSE.INPUT.":COM.AI$DB.PREFIX<ONE,DVC.LOC>
*
ECHO OFF
CALL @EXEC.ROUTINE(MAT COM.AIP,INPUT.PACKET,ORIG.PACKET,MAT CNT.TST,COM.FILE,LOCKS.FILE,LOCK.TYPE,SEND.STATUS,MAT COM.AIIERR,COM.AIICMD,OPT.COMM,AI.CODE)
ECHO ON
*
IF SEND.STATUS EQ "0" THEN SEND.STATUS = EMPTY
IF SEND.STATUS EQ "00" THEN SEND.STATUS = EMPTY
IF NOT(NUM(COM.AIP$INTFC.ERR<ONE,ONE,ONE>)) THEN
INS ERR$BAD.RSP BEFORE COM.AIP$INTFC.ERR<ONE,ONE,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,ONE,ONE>
SEND.STATUS = ERR$BAD.RSP
END
IF COM.AI$LOGGING EQ "Y" OR COM.AI$TEST.MODE OR COM.AIP$INTFC.ERR<ONE,ONE,ONE> OR SEND.STATUS NE EMPTY THEN
* COM.AIP$HEX.RSLT = ORIG.PACKET; COM.AIP$HEX.RSLT<ONE,ONE,TWO> = OCONV(ORIG.PACKET,"HEX")
INS OCONV(ORIG.PACKET,"HEX") BEFORE COM.AIP$HEX.RSLT<ONE,ONE,ONE>
* COM.AIP$HEX.RSLT<ONE,TWO> = INPUT.PACKET; COM.AIP$HEX.RSLT<ONE,TWO,TWO> = OCONV(INPUT.PACKET,"HEX")
* INS OCONV(INPUT.PACKET,"HEX") BEFORE COM.AIP$HEX.RSLT<ONE,ONE,ONE>
END
*
*
END ELSE
INS ERR$NO.RSP BEFORE COM.AIP$INTFC.ERR<ONE,ONE,ONE>
INS "800" BEFORE COM.AIP$ERR<ONE,ONE,ONE>
SEND.STATUS = ERR$NO.RSP
END
*
TC.END.SYS11 = SYSTEM(11)
*
WHILE NOT(CNT.TST$LBL) AND TC.END.SYS11 GT COM.AI.MAX.PKT DO REPEAT
*
** * SEND.CN = SEND.CN + ONE
** * *
** * WHILE SEND.CN LT 3 AND SEND.RETRY = TRUE DO REPEAT
*
!
*
* Load information into COM.AIP Record
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"Update Port Control Record":RVE
*
* COM.AIP$??? = ?
*
!
*
!
*
IF CNT.TST$LBL THEN PRINT CLL:RVB:"AI.COMMAND.SENDER processing complete":RVE; PRINT
* Return to calling program
*
RETURN
*
!
*
LOAD.TST: *
*
* $INCLUDE IBP TST.INCL.LOAD
*
RETURN
!
END
~BU.AI.CONTROL.UTILITY~
*PROGRAM: AI.CONTROL.UTILITY
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1990        ALL RIGHTS RESERVED
*
EQU VS TO "901018 NEW"
*
$INCLUDE IBP AI.CNTRL.UTIL.DOC.TOP
*
*: * INIT
*: * FUNC
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP AI.ERR.INIT
*
AI.TALK = EMPTY
COM.AI.PORT.REC = EMPTY
FUNC.SUB = EMPTY; OLD.FUNC.SUB = EMPTY; CO.DATA = EMPTY; CO.NAME = EMPTY; CO.DATE = EMPTY
$INCLUDE IBP AI.CU.TOP
*
*: * Control Flags
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
SAVE.FUNC.SUB = ""; CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
SYS.LOC = "INIT"; IF CNT.TST$LBL THEN PRINT @(ZERO,20):(SYS.PROG:" ":SYS.LOC) "L#78":; IF CNT.TST$CR THEN INPUT TMP:
*
*
!: * Application Records
SYS.LOC = "AR"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Records" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
*
*     AIL
AIL.NEXT.ID = EMPTY
LOG.REQUIRED = FALSE
*
*
$INCLUDE IBP DVC.DIM
$INCLUDE IBP DVC.EQUATES
MAT DVC = EMPTY; DVC.ID = EMPTY
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
MAT AIX = EMPTY; AIX.ID = EMPTY; AIX.RESET = FALSE
*
*
$INCLUDE IBP WKO.DIM
$INCLUDE IBP WKO.EQUATES
MAT WKO = EMPTY; WKO.ID = EMPTY
*
*
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
MAT ADD = EMPTY; ADD.ID = EMPTY
*
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
MAT ACT = EMPTY; ACT.ID = EMPTY
*
*
!: * Application Parameters and Tables
SYS.LOC = "APT"; IF CNT.TST$LBL THEN PRINT @(60,20):"Application Parameters and Tables" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP AI.CU.TOP.A
*
$INCLUDE IBP AI.CNTRL.UTIL.DOC.START
*
*
LOOP
*
ALREADY.DISPLAYED = EMPTY
*
*: * Start of LOOP * Main 1
*
LOOP
*
GOSUB LOAD.TITLE; * : *
GOSUB DISPLAY.STATUS; * : *
*
GOSUB INTFC.MESSAGES
*
** IF NOT(LEN(FUNC.CHNG)) AND LEN(COM.AI.ERR.TEXT) THEN
IF NOT(LEN(FUNC.CHNG)) AND LEN(COM.AI.ERR.FUNC) THEN
*
IF FUNC NE COM.AI.ERR.FUNC<ONE> AND COM.AI.ERR.FUNC NE EMPTY THEN
*
LOOP
*
FUNC.OK = TRUE
IF COM.AI.ERR.FUNC<ONE> EQ ORIG.FUNC OR COM.AI.ERR.FUNC<ONE> EQ OLD.FUNC THEN FUNC.OK = FALSE
IF COM.AI.ERR.FUNC<ONE> EQ COM.AI$ON.OFF.STAT THEN FUNC.OK = FALSE
IF COM.AI.ERR.FUNC<ONE> EQ COM.AI$UP.DN.STAT  THEN FUNC.OK = FALSE
*
IF FUNK.OK THEN
INS COM.AI.ERR.FUNC<ONE> BEFORE FUNC.CHNG<ONE>
END ELSE
PRINT CLB:"Function change ":COM.AI.ERR.FUNC<ONE>:" rejected.":
EXECUTE "SLEEP 2"
DEL COM.AI.ERR.FUNC<ONE>
DEL COM.AI.ERR.TEXT<ONE>
DEL COM.AI.ERR.TYPE<ONE>
END
*
* IF COM.AI.ERR.FUNC<ONE> NE ORIG.FUNC AND COM.AI.ERR.FUNC<ONE> NE OLD.FUNC<ONE> THEN
*
* BEGIN CASE
* CASE COM.AI.ERR.FUNC<ONE> EQ AI.UP OR COM.AI.ERR.FUNC<ONE> EQ AI.DN
* IF FUNC NE AI.UP AND FUNC NE AI.DN AND NOT(COM.AI$ON.OFF.STAT EQ AI.OFF AND COM.AI.ERR.FUNC<ONE> EQ AI.UP) THEN
* IF COM.AI$UP.DN.STAT NE COM.AI.ERR.FUNC<ONE> THEN INS COM.AI.ERR.FUNC<ONE> BEFORE FUNC.CHNG<ONE>
* END
* CASE COM.AI.ERR.FUNC<ONE> EQ AI.ON OR COM.AI.ERR.FUNC<ONE> EQ AI.OFF
* IF FUNC NE AI.ON AND FUNC NE AI.OFF THEN
* IF COM.AI$ON.OFF.STAT NE COM.AI.ERR.FUNC<ONE> THEN INS COM.AI.ERR.FUNC<ONE> BEFORE FUNC.CHNG<ONE>
* END
* CASE TRUE; NULL
* END CASE
*
** END; * not orig.func
*
WHILE NOT(FUNC.OK) AND LEN(COM.AI.ERR.FUNC) DO REPEAT
*
END; * err.func present
*
END; * status msgs
*
IF LEN(FUNC.CHNG) THEN
*
ERR.DISP.ONLY = FALSE
IF RUN.TYPE EQ TWO THEN ERR.DISP.ONLY = 5; ERR.BELL = TRUE
GOSUB ERROR; * : * 
TEXT<-ONE> = "The function is being changed from ":FUNC:" to ":FUNC.CHNG<ONE>
ERR.DISP.ONLY = 3
IF RUN.TYPE EQ TWO THEN ERR.DISP.ONLY = 10; ERR.BELL = TRUE
GOSUB ERROR; * : * 
IF FUNC.CHNG<ONE> NE "DI" THEN
SAVE.FUNC = FUNC:AM:SAVE.FUNC
SAVE.FUNC.SUB = FUNC.SUB:AM:SAVE.FUNC.SUB
END
FUNC = FUNC.CHNG<ONE>
DEL FUNC.CHNG<ONE>
*
END; * func.chng
*
GOSUB LOAD.TITLE; * : * 
ERR.BELL = TRUE
IF LEN(TEXT) THEN GOSUB ERROR; * : * 
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
*
*
* EXECute function / subject : *
FUNC.WRITE = FALSE; DISP.ONLY = FALSE; SEND.STATUS = EMPTY
BEGIN CASE
CASE FUNC EQ "DI"; DISP.ONLY = TRUE
CASE FUNC EQ AI.ON; GOSUB START.HANDLER; * : *
CASE FUNC EQ AI.OFF; FUNC.WRITE = TRUE;  GOSUB STOP.HANDLER; * : *
CASE FUNC EQ AI.DN; FUNC.WRITE = TRUE; GOSUB DOWN.HANDLER; * : *
CASE FUNC EQ AI.UP; FUNC.WRITE = TRUE; GOSUB UP.HANDLER; * : *
CASE FUNC EQ "DC"; GOSUB DOWN.CHANNELS; * : *
CASE FUNC EQ "UC"; GOSUB UP.CHANNELS; * : *
* CASE FUNC[ONE,ONE] EQ "S"; GOSUB SPECIAL.FUNC; * : *
CASE FUNC[ONE,ONE] EQ "S"; FUNC.WRITE = TRUE; TEXT<-ONE> = "Special command ":FUNC:",":FUNC.SUB:" present!"; * : *
CASE TRUE; TEXT<-ONE> = "No AI function requested!"; GOSUB ERROR; * : *
END CASE
*
IF FUNC.WRITE THEN
SEND.STATUS = FALSE
GOSUB WRITE.COM.AI; * : *
END
*
IF FUNC[ONE,ONE] EQ "S" THEN
GOSUB SPECIAL.FUNC; * : *
END
*
*: * do any stacked functions *
OLD.FUNC = FUNC:AM:OLD.FUNC
OLD.FUNC.SUB = FUNC.SUB:AM:OLD.FUNC.SUB
FUNC = SAVE.FUNC<ONE>
FUNC.SUB = SAVE.FUNC.SUB<ONE>
WHILE SAVE.FUNC NE EMPTY AND NOT(STAT) DO
DEL SAVE.FUNC<ONE>
DEL SAVE.FUNC.SUB<ONE>
REPEAT
IF FUNC EQ EMPTY THEN FUNC = "DI"
*
$INCLUDE IBP AI.CNTRL.UTIL.DOC.SCNDRY
*
NUM.DISPS = ZERO; DISP.ONLY = TRUE; ERR.DISP.ONLY = TWO
NUM.SLPS = COM.AI$STD.PAUSE
STATUS.CYCLE = TRUE
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
*
*: * Start of DISPlay LOOP * Main 2
LOOP
*
NUM.DISPS = NUM.DISPS + ONE
DT = DATE(); TM = TIME()
IF ABS(TM - AI.SCAN.TM) GT TWO * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
PORTS.LIST.BUILD = 9; PORTS.LIST.PREV = PORTS.LIST; PORTS.LIST = EMPTY
AI.RESET = TRUE; AI.SCAN.DT = DT; AI.SCAN.TM = TM
AI.SCAN = TRUE; SCAN.CONT = TRUE; SCAN.FREQ = -COM.AI$SCAN.FREQ; PORT.VC = ONE
GOSUB RESET.HANDLER; * : *
END
*
LOCK.ITM = TRUE; LOCK.RELS = TRUE; GOSUB READ.COM.AI; * : Main 2
GOSUB READ.STL; * : *
*
TMP = SYSTEM(11); * ULT ONLY
IF NOT(TMP) THEN
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB DISPLAY.STATUS; * : Main 2
*
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES
*IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; * : *
*
END
*
ERR.TEXT = "Press any key to get back to menu . . . "
PRINT @(31,23):CLL:ERR.TEXT:
*
** * : SLP cycle * Main 2
SLP.CN = ZERO
SLP.CN.MAX = NUM.DISPS + NUM.SLPS; * SLP.CN.MAX = (NUM.DISPS * 3) + NUM.SLPS
IF SLP.CN.MAX GT COM.AI$MAX.PAUSE / 4 THEN SLP.CN.MAX = COM.AI$MAX.PAUSE / 7
PRINT @(72,23):SLP.CN.MAX "R#3":
*
LOOP
*
SLP.CN = SLP.CN + COM.AI$STD.PAUSE
*
TMP = SYSTEM(11); * ULT ONLY
*TMP = TRUE; * REV ONLY
*
* Check end of DISP - keyboard buffer * Main 2
IF NOT(TMP OR SLP.CN GT SLP.CN.MAX) THEN
*
PRINT @(76,23):SLP.CN "R#3":
EXEC.VERB = "SLEEP ":COM.AI$STD.PAUSE
*
*ULT ONLY
EXECUTE EXEC.VERB
*PERFORM EXEC.VERB; * ULT ONLY
*
END
*
* Check end of DISP - keyboard buffer * Main 2
*
TMP = SYSTEM(11); * ULT ONLY
*TMP = TRUE; * REV ONLY
IF NOT(TMP) THEN
*
IF FAST.DISPLAY THEN
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK; * : *
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES
TMP = SYSTEM(11); * ULT ONLY
*TMP = TRUE; * REV ONLY
IF NOT(TMP) THEN
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; * : *
END ELSE TEXT = EMPTY
IF NOT(NUM(SEND.STATUS)) THEN
PRINT CLB:BELL:SEND.STATUS:"!!!!!!":; INPUT TMP:
SEND.STATUS = FALSE
END
IF SEND.STATUS THEN PRINT BELL:; SEND.STATUS = FALSE
*
END; * OF FAST.DISPLAY
*
END; * OF TMP
*
* Check end of DISP - keyboard buffer * Main 2
*
TMP = SYSTEM(11); * ULT ONLY
*TMP = TRUE; * REV ONLY
*
* Clear keyboard buffer * (continue) * Main 2
IF TMP THEN
PRINT CLB:"Keyboard interupt being cleared.":
LOOP
TMP1 = SYSTEM(11); * ULT ONLY
*TMP1 = TRUE; * REV ONLY
*
UNTIL NOT(TMP1) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
END
*
*
UNTIL TMP OR OFF.FLAG OR LEN(COM.AI.ERR.FUNC<ONE>) OR SLP.CN GT SLP.CN.MAX DO
*
NULL
*
*end of SLP cycle
*
REPEAT
*
* Check end of DISP - keyboard buffer * Main 2
UNTIL TMP OR OFF.FLAG OR LEN(COM.AI.ERR.FUNC<ONE>) DO 
IF LEN(COM.AI.ERR.FUNC<ONE>) THEN
PRINT CLB:"Interface needs to do a ":COM.AI.ERR.FUNC:"!":BELL:
EXECUTE "SLEEP 2"
END
REPEAT
*
* end of DISPLAY * (keyboard entry present) * Main 2
*  secondary function 
** TMP = SYSTEM(11); * ULT ONLY
** *TMP = TRUE; * REV ONLY
*
*21AUG94* WHILE (NOT(TMP) AND NOT(OFF.FLAG)) OR (COM.AI$FUNC.PORT NE EMPTY OR LEN(COM.AI.ERR.FUNC<ONE>)) DO REPEAT
WHILE (NOT(TMP) AND NOT(OFF.FLAG)) OR ((COM.AI$FUNC.PORT NE EMPTY AND COM.AI.ON AND COM.AI.UP) OR LEN(COM.AI.ERR.FUNC<ONE>)) DO
IF LEN(COM.AI$FUNC.PORT) THEN
PRINT CLB:"Interface needs to do work on port(s) ":COM.AI$FUNC.PORT:"!":BELL:
EXECUTE "SLEEP 2"
END
IF LEN(COM.AI.ERR.FUNC<ONE>) THEN
PRINT CLB:"Interface needs to do a ":COM.AI.ERR.FUNC:"!":BELL:
EXECUTE "SLEEP 2"
END
IF TMP THEN
PRINT CLB:"Keyboard interupt ignored.":
END
REPEAT
* REPEAT FOR LOOP BACK ON ERROR
*
** *
** * Clear keyboard buffer * (continue) * Main 2
** LOOP
** TMP1 = SYSTEM(11); * ULT ONLY
** *TMP1 = TRUE; * REV ONLY
** *
** UNTIL NOT(TMP1) DO
** RSP = EMPTY
** RSP = OCONV(RSP,"U51EA")
** REPEAT
* end of MAIN
* finished
*
STOP; * : end of ROUTINE
*
!!
*
* START OF PROGRAM FUNCTIONS
*
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Read Com Ai" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
*
READ.STL: *
*
$INCLUDE IBP AI.INTFC.STL
*
RETURN
*
!
*
RESET.HANDLER: *
*
SYS.LOC = "INTFC.RESET"; IF CNT.TST$LBL THEN PRINT @(60,20):"Intfc Reset" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
DT = DATE(); TM = TIME()
AI.STATUS = FALSE; HEADEND = EMPTY; COMPONENTS.DFLT = EMPTY
LOCK.ITM = FALSE; LOCK.RELS = FALSE
GOSUB READ.STL
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
*
LOCK.ITM = TRUE; LOCK.RELS = FALSE
GOSUB READ.COM.AI; * : @
*
* MATREAD COM.AIHERR FROM COM.FILE,"AI.HERROR" ELSE MAT COM.AIHERR = EMPTY
IF COM.AI$DB.PREFIX<ONE,DVC.LOC> NE INTFC.CODE THEN
INTFC.CODE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":INTFC.CODE ELSE NULL
END
*
IF ABS(TM - AI.SCAN.TM) GT TWO * COM.AI$MAX.PAUSE + COM.AI$STD.PAUSE THEN
PORTS.LIST.BUILD = 9; PORTS.LIST.PREV = PORTS.LIST; PORTS.LIST = EMPTY
AI.RESET = TRUE; AI.SCAN.DT = DT; AI.SCAN.TM = TM
AI.SCAN = TRUE; SCAN.CONT = TRUE; SCAN.FREQ = -COM.AI$SCAN.FREQ; PORT.VC = ONE
END
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
COM.AI.ERR.DISP = FALSE
GOSUB INTFC.CHECK; * : @
*
IF PORTS.LIST NE PORTS.LIST.PREV THEN
IF PORTS.LIST NE EMPTY THEN
COM.AI$FUNC.PORT<ONE,-ONE> = PORTS.LIST
END
PORTS.LIST.PREV = PORTS.LIST
END
*
DT = DATE(); TM = TIME()
COM.AI$FUNC.DT = DT; COM.AI$FUNC.TM = TM
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
IF LOCK.COM.AI THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
*
* GOSUB FULL.STATUS.CHECK; * : @
*
DT = DATE(); TM = TIME()
AI.RESET = FALSE; RESET.FREQ = TM
*
RETURN
*
!
*
FULL.STATUS.CHECK: *
*
SYS.LOC = "INTFC.CHECK.1"; IF CNT.TST$LBL THEN PRINT @(60,20):"Intfc Check" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
IF COM.AI$CHAN.DN.BRDCST EQ "Y" THEN
IF BROADCAST.REQUIRED THEN
* GOSUB BROADCAST.DN; * : @
END
END
*
RESET.FREQ = TIME()
*
RETURN
*
!
*
WRITE.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Write Com Ai" "L#19":RVE:; RQM
*
IF DISP.ONLY THEN RETURN
*
COM.AI.NOT.ON.FILE = TRUE
COM.AI.ID = "AI.TYPE.":AI.CODE
LOCK.STAT = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
LOOP
LOCK.STAT = LOCK.TYPE; CALL LOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE,LOCK.STAT)
ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LOCK.STAT AND ELP LE 300 DO REPEAT
IF NOT(LOCK.STAT) THEN LOCK.COM.AI = TRUE ELSE
IF LOCK.STAT LT 900 THEN AI.STATUS = LOCK.STAT + 1000 ELSE AI.STATUS = LOCK.STAT
RETURN
END
*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN COM.AI.ON.FILE = TRUE ELSE COM.AI.ON.FILE = FALSE; LOCK.STAT = 998; MAT COM.AI = EMPTY
*
COM.AI.NOT.ON.FILE = FALSE
DT = DATE(); TM = TIME(); ELP = ZERO
*
BEGIN CASE
*
CASE FUNC EQ AI.ON
COM.AI$ON.OFF = AI.ON
COM.AI$ON.OFF.DT = DT
COM.AI$ON.OFF.TM = TM
COM.AI$ON.OFF.C.DT = COM.AI$ON.OFF.DT
COM.AI$ON.OFF.C.TM = COM.AI$ON.OFF.TM
COM.AI$ON.OFF.BY   = OPER
*
CASE FUNC EQ AI.OFF
COM.AI$ON.OFF = AI.OFF
COM.AI$ON.OFF.DT = DT
COM.AI$ON.OFF.TM = TM
COM.AI$ON.OFF.C.DT = COM.AI$ON.OFF.DT
COM.AI$ON.OFF.C.TM = COM.AI$ON.OFF.TM
COM.AI$ON.OFF.BY   = OPER
*
CASE FUNC EQ AI.UP
COM.AI$UP.DN = AI.UP
COM.AI$UP.DN.DT = DT
COM.AI$UP.DN.TM = TM
COM.AI$UP.DN.C.DT = COM.AI$UP.DN.DT
COM.AI$UP.DN.C.TM = COM.AI$UP.DN.TM
COM.AI$UP.DN.BY   = OPER
*
CASE FUNC EQ AI.DN
COM.AI$UP.DN = AI.DN
COM.AI$UP.DN.DT = DT
COM.AI$UP.DN.TM = TM
COM.AI$UP.DN.C.DT = COM.AI$UP.DN.DT
COM.AI$UP.DN.C.TM = COM.AI$UP.DN.TM
COM.AI$UP.DN.BY   = OPER
*
CASE FUNC EQ "UC" OR FUNC EQ "DC" OR FUNC EQ "DI"
*
CASE TRUE; TEXT<-ONE> = "No AI function requested!"; GOSUB ERROR; * : *
*
END CASE
*
IF FUNC NE "UC" AND FUNC NE "DC" AND FUNC NE "DI" THEN
COM.AI$COMMAND = FUNC
COM.AI$COMMAND.DT = DATE()
COM.AI$COMMAND.TM = TIME()
COM.AI$OPER = OPER
END
*
COM.ID = "AI.TYPE.":AI.CODE
COM.AI.ID = COM.ID
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Write Com Ai" "L#19":RVE:; RQM
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
*
!
*
WRITE.COM.AI.UNLOCK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Unlock Com Ai (write)" "L#19":RVE:; RQM
*
IF LOCK.COM.AI THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
*
IF HANDLER.COMMAND<ONE> EQ EMPTY THEN
*
IF LEN(HANDLER.COMMAND) THEN DEL HANDLER.COMMAND<ONE,ONE>
*
END ELSE
*
*COMMAND PRESENT
AI.STATUS = FALSE; SEND.STATUS = FALSE
GOSUB WRITE.COMMAND; * : *
*
IF NOT(AI.STATUS GE 100) THEN
IF FUNC NE AI.ON THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND; * : *
END
END
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK; * : *
*
* COM.AI.ERR.CN.MAX = DCOUNT(COM.AI.ERR,AM)
* COM.AI.ERR.CN = ONE; AI.STATUS = FALSE; SEND.STATUS = FALSE
* LOOP WHILE COM.AI.ERR.CN LE COM.AI.ERR.CN.MAX DO
* TMP = COM.AI.ERR<ONE>
* IF LEN(TMP) THEN
* IF NUM(TMP) THEN
* IF TMP LT 200 AND TMP GT AI.STATUS THEN AI.STATUS = TMP
* IF TMP GE 200 AND TMP GT SEND.STATUS THEN SEND.STATUS = TMP
* END
* END
* COM.AI.ERR.CN = COM.AI.ERR.CN + ONE
* REPEAT
*
IF AI.STATUS GE 100 THEN
*
BEGIN CASE
*
CASE FUNC EQ AI.ON
*DEALT WITH IN ON AREA
*
CASE FUNC EQ AI.OFF
*
IF AI.STATUS NE 121 THEN
*
TEXT<-ONE> = "Your attempt to OFF the HANDLER failed!"; GOSUB ERROR; * : *
*
ERR.TEXT = "Do you want to LOGOFF the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF OFF.TRIED GT ONE THEN RSP = "Y" ELSE RSP = "N"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB LOGOFF.PORT; * : *
END ELSE
*
ERR.TEXT = "Do you want to RESTART the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF OFF.TRIED GT ONE THEN RSP = "N" ELSE RSP = "Y"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB RESTART.PORT; * : *
END
END; * no logoff
END; * 111 OR 181
*
IF COM.AI$ON.OFF.STAT NE AI.OFF OR INDEX(COM.AI.ERR,"111",ONE) OR INDEX(COM.AI.ERR,"181",ONE) THEN
*
ERR.TEXT = "Do you want the HANDLER flagged as OFF anyway (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF OFF.TRIED GT ONE THEN RSP = "N" ELSE RSP = "N"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
LOCK.ITM = TRUE; LOCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF NOT(LOCK.STAT) THEN
IF AI.STATUS GE 100 AND AI.STATUS LT 200 THEN COM.AI$ERR = COM.AI.ERR<ONE>:VM:DT:VM:TM:VM:WHO:VM:AI.STATUS:VM:SEND.STATUS
COM.AI$ON.OFF.STAT = AI.OFF
COM.AI$ON.OFF.C.DT = DATE()
COM.AI$ON.OFF.C.TM = TIME()
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
IF LOCK.COM.AI THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
END
END
*
END ELSE
TEXT<-ONE> = "Your attempt to OFF the Handler was successful."
END; * COM.AI.ERR
*
CASE FUNC EQ AI.UP
TEXT<-ONE> = COM.AI.ERR:" - Handler is being flagged as Down!"; GOSUB ERROR; * : *
LOCK.ITM = TRUE; LOCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF LOCK.COM.AI THEN
COM.AI$UP.DN.STAT = AI.DN
COM.AI$UP.DN.C.DT = DATE()
COM.AI$UP.DN.C.TM = TIME()
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
*
CASE FUNC EQ AI.DN
TEXT<-ONE> = COM.AI.ERR:" - Handler is being flagged as Down anyway!"; GOSUB ERROR; * : *
LOCK.ITM = TRUE; LOCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF LOCK.COM.AI THEN
COM.AI$UP.DN.STAT = AI.DN
COM.AI$UP.DN.C.DT = DATE()
COM.AI$UP.DN.C.TM = TIME()
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
*
CASE FUNC EQ "DI" OR FUNC EQ "UC" OR FUNC EQ "UC"
*
CASE TRUE; TEXT<-ONE> = "No AI function requested!"; GOSUB ERROR; * : *
*
END CASE
*
END; * COM.AI.ERR
END; * HANDLER.COMMAND
*
RETURN
*
!
*
WRITE.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Write Command" "L#19":RVE:; RQM
*
INS FUNC BEFORE HANDLER.COMMAND<ONE,ONE>
*
IF HANDLER.COMMAND EQ EMPTY THEN RETURN
*
*@@@ COM.AIP REC LOAD
WKO$OPERATOR = OPER; OPT.DT = DATE(); OPT.TM = TIME(); OPT.PORT = PORT
OPT.COMM = HANDLER.COMMAND<ONE,ONE>; WOF = "SYS"; LOG.REQUIRED = TRUE
*
AIX.RESET = FALSE; IF WKO.ID EQ EMPTY THEN AIX.RESET = TRUE
MAT COM.AIP = EMPTY
*
*INCLUDE IBP AI.LOAD.COM.AIP.TIERS
$INCLUDE IBP AI.LOAD.COM.AIP
*CALL AI.WRITE.LOG: *
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LOCKS.FILE,LOCK.TYPE)
*
HANDLER.COMMAND = OPT.COMM<ONE,ONE>; AI.STATUS = FALSE; SEND.STATUS = FALSE
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY
*
*CALL AI.WRITE.COMMAND: *
CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LOCK.COM.AI,LOCK.COM.AIP,LOCK.TYPE)
IF AI.STATUS EQ "999" THEN STAT = AI.STATUS
*MAT COM.AIP = EMPTY
*
RETURN
*
!
*
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"WAIT FOR COMMAND" "L#19":RVE:; RQM
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY
*
*INCLUDE IBP AI.INCL.WAITFOR.COMMAND
CALL AI.SUBR.WAITFOR.COMMAND(LOCK.TYPE,LOCK.ITM,LOCK.RELS,LOCK.STAT,LOCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,STAT)
*
*CALL AI.UPD.COM.AIP: *
CALL AI.UPD.COM.AIP(LOCKS.FILE,COM.FILE,COM.AIP.ID,MAT COM.AIP,AI.STATUS,SEND.STATUS,STAT)
*
* Clear keyboard buffer * (continue) *
LOOP
TMP = SYSTEM(11); * ULT ONLY
*TMP = TRUE; * REV ONLY
*
UNTIL NOT(TMP) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
*
RETURN
*
*
START.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"START Handler" "L#19":RVE:; RQM
*
UP.ALL.CHANNELS = FALSE
ERR.TEXT = "Do you want to UP any CHANNELS (Y/ALL/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED GT TWO THEN RSP = EMPTY ELSE RSP = EMPTY
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ "KILL" THEN STAT = TRUE; RETURN
IF RSP EQ "Y" OR RSP EQ "ALL" THEN
IF RSP EQ "ALL" THEN UP.ALL.CHANNELS = TRUE
GOSUB UP.CHANNELS; UP.ALL.CHANNELS = FALSE; * : *
END
*
STATUS.CYCLE = TRUE
HANDLER.COMMAND<ONE,-ONE> = FUNC
*
IF ON.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK; * : *
END
ON.TRIED = ON.TRIED + ONE
IF LEN(COM.AI.ERR) THEN
*?
END
*
GOSUB WRITE.COM.AI; * : *
*
*OUTPUTS = EMPTY
*
FOR PORT.TYPE = ONE TO TWO
*Turn on monitor and handler
*
OUTPUTS = EMPTY; 
NUM.EXECS = ZERO; START.CONT = TRUE
*
LOOP
*
IF START.CONT THEN
NUM.EXECS = NUM.EXECS + ONE
IF LEN(TEXT) THEN ERR.DISP.ONLY = TWO; GOSUB ERROR; * : *
IF PORT.TYPE EQ ONE THEN ERR.TMP = "MONITOR" ELSE ERR.TMP = "HANDLER"
ERR.TEXT = "Starting ":ERR.TMP:". Enter N to cancel or <cr>: "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED GT TWO THEN RSP = "N" ELSE RSP = EMPTY
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ "KILL" THEN STAT = TRUE; RETURN
IF RSP EQ "N" THEN START.CONT = 3
*
IF PORT.TYPE EQ ONE THEN PORT.ON = COM.AI$MONITOR.PORT ELSE PORT.ON = COM.AI$COMMPORT
* IF RSP MATCHES "3N" THEN PORT.ON = RSP
* LOOP WHILE LEN(PORT.ON) LT 3 DO PORT.ON = ZERO:PORT.ON REPEAT
*
IF START.CONT AND START.CONT NE 3 THEN
PRINT @(ZERO,16):(AI.CODE:" ":ERR.TMP:" on ":PORT.ON:".") "L#30"
OUTPUTS<-ONE> = ""; *PRINT " " "L#30"
OUTPUTS<-ONE> = "Now attempting start-up . . ." "L#30"
EXEC.IN = PORT.ON + ZERO:",AI.":ERR.TMP:".":AI.CODE
IF COM.AI$PORT.PASS NE EMPTY THEN
EXEC.IN = EXEC.IN:",":COM.AI$PORT.PASS
END
EXEC.VERB = "LOGON"
EXEC.OUT = EMPTY
OUTPUTS<-ONE> = " " "L#30"
OUTPUTS<-ONE> = EXEC.VERB "L#30"
OUTPUTS<-ONE> = EXEC.IN "L#30"
OUTPUTS<-ONE> = " " "L#30"
*
*ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN, //OUT. > EXEC.OUT
*
LOOP WHILE LEN(EXEC.OUT) AND EXEC.OUT<ONE> EQ EMPTY DO DEL EXEC.OUT<ONE> REPEAT
OUTPUTS<-ONE> = EXEC.OUT
*
START.CONT = NOT(INDEX(EXEC.OUT,"uccessful",ONE) + INDEX(EXEC.OUT,"lready",ONE)) * TWO
IF START.CONT EQ TWO THEN
START.CONT = NOT(INDEX(EXEC.OUT,"UCCESSFUL",ONE) + INDEX(EXEC.OUT,"LREADY",ONE)) * TWO
END
END; * cont
END; * cont
*
IF RUN.TYPE EQ TWO THEN ERR.CR = FALSE; ERR.DISP.ONLY = TWO
ERR.BELL = FALSE; TEXT = OUTPUTS:AM:TEXT; GOSUB ERROR; ERR.BELL = TRUE
*
UNTIL NOT(START.CONT) OR START.CONT GE TWO OR NUM.EXECS GE 3 OR RUN.TYPE EQ TWO DO REPEAT
*
NEXT PORT.TYPE
*
!
*
IF NOT(START.CONT) OR START.CONT EQ TWO THEN
*
IF NOT(START.CONT) THEN
AI.STATUS = FALSE; SEND.STATUS = FALSE; WF.C.FUNC = PORT.KEY
GOSUB WAITFOR.COMMAND; * : *
IF AI.STATUS GE 100 AND AI.STATUS NE 121 THEN START.CONT = AI.STATUS
END
*
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK; * : *
*
IF LEN(COM.AI.ERR) THEN
*
COM.AI.ERR.CN.MAX = DCOUNT(COM.AI.ERR,AM)
COM.AI.ERR.CN = ONE
TEXT<-ONE> = EMPTY
*
LOOP WHILE COM.AI.ERR.CN LE COM.AI.ERR.CN.MAX DO
*
IF NUM(COM.AI.ERR<COM.AI.ERR.CN>) THEN
IF COM.AI.ERR<COM.AI.ERR.CN> THEN
IF COM.AI.ERR<COM.AI.ERR.CN> GE 100 AND COM.AI.ERR<COM.AI.ERR.CN> GT START.CONT THEN START.CONT = COM.AI.ERR<COM.AI.ERR.CN>
TEXT<-ONE> = "[EAI":("000":COM.AI.ERR<COM.AI.ERR.CN>) "R#3":"] ":COM.AI.ERR.TEXT<COM.AI.ERR.CN>
TEMP = FALSE
END ELSE TEMP = TRUE
END ELSE TEMP = TRUE
IF TEMP THEN TEXT<-ONE> = "[EAI   ] ":COM.AI.ERR.TEXT<COM.AI.ERR.CN>
*
COM.AI.ERR.CN = COM.AI.ERR.CN + ONE
*
REPEAT
*
END; * cnt.ai.err
*
END; * start.cont
*
!
*
IF START.CONT THEN
*
DT = DATE(); TM = TIME()
FUNC.RELOOP = FALSE; IF RUN.TYPE EQ TWO THEN ERR.CR = FALSE; ERR.DISP.ONLY = TWO
*
TEXT = OUTPUTS:AM:TEXT
*
TEXT<-ONE> = "Your attempt to ":FUNC:" the HANDLER failed!"; GOSUB ERROR; * : *
!
*
IF START.CONT GT ONE THEN
*
ERR.TEXT = "Do you want to LOGOFF the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED GT TWO THEN RSP = "N" ELSE RSP = "Y"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB LOGOFF.PORT; * : *
FUNC.RELOOP = TRUE
END ELSE
*
ERR.TEXT = "Do you want to RESTART the line and try again (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF UP.TRIED GT TWO THEN RSP = "N" ELSE RSP = "Y"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
GOSUB RESTART.PORT; * : *
FUNC.RELOOP = TRUE
END
END; * no logoff, ? restart
*
!
*
IF NOT(FUNC.RELOOP) THEN
*
ERR.TEXT = "Do you want the HANDLER flagged as ":FUNC:" anyway (Y/<cr>): "
IF RUN.TYPE EQ TWO THEN
IF UP.TRIED GT TWO THEN RSP = "Y" ELSE RSP = "N"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "N"
IF RSP EQ "Y" THEN
LOCK.ITM = TRUE; LOCK.RELS = FALSE; GOSUB READ.COM.AI; * : *
IF LOCK.COM.AI THEN
IF FUNC EQ AI.ON OR FUNC EQ AI.OFF THEN
COM.AI$ON.OFF.STAT = FUNC
COM.AI$ON.OFF.C.DT = DT
COM.AI$ON.OFF.C.TM = TM
COM.AI$ON.OFF.BY   = OPER:".SYS"
END ELSE IF FUNC EQ AI.UP OR FUNC EQ AI.DN THEN
COM.AI$UP.DN.STAT = FUNC
COM.AI$UP.DN.C.DT = DT
COM.AI$UP.DN.C.TM = TM
COM.AI$UP.DN.BY   = OPER:".SYS"
END
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AI.ID,LOCKS.FILE)
LOCK.COM.AI = FALSE
END
END; * 'Y' to flag
*
!
*
ERR.TEXT = "Do you want to try the START again (<cr>/N): "
IF RUN.TYPE EQ TWO THEN
IF ON.TRIED GT TWO THEN RSP = "N" ELSE RSP = "Y"
PRINT CLB:ERR.TEXT:RSP:
EXECUTE "SLEEP 1"
END ELSE
PRINT CLB:ERR.TEXT:; INPUT RSP:
END
IF RSP EQ EMPTY THEN RSP = "Y"
IF RSP EQ "Y" THEN FUNC.RELOOP = TRUE
*
END; * start.cont gt 1
*
END; * func.reloop
*
ON.TRIED = ON.TRIED + ONE
*
IF FUNC.RELOOP THEN GOTO START.HANDLER
*
END; * start.cont
*
*
RETURN
*
!
*
LOGOFF.PORT: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"LOGOFF Port" "L#19":RVE:; RQM
*
EXEC.VERB = "LOGOFF"
TEMP.PORT = COM.AI$COMMPORT
LOOP WHILE LEN(TEMP.PORT) LT 3 DO TEMP.PORT = "0":TEMP.PORT REPEAT
EXEC.IN = TEMP.PORT
EXEC.OUT = EMPTY
*
*ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN, //OUT. > EXEC.OUT
*
LOOP WHILE LEN(EXEC.OUT) AND EXEC.OUT<ONE> EQ EMPTY DO DEL EXEC.OUT<ONE> REPEAT
IF LEN(EXEC.OUT) THEN
TEXT<-ONE> = EXEC.VERB
TEXT<-ONE> = EXEC.IN
TEXT<-ONE> = EXEC.OUT
OUTPUTS<-ONE> = "":AM:TEXT
ERR.DISP.ONLY = 3; GOSUB ERROR
END
*
RETURN
*
*
RESTART.PORT: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"RESTART Port" "L#19":RVE:; RQM
*
EXEC.VERB = ":RESTARTLINE"
TEMP.PORT = COM.AI$COMMPORT
LOOP WHILE LEN(TEMP.PORT) LT 3 DO TEMP.PORT = ZERO:TEMP.PORT REPEAT
EXEC.VERB = EXEC.VERB:" ":TEMP.PORT
EXEC.IN = EMPTY
EXEC.OUT = EMPTY
*
* ULT ONLY
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
*
LOOP WHILE LEN(EXEC.OUT) AND EXEC.OUT<ONE> EQ EMPTY DO DEL EXEC.OUT<ONE> REPEAT
IF LEN(EXEC.OUT) THEN
TEXT<-ONE> = EXEC.VERB
TEXT<-ONE> = EXEC.OUT
OUTPUTS<-ONE> = "":AM:TEXT
ERR.DISP.ONLY = TWO; GOSUB ERROR
END
*
RETURN
*
*
STOP.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"STOP Handler" "L#19":RVE:; RQM
*
HANDLER.COMMAND<ONE,-ONE> = FUNC
*
WRITE "1" ON COM.FILE,"AI.OFF.":COM.AI$MONITOR.PORT
WRITE "1" ON COM.FILE,"AI.OFF.":COM.AI$COMMPORT
*
IF OFF.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK; * :
END
OFF.TRIED = OFF.TRIED + ONE
*
*@@@
RETURN
*
*
UP.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Up Handler" "L#19":RVE:; RQM
*
HANDLER.COMMAND<ONE,-ONE> = FUNC
IF UP.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK; * :
END
UP.TRIED = UP.TRIED + ONE
*
*@@@
RETURN
*
*
DOWN.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Down Handler" "L#19":RVE:; RQM
*
HANDLER.COMMAND<ONE,-ONE> = FUNC
IF DN.TRIED THEN
COM.AI.ERR = EMPTY; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
GOSUB INTFC.CHECK; * :
END
DN.TRIED = DN.TRIED + ONE
*
*@@@
RETURN
*
!
*
UP.CHANNELS: *
*
*CALL AI.CHANNEL.UP: *
CALL AI.CHANNEL.UP(TEXT,ERR.DISP.ONLY,ERR.CLB,COM.FILE,CNT.FILE,PAR.FILE,LOCKS.FILE,CO.DATA,CHANNEL.MLES,DOWNED.CHANNELS.CHANGED,AI.CODE,MAT COM.AI,MAT CNT.TST,UP.ALL.CHANNELS,LOCK.TYPE,STL,STAT)
IF STAT EQ 999 THEN AI.STATUS = STAT
*
RETURN
*
!
*
DOWN.CHANNELS: *
*
*CALL AI.CHANNEL.DN: *
CALL AI.CHANNEL.DN(TEXT,ERR.DISP.ONLY,ERR.CLB,COM.FILE,CNT.FILE,PAR.FILE,LOCKS.FILE,CO.DATA,CHANNEL.MLES,DOWNED.CHANNELS.CHANGED,AI.CODE,MAT COM.AI,MAT CNT.TST,UP.ALL.CHANNELS,LOCK.TYPE,STL,STAT)
IF STAT EQ 999 THEN AI.STATUS = STAT
*
RETURN
*
!
*
SPECIAL.FUNC: *
*
CALL AI.CNTRL.FUNC(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,STAT)
*
RETURN
*
!
*
$INCLUDE IBP AI.CNTRL.UTIL.DISP.HDR
*
!
*
DISPLAY.STATUS: *
*
!
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Display Status" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.INTFC.DISPLAY
*
RETURN
*
!
*
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LOCK.TYPE,LOCK.ITM,LOCK.RELS,LOCK.STAT,LOCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,STAT)
IF STAT EQ 999 THEN AI.STATUS = 999
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INTFC.MESSAGES
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
*
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
*
RETURN
*
END
~BU.AI.TALKER~
SUBROUTINE AI.TALKER(AI.ACTN,AI.RSLT,AI.STATUS,WOF,AIL.ID)
*PROGRAM:           AI.TALKER
* VERSION: 940301 1.2  SET AI.TYPE IN COMMN.AREA TO COM.AI$(AI.CODE:VM:DB.PREFIX).
* PRIOR: 940216 1.1  CHANGE COM.AI.ID FROM HEADEND TO AI.CODE.
EQU VS TO "940216 1.1"
* EQU VS TO "901018 NEW"
* DESCRIPTION:  INTERFACE BETWEEN CSR AND AI SYSTEMS
*
* COPYRIGHT      AXION COMPUTER SYSTEMS LTD.
* 1990                 ALL RIGHTS RESERVED
*
* AI.RSLT IS EQUIVALENT TO STAT
* 99 - NOT A VALID ACTION TYPE
* 1  - SERVICES MISMATCH
* 2  - SERVICE QUANTITIES MISMATCH
* 3  - CONNECTED OUTLETS MISMATCH (EQUIVALENT TO 2)
*
* CHECK THAT THE INSTALLER & INTERFACE MESSAGES HAVE BEEN DISPLAYED
*
* AI.ACTN IS A MULTI-VALUED STRING OF NUMBERED FUNCTIONS TO BE PERFORMED
*
!
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
VERSION = VS
*
!
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP AIL.DIM
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIIERR.DIM
*
!
*
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP WKO.EQUATES
$INCLUDE IBP DVC.EQUATES
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP SAVE.ACT.EQUATES
$INCLUDE IBP AI.TALK.VAR.EQUATES
$INCLUDE IBP FN.VAR.EQUATES
$INCLUDE IBP AI.STATUS.VAR.EQUATES
$INCLUDE IBP AI.ERR.VAR.EQUATES
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP AIL.EQUATES
$INCLUDE IBP COM.AIHERR.EQUATES
$INCLUDE IBP COM.AIIERR.EQUATES
*
!
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STAT = 999; RETURN
OPEN "ACG" TO ACG.FILE ELSE PRINT CLB:"Can't open ACG":; INPUT TMP:; STAT = 999; RETURN
OPEN "AIX" TO AIX.FILE ELSE PRINT CLB:"Can't open AIX":; INPUT TMP:; STAT = 999; RETURN
*
!
*
AUTO.RUN = FALSE; DISP.ONLY = FALSE; MSG.DISP = FALSE; DO.PROMPT = TRUE
LOCK.TYPE = -3; LOCK.ITM = TRUE; LOCK.RELS = FALSE; LOCK.STAT = FALSE
MSG = EMPTY; TEXT = EMPTY; OUTPUTS = EMPTY; STATUS.CYCLE = FALSE
COM.AI.ERR = EMPTY; COM.AI.ERR.DISP = FALSE; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
FUNC.CHNG = EMPTY; AIL.NEXT.ID = AIL.ID
*
REDISP = FALSE; ERR.DISP.ONLY = FALSE; ERR.CLB = TRUE
$INCLUDE IBP AI.ERR.INIT
*
CHECK.LN.MIN = 14; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
CHECK.LEN = 49; CHECK.LN.HI = ZERO
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
CHAN.ALL = FALSE
OPERATOR = ""; HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
*
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.RESET = FALSE; AI.STATUS = FALSE; AI.DOWN = EMPTY; AI.SCAN = FALSE
AI.SRCE = "T"; LOG.REQUIRED = FALSE
* PORTS.LIST.BUILD = 9; PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORT.KEY = PORT
PORTS.LIST.BUILD = EMPTY; PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
!
*
GOSUB LOAD.TST
*
*
IF (CNT.TST$RTN OR CNT.TST$LBL) THEN FAST.DISPLAY = TRUE ELSE FAST.DISPLAY = FALSE
IF AI.TALK<OP.MULTI> THEN SINGLE = 0 ELSE SINGLE = 1
*
*
IF CNT.TST$RTN THEN PRINT CLB:"Entering AI.TALKER for ":AI.ACTN:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
LOCK.ITM = FALSE; LOCK.RELS = FALSE
GOSUB READ.COM.AI
*
*
IF NOT(AI.TALK<INTERFACE.MSG>) THEN AI.ACTN = FN$CHECK.INTFC:AM:AI.ACTN
*
IF NOT(AI.TALK<DISPATCHER.MSG>) THEN AI.ACTN = FN$CHECK.DISPATCHER:AM:AI.ACTN
*
!
*
* START *
*
LOOP
TYPE = AI.ACTN<1>
WHILE TYPE NE EMPTY AND NOT(STAT) DO
BEGIN CASE
*
* GENERAL FUNCTIONS     @@@
*
CASE TYPE EQ FN$CHECK.INTFC; *
MSG.P = MSG<FN$CHECK.INTFC>; GOSUB RTN.CHECK.INTFC; * INTERFACE MSG
*
CASE TYPE EQ FN$INPUT.TRAN
IF INDEX("RC",WOF,1) THEN GOSUB Q12.SERVICES.AS.IS; * WILL SERVICES ON PREMISE BE CHANGED?
IF (AI.TALK<BUILD.WO> AND (WKO.ID EQ "NEW" OR WKO.ID EQ EMPTY)) THEN GOSUB BUILD.WKO
*
CASE AI.TALK<OP.STAT>; NULL; * THE INTERFACE IS DOWN
*
CASE TYPE EQ FN$CHECK.DISPATCHER; *
MSG.P = MSG<FN$CHECK.DISPATCHER>; GOSUB RTN.CHECK.DISPATCHER; * DISPATCHER MSG
*
CASE TYPE EQ FN$INPUT.INSTALLER; *
IF NOT(ADD$STAT EQ "H" OR ADD$STAT EQ "C") THEN RETURN
IF AI.TALK<OP.MULTI> AND WOF EQ "S" THEN RETURN
IF AI.TALK<TALKING> EQ EMPTY THEN GOSUB RTN.INPUT.INSTALLER; * IS SOMEONE AT SITE? (AVAIL TO TEST)
*
CASE TYPE EQ FN$COMPR.SVC; * TYPE = 4
GOSUB RTN.COMPARE.SVC
!
* DISC FUNCTIONS     @@@
*
CASE TYPE EQ FN$INPUT.DISC; * TYPE = 5
GOSUB RTN.INPUT.DISC; * DEACTIVATE SERVICES NOW?
*
CASE TYPE EQ FN$VERIFY.DISC; * TYPE = 15
GOSUB RTN.VERIFY.DISC; * HAS SERVICE BEEN STOPPED OK?
*
CASE TYPE EQ FN$REQRD.WO.DISC; * TYPE = 18
GOSUB RTN.REQRD.WO.DISC; * TECHNICIAN MUST BE SENT TO DEACITIVATE SERVICES
*
CASE TYPE EQ FN$INPUT.PREV.TNT; * TYPE = 21
GOSUB RTN.INPUT.PREV.TNT; * DISCONNECT THE PRIOR TENANT?
*
CASE TYPE EQ FN$INPUT.PREV.ADDR; * TYPE = 22
GOSUB RTN.INPUT.PREV.ADDR; * DISCONNECT THE PRIOR.ADDRESS?
!
* TYPE 6 - ENTERED WORK ORDERS
CASE TYPE EQ FN$INPUT.WO
*
IF WOF NE "D" THEN 
IF ACT$SERVICES = "" THEN CALL CALC.WKO.CHANGES
GOSUB RTN.COMPARE.SVC 
*END ELSE
*AI.TALK<ADDRESSABLE> = AIX.ID
END
**********************************************
* CONNECT AND RECONNECT W/O FUNCTIONS     @@@
*
IF WOF = "R" OR WOF = "C" THEN
*
* COLD CONNECT OR RECONNECT *******************
IF ADD$STAT NE "H" THEN 
*
IF AI.TALK<TALKING> THEN
*
GOSUB RTN.INPUT.WO; * ACTIVATE THE COLD ADDRESS?
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
IF AIX.ID NE EMPTY OR AI.TALK<ADDRESSABLE> NE EMPTY THEN
IF AI.TALK<VERIFIED.HOT> THEN 
GOSUB Q10.CONFIRM.WO; * SERVICES ACTIVE. CONFIRM THE WO?
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
*
END ELSE
*
GOSUB RTN.INPUT.TRY ; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
IF AI.TALK<DO.SEND> THEN
GOSUB ACTIVATE.SERVICES
IF AIX.ID NE EMPTY OR AI.TALK<ADDRESSABLE> NE EMPTY THEN
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO; * CONFIRM THIS WORK ORDER?
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END
*
END
*
GOTO REPEAT.EXIT
END
*
* HOT CONNECT OR RECONNECT *********************
IF ADD$STAT EQ "H" THEN
*
IF AI.TALK<TALKING> THEN
GOSUB RTN.VERIFY.SVC
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB RTN.INPUT.WO; * ACTIVATE SERVICES?
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
IF AIX.ID NE EMPTY OR AI.TALK<ADDRESSABLE> NE EMPTY THEN
IF AI.TALK<VERIFIED.HOT> THEN 
GOSUB Q10.CONFIRM.WO
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END ELSE
GOSUB RTN.INPUT.TRY ; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
IF AI.TALK<DO.SEND> THEN
GOSUB ACTIVATE.SERVICES
IF AIX.ID NE EMPTY OR AI.TALK<ADDRESSABLE> NE EMPTY THEN
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO; * CONFIRM THIS WORK ORDER?
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END
END
GOTO REPEAT.EXIT
END
END
*
*************************************
* DISCONNECTS     @@@@
IF (WOF EQ "D") THEN
*
IF AI.TALK<TALKING> THEN
IF CO.DATA<15> THEN GOSUB RTN.INPUT.PREV.ADDR ELSE GOSUB RTN.INPUT.DISC; * DEACTIVATE SERVICES NOW?
IF AI.TALK<DO.SEND> THEN GOSUB DEACTIVATE.SERVICES
IF NOT(CO.DATA<15>) AND AI.TALK<VERIFIED.COLD> THEN 
GOSUB Q10.CONFIRM.WO; * CONFIRM THE WORK ORDER?
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END ELSE
GOSUB RTN.INPUT.TRY; * Do you want to Activate/Deactivate now?
IF AI.TALK<DO.SEND> THEN 
GOSUB DEACTIVATE.SERVICES
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END
GOTO REPEAT.EXIT
END
*
*************************************
*  SERVICE CHANGES    @@@@
*
IF WOF = "S" THEN
*
IF AIX.ID NE EMPTY OR AI.TALK<ADDRESSABLE> NE EMPTY THEN
IF (AI.TALK<TALKING> AND SINGLE AND NOT(WKO$SCH.DATE > DATE())) THEN
GOSUB RTN.INPUT.TRY
IF AI.TALK<DO.SEND> THEN GOSUB SEND.CHANGE
IF AI.TALK<VERIFIED.CHANGED> THEN 
GOSUB Q10.CONFIRM.WO
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END ELSE
LOOP UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO GOSUB SEND.CHANGE REPEAT
IF AI.TALK<SENT> THEN GOSUB CONFIRM.WKO ELSE
AI.TALK<PRINT.WO> = TRUE
IF WKO$SCH.TYPE = "AI" THEN
WKO$SCH.TYPE = ""; WKO$SCH.DATE = ""
GOSUB P25.RESCHEDULE.WO
END
END
END
END
GOTO REPEAT.EXIT
END
!
*
CASE TYPE EQ FN$VERIFY.SVC; * TYPE = 7
GOSUB RTN.VERIFY.SVC; * ARE SERVICES ACTIVE AT THE ADDRESS?
*
CASE TYPE EQ FN$INPUT.TRY; * TYPE = 8
GOSUB RTN.INPUT.TRY; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
*
* CASE TYPE EQ 9; GOSUB P9.ACTIVATING.PLS.WAIT; * ACTIVATING SERVICES
*
* CASE TYPE EQ 10; GOSUB Q10.CONFIRM.WO; * SERVICES ACTIVATED. CONFIRM NOW?
*
* CASE TYPE EQ 11; GOSUB Q11.DO.CHANGE; * DO YOU WANT TO CHANGE SERVICES NOW?
*
* CASE TYPE EQ 14; GOSUB Q14.RETRY.ACTIVATE; * RESEND ACTIVATE/DEACTIVATE?
*
* CASE TYPE EQ 16; GOSUB Q16.SEND.AGAIN; * (DE)ACTIVATE WAS NOT SUCCESSFUL. SEND AGAIN?
*
* CASE TYPE EQ 19; GOSUB P19.CHANGING.PLS.WAIT
*
* CASE TYPE EQ 20; GOSUB Q20.CHANGED
*
* CASE TYPE EQ 24; GOSUB P24.ENTER.MAINT.WO
!
* FROM AI.SEND.WKO  @@@@
*      TYPE 81 = NO MONITORING. PROCESS WITHOUT PROMPTING
*      TYPE 82 = TO BE MONITORED
*
*
CASE (TYPE EQ 81 OR TYPE EQ 82)
IF TYPE EQ 81 THEN AI.TALK<TALKING> = 0
CALL CALC.WKO.CHANGES
OPERATOR = AI.RSLT; AI.RSLT = ""
IF WOF EQ "R" THEN GOSUB ACTIVATE.SERVICES
IF WOF EQ "D" THEN GOSUB DEACTIVATE.SERVICES
IF WOF EQ "S" THEN GOSUB SEND.CHANGE
IF AI.TALK<SENT> THEN GOSUB CONFIRM.WKO
IF TYPE EQ 82 AND NOT(AI.TALK<NOT.SCHEDULED>) THEN WKO$SCH.DATE = WKO$EFF.DATE
*
RETURN
!
* CANCELLED WORK ORDERS    @@@@
*
CASE TYPE EQ 90; * CANCELLING A CONNECT/RECONNECT. DEACTIVATE SERVICE?
IF AI.TALK<TALKING> THEN
IF ADD$STAT EQ "C" THEN
GOSUB RTN.INPUT.WO
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
END
IF ADD$STAT EQ "H" THEN
GOSUB RTN.VERIFY.SVC
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB RTN.INPUT.WO
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
END
END
*
CASE TYPE EQ 91; * CANCELLING A DISCONNECT. REACTIVATE SERVICE?
IF AI.TALK<TALKING> THEN GOSUB RTN.VERIFY.SVC
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB ACTIVATE.SERVICES
*
CASE TYPE EQ 92; * CANCELLING A SERVICE CHANGE. CHECK SERVICES?
IF AI.TALK<TALKING> THEN GOSUB P23.VERIFY.SERVICES
!
*
CASE TRUE; GOSUB TYPE.ERROR; STAT = 999; RETURN
*
END CASE
*
REPEAT.EXIT: *
DEL AI.ACTN<1>
*
REPEAT
*
IF CNT.TST$RTN THEN PRINT CLB:"Exiting from AI.TALKER.":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF AI.TALK<SENT> AND WKO$STAT # "C" THEN
MSG.P = MSG<27>; GOSUB DISPLAY.PROMPT; * NOW DOING REVERSALS
END
RETURN; * to calling program.     @@@
!
* GENERAL FUNCTIONS     @@@
*
TYPE.ERROR: *
RESULT = 99; STAT = 999
MSG.P = MSG<17>
GOSUB DISPLAY.PROMPT; * : @
*
RETURN
!
RTN.CHECK.DISPATCHER: * DISPLAY DISPATCHER MESSAGE IF REQUIRED
*
DT = DATE(); TM = TIME()
*
IF AI.TALK<DISPATCHER.MSG> THEN RETURN
*
READ DISP.MSG FROM COM.FILE,"DISP.MSG" THEN
TEXT = EMPTY
TMP = DISP.MSG<ONE>
IF LEN(TMP) THEN
IF DISP.MSG<2> LT DT OR (DISP.MSG<2> EQ DT AND DISP.MSG<3> LE TM) OR (DISP.MSG<2> EQ EMPTY AND DISP.MSG<3> LE TM) THEN
IF DISP.MSG<4> GT DT OR (DISP.MSG<4> EQ DT AND DISP.MSG<5> LE TM) OR (DISP.MSG<4> EQ EMPTY AND DISP.MSG<5> LE TM) THEN
IF NOT(ERR.CLB) THEN ERR.DISP.ONLY = 4 ELSE ERR.DISP.ONLY = FALSE
LOOP WHILE LEN(TMP) DO
IF ERR.CLB THEN
TEXT = TEXT:TMP<ONE,ONE>:" "
END ELSE
TEXT<-ONE> = TMP<ONE,ONE>
END
DEL TMP<ONE,ONE>
REPEAT
ERR.HDR = "Dispatcher Message"
IF LEN(TEXT) THEN
TEXT = MSG.P:AM:TEXT
GOSUB ERROR
IF NOT(ERR.CLB) THEN CALL DISPLAY.SERVICES; * : @
END; * of text not empty
END; * of not expired
END; * of past effective
END; * of msg text present
END; * of msg on file
*
AI.TALK<DISPATCHER.MSG> = 1
*
RETURN
*
!
RTN.CHECK.INTFC: * DISPLAY ADDRESS INTERFACE MESSAGE IF REQUIRED
*
DT = DATE(); TM = TIME()
*
IF AI.TALK<INTERFACE.MSG> THEN RETURN
*
READ INTFC.MSG FROM COM.FILE,"INTFC.MSG.":AI.CODE THEN
TEXT = EMPTY; ERR.DISP.ONLY = 4
TMP = INTFC.MSG<ONE>
IF LEN(TMP) THEN
IF INTFC.MSG<2> LT DT OR (INTFC.MSG<2> EQ DT AND INTFC.MSG<3> LE TM) OR (INTFC.MSG<2> EQ EMPTY AND INTFC.MSG<3> LE TM) THEN
IF INTFC.MSG<4> GT DT OR (INTFC.MSG<4> EQ DT AND INTFC.MSG<5> LE TM) OR (INTFC.MSG<4> EQ EMPTY AND INTFC.MSG<5> LE TM) THEN
LOOP WHILE LEN(TMP) DO
IF ERR.CLB THEN
TEXT = TEXT:TMP<ONE,ONE>:" "
END ELSE
TEXT<-ONE> = TMP<ONE,ONE>
END
DEL TMP<ONE,ONE>
REPEAT
ERR.HDR = "Addressable Interface Message"
IF LEN(TEXT) THEN
TEXT = MSG.P:AM:TEXT
ERR.DISP.ONLY = FALSE
IF ERR.CLB THEN GOSUB ERROR 
* IF NOT(ERR.CLB) THEN CALL DISPLAY.SERVICES; * : @
AI.TALK<INTERFACE.MSG> = 1
END; * of text not empty
END; * of not expired
END; * of past effective
END; * of msg text present
END; * of msg on file
*
!
*
* IF (CNT.TST$RTN OR CNT.TST$LBL) THEN COM.AI.ERR.DISP = TWO ELSE COM.AI.ERR.DISP = FALSE
LOCK.ITM = FALSE; LOCK.RELS = TRUE
DT = DATE(); TM = TIME()
LOOP
GOSUB READ.COM.AI; * : @
LOCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF LOCK.STAT EQ 999 THEN STAT = 999; RETURN
WHILE LOCK.STAT AND LOCK.ELP LE 60 DO REPEAT
GOSUB CHECK.HANDLER; * : @
$INCLUDE IBP AI.INTFC.MESSAGES
IF LEN(TEXT) AND AI.STATUS THEN
AI.TALK<OP.STAT> = AI.STATUS
AI.TALK<OP.UP>   = FALSE
GOSUB ERROR 
END
*
IF NOT(ERR.CLB OR ERR.DISP.ONLY) THEN CALL DISPLAY.SERVICES; * : @
*
AI.TALK<INTERFACE.MSG> = 1
*
RETURN
*
!
RTN.INPUT.INSTALLER: * PROMPT CSR TO SEE IF CUSTOMER/INSTALLER AT SITE
*
LOOP
PRINT CLB:MSG<FN$INPUT.INSTALLER>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<TALKING> = 0
IF TMP NE "" THEN
IF TMP EQ "T" THEN AI.TALK<TALKING> = 1
IF TMP EQ "I" THEN AI.TALK<TALKING> = 2
TMP = ""
END
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
*
RETURN
*
!
RTN.COMPARE.SVC: * LOAD AIW RECORD FOR THIS PORT
*
EQUAL.SERVICES = 1; EQUAL.OUTLETS = 1; NO.DVCS = 1
*
* IF AI.TALK<ADDRESSABLE> NE EMPTY THEN RETURN
*
WKO.VC = 1; AIX.SV = 1
IF AI.TALK<OP.MULTI> THEN AIX.VC = AI.TALK<OP.MULTI> ELSE AIX.VC = 1
*
LOOP
*
WKO.ACTIV = WKO$ACTIVS<1,WKO.VC>
*
IF INDEX("AHS",WKO.ACTIV,1) THEN
*
SVC.FOUND = TRUE
IF AIX.ID NE "" THEN
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN DVC$SERVICE<1,AIX.VC> SETTING LOC ELSE SVC.FOUND = FALSE
END ELSE
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN COM.AI$DF.SVCS.ONE<1,DVC.LOC> SETTING LOC ELSE SVC.FOUND = FALSE
END
*
IF SVC.FOUND THEN
*
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN ACT$SERVICES<1> SETTING TMP1 THEN TMP = ACT$QNTYS<1,TMP1> ELSE TMP = 0
*
IF AIX.ID NE "" THEN
*
IF AI.TALK<OP.MULTI> THEN 
IF TMP NE DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC> THEN EQUAL.OUTLETS = 0
END ELSE
IF WKO$ACTIV.QNTYS<1,WKO.VC> LT 0 THEN
IF (NOT(DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC> + WKO$ACTIV.QNTYS<1,WKO.VC> = 0)) THEN EQUAL.OUTLETS = 0
END ELSE
IF (TMP NE DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC>) THEN EQUAL.OUTLETS = 0
END
END
*
END ELSE
NULL; * OUTLETS OK ON ADDRESSABLE (?CHECK ADD?)
END
*
END ELSE
EQUAL.SERVICES = 0
END
*
END; * OF ACTIV AHS
*
WKO.VC = WKO.VC + ONE
UNTIL WKO$ACTIVS<1,WKO.VC> EQ EMPTY OR NOT(EQUAL.SERVICES AND EQUAL.OUTLETS) DO REPEAT
*
IF COUNT(WKO$ACTIVS,"W") THEN EQUAL.OUTLETS = 0
IF COUNT(WKO$ACTIVS,"I") THEN NO.DVCS = 0
*
IF AI.TALK<ADDRESSABLE> NE EMPTY THEN
IF EQUAL.OUTLETS THEN AI.TALK<DO.SEND> = TRUE ELSE AI.TALK<PRINT.WO> = TRUE
END ELSE IF AIX.ID NE EMPTY THEN
* IF EQUAL.SERVICES AND EQUAL.OUTLETS AND NO.DVCS THEN AI.TALK<ADDRESSABLE> = AIX.ID ELSE AI.TALK<PRINT.WO> = TRUE
IF EQUAL.SERVICES AND EQUAL.OUTLETS AND NO.DVCS THEN AI.TALK<DO.SEND> = TRUE ELSE AI.TALK<PRINT.WO> = TRUE
END ELSE AI.TALK<PRINT.WO> = TRUE
*
RETURN
*
!
* DISC PROCESSING     @@@
*
RTN.INPUT.DISC: * DEACTIVATE SERVICES NOW?
*
LOOP
PRINT CLB:MSG<FN$INPUT.DISC>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
*
RETURN
*
!
RTN.VERIFY.DISC: * HAVE SERVICES BEEN STOPPED OK?
*
LOOP
PRINT CLB:MSG<FN$VERIFY.DISC>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.COLD> = 0; AI.TALK<SENT> = 0;  RETURN
IF TMP EQ "Y" THEN AI.TALK<VERIFIED.COLD> = 1
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
*
RETURN
*
!
RTN.REQRD.WO.DISC: * This address will require a premise call
*
MSG.P = MSG<FN$REQRD.WO.DISC>
GOSUB DISPLAY.PROMPT
*
RETURN
*
!
RTN.INPUT.PREV.TNT: * DEACTIVATE SERVICES OF PRIOR TENANT NOW?
*
LOOP
PRINT CLB:MSG<FN$INPUT.PREV.TNT>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
*
RETURN
*
!
RTN.INPUT.PREV.ADDR: * DEACTIVATE SERVICES AT PRIOR ADDRESS NOW?
*
LOOP
PRINT CLB:MSG<FN$INPUT.PREV.ADDR>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
*
!
* CONN PROCESSING     @@@
*
RTN.INPUT.WO: * DO YOU WANT TO ACTIVATE THE OP SERVICES?
LOOP
PRINT CLB:MSG<FN$INPUT.WO>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
RTN.VERIFY.SVC: * ARE SERVICES BEING RECEIVED OK AT THIS ADDRESS?
LOOP
PRINT CLB:MSG<FN$VERIFY.SVC>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.HOT> = 0; AI.TALK<SENT> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<VERIFIED.HOT> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
RTN.INPUT.TRY: * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
LOOP
PRINT CLB:MSG<FN$INPUT.TRY>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1; RETURN
IF TMP EQ "N" THEN AI.TALK<DO.SEND> = 0
UNTIL TMP EQ "N" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P9.ACTIVATING.PLS.WAIT: * ACTIVATING SERVICES. PLEASE WAIT...
MSG.P = MSG<9>; DO.PROMPT = FALSE
GOSUB DISPLAY.PROMPT
RETURN
!
Q10.CONFIRM.WO: * CONFIRM THE WORK ORDER?
*
RETURN
*
LOOP
PRINT CLB:MSG<10>:; INPUT TMP:
IF TMP EQ "KILL" THEN
* IF (WOF EQ "C" OR WOF EQ "R") THEN
* IF AI.TALK<TALKING> THEN
* GOSUB DEACTIVATE.SERVICES
* GOSUB RTN.VERIFY.DISC
* IF NOT(AI.TALK<VERIFIED.HOT>) THEN
* LOOP
* GOSUB DEACTIVATE.SERVICES
* IF NOT(AI.TALK<VERIFIED.COLD>) THEN GOSUB Q16.SEND.AGAIN
* UNTIL AI.TALK<VERIFIED.COLD> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
* END
* IF WOF EQ "D" THEN
* END
* IF WOF EQ "S" THEN
* END
* IF NOT(AI.TALK<VERIFIED.COLD>) THEN GOSUB RTN.REQRD.WO.DISC
* END ELSE
* IF NOT(AI.TALK<VERIFIED.CHANGED>) THEN GOSUB RTN.REQRD.WO.DISC
* END
* END
STAT = 999
RETURN
END
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
RETURN
!
Q11.DO.CHANGE: * DO A SERVICE CHANGE?
LOOP
PRINT CLB:MSG<11>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN RETURN
IF TMP EQ "Y" THEN
TMP<1> = "S"
CALL MAINT.WORK.ORDER
RETURN
TMP = ""
END
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
RETURN
!
Q12.SERVICES.AS.IS: * WILL THERE BE A CHANGE TO OP SERVICES?
LOOP
PRINT CLB:MSG<12>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF INDEX("RC",WOF,1) AND (TMP EQ EMPTY OR TMP EQ "N") THEN AI.TALK<BUILD.WO> = 1; RETURN
IF TMP EQ "Y" THEN AI.TALK<PRINT.WO> = TRUE; RETURN
UNTIL TMP NE "Y" OR TMP = EMPTY DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P13.DEACTIVATING.PLS.WAIT: * DEACTIVATING SERVICES. PLEASE WAIT...
MSG.P = MSG<13>; DO.PROMPT = FALSE
GOSUB DISPLAY.PROMPT;
RETURN
!
* Q14.RETRY.ACTIVATE: * RETRY ACTIVATING SERVICES
* LOOP
* PRINT CLB:MSG<14>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
* IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
* IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
* UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
* TMP = ""
* RETURN
!
Q16.SEND.AGAIN: * ACTIVATE/DEACTIVATE WAS NOT SUCCESSFUL. SEND AGAIN?
LOOP
PRINT CLB:MSG<16>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P25.RESCHEDULE.WO: * THE WORK ORDER MUST BE RESCHEDULED
MSG.P = MSG<25>
WKO$SCH.TYPE = ""
WKO$SCH.DATE = ""
GOSUB DISPLAY.PROMPT
RETURN
!
P19.CHANGING.PLS.WAIT: *
MSG.P = MSG<19>; DO.PROMPT = FALSE
GOSUB DISPLAY.PROMPT
RETURN
!
Q20.CHANGED: *
LOOP
PRINT CLB:MSG<20>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.CHANGED> = 0; AI.TALK<SENT> = 0;  RETURN
IF TMP EQ "Y" THEN AI.TALK<VERIFIED.CHANGED> = 1
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P23.VERIFY.SERVICES: * PLEASE CHECK CURRENT SERVICES RECEIVED OK.
MSG.P = MSG<23>
GOSUB DISPLAY.PROMPT
RETURN
!
P24.ENTER.MAINT.WO: *
MSG.P = MSG<24>
GOSUB DISPLAY.PROMPT
RETURN
!
DISPLAY.PROMPT: * DISPLAY MSG AND PROMPT 'ENTER <cr>' IF DO.PROMPT
LOOP
PRINT CLB:MSG.P:; IF DO.PROMPT THEN INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
MSG.P = ""; DO.PROMPT = 1
RETURN
!
CONFIRM.WKO: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering CONFIRM.WKO":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
RETURN
*
IF WOF # "D" AND WKO$EFF.DATE LT DATE() THEN WKO$EFF.DATE = DATE()
IF TYPE # 81 AND WOF EQ "D" THEN WKO$EFF.DATE = DATE() ELSE WKO$EFF.DATE = DATE()+1
WKO$STAT = "C"
WKO$INSTALLER = "!AI"
IF TYPE[1,1] = 8 THEN OPERATOR = "!AI"
WKO$OPERATOR = WKO$OPERATOR:"*":OPERATOR
WKO$COMPL.DATE = DATE()
IF WOF EQ "D" THEN ADD$STAT = "C"; ADD$HOT.OUTLETS = 0; WKO$TYPE = "SS" ELSE
* 9JUL91 IF WOF NE "R" THEN
* A PENDING OR FROM AI.SEND.WKO
IF TYPE[1,1] = 8 OR ACT$SERVICES = "" THEN
MAT SAVE.ACT = MAT ACT
IF TYPE = 82 OR TYPE = 91 THEN CALL DISPLAY.WORK.ORDER.CALCS
END
END
MAT SAVE.ACT = MAT ACT
RSP = "C"; CALL CONFIRM.WORK.ORDER
CALL UPDATE.FILES; RSP = "S"; CALL DISPLAY.BASIC.DATA; CALL DISPLAY.SERVICES; AI.TALK<WKO.STAT> = "C"; RSP = "C"
LOOP UNTIL UPDATED = EMPTY DO
ITEM.NAME = UPDATED<ONE>
POS = INDEX(ITEM.NAME,"*",ONE)
FILE.NAME = ITEM.NAME[ONE,POS - ONE]
ITEM.NAME = ITEM.NAME[POS + ONE,999]
CALL UNLOCK.ITEM(LOCKS.FILE,FILE.NAME,ITEM.NAME,LOCKS.FILE)
DEL UPDATED<ONE>
REPEAT
RETURN
!
ACTIVATE.SERVICES: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering ACTIVATE.SERVICES":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
* 1. SEND ACTIVATE
* 2. IF NOT SUCCESSFUL
*       GOSUB Q16.SEND.AGAIN (NOT SUCCESSFUL. SEND AGAIN?)
*       REPEAT UNTIL SUCCESSFUL (SENT)
*                 OR NO RESEND  (NOT ACTIVATE)
* 3 IF SUCCESSFUL
*      SET SENT
AI.CNTRL.NUM = ONE
GOSUB ATTEMPT.COMMAND
*
*21MAR94*LOOP
*21MAR94**
*21MAR94*GOSUB P9.ACTIVATING.PLS.WAIT; * ACTIVATING SERVICES. PLEASE WAIT...
*21MAR94**
*21MAR94*AI.TALK<SENT> = FALSE; AI.STATUS = FALSE
*21MAR94*GOSUB WRITE.COMMAND; * : @
*21MAR94**
*21MAR94*IF NOT(AI.STATUS) THEN
*21MAR94*WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND;* : @
*21MAR94*IF NOT(AI.STATUS) THEN AI.TALK<SENT> = TRUE
*21MAR94*END
*21MAR94**
*21MAR94*IF NOT(AI.TALK<SENT>) THEN 
*21MAR94*GOSUB Q16.SEND.AGAIN; * NOT SUCCESSFUL, SEND AGAIN?
*21MAR94*END ELSE
*21MAR94*IF AI.TALK<TALKING> THEN
*21MAR94*GOSUB RTN.VERIFY.SVC; * ARE SERVICES BEING RECEIVED OK?
21MAR94*IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB Q16.SEND.AGAIN
21MAR94*END
21MAR94*END
21MAR94*IF STAT = 999 THEN RETURN
21MAR94*UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
RETURN
!
DEACTIVATE.SERVICES: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering DEACTIVATE.SERVICES":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
* HANDLED THE SAME AS THE ABOVE.
AI.CNTRL.NUM = TWO
GOSUB ATTEMPT.COMMAND
*21MAR94*LOOP
*21MAR94*GOSUB P13.DEACTIVATING.PLS.WAIT
*21MAR94*AI.TALK<SENT> = FALSE; AI.STATUS = FALSE
*21MAR94*GOSUB WRITE.COMMAND; * : @
*21MAR94**
*21MAR94*IF NOT(AI.STATUS) THEN
*21MAR94*WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND;* : @
*21MAR94*IF NOT(AI.STATUS) THEN AI.TALK<SENT> = TRUE
*21MAR94*END
*21MAR94**
*21MAR94*IF NOT(AI.TALK<SENT>) THEN 
*21MAR94*GOSUB Q16.SEND.AGAIN; * NOT SUCCESSFUL, SEND AGAIN?
*21MAR94*END ELSE
*21MAR94*IF AI.TALK<TALKING> THEN
*21MAR94*GOSUB RTN.VERIFY.DISC; * HAVE SERVICES BEEN STOPPED?
*21MAR94*IF NOT(AI.TALK<VERIFIED.COLD>) THEN GOSUB Q16.SEND.AGAIN
*21MAR94*END
21MAR94*END
21MAR94*IF STAT = 999 THEN RETURN
21MAR94*UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
RETURN
!
SEND.CHANGE: *
* 1. SEND CHANGE
* 2. IF NOT SUCCESSFUL
*       GOSUB Q16.SEND.AGAIN (NOT SUCCESSFUL. SEND AGAIN?)
*       REPEAT UNTIL SUCCESSFUL (AI.TALK<SENT>)
*                 OR NO RESEND  (NOT ACTIVATE)
* 3 IF SUCCESSFUL
*      SET AI.TALK<SENT>
AI.CNTRL.NUM = 3
GOSUB ATTEMPT.COMMAND
*21MAR94*LOOP
*21MAR94*GOSUB P19.CHANGING.PLS.WAIT; * CHANGING SERVICES. PLEASE WAIT...
*21MAR94*AI.TALK<SENT> = FALSE; AI.STATUS = FALSE
*21MAR94*GOSUB WRITE.COMMAND; * : @
*21MAR94**
*21MAR94*IF NOT(AI.STATUS) THEN
*21MAR94*WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND;* : @
*21MAR94*IF NOT(AI.STATUS) THEN AI.TALK<SENT> = TRUE
*21MAR94*END
*21MAR94**
*21MAR94*IF NOT(AI.TALK<SENT>) THEN 
*21MAR94*GOSUB Q16.SEND.AGAIN; * NOT SUCCESSFUL, SEND AGAIN?
*21MAR94*END ELSE
*21MAR94*IF AI.TALK<TALKING> THEN
*21MAR94*GOSUB Q20.CHANGED; * HAVE SERVICES BEING CHANGED OK?
*21MAR94*IF NOT(AI.TALK<VERIFIED.CHANGED>) THEN GOSUB Q16.SEND.AGAIN
*21MAR94*END
21MAR94*END
21MAR94*IF STAT = 999 THEN RETURN
21MAR94*UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
RETURN
!
BUILD.WKO: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering BUILD.WKO":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
IF WKO$ACTIV.SERVICES<1,1> NE "" THEN RETURN
AIX.VC = ADD$AIX.LOCATION; IF AIX.VC = "" THEN AIX.VC = 1
IF DVC$SERVICE<1,AIX.VC> NE "" THEN
AI.TALK<BUILD.WO> = 1; AIX.SV = 1; WKO.VC = 1
LOOP SVC.ID = DVC$SERVICE<1,AIX.VC,AIX.SV> UNTIL SVC.ID EQ EMPTY DO
IF NOT(WKO.VC EQ 1) THEN WKO$ACTIVS<1,WKO.VC> = WKO$ACTIVS<1,WKO.VC>:"!S"
WKO$ACTIV.SERVICES<1,WKO.VC> = WKO$ACTIV.SERVICES<1,WKO.VC>: "!":SVC.ID
WKO$ACTIV.QNTYS<1,WKO.VC> = WKO$ACTIV.QNTYS<1,WKO.VC>: "!":DVC$CONNECTED.OUTLETS<1,AIX.VC,AIX.SV>
AIX.SV = AIX.SV+1; WKO.VC = WKO.VC+1
REPEAT
END
RETURN
!
ATTEMPT.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Attempt Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
IF AI.CNTRL.NUM EQ ONE THEN
AI.CNTRL.CHECK = VERIFIED.HOT
END ELSE IF AI.CNTRL.NUM EQ TWO THEN
AI.CNTRL.CHECK = VERIFIED.COLD
END ELSE IF AI.CNTRL.NUM EQ 3 THEN
AI.CNTRL.CHECK = VERIFIED.CHANGED
END ELSE
AI.CNTRL.NUM = 4
AI.CNTRL.CHECK = VERIFIED.CHANGED
END
*
LOOP
*
ON AI.CNTRL.NUM GOSUB P9.ACTIVATING.PLS.WAIT,P13.DEACTIVATING.PLS.WAIT,P19.CHANGING.PLS.WAIT,P19.CHANGING.PLS.WAIT
*
* 1 ACTIVATING SERVICES. PLEASE WAIT . . . 
* 2 DEACTIVATING SERVICES
* 3 CHANGING SERVICES
* 4 UNKNOWN (USE CHANGE)
*
AI.TALK<SENT> = FALSE; AI.STATUS = FALSE
GOSUB WRITE.COMMAND; * : @
*
IF NOT(AI.STATUS) THEN
WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND;* : @
IF NOT(AI.STATUS) THEN AI.TALK<SENT> = TRUE
END
*
IF NOT(AI.TALK<SENT>) THEN 
*
GOSUB Q16.SEND.AGAIN; * NOT SUCCESSFUL, SEND AGAIN?
*
END ELSE
*
IF AI.TALK<TALKING> THEN
*
ON AI.CNTRL.NUM GOSUB RTN.VERIFY.SVC,RTN.VERIFY.DISC,Q20.CHANGED,Q20.CHANGED
*
* ARE SERVICES BEING RECEIVED OK?
* HAVE SERVICES BEEN STOPPED?
* HAVE SERVICES BEEN CHANGED OK?
*
IF NOT(AI.TALK<AI.CNTRL.CHECK>) THEN GOSUB Q16.SEND.AGAIN
*
END
*
END
*
IF STAT EQ 999 THEN RETURN
*
UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
*
RETURN
!
WRITE.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Write Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*
* @@@ COM.AIP REC LOAD
*
HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
OPT.DT = DATE(); OPT.TM = TIME()
DT = OPT.DT; TM = OPT.TM
OPT.ORIG.SVC.ID = DVC$SERVICE; HANDLER.COMMAND = "AIDVC"; AI.STATUS = FALSE
OPT.COMM = HANDLER.COMMAND
LOCK.ITM = TRUE; LOCK.RELS = TRUE 
*21MAR94*
IF STAT THEN RETURN
*21MAR94*^
*
LOOP
GOSUB READ.COM.AI; * : @
LOCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LOCK.STAT AND LOCK.STAT NE 998 AND LOCK.ELP LE 60 DO REPEAT
*
IF LOCK.STAT EQ 998 THEN
MSG.P = "Transaction cancelled - Interface info missing! Enter <cr>: "
END ELSE
IF LOCK.STAT THEN
MSG.P = "Transaction cancelled - Interface locks error!! Again (Y/<cr>): "
END
IF LOCK.STAT THEN
GOSUB DISPLAY.PROMPT
IF RSP EQ "Y" THEN STAT = FALSE; GOTO WRITE.COMMAND
AI.STATUS = LOCK.STAT; STAT = 999
END
*
IF NOT(STAT) THEN
*
MAT COM.AIP = EMPTY
*
$INCLUDE IBP AI.LOAD.COM.AIP.TIERS
$INCLUDE IBP AI.LOAD.COM.AIP
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY
*
CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,COMMPORT)
*
*21MAR94*END; * OF NOT STAT
*
LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
IF COM.AI$FUNC.PORT NE EMPTY THEN COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM
COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:PORT.KEY
END
*
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
*
*
LOCK.ITM = TRUE; LOCK.RELS = TRUE
GOSUB READ.COM.AI.UNLOCK
*
*21MAR94*
END; * OF STAT
*
END; * OF LOCK.STAT 998
*
RETURN
!
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT CLB:"WAIT FOR COMMAND":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
$INCLUDE IBP AI.INTFC.WAITFOR.COMMAND
*
LOCATE ERR$NO.UNIT IN COM.AIP$ERR<ONE> SETTING TMP THEN
TMP = FIELD(AIX.ID,"*",2); * NO SUCH SERIAL NUMBER
MSG.P = TMP:MSG<26>; GOSUB DISPLAY.PROMPT
END
*
RETURN
!
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
VC = 1; HIT = 0
LOOP
AI.CODE = AI.TYPES<1,VC>
LOCATE HEADEND IN AI.TYPES<4,VC> SETTING LOC THEN HIT = 1 ELSE HIT = 0
UNTIL AI.CODE = "" OR HIT DO VC = VC+1 REPEAT
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
*
DVC.TYPE = DVC$TYPE
*
!
*
COM.AI.NOT.ON.FILE = TRUE
COM.AI.ID = "AI.TYPE.":AI.CODE
* LOCK.ITM = TRUE; LOCK.RELS = TRUE
SAVE.DISP.ONLY = DISP.ONLY; DISP.ONLY = FALSE
*
$INCLUDE IBP AI.READ.COM.AI
*
COMMPORT = COM.AI$COMMPORT; AI.TYPE = COM.AI.ID:VM:COM.AI$DB.PREFIX
!
*
* 16-FEB-91 * LOCATE DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
*
 EQUIP.TYPE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
*
READ MSG FROM COM.FILE,"AI.TALKER.MSGS.":EQUIP.TYPE ELSE
PRINT CLB:"Can't find COM AI.TALKER.MSGS.":EQUIP.TYPE
STAT = 999
RETURN
END
*
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":EQUIP.TYPE ELSE MAT COM.AIIERR = EMPTY
*
*
DISP.ONLY = SAVE.DISP.ONLY
*
IF COM.AI$GENIE.WINDOW EQ "Y" THEN COM.AI.ERR.DISP = TWO
*
RETURN
!
CHECK.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Check Handler":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
* $INCLUDE IBP AI.INTFC.CHECK
CALL AI.CHECK.HANDLER(LOCK.TYPE,LOCK.ITM,LOCK.RELS,LOCK.STAT,COMMPORT,HEADEND,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,STAT)
*
RETURN
*
!
WRITE.LOG: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Write Log":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF LOG.REQUIRED THEN
$INCLUDE IBP AI.LOG.WRITE
LOG.REQUIRED = FALSE
END
*
RETURN
*
!
ERROR: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Error Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
!
*
RETURN
!
END
~BU.AI.WRITE.COMMAND~
SUBROUTINE AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS)
*SUBROUTINE: AI.WRITE.COMMAND
*
* AUTHOR: DAVID G. HORSMAN
* COMPANY: Written for AXION COMPUTER SYSTEMS INC.
*
* DATE RELEASED: ?? DEC 90
*
*      Write a command onto the port's work file record for transmission...
*
!
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP SAVE.COM.AIP.DIM
!
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AI.STATUS.VAR.EQUATES
!
OPEN "COM" TO COM.FILE ELSE PRINT @(0,23):CLL:"Can't open COM":; INPUT RSP:; STOP
OPEN "LOCKS" TO LOCKS.FILE ELSE PRINT @(0,23):CLL:"Can't open LOCKS":; INPUT RSP:; STOP
*
!
*
*IF NOT(NUM(HANDLER.COMMAND<ONE>)) THEN
*IF HANDLER.COMMAND<ONE> EQ AI.UP THEN AI.STATUS = FALSE ELSE AI.STATUS = TRUE
*END
*
PREV.DT = DATE(); PREV.TM = TIME()
*
*IF HANDLER.COMMAND NE EMPTY THEN AI.STATUS = HANDLER.COMMAND; RETURN
*
IF COM.AIP.ID EQ EMPTY THEN AI.STATUS = 21; RETURN
*
MAT SAVE.COM.AIP = MAT COM.AIP; RETRY = 0
*
PRINT @(0,23):CLL:@(31):
*
IF COM.AI$UP.DN.STAT NE AI.UP THEN
PRINT @(31,22):BELL:RVB:"The Addressable Interface Handler is down" "L#48":RVE:
IF NOT(INDEX("*":AI.ON:"*":AI.UP:"*":AI.OFF:"*","*":HANDLER.COMMAND<ONE>:"*",ONE)) THEN
PRINT @(31,23):" -- press <cr>...":
INPUT RSP:; PRINT @(31,23):SPACE(48):
*HANDLER.COMMAND = 1; 
AI.STATUS = 11; RETURN
END
END
*
!
*
* Main program loop
*
RETRY.CONT = TRUE
OVERWRITE.FLAG = FALSE
*
*
LOOP
*
*
* LOCK ITEM
*
LOCK.CN = ONE
LOCK.FLAG = FALSE
LOOP
*
LOCK.STAT = -ONE
CALL LOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE,LOCK.STAT); * lock out the COM.AIP file
IF LOCK.STAT GE 900 THEN HANDLER.LOCK.STATUS = LOCK.STAT
IF NOT(LOCK.STAT) THEN LOCK.FLAG = TRUE
*
UNTIL LOCK.FLAG OR LOCK.CN GT 2 DO LOCK.CN = LOCK.CN + ONE REPEAT
*
!
*
*
IF NOT(LOCK.FLAG) THEN MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT = "LOCKED" ELSE
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = EMPTY; COM.AIP$COMM.PORT = EMPTY
END
*
IF COM.AIP$COMM.PORT EQ EMPTY THEN OVERWRITE.FLAG = TRUE
*
UNTIL (LOCK.FLAG OR LOCK.CN GT 2) AND (OVERWRITE.FLAG OR NOT(RETRY.CONT) OR OVERWRITE.FLAG) DO
*
RETRY = RETRY + ONE
CURR.ELP = ((DATE() - PREV.DT) * 86400) + (TIME() - PREV.TM)
*
IF (CURR.ELP LE COM.AI$MAX.PAUSE AND COM.AI$UP.DN.STAT EQ AI.UP) AND SYSTEM(11) LE 3 THEN
*
PRINT @(31,23):RVB:("Handler Command attempt #":RETRY:" at time ":CURR.ELP) "L#48":RVE:
*
IF LOCK.FLAG THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
LOCK.FLAG = FALSE
END
RQM
PRINT @(31,23):SPACE(48):
END ELSE
*
PREV.DT = DATE(); PREV.TM = TIME()
PRINT BELL:
*
IF COM.AI$UP.DN.STAT EQ AI.UP THEN
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command has not been sent -- wait longer? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
END ELSE RSP = "N"
*
IF RSP EQ "Y" THEN
RETRY.CONT = TRUE
PREV.DT = DATE(); PREV.TM = TIME()
END ELSE
*
PRINT BELL:
*
LOOP
PRINT @(ZERO,23):CLL:RVB:"The prior command will be lost -- overwrite it? (Y/N) ":RVE:
INPUT RSP:; PRINT @(ZERO,23):CLL:
UNTIL RSP EQ "Y" OR RSP EQ "N" DO REPEAT
*
IF RSP EQ "Y" THEN
* Yes, overwrite item
MATWRITE COM.AIP ON COM.FILE,DATE():"@":TIME():"@":COM.AIP.ID
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
RETRY.CONT = TRUE
OVERWRITE.FLAG = TRUE
PRINT @(ZERO,23):CLL:@(31):BELL:RVB:("Handler Command over-ride placed at ":OCONV(TIME(),"MTS")) "L#48":RVE:
END ELSE
* No, do not overwrite item
RETRY.CONT = FALSE
OVERWRITE.FLAG = FALSE
PRINT @(ZERO,23):CLL:@(31):BELL:RVB:("Handler Command Request denied at ":CURR.ELP) "L#48":RVE:
END; * of Y/N to overwrite
*
END; * of do not continue to wait for prior command
*
END; * of more than six waits for the command
*
REPEAT
* for repeated attempts to send the command
*
!
*
IF OVERWRITE.FLAG AND LOCK.FLAG THEN
*
MAT COM.AIP = MAT SAVE.COM.AIP
MATWRITE COM.AIP ON COM.FILE,COM.AIP.ID
*
PRINT @(31,23):RVB:"The Handler Command has been submitted." "L#48":RVE:
RQM
*
END; * of overwrite flag set
*
IF LOCK.FLAG THEN
CALL UNLOCK.ITEM(COM.FILE,"COM",COM.AIP.ID,LOCKS.FILE)
END
*
RETURN
!
END
~BU.CASH.LBOX.IMP.SPLIT~
*PROGRAM:         CASH.LBOX.IMP.SPLIT
* VERSION: 910611 1.0  SPLIT PAYMENTS TAPE IMPORT FILE & VERIFY
EQU VS TO "1.0"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1991              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
* DESCRIPTION:     THIS PROGRAM PROCESSES THE XTR FILE.
* If valid the data is output to the CAJ files for each company.
* This file is transfered to the host not more than once per day. It con-
* tains payments to be applied to customer acccounts. There can be more
* than one day to process at a time. Payments for all three companies can
* be present and are handler appropriately through file pointers.
*  
* DATE WRITTEN:    11 JUN 91
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*
$INCLUDE IBP XTR.IND.DIM
$INCLUDE IBP XTR.TRANS.DIM
*
$INCLUDE IBP XTR.IND.EQUATES
$INCLUDE IBP XTR.TRANS.EQUATES
*
OPEN "XTR" TO XTR.FILE ELSE PRINT "Can't open file XTR"; INPUT RSP; STOP
* ULT ONLY
OPEN "LOCKS" TO LOCKS.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
* LOCKS.FILE = ZERO; * REV ONLY
*
MAX.DESC = ONE; DESC.LEN = 5; INPUT.DESC = "N"
INPUT ENTRY.TYPE
*
TITLE = "Process Imported Payments - Validate Transmission"; TRANS.CLASS = 'p'; TRANS.ITEM = "TRANS.TYPES.PMT"
*
XTR = EMPTY; XTR.HDR = EMPTY; MAT XTR.TRANS = EMPTY; MAT XTR.IND = EMPTY
XTR.ERRORS = EMPTY
SOURCE = "C"; LC.SOURCE = CHAR(SEQ(SOURCE)+32)
OPERATOR = "LBox"; DEFAULT.TYPE = "?"; ITEM.COUNT = 0
BATCH.STATUS = "E"; ENTRY.TIME = EMPTY; ENTRY.DATE = EMPTY
POST.DATE = EMPTY; POST.TIME = EMPTY; BUS.DATE = EMPTY; EFF.DATE = EMPTY
DEFAULT.TYPE = "?"
RUN.TRANS.CLASS = TRANS.CLASS
RUN.SOURCE = SOURCE
RUN.LC.SOURCE = LC.SOURCE
*
CO.PRE = EMPTY; CO.FIRST = TRUE
GOSUB OPEN.COMPANY
*
LOCK.STAT = -ONE; CALL LOCK.ITEM(XTR.FILE,"XTR","XTR.CTL",LOCKS.FILE,LOCK.STAT)
IF LOCK.STAT THEN STOP
MATREAD XTR.IND FROM XTR.FILE,"XTR.CTL" ELSE MAT XTR.IND = EMPTY
DOLLAR.EDIT = ""; STAT = ""; POSTED.BATCHES = ""
!
START: *
XTR.DT.CURR = EMPTY; XTR.DT = EMPTY
XTR.FOUND = EMPTY; MAT XTR.TRANS = EMPTY; XTR.HDR = EMPTY; XTR.ERRORS = EMPTY
XTR.ERR = ZERO; XTR.ERR.CN = ZERO
XTR.SEQ = ZERO; XTR.SEQ.LAST = ZERO
XTR.BAT = ZERO; XTR.BAT.LAST = ZERO
XTR.REC.CN = ZERO; XTR.TOT.REMT = ZERO; XTR.REMT.CN = ZERO
XTR.BAT.TOT.REMT = ZERO; XTR.BAT.REMT.CN = ZERO; XTR.BAT.ERR = FALSE
XTR.BAF.TOT.REMT = ZERO; XTR.BAF.REMT.CN = ZERO
XTR.ITEM.CN = ZERO; XTR.ITEM = ZERO; XTR.ITEM.LAST = ZERO
!
*
VALIDATE.FILE: *
*
*Select the XTR file by date*sequence number
*
EXECUTE "SSELECT XTR"
*
LOOP
*
LOOP
*
*Read next record
*
READNEXT XTR.ID ELSE XTR.ID = "@@@"
XTR.SEQ  = FIELD(XTR.ID,"*",TWO)
IF XTR.ID NE "@@@" AND XTR.ID NE "XTR.CTL" AND XTR.SEQ NE "HDR" AND XTR.SEQ NE "TRANS" AND XTR.SEQ NE "ERR" THEN
READ XTR FROM XTR.FILE,XTR.ID ELSE XTR = EMPTY
PRINT @(25,10):XTR.ID "L#15":
END
*
IF XTR.ID NE "XTR.CTL" THEN
*
XTR.DT = FIELD(XTR.ID,"*",ONE)
XTR.ERR  = FALSE
*
*Detect break in date
*
IF XTR.SEQ NE "HDR" AND XTR.SEQ NE "TRANS" AND XTR.SEQ NE "ERR" THEN
*
IF XTR.DT NE XTR.DT.CURR THEN
*
IF XTR.DT.CURR NE EMPTY THEN
*
* Validate end of last transmission
*
* Do not process previously split transmissions
*
IF NOT(XTR.TRANS$SPLIT) THEN
*
*Record Counts
IF XTR.REC.CN NE XTR.TRANS$REC.CN THEN
XTR.ERR = 15; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.TOT.REMT NE XTR.TRANS$TOT.REMT THEN
XTR.ERR = 7; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.REMT.CN NE XTR.TRANS$REMT.CN THEN
XTR.ERR = 8; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.FOUND<ONE,5> NE XTR.FOUND<ONE,7> THEN
XTR.ERR = 3; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
* File old transmission
*
*Index
INS XTR.DT.CURR      BEFORE XTR.IND$INDEX<ONE,ONE>
INS XTR.REC.CN       BEFORE XTR.IND$REC.CN<ONE,ONE>
INS XTR.REMT.CN      BEFORE XTR.IND$REMT.CN<ONE,ONE>
INS XTR.TOT.REMT     BEFORE XTR.IND$TOT.REMT<ONE,ONE>
INS XTR.TRANS$ERR    BEFORE XTR.IND$ERR<ONE,ONE>
INS XTR.ERR.CN       BEFORE XTR.IND$ERR.CN<ONE,ONE>
INS XTR.TRANS$FAILED BEFORE XTR.IND$FAILED<ONE,ONE>
INS XTR.TRANS$SPLIT  BEFORE XTR.IND$SPLIT<ONE,ONE>
LOOP
TMP = DCOUNT(XTR.IND$INDEX,VM)
WHILE TMP GT 15 AND NOT(STAT) DO
DEL XTR.IND$INDEX<ONE,16>
DEL XTR.IND$REC.CN<ONE,16>
DEL XTR.IND$REMT.CN<ONE,16>
DEL XTR.IND$TOT.REMT<ONE,16>
DEL XTR.IND$ERR<ONE,16>
DEL XTR.IND$ERR.CN<ONE,16>
DEL XTR.IND$FAILED<ONE,16>
REPEAT
MATWRITE XTR.IND ON XTR.FILE,"XTR.CTL"
*Transmission Header
WRITE XTR.HDR ON XTR.FILE,XTR.DT.CURR:"*HDR"
*Transmission Statistics
XTR.TRANS$FOUND = XTR.FOUND
MATWRITE XTR.TRANS ON XTR.FILE,XTR.DT.CURR:"*TRANS"
*Transmission Errors
WRITE XTR.ERRORS ON XTR.FILE,XTR.DT.CURR:"*ERR"
*
END; * of previously split transmission
*
END; * of current date not empty
*
XTR.HDR = EMPTY; MAT XTR.TRANS = EMPTY; XTR.ERRORS = EMPTY
XTR.DT.CURR = XTR.DT
XTR.FOUND = EMPTY; XTR.HDR = EMPTY
MATREAD XTR.TRANS FROM XTR.FILE,XTR.DT.CURR:"*TRANS" ELSE MAT XTR.TRANS = EMPTY
IF NOT(XTR.TRANS$SPLIT) THEN MAT XTR.TRANS = EMPTY
XTR.ERR = ZERO; XTR.BAT.ERR = TRUE; XTR.ERR.CN = ZERO
XTR.SEQ.LAST = ZERO; * XTR.SEQ = ZERO
XTR.BAT = ZERO; XTR.BAT.LAST = ZERO
XTR.REC.CN = ZERO; XTR.TOT.REMT = ZERO; XTR.REMT.CN = ZERO
XTR.BAT.TOT.REMT = ZERO; XTR.BAT.REMT.CN = ZERO; XTR.BAT.ERR = FALSE
XTR.BAF.TOT.REMT = ZERO; XTR.BAF.REMT.CN = ZERO
XTR.ITEM.CN = ZERO; XTR.ITEM = ZERO; XTR.ITEM.LAST = ZERO
*
END; * of date change
*
END; * of not HDR or TRANS
*
END; * of not XTR.CTL
*
* Skip rest of transmission if gt 100 errors
WHILE ((XTR.TRANS$FAILED OR XTR.TRANS$SPLIT) OR XTR.SEQ EQ "HDR" OR XTR.SEQ EQ "TRANS" OR XTR.SEQ EQ "ERR" OR XTR.ID EQ "XTR.CTL") AND NOT(STAT) AND XTR.ID NE "@@@" DO REPEAT
*
*Detect end of file
*
UNTIL XTR.ID EQ "@@@" OR STAT DO
*
XTR.REC.CN = XTR.REC.CN + ONE
*
*Validate record type
XTR.REC.TYPE = XTR[ONE,ONE]; XTR.VALID = TRUE
IF NOT(NUM(XTR.REC.TYPE)) THEN XTR.VALID = FALSE ELSE
IF XTR.REC.TYPE LT ONE OR XTR.REC.TYPE GT 9 THEN XTR.VALID = FALSE
END
IF NOT(XTR.VALID) THEN
XTR.ERR = ONE; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
*Validate rec len
IF LEN(XTR) NE 80 THEN
XTR.ERR = 4; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
XTR.VALID = FALSE
END
*
IF XTR.VALID THEN
*
*Extract headers
*     and
*Data records
*
*Validate ID sequence
IF NOT(NUM(XTR.SEQ)) THEN XTR.SEQ = ZERO
IF XTR.SEQ NE XTR.SEQ.LAST + ONE THEN
XTR.ERR = 13; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
XTR.SEQ.LAST = XTR.SEQ
*
BEGIN CASE
*
CASE XTR.REC.TYPE EQ 6
* Detail record
*
*Validate Batch Number
XTR.BAT = XTR[TWO,3]
IF NOT(NUM(XTR.BAT)) THEN XTR.BAT = ZERO
IF XTR.BAT NE XTR.TRANS$BAT.LAST THEN
XTR.ERR = 5; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
* Count remitances
XTR.REMT.CN = XTR.REMT.CN + ONE
XTR.BAT.REMT.CN = XTR.BAT.REMT.CN + ONE
*
*Validate Item Sequence
XTR.ITEM.CN = XTR.ITEM.CN + ONE
XTR.ITEM = XTR[5,3]
IF NOT(NUM(XTR.ITEM)) THEN XTR.ITEM = ZERO
IF XTR.ITEM NE XTR.ITEM.LAST + ONE THEN
XTR.ERR = 16; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
XTR.ITEM.LAST = XTR.ITEM
XTR.REMT = XTR[8,10]
IF NOT(NUM(XTR.REMT)) THEN AMT.VALID = FALSE ELSE AMT.VALID = TRUE
IF NOT(AMT.VALID) THEN
XTR.ERR = 12; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END ELSE
XTR.TOT.REMT = XTR.TOT.REMT + XTR.REMT
XTR.BAT.TOT.REMT = XTR.BAT.TOT.REMT + XTR.REMT
END
*
XTR.ACCT = XTR[18,16]
LOOP WHILE XTR.ACCT[ONE,ONE] EQ "0" AND LEN(XTR.ACCT) GT 7 DO XTR.ACCT = XTR.ACCT[TWO,9999] REPEAT
XTR.TRANS.CD = XTR.ACCT[7,ONE]
XTR.ACCT = XTR.ACCT[ONE,6]
CALL MOD11.DIGIT(XTR.ACCT,CD)
IF CD NE XTR.TRANS.CD THEN
XTR.ERR = 11; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
CASE TRUE
* Header records
*
* Load header into XTR.HDR
XTR.HDR<XTR.REC.TYPE,-ONE> = XTR
* Check for duplicate headers
IF XTR.FOUND<ONE,XTR.REC.TYPE> THEN
IF XTR.REC.TYPE NE 5 AND XTR.REC.TYPE NE 7 THEN
XTR.ERR = 3; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
END
XTR.FOUND<ONE,XTR.REC.TYPE> = XTR.FOUND<ONE,XTR.REC.TYPE> + ONE
*
BEGIN CASE
*
CASE XTR.REC.TYPE EQ ONE
* Immediate Address Header
XTR.TRANS$TRANS.DT = XTR[24,6]; * YYMMDD
XTR.TRANS$TRANS.TM = XTR[30,4]; * HHMM
*
CASE XTR.REC.TYPE EQ TWO
* Service Record
NULL
*
CASE XTR.REC.TYPE EQ 5
* Lock Box Detail Header
* Batch Header Record
XTR.TRANS$BAT.LAST = XTR[TWO,3]; * NNN
XTR.TRANS$DEP.DT = XTR[15,6]; * YYMMDD
*
*Validate batch against last batch number
IF XTR.TRANS$BAT.LAST NE XTR.BAT.LAST + ONE THEN
XTR.ERR = 14; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
*Clear Batch fields for this batch
XTR.BAT.LAST = XTR.TRANS$BAT.LAST
IF NOT(NUM(XTR.BAT.LAST)) THEN XTR.BAT.LAST = ZERO
XTR.BAT.TOT.REMT = ZERO; XTR.BAT.REMT.CN = ZERO; XTR.BAT.ERR = FALSE
*
CASE XTR.REC.TYPE EQ 7
* Batch Total Record
XTR.BAT = XTR[TWO,3]
IF NOT(NUM(XTR.BAT)) THEN XTR.BAT = ZERO
IF XTR.BAT NE XTR.TRANS$BAT.LAST THEN
XTR.ERR = 5; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
XTR.DEP.DT = XTR[15,6]
IF XTR.DEP.DT NE XTR.TRANS$DEP.DT THEN
XTR.ERR = 9; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
XTR.SEQ = XTR[5,3]
XTR.LBOX = XTR[8,7]
XTR.BAF.REMT.CN = XTR[21,3]
XTR.BAF.TOT.REMT   = XTR[24,10]
XTR.TRANS$CALC.REMT.CN = XTR.REMT.CN
XTR.TRANS$CALC.TOT.REMT = XTR.TOT.REMT
*
*Validate Batch Totals
IF XTR.BAT.TOT.REMT NE XTR.BAF.TOT.REMT THEN
XTR.ERR = 7; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.BAT.REMT.CN NE XTR.BAF.REMT.CN THEN
XTR.ERR = 8; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
*Store Batch Infor on failed batch
IF XTR.BAT.LAST NE "0" THEN
IF XTR.BAT.ERR THEN
INS XTR.TRANS$BAT.LAST BEFORE XTR.TRANS$BAT<ONE>
INS XTR.BAT.REMT.CN    BEFORE XTR.TRANS$BAT.REMT.CN<ONE>
INS XTR.BAT.TOT.REMT   BEFORE XTR.TRANS$BAT.TOT.REMT<ONE>
INS XTR.TRANS$ERR      BEFORE XTR.TRANS$BAT.ERR<ONE>
END
END
*
XTR.ITEM.LAST = ZERO
*
CASE XTR.REC.TYPE EQ 8
* Service Total Record
* Transmission Total Record
*
XTR.DEP.DT = XTR[15,6]
IF XTR.DEP.DT NE XTR.TRANS$DEP.DT THEN
XTR.ERR = 10; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
XTR.SEQ = XTR[5,3]
XTR.LBOX = XTR[8,7]
XTR.TRANS$REMT.CN = XTR[21,5]
XTR.TRANS$TOT.REMT = XTR[26,10]
XTR.TRANS$CALC.REMT.CN = XTR.REMT.CN
XTR.TRANS$CALC.TOT.REMT = XTR.TOT.REMT
*
IF XTR.TRANS$REMT.CN NE XTR.TRANS$CALC.REMT.CN THEN
XTR.ERR = 17; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
IF XTR.TRANS$TOT.REMT NE XTR.TRANS$CALC.TOT.REMT THEN
XTR.ERR = 18; XTR.BAT.ERR = TRUE; XTR.TRANS$FAILED = DATE()
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
END
*
CASE XTR.REC.TYPE EQ 9
* End Of Transmission Record
XTR.TRANS$REC.CN = XTR[TWO,6]
*
CASE TRUE
XTR.ERR = TWO; XTR.BAT.ERR = TRUE
XTR.ERRORS<ONE,-ONE> = XTR.ID; XTR.ERRORS<TWO,-ONE> = XTR.ERR
XTR.TRANS$ERR<ONE,ONE,XTR.ERR> = XTR.TRANS$ERR<ONE,ONE,XTR.ERR> + ONE
XTR.ERR.CN = XTR.ERR.CN + ONE
*
END CASE
*
END CASE
*
END; * of valid record type
*
IF XTR.ERR.CN GT 100 THEN XTR.TRANS$FAILED = 3
*
REPEAT ; * get next date / seq
*
!
*
SPLIT.XTR: *
*
TITLE = "Process Imported Payments - Split for Batches"
IF NOT(STAT) THEN
*
*Select the XTR file by date account number
*
EXECUTE "SSELECT XTR BY DATE BY ACCOUNT"
*
* Init fields
*
XTR.DT.CURR = EMPTY; XTR.DT = EMPTY
MAT XTR.TRANS = EMPTY; XTR.HDR = EMPTY; XTR.ERRORS = EMPTY
CO.NO = EMPTY; CO.NO.LAST = EMPTY
BAT.CN = ZERO; BAT.CN.BAD = ZERO
CAJ = EMPTY; CAJ.BAD = EMPTY
ITEM.COUNT = ZERO
BATCH.TOTAL = ZERO; BATCH.TOTAL.BAD = ZERO
ENTERED.TOTAL = ZERO; ENTERED.TOTAL.BAD = ZERO
ADJUST.TOTAL = ZERO; ADJUST.TOTAL.BAD = ZERO
XTR.REC.TYPE = EMPTY
*
* Main Loop
*
LOOP
*
LOOP
*
*Read next id
*
READNEXT XTR.ID ELSE XTR.ID = "@@@"
IF XTR.ID NE "@@@" AND XTR.ID NE "XTR.CTL" THEN
READ XTR FROM XTR.FILE,XTR.ID ELSE XTR = EMPTY
PRINT @(25,10):XTR.ID "L#15":
END
*
IF XTR.ID NE "XTR.CTL" THEN
*
XTR.DT = FIELD(XTR.ID,"*",ONE)
XTR.SEQ  = FIELD(XTR.ID,"*",TWO)
XTR.REC.TYPE = XTR[ONE,ONE]
*
IF XTR.SEQ NE "HDR" AND XTR.SEQ NE "TRANS" AND XTR.SEQ NE "ERR" THEN
*
IF XTR.REC.TYPE EQ "6" THEN
*
*Extract Trans information
*
TRANS = EMPTY
TRANS.BAD = FALSE
*
* Check for change in date
IF XTR.DT NE XTR.DT.CURR THEN
*
IF XTR.DT.CURR NE EMPTY THEN
*
IF CO.NO NE EMPTY AND BAT.CN THEN
BATCH.STATUS = "B"
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO; BATCH.TOTAL = ZERO; ENTERED.TOTAL = ZERO
END
*
IF CO.NO NE EMPTY AND BAT.CN.BAD THEN
SAVE.CAJ = CAJ; SAVE.BAT.CN = BAT.CN
SAVE.BATCH.TOTAL = BATCH.TOTAL; SAVE.ENTERED.TOTAL = ENTERED.TOTAL
BATCH.STATUS = "E"
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = SAVE.CAJ; BAT.CN = SAVE.BAT.CN
BATCH.TOTAL = SAVE.BATCH.TOTAL; ENTERED.TOTAL = SAVE.ENTERED.TOTAL
END
*
IF NOT(XTR.TRANS$FAILED OR XTR.TRANS$SPLIT) THEN
XTR.TRANS$SPLIT = DATE()
MATWRITE XTR.TRANS ON XTR.FILE,XTR.DT.CURR:"*TRANS"
LOCATE XTR.DT.CURR IN XTR.IND$INDEX<ONE> SETTING IND.LOC THEN
XTR.IND$SPLIT<ONE,IND.LOC> = XTR.TRANS$SPLIT
MATWRITE XTR.IND ON XTR.FILE,"XTR.CTL"
END
END
*
END; * of curr date not empty
*
XTR.DT.CURR = XTR.DT
*
* Open transmission
*
READ XTR.HDR FROM XTR.FILE,XTR.DT.CURR:"*HDR" ELSE XTR.HDR = EMPTY
MATREAD XTR.TRANS FROM XTR.FILE,XTR.DT.CURR:"*TRANS" ELSE MAT XTR.TRANS = EMPTY
READ XTR.ERRORS FROM XTR.FILE,XTR.DT.CURR:"*ERR" ELSE XTR.ERRORS = EMPTY
*
GOSUB OPEN.BATCH
*
END; * of date change
*
IF NOT(XTR.TRANS$FAILED OR XTR.TRANS$SPLIT) THEN
*
* Load field 1 - ACCT
XTR.ACCT = XTR[18,16]
LOOP WHILE XTR.ACCT[ONE,ONE] EQ "0" AND LEN(XTR.ACCT) GT 7 DO XTR.ACCT = XTR.ACCT[TWO,9999] REPEAT
IF NUM(XTR.ACCT) THEN
XTR.TRANS.CD = XTR.ACCT[7,ONE]
XTR.ACCT = XTR.ACCT[ONE,6]
CALL MOD11.DIGIT(XTR.ACCT,CD)
IF CD NE XTR.TRANS.CD THEN
TRANS<ONE,7> = " Check digit is wrong!"
TRANS.BAD = TRUE
END
XTR.ACCT = XTR.ACCT:XTR.TRANS.CD
END ELSE
TRANS<ONE,7> = " Account not numeric"
TRANS.BAD = TRUE
END
*
TRANS<ONE,ONE> = XTR.ACCT
*
IF NOT(TRANS.BAD) THEN
TMP = XTR.ACCT[ONE,6]
TMP = "0":TMP[TWO,9999]
MATREAD ACT FROM ACT.FILE,TMP THEN
IF ACT$STAT = "C" THEN TRANS<1,6> = " on *COL* acct"
END ELSE
TRANS<ONE,7> = " Account not on file"
TRANS.BAD = TRUE
END
END
IF TRANS.BAD THEN TRANS<ONE,5> = XTR.ACCT
*
END; * of not(failed or split)
*
END; * of REC.TYPE 6
*
END; * of not HDR or TRANS
*
END; * of id XTR.CTL
*
UNTIL XTR.ID EQ "@@@" OR (XTR.REC.TYPE EQ "6" AND NOT(XTR.TRANS$FAILED OR XTR.TRANS$SPLIT) AND XTR.ID NE "XTR.CTL") OR STAT DO REPEAT
*
UNTIL XTR.ID EQ "@@@" OR STAT DO
*
*Extract Trans information
*
* Look for validation error
*
LOCATE XTR.ID IN XTR.ERRORS<ONE> SETTING ERR.LOC ELSE ERR.LOC = ZERO
IF ERR.LOC THEN
VALIDATION.ERROR = XTR.ERRORS<TWO,ERR.LOC>
END ELSE
VALIDATION.ERROR = ZERO
END
*
* Load transactions type
*
TRANS<ONE,TWO> = "LB"
*
XTR.REMT = XTR[8,10]
AMT.VALID = TRUE
IF NOT(NUM(XTR.REMT)) THEN AMT.VALID = FALSE ELSE
TRANS.AMT = ICONV(XTR.REMT,"MR0")
IF XTR.REMT NE TRANS.AMT THEN AMT.VALID = FALSE
END
IF NOT(AMT.VALID) THEN
TRANS<ONE,7> = " (":XTR.REMT:") Amount is bad"
XTR.REMT = ZERO
TRANS.BAD = TRUE
END
XTR.REMT = XTR.REMT
*
IF AMT.VALID THEN
TRANS<ONE,3> = TRANS.AMT
END ELSE
TRANS<ONE,3> = XTR.REMT
END
*
* Load description (blank because LB is predefined and looked up)
*
TRANS<ONE,4> = EMPTY
*
* Load the cheque number
*
TRANS.CHEQUE = XTR[37,6]
IF NOT(NUM(TRANS.CHEQUE)) THEN TRANS.CHEQUE = EMPTY
IF TRANS.CHEQUE THEN
TRANS<ONE,4,ONE> = TRANS.CHEQUE
END
*
* Check max batch size
*
IF CO.NO NE EMPTY AND BAT.CN GT 200 THEN
BATCH.STATUS = "B"
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO; BATCH.TOTAL = ZERO; ENTERED.TOTAL = ZERO
END
*
IF CO.NO NE EMPTY AND BAT.CN.BAD GT 50 THEN
SAVE.CAJ = CAJ; SAVE.BAT.CN = BAT.CN
SAVE.BATCH.TOTAL = BATCH.TOTAL; SAVE.ENTERED.TOTAL = ENTERED.TOTAL
BATCH.STATUS = "E"
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = SAVE.CAJ; BAT.CN = SAVE.BAT.CN
BATCH.TOTAL = SAVE.BATCH.TOTAL; ENTERED.TOTAL = SAVE.ENTERED.TOTAL
END
*
* Company No
CO.NO = XTR.ACCT[ONE,ONE]
*
*Close batches if Company changed
IF CO.NO NE CO.NO.LAST THEN
*
GOSUB COMPANY.CHANGE
*
END
*
* Check for validation errors
*
IF VALIDATION.ERROR THEN
IF LEN(TRANS<ONE,7>) THEN TRANS<ONE,7> = TRANS<ONE,7>:", "
TRANS<ONE,7> = TRANS<ONE,7>:"validation error ":VALIDATION.ERROR
TRANS.BAD = TRUE
END
*
*
*Write into batch
*
IF NOT(TRANS.BAD) THEN
*
*Increment batch detail count
BAT.CN = BAT.CN + ONE
ITEM.COUNT = ITEM.COUNT + ONE
*
*Write into batch
CAJ<-ONE> = TRANS
*
*Accumulate batch totals
BATCH.TOTAL = BATCH.TOTAL + XTR.REMT
ENTERED.TOTAL = ENTERED.TOTAL + XTR.REMT
*
END ELSE
*
*Increment batch detail count
BAT.CN.BAD = BAT.CN.BAD + ONE
*
*Write into batch
CAJ.BAD<-ONE> = TRANS
*
*Accumulate batch totals
BATCH.TOTAL.BAD = BATCH.TOTAL.BAD + XTR.REMT
ENTERED.TOTAL.BAD = ENTERED.TOTAL.BAD + XTR.REMT
*
END
*
*Next record
REPEAT
*
CO.NO = "@@@"
*
GOSUB COMPANY.CHANGE
*
END; * of STAT
*
FINISH: *
*
IF CO.NO.LAST NE EMPTY AND NOT(STAT) THEN
IF NOT(XTR.TRANS$FAILED OR XTR.TRANS$SPLIT) THEN
XTR.TRANS$SPLIT = DATE()
MATWRITE XTR.TRANS ON XTR.FILE,XTR.DT.CURR:"*TRANS"
LOCATE XTR.DT.CURR IN XTR.IND$INDEX<ONE> SETTING IND.LOC THEN
XTR.IND$SPLIT<ONE,IND.LOC> = XTR.TRANS$SPLIT
MATWRITE XTR.IND ON XTR.FILE,"XTR.CTL"
END
END
END
*
IF STAT THEN INPUT RSP:
*
CALL UNLOCK.ITEM(XTR.FILE,"XTR","XTR.CTL",LOCKS.FILE)
*
STOP
*
*
OPEN.BATCH: *
*
BATCH.TOTAL = ZERO; BATCH.TOTAL.BAD = ZERO
ENTERED.TOTAL = ZERO; ENTERED.TOTAL.BAD = ZERO
ADJUST.TOTAL = ZERO; ADJUST.TOTAL.BAD = ZERO
ITEM.COUNT = ZERO
*
RETURN
*
CLOSE.BATCH: *
*
ADJUST.TOTAL = ZERO
ENTRY.DATE = DATE()
ENTRY.TIME = OCONV(TIME(),"MT")
ITEM.COUNT = BAT.CN
BUS.DATE = CONTROL.DT
EFF.DATE = XTR.TRANS$DEP.DT
*YYMMDD
EFF.DATE = EFF.DATE[3,TWO]:"/":EFF.DATE[5,TWO]:"/":EFF.DATE[ONE,TWO]
EFF.DATE = ICONV(EFF.DATE,"D2/")
POST.DATE = ""
POST.TIME = ""
*
LOOP
LOCK.STAT = -ONE; CALL LOCK.ITEM(CNT.FILE,"CNT","CASH.BATCH.NUM",LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT DO REPEAT
IF NOT(LOCK.STAT) THEN
READ BATCH.NUM FROM CNT.FILE,"CASH.BATCH.NUM" ELSE BATCH.NUM = ONE
WRITE BATCH.NUM + ONE ON CNT.FILE,"CASH.BATCH.NUM"
CALL UNLOCK.ITEM(CNT.FILE,"CNT","CASH.BATCH.NUM",LOCKS.FILE)
END
BATCH.NUM = (BATCH.NUM+100000)[2,5]
LOOP
LOCK.STAT = -ONE; CALL LOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT DO REPEAT
*
IF BATCH.STATUS EQ "B" THEN
XTR.POST<-ONE> = BATCH.NUM
END ELSE
XTR.POST.ERR<-ONE> = BATCH.NUM
END
*
$INCLUDE IBP CASH.UPD.HDR
*
*WRITE BATCH.HEADER:AM:CAJ ON CAJ.FILE,BATCH.NUM
CALL UNLOCK.ITEM(CAJ.FILE,"CAJ",BATCH.NUM,LOCKS.FILE)
*
RETURN
*
OPEN.COMPANY: *
*
OPEN CO.PRE:"ACT" TO ACT.FILE ELSE PRINT "Can't open ":CO.PRE:"ACT"; STAT = 999; RETURN
OPEN CO.PRE:"CAJ" TO CAJ.FILE ELSE PRINT "Can't open ":CO.PRE:"CAJ"; STAT = 999; RETURN
OPEN CO.PRE:"PAR" TO PAR.FILE ELSE PRINT "Can't open ":CO.PRE:"PAR"; STAT = 999; RETURN
OPEN CO.PRE:"CNT" TO CNT.FILE ELSE PRINT "Can't open ":CO.PRE:"CNT"; STAT = 999; RETURN
*
READ TRANS.TYPES FROM PAR.FILE,TRANS.ITEM ELSE PRINT "Can't read PAR ":TRANS.ITEM; STAT = 999; RETURN
*
READ CURR.ACCTG.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; STAT = 999; RETURN
ACCTG.PERIOD = CURR.ACCTG.PERIOD[ONE,TWO]:"-":CURR.ACCTG.PERIOD[3,TWO]
READ CURR.ACCTG.DATE FROM CNT.FILE,"CURR.ACCTG.DATE" ELSE PRINT "Can't read CNT CURR.ACCTG.DATE"; STAT = 999; RETURN
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; STAT = 999; RETURN
CO.NAME = CO.DATA<ONE,ONE,ONE>; CONTROL.DT = CO.DATA<TWO,ONE,ONE>
*
XTR.POST.ID = "XTR.POST"
XTR.POST = EMPTY; XTR.POST.ERR = EMPTY
*
IF NOT(CO.FIRST) THEN
*
LOOP
LOCK.STAT = -ONE; CALL LOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID,LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT DO REPEAT
READ XTR.POST FROM CNT.FILE,XTR.POST.ID ELSE XTR.POST = EMPTY
*
LOOP
LOCK.STAT = -ONE; CALL LOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID:".ERR",LOCKS.FILE,LOCK.STAT)
WHILE LOCK.STAT DO REPEAT
READ XTR.POST.ERR FROM CNT.FILE,XTR.POST.ID:".ERR" ELSE XTR.POST.ERR = EMPTY
*
END
*
CO.FIRST = FALSE
*
PRINT @(ZERO,ZERO):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25 - LEN(CO.NAME) / TWO + .5):CO.NAME) "L#50":("Port ":PORT) "R#15":
PRINT @(ZERO,ONE):RVB:OCONV(TIME(),"MT") "L#10":(SPACE(30 - LEN(TITLE) / TWO + .5):TITLE) "L#60":("Acct ":ACCT) "R#10":
PRINT @(ZERO,8):"Company: ":FIELD(CO.PRE,".",ONE):" ":CO.NAME:
PRINT @(ZERO,10):"Item being processed: ":
*
*
RETURN
*
COMPANY.CHANGE: *
*
*Close Company 
*
IF CO.NO.LAST NE EMPTY AND BAT.CN THEN 
BATCH.STATUS = "B"
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO
BATCH.TOTAL = ZERO; ENTERED.TOTAL = EMPTY
END
*
IF CO.NO.LAST NE EMPTY AND BAT.CN.BAD THEN 
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
BATCH.STATUS = "E"
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = EMPTY; BAT.CN = ZERO
BATCH.TOTAL = ZERO; ENTERED.TOTAL = EMPTY
END
*
IF CO.NO.LAST NE EMPTY THEN
WRITE XTR.POST ON CNT.FILE,XTR.POST.ID
WRITE XTR.POST.ERR ON CNT.FILE,XTR.POST.ID:".ERR"
CALL UNLOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID,LOCKS.FILE)
CALL UNLOCK.ITEM(CNT.FILE,"CNT",XTR.POST.ID:".ERR",LOCKS.FILE)
END
*
IF CO.NO NE "@@@" AND CO.NO NE CO.NO.LAST THEN
CO.NO.LAST = CO.NO
LOCATE CO.NO IN XTR.IND$CO.NO.IND<ONE> SETTING LOC ELSE LOC = ONE; STAT = 999
CO.PRE = XTR.IND$CO.NO.PRE<ONE,LOC>
IF LEN(CO.PRE) THEN CO.PRE = CO.PRE:"."
GOSUB OPEN.COMPANY
END; * of company change
*
RETURN
*
*
END
~BU.CASH.OR.ADJ.POST~
XSUBROUTINE CASH.OR.ADJ.POST(LOCKS.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,STAT,LOCK.TYPE,CAJ,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,DELINQ.STAT,MIN.BALANCE,BUS.DATE,ENTRY.TYPE,DEFAULT.TYPE)
* VERSION: 921002 271  ADDED ATR LOCKING
* PRIOR: 910625 2.7  NEW
* DESCRIPTION:      POSTS A BATCH OF TRANSACTIONS
* COPYRIGHT         AXION COMPUTER SYSTEMS LTD.
*   1991             ALL RIGHTS RESERVED
*
* AUTHOR:           DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*
*     Adapted from cash.or.adj.entry (COPYRIGHT 1983 - AXION)
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP AAX.DIM
$INCLUDE IBP AAX.EQUATES
$INCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
$INCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP EFT.DIM
$INCLUDE IBP EFT.EQUATES
*
!
*
TRANS.COUNT = ONE
LOOP TRANS = CAJ<TRANS.COUNT> UNTIL TRANS EQ EMPTY OR STAT DO
IF TRANS<ONE,3> THEN GOSUB POST.TRANS
TRANS.COUNT = TRANS.COUNT + ONE
REPEAT
*
!
*
FINISH: *
*
RETURN
*
!
POST.TRANS: *
ACT.ID = TRANS<ONE,ONE>; CD = ACT.ID[7,ONE]; ACT.ID = ACT.ID[ONE,6]
PRINT @(10,11):CLL:"Now posting transaction on account no. ":ACT.ID:"-":CD
LOOP
LOCK.STAT = LOCK.TYPE; CALL LOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LOCKS.FILE,LOCK.STAT) 
WHILE STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ACT file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
MATREAD ACT FROM ACT.FILE,ACT.ID ELSE MAT ACT = EMPTY; STAT = TRUE
LOOP
LOCK.STAT = LOCK.TYPE; CALL LOCK.ITEM(ATR.FILE,"ATR",ACT.ID,LOCKS.FILE,LOCK.STAT) 
WHILE STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ATR file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = EMPTY; * STAT = TRUE
MATREAD ADD FROM ADD.FILE,ACT$ADD.ID ELSE MAT ADD = EMPTY; STAT = TRUE
IF STAT THEN RETURN
PHASE = FIELD(ADD$GEOGRAPHIC.DATA,"*",ONE); IF LEN(PHASE) EQ ONE THEN PHASE = "0":PHASE
MAT ACG = EMPTY
TRANS.TYPE = TRANS<ONE,TWO>; IF TRANS.TYPE EQ EMPTY THEN TRANS.TYPE = DEFAULT.TYPE
AMOUNT = TRANS<ONE,3>; IF ENTRY.TYPE THEN AMOUNT = -AMOUNT
DESC = TRANS<ONE,4>
IF DESC[ONE,TWO] EQ "a-" THEN
SOURCE = "A"
LC.SOURCE = "a"
TRANS.CLASS = "a"
END ELSE
SOURCE = RUN.SOURCE
LC.SOURCE = RUN.LC.SOURCE
TRANS.CLASS = RUN.TRANS.CLASS
END
CALL PACK.NUMBER(EFF.DATE,TEMP); INS TEMP BEFORE ATR$EFF.DATES<ONE,ONE>
CALL PACK.NUMBER(CONTROL.DT,TEMP); INS TEMP BEFORE ATR$ENTRY.DATES<ONE,ONE>
CALL PACK.NUMBER(CURR.ACCTG.PERIOD,TEMP); INS TEMP BEFORE ATR$ENTRY.PERIODS<ONE,ONE>
INS SOURCE BEFORE ATR$TYPES<ONE,ONE>
INS BATCH.NUM BEFORE ATR$REFS<ONE,ONE>
CALL PACK.NUMBER(AMOUNT,TEMP); INS TEMP BEFORE ATR$TOTAL.AMTS<ONE,ONE>
IF DESC[ONE,TWO] EQ "a-" THEN INS EMPTY BEFORE ATR$DESCS<ONE,ONE> ELSE INS DESC BEFORE ATR$DESCS<ONE,ONE>
W.TYP = TRANS.CLASS:'*':TRANS.TYPE
INS W.TYP BEFORE ATR$SVC.TYPES<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.QNTYS<ONE,ONE>
CALL PACK.NUMBER(AMOUNT,TEMP); INS TEMP BEFORE ATR$SVC.AMTS<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.FROM.DATES<ONE,ONE>
INS EMPTY BEFORE ATR$SVC.TO.DATES<ONE,ONE>
*
IF ENTRY.TYPE LE ONE THEN
ACT$BALANCE = ACT$BALANCE + AMOUNT
AMT.TO.APPLY = -AMOUNT
IF AMT.TO.APPLY GT ZERO THEN AGE.NUM = 4 ELSE
AGE.NUM = TWO
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
* NOW SET CR. STATUS TO MIN. DLQ FOR A 'LATE NOTICE' TRANSACTION
IF TRANS.TYPES<4,LOC> EQ "Y" THEN IF ACT$CREDIT.STATUS LT DELINQ.STAT THEN AGE.NUM = DELINQ.STAT
END
END
LOOP WHILE AMT.TO.APPLY DO
AGED = FIELD(ACT$AGED.AMTS,"*",ONE)
AGED<TWO> = FIELD(ACT$AGED.AMTS,"*",TWO)
AGED<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGED<4> = FIELD(ACT$AGED.AMTS,"*",4)
IF AGED<ONE> LT ZERO THEN AGED<4> = AGED<4> + AGED<ONE>; AGED<ONE> = ZERO
AGED<AGE.NUM> = AGED<AGE.NUM> - AMT.TO.APPLY
AGE.NUM = 4
LOOP
WHILE AGE.NUM GT ONE DO
IF AGED<AGE.NUM> LT ZERO THEN AGED<AGE.NUM - ONE> = AGED<AGE.NUM - ONE> + AGED<AGE.NUM>; AGED<AGE.NUM> = ZERO
AGE.NUM = AGE.NUM - ONE
REPEAT
AMT.TO.APPLY = AGED<ONE> + AGED<TWO> + AGED<3> + AGED<4> - ACT$BALANCE
IF AMT.TO.APPLY GT ZERO THEN AGE.NUM = 4 ELSE AGE.NUM = TWO
BEGIN CASE
CASE AGED<4>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>:"*":AGED<3>:"*":AGED<4>
CASE AGED<3>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>:"*":AGED<3>
CASE AGED<TWO>; ACT$AGED.AMTS = AGED<ONE>:"*":AGED<TWO>
CASE ONE;       ACT$AGED.AMTS = AGED<ONE>
END CASE
BEGIN CASE
CASE AGED<4> GE MIN.BALANCE;               * 60 DAYS  + 
IF ACT$CREDIT.STATUS LT 3 THEN ACT$CREDIT.STATUS = 3 
CASE AGED<3> + AGED<4> GE MIN.BALANCE;       * 30 DAYS  + 
ACT$CREDIT.STATUS = TWO
CASE AGED<TWO> + AGED<3> + AGED<4> GE MIN.BALANCE; * CURRENT
ACT$CREDIT.STATUS = ONE
CASE ONE;                                    * UNDER 30 DAYS
ACT$CREDIT.STATUS = ZERO
IF ACT$STAT EQ "A" THEN ACT$DISC.DATE = EMPTY ELSE IF ACT$BALANCE LT ZERO AND ABS(ACT$BALANCE) GE MIN.BALANCE THEN ACT$CREDIT.STATUS = -ONE
END CASE
REPEAT
END ELSE
DEPOSIT.TYPE = "D"
BEGIN CASE
CASE TRANS.TYPE EQ "01" OR TRANS.TYPE EQ "03" OR TRANS.TYPE EQ "05" OR TRANS.TYPE EQ "07"
DEPOSIT.TYPE = "D"
CASE TRANS.TYPE EQ "02" OR TRANS.TYPE EQ "04" OR TRANS.TYPE EQ "04" OR TRANS.TYPE EQ "08"
DEPOSIT.TYPE = "X"
END CASE
LOCATE TRANS.TYPE IN TRANS.TYPES<ONE> SETTING LOC THEN
IF TRANS.TYPES<4,LOC> NE EMPTY THEN DEPOSIT.TYPE = TRANS.TYPES<4,LOC>
END
BEGIN CASE
CASE DEPOSIT.TYPE EQ "D"
ACT$DEPOSIT.AMT = ACT$DEPOSIT.AMT + AMOUNT
CASE DEPOSIT.TYPE EQ "X"
ACT$DEPOSIT.TAX = ACT$DEPOSIT.TAX + AMOUNT
END CASE
END
*
LOCATE LC.SOURCE IN ACG$SOURCES<ONE> BY "AL" SETTING SOURCE.LOC ELSE
INS LC.SOURCE BEFORE ACG$SOURCES<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$TRANS.TYPES<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$AMOUNTS<ONE,SOURCE.LOC>
INS EMPTY BEFORE ACG$COUNTS<ONE,SOURCE.LOC>
END
LOCATE TRANS.TYPE IN ACG$TRANS.TYPES<ONE,SOURCE.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRANS.TYPE BEFORE ACG$TRANS.TYPES<ONE,SOURCE.LOC,TRANS.LOC>
INS EMPTY BEFORE ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC>
INS EMPTY BEFORE ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC>
END
ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC> = ACG$AMOUNTS<ONE,SOURCE.LOC,TRANS.LOC> + AMOUNT
ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC> = ACG$COUNTS<ONE,SOURCE.LOC,TRANS.LOC> + ONE
*
ACG.ID = PHASE:"*":BUS.DATE
LOOP
LOOP LOCK.STAT = LOCK.TYPE; CALL LOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LOCKS.FILE,LOCK.STAT) WHILE LOCK.STAT DO
PRINT BELL:CLB:"You must unlock ACG file - item ":ACG.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
MATREAD SAVE.ACG FROM ACG.FILE,ACG.ID ELSE MAT SAVE.ACG = EMPTY
VC = ONE
LOOP SRC = ACG$SOURCES<ONE,VC> UNTIL SRC EQ EMPTY DO
LOCATE SRC IN SAVE.ACG$SOURCES<ONE> BY "AL" SETTING SRC.LOC ELSE
INS SRC BEFORE SAVE.ACG$SOURCES<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$AMOUNTS<ONE,SRC.LOC>
INS EMPTY BEFORE SAVE.ACG$COUNTS<ONE,SRC.LOC>
END
SC = ONE
LOOP TRTYP = ACG$TRANS.TYPES<ONE,VC,SC> UNTIL TRTYP EQ EMPTY DO
LOCATE TRTYP IN SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRTYP BEFORE SAVE.ACG$TRANS.TYPES<ONE,SRC.LOC,TRANS.LOC>
INS EMPTY BEFORE SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC>
INS EMPTY BEFORE SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC>
END
SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC> = SAVE.ACG$AMOUNTS<ONE,SRC.LOC,TRANS.LOC> + ACG$AMOUNTS<ONE,VC,SC>
SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC> = SAVE.ACG$COUNTS<ONE,SRC.LOC,TRANS.LOC> + ACG$COUNTS<ONE,VC,SC>
SC = SC + ONE
REPEAT
VC = VC + ONE
REPEAT
MATWRITE SAVE.ACG ON ACG.FILE,ACG.ID
CALL UNLOCK.ITEM(ACG.FILE,"ACG",ACG.ID,LOCKS.FILE)
UNTIL ACG.ID[ONE,ONE] EQ "$" DO ACG.ID = "$":PHASE:"*":CONTROL.DT REPEAT
*
MATWRITE ATR ON ATR.FILE,ACT.ID
MATWRITE ACT ON ACT.FILE,ACT.ID
*
IF TRANS.TYPE MATCHES "'E'1A" THEN
IF TRANS.TYPE NE "EP" THEN
MATREAD EFT FROM EFT.FILE,ACT.ID THEN
BEGIN CASE
CASE TRANS.TYPE EQ "EE"; * EFT - Error in coding
EFT$STAT = "S"
IF EFT$ERROR.FLAG EQ EMPTY THEN EFT$ERROR.FLAG = "E"
CASE TRANS.TYPE EQ "EN"; * EFT - NSF cheque
IF EFT$ERROR.FLAG MATCHES "0N" THEN EFT$ERROR.FLAG = EFT$ERROR.FLAG + ONE ELSE EFT$ERROR.FLAG = ONE
CASE ONE; * CLOSED ACCOUNT OR STOP PAYMENT
EFT$STAT = "C"
END CASE
MATWRITE EFT ON EFT.FILE,ACT.ID
END
END
END
*
CALL UNLOCK.ITEM(ACT.FILE,"ACT",ACT.ID,LOCKS.FILE)
CALL UNLOCK.ITEM(ATR.FILE,"ATR",ACT.ID,LOCKS.FILE)
*
RETURN
*
!
*
END
~BU.GET.CHANNEL.LIST~
SUBROUTINE GET.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES)
* PROGRAM:           GET.CHANNEL.LIST
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       BUILD A LIST OF CHANNEL NUMBERS FOR EDITING...
*
* DATE WRITTEN:      11 JUN 86
* DATE RELEASED:     11 JUN 86
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
CHANNEL.MLES = ""; IMAX = COUNT(COMPONENTS<3>,VM)+1
FOR I = 1 TO IMAX
MLE.NUMS = COMPONENTS<3,I>
JMAX = COUNT(MLE.NUMS,",")+1
FOR J = 1 TO JMAX
MLE.NUM = FIELD(MLE.NUMS,",",J)+0
IF MLE.NUM THEN
LOCATE MLE.NUM IN CHANNEL.MLES<1> BY "AR" SETTING LOC ELSE INS MLE.NUM BEFORE CHANNEL.MLES<1,LOC>
END
NEXT J
NEXT I
RETURN
!
END
~BU.MAINT.DEVICE.TYPES~
*PROGRAM: MAINT.DEVICE.TYPES
* VERSION: 910809 2.7  IF.LN.>.20.THEN.LN=5
* PRIOR: 900926 2.4  MODIFIED.FOR.ON.PREMISE
* AUTHOR:            DAVID STERN
* DESCRIPTION:       GENERATED BY "SOURCEGEN" FROM "SCREEN.HANDLER"
*                    SEE '*CUSTOM*' LINES.
*                    ANY 888 REFERENCE MUST BE CHANGED TO 'WO.VC'.
* DATE WRITTEN:      12 MAR 84
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LOCKS.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LOCKS.FILE = 0; * REV ONLY
LOCK.ITM = TRUE; LOCK.TYPE = ZERO
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
READ DEVICE.FUNCTIONS FROM PAR.FILE,"DEVICE.FUNCTIONS" ELSE DEVICE.FUNCTIONS = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(5)
VALID.REFS = "DS":AM:"IN":AM:"PA":AM:"AS":AM:"OA":AM:"MF":AM:"OF"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
*CUSTOM* GOSUB DISPLAY.BACKGROUND
PAR.ID = ""; GOSUB GET.KEY; IF PAR.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN CALL LOCK.ITEM(PAR.FILE,"PAR",PAR.ID,LOCKS.FILE,STAT)
IF STAT THEN GOTO UNLOCK
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = "" ELSE NEW = 1; PAR = ""
GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
GOSUB DISPLAY.BACKGROUND; *CUSTOM*
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 5
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT CLB:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
GOSUB DEL.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
GOTO UPDATE; *CUSTOM*
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE PAR ON PAR.FILE,PAR.ID
READ RAMDISK.FILES FROM CNT.FILE,"RAMDISK.FILES" THEN
LOCATE "PAR" IN RAMDISK.FILES<1> BY "AL" SETTING RAMLOC THEN
IF RAMDISK.FILES<2,RAMLOC> # 1 THEN
RAMDISK.FILES<2,RAMLOC> = 1
WRITE RAMDISK.FILES ON CNT.FILE,"RAMDISK.FILES"
END
END
END
UPDATED = 1
!
UNLOCK: *
CALL UNLOCK.ITEM(PAR.FILE,"PAR",PAR.ID,LOCKS.FILE)
GOTO NEXT.ITEM; *CUSTOM*
*CUSTOM* STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28-((LEN(CO.NAME)/2)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                            Device Type Maintenance                             ":RVE:
PRINT @(0,3):RVB:"Device Type.............":RVE:
PRINT @(0,5):RVB:"DS> Description.........":RVE:
PRINT @(0,6):RVB:"IN> Inventory part #....":RVE:
PRINT @(0,7):RVB:"PA> Programmable/       ":RVE:
PRINT @(45,7):RVB:"AS> # Addresses supported..":RVE:
PRINT @(0,8):RVB:"    Addressable.........":RVE:
* PRINT @(45,8):RVB:"OA> Outlets per address....":RVE:
PRINT @(0,10):RVB:"MF> Mandatory functions     ":RVE:"  ":RVB:"OF> Optional functions ":RVE:
PRINT @(25,3):PAR<1,WO.VC>"L#5":; *CUSTOM*
RETURN
!
DISPLAY.FOREGROUND: *
*CUSTOM* PRINT @(25,3):PAR<1,WO.VC> "L#5":
PRINT @(25,5):PAR<2,WO.VC> "L#25":
PRINT @(25,6):PAR<6,WO.VC> "L#16":
PRINT @(73,7):PAR<7,WO.VC> "R#3":
PRINT @(25,8):PAR<5,WO.VC> "L#1":
* PRINT @(73,8):PAR<8,WO.VC> "R#3":
DYNAMIC = ""; GOSUB D06; IF STAT = 999 THEN RETURN
DYNAMIC = ""; GOSUB D07; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
PAR.ID = "DEVICE.TYPES"
RETURN
!
GET.DATA: *
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07
RETURN
!
I01: CALL INPUT.DATA(PAR,25,5,"L25",2:",":WO.VC,"","","",RSP,STAT); RETURN
I02: CALL INPUT.DATA(PAR,25,6,"L16",6:",":WO.VC,"","","",RSP,STAT); RETURN
I03: CALL INPUT.DATA(PAR,25,8,"L1",5:",":WO.VC,"","OP":VM:"EQ":SVM:"P":SVM:"A":SVM:"O","",RSP,STAT); RETURN
I04:
IF PAR<5,WO.VC> EQ "P" AND NOT(NEW) THEN
TEXT = "This is not an Addressable Device type"
GOSUB ERROR
RETURN
END
IF PAR<5,WO.VC> EQ "A" THEN PAR<7,WO.VC> = 1; PRINT @(7,73):PAR<7,WO.VC> "R#3":; RETURN
IF PAR<5,WO.VC> EQ "P" THEN RETURN
CALL INPUT.DATA(PAR,73,7,"R3",7:",":WO.VC,"","MA":SVM:"0N","",RSP,STAT); RETURN
I05: RETURN
CALL INPUT.DATA(PAR,73,8,"R1",8:",":WO.VC,"","OP":SVM:"0N","",RSP,STAT); RETURN
I06:  PRINT CLB:"Enter mandatory function: ":
FLD = ""; CALL INPUT.DATA(FLD,26,23,"L1",1,"","SE":VM:"OP":VM:"EQ":SVM:"@":DEVICE.FUNCTIONS<1>:"@","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I06
IF FLD = "" THEN RETURN
LOCATE FLD IN PAR<3,WO.VC> BY "AL" SETTING SC THEN
PRINT CLB:"Ref. MF> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL PAR<3,WO.VC,SC>
TOP.DISP.LOC(4) = -ABS(TOP.DISP.LOC(4))
DYNAMIC = "D"; GOSUB D06; IF STAT = 999 THEN RETURN
GOTO I06
END
END ELSE
IF PAR<3,WO.VC,SC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF SC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I06
END
INS FLD BEFORE PAR<3,WO.VC,SC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(4) = -ABS(TOP.DISP.LOC(4)) ELSE IF NOT(TOP.DISP.LOC(4)) THEN TOP.DISP.LOC(4) = 1
END
GOSUB D06; IF STAT = 999 THEN RETURN
LN = MOD(SC-1,10)+11
GOTO I06
I06A: CALL INPUT.DATA(PAR,0,LN,"L1",3:",":WO.VC:",":SC,"","EQ":SVM:"@":DEVICE.FUNCTIONS<1>:"@","",RSP,STAT)
IF STAT THEN RETURN ELSE GOSUB T01
RETURN
D06: SAVE.SC = SC
IF TOP.DISP.LOC(4) < 0 THEN TOP.DISP.LOC(4) = ABS(TOP.DISP.LOC(4)) ELSE
IF SC >= TOP.DISP.LOC(4) THEN IF SC <= TOP.DISP.LOC(4)+9 THEN
IF DYNAMIC = "N" THEN LN = MOD(SC-1,10)+11; PRINT @(0,LN):PAR<3,WO.VC,SC> "L#1":; GOSUB T01
RETURN
END
END
IF TOP.DISP.LOC(4) THEN SC = SC-MOD(SC-1,10); CLEAR = 1 ELSE SC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 11 TO 20 UNTIL PAR<3,WO.VC,SC> = ""
IF LN = 11 THEN TOP.LOC = SC
PRINT @(0,LN):PAR<3,WO.VC,SC> "L#1":; GOSUB T01
SC = SC+1
NEXT LN
IF TOP.DISP.LOC(4) OR PAR<3,WO.VC,SC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 11; GOSUB C06 REPEAT
IF CLEAR THEN GOSUB C06 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(4) = TOP.LOC
SC = SAVE.SC
RETURN
C06: FOR LN = LN TO 20
PRINT @(0,LN):SPACE(1):; GOSUB TC01
NEXT LN
RETURN
I07:  PRINT CLB:"Enter optional function: ":
FLD = ""; CALL INPUT.DATA(FLD,25,23,"L1",1,"","SE":VM:"OP":VM:"EQ":SVM:"@":DEVICE.FUNCTIONS<1>:"@","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I07
IF FLD = "" THEN RETURN
LOCATE FLD IN PAR<4,WO.VC> BY "AL" SETTING SC THEN
PRINT CLB:"Ref. OF> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL PAR<4,WO.VC,SC>
TOP.DISP.LOC(5) = -ABS(TOP.DISP.LOC(5))
DYNAMIC = "D"; GOSUB D07; IF STAT = 999 THEN RETURN
GOTO I07
END
END ELSE
IF PAR<4,WO.VC,SC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF SC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I07
END
INS FLD BEFORE PAR<4,WO.VC,SC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(5) = -ABS(TOP.DISP.LOC(5)) ELSE IF NOT(TOP.DISP.LOC(5)) THEN TOP.DISP.LOC(5) = 1
END
GOSUB D07; IF STAT = 999 THEN RETURN
LN = MOD(SC-1,10)+11
GOTO I07
I07A: CALL INPUT.DATA(PAR,30,LN,"L1",4:",":WO.VC:",":SC,"","EQ":SVM:"@":DEVICE.FUNCTIONS<1>:"@","",RSP,STAT)
IF STAT THEN RETURN ELSE GOSUB T02
RETURN
D07: SAVE.SC = SC
IF TOP.DISP.LOC(5) < 0 THEN TOP.DISP.LOC(5) = ABS(TOP.DISP.LOC(5)) ELSE
IF SC >= TOP.DISP.LOC(5) THEN IF SC <= TOP.DISP.LOC(5)+9 THEN
IF DYNAMIC = "N" THEN LN = MOD(SC-1,10)+11; PRINT @(30,LN):PAR<4,WO.VC,SC> "L#1":; GOSUB T02
RETURN
END
END
IF TOP.DISP.LOC(5) THEN SC = SC-MOD(SC-1,10); CLEAR = 1 ELSE SC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 11 TO 20 UNTIL PAR<4,WO.VC,SC> = ""
IF LN = 11 THEN TOP.LOC = SC
PRINT @(30,LN):PAR<4,WO.VC,SC> "L#1":; GOSUB T02
SC = SC+1
NEXT LN
IF TOP.DISP.LOC(5) OR PAR<4,WO.VC,SC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 11; GOSUB C07 REPEAT
IF CLEAR THEN GOSUB C07 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(5) = TOP.LOC
SC = SAVE.SC
RETURN
C07: FOR LN = LN TO 20
PRINT @(30,LN):SPACE(1):; GOSUB TC02
NEXT LN
RETURN
!
T01: TRN.FLD = PAR<3,WO.VC,SC>
LOCATE TRN.FLD IN DEVICE.FUNCTIONS<1> SETTING LOC THEN TRN.FLD = DEVICE.FUNCTIONS<2,LOC> ELSE TRN.FLD = ""
PRINT @(3,LN):TRN.FLD "L#20":
RETURN
TC01: PRINT @(3,LN):SPACE(20):; RETURN
T02: TRN.FLD = PAR<4,WO.VC,SC>
LOCATE TRN.FLD IN DEVICE.FUNCTIONS<1> SETTING LOC THEN TRN.FLD = DEVICE.FUNCTIONS<2,LOC> ELSE TRN.FLD = ""
PRINT @(33,LN):TRN.FLD "L#20":
RETURN
TC02: PRINT @(33,LN):SPACE(20):; RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
DEL.CALL: *
* DELETE ONLY A SINGLE DEVICE TYPE FROM ITEM
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN STAT = 1; RETURN
FOR AC = 1 TO 20
DEL PAR<AC,WO.VC>
NEXT AC
RETURN
!
READ.CALL: *
* DISPLAY DEVICE TYPES THEN SELECT ONE
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28-((LEN(CO.NAME)/2)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                            Device Type Maintenance                             ":RVE:
TITLE = RVB:"Type":RVE:"  ":RVB:"Description":RVE
PRINT @(5,3):TITLE:@(45,3):TITLE:
IF NEW THEN PAR = ""
VC = 1; CL = 5; LN = 5
LOOP TYPE = PAR<1,VC> UNTIL TYPE = "" DO
PRINT @(CL,LN):RVB:TYPE "L#4":RVE:"  ":PAR<2,VC> "L#25":
LN = LN+1; IF LN > 20 THEN IF CL = 5 THEN CL = 45; LN = 5 ELSE VC = 999
VC = VC+1
REPEAT
PRINT @(10,22):CLL:"Enter Device Type: ":
INPUT RSP:; IF RSP = "KILL" OR RSP = "" THEN
CALL UNLOCK.ITEM(PAR.FILE,"PAR",PAR.ID,LOCKS.FILE)
STOP
END
IF RSP MATCHES "1N" THEN RSP = "0":RSP
IF NEW THEN PAR<1,1> = RSP; WO.VC = 1; RETURN
LOCATE RSP IN PAR<1> BY "AL" SETTING WO.VC THEN RETURN
NEW = 1
FOR AC = 1 TO 20
INS "" BEFORE PAR<AC,WO.VC>
NEXT AC
PAR<1,WO.VC> = RSP
RETURN
!
END
~BU.MENU.HANDLER~
*PROGRAM:           MENU.HANDLER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
NEXT.SYSTEM: *
RESET.FLAG = FALSE
* IF @USER0 EQ EMPTY THEN PERFORM "RUN BP.OBJ INITIALIZATION"; * REV ONLY
!
*
OPEN "MENUS" TO MU.FILE ELSE STOP
OPEN "PAR" TO PAR.FILE ELSE
OPEN "LISTS" TO PAR.FILE ELSE STOP
END
*
!
*
LAST.MENU = EMPTY
PORT.KEY = (PORT+1000) "R#3"
CALL.ID = "MENU.":PORT.KEY
IF OPSYS NE "R" THEN
* IF OPSYS NE "U" THEN
OPEN "ACC" TO AC.FILE ELSE STOP
* END ELSE
IF OPSYS EQ "U" THEN
OPEN "DICT","ACC" TO AC.FILE.D ELSE STOP
END
END
*
!
*
DIM SCR.POSN(5); MAT SCR.POSN = EMPTY
DIM MENU(50),ROUTE(50),DOC(50),PRMPT(50),POSN(50)
*
READV DF.MENU.NAME FROM MU.FILE,"FIRST.MENU",ONE THEN
READ GENERIC FROM PAR.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM PAR.FILE,"GENERIC" ELSE NULL
END
END ELSE
DF.MENU.NAME = "/"
END
*
!
*
MATREAD SCR.POSN FROM PAR.FILE,CALL.ID THEN
*
ACC.ID = SCR.POSN(ONE)
MENU.NAME = SCR.POSN(TWO)<ONE,ONE>
SCR.LOCN = SCR.POSN(3)<ONE,ONE>
*
IF SCR.POSN(TWO) NE EMPTY THEN
*
LOOP
DEL SCR.POSN(TWO)<ONE,ONE>
DEL SCR.POSN(3)<ONE,ONE>
WHILE LEN(SCR.POSN(TWO)) AND SCR.POSN(TWO)<ONE,ONE> EQ MENU.NAME DO SCR.LOCN = SCR.POSN(3)<ONE,ONE> REPEAT
*
LOOP
LOCATE MENU.NAME IN SCR.POSN(TWO)<ONE> SETTING TMP ELSE TMP = FALSE
WHILE LEN(SCR.POSN(TWO)) AND TMP DO
TMP = DCOUNT(SCR.POSN(TWO),VM)
DEL SCR.POSN(TWO)<ONE,TMP>
DEL SCR.POSN(3)<ONE,TMP>
REPEAT
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "Logon / Initialization"
*
END
*
END ELSE
MAT SCR.POSN = EMPTY
ACC.ID = "MENU.":PORT.KEY
SCR.POSN(ONE) = ACC.ID
MENU.NAME = DF.MENU.NAME
SCR.POSN(TWO) = MENU.NAME
SCR.LOCN = ONE
SCR.POSN(3) = SCR.LOCN
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "Logon / Initialization"
END
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
*
!
*
CALL COPYRIGHT
*
!
*
READV RSP FROM MU.FILE,MENU.NAME,ONE ELSE MENU.NAME = DF.MENU.NAME; SCR.LOCN = ONE
RSP = EMPTY
IF NOT(NUM(SCR.LOCN)) THEN SCR.LOCN = ONE
IF SCR.LOCN LT ONE THEN SCR.LOCN = ONE
*
CO.DATA = "System not on disk":AM:DATE(); CNT.FILE.SW = EMPTY
CNT.FILE.OPEN = EMPTY
OPEN "CNT" TO CNT.FILE THEN
CNT.FILE.OPEN = ONE
READ CO.DATA FROM CNT.FILE,"CO.DATA" THEN CNT.FILE.SW = ONE ELSE CO.DATA = EMPTY; CNT.FILE.SW = EMPTY
END
*CKEYS
IF GENERIC THEN CURSOR.KEYS = EMPTY ELSE
*CKEYS
READ CURSOR.KEYS FROM PAR.FILE,"CURSOR.KEYS" ELSE CURSOR.KEYS = EMPTY
*CKEYS
END
*CKEYS
FKEYS="F1":VM:"F2":VM:"F3":VM:"F4":VM:"F5":VM:"F6":VM:"F7":VM:"F8":AM:"What?":VM:"How?":VM:"off":VM:"tcl":VM:"spool":VM:"compress":VM:"large":VM:"system"
IF LEN(CURSOR.KEYS<4>) THEN FKEYS = FKEYS<ONE>:AM:CURSOR.KEYS<4>
CO.NAME = CO.DATA<ONE,ONE,ONE>; CONTROL.DT = CO.DATA<TWO,ONE,ONE>
IF CONTROL.DT NE DATE() THEN
IF NOT(DATE() EQ CONTROL.DT AND TIME() LT 10000) THEN
IF NOT(CO.DATA<3>) THEN
CALL MAINT.CONTROL.DT(CNT.FILE,CO.DATA)
END ELSE
PRINT @(ZERO,23):CLL:"CONTROL DATE OVERRIDE IS SET!":
RQM
END
END
END
*
!
*
NEXT.MENU: *
*
*
LOOP
*
HELP = ZERO
*
IF MENU.NAME NE LAST.MENU THEN
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE
IF MENU.NAME EQ DF.MENU.NAME THEN STOP ELSE
MENU.NAME = DF.MENU.NAME
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE STOP
END
END
LAST.MENU = MENU.NAME
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV MENU(1) ON AC.FILE.D,ACC.ID,4
END
WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
END
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = MENU(1)
END
*
!
*
MAT ROUTE = EMPTY; MAT PRMPT = EMPTY; MAT POSN = EMPTY
TMP = ACCT; IF LEN(TMP) EQ ONE THEN TMP = TMP:" "
PRINT @(ZERO,ZERO):CLS:RVB:OCONV(CONTROL.DT,"D2") "L#12":(SPACE(28 - (LEN(CO.NAME) + ONE) / TWO):CO.NAME) "L#56":("Port ":PORT:SPACE(LEN(TMP) - TWO)) "R#12":
PRINT @(ZERO,ONE):OCONV(TIME(),"MTS") "L#12":(SPACE(28 - (LEN(MENU(ONE)) + ONE) / TWO):MENU(ONE)) "L#56":("Acct ":TMP) "R#12":RVE:
*
AC = TWO; CL = 22; LN = 3; CL.INC = 40
LOOP LINE = MENU(AC) UNTIL LINE EQ EMPTY OR AC EQ 100 DO
AC = AC + ONE
IF LINE<ONE,ONE> EQ ">" THEN
IF CL EQ TWO THEN
CL.INC = 30
END ELSE
CL = TWO
END
END
REPEAT
*
MAX.AC = AC - ONE; NUM = ONE
IF MAX.AC LT SCR.LOCN THEN SCR.LOCN = ONE
*
!
*
FOR AC = TWO TO MAX.AC
*
LINE = MENU(AC)
*
IF LINE<ONE,5> EQ EMPTY OR INDEX(LINE<ONE,5>,OPSYS,ONE) THEN
TEXT = LINE<ONE,ONE>
*
IF TEXT EQ ">" THEN CL = CL + CL.INC; LN = TWO; PRINT @(CL,LN): ELSE
*
IF TEXT[ONE,ONE] NE "*" THEN
PRMPT(NUM) = LINE<ONE,3>; IF PRMPT(NUM) EQ EMPTY THEN PRMPT(NUM) = NUM
POSN(NUM) = CL:AM:LN
ROUTE(NUM) = LINE<ONE,TWO>
DOC(NUM) = LINE<ONE,4>
* ULT ONLY
IF SYSTEM(11) LT 6 THEN
IF TEXT NE EMPTY THEN PRINT @(CL,LN):RVB:PRMPT(NUM) "R#3":RVE:" ":TEXT
* ULT ONLY
END
NUM = NUM + ONE
END ELSE IF TEXT NE "*" THEN PRINT @(CL - TWO,LN):TEXT[TWO,99]
*
END
*
LN = LN + ONE
*
END; * of valid for this OPerating SYStem
*
NEXT AC
*
!
*
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
*SCR.POSN(5) = MENU.NAME
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV MENU(1) ON AC.FILE,ACC.ID,4
END
WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
END
*
!
*
LOOP
*
*CKEYS
IF CURSOR.KEYS EQ EMPTY THEN
PRINT @(20,23):"Enter your choice: ":
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
INPUT RSP:
END ELSE
*CKEYS
*
PRINT CLB:
VC = ONE
*
LOOP UNTIL FKEYS<ONE,VC> EQ EMPTY DO
PRINT RVB:FKEYS<ONE,VC>:RVE:" ":FKEYS<TWO,VC>:"  ":
VC = VC + ONE
REPEAT
*
RSP = "\\\"
CRSP = EMPTY
*
* CURSOR POSITIONING LOOP
*
LOOP WHILE RSP EQ "\\\" DO
*
IF NOT(NUM(SCR.LOCN)) THEN SCR.LOCN = ONE
IF SCR.LOCN LT ONE THEN SCR.LOCN = ONE
FUNC.KEY = EMPTY
CLLN = POSN(SCR.LOCN)
CL = CLLN<ONE> - ONE
LN = CLLN<TWO>
PRINT @(CL,LN):
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
ECHO OFF
INPUT RSPC,ONE:
ECHO ON
RSPN = SEQ(RSPC)
*
IF CRSP[ONE,ONE] NE "." THEN
LOCATE RSPN IN CURSOR.KEYS<TWO> SETTING LOC THEN
RSPC = CURSOR.KEYS<3,LOC>; FUNC.KEY = ONE
RSPN = SEQ(RSPC)
END
END
*
IF NOT(RSPN) OR RSPN EQ 255 THEN
* MATCHES MINI'S MORE ACCURATELY RSP = PRMPT(SCR.LOCN)
RSP = EMPTY
IF CRSP NE EMPTY THEN RSP = CRSP
*
END ELSE IF FUNC.KEY AND RSPC EQ "5" THEN
RSP = PRMPT(SCR.LOCN)
IF CRSP NE EMPTY THEN RSP = CRSP
*
END ELSE
*
IF RSPN EQ 27 OR RSPN EQ 251 THEN
ECHO OFF
PRINT @(ZERO,22):CLL:RVB:"Enter function key number: ":RVE:
INPUT RSPC,ONE:
PRINT @(ZERO,22):CLL:
IF NUM(RSPC) THEN
IF RSPC GT ZERO AND RSPC LT 10 THEN
IF LEN(CURSOR.KEYS<5>) THEN
RSP = CURSOR.KEYS<5,RSPC>
END ELSE
RSPC = "NIOTSCRA"[RSPC,ONE]
FUNC.KEY = ONE
END
END
END ELSE
IF INDEX("NIOTSCRA",RSPC,ONE) THEN FUNC.KEY = ONE ELSE RSPC = EMPTY
END
ECHO ON
END; * OF ESC ENTERED
*
IF FUNC.KEY THEN
*
IF RSPC EQ ZERO THEN
CRSP = EMPTY
PRINT @(ZERO,22):CLL:
*
END ELSE IF RSPC EQ TWO THEN
SCR.LOCN = SCR.LOCN + ONE
IF PRMPT(SCR.LOCN) EQ EMPTY THEN SCR.LOCN = ONE
*
END ELSE IF RSPC EQ "8" THEN
SCR.LOCN = SCR.LOCN - ONE
IF NOT(SCR.LOCN) THEN RSP = EMPTY
*
END ELSE IF RSPC EQ "4" THEN
SCR.LOCN = ZERO
NCL = EMPTY; NLN = EMPTY; FOUND = EMPTY
*
LOOP UNTIL NLN GE LN DO
IF NCL LT CL THEN FOUND = FOUND + ONE
SCR.LOCN = SCR.LOCN + ONE
CLLN = POSN(SCR.LOCN)
NCL = CLLN<ONE> - ONE
NLN = CLLN<TWO>
REPEAT
*
IF NCL >= CL THEN
IF FOUND LT TWO THEN RSP = EMPTY ELSE SCR.LOCN = SCR.LOCN - ONE
END
*
END ELSE IF RSPC EQ "6" THEN
*
LOOP
*
SCR.LOCN = SCR.LOCN + ONE
CLLN = POSN(SCR.LOCN)
NCL = CLLN<ONE> - ONE
NLN = CLLN<TWO>
IF PRMPT(SCR.LOCN) EQ EMPTY THEN LN = ZERO; CL = ZERO; NLN = 999; NCL = 999; SCR.LOCN = SCR.LOCN - ONE
UNTIL NLN GE LN AND NCL GT CL DO
REPEAT
*
END ELSE
*
IF RSPC EQ "N" THEN RSP = "?":PRMPT(SCR.LOCN) ELSE
IF RSPC EQ "I" THEN RSP = "??":PRMPT(SCR.LOCN) ELSE
IF RSPC EQ "O" THEN RSP = "OFF" ELSE
IF RSPC EQ "T" THEN RSP = "TCL" ELSE
IF RSPC EQ "S" THEN RSP = "SPO" ELSE
IF RSPC EQ "C" THEN RSP = "COM" ELSE
IF RSPC EQ "R" THEN RSP = "REG" ELSE
IF RSPC EQ "A" THEN RSP = "ACT"
*
END; * REG
END; * COM
END; * SPO
END; * TCL
END; * OFF
END; * ??
END; * ?
*
END; * OF FKEY FUNCTIONS vs DEFINED POSITIONING
*
END ELSE
*
CRSP = CRSP:RSPC
IF LEN(CRSP) GT 3 AND CRSP[ONE,ONE] NE "." THEN CRSP = CRSP[TWO,3]
PRINT @(25,22):"Entry: ":RVB:CRSP:RVE:"  ":
*
END; * OF CHARACTER
*
END; * OF RSPN NOT NULL
*
REPEAT; * FOR CURSOR POSITIONING LOOP
*
PRINT @(ZERO,23):CLL:@(ZERO,22):CLL:@(20,22):"Enter your choice: ":RVB:RSP:RVE:
*CKEYS
END; * OF CURSOR KEYS NE EMPTY
*CKEYS
*
!
*
ROUTING = EMPTY; CR.FLAG = FALSE
*
IF RSP[ONE,ONE] EQ "." THEN
RESET.FLAG = TRUE
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
IF OPSYS NE "R" THEN
IF OPSYS EQ "U" THEN
WRITEV "Menu: ":MENU.NAME:" ":RSP ON AC.FILE.D,ACC.ID,4
END
WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
END
PRINT @(ZERO,23):CLL:@(ZERO,22):CLL:RSP[TWO,999]
* EXECUTE RSP[TWO,999]
* PRINT CLB:"Enter <cr> to return to menu . . .  ":; INPUT RSP:
* RSP = MENU.NAME
ROUTING = RSP[TWO,999]
CR.FLAG = TRUE
END
*
IF RSP EQ EMPTY THEN
LOOP
IF LEN(SCR.POSN(TWO)) THEN
IF MENU.NAME EQ SCR.POSN(TWO)<ONE,ONE> THEN
DEL SCR.POSN(TWO)<ONE,ONE>
DEL SCR.POSN(3)<ONE,ONE>
END
ROUTING = SCR.POSN(TWO)<ONE,ONE>
SCR.LOCN = SCR.POSN(3)<ONE,ONE>
IF NOT(NUM(SCR.LOCN)) THEN SCR.LOCN = ONE
IF SCR.LOCN LT ONE THEN SCR.LOCN = ONE
* IF SCR.POSN(TWO) NE EMPTY THEN
* DEL SCR.POSN(TWO)<ONE,ONE>
* DEL SCR.POSN(3)<ONE,ONE>
* END
END
IF ROUTING EQ EMPTY THEN ROUTING = DF.MENU.NAME
WHILE LEN(SCR.POSN(TWO)) AND ROUTING EQ MENU.NAME DO REPEAT
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "previous menu"
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
*
END ELSE IF RSP EQ "DATE" THEN
CALL MAINT.CONTROL.DT(CNT.FILE,CO.DATA)
ROUTING = MENU.NAME
*
END ELSE IF RSP[ONE,ONE] NE "." THEN
*
IF RSP[ONE,ONE] EQ "?" THEN
SUB = EMPTY; RSP = TRIM(RSP[TWO,99]); IF RSP[ONE,ONE] EQ "?" THEN RSP = RSP[TWO,99]; HELP = TWO ELSE HELP = ONE
ROUTING = STR("?",HELP); DOC.NAME = RSP
*IF RSP EQ EMPTY THEN RSP = MENU.NAME
IF DOC.NAME EQ EMPTY THEN DOC.NAME = MENU.NAME
END ELSE SUB = FIELD(RSP,"/",TWO); RSP = FIELD(RSP,"/",ONE); HELP = ZERO
*
IF SUB NE EMPTY THEN
READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
IF ROUTING NE EMPTY THEN READ DEFAULTS FROM MU.FILE,"/":RSP THEN RSP = SUB; GOSUB CHECK.DEFAULTS
END ELSE
*
* IF ROUTING[ONE,ONE] NE "?" AND ROUTING[ONE,ONE] NE "/" THEN
*
FOR NUM = ONE TO 100 UNTIL PRMPT(NUM) EQ RSP OR PRMPT(NUM) EQ EMPTY; NEXT NUM
*
IF NUM LE 100 AND PRMPT(NUM) NE EMPTY THEN
ROUTING = ROUTE(NUM); DOC.NAME = DOC(NUM); IF DOC.NAME EQ EMPTY THEN DOC.NAME = STR("?",HELP):ROUTING
SCR.LOCN = NUM
END ELSE IF ROUTING[ONE,ONE] NE "?" AND ROUTING[ONE,ONE] NE "/" THEN
READ DEFAULTS FROM MU.FILE,"DEFAULTS" THEN GOSUB CHECK.DEFAULTS
END
*
* END; * OF "?"
*
END; * of empty SUB
*
IF HELP OR ROUTING[ONE,ONE] EQ "?" THEN
*
IF NOT(HELP) THEN
IF ROUTING[TWO,ONE] EQ "?" THEN HELP = TWO ELSE HELP = ONE
END
*
IF HELP THEN IF ROUTING NE EMPTY THEN GOSUB HELP.MESSAGE; ROUTING = MENU.NAME
*
END; * OF "?"
*
END; * of other scan / help
*
WHILE ROUTING = EMPTY DO PRINT BELL: REPEAT
*
!
*
IF MENU.NAME EQ SCR.POSN(TWO)<ONE,ONE> THEN SCR.POSN(3)<ONE,ONE> = SCR.LOCN
*
IF MENU.NAME NE SCR.POSN(TWO)<ONE,ONE> AND RSP NE EMPTY THEN
INS MENU.NAME BEFORE SCR.POSN(TWO)<ONE,ONE>
INS SCR.LOCN BEFORE SCR.POSN(3)<ONE,ONE>
*IF OPSYS NE "R" THEN
*IF OPSYS EQ "U" THEN
*WRITEV MENU.NAME ON AC.FILE.D,ACC.ID,4
*END
*WRITE AM:MENU.NAME:AM:(DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5] ON AC.FILE,CALL.ID
*END
END
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
*SCR.POSN(5) = MENU.NAME
*MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
*
WHILE ROUTING[ONE,ONE] EQ "/" DO
*
IF MENU.NAME NE ROUTING AND RSP NE EMPTY THEN SCR.LOCN = ONE
MENU.NAME = ROUTING
*
REPEAT
*
!
*
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = ROUTING
*
IF (OPSYS EQ "M" OR ROUTING EQ "TCL") AND (MENU.NAME NE EMPTY AND MENU.NAME NE SCR.POSN(TWO)<ONE,ONE>) THEN
INS MENU.NAME BEFORE SCR.POSN(TWO)<ONE,ONE>
INS SCR.LOCN BEFORE SCR.POSN(3)<ONE,ONE>
END
SCR.POSN(3)<ONE,ONE> = SCR.LOCN
*
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
*
IF ROUTING EQ "OFF" OR ROUTING EQ "CHAIN OFF" THEN
*
*DELETE PAR.FILE,CALL.ID
SCR.POSN(TWO) = EMPTY
SCR.POSN(3)   = ONE
SCR.POSN(4) = (DATE()+100000)[TWO,5]:(TIME()+100000)[TWO,5]
SCR.POSN(5) = "OFF"
MATWRITE SCR.POSN ON PAR.FILE,CALL.ID
END
*
CLS.COL = ZERO; CLS.ROW = 3; GOSUB CLS.ROUTINE
*
IF ROUTING[ONE,ONE] EQ "^" THEN RESET.FLAG = TRUE; ROUTING = ROUTING[TWO,999]
IF ROUTING[ONE,ONE] EQ "%" THEN CR.FLAG = TRUE; ROUTING = ROUTING[TWO,999]
*
LOOP TC = INDEX(ROUTING,"$",ONE) WHILE TC DO
ROUTING = ROUTING[ONE,TC - ONE]:PORT.KEY:ROUTING[TC + ONE,999]
REPEAT
*
LOOP TC = INDEX(ROUTING,"#",ONE) WHILE TC DO
TMP = ROUTING[TC,TWO]
TMP = TMP[TWO,ONE]
IF NOT(NUM(TMP)) THEN TMP = ONE
IF NOT(TMP) THEN TMP = ONE
ROUTING = ROUTING[ONE,TC - ONE]:FIELD(ACCT,".",TMP):ROUTING[TC + TWO,999]
REPEAT
*
ROUTINE.SUFFIX = EMPTY
LOOP TC = INDEX(ROUTING,".?",ONE) WHILE TC DO
IF NOT(LEN(ROUTINE.SUFFIX)) THEN
TMP = ROUTING[ONE,TC - ONE]
LOOP UNTIL NOT(INDEX(TMP," ",ONE)) DO TMP = TMP[TWO,999] REPEAT
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = EMPTY
LOCATE TMP IN SPECIAL.ROUTINES<ONE> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<TWO,LOC>
END
ROUTING = ROUTING[ONE,TC]:ROUTINE.SUFFIX:ROUTING[TC + TWO,999]
REPEAT
*
*
PARAMS = ROUTING
ROUTING = ROUTING<ONE,ONE,ONE>
DEL PARAMS<ONE,ONE,ONE>
INPARAMS = EMPTY
*
LOOP UNTIL PARAMS = EMPTY DO
IF OPSYS = "R" THEN DATA PARAMS<ONE,ONE,ONE> ELSE INPARAMS = INPARAMS:PARAMS<ONE,ONE,ONE>:AM
DEL PARAMS<ONE,ONE,ONE>
REPEAT
*
IF OPSYS NE "R" THEN
WRITE AM:ROUTING:AM:(DATE() + 100000)[TWO,5]:(TIME() + 100000)[TWO,5] ON AC.FILE,CALL.ID
END
*
BEGIN CASE
*
CASE OPSYS = "U"
* ULT ONLY
*
IF ROUTING[ONE,6] NE "CHAIN" AND ROUTING NE "OFF" AND ROUTING NE "TCL" AND RSP[ONE,ONE] NE "." THEN
IF FIELD(ROUTING," ",TWO) = EMPTY THEN ROUTING = "RUN BP ":ROUTING
END
WRITEV ROUTING ON AC.FILE.D,ACC.ID,4
*
CASE OPSYS = "R"
* IF FIELD(ROUTING," ",TWO) = EMPTY THEN ROUTING = "RUN BP.OBJ ":ROUTING; * REV ONLY
*
CASE TRUE
TMP = FIELD(ROUTING," ",ONE)
IF TMP EQ "RUN" THEN
TMP = FIELD(ROUTING," ",TWO)
ROUTING = ROUTING[COL2() + ONE,9999]
END
*
END CASE
*
!
*
IF ROUTING = "TCL" THEN
BEGIN CASE
CASE OPSYS EQ "M"
ABORT
CASE TRUE
STOP
END CASE
END
*
IF ROUTING[ONE,6] = "CHAIN " THEN CHAIN ROUTING[7,999]
*
IF ROUTING[ONE,3] EQ "PC " THEN
EXECUTE ROUTING; * DON'T CHANGE
*
END ELSE
IF INPARAMS = EMPTY THEN
*
BEGIN CASE
*
CASE OPSYS = "M"
CHAIN ROUTING
*
CASE TRUE
EXECUTE ROUTING
*
END CASE
*
END ELSE
INPARAMS = INPARAMS[ONE,LEN(INPARAMS) - ONE]
*
BEGIN CASE
*
CASE OPSYS = "M"
DTEMP = INPARAMS
LOOP
DTCN = ZERO
LOOP DTCN = DTCN + 120 WHILE DTCN LT LEN(DTEMP<ONE>) DO
DTEMP<ONE> = DTEMP<ONE>[ONE,DTCN]:CHAR(31):CHAR(13):DTEMP<ONE>[DTCN + ONE,999]
REPEAT
DATA DTEMP<ONE>
DEL DTEMP<ONE,ZERO,ZERO>
WHILE LEN(DTEMP) DO REPEAT
CHAIN ROUTING
*
CASE TRUE
EXECUTE ROUTING, //IN. < INPARAMS
*
END CASE
*
END
*
END
*
*
REOPEN = EMPTY
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF CNT.FILE.OPEN THEN
READ RAMDISK.CNT FROM CNT.FILE,"RAMDISK.FILES" THEN
LOCATE ONE IN RAMDISK.CNT<TWO> SETTING LOC THEN
OPEN "LISTS" TO LISTS.FILE THEN
READ RAMDISK.REC FROM LISTS.FILE,"RAMDISK.FILES" THEN
CALL DOWNLOAD.RAMDISK(CNT.FILE,RAMDISK.CNT,LISTS.FILE,RAMDISK.REC)
REOPEN = ONE
END
END
END
END
END
*
*
* IF @USER0 EQ EMPTY THEN GOTO NEXT.SYSTEM; * REV ONLY
*
IF REOPEN THEN GOTO NEXT.SYSTEM
*
*
* VERIFY DATE IF IT DOES NOT MATCH CONTROL (Don't worry if before 3:00 next morning!)
IF NOT(CNT.FILE.SW) THEN GOTO NEXT.MENU
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE,ONE>; CONTROL.DT = CO.DATA<TWO,ONE,ONE>
IF CONTROL.DT NE DATE() THEN IF NOT(DATE() EQ CONTROL.DT + ONE AND TIME() LT 10000) THEN
IF NOT(CO.DATA<3>) THEN
CALL MAINT.CONTROL.DT(CNT.FILE,CO.DATA)
END ELSE
PRINT @(ZERO,23):CLL:"CONTROL DATE OVERRIDE IS SET!":
RQM
END
CONTROL.DT = CO.DATA<TWO>
END
*
IF CR.FLAG EQ TWO THEN
PRINT CLB:"Returning to menu . . . ":; RQM; RQM
END ELSE IF CR.FLAG THEN
PRINT CLB:"Enter <cr> to return to menu . . . ":; INPUT RSP:
END
*
*
IF RESET.FLAG THEN GOTO NEXT.SYSTEM
*
GOTO NEXT.MENU
*
*
STOP
!
*
*
CHECK.DEFAULTS: *
AC = TWO
LOOP DEFAULT = DEFAULTS<AC> UNTIL DEFAULT<ONE,3> EQ RSP OR DEFAULT EQ EMPTY DO AC = AC + ONE REPEAT
IF DEFAULT EQ EMPTY THEN
ROUTING = "/":RSP
READV TEMP FROM MU.FILE,ROUTING,ONE ELSE ROUTING = MENU.NAME
END ELSE
ROUTING = DEFAULT<ONE,TWO>; DOC.NAME = DEFAULT<ONE,4>; IF DOC.NAME = EMPTY THEN DOC.NAME = ROUTING
END
RETURN
!
HELP.MESSAGE: *
CLS.COL = ZERO; CLS.ROW = TWO; GOSUB CLS.ROUTINE
IF NOT(GENERIC) OR ROUTING EQ "?" OR DOC.NAME EQ "?" THEN
EXEC.LINE = 'COPY PAR MASK (T,S)'
EXECUTE EXEC.LINE
PRINT CLB:"Enter <cr> to continue with help . . . ":; INPUT RSP:
END
DOC.NAME.F = FIELD(DOC.NAME," ",ONE)
IF DOC.NAME.F NE EMPTY THEN
DOC.NAME.I = FIELD(DOC.NAME," ",TWO)
IF DOC.NAME.I = EMPTY THEN DOC.NAME.I = DOC.NAME.F; DOC.NAME.F = "CABLE"
IF HELP EQ TWO THEN DOC.NAME.I = "?":DOC.NAME.I
* ULT ONLY
EXLN = 'RUNOFF HLP,':DOC.NAME.F:' ':DOC.NAME.I
* EXLN = 'RUNOFF HLP ':DOC.NAME.F:'.':DOC.NAME.I; * REV ONLY
EXECUTE EXLN
PRINT CLB:"Enter <cr> to return to menu . . . ":; INPUT RSP:
END
RETURN
$INCLUDE IBP CLS.ROUTINE
END
~BU.PACK.NUMBER~
SUBROUTINE UNPACK.NUMBER(NUM.IN,NUM.OUT)
* PROGRAM:           UNPACK.NUMBER
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       UNPACK A NUMBER IN HEX
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*SETTERM
!
BEGIN CASE
CASE OPSYS = "R"
IF NUM.IN[1,1] = CHAR(13) THEN NUM.OUT = -OCONV(NUM.IN[2,99],"HEX") ELSE NUM.OUT = OCONV(NUM.IN,"HEX")
CASE OPSYS = "U"
NUM.OUT = OCONV(NUM.IN,"MX")
IF NUM.OUT[1,1] = "D" THEN NUM.OUT = -NUM.OUT[2,99] ELSE IF NUM.OUT[1,2] = "0D" THEN NUM.OUT = -NUM.OUT[3,99] ELSE NUM.OUT = NUM.OUT+0
CASE OPSYS = "M"
IF NUM.IN[1,1] = CHAR(13) THEN NUM.OUT = -OCONV(NUM.IN[2,99],"MX") ELSE NUM.OUT = OCONV(NUM.IN,"MX")
CASE 1; NUM.OUT = ""
END CASE
RETURN
END
~BU.UPLOAD.PPV.BUYS.PA~
*PROGRAM: UPLOAD.PPV.BUYS.PA
* VERSION: 950322 1.4  ADD OTHER.CTR (COLLECTION ERROR) & ERREV.CTR (EVENTS BUT COLL STATUS SET)
* PRIOR: 941005 1.3  ADD TIME() TO XPV RECORD.
* PRIOR: 940911 1.2  ADD GROUP TO XPV RECORD.
* PRIOR: 940420 1.1  ADDED CONTINUE UPLOAD OPTION (NEXT.DVC.ID = "XXXXXX"
*                      TRAP INTEFACE FATAL ERRORS AND STOP.
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
* DESCRIPTION:  UPLOAD IMPULSE PPV EVENTS FROM PIONEER POC.
*               UPLOAD.MODE IS INPUT FROM THE MENUS:
*                         0 IS UPLOAD ONLY NOT PREVIOUSLY UPLOADED
*                         1 IS UPLOAD ALL PPV BUYS.
*               WRITES VALID RESPONSES IN THE XPV FILE.
*                  XPV ERR CODES SET ARE:
*                   1 - Unkown Terminal ID (not in AIX)
*                   2 - Invalid Company (based on 1st digit of acct #)
*
*               COLLECTION STATUS IS RECEIVED IN COM.AIP$GROUP.RSLT
*               AN XPV RECORD WILL NOT BE WRITTEN FOR COLLECTION
*               STATUSES OF:
*               0E - NO CALL IN (WILL CURRENTLY BE FOLLOWED UP ON BY THE
*                    PPV DEPT. FROM POC PRINT OUTS).
*                    ** IN FUTURE THESE MAY BE CAPTURED AND BE USED
*                       TO GENERATE A LIST OF 'NO PHONE INS' WHICH WILL
*                       CONTAIN NAME ADDRESS AND TELEPHONE NUMBER AND WILL
*                       SAVE THEM THE TIME OF LOOKING THEM UP FROM THE
*                       TERMINAL ID.
*               0F - NO DATA RECEIVED.
*
*
* TEST MODE: IF LIST.NAME IT WILL CONTAIN DVC.IDs AND:
*              -WILL BYPASS AI OFF/DN ERROR,
*              -WILL HAVE BAD DVC.IDs IN LIST TO CREATE DVC ERRORS
*              -WILL GENERATE EVENTS FROM DVC.IDs IN THE LIST
*               USING TST.GENS, A LOOP THRU FOR # EVENTS PER DVC.ID
*               AND CHECKING TST(20) - THE HIGHEST EVENT NUMBER TO GENERATE
*               AND MAKE EVERY 10TH EVENT AN ERROR EVENT
*            ALSO TEST CNT.TST$Z - NO XPV WRITE COMMAND ISSUED
*
!
VERSION = "( 1.2)"; VS = VERSION
SYS.PROG = "UPLOAD.PPV.BUYS.PA"
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
*
$INCLUDE IBP XPV.DIM
$INCLUDE IBP XPV.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
!
*
INPUT AUTO.RUN
INPUT UPLOAD.MODE
*
$INCLUDE IBP AI.ERR.INIT
*
MAT CNT.TST = EMPTY
CHECK.LN.MIN = 14; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
OPER = ""; OPT.COMM = ""; CHECK.LEN = 35; CHECK.LN.HI = ZERO
* IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
AI.TALK = EMPTY
*
* INPUT AUTO.RUN
IF NOT(AUTO.RUN) THEN
* INPUT UPLOAD.MODE
END ELSE
READ CURRENT.RUN FROM CNT.FILE,"CURRENT.RUN" ELSE STOP
UPLOAD.MODE = CURRENT.RUN<1,2>
AI.CODE     = CURRENT.RUN<1,3>
GROUP       = CURRENT.RUN<1,4>
END
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:; STOP
OPEN "AIX" TO AIX.FILE ELSE PRINT CLB:"Can't open AIX":; INPUT TMP:; STOP
*
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN "XPV" TO XPV.FILE ELSE PRINT CLB:"Can't open XPV":; INPUT TMP:; STOP
OPEN "LOCKS" TO LOCKS.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:; STOP
* LOCK.FILE = 0; * REV ONLY
!
*
LOCK.TYPE = -3; LOCK.ITM = TRUE; LOCK.RELS = FALSE; LOCK.STAT = FALSE
MSG = EMPTY; TEXT = EMPTY; OUTPUTS = EMPTY; STATUS.CYCLE = FALSE
OPT.COMM = ""; TRANS.NUM = ""
COM.AI.ERR.DISP = TRUE; *10APR94*
REDISP = FALSE; ERR.DISP.ONLY = 5
ERR.LN.MIN = 14; ERR.LN.MAX = 20; ERR.LN.HI = ZERO
DO.PROMPT = TRUE
STAT = FALSE
*
CHECK.LN.MIN = 14; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
CHECK.LEN = 35; CHECK.LN.HI = ZERO
* IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
CHAN.ALL = FALSE; OPER = ""
*
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "U"; LOG.REQUIRED = FALSE; DVC.LOC = ONE
SEND.STATUS = EMPTY
FAST.DISPLAY = FALSE; PORTS.LIST.BUILD = 9; AI.SCAN = TRUE
AI.CHK.ERR = ""; MAT COM.AIHERR = ""
*
!
*
GOSUB LOAD.TST
IF CNT.TST$ON THEN VERSION = VERSION:" **** TEST MODE ****"
*
TST.GENS = "1":AM:"2":AM:"3":AM:"4":AM:"5"
EVENT.NUM = 1; EVENT.HI = CNT.TST(21); IF EVENT.HI = "" THEN EVENT.HI = "00050"
DISP.EVENT = EMPTY
*
IF CNT.TST$RTN THEN PRINT @(60,20):"UPLOAD.PPV.BUYS.PA" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = "Unknown"
CO.NAME = CO.DATA<1>
READV CURR.PER FROM COM.FILE,"CURR.PPV.REPORT.PERIOD",2 ELSE CURR.PER = ""
READ LAST.PPV.UPLOAD FROM COM.FILE,"LAST.PPV.UPLOAD.DATE" ELSE LAST.PPV.UPLOAD = ""
READ AI.COS FROM COM.FILE,"AI.COS" ELSE
PRINT CLB:"AI.COS is missing from COM file. Correct and restart. ":
INPUT TMP:
STOP
END
*
READV AI.TYPES FROM COM.FILE,"AI.TYPES",1 ELSE AI.TYPES = ""
IF NOT(COUNT(AI.TYPES<1>,VM)) THEN AI.CODE = AI.TYPES<1> ELSE AI.CODE = ""
*
AI.ERROR = 0; OVER = FALSE; UPLOADED.CTR = 0; ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
OVER.SKIP = ZERO
*
OVER = FALSE; SEND.OK.CN = 0; SEND.ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
SEND.STATUS = EMPTY; SEND.CN = ZERO; SEND.ERR.CN = ZERO
SEND.ERR.CN.TOT = ZERO; SEND.ERR.CN.MAX = 10; SEND.ERR.PER.MAX = 5
*
OKCOLL.CTR = 0; NOCALL.CTR = 0; NODATA.CTR = 0; OTHER.CTR = 0; INVALID.DVC = 0; VALID.CTR = 0
EMPEV.CTR = 0; ERREV.CTR = 0
DUPE.CTR = 0; COMM.CTR = 0
UPLOAD.DATE = DATE()
DVC.ID = ""; NEXT.DVC.ID = ""; EVENT.NUMS = ""; EVENT.DUR = ""
ACT.ID = ""; XPV.ID = ""
MAT XPV = ""
AI.STATUS = ""; SEND.STATUS = ""; COLL.STATUS = ""
*
PRINT @(0,0):CLS:
TITLE = "Upload Impulse PPV Buys":VERSION
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
IF CNT.TST$ON THEN
IF CNT.TST$LIST.NAME NE "" THEN
PRINT @(0,5):"LIST.NAME is ":CNT.TST$LIST.NAME:
LOOP
PRINT @(0,6):"Transactions will be generated.":
PRINT @(0,7):"Enter a starting transaction number: ":; INPUT TRANS.NUM:
IF NOT(NUM(TRANS.NUM)) THEN TRANS.NUM = ""
UNTIL TRANS.NUM NE "" DO PRINT BELL: REPEAT
END ELSE
PRINT @(0,5):"Uploading thru the Interface.":
END
IF CNT.TST$Z THEN
PRINT @(0,7):"Interface will be bypassed.":
END ELSE
PRINT @(0,7):"Interface will be tested and used if OK.":
END
PRINT CLB:"Press <E> to continue, or 'KILL': ":
INPUT RESP:
IF RESP = "KILL" THEN STOP
PRINT CLB:
MAT COM.AIP = ""; RESP = ""; PRINT @(0,3):CLS:
END
!
GET.INPUT: *
*
LN = 3
*
LOOP
IF AI.CODE = "" THEN PRINT @(10,LN):CLL:"Enter the Addressable Interface Code: ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP
LOCK.ITM = FALSE; LOCK.RELS = FALSE
GOSUB READ.COM.AI
IF NOT(COM.AI.ON.FILE) THEN IF NOT(CNT.TST$ON) THEN 
AI.CODE = ""
PRINT CLB:"That Addressable Interface has not been defined. Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
UNTIL AI.CODE NE "" DO REPEAT
IF AI.ERROR AND CNT.TST$LIST.NAME = "" THEN
PRINT @(10,LN+2):"The AI is ":COM.AI$ON.OFF.STAT:" and ":COM.AI$UP.DN.STAT:"  Do want to try another AI? (Y/<cr>): ":; INPUT RESP:
AI.ERROR = 0
IF RESP = "Y" THEN PRINT @(10,LN):CLL:; RESP = ""; AI.CODE = ""; GOTO GET.INPUT
STOP
PRINT @(10,LN+2):CLL:
END
*
LOCK.ITM = FALSE; LOCK.RELS = FALSE
*
AI.SUFFIX = COM.AI$DB.PREFIX; COMMPORT = COM.AI$COMMPORT
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":AI.SUFFIX ELSE MAT COM.AIIERR = ""
*
*
LN = LN+2
IF CURR.PER NE "" THEN
PRINT @(18,LN):CLL:"The Current PPV Reporting Period is ":CURR.PER:; LN = LN+1
END
*
IF UPLOAD.MODE THEN MODE = "Continue " ELSE MODE = ""
PRINT @(18,LN):CLL:MODE:"Uploading from Addressable Interface ":AI.CODE:; LN = LN+1
*
*
* IF NOT(AUTO.RUN) THEN
* IF UPLOAD.DATE EQ LAST.PPV.UPLOAD<1,1> THEN
LN = LN+2; UL.AC = 1
PRINT @(0,LN):"Gr Uploaded                   |Last|Valid Device|Invalid Dvcs|  No  ":; LN = LN+1
PRINT @(0,LN):"Gr Upld.Date Started  Elapsed |Tran|CountsEvents|CountsEvents|Events":; LN = LN+1
*
LOOP UL.DATE = LAST.PPV.UPLOAD<UL.AC,1> UNTIL UL.DATE = "" OR UL.DATE # LAST.PPV.UPLOAD<1,1> OR LN GT 19 DO
PRINT @(0,LN):LAST.PPV.UPLOAD<UL.AC,23> "L#2":" ":
PRINT OCONV(LAST.PPV.UPLOAD<UL.AC,1>,"D2") "L#10":
PRINT OCONV(LAST.PPV.UPLOAD<UL.AC,3>,"MTS") "L#9":
PRINT OCONV(LAST.PPV.UPLOAD<UL.AC,4>,"MTS") "L#8":
*30
PRINT "|":
PRINT LAST.PPV.UPLOAD<UL.AC,2> "R#4":
PRINT "|":
*37
PRINT LAST.PPV.UPLOAD<UL.AC,5> "R#6":
PRINT LAST.PPV.UPLOAD<UL.AC,7> "R#6":
PRINT "|":
*50
PRINT LAST.PPV.UPLOAD<UL.AC,8> "R#6":
PRINT LAST.PPV.UPLOAD<UL.AC,9> "R#6":
PRINT "|":
*63
PRINT LAST.PPV.UPLOAD<UL.AC,10> "R#4":
*67
PRINT LAST.PPV.UPLOAD<UL.AC,11> "R#4"
*71
PRINT LAST.PPV.UPLOAD<UL.AC,13> "R#4"
*75
PRINT LAST.PPV.UPLOAD<UL.AC,18> "R#4"
*79
UL.AC = UL.AC+1; LN = LN+1
*
REPEAT
*
* END
* END
*
*
LN = LN+2
LOOP
PRINT @(18,LN):CLL:"Enter the Group to upload or <cr> for all: ":; INPUT GROUP:
IF GROUP = "KILL" THEN STOP
IF GROUP = "" THEN GROUP = "00"
IF NOT(NUM(GROUP)) THEN GROUP = ""
UNTIL GROUP NE "" DO REPEAT
GROUP = ("00":GROUP) "R#2"
*
*
!
*
IF NOT(AUTO.RUN) THEN
CALL AUTO.LOADER("UPLOAD.PPV.BUYS.PA",UPLOAD.MODE:VM:AI.CODE:VM:GROUP,"Upl PPV Buys")
END
*
!
*
PRINT @(0,6):
START.TM = TIME(); LN = LN+2; IF LN GT 17 THEN LN = 17
*
IF CNT.TST$LIST.NAME NE "" THEN
EXECUTE 'GET-LIST ':CNT.TST$LIST.NAME
END
*
* SET DVC.ID TO UPLOAD FIRST BUY
DVC.ID = ""; NEXT.DVC.ID = ""; PREV.DVC.ID = ""
IF UPLOAD.MODE THEN NEXT.DVC.ID = "XXXXXX" ELSE NEXT.DVC.ID = "000000"
*
ERROR.IND = EMPTY
*
LOOP
LOCK.ITM = TRUE; LOCK.RELS = TRUE
GOSUB READ.COM.AI
GOSUB INTFC.CHECK
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
PRINT CLB:BELL:"The interface is not useable! Enter KILL or <cr> to retry . . . ":
IF NOT(AUTO.RUN) THEN
INPUT TMP:
IF TMP EQ "KILL" THEN STOP
GOTO GET.INPUT
END ELSE OVER = TRUE
END
WHILE NOT(COM.AI.ON AND COM.AI.UP) AND NOT(AUTO.RUN) DO REPEAT
*
!
MAIN.LOOP: *
IF CNT.TST$LBL THEN PRINT CLB:"Mainloop ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
PRINT @(0,3):CLS:
LN = 3
GENS.VC = 1; GEN.VC = 1
*
LOOP UNTIL OVER DO
*
EVENT.NUMS = ""; EVENT.DUR = ""; DVC.ID = ""; COLL.STATUS = ""
* IF AI.STATUS LT 100 OR AI.STATUS GE 600 THEN AI.STATUS = FALSE
AI.STATUS = EMPTY
SEND.STATUS = EMPTY
*
* ACCEPT KEYBOARD INPUT
IF SYSTEM(11) THEN
PRINT CLB:"Enter (S)top or <cr> to continue: ":; INPUT TMP:
PRINT CLB:; IF TMP = "S" THEN ERROR.IND = "O"; GOTO FINISH
LOOP
TMP = SYSTEM(11)
UNTIL NOT(TMP) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
END
*
!
*
IF CNT.TST$LIST.NAME NE "" THEN
*
READNEXT DVC.ID ELSE OVER = TRUE
*
IF (EVENT.NUM > EVENT.HI OR OVER) THEN OVER = TRUE; COM.AIP$END.OF.UPLOAD = "z"
*
* fill the XPV record with events to TST.GENS count
MAT XPV = ""; MAT COM.AIP = ""; TST.EVENTS = ""; TST.DUR = ""; EVENT.VC = 1
LOOP UNTIL EVENT.VC > TST.GENS<GENS.VC> DO
EVENT.ID = ("0000":EVENT.NUM) "R#4"
IF EVENT.ID[5,1] = 0 THEN EVENT.ID = "9":EVENT.ID[2,4]
TST.EVENTS<1,EVENT.VC> = EVENT.ID
TST.DUR<1,EVENT.VC> = ""
EVENT.NUM = EVENT.NUM+1; EVENT.VC = EVENT.VC+1
REPEAT
*
GENS.VC = GENS.VC+1
IF GENS.VC = 6 THEN GENS.VC = 1
COM.AIP$EVENT = TST.EVENTS
COM.AIP$EVENT.DUR = TST.DUR
COM.AIP$DVC.ID = DVC.ID
COM.AIP$TRAN.SEQ = TRANS.NUM
TRANS.NUM = TRANS.NUM+1
*
!
* Normal run
*
END ELSE
*
* GET ACTUAL DVC.ID AND EVENTS FROM NEXT TERMINAL
TRANS.TYPE = "UPB"; OPT.COMM<ONE> = TRANS.TYPE; HANDLER.COMMAND = TRANS.TYPE
MAT COM.AIP = EMPTY
OPT.PORT = PORT.KEY; OPT.DT = DATE(); OPT.TM = TIME(); AI.TALK = ""; COM.AIP$INTFC.STAT = ""
*
$INCLUDE IBP AI.LOAD.COM.AIP
*
COM.AIP$SVC.FUNC = "UPB"; COM.AIP$DVC.TYPE = AI.CODE
COM.AIP$OPER     = OPER
COM.AIP$SVC.EXTR = UPLOAD.MODE
COM.AIP$GROUP    = GROUP
COM.AIP$DVC.ID   = NEXT.DVC.ID
*
COM.AIP$EVENT = ""
COM.AIP$EVENT.DUR = ""
COM.AIP$GROUP.RSLT = ""
COM.AIP$END.OF.UPLOAD = ""
*
*
GOSUB WRITE.COMMAND
*
IF (AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*????
END
IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) THEN
ERROR.IND = "F"; GOTO FINISH
END
*
* Wait for command to be processed
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
WF.C.FUNC = PORT.KEY; STAT = 0; GOSUB WAITFOR.COMMAND
END
*
* Check transmission result
*
TMP.STAT = 0
$INCLUDE IBP AI.COM.AIP.UPD
*
*
IF TMP.STAT = 0 THEN TMP.STAT = ""; AI.STATUSES = ""
IF TMP.STAT NE "" THEN
IF AI.STATUS NE "" THEN
AI.STATUSES = TMP.STAT:AM:AI.STATUS
END ELSE
AI.STATUSES = TMP.STAT
END
END
*
IF AI.STATUSES NE "" THEN
VC = 1
LOOP TMP9 = AI.STATUSES<VC> UNTIL TMP9 = "" DO
LOCATE TMP9 IN COM.AIIERR$STD<1> SETTING LOC THEN
COM.AI.ERR      = COM.AI.ERR:AM:COM.AIIERR$STD<1,LOC>
COM.AI.ERR.TYPE = COM.AI.ERR.TYPE:AM:COM.AIIERR$TYPE<1,LOC>
COM.AI.ERR.DESC = COM.AI.ERR.DESC:AM:COM.AIIERR$DESC<1,LOC>
END
VC = VC+1
REPEAT
GOSUB INTFC.MESSAGES; GOSUB ERROR
END
*
*
**IF (AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
** ERROR.CTR = ERROR.CTR + 1
IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) THEN
ERROR.IND = "F"; GOTO FINISH
END
**END
*
LOOP WHILE NOT(COM.AI.ON AND COM.AI.UP) DO
LOCK.ITM = TRUE; LOCK.RELS = TRUE
GOSUB READ.COM.AI
GOSUB INTFC.CHECK
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
IF NOT(AUTO.RUN) THEN
PRINT CLB:BELL:"The interface is not useable! Enter <cr> or KILL ... ":
INPUT TMP:
IF TMP EQ "KILL" THEN GOTO FINISH
END ELSE
GOTO FINISH
END
END
REPEAT
*
*
END; * of not test mode
*
!
**PRINT CLB:"MIDDLE ":AI.STATUS:",":SEND.STATUS:",":COM.AIP$END.OF.UPLOAD:",":OVER:; INPUT TMP:
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*
IF COM.AIP$END.OF.UPLOAD NE "z" THEN
*
IF CNT.TST$X THEN
PRINT CLB:"Start process of uploaded item.":
PRINT "Enter <cr>: ":; INPUT TMP:
END
*
MAT XPV = ""
* not last terminal
*
EVENT.NUMS =     COM.AIP$EVENT
EVENT.DUR =      COM.AIP$EVENT.DUR
DVC.ID =         COM.AIP$DVC.ID
COLL.STATUS =    COM.AIP$GROUP.RSLT
*9503*DGH** IF EVENT.NUMS = "" THEN COLL.STATUS = "0D"
*
* validate the terminal id
*
MATREAD AIX FROM AIX.FILE,DVC.ID THEN INVALID.DVC = 0 ELSE INVALID.DVC =1; MAT AIX = ""
IF COUNT(AIX$ACT.ID,VM) THEN ACT.ID = "MULT" ELSE ACT.ID = AIX$ACT.ID
* prepare next terminal id'
NEXT.DVC.ID = "XXXXXX"
*
*@@@**** MOVE ABOVE READ
IF DVC.ID EQ PREV.DVC.ID THEN
DUPE.CTR = DUPE.CTR + 1
END ELSE
*
PREV.DVC.ID = DVC.ID
*
IF INVALID.DVC THEN
*
* Unknown Device Serial Number
*
XPV$ACT.ID = "000000"
XPV$ACC=     ""
XPV$ERROR = 1
*
END ELSE
*
*
* Validate Company
*
CO.PREFIX =  ACT.ID[1,1]
LOCATE CO.PREFIX IN AI.COS<1> BY "AR" SETTING LOC THEN
*
* Good Company
*
XPV$ACC = AI.COS<2,LOC>
*
END ELSE
*
* Bad Company Number
*
XPV$ACC = ""
XPV$ERROR = 2
*
END; * of locate
END; * of valid dvc
*
*950322*DGH*IF COLL.STATUS EQ "00" OR XPV$EVENT.NUMS NE "" THEN   *v
IF EVENT.NUMS NE "" THEN
*
IF COLL.STATUS NE "00" THEN ERREV.CTR = ERREV.CTR + 1
*950322*DGH*^
*
IF XPV$ERROR THEN
ERROR.CTR = ERROR.CTR + 1
ERROR.EVENT.CTR = ERROR.EVENT.CTR+(COUNT(EVENT.NUMS,VM)+1)
END ELSE
VALID.CTR = VALID.CTR + 1
EVENT.CTR = EVENT.CTR+(COUNT(EVENT.NUMS,VM)+1)
END
*
TRANS.NUM = COM.AIP$TRAN.SEQ
*
XPV.ID = DATE():"*":TRANS.NUM:"*":DVC.ID
XPV$AI.CODE =    AI.CODE
XPV$EVENT.NUMS = EVENT.NUMS
XPV$DUR    =     EVENT.DUR
XPV$ACCOUNT    = ACT.ID
XPV$GROUP      = GROUP
XPV(10)        = TIME()
*
MATWRITE XPV ON XPV.FILE,XPV.ID
*
*
END ELSE
EMPEV.CTR = EMPEV.CTR + 1
*950322*DGH*END ELSE   *v
END; * OF EVENT NUMS PRESENT
*
IF COLL.STATUS NE "00" THEN
*950322*DGH*^
*
*950322*DGH*IF COLL.STATUS = "0E" AND EVENT.NUMS = "" THEN NOCALL.CTR = NOCALL.CTR + 1   *v
*950322*DGH*IF COLL.STATUS = "0D" THEN NODATA.CTR = NODATA.CTR + 1
IF COLL.STATUS = "0E" THEN NOCALL.CTR = NOCALL.CTR + 1 ELSE
IF COLL.STATUS = "0D" THEN NODATA.CTR = NODATA.CTR + 1 ELSE
OTHER.CTR = OTHER.CTR + 1
END
END
*950322*DGH*^
*
END ELSE
OKCOLL.CTR = OKCOLL.CTR + 1
END; * of collection status not "00"
*
UPLOADED.CTR =   UPLOADED.CTR + 1
*
END; * of duplicate device
*
!
*
*950106*END ELSE OVER = TRUE; * Last terminal has been received
END ELSE
*
IF UPLOADED.CTR GT ZERO OR OVER.SKIP GT 2 THEN
OVER = TRUE
PRINT CLB:"Finished.":BELL:
END ELSE
OVER.SKIP = OVER.SKIP + ONE
PRINT CLB:"POC says we are finished.  Double checking.":BELL:
END
*
COMM.CTR = COMM.CTR + 1
*
END; * Last terminal has been received
*
*
END ELSE
PRINT CLB:"Trans error (":AI.STATUS:",":SEND.STATUS:")!!!":BELL:
COMM.CTR = COMM.CTR + 1
END; * of transmission error
*
!
*
SEND.CN = SEND.CN + ONE
*950324*DGH*IF AI.STATUS LT 100 AND (NOT(SEND.STATUS) OR SEND.STATUS EQ ERR$CHECK.TOUT) THEN
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*
SEND.ERR.CN = ZERO
* PVE$DLL.ERR = ""
SEND.OK.CN = SEND.OK.CN + 1
SEND.ERR.PER = INT(SEND.ERR.CN.TOT / SEND.CN * 100)
PRINT CLB:SEND.ERR.CN+0:" errors in a row, at ":SEND.ERR.PER:"%, [":AI.STATUS:"], (Total ":SEND.ERR.CN.TOT+0:").":
* PRINT @(40,EV.LN+1):CLL:"Event Details Uploaded: ":SEND.OK.CN "R#4":
* PRINT @(5,11):CLL:"Event Details Uploaded: ":SEND.OK.CN "R#4":
IF CNT.TST$ID THEN
PRINT CLB:"Completed upload of Event ":DISP.EVENT:
IF CNT.TST$Y THEN PRINT "Enter <cr>: ":; INPUT TMP:
END
*
END ELSE
*
SEND.ERR.CN = SEND.ERR.CN + ONE
SEND.ERR.CN.TOT = SEND.ERR.CN.TOT + ONE
SEND.ERROR.CTR = SEND.ERROR.CTR + 1
SEND.ERR.PER = INT(SEND.ERR.CN.TOT / SEND.CN * 100)
PRINT CLB:SEND.ERR.CN+0:" errors in a row, at ":SEND.ERR.PER:"%, [":AI.STATUS:"], (Total ":SEND.ERR.CN.TOT+0:").":
PRINT @(0,12):SEND.ERR.CN+0:" errors in a row, at ":SEND.ERR.PER:"%, [":AI.STATUS:"], (Total ":SEND.ERR.CN.TOT+0:").":
*
IF SEND.ERR.CN GT SEND.ERR.CN.MAX OR (SEND.ERR.PER GT SEND.ERR.PER.MAX AND SEND.ERR.CN GT 5) THEN
PRINT CLB:"Too many errors (":SEND.ERR.CN.TOT+0:")! Stopping the upload.":BELL:
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>: ":
INPUT TMP:
END
OVER = TRUE
END
*
PRINT CLB:"Error (":AI.STATUS:",":SEND.STATUS:") on upload of Event: ":DISP.EVENT:BELL:
IF CNT.TST$ID THEN
IF CNT.TST$Y THEN PRINT "Enter <cr>: ":; INPUT TMP:
END
IF CNT.TST$LBL THEN PRINT CLB:("Handler Send Error: ":COM.AIP$INTFC.ERR) "L#30":; IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:
*
END; * of transmission error
*
*
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
PRINT CLB:"The Handler is not ON and UP. Stopping the upload.":
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>: ":
INPUT TMP:
END
OVER = TRUE
END
*
* END; * of not list.name
*
*
PRINT @(9,LN-1):CLL:"      Uploading Group: ":GROUP "R#6":"    Device: ":DVC.ID "L#20":
PRINT @(9,LN+0):CLL:"  Converters Uploaded: ":UPLOADED.CTR "R#6":"     Status: (":AI.STATUS:"-":SEND.STATUS:"-":COLL.STATUS:"-":XPV$ERROR:")":
PRINT @(9,LN+1):CLL:"                Empty: ":EMPEV.CTR "R#6":
PRINT @(9,LN+2):CLL:"                Valid: ":VALID.CTR "R#6":"  Events: ":EVENT.CTR "R#6":
PRINT @(9,LN+3):CLL:"          *** Invalid: ":ERROR.CTR "R#6":"  Events: ":ERROR.EVENT.CTR "R#6":"    Tot Devices: ":(EMPEV.CTR+VALID.CTR+ERROR.CTR) "R#6":
PRINT @(9,LN+4):CLL:"   Events & Coll Note: ":ERREV.CTR "R#6":"   Total: ":(EVENT.CTR+ERROR.EVENT.CTR) "R#6":
PRINT @(9,LN+5):CLL:"    Other Coll Errors: ":OTHER.CTR "R#6":
PRINT @(9,LN+6):CLL:"           No Call In: ":NOCALL.CTR "R#6":
PRINT @(9,LN+7):CLL:"          *** No Data: ":NODATA.CTR "R#6":"  TotColl: ":(OTHER.CTR+NOCALL.CTR+NODATA.CTR) "R#6":" vs ":OKCOLL.CTR "L#6":"  for ":(OTHER.CTR+NOCALL.CTR+NODATA.CTR+OKCOLL.CTR) "R#6":
PRINT @(9,LN+8):CLL:"            Comm Data: ":COMM.CTR "R#6":
PRINT @(9,LN+9):CLL:"            Dupe Data: ":DUPE.CTR "R#6":"     Good: ":OKCOLL.CTR "R#6":"      All Comm: ":(OTHER.CTR+NOCALL.CTR+NODATA.CTR+OKCOLL.CTR+COMM.CTR+DUPE.CTR) "R#6":
PRINT @(9,LN+10):CLL:"*** Total Comm Errors: ":SEND.ERR.CN.TOT "R#6":"     Good: ":SEND.OK.CN "R#6":"         Total: ":SEND.CN "R#6":
PRINT @(9,LN+11):CLL:"Interface Trans. Num.: ":TRANS.NUM "R#6":
*
*
REPEAT
*
ERROR.IND = "N"; GOTO FINISH; * : *
*
!
WRITE.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Write Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*
* @@@ COM.AIP REC LOAD
*
DT = DATE(); TM = TIME(); HEADEND = ""
LOCK.ITM = TRUE; LOCK.RELS = TRUE
* 250
*
LOOP
GOSUB READ.COM.AI; * : @
LOCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LOCK.STAT AND LOCK.STAT NE 998 AND LOCK.ELP LE 60 DO REPEAT
*
IF LOCK.STAT EQ 998 THEN
MSG.P = "Transaction cancelled - Interface info missing! Enter <cr>: "
END ELSE
IF LOCK.STAT THEN
MSG.P = "Transaction cancelled - Interface locks error!! Again (Y/<cr>): "
END
END
IF LOCK.STAT THEN
GOSUB DISPLAY.PROMPT
IF RSP EQ "Y" THEN STAT = FALSE; GOTO WRITE.COMMAND
**AI.STATUS = LOCK.STAT; STAT = 999
STAT = 999
END
*
IF NOT(LOCK.STAT) THEN
*
CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LOCK.COM.AI,LOCK.COM.AIP,LOCK.TYPE)
*
END; * of not stat
*
**LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
**COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:PORT.KEY
**END
***
**MATWRITE COM.AI ON COM.FILE,COM.AI.ID
***
**LOCK.ITM = TRUE; LOCK.RELS = TRUE
**GOSUB READ.COM.AI.UNLOCK
*
RETURN
!
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LOCK.TYPE,LOCK.ITM,LOCK.RELS,LOCK.STAT,LOCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,STAT)
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT CLB:"WAIT FOR COMMAND":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*INCLUDE IBP AI.INCL.WAITFOR.COMMAND
CALL AI.SUBR.WAITFOR.COMMAND(LOCK.TYPE,LOCK.ITM,LOCK.RELS,LOCK.STAT,LOCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,STAT)
*
RETURN
!
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Read Com Ai" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.READ.COM.AI
*
IF NOT(COM.AI$ON.OFF = "ON" AND COM.AI$UP.DN.STAT = "UP") THEN
AI.ERROR = 1
END ELSE AI.ERROR = 0
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY
*
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE MAT COM.AIIERR = EMPTY
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
*
RETURN
*
!
!
DISPLAY.PROMPT: * DISPLAY MSG AND PROMPT 'ENTER <cr>' IF DO.PROMPT
LOOP
PRINT CLB:MSG.P:; IF DO.PROMPT THEN INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
MSG.P = ""; DO.PROMPT = 1
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INTFC.MESSAGES
*
RETURN
*
!
FINISH: *
IF CNT.TST$LBL THEN PRINT CLB:"Finish ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
END.DATE = DATE(); ELAPSED.TM = (END.DATE-UPLOAD.DATE)*86400+(TIME()-START.TM)
*
INS UPLOAD.DATE     BEFORE LAST.PPV.UPLOAD<1>
INS TRANS.NUM       BEFORE LAST.PPV.UPLOAD<1,2>
INS START.TM        BEFORE LAST.PPV.UPLOAD<1,3>
INS ELAPSED.TM      BEFORE LAST.PPV.UPLOAD<1,4>
INS UPLOADED.CTR    BEFORE LAST.PPV.UPLOAD<1,5>
INS VALID.CTR       BEFORE LAST.PPV.UPLOAD<1,6>
INS EVENT.CTR       BEFORE LAST.PPV.UPLOAD<1,7>
INS ERROR.CTR       BEFORE LAST.PPV.UPLOAD<1,8>
INS ERROR.EVENT.CTR BEFORE LAST.PPV.UPLOAD<1,9>
INS NODATA.CTR      BEFORE LAST.PPV.UPLOAD<1,10>
INS NOCALL.CTR      BEFORE LAST.PPV.UPLOAD<1,11>
INS ERROR.IND       BEFORE LAST.PPV.UPLOAD<1,12>
INS OTHER.CTR       BEFORE LAST.PPV.UPLOAD<1,13>
INS ERREV.CTR       BEFORE LAST.PPV.UPLOAD<1,14>
INS SEND.ERR.CN.TOT BEFORE LAST.PPV.UPLOAD<1,15>
INS SEND.OK.CN      BEFORE LAST.PPV.UPLOAD<1,16>
INS SEND.CN         BEFORE LAST.PPV.UPLOAD<1,17>
INS EMPEV.CTR       BEFORE LAST.PPV.UPLOAD<1,18>
INS OKCOLL.CTR      BEFORE LAST.PPV.UPLOAD<1,19>
INS AI.STATUS       BEFORE LAST.PPV.UPLOAD<1,20>
INS SEND.STATUS     BEFORE LAST.PPV.UPLOAD<1,21>
INS COLL.STATUS     BEFORE LAST.PPV.UPLOAD<1,22>
INS GROUP           BEFORE LAST.PPV.UPLOAD<1,23>
*
CN.MAX = DCOUNT(LAST.PPV.UPLOAD,AM)
LOOP WHILE CN.MAX GT 100 DO
PRINT @(0,23):CN.MAX:
DEL LAST.PPV.UPLOAD<CN.MAX>
CN.MAX = CN.MAX - 1
REPEAT
*
WRITE LAST.PPV.UPLOAD ON COM.FILE,"LAST.PPV.UPLOAD.DATE"
*
IF ERROR.IND = "O" THEN END.LIT = "by operator"
IF ERROR.IND = "F" THEN END.LIT = "Abnormal, Interface failure"
IF ERROR.IND = "N" THEN END.LIT = "completed succesfully"
PRINT CLB:"Upload stopped - ":END.LIT:". Enter <cr>: ":; INPUT TMP:
STOP
*
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
!
END
~BU1.AI.TALKER~
SUBROUTINE AI.TALKER(AI.ACTN,AI.RSLT,AI.STATUS,WOF,AIL.ID)
*PROGRAM:           AI.TALKER
EQU VS TO "940216 1.1"
*
* COPYRIGHT AXION COMPUTER SYSTEMS
*
$INCLUDE IBP AI.TALKER.TOP
*
!
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
VERSION = VS
*
!
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP AIL.DIM
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIIERR.DIM
*
!
*
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP WKO.EQUATES
$INCLUDE IBP DVC.EQUATES
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP SAVE.ACT.EQUATES
$INCLUDE IBP AI.TALK.VAR.EQUATES
$INCLUDE IBP FN.VAR.EQUATES
$INCLUDE IBP AI.STATUS.VAR.EQUATES
$INCLUDE IBP AI.ERR.VAR.EQUATES
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP COM.AIP.EQUATES
$INCLUDE IBP AIL.EQUATES
$INCLUDE IBP COM.AIHERR.EQUATES
$INCLUDE IBP COM.AIIERR.EQUATES
*
!
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STAT = 999; RETURN
OPEN "ACG" TO ACG.FILE ELSE PRINT CLB:"Can't open ACG":; INPUT TMP:; STAT = 999; RETURN
OPEN "AIX" TO AIX.FILE ELSE PRINT CLB:"Can't open AIX":; INPUT TMP:; STAT = 999; RETURN
*
!
*
AUTO.RUN = FALSE; DISP.ONLY = FALSE; MSG.DISP = FALSE; DO.PROMPT = TRUE
LOCK.TYPE = -3; LOCK.ITM = TRUE; LOCK.RELS = FALSE; LOCK.STAT = FALSE
MSG = EMPTY; TEXT = EMPTY; OUTPUTS = EMPTY; STATUS.CYCLE = FALSE
COM.AI.ERR = EMPTY; COM.AI.ERR.DISP = FALSE; COM.AI.ERR.TEXT = EMPTY
COM.AI.ERR.TYPE = EMPTY; COM.AI.ERR.FUNC = EMPTY
* COM.AI.ERR.DISP = TRUE
LOCK.COM.AI = FALSE
FUNC.CHNG = EMPTY; AIL.NEXT.ID = AIL.ID
*
REDISP = FALSE
$INCLUDE IBP AI.ERR.INIT
COM.AI.ERR.DISP = TWO
ERR.CLB = FALSE
ERR.LN.MIN = TWO; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CL = 43; ERR.LEN = 36
ERR.DISP.ONLY = 3
*
CHECK.LN.MIN = 12; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
CHECK.LEN = 48; CHECK.LN.HI = ZERO
IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
CHAN.ALL = FALSE
OPER = ""; HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
*
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.RESET = FALSE; AI.STATUS = FALSE; AI.DOWN = EMPTY; AI.SCAN = FALSE
AI.SRCE = "T"; LOG.REQUIRED = FALSE
PORTS.LIST.BUILD = EMPTY; PORTS.LIST = EMPTY; PORTS.LIST.PREV = EMPTY; PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
*
!
*
GOSUB LOAD.TST
*
*
* IF (CNT.TST$RTN OR CNT.TST$LBL) THEN FAST.DISPLAY = TRUE ELSE FAST.DISPLAY = FALSE
FAST.DISPLAY = TRUE
IF AI.TALK<OP.MULTI> THEN SINGLE = 0 ELSE SINGLE = 1
*
*
IF CNT.TST$RTN THEN PRINT CLB:"Entering AI.TALKER for ":AI.ACTN:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
LOCK.ITM = FALSE; LOCK.RELS = FALSE
GOSUB READ.COM.AI
IF COM.AI.NOT.ON.FILE THEN RETURN
*
*
IF NOT(AI.TALK<INTERFACE.MSG>) THEN AI.ACTN = FN$CHECK.INTFC:AM:AI.ACTN
*
IF NOT(AI.TALK<DISPATCHER.MSG>) THEN AI.ACTN = FN$CHECK.DISPATCHER:AM:AI.ACTN
*
IF AIX.ID NE EMPTY OR (AI.TALK<AI.DVC.NEXT> AND AI.TALK<AI.DVC.IDS> NE EMPTY) THEN DVC.ON.FILE = TRUE ELSE DVC.ON.FILE = FALSE
*
!
*
START: *
*
LOOP
TYPE = AI.ACTN<1>
WHILE TYPE NE EMPTY AND NOT(STAT) DO
BEGIN CASE
*
* GENERAL FUNCTIONS     @@@
*
CASE TYPE EQ FN$CHECK.INTFC; *
MSG.P = MSG<FN$CHECK.INTFC>; GOSUB RTN.CHECK.INTFC; * INTERFACE MSG
*
CASE TYPE EQ FN$INPUT.TRAN
* ON PREMISE CHECK
IF INDEX("RC",WOF,1) THEN GOSUB Q12.SERVICES.AS.IS; * WILL SERVICES ON PREMISE BE CHANGED?
IF (AI.TALK<BUILD.WO> AND (WKO.ID EQ "NEW" OR WKO.ID EQ EMPTY)) THEN GOSUB BUILD.WKO
*
CASE AI.TALK<OP.STAT>; NULL; * THE INTERFACE IS DOWN
*
CASE TYPE EQ FN$CHECK.DISPATCHER; *
MSG.P = MSG<FN$CHECK.DISPATCHER>; GOSUB RTN.CHECK.DISPATCHER; * DISPATCHER MSG
*
CASE TYPE EQ FN$INPUT.INSTALLER; *
IF NOT(ADD$STAT EQ "H" OR ADD$STAT EQ "C") THEN RETURN
IF AI.TALK<OP.MULTI> AND WOF EQ "S" THEN RETURN
IF AI.TALK<TALKING> EQ EMPTY THEN GOSUB RTN.INPUT.INSTALLER; * IS SOMEONE AT SITE? (AVAIL TO TEST)
*
CASE TYPE EQ FN$COMPR.SVC; * TYPE = 4
GOSUB RTN.COMPARE.SVC
!
* DISC FUNCTIONS     @@@
*
CASE TYPE EQ FN$INPUT.DISC; * TYPE = 5
GOSUB RTN.INPUT.DISC; * DEACTIVATE SERVICES NOW?
*
CASE TYPE EQ FN$VERIFY.DISC; * TYPE = 15
GOSUB RTN.VERIFY.DISC; * HAS SERVICE BEEN STOPPED OK?
*
CASE TYPE EQ FN$REQRD.WO.DISC; * TYPE = 18
GOSUB RTN.REQRD.WO.DISC; * TECHNICIAN MUST BE SENT TO DEACITIVATE SERVICES
*
CASE TYPE EQ FN$INPUT.PREV.TNT; * TYPE = 21
GOSUB RTN.INPUT.PREV.TNT; * DISCONNECT THE PRIOR TENANT?
*
CASE TYPE EQ FN$INPUT.PREV.ADDR; * TYPE = 22
GOSUB RTN.INPUT.PREV.ADDR; * DISCONNECT THE PRIOR.ADDRESS?
!
* TYPE 6 - ENTERED WORK ORDERS
CASE TYPE EQ FN$INPUT.WO
*
IF WOF NE "D" THEN 
IF ACT$SERVICES = "" THEN CALL CALC.WKO.CHANGES
GOSUB RTN.COMPARE.SVC 
*END ELSE
*AI.TALK<ADDRESSABLE> = AIX.ID
END
**********************************************
* CONNECT AND RECONNECT W/O FUNCTIONS     @@@
*
IF WOF = "R" OR WOF = "C" THEN
*
* COLD CONNECT OR RECONNECT *******************
IF ADD$STAT NE "H" THEN 
*
IF AI.TALK<TALKING> THEN
*
GOSUB RTN.INPUT.WO; * ACTIVATE THE COLD ADDRESS?
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
IF DVC.ON.FILE THEN
IF AI.TALK<VERIFIED.HOT> THEN 
GOSUB Q10.CONFIRM.WO; * SERVICES ACTIVE. CONFIRM THE WO?
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
*
END ELSE
*
GOSUB RTN.INPUT.TRY ; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
IF AI.TALK<DO.SEND> THEN
GOSUB ACTIVATE.SERVICES
IF DVC.ON.FILE THEN
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO; * CONFIRM THIS WORK ORDER?
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END
*
END
*
GOTO REPEAT.EXIT
END
*
* HOT CONNECT OR RECONNECT *********************
IF ADD$STAT EQ "H" THEN
*
IF AI.TALK<TALKING> THEN
GOSUB RTN.VERIFY.SVC
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB RTN.INPUT.WO; * ACTIVATE SERVICES?
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
IF DVC.ON.FILE THEN
IF AI.TALK<VERIFIED.HOT> THEN 
GOSUB Q10.CONFIRM.WO
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END ELSE
GOSUB RTN.INPUT.TRY ; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
IF AI.TALK<DO.SEND> THEN
GOSUB ACTIVATE.SERVICES
IF DVC.ON.FILE THEN
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO; * CONFIRM THIS WORK ORDER?
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END
END
GOTO REPEAT.EXIT
END
END
*
*************************************
* DISCONNECTS     @@@@
IF (WOF EQ "D") THEN
*
IF AI.TALK<TALKING> THEN
IF CO.DATA<15> THEN GOSUB RTN.INPUT.PREV.ADDR ELSE GOSUB RTN.INPUT.DISC; * DEACTIVATE SERVICES NOW?
IF AI.TALK<DO.SEND> THEN GOSUB DEACTIVATE.SERVICES
IF NOT(CO.DATA<15>) AND AI.TALK<VERIFIED.COLD> THEN 
GOSUB Q10.CONFIRM.WO; * CONFIRM THE WORK ORDER?
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END ELSE
GOSUB RTN.INPUT.TRY; * Do you want to Activate/Deactivate now?
IF AI.TALK<DO.SEND> THEN 
GOSUB DEACTIVATE.SERVICES
IF AI.TALK<SENT> THEN 
* GOSUB Q10.CONFIRM.WO
GOSUB CONFIRM.WKO; * IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END
END
GOTO REPEAT.EXIT
END
*
*************************************
*  SERVICE CHANGES    @@@@
*
IF WOF = "S" THEN
*
IF DVC.ON.FILE THEN
IF (AI.TALK<TALKING> AND SINGLE AND NOT(WKO$SCH.DATE > DATE())) THEN
GOSUB RTN.INPUT.TRY
IF AI.TALK<DO.SEND> THEN GOSUB SEND.CHANGE
IF AI.TALK<VERIFIED.CHANGED> THEN 
GOSUB Q10.CONFIRM.WO
IF STAT = 999 THEN RETURN ELSE GOSUB CONFIRM.WKO
END
END ELSE
LOOP UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO GOSUB SEND.CHANGE REPEAT
IF AI.TALK<SENT> THEN GOSUB CONFIRM.WKO ELSE
AI.TALK<PRINT.WO> = TRUE
IF WKO$SCH.TYPE = "AI" THEN
WKO$SCH.TYPE = ""; WKO$SCH.DATE = ""
GOSUB P25.RESCHEDULE.WO
END
END
END
END
GOTO REPEAT.EXIT
END
!
*
CASE TYPE EQ FN$VERIFY.SVC; * TYPE = 7
GOSUB RTN.VERIFY.SVC; * ARE SERVICES ACTIVE AT THE ADDRESS?
*
CASE TYPE EQ FN$INPUT.TRY; * TYPE = 8
GOSUB RTN.INPUT.TRY; * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
*
* CASE TYPE EQ 9; GOSUB P9.ACTIVATING.PLS.WAIT; * ACTIVATING SERVICES
*
* CASE TYPE EQ 10; GOSUB Q10.CONFIRM.WO; * SERVICES ACTIVATED. CONFIRM NOW?
*
* CASE TYPE EQ 11; GOSUB Q11.DO.CHANGE; * DO YOU WANT TO CHANGE SERVICES NOW?
*
* CASE TYPE EQ 14; GOSUB Q14.RETRY.ACTIVATE; * RESEND ACTIVATE/DEACTIVATE?
*
* CASE TYPE EQ 16; GOSUB Q16.SEND.AGAIN; * (DE)ACTIVATE WAS NOT SUCCESSFUL. SEND AGAIN?
*
* CASE TYPE EQ 19; GOSUB P19.CHANGING.PLS.WAIT
*
* CASE TYPE EQ 20; GOSUB Q20.CHANGED
*
* CASE TYPE EQ 24; GOSUB P24.ENTER.MAINT.WO
*
!
CASE TYPE EQ 60; GOSUB Q9.ACTIVATE.SERVICES
*
!
* FROM AI.SEND.WKO  @@@@
*      TYPE 81 = NO MONITORING. PROCESS WITHOUT PROMPTING
*      TYPE 82 = TO BE MONITORED
*
*
CASE (TYPE EQ 81 OR TYPE EQ 82); * WO'S (WOF R,D,S) (81 NOT TALKING)
IF TYPE EQ 81 THEN AI.TALK<TALKING> = 0
CALL CALC.WKO.CHANGES
OPER = AI.RSLT; AI.RSLT = ""
IF WOF EQ "R" THEN GOSUB ACTIVATE.SERVICES
IF WOF EQ "D" THEN GOSUB DEACTIVATE.SERVICES
IF WOF EQ "S" THEN GOSUB SEND.CHANGE
IF AI.TALK<SENT> THEN GOSUB CONFIRM.WKO
IF TYPE EQ 82 AND NOT(AI.TALK<NOT.SCHEDULED>) THEN WKO$SCH.DATE = WKO$EFF.DATE
*
RETURN
!
* CANCELLED WORK ORDERS    @@@@
*
CASE TYPE EQ 90; * CANCELLING A CONNECT/RECONNECT. DEACTIVATE SERVICE?
IF AI.TALK<TALKING> THEN
IF ADD$STAT EQ "C" THEN
GOSUB RTN.INPUT.WO
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
END
IF ADD$STAT EQ "H" THEN
GOSUB RTN.VERIFY.SVC
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB RTN.INPUT.WO
IF AI.TALK<DO.SEND> THEN GOSUB ACTIVATE.SERVICES
END
END
*
CASE TYPE EQ 91; * CANCELLING A DISCONNECT. REACTIVATE SERVICE?
IF AI.TALK<TALKING> THEN GOSUB RTN.VERIFY.SVC
IF NOT(AI.TALK<VERIFIED.HOT>) THEN GOSUB ACTIVATE.SERVICES
*
CASE TYPE EQ 92; * CANCELLING A SERVICE CHANGE. CHECK SERVICES?
IF AI.TALK<TALKING> THEN GOSUB P23.VERIFY.SERVICES
!
*
CASE TRUE; GOSUB TYPE.ERROR; STAT = 999; RETURN
*
END CASE
*
REPEAT.EXIT: *
DEL AI.ACTN<1>
*
REPEAT
*
IF CNT.TST$RTN THEN PRINT CLB:"Exiting from AI.TALKER.":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF AI.TALK<SENT> AND WKO$STAT # "C" THEN
MSG.P = MSG<27>; GOSUB DISPLAY.PROMPT; * NOW DOING REVERSALS
END
*
* IF COM.AI$GENIE.WINDOW EQ "Y" THEN
* CALL DISPLAY.SERVICES
* CALL DISPLAY.WORK.ORDER.DETAIL
* END
*
RETURN; * to calling program.     @@@
!
* GENERAL FUNCTIONS     @@@
*
TYPE.ERROR: *
RESULT = 99; STAT = 999
MSG.P = MSG<17>
GOSUB DISPLAY.PROMPT; * : @
*
RETURN
!
RTN.CHECK.DISPATCHER: * DISPLAY DISPATCHER MESSAGE IF REQUIRED
*
DT = DATE(); TM = TIME()
*
IF AI.TALK<DISPATCHER.MSG> THEN RETURN
*
READ DISP.MSG FROM COM.FILE,"DISP.MSG" THEN
TEXT = EMPTY
TMP = DISP.MSG<ONE>
IF LEN(TMP) THEN
IF DISP.MSG<2> LT DT OR (DISP.MSG<2> EQ DT AND DISP.MSG<3> LE TM) OR (DISP.MSG<2> EQ EMPTY AND DISP.MSG<3> LE TM) THEN
IF DISP.MSG<4> GT DT OR (DISP.MSG<4> EQ DT AND DISP.MSG<5> LE TM) OR (DISP.MSG<4> EQ EMPTY AND DISP.MSG<5> LE TM) THEN
IF NOT(ERR.CLB) THEN ERR.DISP.ONLY = 4 ELSE ERR.DISP.ONLY = FALSE
LOOP WHILE LEN(TMP) DO
IF ERR.CLB THEN
TEXT = TEXT:TMP<ONE,ONE>:" "
END ELSE
TEXT<-ONE> = TMP<ONE,ONE>
END
DEL TMP<ONE,ONE>
REPEAT
ERR.HDR = "Dispatcher Message"
IF LEN(TEXT) THEN
TEXT = MSG.P:AM:TEXT
GOSUB ERROR
IF NOT(ERR.CLB) THEN CALL DISPLAY.SERVICES; * : @
END; * of text not empty
END; * of not expired
END; * of past effective
END; * of msg text present
END; * of msg on file
*
AI.TALK<DISPATCHER.MSG> = 1
*
RETURN
*
!
RTN.CHECK.INTFC: * DISPLAY ADDRESS INTERFACE MESSAGE IF REQUIRED
*
DT = DATE(); TM = TIME()
*
IF AI.TALK<INTERFACE.MSG> THEN RETURN
*
READ INTFC.MSG FROM COM.FILE,"INTFC.MSG.":AI.CODE THEN
TEXT = EMPTY; ERR.DISP.ONLY = 4
TMP = INTFC.MSG<ONE>
IF LEN(TMP) THEN
IF INTFC.MSG<2> LT DT OR (INTFC.MSG<2> EQ DT AND INTFC.MSG<3> LE TM) OR (INTFC.MSG<2> EQ EMPTY AND INTFC.MSG<3> LE TM) THEN
IF INTFC.MSG<4> GT DT OR (INTFC.MSG<4> EQ DT AND INTFC.MSG<5> LE TM) OR (INTFC.MSG<4> EQ EMPTY AND INTFC.MSG<5> LE TM) THEN
LOOP WHILE LEN(TMP) DO
IF ERR.CLB THEN
TEXT = TEXT:TMP<ONE,ONE>:" "
END ELSE
TEXT<-ONE> = TMP<ONE,ONE>
END
DEL TMP<ONE,ONE>
REPEAT
ERR.HDR = "Addressable Interface Message"
IF LEN(TEXT) THEN
TEXT = MSG.P:AM:TEXT
ERR.DISP.ONLY = FALSE
IF ERR.CLB THEN GOSUB ERROR 
* IF NOT(ERR.CLB) THEN CALL DISPLAY.SERVICES; * : @
AI.TALK<INTERFACE.MSG> = 1
END; * of text not empty
END; * of not expired
END; * of past effective
END; * of msg text present
END; * of msg on file
*
!
*
IF (CNT.TST$RTN OR CNT.TST$LBL) THEN COM.AI.ERR.DISP = TWO ELSE COM.AI.ERR.DISP = FALSE
LOCK.ITM = FALSE; LOCK.RELS = TRUE
DT = DATE(); TM = TIME()
LOOP
GOSUB READ.COM.AI; * : @
LOCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
IF LOCK.STAT EQ 999 THEN STAT = 999; RETURN
WHILE LOCK.STAT AND LOCK.ELP LE 60 DO REPEAT
GOSUB CHECK.HANDLER; * : @
GOSUB INTFC.MESSAGES
IF LEN(TEXT) AND AI.STATUS THEN
* AI.TALK<OP.STAT> = AI.STATUS
AI.TALK<OP.STAT> = NOT(COM.AI.ON AND COM.AI.UP)
AI.TALK<OP.UP>   = FALSE
GOSUB ERROR 
END
*
IF NOT(ERR.CLB OR ERR.DISP.ONLY) THEN CALL DISPLAY.SERVICES; * : @
*
AI.TALK<INTERFACE.MSG> = 1
*
RETURN
*
!
RTN.INPUT.INSTALLER: * PROMPT CSR TO SEE IF CUSTOMER/INSTALLER AT SITE
*
LOOP
PRINT CLB:MSG<FN$INPUT.INSTALLER>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<TALKING> = 0
IF TMP NE "" THEN
IF TMP EQ "T" THEN AI.TALK<TALKING> = 1
IF TMP EQ "I" THEN AI.TALK<TALKING> = 2
TMP = ""
END
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
*
RETURN
*
!
RTN.COMPARE.SVC: * LOAD AIW RECORD FOR THIS PORT
*
EQUAL.SERVICES = 1; EQUAL.OUTLETS = 1; NO.DVCS = 1
*
* IF AI.TALK<ADDRESSABLE> NE EMPTY THEN RETURN
*
WKO.VC = 1; AIX.SV = 1
IF AI.TALK<OP.MULTI> THEN AIX.VC = AI.TALK<OP.MULTI> ELSE AIX.VC = 1
*
LOOP
*
WKO.ACTIV = WKO$ACTIVS<1,WKO.VC>
*
*27MAR94*IF INDEX("AHS",WKO.ACTIV,1) THEN
IF WKO.ACTIV EQ "S" THEN
*
SVC.FOUND = TRUE
IF AIX.ID NE "" THEN
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN DVC$SERVICE<1,AIX.VC> SETTING LOC ELSE SVC.FOUND = FALSE
END ELSE
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN COM.AI$DF.SVCS.ONE<1,DVC.LOC> SETTING LOC ELSE SVC.FOUND = FALSE
END
*
IF SVC.FOUND THEN
*
LOCATE WKO$ACTIV.SERVICES<1,WKO.VC> IN ACT$SERVICES<1> SETTING TMP1 THEN TMP = ACT$QNTYS<1,TMP1> ELSE TMP = 0
*
IF AIX.ID NE "" THEN
*
IF AI.TALK<OP.MULTI> THEN 
IF TMP NE DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC> THEN EQUAL.OUTLETS = 0
END ELSE
IF WKO$ACTIV.QNTYS<1,WKO.VC> LT 0 THEN
IF (NOT(DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC> + WKO$ACTIV.QNTYS<1,WKO.VC> = 0)) THEN EQUAL.OUTLETS = 0
END ELSE
IF (TMP NE DVC$CONNECTED.OUTLETS<1,AIX.VC,LOC>) THEN EQUAL.OUTLETS = 0
END
END
*
END ELSE
NULL; * OUTLETS OK ON ADDRESSABLE (?CHECK ADD?)
END
*
END ELSE
EQUAL.SERVICES = 0
END
*
END; * OF ACTIV AHS
*
WKO.VC = WKO.VC + ONE
UNTIL WKO$ACTIVS<1,WKO.VC> EQ EMPTY OR NOT(EQUAL.SERVICES AND EQUAL.OUTLETS) DO REPEAT
*
IF COUNT(WKO$ACTIVS,"W") THEN EQUAL.OUTLETS = 0
IF COUNT(WKO$ACTIVS,"I") THEN NO.DVCS = 0
*
IF AI.TALK<AI.DVC.NEXT> AND AI.TALK<AI.DVC.IDS> NE EMPTY THEN
IF WKO$STAT NE "P" OR EQUAL.OUTLETS THEN AI.TALK<DO.SEND> = TRUE ELSE AI.TALK<PRINT.WO> = TRUE
END ELSE IF AIX.ID NE EMPTY THEN
* IF EQUAL.SERVICES AND EQUAL.OUTLETS AND NO.DVCS THEN AI.TALK<ADDRESSABLE> = AIX.ID ELSE AI.TALK<PRINT.WO> = TRUE
IF (EQUAL.SERVICES AND EQUAL.OUTLETS AND NO.DVCS) THEN AI.TALK<DO.SEND> = TRUE ELSE AI.TALK<PRINT.WO> = TRUE
END ELSE AI.TALK<PRINT.WO> = TRUE
*
RETURN
*
!
* DISC PROCESSING     @@@
*
RTN.INPUT.DISC: * DEACTIVATE SERVICES NOW?
*
LOOP
PRINT CLB:MSG<FN$INPUT.DISC>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
*
RETURN
*
!
RTN.VERIFY.DISC: * HAVE SERVICES BEEN STOPPED OK?
*
LOOP
PRINT CLB:MSG<FN$VERIFY.DISC>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.COLD> = 0; AI.TALK<SENT> = 0;  RETURN
IF TMP EQ "Y" THEN AI.TALK<VERIFIED.COLD> = 1
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
*
RETURN
*
!
RTN.REQRD.WO.DISC: * This address will require a premise call
*
MSG.P = MSG<FN$REQRD.WO.DISC>
GOSUB DISPLAY.PROMPT
*
RETURN
*
!
RTN.INPUT.PREV.TNT: * DEACTIVATE SERVICES OF PRIOR TENANT NOW?
*
LOOP
PRINT CLB:MSG<FN$INPUT.PREV.TNT>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
*
RETURN
*
!
RTN.INPUT.PREV.ADDR: * DEACTIVATE SERVICES AT PRIOR ADDRESS NOW?
*
LOOP
PRINT CLB:MSG<FN$INPUT.PREV.ADDR>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
*
!
* CONN PROCESSING     @@@
*
RTN.INPUT.WO: * DO YOU WANT TO ACTIVATE THE OP SERVICES?
LOOP
PRINT CLB:MSG<FN$INPUT.WO>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<DO.SEND> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
RTN.VERIFY.SVC: * ARE SERVICES BEING RECEIVED OK AT THIS ADDRESS?
LOOP
PRINT CLB:MSG<FN$VERIFY.SVC>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.HOT> = 0; AI.TALK<SENT> = 0; RETURN
IF TMP EQ "Y" THEN
AI.TALK<VERIFIED.HOT> = 1
END
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
RTN.INPUT.TRY: * DO YOU WANT TO ACTIVATE/DEACTIVATE NOW?
LOOP
PRINT CLB:MSG<FN$INPUT.TRY>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1; RETURN
IF TMP EQ "N" THEN AI.TALK<DO.SEND> = 0
UNTIL TMP EQ "N" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P9.ACTIVATING.PLS.WAIT: * ACTIVATING SERVICES. PLEASE WAIT...
MSG.P = MSG<9>; DO.PROMPT = FALSE
GOSUB DISPLAY.PROMPT
RETURN
!
Q9.ACTIVATE.SERVICES: * ACTIVATE SERVICES AS IS.
*
IF LEN(AI.TALK<AI.DVC.IDS>) THEN
IF AI.TALK<AI.DVC.NEXT> THEN
SAVE.AI.DVC.NEXT = AI.TALK<AI.DVC.NEXT>
AI.DVC.NEXT.MAX = DCOUNT(AI.TALK<AI.DVC.IDS>,VM)
FOR AI.DVC.NEXT.CN = ONE TO AI.DVC.NEXT.MAX
AI.TALK<AI.DVC.NEXT> = AI.DVC.NEXT.CN
IF AI.TALK<AI.DVC.IDS,AI.TALK<AI.DVC.NEXT>> NE EMPTY THEN
IF AI.TALK<OP.UP> THEN
GOSUB ACTIVATE.SERVICES
END
END
NEXT AI.DVC.NEXT.CN
AI.TALK<AI.DVC.NEXT> = SAVE.AI.DVC.NEXT
END
END
*
RETURN
!
Q10.CONFIRM.WO: * CONFIRM THE WORK ORDER?
*
RETURN
*
LOOP
PRINT CLB:MSG<10>:; INPUT TMP:
IF TMP EQ "KILL" THEN
* IF (WOF EQ "C" OR WOF EQ "R") THEN
* IF AI.TALK<TALKING> THEN
* GOSUB DEACTIVATE.SERVICES
* GOSUB RTN.VERIFY.DISC
* IF NOT(AI.TALK<VERIFIED.HOT>) THEN
* LOOP
* GOSUB DEACTIVATE.SERVICES
* IF NOT(AI.TALK<VERIFIED.COLD>) THEN GOSUB Q16.SEND.AGAIN
* UNTIL AI.TALK<VERIFIED.COLD> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
* END
* IF WOF EQ "D" THEN
* END
* IF WOF EQ "S" THEN
* END
* IF NOT(AI.TALK<VERIFIED.COLD>) THEN GOSUB RTN.REQRD.WO.DISC
* END ELSE
* IF NOT(AI.TALK<VERIFIED.CHANGED>) THEN GOSUB RTN.REQRD.WO.DISC
* END
* END
STAT = 999
RETURN
END
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
RETURN
!
Q11.DO.CHANGE: * DO A SERVICE CHANGE?
LOOP
PRINT CLB:MSG<11>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN RETURN
IF TMP EQ "Y" THEN
TMP<1> = "S"
CALL MAINT.WORK.ORDER
RETURN
TMP = ""
END
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
RETURN
!
Q12.SERVICES.AS.IS: * WILL THERE BE A CHANGE TO OP SERVICES?
LOOP
PRINT CLB:MSG<12>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF INDEX("RC",WOF,1) AND (TMP EQ EMPTY OR TMP EQ "N") THEN AI.TALK<BUILD.WO> = 1; RETURN
IF AIX.ID NE EMPTY AND TMP EQ "Y" THEN AI.TALK<PRINT.WO> = TRUE; RETURN
UNTIL TMP NE "Y" OR TMP = EMPTY DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P13.DEACTIVATING.PLS.WAIT: * DEACTIVATING SERVICES. PLEASE WAIT...
MSG.P = MSG<13>; DO.PROMPT = FALSE
GOSUB DISPLAY.PROMPT;
RETURN
!
* Q14.RETRY.ACTIVATE: * RETRY ACTIVATING SERVICES
* LOOP
* PRINT CLB:MSG<14>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
* IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
* IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
* UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
* TMP = ""
* RETURN
!
Q16.SEND.AGAIN: * ACTIVATE/DEACTIVATE WAS NOT SUCCESSFUL. SEND AGAIN?
LOOP
PRINT CLB:MSG<16>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<DO.SEND> = 0; RETURN
IF TMP EQ "Y" THEN AI.TALK<DO.SEND> = 1
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P25.RESCHEDULE.WO: * THE WORK ORDER MUST BE RESCHEDULED
MSG.P = MSG<25>
WKO$SCH.TYPE = ""
WKO$SCH.DATE = ""
GOSUB DISPLAY.PROMPT
RETURN
!
P19.CHANGING.PLS.WAIT: *
MSG.P = MSG<19>; DO.PROMPT = FALSE
GOSUB DISPLAY.PROMPT
RETURN
!
Q20.CHANGED: *
LOOP
PRINT CLB:MSG<20>:; INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ EMPTY OR TMP EQ "N" THEN AI.TALK<VERIFIED.CHANGED> = 0; AI.TALK<SENT> = 0;  RETURN
IF TMP EQ "Y" THEN AI.TALK<VERIFIED.CHANGED> = 1
UNTIL TMP EQ "Y" DO PRINT BELL: REPEAT
TMP = ""
RETURN
!
P23.VERIFY.SERVICES: * PLEASE CHECK CURRENT SERVICES RECEIVED OK.
MSG.P = MSG<23>
GOSUB DISPLAY.PROMPT
RETURN
!
P24.ENTER.MAINT.WO: *
MSG.P = MSG<24>
GOSUB DISPLAY.PROMPT
RETURN
!
DISPLAY.PROMPT: * DISPLAY MSG AND PROMPT 'ENTER <cr>' IF DO.PROMPT
LOOP
PRINT CLB:MSG.P:; IF DO.PROMPT THEN INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
MSG.P = ""; DO.PROMPT = 1
RETURN
!
CONFIRM.WKO: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering CONFIRM.WKO":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
RETURN
*
IF WOF # "D" AND WKO$EFF.DATE LT DATE() THEN WKO$EFF.DATE = DATE()
IF TYPE # 81 AND WOF EQ "D" THEN WKO$EFF.DATE = DATE() ELSE WKO$EFF.DATE = DATE()+1
WKO$STAT = "C"
WKO$INSTALLER = "!AI"
IF TYPE[1,1] = 8 THEN OPER = "!AI"
WKO$OPERATOR = WKO$OPERATOR:"*":OPER
WKO$COMPL.DATE = DATE()
IF WOF EQ "D" THEN ADD$STAT = "C"; ADD$HOT.OUTLETS = 0; WKO$TYPE = "SS" ELSE
* 9JUL91 IF WOF NE "R" THEN
* A PENDING OR FROM AI.SEND.WKO
IF TYPE[1,1] = 8 OR ACT$SERVICES = "" THEN
MAT SAVE.ACT = MAT ACT
IF TYPE = 82 OR TYPE = 91 THEN CALL DISPLAY.WORK.ORDER.CALCS
END
END
MAT SAVE.ACT = MAT ACT
RSP = "C"; CALL CONFIRM.WORK.ORDER
CALL UPDATE.FILES; RSP = "S"; CALL DISPLAY.BASIC.DATA; CALL DISPLAY.SERVICES; AI.TALK<WKO.STAT> = "C"; RSP = "C"
LOOP UNTIL UPDATED = EMPTY DO
ITEM.NAME = UPDATED<ONE>
POS = INDEX(ITEM.NAME,"*",ONE)
FILE.NAME = ITEM.NAME[ONE,POS - ONE]
ITEM.NAME = ITEM.NAME[POS + ONE,999]
CALL UNLOCK.ITEM(LOCKS.FILE,FILE.NAME,ITEM.NAME,LOCKS.FILE)
DEL UPDATED<ONE>
REPEAT
RETURN
*
!
*
ACTIVATE.SERVICES: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering ACTIVATE.SERVICES":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
AI.CNTRL.NUM = ONE
HANDLER.COMMAND = "AIDVC"
IF AI.TALK<IMPULSE.PPV> THEN
HANDLER.COMMAND<ONE,-ONE> = "IVI"
END ELSE IF AI.TALK<PAY.PER.VIEW> THEN
HANDLER.COMMAND<ONE,-ONE> = "PVI"
END
GOSUB ATTEMPT.COMMAND
*
RETURN
*
!
*
DEACTIVATE.SERVICES: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering DEACTIVATE.SERVICES":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
HANDLER.COMMAND = "AIDVC"
IF AI.TALK<IMPULSE.PPV> THEN
HANDLER.COMMAND = "IVD":VM:HANDLER.COMMAND
END ELSE IF AI.TALK<PAY.PER.VIEW> THEN
HANDLER.COMMAND = "PVD":VM:HANDLER.COMMAND
END
AI.CNTRL.NUM = TWO
GOSUB ATTEMPT.COMMAND
*
RETURN
*
!
*
SEND.CHANGE: *
*
AI.CNTRL.NUM = 3
HANDLER.COMMAND = "AIDVC"
*
DVC.CHECK.FUNC = "WKO"
$INCLUDE IBP KBIL.INCL.DVC.CHECK.TYPE
*
TMP.ID = AI.TALK<ADDRESSABLE>
IF TMP.ID EQ EMPTY THEN TMP.ID = AIX.ID
LOCATE TMP.ID IN AI.TALK<AI.DVC.IDS> SETTING DVC.LOC THEN
*
IF AI.TALK<AI.DVC.IPPV,DVC.LOC> THEN
IF AI.TALK<IMPULSE.PPV> THEN
HANDLER.COMMAND<ONE,-ONE> = "IVI"
END ELSE
HANDLER.COMMAND = "IVD":VM:HANDLER.COMMAND
END
END
*
IF AI.TALK<AI.DVC.PPV,DVC.LOC> THEN
IF AI.TALK<PAY.PER.VIEW> THEN
HANDLER.COMMAND<ONE,-ONE> = "PVI"
END ELSE
HANDLER.COMMAND = "PVD":VM:HANDLER.COMMAND
END
END
*
END; * OF LOCATE
*
GOSUB ATTEMPT.COMMAND
*
RETURN
*
!
*
BUILD.WKO: *
IF CNT.TST$LBL THEN PRINT CLB:"Entering BUILD.WKO":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF WKO$ACTIV.SERVICES<1,1> NE "" THEN RETURN
AIX.VC = ADD$AIX.LOCATION; IF AIX.VC = "" THEN AIX.VC = 1
IF DVC$SERVICE<1,AIX.VC> NE "" THEN
AI.TALK<BUILD.WO> = 1; AIX.SV = 1; WKO.VC = 1
LOOP SVC.ID = DVC$SERVICE<1,AIX.VC,AIX.SV> UNTIL SVC.ID EQ EMPTY DO
IF NOT(WKO.VC EQ 1) THEN WKO$ACTIVS<1,WKO.VC> = WKO$ACTIVS<1,WKO.VC>:"!S"
WKO$ACTIV.SERVICES<1,WKO.VC> = WKO$ACTIV.SERVICES<1,WKO.VC>: "!":SVC.ID
WKO$ACTIV.QNTYS<1,WKO.VC> = WKO$ACTIV.QNTYS<1,WKO.VC>: "!":DVC$CONNECTED.OUTLETS<1,AIX.VC,AIX.SV>
AIX.SV = AIX.SV+1; WKO.VC = WKO.VC+1
REPEAT
END
RETURN
*
!
*
ATTEMPT.COMMAND: *
IF CNT.TST$LBL THEN PRINT CLB:"Attempt Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
IF AI.CNTRL.NUM EQ ONE THEN
AI.CNTRL.CHECK = VERIFIED.HOT
END ELSE IF AI.CNTRL.NUM EQ TWO THEN
AI.CNTRL.CHECK = VERIFIED.COLD
END ELSE IF AI.CNTRL.NUM EQ 3 THEN
AI.CNTRL.CHECK = VERIFIED.CHANGED
END ELSE
AI.CNTRL.NUM = 4
AI.CNTRL.CHECK = VERIFIED.CHANGED
END
*
LOOP
*
ON AI.CNTRL.NUM GOSUB P9.ACTIVATING.PLS.WAIT,P13.DEACTIVATING.PLS.WAIT,P19.CHANGING.PLS.WAIT,P19.CHANGING.PLS.WAIT
*
* 1 ACTIVATING SERVICES. PLEASE WAIT . . . 
* 2 DEACTIVATING SERVICES
* 3 CHANGING SERVICES
* 4 UNKNOWN (USE CHANGE)
*
AI.TALK<SENT> = FALSE; AI.STATUS = FALSE
GOSUB WRITE.COMMAND; * : @
*
IF NOT(AI.STATUS) THEN
WF.C.FUNC = PORT.KEY; GOSUB WAITFOR.COMMAND;* : @
IF NOT(AI.STATUS) THEN AI.TALK<SENT> = TRUE
END
*
IF NOT(AI.TALK<SENT>) THEN 
*
GOSUB Q16.SEND.AGAIN; * NOT SUCCESSFUL, SEND AGAIN?
*
END ELSE
*
IF AI.TALK<TALKING> THEN
*
ON AI.CNTRL.NUM GOSUB RTN.VERIFY.SVC,RTN.VERIFY.DISC,Q20.CHANGED,Q20.CHANGED
*
* ARE SERVICES BEING RECEIVED OK?
* HAVE SERVICES BEEN STOPPED?
* HAVE SERVICES BEEN CHANGED OK?
*
IF NOT(AI.TALK<AI.CNTRL.CHECK>) THEN GOSUB Q16.SEND.AGAIN
*
END
*
END
*
IF STAT EQ 999 THEN RETURN
*
UNTIL AI.TALK<SENT> OR NOT(AI.TALK<DO.SEND>) DO REPEAT
*
RETURN
*
!
*
WRITE.COMMAND: *
IF CNT.TST$LBL THEN PRINT CLB:"Write Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
* @@@ COM.AIP REC LOAD
*
HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
OPT.DT = DATE(); OPT.TM = TIME()
DT = OPT.DT; TM = OPT.TM
OPT.ORIG.SVC.ID = DVC$SERVICE; AI.STATUS = FALSE
OPT.COMM = HANDLER.COMMAND
LOCK.ITM = TRUE; LOCK.RELS = TRUE 
*21MAR94*
IF STAT THEN RETURN
*21MAR94*^
*
LOOP
GOSUB READ.COM.AI; * : @
LOCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LOCK.STAT AND LOCK.STAT NE 998 AND LOCK.ELP LE 60 DO REPEAT
*
IF LOCK.STAT EQ 998 THEN
MSG.P = "Transaction cancelled - Interface info missing! Enter <cr>: "
END ELSE
IF LOCK.STAT THEN
MSG.P = "Transaction cancelled - Interface locks error!! Again (Y/<cr>): "
END
IF LOCK.STAT THEN
GOSUB DISPLAY.PROMPT
IF RSP EQ "Y" THEN STAT = FALSE; GOTO WRITE.COMMAND
AI.STATUS = LOCK.STAT; STAT = 999
END
*
IF NOT(STAT) THEN
*
MAT COM.AIP = EMPTY
*
$INCLUDE IBP AI.LOAD.COM.AIP.TIERS
$INCLUDE IBP AI.LOAD.COM.AIP
*
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY
*
CALL AI.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,AI.CODE,AI.SRCE,"0")
IF AI.STATUS EQ 999 THEN STAT = AI.STATUS; RETURN
*
*21MAR94*END; * OF NOT STAT
*
* LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
* IF COM.AI$FUNC.PORT NE EMPTY THEN COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM
* COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:PORT.KEY
* END
* *
* MATWRITE COM.AI ON COM.FILE,COM.AI.ID
* *
* *
* LOCK.ITM = TRUE; LOCK.RELS = TRUE
* GOSUB READ.COM.AI.UNLOCK
*
*21MAR94*
END; * OF STAT
*
END; * OF LOCK.STAT 998
*
RETURN
!
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT CLB:"WAIT FOR COMMAND":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
$INCLUDE IBP AI.INTFC.WAITFOR.COMMAND
*
LOCATE ERR$NO.UNIT IN COM.AIP$ERR<ONE> SETTING TMP THEN
TMP = FIELD(AIX.ID,"*",2); * NO SUCH SERIAL NUMBER
MSG.P = TMP:MSG<26>; GOSUB DISPLAY.PROMPT
END
*
RETURN
!
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
COM.AI.NOT.ON.FILE = FALSE
HEADEND = FIELD(ADD$GEOGRAPHIC.DATA,"*",10)
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
VC = 1; HIT = 0
LOOP
AI.CODE = AI.TYPES<1,VC>
LOCATE HEADEND IN AI.TYPES<4,VC> SETTING LOC THEN HIT = 1 ELSE HIT = 0
UNTIL AI.CODE = "" OR HIT DO VC = VC+1 REPEAT
IF AI.CODE = "" AND NOT(HIT) THEN
COM.AI.NOT.ON.FILE = TRUE; DO.PROMPT = FALSE; MSG.P = "Addressable Interface not active for Headend: ":HEADEND; GOSUB DISPLAY.PROMPT
RETURN
* STAT WOULD OTHERWISE BE SET TO 998 ON COM.AI, COM.AIP READS
END
*
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
*
DVC.TYPE = DVC$TYPE
*
!
*
COM.AI.ID = "AI.TYPE.":AI.CODE
* LOCK.ITM = TRUE; LOCK.RELS = TRUE
SAVE.DISP.ONLY = DISP.ONLY; DISP.ONLY = FALSE
*
$INCLUDE IBP AI.READ.COM.AI
*
COMMPORT = COM.AI$COMMPORT; AI.TYPE = COM.AI.ID:VM:COM.AI$DB.PREFIX
!
*
LOCATE DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING DVC.LOC ELSE DVC.LOC = ONE
*
 EQUIP.TYPE = COM.AI$DB.PREFIX<ONE,DVC.LOC>
*
READ MSG FROM COM.FILE,"AI.TALKER.MSGS.":EQUIP.TYPE ELSE
PRINT CLB:"Can't find COM AI.TALKER.MSGS.":EQUIP.TYPE
STAT = 999
RETURN
END
*
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":EQUIP.TYPE ELSE MAT COM.AIIERR = EMPTY
*
*
DISP.ONLY = SAVE.DISP.ONLY
*
IF COM.AI$GENIE.WINDOW EQ "Y" THEN
COM.AI.ERR.DISP = TWO
ERR.CLB = FALSE
ERR.LN.MIN = TWO; ERR.LN.MAX = 9; ERR.LN.HI = ZERO
ERR.CL = 43; ERR.LEN = 36
ERR.DISP.ONLY = 3
END
*
RETURN
!
CHECK.HANDLER: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Check Handler":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
* $INCLUDE IBP AI.INTFC.CHECK
CALL AI.CHECK.HANDLER(LOCK.TYPE,LOCK.ITM,LOCK.RELS,LOCK.STAT,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,STAT)
*
IF COM.AI.ON THEN AI.TALK<OP.UP> = COM.AI.UP ELSE AI.TALK<OP.UP> = FALSE
* AI.TALK<OP.STAT> = AI.STATUS
AI.TALK<OP.STAT> = NOT(COM.AI.ON AND COM.AI.UP)
*
RETURN
*
!
WRITE.LOG: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Write Log":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
IF LOG.REQUIRED THEN
*INCLUDE IBP AI.LOG.WRITE
CALL AI.WRITE.LOG(COM.FILE,MAT COM.AIP,AI.CODE,AI.SRCE,LOCKS.FILE,LOCK.TYPE)
LOG.REQUIRED = FALSE
END
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INTFC.MESSAGES
*
RETURN
*
!
*
ERROR: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Error Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
*INCLUDE IBP SYS.INCL.ERROR
CALL SYS.SUBR.ERROR(TEXT,ERR.FMT,ERR.BELL,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,ERR.CL,ERR.LEN,ERR.CLS,ERR.HDR,ERR.CR,ERR.CLB,STAT)
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
!
*
RETURN
!
END
~BU1.AI.WRITE.COMMAND~
SUBROUTINE AI.WRITE.COMMAND(MAT AIW,AIW.ID,HANDLER.DOWN)
*
*      Write a command onto the port's work file record for transmission...
*
!
IF HANDLER.DOWN THEN RETURN
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP AIW.DIM
$INCLUDE IBP AIW.EQUATES
DIM SAVE.AIW(20)
!
OPEN "AIW" TO AIW.FILE ELSE PRINT @(0,23):CLL:"Can't open AIW":; INPUT RSP:; STOP
IF AIW.ID # "" THEN MATWRITE AIW ON AIW.FILE,AIW.ID; AIW.ID = AIW.ID+1; RETURN
LOOP UNTIL LEN(PORT) = 3 DO PORT = "0":PORT REPEAT
*
MAT SAVE.AIW = MAT AIW; RETRY = 0
READ FLAG FROM AIW.FILE,"FLAG" ELSE FLAG = "D"
IF FLAG<1> = "D" THEN
PRINT @(0,23):CLL:"The addressable interface handler is down -- press <cr>...":
INPUT RSP:; PRINT @(0,23):CLL:
HANDLER.DOWN = 1
RETURN
END
LOOP
MATREAD AIW FROM AIW.FILE,PORT ELSE MAT AIW = ""; AIW$FLAG = "Y"
UNTIL AIW$FLAG = "Y" DO
RETRY = RETRY+1
IF RETRY < 6 THEN
PRINT @(0,23):CLL:"Retry number ":RETRY:
RQM
PRINT @(0,23):CLL:
END ELSE
LOOP
PRINT @(0,23):CLL:"Prior command has not yet been sent to encoders -- wait longer? (Y/N) ":
INPUT RSP:; PRINT @(0,23):CLL:
UNTIL RSP = "Y" OR RSP = "N" DO
REPEAT
IF RSP = "Y" THEN RETRY = 0 ELSE
LOOP
PRINT @(0,23):CLL:"The prior command will be lost -- is this what you want? (Y/N) ":
INPUT RSP:; PRINT @(0,23):CLL:
UNTIL RSP = "Y" OR RSP = "N" DO
REPEAT
IF RSP = "Y" THEN AIW$FLAG = "Y"
RETRY = 0
END
END
REPEAT
MAT AIW = MAT SAVE.AIW
MATWRITE AIW ON AIW.FILE,PORT
PRINT @(0,23):CLL:"An addressable interface command has been submitted to the handler.":
READ FLAG FROM AIW.FILE,"FLAG" ELSE FLAG = "D"
IF FLAG<1> # "D" THEN
FLAG<1> = PORT
WRITE FLAG ON AIW.FILE,"FLAG"
END
*
RETURN
!
END
~CU.TMP~
X* 11JAN94 *  ERR.TEXT = "Enter <cr>, a ":ERR.TMP:" Port #, or N to cancel start-up: "
ERR.TEXT = "Start ":ERR.TMP:" on ":PORT.ON:". Enter N to cancel: "; * 11JAN94
* 11JAN94 * IF PORT.TYPE EQ ONE THEN PORT.ON = COM.AI$MONITOR.PORT ELSE PORT.ON = COM.AI$PORT
* 11JAN94 * IF RSP MATCHES "3N" THEN PORT.ON = RSP
~DOWNLOAD.PPV.EVENTS.PA~
*PROGRAM: DOWNLOAD.PPV.EVENTS.PA
* VERSION: 940326 1.1  CHANGE CH.CODE TO CH.NUM, ADD ENCODER GROUP & MEMBER
* PRIOR: 940208 1.0  NEW
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
* DESCRIPTION:  DOWNLOAD IPPV EVENTS TO PIONEER POC WITH THESE OPTIONS:
*               1) ALL EVENT DETAILS FOR ONE EVENT MASTER,
*               2)  "    "      "     "   "  CHANNEL,
*               3)  "    "      "     "  A PROGRAMMING MONTH
*               4)  "    "      "     "  ALL EVENT MASTERS & ALL CHANNELS,
*
* TEST MODE: CNT.TST$X WILL RUN WITHOUT INTEFACE BEING ON AN UP.
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
!
*
EQU VERSION TO "(1.1)"
VS = VERSION
SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"; SYS.PROG = "DOWNLOAD.PPV.EVENTS.PA"; SYS.LOCT = EMPTY
SYS.PRTN = EMPTY
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
***$INCLUDE IBP COM.RUN.DIM
***$INCLUDE IBP COM.RUN.EQUATES
DIM COM.RUN(40)
EQU COM.RUN$SDT.OK        TO COM.RUN(1)
EQU COM.RUN$SDT.CN        TO COM.RUN(2)
EQU COM.RUN$SDT.ERR.CN     TO COM.RUN(3)
EQU COM.RUN$SDT.ERR.CN.TOT TO COM.RUN(4)
EQU COM.RUN$SDT.ERR.PER    TO COM.RUN(5)
EQU COM.RUN$SDT.ERR.PER.MAX TO COM.RUN(6)
EQU COM.RUN$SDT.TEXT        TO COM.RUN(7)
EQU COM.RUN$AI.STATUS       TO COM.RUN(8)
EQU COM.RUN$SEND.STATUS     TO COM.RUN(9)
EQU COM.RUN$SDT.CN.PVM       TO COM.RUN(10)
EQU COM.RUN$SDT.SE.CN       TO COM.RUN(11)
EQU COM.RUN$SDT.PR.ID       TO COM.RUN(12)
EQU COM.RUN$SDT.SE.ID       TO COM.RUN(13)
EQU COM.RUN$CN.PVM      TO COM.RUN(14)
EQU COM.RUN$CN.ERR     TO COM.RUN(15)
EQU COM.RUN$CN.DETAIL  TO COM.RUN(16)
*DUPE** COM.RUN$CN.ERROR   TO COM.RUN(17)
EQU COM.RUN$CN.EVENT   TO COM.RUN(18)
EQU COM.RUN$CN.ERR.EVENT TO COM.RUN(19)
EQU COM.RUN$CN.VALID   TO COM.RUN(20)
EQU COM.RUN$UPL.DT     TO COM.RUN(21)
EQU COM.RUN$OVER       TO COM.RUN(22)
EQU COM.RUN$AI.ERROR   TO COM.RUN(23)
EQU COM.RUN$RSTAT      TO COM.RUN(25)
EQU COM.RUN$BEG.DT   TO COM.RUN(26)
EQU COM.RUN$BEG.TM   TO COM.RUN(26)
EQU COM.RUN$END.DT     TO COM.RUN(27)
EQU COM.RUN$END.TM     TO COM.RUN(28)
EQU COM.RUN$ELP.TM     TO COM.RUN(29)
EQU COM.RUN$DLE.DT     TO COM.RUN(30)
EQU COM.RUN$AUTO       TO COM.RUN(31)
EQU COM.RUN$CN.PVE     TO COM.RUN(32)
EQU COM.RUN$CN.TEST    TO COM.RUN(33)
EQU COM.RUN$PVM.ID     TO COM.RUN(34)
EQU COM.RUN$PVE.ID     TO COM.RUN(35)
EQU COM.RUN$DESC       TO COM.RUN(36)
*
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
*
EQU WKO$STAT TO COM.AIP(30)
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
!
*
INPUT AUTO.RUN:
*
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT CLB:"Can't open PVM":; INPUT TMP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:; STOP
* LCK.FILE = 0; * REV ONLY
*
!
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
END
*
*
IF NOT(AUTO.RUN) THEN
INPUT RUN.TYPE
END ELSE
RUN.TYPE = CURRENT.RUN<ONE,TWO>
END
*
$INCLUDE IBP AI.ERR.INIT
*
AI.TALK = EMPTY
DISP.ONLY = FALSE; MSG.DISP = FALSE; DO.PROMPT = TRUE
LCK.TYPE = -3; LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.STAT = FALSE
*@@*COM.AI.ERR.DISP = TRUE; *10APR94*
COM.AI.ERR.DISP = 2; *10APR94*
TRANS.NUM = ""
*
REDISP = FALSE; ERR.DISP.ONLY = 5
*@@*ERR.CL = 31; ERR.LN.MIN = 16; ERR.LN.HI = ZERO; ERR.LN.MAX = 20
ERR.CL = 49; ERR.LN.MIN = 16; ERR.LN.HI = ZERO; ERR.LN.MAX = 20
ERR.LEN = 30; ERR.HDR = "Addr. Intfc. Messages"
*@@*ERR.LEN = 49; ERR.HDR = "Addr. Intfc. Messages"
*
CHECK.LN.MIN = 16; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
*@@*OPER = ""; OPT.COMM = ""; CHECK.LEN = 35; CHECK.LN.HI = ZERO
OPER = ""; OPT.COMM = ""; CHECK.LEN = 48; CHECK.LN.HI = ZERO
* IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
COM.RUN$CN.ERR = 0; COM.RUN$PVM.ID =""; COM.RUN$SDT.CN.PVM = 0; CHAN.ALL = FALSE; OPERATOR = ""
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "D"; LOG.REQUIRED = FALSE; DVC.LOC = ONE
AI.STATUS = EMPTY; SEND.STATUS = EMPTY
RUN.CODE = EMPTY
COM.RUN.ID = "LAST.PPV.DOWNLOAD"
MATREAD COM.RUN FROM COM.FILE,COM.RUN.ID ELSE
MAT COM.RUN = EMPTY
END
MAT COM.AI = EMPTY; COM.AI.ID = EMPTY
MAT COM.AIP = EMPTY; COM.AIP.ID = EMPTY
LPDL = EMPTY; LPDL.ID = EMPTY
PORTS.LIST.BUILD = 8
*
!
*
GOSUB LOAD.TST; * : *
IF AUTO.RUN THEN CNT.TST$CR = FALSE
IF CNT.TST$ON THEN VS = VERSION:" **** TEST MODE ****"
FAST.DISPLAY = FALSE; PORTS.LIST.BUILD = 9; AI.SCAN = TRUE
*
MAT PVE = EMPTY; PVE.ID = EMPTY
MAT PVM = EMPTY; PVM.ID = EMPTY
MAT COM.AI = EMPTY; COM.AI.ID = EMPTY
MAT COM.AIP = EMPTY; COM.AIP.ID = EMPTY
*
*
*
IF CNT.TST$RTN THEN PRINT @(60,20):"DOWNLOAD.PPV.EVENTS.PA" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.NAME = "Unknown"
CO.NAME = CO.DATA<1>
*
COM.RUN$OVER = FALSE; COM.RUN$CN.DETAIL = 0; COM.RUN$CN.ERR = 0; COM.RUN$CN.EVENT = 0; COM.RUN$CN.ERR.EVENT = 0
*
COM.RUN$CN.VALID = 0; UPLOAD.DATE = DATE()
*
*9606*DGH*PRINT @(0,0):CLS:
TITLE = "Download Impulse PPV Event":VS
LN = TWO; LN.HI = 15
PG = ZERO
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
IF CNT.TST$X THEN
PRINT @(18,TWO):"*** TEST MODE - Interface will be bypassed ***"; LN = LN + TWO
END ELSE
PRINT @(ZERO,TWO):CLL:"Downloading thru the Interface.":
END
*
!
*
GET.INPUT: *
*
LN = 3
CH.NUM = ""; AI.CODE = EMPTY; EVENT.ID = EMPTY; CH.CODE = EMPTY; PERIOD = EMPTY
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
IF NOT(COUNT(AI.TYPES<1>,VM)) THEN AI.CODE = AI.TYPES<1> ELSE AI.CODE = ""
*
LOOP
* IF AI.CODE = "" THEN PRINT @(0,LN):CLL:"Enter the Addressable Interface Code: ":
PRINT @(ZERO,LN):CLL:"Addressable Interface Code: ":
IF NOT(AUTO.RUN) THEN
IF AI.CODE EQ EMPTY THEN
INPUT AI.CODE:
END ELSE PRINT AI.CODE:
END ELSE
AI.CODE = CURRENT.RUN<ONE,3>
PRINT AI.CODE:
END
IF AI.CODE = "KILL" THEN GOTO FINISH
LCK.ITM = FALSE; LCK.RELS = TRUE
GOSUB READ.COM.AI; * : *
IF NOT(COM.AI.ON.FILE) THEN 
AI.CODE = ""
COM.RUN$SDT.TEXT = "That Addressable Interface has not been defined."
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>...  ":
INPUT TMP:; PRINT CLB:
END
END
UNTIL AI.CODE NE "" DO 
IF AUTO.RUN THEN GOTO FINISH
COM.RUN$SDT.TEXT = "Enter an Interface Name here!"
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
REPEAT
*
!
*
COM.RUN$CN.TEST = ZERO
LOOP
COM.RUN$CN.TEST = COM.RUN$CN.TEST + ONE
LCK.ITM = TRUE; LCK.RELS = TRUE
COM.RUN$AI.ERROR = EMPTY
*
GOSUB READ.COM.AI; * : *
*
GOSUB INTFC.CHECK; * : *
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES; * : *
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; TEXT = EMPTY; * : *
*
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
COM.RUN$SDT.TEXT = "The interface is not useable!"
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>... ":
INPUT TMP:
END ELSE
IF COM.RUN$CN.TEST GT 10 THEN TMP = "KILL" ELSE TMP = EMPTY
END
IF TMP EQ "KILL" THEN GOTO FINISH
END
WHILE NOT(COM.AI.ON AND COM.AI.UP) DO
IF AUTO.RUN THEN
*9606*DGH*GOTO FINISH
EXEC.OUT = EMPTY
EXECUTE "SLEEP 60", //OUT. > EXEC.OUT
* CHECK ELP
END
REPEAT
*
IF AI.ERROR THEN COM.RUN$AI.ERROR = AI.ERROR
IF AI.ERROR AND NOT(CNT.TST$X) THEN
PRINT @(ZERO,LN + ONE):"The AI is ":COM.AI$ON.OFF.STAT:" and ":COM.AI$UP.DN.STAT:"  Do want to try another AI? (Y/<cr>): ":
IF NOT(AUTO.RUN) THEN
INPUT RESP:
END ELSE
RESP = KILL
END
AI.ERROR = 0
IF RESP = "Y" THEN PRINT @(0,LN):CLL:; RESP = ""; AI.CODE = ""; GOTO GET.INPUT; * : *
GOTO FINISH
END
* PRINT @(ZERO,LN + ONE):CLL:
*
LCK.ITM = FALSE; LCK.RELS = FALSE
AI.DVC.NEXT.CN = ONE
COMMPORT = COM.AI$COMMPORT; COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
*
LOCATE AI.CODE IN AI.TYPES<1> BY "AL" SETTING LOC THEN AI.DESC = AI.TYPES<2,LOC>
PRINT @(ZERO,LN + ONE):AI.DESC:
READ LPDL FROM COM.FILE,COM.RUN.ID:".DATE.":AI.CODE ELSE LPDL = ""
LDPL.LINE = EMPTY
READ CH.CODES FROM COM.FILE,"PPV.CHANNELS.":AI.CODE ELSE CH.CODES = ""
* BEGIN CASE
RUN.LIT  = ' WITH AI.CODE = "':AI.CODE:'" '; SEQ.LIT = ""
*
LN = LN + TWO
* BEGIN CASE
IF RUN.TYPE = 1 THEN
LOOP
PRINT @(ZERO,LN):"Enter the Master Event Code: ":
IF NOT(AUTO.RUN) THEN
INPUT EVENT.ID:
END ELSE
EVENT.ID = CURRENT.RUN<ONE,4>
PRINT EVENT.ID:
END
IF EVENT.ID = "KILL" THEN GOTO FINISH
READV TMP FROM PVM.FILE,EVENT.ID,2 ELSE EVENT.ID = ""
UNTIL EVENT.ID NE EMPTY DO
PRINT BELL:
IF AUTO.RUN THEN GOTO FINISH
REPEAT
PRINT @(40,LN):TMP:
RUN.EVENT.DESC = TMP
RUN.NAME = " for the Event ":EVENT.ID:" - ":TMP
RUN.LIT  = RUN.LIT:'AND WITH EVENT.ID = "':EVENT.ID:'"'
RUN.CODE = EVENT.ID
LN = LN + ONE
*
END ELSE
!
LOOP
VALID = TRUE
PRINT @(ZERO,LN):"Enter the Program Period (YYMM): ":
IF NOT(AUTO.RUN) THEN
INPUT PERIOD:
END ELSE
PERIOD = CURRENT.RUN<ONE,6>
PRINT PERIOD:
END
IF PERIOD = "KILL" THEN GOTO FINISH
YEAR = PERIOD[1,2]; MONTH = PERIOD[3,2]
IF MONTH LT "01" OR MONTH GT "12" THEN VALID = FALSE
IF NOT(NUM(YEAR)) THEN VALID = FALSE
UNTIL VALID DO
PRINT BELL:
IF AUTO.RUN THEN GOTO FINISH
REPEAT
RUN.NAME = ' for the Period ':PERIOD
RUN.LIT  = RUN.LIT:'AND WITH PROGMO = "':PERIOD:'"'
RUN.CODE = PERIOD
LN = LN + 1
END
*
IF RUN.TYPE = 2 THEN
LOOP
PRINT @(ZERO,LN):"Enter the Channel Number: ":
IF NOT(AUTO.RUN) THEN
INPUT CH.NUM:
END ELSE
CH.NUM = CURRENT.RUN<ONE,5>
PRINT CH.NUM:
END
IF CH.NUM = "KILL" THEN GOTO FINISH
LOCATE CH.NUM IN CH.CODES<1> BY "AL" SETTING LOC ELSE CH.NUM = ""
UNTIL CH.NUM NE EMPTY DO
PRINT BELL:
IF AUTO.RUN THEN GOTO FINISH
REPEAT
CH.DESC = CH.CODES<2,LOC>
CH.CODE = CH.CODES<3,LOC>
CH.ENCODER.GROUP = CH.CODES<4,LOC>
CH.ENCODER.MEMBER = CH.CODES<5,LOC>
PRINT @(ZERO,LN + ONE):CH.DESC:"   for encoder: ":CH.ENCODER.GROUP:":":CH.ENCODER.MEMBER:
RUN.NAME = " for the Channel Code ":CH.NUM:" - ":CH.DESC:RUN.NAME
RUN.LIT  = RUN.LIT:' AND WITH CH.NUM = "':CH.NUM:'"'
RUN.CODE = CH.NUM
LN = LN + 1
END
*
IF RUN.TYPE = 3 THEN
*
IF RUN.TYPE = 4 THEN
RUN.NAME = ' for ALL Channels':RUN.NAME
SEQ.LIT = 'BY CH.NUM '
RUN.CODE = "All"
*
END
*
END
*
RUN.LIT  = RUN.LIT:' AND WITH DOWNLOADED NE "Y"'
SEQ.LIT = SEQ.LIT:'BY PVM.ID BY DT BY TM'
*
COM.RUN$DLE.DT = DATE()
LN = LN + TWO
LN.SAVE = LN; LN.HI = 15
IF LN.SAVE + 5 GT LN.HI THEN LN.SAVE = LN.HI - 5
*9606*DGH*IF LN + 5 GT LN.HI THEN LN.HI = 21
*
IF COM.RUN$DLE.DT EQ LPDL<1,1> THEN
*
CLS.COL = ZERO; CLS.ROW = 13; GOSUB CLS.ROUTINE; * : *
LN = LN.SAVE
DL.VC = 1; DL.SVC = 1
PRINT @(5,LN):"Downloaded    Start   Elapsed    Event     Event     Event    Dnld":; LN = LN + ONE
PRINT @(5,LN):" Dld Date      Time     Time    Masters   Details    Errors   Type":; LN = LN + ONE
*
*9606*DGH*LOOP DL.TIME = LPDL<2,DL.VC,DL.SVC> UNTIL DL.TIME = "" OR LN = 21 DO
LOOP DL.TIME = LPDL<2,DL.VC,DL.SVC> UNTIL DL.TIME = "" OR LN GE LH.HI DO
PRINT @(5,LN):OCONV(LPDL<1,DL.VC,DL.SVC>,"D2") "R#9":
PRINT @(15,LN):OCONV(LPDL<2,DL.VC,DL.SVC>,"MTS") "R#11":
PRINT @(26,LN):OCONV(LPDL<3,DL.VC,DL.SVC>,"MT") "R#7":
PRINT @(33,LN):LPDL<4,DL.VC,DL.SVC> "R#10":
PRINT @(43,LN):LPDL<5,DL.VC,DL.SVC> "R#10":
PRINT @(53,LN):LPDL<6,DL.VC,DL.SVC> "R#10":
PRINT @(60,LN):LPDL<7,DL.VC,DL.SVC> "R#7":
DL.SVC = DL.SVC + ONE; LN = LN + ONE
REPEAT
*
END
*
!
*
INPUTS = RUN.TYPE:VM:AI.CODE:VM:EVENT.ID:VM:CH.NUM:VM:PERIOD
AUTO.DESC = "Dnld PPV"
IF CH.NUM NE EMPTY   THEN AUTO.DESC = AUTO.DESC:" c":CH.NUM
IF EVENT.ID NE EMPTY THEN AUTO.DESC = AUTO.DESC:" e":EVENT.ID
IF PERIOD NE EMPTY   THEN AUTO.DESC = AUTO.DESC:" p":PERIOD
COM.RUN$AUTO = INPUTS
COM.RUN$DESC = AUTO.DESC
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("DOWNLOAD.PPV.EVENTS.PA",INPUTS,AUTO.DESC)
IF AUTO.RUN THEN LCK.TYPE = -8
*
LN = LN.SAVE
EXLN = 'SSELECT PVE ':SEQ.LIT:RUN.LIT
PRINT @(0,LN):CLL:EXLN:
* EXECUTE EXLN; * REV ONLY
* ULT ONLY
EXECUTE EXLN, //SELECT. > PVE.ID.LIST
*
!
*
START: *
*
*9606*DGH*EV.LN = 7
*9606*DGH*EV.LN = LN.SAVE
*9606*DGH*IF EV.LN GE 12 THEN EV.LN = 7
EV.LN = LN.HI + ONE
IF CNT.TST$LBL THEN PRINT CLB:"Start" "L#19":; IF CNT.TST$CR THEN PRINT " Enter <cr> :":; INPUT TMP:
*
COM.RUN$BEG.DT = DATE(); COM.RUN$BEG.TM = TIME(); * EV.LN = EV.LN + TWO
SEND.STATUS = EMPTY; COM.RUN$SDT.CN = ZERO; COM.RUN$SDT.ERR.CN = ZERO
COM.RUN$SDT.ERR.CN.TOT = ZERO; COM.RUN$SDT.ERR.CN.MAX = 50; COM.RUN$SDT.ERR.PER.MAX = 5
COM.RUN$CN.TEST = ZERO
COM.RUN$CN.PVE = ZERO
*
LOOP
COM.RUN$CN.TEST = COM.RUN$CN.TEST + ONE
LCK.ITM = TRUE; LCK.RELS = TRUE
*
GOSUB READ.COM.AI; * : *
*
GOSUB INTFC.CHECK; * : *
IF LEN(OUTPUTS) THEN TEXT<-ONE> = OUTPUTS
GOSUB INTFC.MESSAGES; * : *
ERR.BELL = FALSE; GOSUB ERROR; ERR.BELL = TRUE; TEXT = EMPTY; * : *
*
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
COM.RUN$SDT.TEXT = "The interface is not useable!"
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
IF NOT(AUTO.RUN) THEN
PRINT BELL:" Enter <cr>...  ":
INPUT TMP:
IF TMP EQ "KILL" THEN COM.RUN$OVER = TRUE
END ELSE
IF COM.RUN$CN.TEST LT 10 THEN
EXEC.OUT = EMPTY
EXECUTE "SLEEP (60)", //OUT. > EXEC.OUT
END ELSE
GOTO FINISH
END
END
END
WHILE NOT(COM.AI.ON AND COM.AI.UP) AND NOT(COM.RUN$OVER) DO REPEAT
*
IF NOT(AUTO.RUN) THEN
LOOP
COM.RUN$SDT.TEXT = "Enter <cr> to proceed or 'KILL' to end: "
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
INPUT RESP:
IF RESP = "KILL" THEN GOTO FINISH
UNTIL RESP = "" DO PRINT BELL: REPEAT
END ELSE
PRINT @(ZERO,LN.SAVE):CLL:"Proceeding with DOWNLOAD!!!":BELL:
* PRINT @(0,10):CLS:
END
*
CLS.COL = ZERO; CLS.ROW = 13; GOSUB CLS.ROUTINE; * : *
LOG.REQUIRED = FALSE
SEND.STATUS = EMPTY
*
!
*
NEXT.EVENT: *
*
READNEXT PVE.ID FROM PVE.ID.LIST ELSE COM.RUN$OVER = 1
IF COM.RUN$OVER THEN
COM.RUN$SDT.TEXT = "Done!!!    "
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
GOTO FINISH; * : *
END ELSE
COM.RUN$PVE.ID = PVE.ID
*
COM.RUN$CN.PVE = COM.RUN$CN.PVE + ONE
IF AI.STATUS LT 100 OR AI.STATUS GE 600 THEN AI.STATUS = FALSE
SEND.STATUS = EMPTY
*
* ACCEPT KEYBOARD INPUT
IF SYSTEM(11) THEN
COM.RUN$SDT.TEXT = "Enter (S)top or <cr> to continue: "
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
INPUT TMP:
PRINT CLB:; IF TMP = "S" THEN COM.RUN$OVER = TRUE
RSP = EMPTY; ERROR.IND = "O"
RSP = OCONV(RSP,"U51EA")
END
*
IF NOT(COM.RUN$OVER) THEN
*
PRINT @(ZERO,LN.SAVE + TWO):RVB:" ":RVE:"Event Id: ":PVE.ID "L#10":
IF CNT.TST$ID AND CNT.TST$CR THEN PRINT " Enter <cr>... ":; INPUT TMP:
*
TMP.TYPE = LCK.TYPE
LOOP
* LCK.TYPE = -3
CALL SYS.ITM.LCK("PVE",PVE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
WHILE LCK.STAT DO 
IF SYSTEM(11) THEN TMP.TYPE = ZERO
REPEAT
*
MATREAD PVE FROM PVE.FILE,PVE.ID THEN
*
IF PVE$PVM.ID NE COM.RUN$PVM.ID THEN
COM.RUN$SDT.CN.PVM = COM.RUN$SDT.CN.PVM + ONE
MATREAD PVM FROM PVM.FILE,PVE$PVM.ID ELSE MAT PVM = ""
EVENT.DESC = PVM$DESC
EV.LN = EV.LN + TWO
*9606*DGH*IF EV.LN GT LN.HI THEN EV.LN = LN.SAVE
IF EV.LN GT LN.HI THEN EV.LN = 3
*9606*DGH*PRINT @(5,10):CLL:"Master # :":COM.RUN$SDT.CN.PVM "R#3":"  ":PVE$PVM.ID:" ":EVENT.DESC:
PRINT @(ZERO,LN.SAVE + ONE):RVB:" ":RVE:("Master Event # :":COM.RUN$SDT.CN.PVM "R#3":"  ":PVE$PVM.ID:" ":EVENT.DESC) "L#38":RVB:" ":RVE:
PRINT @(40,EV.LN):RVB:" ":RVE:("Master Event # :":COM.RUN$SDT.CN.PVM "R#3":"  ":PVE$PVM.ID:" ":EVENT.DESC) "L#38":RVB:" ":RVE:
PRINT @(40,EV.LN + ONE):RVB:" ":RVE:("Event Details Downloaded: ":COM.RUN$CN.DETAIL "R#4") "L#38":RVB:" ":RVE:
COM.RUN$PVM.ID = PVE$PVM.ID
COM.RUN$SDT.PR.ID = COM.RUN$PVM.ID
CH.NUM = PVM$CH.CODE
LOCATE CH.NUM IN CH.CODES<1> BY "AL" SETTING LOC ELSE CH.NUM = ""
CH.DESC = CH.CODES<2,LOC>
CH.CODE = CH.CODES<3,LOC>
CH.ENCODER.GROUP = CH.CODES<4,LOC>
CH.ENCODER.MEMBER = CH.CODES<5,LOC>
END
*
*
*
MAT COM.AIP = EMPTY
IF CNT.TST$X THEN
MATREAD COM.AIP FROM COM.FILE,COM.AIP.ID ELSE MAT COM.AIP = ""
END
TRANS.TYPE = "DLE"; OPT.COMM<ONE> = TRANS.TYPE; HANDLER.COMMAND = OPT.COMM<ONE>
OPT.PORT = PORT.KEY; OPT.DT = DATE(); OPT.TM = TIME(); AI.TALK = ""
COM.AIP$INTFC.STAT = ""; PPV.CONTROL.FLAGS = "02"
COM.AIP$ERR = ""; COM.AIP$INTFC.ERR = ""
* 00000100 = enable PPV channel
* 0 - reserved
*  0 - disable tier linked PPV
*   0 - disable scramble/standy control with PPV
*    0 - (n/a) cyclic PPV type
*     0 - disable cyclic PPV indicator
*      0 - enable PPV channel
*       1 - disable/change PPV encoder code
*        0 - disable change encoder tag value
*
$INCLUDE IBP AI.LOAD.COM.AIP
*
COM.AIP$DVC.ID       = ""
COM.AIP$SVC.FUNC    = "DLE"
COM.AIP$DVC.TYPE    = AI.CODE
COM.AIP$SVC.EXTR    = PPV.CONTROL.FLAGS
DISP.EVENT          = FIELD(PVE.ID,"*",2)
COM.AIP$EVENT       = DISP.EVENT
COM.AIP$EVENT.CH    = PVE$CH.CODE
COM.AIP$EVENT.DT    = PVE$DT
COM.AIP$EVENT.TM    = PVE$TM
COM.AIP$EVENT.DUR   = PVE$DUR
COM.AIP$WKO.SCH.DT  = CH.ENCODER.GROUP
COM.AIP$WKO.SCH.TM  = CH.ENCODER.MEMBER
*
IF CNT.TST$ID THEN
COM.RUN$SDT.TEXT = "COM.AIP is loaded for Event ":DISP.EVENT
PRINT CLB:COM.RUN$SDT.TEXT:
IF CNT.TST$Y THEN PRINT "Enter <cr>...  ":; INPUT TMP:
END
AI.DVC.NEXT.CN = ONE
COMMPORT = COM.AI$COMMPORT; COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
COM.RUN$SDT.CN = COM.RUN$SDT.CN + ONE
SEND.STATUS = EMPTY
GOSUB WRITE.COMMAND; * : *
*
**IF (AI.STATUS LT 100 OR AI.STATUS GE 600) OR NOT(SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
COM.AI.ERR.DISP = 2; PORTS.LIST.BUILD = 9
WF.C.FUNC = PORT.KEY; STAT = 0; GOSUB WAITFOR.COMMAND; * : *
**END
*
*** IF NOT(AI.STATUS) THEN
* PRINT CLB:"HELLO":; INPUT TMP
*
* TMP.TYPE = LCK.TYPE
* LOOP
* LCK.TYPE = -3
* CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","B","",LCK.STAT)
* WHILE LCK.STAT DO
* IF SYSTEM(11) THEN TMP.TYPE = ZERO
* REPEAT
TMP.STAT = 0
*
$INCLUDE IBP AI.INCL.UPDT.COM.AIP
*
**CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","C","",LCK.STAT)
*
IF COM.AI$LOGGING EQ "Y" THEN LOG.REQUIRED = 85001
IF AI.STATUS THEN LOG.REQUIRED = 86002
IF NOT(COM.AI.ON AND COM.AI.UP) THEN LOG.REQUIRED = 86003
IF LOG.REQUIRED THEN
CALL AI.SUBR.WRITE.LOG(COM.FILE,MAT COM.AIP,COM.AIP.ID,AI.CODE,AI.SRCE,LOG.REQUIRED,HANDLER.COMMAND,LCK.FILE,LCK.TYPE,SYS.PROG,STAT)
LOG.REQUIRED = FALSE
END
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
COM.RUN$SDT.OK = TRUE
END ELSE COM.RUN$SDT.OK = FALSE
*
*** END; * OF NOT(AI.STATUS))
*
END ELSE COM.RUN$SDT.OK = FALSE; * OF MATREAD
*
PVE$DLL.ERR = COM.AIP$INTFC.ERR
*
END ELSE COM.RUN$SDT.OK = FALSE; * COM.RUN$OVER
*
*** IF NOT(AI.STATUS) THEN
* IF AI.STATUS LT 100 THEN
IF AI.STATUS LT 100 AND (NOT(SEND.STATUS) OR SEND.STATUS EQ ERR$CHECK.TOUT) THEN
*
COM.RUN$SDT.ERR.CN = ZERO
* PVE$DLL.ERR = ""
PVE$DOWNLOADED = "Y"; COM.RUN$CN.DETAIL = COM.RUN$CN.DETAIL + ONE
*9606*DGH*PRINT @(40,EV.LN + ONE):RVB:" ":RVE:("Event Details Downloaded: ":COM.RUN$CN.DETAIL "R#4") "L#38":RVB:" ":RVE:
*9606*DGH*EV.LN = EV.LN + TWO
*9606*DGH*IF EV.LN GT LN.HI THEN EV.N = 3
*9606*DGH*PRINT @(ZERO,LN.SAVE + 3):RVB:" ":RVE:("Event Details Downloaded: ":COM.RUN$CN.DETAIL "R#4") "L#37":RVB:" ":RVE:
PRINT @(ZERO,LN.SAVE + 5):RVB:" ":RVE:("Downloaded: ":COM.RUN$CN.DETAIL "R#4") "L#18":
IF CNT.TST$ID THEN
COM.RUN$SDT.TEXT = "Completed download of Event ":DISP.EVENT
PRINT CLB:COM.RUN$SDT.TEXT:
IF CNT.TST$Y THEN PRINT "Enter <cr>...  ":; INPUT TMP:
END
*
END ELSE
*
COM.RUN$SDT.ERR.CN = COM.RUN$SDT.ERR.CN + ONE
COM.RUN$SDT.ERR.CN.TOT = COM.RUN$SDT.ERR.CN.TOT + ONE
COM.RUN$CN.ERR = COM.RUN$CN.ERR + ONE
COM.RUN$SDT.ERR.PER = INT(COM.RUN$SDT.ERR.CN.TOT / COM.RUN$SDT.CN * 100)
PRINT @(ZERO,LN.SAVE + 4):COM.RUN$SDT.ERR.CN:" errors in a row, at ":COM.RUN$SDT.ERR.PER:"% (":AI.STATUS:").":
*
*9606*DGH*IF COM.RUN$SDT.ERR.CN.TOT GT COM.RUN$SDT.ERR.CN.MAX OR (COM.RUN$SDT.ERR.PER GT COM.RUN$SDT.ERR.PER.MAX AND COM.RUN$SDT.ERR.CN.TOT GT 5) OR (COM.RUN$SDT.ERR.CN GT 10) THEN
IF COM.RUN$SDT.ERR.CN GT COM.RUN$SDT.ERR.CN.MAX OR (COM.RUN$SDT.ERR.PER GT COM.RUN$SDT.ERR.PER.MAX AND COM.RUN$SDT.ERR.CN GT 5) THEN
COM.RUN$SDT.TEXT = "Too many errors (":COM.RUN$SDT.ERR.CN.TOT:")! Stopping the download."
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>...  ":
INPUT TMP:
END
COM.RUN$OVER = TRUE
END
*
COM.RUN$SDT.TEXT = "Error (":AI.STATUS:",":SEND.STATUS:") on download of Event: ":DISP.EVENT
PRINT CLB:COM.RUN$SDT.TEXT:
PRINT @(ZERO,LN.SAVE + 4):COM.RUN$SDT.TEXT "L#40":
IF CNT.TST$ID THEN
IF CNT.TST$Y THEN PRINT "Enter <cr>...  ":; INPUT TMP:
END
IF CNT.TST$LBL THEN
COM.RUN$SDT.TEXT = ("Handler Send Error: ":COM.AIP$INTFC.ERR) "L#30"
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:
END
*
END
*
*
MATWRITE PVE ON PVE.FILE,PVE.ID
*
CALL SYS.ITM.RLS("PVE",PVE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","D","",LCK.STAT)
*
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
COM.RUN$SDT.TEXT = "The Handler is down. Stopping the download."
PRINT CLB:COM.RUN$SDT.TEXT:BELL:
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>...  ":
INPUT TMP:
END
COM.RUN$OVER = TRUE
END
*
COM.RUN$AI.STATUS = AI.STATUS
COM.RUN$SEND.STATUS = SEND.STATUS
*
MATWRITE COM.RUN ON COM.FILE,COM.RUN.ID
*
GOTO NEXT.EVENT; * : *
*
END; * OF NOT(COM.RUN$OVER)
*
!
*
FINISH: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Finish" "L#19":; IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:
*
COM.RUN$AI.STATUS = AI.STATUS
COM.RUN$SEND.STATUS = SEND.STATUS
*
**MATWRITE COM.RUN ON COM.FILE,COM.RUN.ID
*
COM.RUN$END.DT = DATE(); COM.RUN$END.TM = TIME()
COM.RUN$ELP.TM = ((COM.RUN$END.DT - COM.RUN$BEG.DT) * 86400) + (COM.RUN$END.TM - COM.RUN$BEG.TM)
*
IF COM.RUN$CN.DETAIL GT 0 THEN
LOCATE COM.RUN$DLE.DT IN LPDL<1> BY "DL" SETTING VC ELSE
INS COM.RUN$DLE.DT BEFORE LPDL<1,VC>
INS ""            BEFORE LPDL<2,VC>
INS ""            BEFORE LPDL<3,VC>
INS ""            BEFORE LPDL<4,VC>
INS ""            BEFORE LPDL<5,VC>
INS ""            BEFORE LPDL<6,VC>
INS ""            BEFORE LPDL<7,VC>
END
LOCATE COM.RUN$BEG.TM IN LPDL<1,VC> BY "DL" SETTING SVC ELSE
INS COM.RUN$BEG.TM      BEFORE LPDL<2,VC,SVC>
INS COM.RUN$ELP.TM         BEFORE LPDL<3,VC,SVC>
INS COM.RUN$SDT.CN.PVM    BEFORE LPDL<4,VC,SVC>
INS COM.RUN$CN.DETAIL    BEFORE LPDL<5,VC,SVC>
INS COM.RUN$CN.ERR     BEFORE LPDL<6,VC,SVC>
INS RUN.CODE      BEFORE LPDL<7,VC,SVC>
END
LPDL.LINE = COM.RUN$DLE.DT:VM:COM.RUN$BEG.TM:VM:COM.RUN$ELP.TM:VM:COM.RUN$SDT.CN.PVM:VM:COM.RUN$CN.DETAIL:VM:COM.RUN$CN.ERR:VM:RUN.CODE
COM.RUN$RSTAT = LPDL.LINE
END
*
LOOP
TMP = DCOUNT(LPDL<1>,VM)
WHILE TMP GT 25 DO
DEL LPDL<1,TMP>
DEL LPDL<2,TMP>
DEL LPDL<3,TMP>
DEL LPDL<4,TMP>
DEL LPDL<5,TMP>
DEL LPDL<6,TMP>
DEL LPDL<7,TMP>
REPEAT
*
WRITE LPDL ON COM.FILE,COM.RUN.ID:".DATE.":AI.CODE
MATWRITE COM.RUN ON COM.FILE,COM.RUN.ID
*
STOP
*
!
*
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai" "L#19":
IF CNT.TST$CR THEN PRINT "Enter <cr>...  ":; INPUT TMP:
*
COM.AI.ID = "AI.TYPE.":AI.CODE
*
$INCLUDE IBP AI.READ.COM.AI
*
IF NOT(COM.AI$ON.OFF = "ON" AND COM.AI$UP.DN.STAT = "UP") THEN
AI.ERROR = 1
COM.RUN$AI.ERROR = 1
END ELSE AI.ERROR = 0
*
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE MAT COM.AIIERR = EMPTY
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
RETURN
*
!
*
WRITE.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Write Command":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*
* @@@ COM.AIP REC LOAD
*
DT = DATE(); TM = TIME(); HEADEND = ""
LCK.ITM = TRUE; LCK.RELS = TRUE; STAT = ZERO
TMP.TYPE = LCK.TYPE
*
LOOP
GOSUB READ.COM.AI; * : *
LCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND LCK.STAT NE 998 AND LCK.ELP LE 60 DO
IF SYSTEM(11) THEN LCK.TYPE = ZERO
REPEAT
LCK.TYPE = TMP.TYPE
*
IF LCK.STAT EQ 998 THEN
MSG.P = "Transaction cancelled - Interface info missing! Enter <cr>: "
END ELSE
IF LCK.STAT THEN
MSG.P = "Transaction cancelled - Interface locks error!! Again (Y/<cr>): "
END
END
IF LCK.STAT THEN
GOSUB DISPLAY.PROMPT; * : *
IF RSP EQ "Y" THEN STAT = FALSE; GOTO WRITE.COMMAND; * : *
AI.STATUS = LCK.STAT; STAT = 999
END
*
IF NOT(STAT) THEN
*
*
*
CALL AI.SUBR.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,1,SYS.PROG,STAT)
*
END; * OF NOT STAT
*
* LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
* COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:PORT.KEY
* END
* *
* MATWRITE COM.AI ON COM.FILE,COM.AI.ID
* *
* LCK.ITM = TRUE; LCK.RELS = TRUE
* GOSUB READ.COM.AI.UNLOCK; * : *
*
RETURN
!
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT CLB:"WAIT FOR COMMAND":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*INCLUDE IBP AI.INCL.WAITFOR.COMMAND
CALL AI.SUBR.WAITFOR.COMMAND(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
*
RETURN
!
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT CLB:RVB:"Message Display":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
DISPLAY.PROMPT: * DISPLAY MSG AND PROMPT 'ENTER <cr>' IF DO.PROMPT
LOOP
PRINT CLB:MSG.P:; IF DO.PROMPT THEN INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
MSG.P = ""; DO.PROMPT = 1
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
!
END
~GEN.PPV.EVENT.DETAILS.PA~
*PROGRAM: GEN.PPV.EVENT.DETAILS.PA
* VERSION: 950509 1.2  ADDED UPDATE OF PVE PURGE.DT FROM PVM PURGE.DT.
* PRIOR: 940218 1.1  ADDED AI.CODE PREFIX TO PVE.ID.
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
* DESCRIPTION:  GENERATE PVE FILE ITEMS FROM THE PVM.
*               FOR TESTING USE ONLY. EVENT NUMS WERE ENTERED RATHER
*               THAN ASSIGNED.
*
*
*             CNT.TST$Z WILL NOT WRITE PVE RECORDS
!
*
VERSION = " (1.2)"; VS = VERSION
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
!
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT CLB:"Can't open PVM":; INPUT TMP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:; STOP
* LCK.FILE = 0; * REV ONLY
!
*
LCK.TYPE = -3; LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.STAT = FALSE
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY; LCK.ID = EMPTY
LCK.CLASS = EMPTY
LCK.RSRV = EMPTY
OPER = EMPTY; EXP.TM = EMPTY
TMPA = EMPTY; TMPB = EMPTY; TMPC = EMPTY
START.NUM = EMPTY; TMP.EVENT.NUM = EMPTY 
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "A"
*
GOSUB LOAD.TST
IF CNT.TST$ON THEN VERSION = VERSION:" **** TEST MODE ****"
*
*
IF CNT.TST$RTN THEN PRINT CLB:"GEN.PPV.EVENT.DETAILS.PA":; IF CNT.TST$CR THEN INPUT TMP:
PRINT CLB:
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = "Unknown"
*
OVER = FALSE; UPLOADED.CTR = 0; ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
*
VALID.CTR = 0; UPLOAD.DATE = DATE()
*
PRINT @(0,0):CLS:
TITLE = "Generate PPV Event Details":VERSION
$INCLUDE IBP DISPLAY.SCREEN.HEADER
LN = 4; SAVE.LN = 0
*
*
IF CNT.TST$Z THEN
PRINT @(0,LN):"Write of PVE records will be bypassed.":; LN = LN+1
END
*
!
GET.INPUT: *
LN = LN+1
GET.LN = LN
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
IF NOT(COUNT(AI.TYPES<1>,VM)) THEN AI.CODE = AI.TYPES<1>; AI.DESC = AI.TYPES<2> ELSE AI.CODE = ""
*
IF AI.CODE = "" THEN
LOOP
PRINT @(0,LN):CLL:"Enter the Addressable Interface Code: ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP ELSE IF AI.CODE = "" THEN STOP
LOCATE AI.CODE IN AI.TYPES<1> BY "AL" SETTING LOC THEN AI.DESC = AI.TYPES<2,LOC> ELSE
AI.CODE = ""
PRINT CLB:"That Addressable Interface has not been defined. Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
UNTIL AI.CODE NE "" DO REPEAT
END
LN = LN+1
PRINT @(10,LN):AI.DESC:; LN = LN+1
*
COM.ID = "NEXT.PPV.EVENT.NUM.":AI.CODE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO REPEAT
READ START.NUM FROM COM.FILE,COM.ID ELSE START.NUM = 1
*
START.NUM = ("0000":START.NUM) "R#4"
SAVE.LN = LN; GET.NUM = START.NUM
*
!
NEXT.EVENT: *
*
LOOP
PRINT @(0,LN):CLL:"Enter the Master Event Code for assignment: ":; INPUT EVENT.CODE:
IF EVENT.CODE = "KILL" THEN STOP ELSE IF EVENT.CODE = "" THEN GOTO FINISH
* LOOP
* LCK.TYPE = 0
CALL SYS.ITM.LCK("PVM",EVENT.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO REPEAT
MATREAD PVM FROM PVM.FILE,EVENT.CODE ELSE EVENT.CODE = ""
IF EVENT.CODE NE "" THEN
PRINT @(5,LN+1):CLL:EVENT.CODE:" - ":PVM$DESC:" - debuts on ":OCONV(PVM$DEBUT.DT,"D2"):
VC = 1; E.CTR = 0; ECHK.CTR = 0; ENUM.CTR = 0
LOOP EVENT.DT = PVM$PVE.DT<1,VC> UNTIL EVENT.DT = "" DO
E.CTR = E.CTR+1
MATREAD PVE FROM PVE.FILE,AI.CODE:"*":PVM$EVENT.NUMS<1,VC> THEN
ENUM.CTR = ENUM.CTR+1 
END ELSE
ECHK.CTR = ECHK.CTR+1
END
VC = VC+1
REPEAT
IF NOT(ECHK.CTR) THEN
PRINT CLB:"All showings of the Master Event have been generated.":; PRINT BELL:; INPUT TMP:; PRINT CLB:
EVENT.CODE = ""
END
END
UNTIL EVENT.CODE NE "" DO PRINT BELL: REPEAT
*
LN = LN+2
PRINT @(0,LN):"Number of Event showings:         ":E.CTR:; LN = LN+1
PRINT @(0,LN):"Number of Event Number generated: ":ENUM.CTR:; LN = LN+1
PRINT @(0,LN):"Number to be assigned now:        ":ECHK.CTR:; LN = LN+1
*
*
!
MAIN.LOOP: *
LN = LN+2
PRINT @(0,LN):CLL:"Generating Event Details....":; LN = LN+1
*
LCK.TYPE = -4
*
*
INSERT.ON = 0; PREV.CTR = 0; ASSIGNED.CTR = 0; USED.CTR = 0; TMP.EVENT.NUM = ""
* TMP.EVENT.NUM = ("0000":TMP.EVENT.NUM) "R#4"
VC = 1
*
*
VC = 1
LOOP EVENT.DT = PVM$PVE.DT<1,VC> UNTIL EVENT.DT = "" DO
IF PVM$EVENT.NUMS<1,VC> NE "" THEN
TMP.EVENT.NUM = PVM$EVENT.NUMS<1,VC>
CALL SYS.ITM.LCK("PVM",AI.CODE:"*":TMP.EVENT.NUM,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
IF LCK.STAT THEN
USED.CTR = USED.CTR+1
END ELSE
*
MATREAD PVE FROM PVE.FILE,AI.CODE:"*":TMP.EVENT.NUM THEN
USED.CTR = USED.CTR+1
END ELSE
MAT PVE = ""
ASSIGNED.CTR = ASSIGNED.CTR+1
PVE$PVM.ID = EVENT.CODE
PVE$PROGMO = PVM$PROGMO
PVE$CH.CODE = PVM$CH.CODE
IF PVM$PVE.RATE.CL<1,VC> NE "" THEN PVE$RATE.CL = PVM$PVE.RATE.CL<1,VC> ELSE PVE$RATE.CL = PVM$RATE.CL
IF PVM$PVE.RATE.CL.SUB<1,VC> NE "" THEN PVE$RATE.CL.SUB = PVM$PVE.RATE.CL.SUB<1,VC> ELSE PVE$RATE.CL.SUB = PVM$RATE.CL.SUB
PVE$DT = PVM$PVE.DT<1,VC>
PVE$TM = PVM$PVE.TM<1,VC>
PVE$DUR = PVM$DUR
PVE$PURGE.DT = PVM$PURGE.DT
PVE$DOWNLOADED = ""
*
* PVM$EVENT.NUMS<1,VC> = TMP.EVENT.NUM
*
IF NOT(CNT.TST$Z) THEN MATWRITE PVE ON PVE.FILE,AI.CODE:"*":TMP.EVENT.NUM
*
END
*
END
*
END
*
CALL SYS.ITM.RLS("PVM",AI.CODE:"*":TMP.EVENT.NUM,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
* TMP.EVENT.NUM = ("0000":(TMP.EVENT.NUM+1)) "R#4"; IF TMP.EVENT.NUM GT "9999" THEN TMP.EVENT.NUM = "0001"
PRINT @(0,LN+1):"Processed: ":VC-1 "R#4":"  Assigned: ":ASSIGNED.CTR "R#4":"  Assigned Prev: ":PREV.CTR "R#4":"  Already used: ":USED.CTR "R#4":
VC = VC+1
REPEAT
*
* IF NOT(CNT.TST$X) THEN MATWRITE PVM ON PVM.FILE,EVENT.CODE
*
* CALL SYS.ITM.RLS("PVM",EVENT.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
PRINT @(0,SAVE.LN):CLS:
LN = SAVE.LN
GOTO NEXT.EVENT
*
!
FINISH: *
IF CNT.TST$LBL THEN PRINT CLB:"Finish" :; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
LN = GET.LN-1; STOP
!
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai":; RQM; PRINT CLB:
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
END
~GET.CHANNEL.LIST~
SUBROUTINE GET.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PRNT,STAT)
* PROGRAM:           GET.CHANNEL.LIST
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       BUILD A LIST OF CHANNEL NUMBERS FOR EDITING...
*
* DATE WRITTEN:      11 JUN 86
* DATE RELEASED:     11 JUN 86
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(1.0)"
VS = VERSION
SYS.APPL.SUB = "AI"; SYS.PROG = "GET.CHANNEL.LIST"; SYS.LOCT = EMPTY
*
!
*
CHANNEL.MLES = EMPTY; IMAX = COUNT(COMPONENTS<3>,VM) + ONE
FOR I = ONE TO IMAX
MLE.NUMS = COMPONENTS<3,I>
JMAX = COUNT(MLE.NUMS,",") + ONE
FOR J = ONE TO JMAX
MLE.NUM = FIELD(MLE.NUMS,",",J) + ZERO
IF MLE.NUM THEN
LOCATE MLE.NUM IN CHANNEL.MLES<ONE> BY "AR" SETTING LOC ELSE
INS MLE.NUM BEFORE CHANNEL.MLES<ONE,LOC>
INS EMPTY BEFORE CHANNEL.MLES<TWO,LOC>
INS EMPTY BEFORE CHANNEL.MLES<3,LOC>
END
CHANNEL.MLES<TWO,LOC> = COMPONENTS<TWO,I>
CHANNEL.MLES<3,LOC> = COMPONENTS<ONE,I>
END
NEXT J
NEXT I
RETURN
!
END
~GET.OP.STATUS~
SUBROUTINE GET.OP.STATUS(SYS.PRNT)
*PROGRAM:           GET.OP.STATUS
* VERSION: 901018 NEW
* DESCRIPTION:  GETS STATUS AND MULTI IF OP DEVICE AT ADDRESS
*
* COPYRIGHT      AXION COMPUTER SYSTEMS LTD.
* 1990                 ALL RIGHTS RESERVED
*
*
$INCLUDE IBP GENERAL.COMMON.AREA
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "(1.0)"
VS = VERSION
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CHANNEL.DN"; SYS.LOCT = EMPTY
*
!
*
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP WKO.EQUATES
$INCLUDE IBP AIX.EQUATES
*
IF SYS.TST<5> NE "" THEN
IF SYS.TST<6> NE "" THEN TEST.FL = 1 ELSE TEST.FL = 0
IF SYS.TST<8> NE "" THEN CO.DATA<4> = 1 ELSE CO.DATA<4> = 0
IF SYS.TST<9> NE "" THEN CO.DATA<7> = 1 ELSE CO.DATA<7> = 0
END ELSE TEST.FL = 0
!
* START *
READ AI.TYPE FROM CNT.FILE,"AI.TYPE.":FIELD(ADD$GEOGRAPHIC.DATA,"*",10) ELSE AI.TYPE = ""
IF ADD$AIX.ID NE "" THEN
AIX.ID = FIELD(ADD$GEOGRAPHIC.DATA,"*",10):"*":ADD$AIX.ID
AI.MULTI = ADD$AIX.LOCATION
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
END
RETURN
!
END
~GET.PVE.XREF~
SUBROUTINE GET.PVE.XREF(FILE.NAME,ITEM.NAME,ITEM,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,TM.MAX,TT,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,SYS.PRNT,STAT)
* SUBROUTINE:        GET.PVE.XREF
* AUTHOR:            DAVID HORSMAN
* DATE WRITTEN:      5 JUN 93
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
EQU VERSION TO "(1.0)"
VS = VERSION
SYS.APPL.SUB = "AI"; SYS.PROG = "AI.CHANNEL.DN"; SYS.LOCT = EMPTY
*
!
*
GET.DATA: *
*
PVM$PVE.XREF = EMPTY; PVM$PVE.DT = EMPTY; PVM$PVE.TM = EMPTY
*
FOR SUB.REF = ONE TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I02B,I02C,I02D
TC.FUNC = EMPTY; TC.OUT = EMPTY
LN = 23
IF STAT EQ 999 THEN RETURN
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 4
END ELSE
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
*
RSP = (PVM$PVE.DT * 100000) + PVM$PVE.TM
RSP = ("0000000000":RSP) "R#10":PVM$PVE.COMP
*
PRINT @(50,23):RSP "L#16"
*
RETURN; * To calling program
*
I02A: *
*
PVM$PVE.XREF = EMPTY
CALL INPUT.DATA.SG1("PVM$PVE","1",PVM$PVE.XREF,4,LN,"L0","0",ONE:",":VC,"","OP",EMPTY,RSP,RSPBUF,TM.MAX,REDISP,TT,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,4,LN,".",STD.SUBR.NAME,STAT)
* IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02A
RETURN
*
I02B: *
*
PVM$PVE.DT = EMPTY
CALL INPUT.DATA.SG1("PVM$PVE","18",PVM$PVE.DT,10,LN,"L9","9",ONE:",":VC,"D2","OP":VM:"DT",EMPTY,RSP,RSPBUF,TM.MAX,REDISP,TT,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,10,LN,".",STD.SUBR.NAME,STAT)
* IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02B
RETURN
*
I02C: *
*
PVM$PVE.TM = EMPTY
CALL INPUT.DATA.SG1("PVM$PVE","19",PVM$PVE.TM,20,LN,"L8","8",ONE:",":VC,"MTS","OP":VM:"",EMPTY,RSP,RSPBUF,TM.MAX,REDISP,TT,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,20,LN,".",STD.SUBR.NAME,STAT)
* IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02C
RETURN
*
I02D: *
*
PVM$PVE.COMP = EMPTY
CALL INPUT.DATA.SG1("PVM$PVE","20",PVM$PVE.COMP,30,LN,"L8","8",ONE:",":VC,"","EQ":SVM:"@":COMPONENTS<ONE>:"@",EMPTY,RSP,RSPBUF,TM.MAX,REDISP,TT,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,30,LN,".",STD.SUBR.NAME,STAT)
* IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02D
RETURN
*
END
~INPUT.OPERATOR~
SUBROUTINE INPUT.OPERATOR(OPER,OPER.POSN,OPER.LN,OPER.CL,OPER.TEXT,DESC.LN,DESC.CL,DESC.FMT,RVB.FLAG,RUN.TYPE,OPER.DISP,OPER.STAT)
* SUBROUTINE:        INPUT.OPERATOR
* AUTHOR:            DAVID HORSMAN
* DATE WRITTEN:      17 NOV 90
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = ""
BEGIN CASE
CASE RUN.TYPE EQ 1; * NORMAL
NULL
CASE RUN.TYPE EQ 2; * DEVICE ALSO
OPERATORS<1,-1> = "DEVICE"
OPERATORS<2,-1> = "System Device Port"
OPERATORS<3,-1> = "Hardware Device Resources"
OPER.DISP = TRUE
END CASE
*
CL = OPER.CL; LN = OPER.LN
OPER.TEXT.LEN = LEN(OPER.TEXT) + ONE
OPER.TEXT.CL = CL
CL = CL + OPER.TEXT.LEN
*
!
*
IF NOT(OPER.DISP) THEN
*
IF OPER NE "" THEN GOSUB DISP.FG
*
IF RVB.FLAG THEN
PRINT @(OPER.TEXT.CL,LN):RVB:OPER.TEXT:RVE:
END ELSE
PRINT @(OPER.TEXT.CL,LN):OPER.TEXT:
END
*
GOSUB GET.DATA
IF OPER.STAT THEN RETURN
*
END
*
GOSUB DISP.FG
*
RETURN
*
!
*
DISP.FG: *
IF RVB.FLAG THEN
PRINT @(OPER.TEXT.CL,LN):RVB:OPER.TEXT:RVE:@(CL,LN):OPER<ONE> "L#6":
END ELSE
PRINT @(OPER.TEXT.CL,LN):OPER.TEXT:@(CL,LN):OPER<ONE>:
END
GOSUB T01
*
RETURN
*
GET.DATA: *
*
I01: CALL INPUT.DATA(OPER,CL,LN,"L6",1,"","EQ":SVM:"@":OPERATORS<1>:"@","",RSP,OPER.STAT)
IF OPER.STAT THEN RETURN ELSE GOSUB T01
RETURN
*
!
*
T01: TRN.FLD = OPER<ONE>
LOCATE TRN.FLD IN OPERATORS<ONE> SETTING LOC THEN
TRN.FLD = OPERATORS<TWO,LOC>
OPER.POSN = OPERATORS<3,LOC>
END ELSE
TRN.FLD = "Not on file"
OPER.POSN = EMPTY
END
PRINT @(DESC.CL,DESC.LN):TRN.FLD DESC.FMT:
RETURN
*
!
*
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[ONE,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*
!
*
END
~LOAD.CHANNEL.LIST~
SUBROUTINE LOAD.CHANNEL.LIST(COMPONENTS,CHANNEL.MLES,SYS.PRNT,STAT)
* PROGRAM:           LOAD.CHANNEL.LIST
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       BUILD A LIST OF CHANNEL NUMBERS FOR EDITING...
*
* DATE WRITTEN:      11 JUN 86
* DATE RELEASED:     11 JUN 86
!
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
CHANNEL.MLES = EMPTY; IMAX = COUNT(COMPONENTS<3>,VM) + ONE
FOR I = ONE TO IMAX
MLE.NUMS = COMPONENTS<3,I>
JMAX = COUNT(MLE.NUMS,",") + ONE
FOR J = ONE TO JMAX
MLE.NUM = FIELD(MLE.NUMS,",",J) + ZERO
IF MLE.NUM THEN
LOCATE MLE.NUM IN CHANNEL.MLES<ONE> BY "AR" SETTING LOC ELSE
INS MLE.NUM BEFORE CHANNEL.MLES<ONE,LOC>
INS EMPTY BEFORE CHANNEL.MLES<TWO,LOC>
INS EMPTY BEFORE CHANNEL.MLES<3,LOC>
END
CHANNEL.MLES<TWO,LOC> = COMPONENTS<TWO,I>
CHANNEL.MLES<3,LOC> = COMPONENTS<ONE,I>
END
NEXT J
NEXT I
RETURN
!
END
~LOAD.CHANNEL.NUMBERS~
SUBROUTINE LOAD.CHANNEL.NUMBERS(PAR.FILE,SVC.FILE,SVC.CHANNELS)
* PROGRAM:           LOAD.CHANNEL.NUMBERS
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       BUILD A TABLE OF SERVICES, EACH WITH ITS CORRESPONDING
*                    LIST OF CHANNEL NUMBERS.
*
* DATE WRITTEN:      27 MAY 86
* DATE RELEASED:     27 MAY 86
!
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SVC.DIM
$INCLUDE IBP SVC.EQUATES
!
READ COMPONENTS FROM PAR.FILE,"COMPONENTS" ELSE PRINT "Can't find PAR COMPONENTS":; INPUT RSP; STOP
SVC.CHANNELS = ""
EXECUTE "SSELECT SVC "
LOOP
READNEXT SVC.ID ELSE SVC.ID = ""
UNTIL SVC.ID = "" DO
MATREAD SVC FROM SVC.FILE,SVC.ID THEN
LOCATE SVC.ID IN SVC.CHANNELS<1> BY "AL" SETTING VC ELSE
INS SVC.ID BEFORE SVC.CHANNELS<1,VC>
INS SVC$DESC BEFORE SVC.CHANNELS<2,VC>
INS "" BEFORE SVC.CHANNELS<3,VC>
INS "" BEFORE SVC.CHANNELS<4,VC>
END
CVC = 1; SV = 0
LOOP
COMPONENT = SVC$COMPONENTS<1,CVC>
UNTIL COMPONENT = "" DO
LOCATE COMPONENT IN COMPONENTS<1> BY "AL" SETTING CVC1 THEN
CHANNEL.GRP = COMPONENTS<3,CVC1>
CHAN.MAX = COUNT(CHANNEL.GRP,",")+1
FOR CHAN.NO = 1 TO CHAN.MAX
CHANNEL = FIELD(CHANNEL.GRP,",",CHAN.NO)+0
IF CHANNEL THEN
SV = SV+1
SVC.CHANNELS<3,VC,SV> = CHANNEL
SVC.CHANNELS<4,VC,SV> = FIELD(COMPONENTS<4,CVC1>,",",CHAN.NO)
END
NEXT CHAN.NO
END
CVC = CVC+1
REPEAT
IF SV = 0 THEN
DEL SVC.CHANNELS<1,VC>
DEL SVC.CHANNELS<2,VC>
DEL SVC.CHANNELS<3,VC>
DEL SVC.CHANNELS<4,VC>
END
END
REPEAT
WRITE SVC.CHANNELS ON PAR.FILE,"SVC.CHANNELS"
RETURN
!
END
~MAINT.AI.TYPES~
*PROGRAM:           MAINT.AI.TYPES
* VERSION: 940127 1.0  NEW
*  
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1994               ALL RIGHTS RESERVED
*  
* AUTHOR:          H HORSMAN
* DESCRIPTION:  MAINTAIN ADDRESSABLE INTERFACE TYPES.
*               COPIED FROM MAINT.ADMIN.AREAS
*                    SEE '*CUSTOM*' LINES.
*                    ANY 888 REFERENCE MUST BE CHANGED TO 'AA.VC'.
*
!
VERSION = " (R:1.0)"
TITLE = "Addressable Interfaces Types Maintenance":VERSION
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "COM" TO COM.FILE ELSE TEXT = "Can't open COM"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
READ HENDS FROM PAR.FILE,"HEADENDS" ELSE HENDS = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(4)
VALID.REFS = "DS":AM:"ZO":AM:"HE"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
*CUSTOM* GOSUB DISPLAY.BACKGROUND
COM.ID = ""; GOSUB GET.KEY; IF COM.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
END
IF STAT THEN GOTO UNLOCK
READ COM FROM COM.FILE,COM.ID THEN NEW = "" ELSE NEW = 1; COM = ""
GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
GOSUB DISPLAY.BACKGROUND; *CUSTOM*
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = COM.ID; COM.ID = "!":COM.ID; GOSUB GET.KEY; COM.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 3
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT CLB:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
GOSUB DEL.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
GOTO UPDATE; *CUSTOM*
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = COM.ID; COM.ID = "!":COM.ID; GOSUB GET.KEY; COM.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
*CUSTOM* GOSUB UPD.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
WRITE COM ON COM.FILE,COM.ID
UPDATED = 1
!
UNLOCK: *
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
GOTO NEXT.ITEM; *CUSTOM*
*CUSTOM* STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28-((LEN(CO.NAME)/2)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
PRINT @(0,3):RVB:"Interface Type Code......":RVE:
PRINT @(0,5):RVB:"DS> Description..........":RVE:
PRINT @(0,6):RVB:"ZO> AI Computer Model....":RVE:
PRINT @(0,8):RVB:"HE> Headends":RVE:"   ":RVB:"Description":RVE:
PRINT @(26,3):COM<1,AA.VC>"L#8":; *CUSTOM*
RETURN
!
DISPLAY.FOREGROUND: *
*CUSTOM* PRINT @(26,3):COM<1,AA.VC> "L#8":
PRINT @(26,5):COM<2,AA.VC> "L#30":
PRINT @(26,6):COM<3,AA.VC> "L#30":
DYNAMIC = ""; GOSUB D03; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
COM.ID = "AI.TYPES"
RETURN
!
GET.DATA: *
ON REF GOSUB I01,I02,I03
RETURN
!
I01: CALL INPUT.DATA(COM,26,5,"L30",2:",":AA.VC,"","","",RSP,STAT); RETURN
I02: CALL INPUT.DATA(COM,26,6,"L30",3:",":AA.VC,"","","",RSP,STAT); RETURN
I03:  PRINT CLB:"Enter Headend: ":
FLD = ""; CALL INPUT.DATA(FLD,16,23,"L4",1,"","SE":VM:"OP","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I03
IF FLD = "" THEN RETURN
LOCATE FLD IN COM<4,AA.VC> BY "AL" SETTING SC THEN
PRINT CLB:"Ref. LO> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL COM<4,AA.VC,SC>
TOP.DISP.LOC(4) = -ABS(TOP.DISP.LOC(4))
DYNAMIC = "D"; GOSUB D03; IF STAT = 999 THEN RETURN
GOTO I03
END
END ELSE
GOSUB UPD.CALL; IF STAT = 999 THEN RETURN ELSE IF STAT THEN GOTO I03; *CUSTOM*
IF COM<4,AA.VC,SC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF SC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I03
END
INS FLD BEFORE COM<4,AA.VC,SC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(4) = -ABS(TOP.DISP.LOC(4)) ELSE IF NOT(TOP.DISP.LOC(4)) THEN TOP.DISP.LOC(4) = 1
END
GOSUB D03; IF STAT = 999 THEN RETURN
LN = MOD(SC-1,10)+9
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB I03
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 3
NEXT SUB.REF
RETURN
D03: SAVE.SC = SC
IF TOP.DISP.LOC(4) < 0 THEN TOP.DISP.LOC(4) = ABS(TOP.DISP.LOC(4)) ELSE
IF SC >= TOP.DISP.LOC(4) THEN IF SC <= TOP.DISP.LOC(4)+9 THEN
IF DYNAMIC = "N" THEN LN = MOD(SC-1,10)+9; PRINT @(4,LN):COM<4,AA.VC,SC> "L#2":
RETURN
END
END
IF TOP.DISP.LOC(4) THEN SC = SC-MOD(SC-1,10); CLEAR = 1 ELSE SC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 9 TO 20 UNTIL COM<4,AA.VC,SC> = ""
IF LN = 9 THEN TOP.LOC = SC
PRINT @(4,LN):COM<4,AA.VC,SC> "L#2":
LOCATE COM<4,AA.VC,SC> IN HENDS BY "AR" SETTING LOC THEN
PRINT @(15,LN):HENDS<2,LOC> "L#30":
END
SC = SC+1
NEXT LN
IF TOP.DISP.LOC(4) OR COM<4,AA.VC,SC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 9; GOSUB C03 REPEAT
IF CLEAR THEN GOSUB C03 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(4) = TOP.LOC
SC = SAVE.SC
RETURN
C03: FOR LN = LN TO 20
PRINT @(4,LN):SPACE(2):
PRINT @(15,LN):SPACE(30):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
UPD.CALL: *
* VERIFY THAT NONE OF THE SYNONYM ACCOUNTS ARE IN ANY OTHER ACCOUNT...
STAT = 0
TVC = 0
LOOP TVC = TVC+1 UNTIL COM<4,TVC> = "" OR STAT > 0 DO
IF TVC # AA.VC THEN
LOCATE FLD IN COM<4,TVC> SETTING WSC THEN
PRINT @(0,23):BELL:CLL:"The Headend is in AI Type: ":COM<1,TVC>:
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999 ELSE STAT = 1
PRINT CLB:
END
END
REPEAT
RETURN
!
DEL.CALL: *
* DELETE ONLY A SINGLE ADMINISTRATIVE AREA FROM ITEM...
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN STAT = 1; RETURN
FOR AC = 1 TO 4
DEL COM<AC,AA.VC>
NEXT AC
RETURN
!
READ.CALL: *
* DISPLAY ADMIN.AREAS THEN SELECT ONE...
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28-((LEN(CO.NAME)/2)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
TITLE2 = RVB:"AI Code":RVE:"  ":RVB:"Description":RVE
PRINT @(0,3):TITLE2:@(40,3):TITLE2:
IF NEW THEN COM = ""
VC = 1; CL = 0; LN = 5
LOOP AI.CODE = COM<1,VC> UNTIL AI.CODE = "" DO
PRINT @(CL,LN):AI.CODE "L#9":COM<2,VC> "L#30":
LN = LN+1; IF LN > 20 THEN IF CL = 0 THEN CL = 40 ELSE VC = 999
VC = VC+1
REPEAT
PRINT @(10,22):CLL:"Enter AI Code: ":
INPUT RSP:; IF RSP = "KILL" OR RSP = "" THEN
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STOP
END
IF NEW THEN COM<1,1> = RSP; AA.VC = 1; RETURN
LOCATE RSP IN COM<1> BY "AL" SETTING AA.VC THEN RETURN
NEW = 1
FOR AC = 1 TO 4
INS "" BEFORE COM<AC,AA.VC>
NEXT AC
COM<1,AA.VC> = RSP
RETURN
!
END
~MAINT.AIX.OP~
*PROGRAM:           MAINT.AIX.OP
* VERSION: 900925 NEW  COPIED FROM MAINT.DVC. REVISED 910416.
* DESCRIPTION:  MAINTAIN ON PREMISE DEVICE (1 TO 8 ADDRESSES)
* COPYRIGHT      AXION COMPUTER SYSTEMS LTD.
*   1990            ALL RIGHTS RESERVED
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP SAVE.AIX.DIM
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP DVT.DIM
$INCLUDE IBP DVT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP SVC.DIM
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STX.DIM
$INCLUDE IBP STT.DIM
$INCLUDE IBP STT.EQUATES
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ASH.DIM
$INCLUDE IBP ASH.EQUATES
$INCLUDE IBP ADD.AIX.DIM
MAT COM.AI = EMPTY; COM.AI.ID = EMPTY; MAT SAVE.AIX = EMPTY; MAT ADD.AIX = EMPTY
!
OPEN "DVC" TO AIX.FILE ELSE TEXT = "Can't open AIX"; GOSUB ERROR; STOP
OPEN "ACT" TO ACT.FILE ELSE TEXT = "Can't open ACT"; GOSUB ERROR; STOP
OPEN "ASH" TO ASH.FILE ELSE TEXT = "Can't open ASH"; GOSUB ERROR; STOP
OPEN "SVC" TO SVC.FILE ELSE TEXT = "Can't open SVC"; GOSUB ERROR; STOP
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "COM" TO COM.FILE ELSE TEXT = "Can't open COM"; GOSUB ERROR; STOP
OPEN "ADD" TO ADD.FILE ELSE TEXT = "Can't open ADD"; GOSUB ERROR; STOP
OPEN "STX" TO STX.FILE ELSE TEXT = "Can't open STX"; GOSUB ERROR; STOP
OPEN "STT" TO STT.FILE ELSE TEXT = "Can't open STT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO
ON.PREM = 1; SVC.CHANNELS = ""; VERSION = " (R:?.?)"; MULTI.COMMPORTS = 0
SERIAL.NUM = ""; NUM.SERVED = 1; PRIOR.STT.NUM = ""; ADD.TYPE = ""
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
MATREAD DVT FROM PAR.FILE,"DEVICE.TYPES" ELSE MAT DVT = ""
READ DEVICE.FUNCTIONS FROM PAR.FILE,"DEVICE.FUNCTIONS" ELSE DEVICE.FUNCTIONS = ""
READ CITIES FROM PAR.FILE,"CITIES" ELSE PRINT CLB:"Can't read PAR CITIES":; INPUT RSP:; STAT = 999; RETURN
READ DEVICE.STATUSES FROM PAR.FILE,"DEVICE.STATUSES" ELSE DEVICE.STATUSES = ""
CN = 1
LOOP WHILE DEVICE.STATUSES<1,CN> # "" DO
IF DEVICE.STATUSES<4,CN> = "Y" THEN DEVICE.STATUSES<4,CN> = 1 ELSE DEVICE.STATUSES<4,CN> = ""
CN = CN+1
REPEAT
READ COMMPORTS FROM COM.FILE,"COMMPORTS" ELSE PRINT "Can't find COMMPORTS":; INPUT RSP:; STOP; *CUSTOM*
LN = 6
IF COUNT(COMMPORTS<1>,VM) THEN
VC = 1
LOOP COMMPORT = COMMPORTS<1,VC> UNTIL COMMPORT = "" DO
* HEAD.NAME = COMMPORTS<2,VC>
* PRINT @(15,LN):COMMPORT:"  ":HEAD.NAME:; LN = LN+1
PRINT @(15,LN):COMMPORT:; LN = LN + 1
VC = VC+1
REPEAT
LN = LN+2
END
VC = 0; FOUND = 0
*
IF COUNT(COMMPORTS<1>,VM) THEN MULTI.COMMPORTS = 1 ELSE MULTI.COMMPORTS = 0; COMMPORT = COMMPORTS<1,1>
IF MULTI.COMMPORTS THEN
RSP.RELOOP: *
PRINT @(15,LN):CLL:"Enter the Comm Port you are working on: ":; INPUT COMMPORT:
IF COMMPORT = "KILL" OR COMMPORT = "" THEN STOP
LOCATE COMMPORT IN COMMPORTS<1> BY "AL" SETTING COMMPORT.VM ELSE GOTO RSP.RELOOP
END ELSE
COMMPORT.VM = 1
END
*
COM.AI.ID = "AI.TYPE.":COMMPORT
MATREAD COM.AI FROM COM.FILE,COM.AI.ID ELSE
PRINT CLB:"Cannot proceed. The interface type has not been defined.":; INPUT TMP:; STOP
MAT COM.AI = EMPTY
END
PREFIX = COMMPORT
*
AC = ""; VC = ""; SC = ""; TEXT = ""
DIM TOP.DISP.LOC(7)
VALID.REFS = "TY":AM:"ID":AM:"CO":AM:"IA":AM:"ST":AM:"SA":AM:"AS"
*
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28-((LEN(CO.NAME)/2)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
TITLE = "On Premise Device Maintenance for Headend ":COMMPORT:VERSION
PRINT @(0,1):RVB:(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""; STREET = ""; NUM.DEVICES = 1; AI.DOWN = ""; CITY.NUM = ""
GOSUB DISPLAY.BACKGROUND
SERIAL.NUM = ""; AIX.ID = ""; GOSUB GET.KEY; IF AIX.ID = "" THEN STOP
FIRST.AIX.ID = AIX.ID
AIX.TO.ID = AIX.ID
IF NOT(DISPLAY.ONLY) THEN
CALL SYS.ITM.LCK("AIX",FIRST.AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
END
IF STAT THEN GOTO UNLOCK
NEW.AIX = ""
MATREAD AIX FROM AIX.FILE,AIX.ID THEN NEW = "" ELSE NEW = 1; MAT AIX = ""
ADD.ID = AIX$INSTALLED.ADD.ID; PRIOR.ADD.ID = ADD.ID
MATREAD ADD FROM ADD.FILE,ADD.ID ELSE MAT ADD = ""
ADD.STAT = ADD$STAT
IF ADD.STAT = "H" THEN HOT.ADDRESS = 1 ELSE HOT.ADDRESS = 0
PRIOR.SERIAL.NUM = AIX$DVC.ID
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = AIX.ID; AIX.ID = "!":AIX.ID; GOSUB GET.KEY; AIX.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
AIX$STAT = "N"
GOSUB DISPLAY.FOREGROUND
AIX.TO.ID = ""
LOOP UNTIL AIX.TO.ID >= AIX.ID DO
AIX.TO.ID = SERIAL.NUM
CALL INPUT.DATA(AIX.TO.ID,43,3,"L15",1,"","","",RSP,STAT)
IF STAT THEN GOTO UNLOCK
TEXT = ""; AIX.TO.ID = PREFIX:"*":AIX.TO.ID
IF AIX.TO.ID # AIX.ID THEN
IF AIX.TO.ID < AIX.ID THEN TEXT = "must be same or greater"
IF LEN(AIX.TO.ID) # LEN(AIX.ID) THEN TEXT = "length must be the same"
IF TEXT # "" THEN GOSUB ERROR; AIX.TO.ID = "" ELSE
LNG1 = 1
LOOP UNTIL AIX.ID[1,LNG1] # AIX.TO.ID[1,LNG1] DO LNG1 = LNG1+1 REPEAT
LNG1=LNG1-1
AIX.ID.NUM = AIX.ID[LNG1+1,LEN(AIX.ID)-LNG1]
IF NOT(AIX.ID.NUM MATCHES "0N") THEN TEXT = "numbers not in same range"; GOSUB ERROR ELSE
AIX.TO.ID.NUM = AIX.TO.ID[LNG1+1,LEN(AIX.ID)-LNG1]
NUM.DEVICES = AIX.TO.ID.NUM-AIX.ID.NUM+1
PRINT @(60,3):NUM.DEVICES:" devices.":
TEST.ID = AIX.ID
LOOP
TEST.NUM = TEST.ID[LNG1+1,LEN(AIX.ID)-LNG1]+1
LOOP TEST.ID = TEST.ID[1,LNG1]:TEST.NUM UNTIL LEN(TEST.ID) = LEN(AIX.ID) DO
TEST.NUM = "0":TEST.NUM
REPEAT
READ TEST.ITEM FROM AIX.FILE,TEST.ID THEN
IF TEXT # "" THEN TEXT = TEXT:","
TEXT = TEXT:TEST.ID
END
UNTIL LEN(TEXT) > 45 OR TEST.ID >= AIX.TO.ID DO
REPEAT
IF TEXT # "" THEN TEXT = "on file: ":TEXT; GOSUB ERROR
END
END
END
IF TEXT # "" THEN AIX.TO.ID = ""
REPEAT
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
MAT AIX = MAT ADD.AIX
AIX$INSTALLED.ADD.ID = ""; AIX$SVC.ID = ""; AIX$SVC.ADD.ID = ""; AIX$ACT.ID = ""; AIX$CONN.OUTLETS = ""
AIX$STAT = "N"; AIX$DVC.ID = SERIAL.NUM; 
GOSUB DISPLAY.FOREGROUND
IF AIX$TYPE # "" THEN PRINT CLB:"The fields of the last added device are shown as default values...":
FOR REF = 1 TO 5
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
NEW.AIX = 1
MAT ADD.AIX = MAT AIX
IF AIX$INSTALLED.ADD.ID # "" THEN
PRINT CLB:"Enter 'KILL' or <cr> to update: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
MATWRITE AIX ON AIX.FILE,AIX.ID
GOSUB UPDATE.ADDRESS
END
END
!
CHANGES: *
PRINT CLB:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
GOSUB DEL.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE AIX.FILE,AIX.ID; GOTO UNLOCK
GOSUB DISPLAY.BACKGROUND
TEMP = AIX.ID; AIX.ID = "!":SERIAL.NUM; GOSUB GET.KEY; AIX.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = AIX.ID; AIX.ID = "!":SERIAL.NUM; GOSUB GET.KEY; AIX.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
IF (NEW.AIX) AND AIX$STAT<1,1> = "N" THEN MAT ADD.AIX = MAT AIX
TEXT = ""
LOOP
MATWRITE AIX ON AIX.FILE,AIX.ID
UNTIL AIX.ID = AIX.TO.ID DO
SERIAL.NUM = SERIAL.NUM+1; AIX$DVC.ID = SERIAL.NUM; AIX$INSTALLED.ADD.ID = ""; AIX.ID.NUM = AIX.ID.NUM+1
LOOP AIX.ID = AIX.ID[1,LNG1]:AIX.ID.NUM UNTIL LEN(AIX.ID) = LEN(AIX.TO.ID) DO
AIX.ID.NUM = "0":AIX.ID.NUM
REPEAT
PRINT @(22,3):SERIAL.NUM:
REPEAT
UPDATED = 1
!
UNLOCK: *
CALL SYS.ITM.RLS("AIX",FIRST.AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
IF STAT = 999 THEN STOP
GOTO NEXT.ITEM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,2):CLS:
PRINT @(0,3):RVB:"    Serial No.......":RVE:@(39,3):RVB:"To:":RVE:
PRINT @(0,5):RVB:"TY> Device Type.....":RVE:
PRINT @(0,6):RVB:"ID> Interface ID....":RVE:
PRINT @(0,7):RVB:"CO> Comments........":RVE:
PRINT @(0,8):RVB:"IA> Installed Addr..":RVE:
PRINT @(0,9):RVB:"ST> Status (O,I,N)..":RVE:
PRINT @(0,12):RVB:"SA> Addresses ":RVE:
PRINT @(43,12):RVB:"AS> Current Available Services ":RVE:
ADD.HDR = RVB:"# St ....Apt  House Street" "L#42":RVE
SVC.HDR = ADD.HDR:" ":RVB:"St Account# S# Service Outlet Tier St" "L#37":RVE
FULL.HDR = ADD.HDR:" ":RVB:"St Account# Services at address" "L#37":RVE
PRINT @(0,13):FULL.HDR:
*
RETURN
*
!
*
LOAD.COM.AI.SVCS: *
*
************
IF AIX$TYPE # "" THEN
*
* LOCATE AIX$TYPE IN DVT$DEVICE.TYPE<1> BY "AL" SETTING LOC THEN NUM.SERVED = DVT(7)<1,LOC> ELSE NUM.SERVED = 1
* NUM.SERVED = DVT(7)<1,LOC>
*
LOCATE AIX$TYPE IN COM.AI$UNIT<ONE> BY "AL" SETTING TYPE.LOC THEN
NUM.SERVED = COM.AI$ADDR.PER.UNIT<ONE,TYPE.LOC>
NUM.TIERS  = COM.AI$TIER.PER.UNIT<ONE,TYPE.LOC>
END ELSE
NUM.SERVED = ONE
NUM.TIERS  = 132
END
*
* IF NUM.SERVED EQ 1 THEN
SVCS.DEFAULTS = COM.AI$DF.SVCS.ONE<ONE,TYPE.LOC>
COUT.DEFAULTS = COM.AI$DF.COUT.ONE<ONE,TYPE.LOC>
TIER.DEFAULTS = COM.AI$DF.TIER.ONE<ONE,TYPE.LOC>
* END ELSE
* SVCS.DEFAULTS = COM.AI$DF.SVCS.EIGHT
* COUT.DEFAULTS = COM.AI$DF.COUT.EIGHT
* TIER.DEFAULTS = COM.AI$DF.TIER.EIGHT
* END
*
END
*
RETURN
*
!
*
DISPLAY.FOREGROUND: *
*
GOSUB LOAD.COM.AI.SVCS
*
PRINT @(22,5):AIX$TYPE<1> "L#5":; LN = 5; GOSUB T01
PRINT @(22,6):AIX$DVC.ID<1> "L#10":
PRINT @(22,7):AIX$COMMENTS<1,1> "L#30":
*
TMP.ADD.ID = AIX$INSTALLED.ADD.ID
IF TMP.ADD.ID NE "" THEN ADD.TYPE = "I"; GOSUB D06; PRINT @(22,8):DISPLAY.ADDRESS "L30":
*
PRINT @(22,9):AIX$STAT<1> "L#1":
STAT.DESC = ""
IF AIX$STAT = "O" THEN STAT.DESC = "Installed and connected"; AIX.INSTALLED = 1 ELSE AIX.INSTALLED = 0
IF AIX$STAT = "N" THEN STAT.DESC = "Not installed"
IF AIX$STAT = "I" THEN STAT.DESC = "Installed and not connected"
PRINT @(25,9):CLL:STAT.DESC:
*
GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS
*
RETURN
*
!
*
DISPLAY.SVC.ADDRESSES: *
*
ADD.VC = 0; MAX.VC = NUM.SERVED+1; LN = 14; IF MAX.VC LT 9 THEN MAX.VC = 9
LOOP ADD.VC = ADD.VC+1 UNTIL ADD.VC = MAX.VC DO
TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>; ADD.LINE = ""; TMP.STAT = ""
IF TMP.ADD.ID NE "" THEN
ADD.TYPE = "D"; GOSUB D06
STREET = STREET:", ":CITY
ADD.LINE = " ":TMP.STAT "R#2":APT "R#8":HOUSE "R#7":" ":STREET "L#22"
END
IF ADD.VC GT NUM.SERVED THEN V.REF = " " ELSE V.REF = ADD.VC
PRINT @(0,LN):V.REF:ADD.LINE "L#32":
LN = LN+1
REPEAT
*
RETURN
*
!
*
DISPLAY.ADD.SVCS: *
*
PRINT @(0,13):FULL.HDR:
SVC.VC = 0; LN = 14; MAX.VC = NUM.SERVED+1; IF MAX.VC LT 9 THEN MAX.VC = 9
LOOP SVC.VC = SVC.VC+1 UNTIL SVC.VC = MAX.VC DO
ACT.ID = AIX$ACT.ID<1,SVC.VC>; FULL.ACT.ID = ""; ACT.STAT = ""
IF ACT.ID THEN 
CALL MOD11.DIGIT(ACT.ID,CD); FULL.ACT.ID = ACT.ID:"-":CD
READV ACT.STAT FROM ACT.FILE,ACT.ID,2 ELSE ACT.STAT = ""
END
SVC.LINE = " ":ACT.STAT:" ":FULL.ACT.ID "L#9"; SC = 1
LOOP UNTIL AIX$SVC.ID<1,SVC.VC,SC> = "" DO
CONN.OUTLETS = AIX$CONN.OUTLETS<1,SVC.VC,SC>
TIER.NUM     = AIX$TIERS<1,SVC.VC,SC>; IF TIER.NUM NE "" THEN TIER.NUM = "@":TIER.NUM
ADD.SVC = AIX$SVC.ID<1,SVC.VC,SC>; SVC.LINE = SVC.LINE:ADD.SVC:"\":CONN.OUTLETS:TIER.NUM
SC = SC+1; IF AIX$SVC.ID<1,SVC.VC,SC> NE "" THEN SVC.LINE = SVC.LINE:","
REPEAT
IF LEN(SVC.LINE) GT 37 THEN SVC.LINE = SVC.LINE[1,33]:"+"
PRINT @(43,LN):SVC.LINE "L#37":
LN = LN+1
REPEAT
*
RETURN
*
!
*
GET.KEY: *
*
CALL INPUT.DATA(AIX.ID,22,3,"L15",1,"","","",RSP,STAT)
IF AIX.ID NE "" THEN SERIAL.NUM = AIX.ID; AIX.ID = PREFIX:"*":AIX.ID
PRINT @(22,3):SERIAL.NUM:
IF STAT = 999 THEN RETURN
*
RETURN
*
!
*
GET.DATA: *
*
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07
*
RETURN
*
!
*
I01: *
*
PRE.TYPE = AIX$TYPE
* IF HOT.ADDRESS THEN RETURN
CALL INPUT.DATA(AIX$TYPE,22,5,"L5",1,"","EQ|@":DVT$DEVICE.TYPE:"@","",RSP,STAT)
IF STAT THEN RETURN ELSE LN = 5; GOSUB T01
IF AIX$DVC.ID # "" THEN
IF DVT$PROG.ADDR<1,TYPE.LOC> # "O" THEN AIX$DVC.ID = ""; PRINT @(22,8):SPACE(10):
END
LOCATE AIX$TYPE IN DVT$DEVICE.TYPE<1> BY "AL" SETTING LOC THEN NUM.SERVED = DVT(7)<1,LOC> ELSE NUM.SERVED = 1
IF AIX$TYPE = PRE.TYPE THEN RETURN
*
IF DVT$PROG.ADDR<1,TYPE.LOC> = "O" THEN ON.PREM = 1 ELSE ON.PREM = 0
IF DVT$PROG.ADDR<1,TYPE.LOC> EQ "A" OR DVT$PROG.ADDR<1,TYPE.LOC> EQ "I" THEN ADDRESSABLE = 1 ELSE ADDRESSABLE = 0
*
GOSUB LOAD.COM.AI.SVCS
*
RETURN
*
!
*
T01: *
*
TRN.FLD = AIX$TYPE<1>
LOCATE TRN.FLD IN DVT$DEVICE.TYPE<1> SETTING TYPE.LOC THEN TRN.FLD = DVT$DESCRIPTION<1,TYPE.LOC> ELSE TRN.FLD = ""
PRINT @(32,LN):TRN.FLD "L#25":
RETURN
TC02: PRINT @(32,LN):SPACE(12):; RETURN
*
RETURN
*
!
*
I02: *
*
*CUSTOM*
* IF NOT(ON.PREM) THEN RETURN
IF NOT(ADDRESSABLE) THEN RETURN
IF AIX$DVC.ID = "" THEN AIX$DVC.ID = SERIAL.NUM
CALL INPUT.DATA(AIX$DVC.ID,22,6,"L16",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I02
IF AIX$DVC.ID = "" THEN TEXT = "you must enter something here" ELSE
END
IF TEXT # "" THEN
AIX$DVC.ID = PRIOR.SERIAL.NUM
GOSUB ERROR; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
GOTO I02
END
*
RETURN
*
!
*
I03: *
*
IF AIX.ID # AIX.TO.ID THEN RETURN ELSE CALL INPUT.DATA(AIX$COMMENTS,22,7,"L30",1:",":1,"","","",RSP,STAT); RETURN
*
!
*
I04: * INSTALLED ADDRESS
*
IF AIX.ID # AIX.TO.ID THEN RETURN ELSE PRINT @(22,8):; INPUT ID:
ID = TRIM(ID)
IF ID = "" THEN RETURN
IF ID = "\" THEN
AIX$INSTALLED.ADD.ID = ""; TMP.ADD.ID = ""; ID = ""
PRINT @(22,8):CLL:
INSTALL.ADDRESS = ""
END
IF ID = "KILL" THEN GOTO UNLOCK
LN = 8; COL = 53; GOSUB GET.ADDRESS
IF STAT THEN GOSUB DISPLAY.FOREGROUND; ID = ""; STAT = 0; GOTO I04
READV TMP.SERIAL.NUM FROM ADD.FILE,TMP.ADD.ID,23 ELSE TMP.SERIAL.NUM = ""
IF TMP.SERIAL.NUM EQ "" THEN
AIX$INSTALLED.ADD.ID = TMP.ADD.ID
IF NUM.SERVED = 1 THEN
PRIOR.SVC.ADD.ID = AIX$SVC.ADD.ID<1,1>
ADD.VC = 1; GOSUB UPDATE.ADDRESS; GOSUB LOAD.SERVICES
* IF AIX$SVC.ADD.ID<1,1> = "" THEN AIX$SVC.ADD.ID<1,1> = TMP.ADD.ID
END
END ELSE
PRINT CLB:"The address is already served by Serial No. ":TMP.SERIAL.NUM:; INPUT TMP:
TMP.ADD.ID = ""; ID = ""; INSTALL.ADDRESS = ""
PRINT @(22,8):CLL:
GOTO I04
END
PRINT @(22,8):CLL:INSTALL.ADDRESS:; GOSUB DISPLAY.SVC.ADDRESSES
*
RETURN
*
!
*
I05: * DVC STATUS
*
IF AIX.ID # AIX.TO.ID THEN GOTO STAT.EXIT ELSE PRIOR.STAT = AIX$STAT
CALL INPUT.DATA(AIX$STAT,22,9,"L1",1,"","OP":VM:"EQ:SVM:@":DEVICE.STATUSES<1>:"@","",RSP,STAT)
IF NOT(STAT) THEN
IF NOT(COUNT("INO",AIX$STAT)) THEN
PRINT CLB:"That is not a valid status for an On Premise device.":; INPUT TMP:
AIX$STAT = PRIOR.STAT
GOTO STAT.EXIT
END
IF AIX$STAT NE "O" THEN
IF COUNT(AIX$SVC.ADD.STAT<1>,"H") THEN
LOOP
PRINT CLB:"There are hot addresses on this device. Proceed anyway? (Y/<cr>: ":; INPUT RSP:
IF RSP = "KILL" OR RSP = "" THEN AIX$STAT = PRIOR.STAT; GOTO STAT.EXIT
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
END
END ELSE
IF AIX$INSTALLED.ADD.ID = "" THEN
TEXT = "Please enter the Installed Address first."
AIX$STAT = PRIOR.STAT
GOSUB ERROR
GOTO STAT.EXIT
END
END
END
*
*
STAT.EXIT: *
*
GOSUB DISPLAY.FOREGROUND
*
RETURN
*
!
*
GET.ADDRESS: *
*
IF ID = "" THEN DISPLAY.ADDRESS = SPACE(30); RETURN
APT = ""; POS = INDEX(ID,"-",1); IF POS THEN IF ID[POS+1,2] MATCHES "1N1X" THEN APT = ID[1,POS-1]; ID = ID[POS+1,99]
POS = INDEX(ID," ",1); HOUSE = ID[1,POS-1]; STREET = ID[POS+1,99]
LOOP WHILE HOUSE[1,1] = "0" DO HOUSE = HOUSE[2,99] REPEAT
POS = INDEX(STREET,",",1); IF POS THEN CITY = TRIM(STREET[POS+1,99]); STREET = STREET[1,POS-1] ELSE CITY = ""
POS = LEN(STREET); IF STREET[POS,1] = "." THEN POS = POS-1; STREET = STREET[1,POS]
LOOP UNTIL STREET[POS,1] = "" OR STREET[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
IF STREET[POS,999] MATCHES "0N" THEN TEXT = "Invalid ID type"; STAT = 1;  GOSUB ERROR; RETURN
INSTALL.ADDRESS = HOUSE:" ":STREET; IF APT # "" THEN INSTALL.ADDRESS = APT:"-":INSTALL.ADDRESS
IF CITIES<1,2> = "" THEN LOC = 1; CITY = CITIES<1,1> ELSE
LOOP
IF CITY = "" THEN
PRINT @(COL,LN):CLL:"Enter city: ":
INPUT CITY:; IF CITY = "KILL" THEN STAT = 999; GOTO UNLOCK
IF CITY = "" THEN TEXT = ""; STAT = 1; RETURN
END
LOCATE CITY IN CITIES<1> SETTING LOC ELSE LOC = 0
UNTIL LOC DO PRINT BELL:; CITY = "" REPEAT
END
CITY.NAME = CITIES<2,LOC>
INSTALL.ADDRESS = INSTALL.ADDRESS:", ":CITY
*
STX.ID = CITY:"*":STREET
MATREAD STX FROM STX.FILE,STX.ID ELSE TEXT = "Street not on file"; STAT = 1; GOSUB ERROR; PRINT @(22,8):SPACE(30):; RETURN
STREET = STX(1)
MATREAD STT FROM STT.FILE,STREET ELSE TEXT = "Street not on file"; STAT = 1; GOSUB ERROR; PRINT @(22,8):SPACE(30):; RETURN
*
MAT ADD = ""
TMP.ADD.ID = APT:"*":HOUSE:"*":STREET; REQUESTED.ADD.ID = TMP.ADD.ID
MATREAD ADD FROM ADD.FILE,TMP.ADD.ID THEN
RETURN
END ELSE
TEXT = "Invalid address. Please try again."; GOSUB ERROR
PRINT @(22,8):SPACE(50):
STAT = 1; RETURN
END
*
!
*
D06: *
*
* GENERATE DISPLAY ADDRESS
APT = FIELD(TMP.ADD.ID,"*",1)
HOUSE = FIELD(TMP.ADD.ID,"*",2)
STT.NUM = FIELD(TMP.ADD.ID,"*",3)
MATREAD STT FROM STT.FILE,STT.NUM THEN
PRIOR.STT.NUM = STT.NUM
STREET = STT$NAME
CITY = STT$CITY.NUM
END ELSE STREET = "Not on file"; CITY = ""
IF ADD.TYPE = "I" THEN TMP.STAT = "" ELSE TMP.STAT = AIX$SVC.ADD.STAT<1,ADD.VC>
DISPLAY.ADDRESS = HOUSE:" ":STREET:", ":CITY; IF APT NE "" THEN DISPLAY.ADDRESS = APT:" - ":DISPLAY.ADDRESS
ADD.TYPE = ""
*
RETURN
*
!
*
I06: *
*
* INPUT SERVICE ADDRESS
IF AIX$INSTALLED.ADD.ID = "" THEN
TEXT = "Please enter the Installed Address first"
GOSUB ERROR
RETURN
END
LOOP
PRINT CLB:"Enter # to change: ":; IF NUM.SERVED = 1 THEN ADD.VC = 1 ELSE INPUT ADD.VC:
IF ADD.VC = "" THEN RETURN
IF ADD.VC = "KILL" THEN GOTO UNLOCK
UNTIL ADD.VC <=  NUM.SERVED DO PRINT BELL: REPEAT
IF AIX$SVC.ADD.ID<1,ADD.VC> NE "" THEN
PRIOR.SVC.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>
TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>
END ELSE PRIOR.SVC.ADD.ID = ""
IF AIX$SVC.ADD.ID<1,ADD.VC> EQ "" AND AIX$INSTALLED.ADD.ID NE "" THEN
TMP.ADD.ID = AIX$INSTALLED.ADD.ID
END
GOSUB D06
TMP.APT = APT
TMP.HOUSE = HOUSE
TMP.STREET = STREET
TMP.CITY = CITY
CALL INPUT.DATA(TMP.APT,5,13+ADD.VC,"R7",1,"","","",RSP,STAT)
IF STAT THEN GOSUB DISPLAY.SVC.ADDRESSES; GOTO UNLOCK
CALL INPUT.DATA(TMP.HOUSE,13,13+ADD.VC,"R6",1,"","","",RSP,STAT)
IF STAT THEN GOSUB DISPLAY.SVC.ADDRESSES; GOTO UNLOCK
IF TMP.HOUSE NE "" THEN CALL INPUT.DATA(TMP.STREET,20,13+ADD.VC,"L25",1,"","","",RSP,STAT)
IF STAT THEN GOSUB DISPLAY.SVC.ADDRESSES; GOTO UNLOCK
IF TMP.HOUSE = "" THEN TMP.ADD.ID = "" ELSE
IF NOT(COUNT(TMP.STREET,",")) THEN TMP.STREET = TMP.STREET:",":CITY
ID = TMP.HOUSE:" ":TMP.STREET; IF TMP.APT NE "" THEN ID = TMP.APT:"-":ID
GOSUB GET.ADDRESS
IF STAT THEN
GOSUB DISPLAY.SVC.ADDRESSES
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I06
END
END
IF (TMP.ADD.ID = "" AND PRIOR.SVC.ADD.ID NE "") OR (TMP.ADD.ID NE "" AND TMP.ADD.ID NE PRIOR.SVC.ADD.ID) THEN
TMP.VC = 0
LOOP TMP.VC = TMP.VC+1 UNTIL AIX$SVC.ADD.ID<1,TMP.VC> = "" DO
IF AIX$SVC.ADD.ID<1,TMP.VC> = TMP.ADD.ID THEN
TEXT = "That address is already serviced by this device."
GOSUB ERROR; IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOSUB DISPLAY.SVC.ADDRESSES; GOTO I06
END
REPEAT
READV TMP.SERIAL.NUM FROM ADD.FILE,TMP.ADD.ID,23 ELSE TMP.SERIAL.NUM = ""
IF TMP.SERIAL.NUM NE "" THEN
TMP.NO = AIX.ID:"*":ADD.VC
IF TMP.NO NE TMP.SERIAL.NUM THEN
TEXT = "That address is already serviced by device ":TMP.SERIAL.NUM
GOSUB ERROR; GOSUB DISPLAY.SVC.ADDRESSES
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I06
END
END
END
LOOP
PRINT CLB:"Proceed with update of the service address (N/<cr>?: ":; INPUT RSP:
IF RSP = "KILL" THEN GOTO UNLOCK
IF RSP = "N" THEN GOSUB DISPLAY.SVC.ADDRESSES; RETURN
UNTIL RSP = "" DO PRINT BELL: REPEAT
GOSUB UPDATE.ADDRESS
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I06
*
!
*
UPDATE.ADDRESS: *
*
IF TMP.ADD.ID = "" AND PRIOR.SVC.ADD.ID NE "" THEN GOTO UPDATE.PRIOR
LOOP
LCK.TYPE = -1
CALL SYS.ITM.LCK("ADD",TMP.ADD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
WHILE STAT DO
PRINT CLB:CLL:"You must unlock ADD file - item ":TMP.ADD.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
AIX$SVC.ADD.ID<1,ADD.VC> = TMP.ADD.ID; AIX$SVC.ID<1,ADD.VC> = ""; AIX$ACT.ID<1,ADD.VC> = ""
AIX$SVC.ADD.STAT<1,ADD.VC> = ADD$STAT; ADD$AIX.ID = SERIAL.NUM
IF NUM.SERVED = 1 THEN ADD$AIX.LOCATION = 0 ELSE ADD$AIX.LOCATION = ADD.VC
MATWRITE ADD ON ADD.FILE,TMP.ADD.ID
CALL SYS.ITM.RLS("ADD",TMP.ADD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
* UNLOCK ADD.FILE,TMP.ADD.ID; * REV ONLY
GOSUB LOAD.SERVICES
UPDATE.PRIOR: *
IF TMP.ADD.ID = "" THEN 
AIX$ACT.ID<1,ADD.VC> = ""; AIX$SVC.ID<1,ADD.VC> = ""; AIX$SVC.ADD.ID<1,ADD.VC> = ""
AIX$SVC.ADD.STAT<1,ADD.VC> = ""; AIX$CONN.OUTLETS<1,ADD.VC> = ""
AIX$TIERS<1,ADD.VC> = ""; AIX$TSTAT<1,ADD.VC> = ""
END
LOOP
LCK.TYPE = -1
CALL SYS.ITM.LCK("ADD",PRIOR.SVC.ADD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
WHILE STAT DO
PRINT CLB:CLL:"You must unlock ADD file - item ":PRIOR.SVC.ADD.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
WRITEV "" ON ADD.FILE,PRIOR.SVC.ADD.ID,23; WRITEV "" ON ADD.FILE,PRIOR.SVC.ADD.ID,24
CALL SYS.ITM.RLS("ADD",PRIOR.SVC.ADD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
* UNLOCK ADD.FILE,PRIOR.SVC.ADD.ID; * REV ONLY
GOSUB DISPLAY.SVC.ADDRESSES
GOSUB DISPLAY.ADD.SVCS
* END
*
RETURN
*
!
*
LOAD.SERVICES: * GET SERVICES AT ADDRESS
*
IF TMP.ADD.ID = "" THEN
* PRINT CLB:"Clearing Services":
AIX$SVC.ID<1,ADD.VC> = ""
RETURN
END
MATREAD ADD FROM ADD.FILE,TMP.ADD.ID ELSE MAT ADD = ""
AA.VC = 1
IF AIX$SVC.ID<1,ADD.VC> = "" AND NUM.SERVED = 1 THEN
SVC.SC = 1
LOOP TMP.SVC.ID = SVCS.DEFAULTS<1,SVC.SC> UNTIL TMP.SVC.ID = "" DO
AIX$SVC.ID<1,ADD.VC,SVC.SC> = SVCS.DEFAULTS<1,SVC.SC>
AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC> = COUT.DEFAULTS<1,SVC.SC>
AIX$TIERS<1,ADD.VC,SVC.SC> = TIER.DEFAULTS<1,SVC.SC>
AIX$TSTAT<1,ADD.VC,SVC.SC> = 0
SVC.SC = SVC.SC+1
REPEAT
END
*
LOOP
ADD.ACT.ID = ADD$ACT.IDS<1,AA.VC>
IF ADD$ACT.FROM.DATES<1,AA.VC> NE "" THEN
MATREAD ACT FROM ACT.FILE,ADD.ACT.ID ELSE MAT ACT = ""
IF ACT$ADD.ID = TMP.ADD.ID THEN
AIX$ACT.ID<1,ADD.VC> = ADD.ACT.ID
IF ACT$STAT = "A" THEN
ADD.SC = 1; ACT.VC = 1
LOOP
UNTIL ACT$SERVICES<1,ACT.VC> = "" DO
SVC.ID = ACT$SERVICES<1,ACT.VC>
* MATREAD SVC FROM SVC.FILE,SVC.ID ELSE MAT SVC = ""
LOCATE SVC.ID IN AIX$SVC.ID<1,ADD.VC> SETTING LOC THEN
AIX$TSTAT<1,ADD.VC,LOC> = 1
END ELSE
IF NUM.SERVED = 1 THEN AIX$TSTAT<1,ADD.VC,LOC> = 0 ELSE
INS SVC.ID BEFORE AIX$SVC.ID<1,ADD.VC,LOC>
INS ACT$QNTYS<1,ACT.VC>      BEFORE AIX$CONN.OUTLETS<1,ADD.VC,LOC>
INS 1  BEFORE AIX$TSTAT<1,ADD.VC,LOC>
END
END
ACT.VC = ACT.VC+1
REPEAT
END
END
END
UNTIL ADD$ACT.FROM.DATES<1,AA.VC> NE "" OR ADD.ACT.ID = "" DO AA.VC = AA.VC+1 REPEAT
IF AIX$SVC.ID<1,ADD.VC> = "" AND NUM.SERVED # 1 THEN
SVC.SC = 1
LOOP TMP.SVC.ID = SVCS.DEFAULTS<1,SVC.SC> UNTIL TMP.SVC.ID = "" DO
AIX$SVC.ID<1,ADD.VC,SVC.SC> = SVCS.DEFAULTS<1,SVC.SC>
AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC> = COUT.DEFAULTS<1,SVC.SC>
AIX$TIERS<1,ADD.VC,SVC.SC> = TIER.DEFAULTS<1,SVC.SC>
AIX$TSTAT<1,ADD.VC,SVC.SC> = 0
SVC.SC = SVC.SC+1
REPEAT
END
GOSUB DISPLAY.ADD.SVCS
*
RETURN
*
!
*
I07: *
*
* INPUT SERVICES AND OUTLET QUANTITIES AT ADDRESS
LOOP
IF NUM.SERVED = 1 THEN ADD.VC = 1 ELSE PRINT CLB:@(0,23):"Enter Address # to change: ":; INPUT ADD.VC:
IF ADD.VC = "KILL" THEN GOTO UNLOCK; IF ADD.VC = "" THEN RETURN
UNTIL ADD.VC <=  NUM.SERVED DO PRINT BELL: REPEAT
IF AIX$SVC.ADD.ID<1,ADD.VC> = "" THEN
TEXT = "Please enter the Service Addresses first."
GOSUB ERROR
RETURN
END
READV TMP.STAT FROM ACT.FILE,AIX$ACT.ID<1,ADD.VC>,2 ELSE TMP.STAT = ""
PRIOR.SERVICE = AIX$SVC.ID<1,ADD.VC>
IF AIX$SVC.ID<1,ADD.VC> = "" THEN TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>; GOSUB LOAD.SERVICES; GOSUB D08; GOTO I07A
IF TMP.STAT = "A" THEN
GOSUB D08
TEXT = "You can't change the service of an active account"
GOSUB ERROR
GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I07
END
GOSUB D08
*
!
*
I07A: * INPUT SERVICE
*
LOOP
LOCATE "" IN AIX$SVC.ID<1,ADD.VC> SETTING NEXT.VC ELSE NULL
PRINT CLB:"Enter Service # to change, N(ext line), or <cr> to end: ":; INPUT RSP:
IF RSP = "" THEN GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS; IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I07
IF RSP MATCHES "0N" THEN IF RSP LE NEXT.VC THEN SVC.SC = RSP ELSE GOTO I07A
IF RSP = "N" THEN SVC.SC = NEXT.VC
LN = SVC.SC+13; AIX.SVC = AIX$SVC.ID<1,ADD.VC,SVC.SC>
CALL INPUT.DATA(AIX.SVC,58,LN,"L8",1,"","","",RSP,STAT)
IF STAT THEN RETURN
IF AIX.SVC = AIX$SVC.ID<1,ADD.VC,SVC.SC> THEN GOTO I07B
IF AIX.SVC NE "" THEN
MATREAD SVC FROM SVC.FILE,AIX.SVC ELSE
TEXT = "No such service"; GOSUB ERROR; AIX$SVC.ID<1,ADD.VC> = PRIOR.SERVICE
GOSUB D08; GOTO I07A
END
LOCATE AIX.SVC IN AIX$SVC.ID<1,ADD.VC> BY "AL" SETTING SVC.SC ELSE
INS AIX.SVC BEFORE AIX$SVC.ID<1,ADD.VC,SVC.SC>
INS "" BEFORE AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC>
INS "" BEFORE AIX$TIERS<1,ADD.VC,SVC.SC>
INS "" BEFORE AIX$TSTAT<1,ADD.VC,SVC.SC>
END
*
!
*
I07B: * INPUT OUTLET QUANTITY
*
CALL INPUT.DATA(AIX$CONN.OUTLETS,68,LN,"L6","1,":ADD.VC:",":SVC.SC,"","","",RSP,STAT)
IF STAT THEN RETURN
* INPUT TIER NUMBER
CALL INPUT.DATA(AIX$TIERS,75,LN,"L1","1,":ADD.VC:",":SVC.SC,"","","",RSP,STAT)
AIX$TSTAT<1,ADD.VC,SVC.SC> = 0
IF STAT THEN RETURN ELSE GOSUB D08; GOTO I07A
END ELSE
DEL AIX$SVC.ID<1,ADD.VC,SVC.SC>
DEL AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC>
DEL AIX$TIERS<1,ADD.VC,SVC.SC>
DEL AIX$TSTAT<1,ADD.VC,SVC.SC>
GOSUB D08; GOTO I07A
END
UNTIL RSP = "" DO REPEAT
GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS
*
RETURN
*
!
*
D08: * DISPLAY SERVICES AT AN ADDRESS
*
LN = 14; SVC.SC = 1; MAX.SC = NUM.SERVED+1; IF MAX.SC LT 9 THEN MAX.SC = 9
PRINT @(0,13):SVC.HDR:
* ID = AIX$ACT.ID<1,ADD.VC>; FULL.ACT.ID = ""
* IF ID THEN CALL MOD11.DIGIT(ID,CD); FULL.ACT.ID = ID:"-":CD
LOOP
ADD.SVC = AIX$SVC.ID<1,ADD.VC,SVC.SC> "L#8"
ADD.OUTLETS = AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC> "R#6"
ADD.TIER = AIX$TIERS<1,ADD.VC,SVC.SC> "R#5"
ADD.TSTAT = AIX$TSTAT<1,ADD.VC,SVC.SC> "R#3"
IF SVC.SC = 1 THEN
TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>; ADD.LINE = ""; TMP.STAT = ""
IF TMP.ADD.ID NE "" THEN
GOSUB D06
STREET = STREET:", ":CITY
ADD.LINE = " ":TMP.STAT "R#2":APT "R#8":HOUSE "R#7":" ":STREET "L#22"
END ELSE
ADD.LINE = ""
END
PRINT @(0,LN):ADD.VC:ADD.LINE "L#32":
ID = AIX$ACT.ID<1,ADD.VC>; FULL.ACT.ID = ""; ACT.STAT = ""
IF ID THEN 
CALL MOD11.DIGIT(ID,CD); FULL.ACT.ID = ID:"-":CD
READV ACT.STAT FROM ACT.FILE,ID,2 ELSE ACT.STAT = ""
END ELSE ACT.STAT = ""
PRINT @(43,LN):" ":ACT.STAT:" ":FULL.ACT.ID "L#9":
END ELSE
PRINT @(0,LN):CLL:
END
SVC.LN = " ":SVC.SC:" ":ADD.SVC:ADD.OUTLETS:ADD.TIER:ADD.TSTAT
PRINT @(55,LN):SVC.LN:
LN = LN+1
SVC.SC = SVC.SC+1
UNTIL AIX$SVC.ID<1,ADD.VC,SVC.SC> = "" DO REPEAT
LOOP UNTIL SVC.SC GE MAX.SC DO
PRINT @(0,LN):CLL:
LN = LN+1; SVC.SC = SVC.SC+1
REPEAT
*
RETURN
*
!
*
ERROR: *
*
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:; TEXT = ""
*
RETURN
*
!
*
DEL.CALL: *
*
* DELETE ONLY IF BILLING STATUS IS NOT INSTALLED
IF AIX.INSTALLED THEN
TEXT = "You can't delete this device"; GOSUB ERROR; STAT = 1
END
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
*
END
~MAINT.DVC.OP~
*PROGRAM:           MAINT.DVC.OP
* VERSION: 900925 NEW  COPIED FROM MAINT.DVC. REVISED 910416.
* DESCRIPTION:  MAINTAIN ON PREMISE DEVICE (1 TO 8 ADDRESSES)
* COPYRIGHT      AXION COMPUTER SYSTEMS LTD.
*   1990            ALL RIGHTS RESERVED
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP SAVE.AIX.DIM
$INCLUDE IBP AIX.EQUATES
$INCLUDE IBP DVT.DIM
$INCLUDE IBP DVT.EQUATES
$INCLUDE IBP ADD.DIM
$INCLUDE IBP ADD.EQUATES
$INCLUDE IBP SVC.DIM
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STX.DIM
$INCLUDE IBP STT.DIM
$INCLUDE IBP STT.EQUATES
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ASH.DIM
$INCLUDE IBP ASH.EQUATES
$INCLUDE IBP ADD.AIX.DIM
MAT COM.AI = EMPTY; COM.AI.ID = EMPTY; MAT SAVE.AIX = EMPTY; MAT ADD.AIX = EMPTY
!
OPEN "AIX" TO AIX.FILE ELSE TEXT = "Can't open AIX"; GOSUB ERROR; STOP
OPEN "ACT" TO ACT.FILE ELSE TEXT = "Can't open ACT"; GOSUB ERROR; STOP
OPEN "ASH" TO ASH.FILE ELSE TEXT = "Can't open ASH"; GOSUB ERROR; STOP
OPEN "SVC" TO SVC.FILE ELSE TEXT = "Can't open SVC"; GOSUB ERROR; STOP
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "COM" TO COM.FILE ELSE TEXT = "Can't open COM"; GOSUB ERROR; STOP
OPEN "ADD" TO ADD.FILE ELSE TEXT = "Can't open ADD"; GOSUB ERROR; STOP
OPEN "STX" TO STX.FILE ELSE TEXT = "Can't open STX"; GOSUB ERROR; STOP
OPEN "STT" TO STT.FILE ELSE TEXT = "Can't open STT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
ADDRESSABLE = 1; SVC.CHANNELS = ""; VERSION = " (R:?.?)"; MULTI.COMMPORTS = 0
SERIAL.NUM = ""; NUM.SERVED = 1; PRIOR.STT.NUM = ""; ADD.TYPE = ""
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
MATREAD DVT FROM PAR.FILE,"DEVICE.TYPES" ELSE MAT DVT = ""
READ DEVICE.FUNCTIONS FROM PAR.FILE,"DEVICE.FUNCTIONS" ELSE DEVICE.FUNCTIONS = ""
READ CITIES FROM PAR.FILE,"CITIES" ELSE PRINT CLB:"Can't read PAR CITIES":; INPUT RSP:; STAT = 999; RETURN
READ DEVICE.STATUSES FROM PAR.FILE,"DEVICE.STATUSES" ELSE DEVICE.STATUSES = ""
CN = 1
LOOP WHILE DEVICE.STATUSES<1,CN> # "" DO
IF DEVICE.STATUSES<4,CN> = "Y" THEN DEVICE.STATUSES<4,CN> = 1 ELSE DEVICE.STATUSES<4,CN> = ""
CN = CN+1
REPEAT
READ COMMPORTS FROM PAR.FILE,"COMMPORTS" ELSE PRINT "Can't find COMMPORTS":; INPUT RSP:; STOP; *CUSTOM*
LN = 6
IF COUNT(COMMPORTS<1>,VM) THEN
VC = 1
LOOP COMMPORT = COMMPORTS<1,VC> UNTIL COMMPORT = "" DO
HEAD.NAME = COMMPORTS<2,VC>
PRINT @(15,LN):COMMPORT:"  ":HEAD.NAME:; LN = LN+1
VC = VC+1
REPEAT
LN = LN+2
END
VC = 0; FOUND = 0
*
IF COUNT(COMMPORTS<1>,VM) THEN MULTI.COMMPORTS = 1 ELSE MULTI.COMMPORTS = 0; COMMPORT = COMMPORTS<1,1>
IF MULTI.COMMPORTS THEN
RSP.RELOOP: *
PRINT @(15,LN):CLL:"Enter the Headend you are working on: ":; INPUT COMMPORT:
IF COMMPORT = "KILL" OR COMMPORT = "" THEN STOP
LOCATE COMMPORT IN COMMPORTS<1> BY "AL" SETTING COMMPORT.VM ELSE GOTO RSP.RELOOP
END ELSE
COMMPORT.VM = 1
END
*
COM.AI.ID = "AI.TYPE.":COMMPORT
MATREAD COM.AI FROM COM.FILE,COM.AI.ID ELSE
PRINT CLB:"Cannot proceed. The interface type has not been defined.":; INPUT TMP:; STOP
MAT COM.AI = EMPTY
END
PREFIX = COMMPORT
*
AC = ""; VC = ""; SC = ""; TEXT = ""
DIM TOP.DISP.LOC(7)
VALID.REFS = "TY":AM:"ID":AM:"CO":AM:"IA":AM:"ST":AM:"SA":AM:"AS"
*
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(OCONV(28-((LEN(CO.NAME)/2)),"MR0")):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
TITLE = "On Premise Device Maintenance for Headend ":COMMPORT:VERSION
PRINT @(0,1):RVB:(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""; STREET = ""; NUM.DEVICES = 1; AI.DOWN = ""; CITY.NUM = ""
GOSUB DISPLAY.BACKGROUND
SERIAL.NUM = ""; AIX.ID = ""; GOSUB GET.KEY; IF AIX.ID = "" THEN STOP
FIRST.AIX.ID = AIX.ID
AIX.TO.ID = AIX.ID
IF NOT(DISPLAY.ONLY) THEN
CALL SYS.ITM.LCK("AIX",FIRST.AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
END
IF STAT THEN GOTO UNLOCK
NEW.AIX = ""
MATREAD AIX FROM DVC.FILE,AIX.ID THEN NEW = "" ELSE NEW = 1; MAT AIX = ""
ADD.ID = AIX$INSTALLED.ADD.ID; PRIOR.ADD.ID = ADD.ID
MATREAD ADD FROM ADD.FILE,ADD.ID ELSE MAT ADD = ""
ADD.STAT = ADD$STAT
IF ADD.STAT = "H" THEN HOT.ADDRESS = 1 ELSE HOT.ADDRESS = 0
PRIOR.SERIAL.NUM = AIX$DVC.ID
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = AIX.ID; AIX.ID = "!":AIX.ID; GOSUB GET.KEY; AIX.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
AIX$STAT = "N"
GOSUB DISPLAY.FOREGROUND
AIX.TO.ID = ""
LOOP UNTIL AIX.TO.ID >= AIX.ID DO
AIX.TO.ID = SERIAL.NUM
CALL INPUT.DATA(AIX.TO.ID,43,3,"L15",1,"","","",RSP,STAT)
IF STAT THEN GOTO UNLOCK
TEXT = ""; AIX.TO.ID = PREFIX:"*":AIX.TO.ID
IF AIX.TO.ID # AIX.ID THEN
IF AIX.TO.ID < AIX.ID THEN TEXT = "must be same or greater"
IF LEN(AIX.TO.ID) # LEN(AIX.ID) THEN TEXT = "length must be the same"
IF TEXT # "" THEN GOSUB ERROR; AIX.TO.ID = "" ELSE
LNG1 = 1
LOOP UNTIL AIX.ID[1,LNG1] # AIX.TO.ID[1,LNG1] DO LNG1 = LNG1+1 REPEAT
LNG1=LNG1-1
AIX.ID.NUM = AIX.ID[LNG1+1,LEN(AIX.ID)-LNG1]
IF NOT(AIX.ID.NUM MATCHES "0N") THEN TEXT = "numbers not in same range"; GOSUB ERROR ELSE
AIX.TO.ID.NUM = AIX.TO.ID[LNG1+1,LEN(AIX.ID)-LNG1]
NUM.DEVICES = AIX.TO.ID.NUM-AIX.ID.NUM+1
PRINT @(60,3):NUM.DEVICES:" devices.":
TEST.ID = AIX.ID
LOOP
TEST.NUM = TEST.ID[LNG1+1,LEN(AIX.ID)-LNG1]+1
LOOP TEST.ID = TEST.ID[1,LNG1]:TEST.NUM UNTIL LEN(TEST.ID) = LEN(AIX.ID) DO
TEST.NUM = "0":TEST.NUM
REPEAT
READ TEST.ITEM FROM AIX.FILE,TEST.ID THEN
IF TEXT # "" THEN TEXT = TEXT:","
TEXT = TEXT:TEST.ID
END
UNTIL LEN(TEXT) > 45 OR TEST.ID >= AIX.TO.ID DO
REPEAT
IF TEXT # "" THEN TEXT = "on file: ":TEXT; GOSUB ERROR
END
END
END
IF TEXT # "" THEN AIX.TO.ID = ""
REPEAT
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
MAT AIX = MAT ADD.AIX
AIX$INSTALLED.ADD.ID = ""; AIX$SVC.ID = ""; AIX$SVC.ADD.ID = ""; AIX$ACT.ID = ""; AIX$CONN.OUTLETS = ""
AIX$STAT = "N"; AIX$DVC.ID = SERIAL.NUM; 
GOSUB DISPLAY.FOREGROUND
IF AIX$TYPE # "" THEN PRINT CLB:"The fields of the last added device are shown as default values...":
FOR REF = 1 TO 5
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
NEW.AIX = 1
MAT ADD.AIX = MAT AIX
IF AIX$INSTALLED.ADD.ID # "" THEN
PRINT CLB:"Enter 'KILL' or <cr> to update: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
MATWRITE AIX ON DVC.FILE,AIX.ID
GOSUB UPDATE.ADDRESS
END
END
!
CHANGES: *
PRINT CLB:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
GOSUB DEL.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE AIX.FILE,AIX.ID; GOTO UNLOCK
GOSUB DISPLAY.BACKGROUND
TEMP = AIX.ID; AIX.ID = "!":SERIAL.NUM; GOSUB GET.KEY; AIX.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = AIX.ID; AIX.ID = "!":SERIAL.NUM; GOSUB GET.KEY; AIX.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
IF (NEW.AIX) AND AIX$STAT<1,1> = "N" THEN MAT ADD.AIX = MAT AIX
TEXT = ""
LOOP
MATWRITE AIX ON DVC.FILE,AIX.ID
UNTIL AIX.ID = AIX.TO.ID DO
SERIAL.NUM = SERIAL.NUM+1; AIX$DVC.ID = SERIAL.NUM; AIX$INSTALLED.ADD.ID = ""; AIX.ID.NUM = AIX.ID.NUM+1
LOOP AIX.ID = AIX.ID[1,LNG1]:AIX.ID.NUM UNTIL LEN(AIX.ID) = LEN(AIX.TO.ID) DO
AIX.ID.NUM = "0":AIX.ID.NUM
REPEAT
PRINT @(22,3):SERIAL.NUM:
REPEAT
UPDATED = 1
!
UNLOCK: *
CALL SYS.ITM.RLS("AIX",FIRST.AIX.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
IF STAT = 999 THEN STOP
GOTO NEXT.ITEM
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,2):CLS:
PRINT @(0,3):RVB:"    Serial No.......":RVE:@(39,3):RVB:"To:":RVE:
PRINT @(0,5):RVB:"TY> Device Type.....":RVE:
PRINT @(0,6):RVB:"ID> Interface ID....":RVE:
PRINT @(0,7):RVB:"CO> Comments........":RVE:
PRINT @(0,8):RVB:"IA> Installed Addr..":RVE:
PRINT @(0,9):RVB:"ST> Status (O,I,N)..":RVE:
PRINT @(0,12):RVB:"SA> Addresses ":RVE:
PRINT @(43,12):RVB:"AS> Current Available Services ":RVE:
ADD.HDR = RVB:"# St ....Apt  House Street" "L#42":RVE
SVC.HDR = ADD.HDR:" ":RVB:"St Account# S# Service Outlet Tier St" "L#37":RVE
FULL.HDR = ADD.HDR:" ":RVB:"St Account# Services at address" "L#37":RVE
PRINT @(0,13):FULL.HDR:
RETURN
!
DISPLAY.FOREGROUND: *
IF AIX$TYPE # "" THEN
LOCATE AIX$TYPE IN DVT$DEVICE.TYPE<1> BY "AL" SETTING LOC THEN NUM.SERVED = DVT(7)<1,LOC> ELSE NUM.SERVED = 1
* NUM.SERVED = DVT(7)<1,LOC>
IF NUM.SERVED EQ 1 THEN
SVCS.DEFAULTS = COM.AI$DF.SVCS.ONE
COUT.DEFAULTS = COM.AI$DF.COUT.ONE
TIER.DEFAULTS = COM.AI$DF.TIER.ONE
END ELSE
SVCS.DEFAULTS = COM.AI$DF.SVCS.EIGHT
COUT.DEFAULTS = COM.AI$DF.COUT.EIGHT
TIER.DEFAULTS = COM.AI$DF.TIER.EIGHT
END
END
PRINT @(22,5):AIX$TYPE<1> "L#5":; LN = 5; GOSUB T01
PRINT @(22,6):AIX$DVC.ID<1> "L#10":
PRINT @(22,7):AIX$COMMENTS<1,1> "L#30":
TMP.ADD.ID = AIX$INSTALLED.ADD.ID
IF TMP.ADD.ID NE "" THEN ADD.TYPE = "I"; GOSUB D06; PRINT @(22,8):DISPLAY.ADDRESS "L30":
PRINT @(22,9):AIX$STAT<1> "L#1":
STAT.DESC = ""
IF AIX$STAT = "O" THEN STAT.DESC = "Installed and connected"; AIX.INSTALLED = 1 ELSE AIX.INSTALLED = 0
IF AIX$STAT = "N" THEN STAT.DESC = "Not installed"
IF AIX$STAT = "I" THEN STAT.DESC = "Installed and not connected"
PRINT @(25,9):CLL:STAT.DESC:
GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS
RETURN
!
DISPLAY.SVC.ADDRESSES: *
ADD.VC = 0; MAX.VC = NUM.SERVED+1; LN = 14; IF MAX.VC LT 9 THEN MAX.VC = 9
LOOP ADD.VC = ADD.VC+1 UNTIL ADD.VC = MAX.VC DO
TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>; ADD.LINE = ""; TMP.STAT = ""
IF TMP.ADD.ID NE "" THEN
ADD.TYPE = "D"; GOSUB D06
STREET = STREET:", ":CITY
ADD.LINE = " ":TMP.STAT "R#2":APT "R#8":HOUSE "R#7":" ":STREET "L#22"
END
IF ADD.VC GT NUM.SERVED THEN V.REF = " " ELSE V.REF = ADD.VC
PRINT @(0,LN):V.REF:ADD.LINE "L#32":
LN = LN+1
REPEAT
RETURN
!
DISPLAY.ADD.SVCS: *
PRINT @(0,13):FULL.HDR:
SVC.VC = 0; LN = 14; MAX.VC = NUM.SERVED+1; IF MAX.VC LT 9 THEN MAX.VC = 9
LOOP SVC.VC = SVC.VC+1 UNTIL SVC.VC = MAX.VC DO
ACT.ID = AIX$ACT.ID<1,SVC.VC>; FULL.ACT.ID = ""; ACT.STAT = ""
IF ACT.ID THEN 
CALL MOD11.DIGIT(ACT.ID,CD); FULL.ACT.ID = ACT.ID:"-":CD
READV ACT.STAT FROM ACT.FILE,ACT.ID,2 ELSE ACT.STAT = ""
END
SVC.LINE = " ":ACT.STAT:" ":FULL.ACT.ID "L#9"; SC = 1
LOOP UNTIL AIX$SVC.ID<1,SVC.VC,SC> = "" DO
CONN.OUTLETS = AIX$CONN.OUTLETS<1,SVC.VC,SC>
TIER.NUM     = AIX$TIERS<1,SVC.VC,SC>; IF TIER.NUM NE "" THEN TIER.NUM = "@":TIER.NUM
ADD.SVC = AIX$SVC.ID<1,SVC.VC,SC>; SVC.LINE = SVC.LINE:ADD.SVC:"\":CONN.OUTLETS:TIER.NUM
SC = SC+1; IF AIX$SVC.ID<1,SVC.VC,SC> NE "" THEN SVC.LINE = SVC.LINE:","
REPEAT
IF LEN(SVC.LINE) GT 37 THEN SVC.LINE = SVC.LINE[1,33]:"+"
PRINT @(43,LN):SVC.LINE "L#37":
LN = LN+1
REPEAT
RETURN
!
GET.KEY: *
CALL INPUT.DATA(AIX.ID,22,3,"L15",1,"","","",RSP,STAT)
IF AIX.ID NE "" THEN SERIAL.NUM = AIX.ID; AIX.ID = PREFIX:"*":AIX.ID
PRINT @(22,3):SERIAL.NUM:
IF STAT = 999 THEN RETURN
RETURN
!
GET.DATA: *
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07
RETURN
!
I01: PRE.TYPE = AIX$TYPE
* IF HOT.ADDRESS THEN RETURN
CALL INPUT.DATA(AIX$TYPE,22,5,"L5",1,"","EQ|@":DVT$DEVICE.TYPE:"@","",RSP,STAT)
IF STAT THEN RETURN ELSE LN = 5; GOSUB T01
IF AIX$DVC.ID # "" THEN
IF DVT$PROG.ADDR<1,TYPE.LOC> # "O" THEN AIX$DVC.ID = ""; PRINT @(22,8):SPACE(10):
END
LOCATE AIX$TYPE IN DVT$DEVICE.TYPE<1> BY "AL" SETTING LOC THEN NUM.SERVED = DVT(7)<1,LOC> ELSE NUM.SERVED = 1
IF AIX$TYPE = PRE.TYPE THEN RETURN
IF DVT$PROG.ADDR<1,TYPE.LOC> = "O" THEN ADDRESSABLE = 1 ELSE ADDRESSABLE = 0
IF NUM.SERVED EQ 1 THEN
SVCS.DEFAULTS = COM.AI$DF.SVCS.ONE
COUT.DEFAULTS = COM.AI$DF.COUT.ONE
TIER.DEFAULTS = COM.AI$DF.TIER.ONE
END ELSE
SVCS.DEFAULTS = COM.AI$DF.SVCS.EIGHT
COUT.DEFAULTS = COM.AI$DF.COUT.EIGHT
TIER.DEFAULTS = COM.AI$DF.TIER.EIGHT
END
RETURN
T01: TRN.FLD = AIX$TYPE<1>
LOCATE TRN.FLD IN DVT$DEVICE.TYPE<1> SETTING TYPE.LOC THEN TRN.FLD = DVT$DESCRIPTION<1,TYPE.LOC> ELSE TRN.FLD = ""
PRINT @(32,LN):TRN.FLD "L#25":
RETURN
TC02: PRINT @(32,LN):SPACE(12):; RETURN
RETURN
!
I02: *CUSTOM*
IF NOT(ADDRESSABLE) THEN RETURN
IF AIX$DVC.ID = "" THEN AIX$DVC.ID = SERIAL.NUM
CALL INPUT.DATA(AIX$DVC.ID,22,6,"L16",1,"","","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I02
IF AIX$DVC.ID = "" THEN TEXT = "you must enter something here" ELSE
END
IF TEXT # "" THEN
AIX$DVC.ID = PRIOR.SERIAL.NUM
GOSUB ERROR; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
GOTO I02
END
RETURN
!
I03: IF AIX.ID # AIX.TO.ID THEN RETURN ELSE CALL INPUT.DATA(AIX$COMMENTS,22,7,"L30",1:",":1,"","","",RSP,STAT); RETURN
!
I04: IF AIX.ID # AIX.TO.ID THEN RETURN ELSE PRINT @(22,8):; INPUT ID:
ID = TRIM(ID)
IF ID = "" THEN RETURN
IF ID = "\" THEN
AIX$INSTALLED.ADD.ID = ""; TMP.ADD.ID = ""; ID = ""
PRINT @(22,8):CLL:
INSTALL.ADDRESS = ""
END
IF ID = "KILL" THEN GOTO UNLOCK
LN = 8; COL = 53; GOSUB GET.ADDRESS
IF STAT THEN GOSUB DISPLAY.FOREGROUND; ID = ""; STAT = 0; GOTO I04
READV TMP.SERIAL.NUM FROM ADD.FILE,TMP.ADD.ID,23 ELSE TMP.SERIAL.NUM = ""
IF TMP.SERIAL.NUM EQ "" THEN
AIX$INSTALLED.ADD.ID = TMP.ADD.ID
IF NUM.SERVED = 1 THEN
PRIOR.SVC.ADD.ID = AIX$SVC.ADD.ID<1,1>
ADD.VC = 1; GOSUB UPDATE.ADDRESS; GOSUB LOAD.SERVICES
* IF AIX$SVC.ADD.ID<1,1> = "" THEN AIX$SVC.ADD.ID<1,1> = TMP.ADD.ID
END
END ELSE
PRINT CLB:"The address is already served by Serial No. ":TMP.SERIAL.NUM:; INPUT TMP:
TMP.ADD.ID = ""; ID = ""; INSTALL.ADDRESS = ""
PRINT @(22,8):CLL:
GOTO I04
END
PRINT @(22,8):CLL:INSTALL.ADDRESS:; GOSUB DISPLAY.SVC.ADDRESSES
RETURN
!
I05: *
IF AIX.ID # AIX.TO.ID THEN GOTO STAT.EXIT ELSE PRIOR.STAT = AIX$STAT
CALL INPUT.DATA(AIX$STAT,22,9,"L1",1,"","OP":VM:"EQ:SVM:@":DEVICE.STATUSES<1>:"@","",RSP,STAT)
IF NOT(STAT) THEN
IF NOT(COUNT("INO",AIX$STAT)) THEN
PRINT CLB:"That is not a valid status for an On Premise device.":; INPUT TMP:
AIX$STAT = PRIOR.STAT
GOTO STAT.EXIT
END
IF AIX$STAT NE "O" THEN
IF COUNT(AIX$SVC.ADD.STAT<1>,"H") THEN
LOOP
PRINT CLB:"There are hot addresses on this device. Proceed anyway? (Y/<cr>: ":; INPUT RSP:
IF RSP = "KILL" OR RSP = "" THEN AIX$STAT = PRIOR.STAT; GOTO STAT.EXIT
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
END
END ELSE
IF AIX$INSTALLED.ADD.ID = "" THEN
TEXT = "Please enter the Installed Address first."
AIX$STAT = PRIOR.STAT
GOSUB ERROR
GOTO STAT.EXIT
END
END
END
STAT.EXIT: *
GOSUB DISPLAY.FOREGROUND
RETURN
!
GET.ADDRESS: *
IF ID = "" THEN DISPLAY.ADDRESS = SPACE(30); RETURN
APT = ""; POS = INDEX(ID,"-",1); IF POS THEN IF ID[POS+1,2] MATCHES "1N1X" THEN APT = ID[1,POS-1]; ID = ID[POS+1,99]
POS = INDEX(ID," ",1); HOUSE = ID[1,POS-1]; STREET = ID[POS+1,99]
LOOP WHILE HOUSE[1,1] = "0" DO HOUSE = HOUSE[2,99] REPEAT
POS = INDEX(STREET,",",1); IF POS THEN CITY = TRIM(STREET[POS+1,99]); STREET = STREET[1,POS-1] ELSE CITY = ""
POS = LEN(STREET); IF STREET[POS,1] = "." THEN POS = POS-1; STREET = STREET[1,POS]
LOOP UNTIL STREET[POS,1] = "" OR STREET[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
IF STREET[POS,999] MATCHES "0N" THEN TEXT = "Invalid ID type"; STAT = 1;  GOSUB ERROR; RETURN
INSTALL.ADDRESS = HOUSE:" ":STREET; IF APT # "" THEN INSTALL.ADDRESS = APT:"-":INSTALL.ADDRESS
IF CITIES<1,2> = "" THEN LOC = 1; CITY = CITIES<1,1> ELSE
LOOP
IF CITY = "" THEN
PRINT @(COL,LN):CLL:"Enter city: ":
INPUT CITY:; IF CITY = "KILL" THEN STAT = 999; GOTO UNLOCK
IF CITY = "" THEN TEXT = ""; STAT = 1; RETURN
END
LOCATE CITY IN CITIES<1> SETTING LOC ELSE LOC = 0
UNTIL LOC DO PRINT BELL:; CITY = "" REPEAT
END
CITY.NAME = CITIES<2,LOC>
INSTALL.ADDRESS = INSTALL.ADDRESS:", ":CITY
*
STX.ID = CITY:"*":STREET
MATREAD STX FROM STX.FILE,STX.ID ELSE TEXT = "Street not on file"; STAT = 1; GOSUB ERROR; PRINT @(22,8):SPACE(30):; RETURN
STREET = STX(1)
MATREAD STT FROM STT.FILE,STREET ELSE TEXT = "Street not on file"; STAT = 1; GOSUB ERROR; PRINT @(22,8):SPACE(30):; RETURN
*
MAT ADD = ""
TMP.ADD.ID = APT:"*":HOUSE:"*":STREET; REQUESTED.ADD.ID = TMP.ADD.ID
MATREAD ADD FROM ADD.FILE,TMP.ADD.ID THEN
RETURN
END ELSE
TEXT = "Invalid address. Please try again."; GOSUB ERROR
PRINT @(22,8):SPACE(50):
STAT = 1; RETURN
END
D06: * GENERATE DISPLAY ADDRESS
APT = FIELD(TMP.ADD.ID,"*",1)
HOUSE = FIELD(TMP.ADD.ID,"*",2)
STT.NUM = FIELD(TMP.ADD.ID,"*",3)
MATREAD STT FROM STT.FILE,STT.NUM THEN
PRIOR.STT.NUM = STT.NUM
STREET = STT$NAME
CITY = STT$CITY.NUM
END ELSE STREET = "Not on file"; CITY = ""
IF ADD.TYPE = "I" THEN TMP.STAT = "" ELSE TMP.STAT = AIX$SVC.ADD.STAT<1,ADD.VC>
DISPLAY.ADDRESS = HOUSE:" ":STREET:", ":CITY; IF APT NE "" THEN DISPLAY.ADDRESS = APT:" - ":DISPLAY.ADDRESS
ADD.TYPE = ""
RETURN
!
I06: * INPUT SERVICE ADDRESS
IF AIX$INSTALLED.ADD.ID = "" THEN
TEXT = "Please enter the Installed Address first"
GOSUB ERROR
RETURN
END
LOOP
PRINT CLB:"Enter # to change: ":; IF NUM.SERVED = 1 THEN ADD.VC = 1 ELSE INPUT ADD.VC:
IF ADD.VC = "" THEN RETURN
IF ADD.VC = "KILL" THEN GOTO UNLOCK
UNTIL ADD.VC <=  NUM.SERVED DO PRINT BELL: REPEAT
IF AIX$SVC.ADD.ID<1,ADD.VC> NE "" THEN
PRIOR.SVC.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>
TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>
END ELSE PRIOR.SVC.ADD.ID = ""
IF AIX$SVC.ADD.ID<1,ADD.VC> EQ "" AND AIX$INSTALLED.ADD.ID NE "" THEN
TMP.ADD.ID = AIX$INSTALLED.ADD.ID
END
GOSUB D06
TMP.APT = APT
TMP.HOUSE = HOUSE
TMP.STREET = STREET
TMP.CITY = CITY
CALL INPUT.DATA(TMP.APT,5,13+ADD.VC,"R7",1,"","","",RSP,STAT)
IF STAT THEN GOSUB DISPLAY.SVC.ADDRESSES; GOTO UNLOCK
CALL INPUT.DATA(TMP.HOUSE,13,13+ADD.VC,"R6",1,"","","",RSP,STAT)
IF STAT THEN GOSUB DISPLAY.SVC.ADDRESSES; GOTO UNLOCK
IF TMP.HOUSE NE "" THEN CALL INPUT.DATA(TMP.STREET,20,13+ADD.VC,"L25",1,"","","",RSP,STAT)
IF STAT THEN GOSUB DISPLAY.SVC.ADDRESSES; GOTO UNLOCK
IF TMP.HOUSE = "" THEN TMP.ADD.ID = "" ELSE
IF NOT(COUNT(TMP.STREET,",")) THEN TMP.STREET = TMP.STREET:",":CITY
ID = TMP.HOUSE:" ":TMP.STREET; IF TMP.APT NE "" THEN ID = TMP.APT:"-":ID
GOSUB GET.ADDRESS
IF STAT THEN
GOSUB DISPLAY.SVC.ADDRESSES
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I06
END
END
IF (TMP.ADD.ID = "" AND PRIOR.SVC.ADD.ID NE "") OR (TMP.ADD.ID NE "" AND TMP.ADD.ID NE PRIOR.SVC.ADD.ID) THEN
TMP.VC = 0
LOOP TMP.VC = TMP.VC+1 UNTIL AIX$SVC.ADD.ID<1,TMP.VC> = "" DO
IF AIX$SVC.ADD.ID<1,TMP.VC> = TMP.ADD.ID THEN
TEXT = "That address is already serviced by this device."
GOSUB ERROR; IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOSUB DISPLAY.SVC.ADDRESSES; GOTO I06
END
REPEAT
READV TMP.SERIAL.NUM FROM ADD.FILE,TMP.ADD.ID,23 ELSE TMP.SERIAL.NUM = ""
IF TMP.SERIAL.NUM NE "" THEN
TMP.NO = AIX.ID:"*":ADD.VC
IF TMP.NO NE TMP.SERIAL.NUM THEN
TEXT = "That address is already serviced by device ":TMP.SERIAL.NUM
GOSUB ERROR; GOSUB DISPLAY.SVC.ADDRESSES
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I06
END
END
END
LOOP
PRINT CLB:"Proceed with update of the service address (N/<cr>?: ":; INPUT RSP:
IF RSP = "KILL" THEN GOTO UNLOCK
IF RSP = "N" THEN GOSUB DISPLAY.SVC.ADDRESSES; RETURN
UNTIL RSP = "" DO PRINT BELL: REPEAT
GOSUB UPDATE.ADDRESS
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I06
!
UPDATE.ADDRESS: *
IF TMP.ADD.ID = "" AND PRIOR.SVC.ADD.ID NE "" THEN GOTO UPDATE.PRIOR
LOOP
LCK.TYPE = -1
CALL SYS.ITM.LCK("ADD",TMP.ADD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
WHILE STAT DO
PRINT CLB:CLL:"You must unlock ADD file - item ":TMP.ADD.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
AIX$SVC.ADD.ID<1,ADD.VC> = TMP.ADD.ID; AIX$SVC.ID<1,ADD.VC> = ""; AIX$ACT.ID<1,ADD.VC> = ""
AIX$SVC.ADD.STAT<1,ADD.VC> = ADD$STAT; ADD$AIX.ID = SERIAL.NUM
IF NUM.SERVED = 1 THEN ADD$AIX.LOCATION = 0 ELSE ADD$AIX.LOCATION = ADD.VC
MATWRITE ADD ON ADD.FILE,TMP.ADD.ID
CALL UNLCK.ITEM(ADD.FILE,"ADD",TMP.ADD.ID,LCK.FILE); * ULT ONLY
* UNLOCK ADD.FILE,TMP.ADD.ID; * REV ONLY
GOSUB LOAD.SERVICES
UPDATE.PRIOR: *
IF TMP.ADD.ID = "" THEN 
AIX$ACT.ID<1,ADD.VC> = ""; AIX$SVC.ID<1,ADD.VC> = ""; AIX$SVC.ADD.ID<1,ADD.VC> = ""
AIX$SVC.ADD.STAT<1,ADD.VC> = ""; AIX$CONN.OUTLETS<1,ADD.VC> = ""
AIX$TIERS<1,ADD.VC> = ""; AIX$TSTAT<1,ADD.VC> = ""
END
LOOP STAT = -1; CALL LCK.ITEM(ADD.FILE,"ADD",PRIOR.SVC.ADD.ID,LCK.FILE,STAT) WHILE STAT DO
PRINT CLB:CLL:"You must unlock ADD file - item ":PRIOR.SVC.ADD.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
WRITEV "" ON ADD.FILE,PRIOR.SVC.ADD.ID,23; WRITEV "" ON ADD.FILE,PRIOR.SVC.ADD.ID,24
CALL UNLCK.ITEM(ADD.FILE,"ADD",PRIOR.SVC.ADD.ID,LCK.FILE); * ULT ONLY
* UNLOCK ADD.FILE,PRIOR.SVC.ADD.ID; * REV ONLY
GOSUB DISPLAY.SVC.ADDRESSES
GOSUB DISPLAY.ADD.SVCS
* END
RETURN
!
LOAD.SERVICES: * GET SERVICES AT ADDRESS
IF TMP.ADD.ID = "" THEN
* PRINT CLB:"Clearing Services":
AIX$SVC.ID<1,ADD.VC> = ""
RETURN
END
MATREAD ADD FROM ADD.FILE,TMP.ADD.ID ELSE MAT ADD = ""
AA.VC = 1
IF AIX$SVC.ID<1,ADD.VC> = "" AND NUM.SERVED = 1 THEN
SVC.SC = 1
LOOP TMP.SVC.ID = SVCS.DEFAULTS<1,SVC.SC> UNTIL TMP.SVC.ID = "" DO
AIX$SVC.ID<1,ADD.VC,SVC.SC> = SVCS.DEFAULTS<1,SVC.SC>
AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC> = COUT.DEFAULTS<1,SVC.SC>
AIX$TIERS<1,ADD.VC,SVC.SC> = TIER.DEFAULTS<1,SVC.SC>
AIX$TSTAT<1,ADD.VC,SVC.SC> = 0
SVC.SC = SVC.SC+1
REPEAT
END
*
LOOP
ADD.ACT.ID = ADD$ACT.IDS<1,AA.VC>
IF ADD$ACT.FROM.DATES<1,AA.VC> NE "" THEN
MATREAD ACT FROM ACT.FILE,ADD.ACT.ID ELSE MAT ACT = ""
IF ACT$ADD.ID = TMP.ADD.ID THEN
AIX$ACT.ID<1,ADD.VC> = ADD.ACT.ID
IF ACT$STAT = "A" THEN
ADD.SC = 1; ACT.VC = 1
LOOP
UNTIL ACT$SERVICES<1,ACT.VC> = "" DO
SVC.ID = ACT$SERVICES<1,ACT.VC>
* MATREAD SVC FROM SVC.FILE,SVC.ID ELSE MAT SVC = ""
LOCATE SVC.ID IN AIX$SVC.ID<1,ADD.VC> SETTING LOC THEN
AIX$TSTAT<1,ADD.VC,LOC> = 1
END ELSE
IF NUM.SERVED = 1 THEN AIX$TSTAT<1,ADD.VC,LOC> = 0 ELSE
INS SVC.ID BEFORE AIX$SVC.ID<1,ADD.VC,LOC>
INS ACT$QNTYS<1,ACT.VC>      BEFORE AIX$CONN.OUTLETS<1,ADD.VC,LOC>
INS 1  BEFORE AIX$TSTAT<1,ADD.VC,LOC>
END
END
ACT.VC = ACT.VC+1
REPEAT
END
END
END
UNTIL ADD$ACT.FROM.DATES<1,AA.VC> NE "" OR ADD.ACT.ID = "" DO AA.VC = AA.VC+1 REPEAT
IF AIX$SVC.ID<1,ADD.VC> = "" AND NUM.SERVED # 1 THEN
SVC.SC = 1
LOOP TMP.SVC.ID = SVCS.DEFAULTS<1,SVC.SC> UNTIL TMP.SVC.ID = "" DO
AIX$SVC.ID<1,ADD.VC,SVC.SC> = SVCS.DEFAULTS<1,SVC.SC>
AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC> = COUT.DEFAULTS<1,SVC.SC>
AIX$TIERS<1,ADD.VC,SVC.SC> = TIER.DEFAULTS<1,SVC.SC>
AIX$TSTAT<1,ADD.VC,SVC.SC> = 0
SVC.SC = SVC.SC+1
REPEAT
END
GOSUB DISPLAY.ADD.SVCS
RETURN
!
I07: * INPUT SERVICES AND OUTLET QUANTITIES AT ADDRESS
LOOP
IF NUM.SERVED = 1 THEN ADD.VC = 1 ELSE PRINT CLB:@(0,23):"Enter Address # to change: ":; INPUT ADD.VC:
IF ADD.VC = "KILL" THEN GOTO UNLOCK; IF ADD.VC = "" THEN RETURN
UNTIL ADD.VC <=  NUM.SERVED DO PRINT BELL: REPEAT
IF AIX$SVC.ADD.ID<1,ADD.VC> = "" THEN
TEXT = "Please enter the Service Addresses first."
GOSUB ERROR
RETURN
END
READV TMP.STAT FROM ACT.FILE,AIX$ACT.ID<1,ADD.VC>,2 ELSE TMP.STAT = ""
PRIOR.SERVICE = AIX$SVC.ID<1,ADD.VC>
IF AIX$SVC.ID<1,ADD.VC> = "" THEN TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>; GOSUB LOAD.SERVICES; GOSUB D08; GOTO I07A
IF TMP.STAT = "A" THEN
GOSUB D08
TEXT = "You can't change the service of an active account"
GOSUB ERROR
GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS
IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I07
END
GOSUB D08
I07A: * INPUT SERVICE
LOOP
LOCATE "" IN AIX$SVC.ID<1,ADD.VC> SETTING NEXT.VC ELSE NULL
PRINT CLB:"Enter Service # to change, N(ext line), or <cr> to end: ":; INPUT RSP:
IF RSP = "" THEN GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS; IF NUM.SERVED = 1 THEN GOTO CHANGES ELSE GOTO I07
IF RSP MATCHES "0N" THEN IF RSP LE NEXT.VC THEN SVC.SC = RSP ELSE GOTO I07A
IF RSP = "N" THEN SVC.SC = NEXT.VC
LN = SVC.SC+13; AIX.SVC = AIX$SVC.ID<1,ADD.VC,SVC.SC>
CALL INPUT.DATA(AIX.SVC,58,LN,"L8",1,"","","",RSP,STAT)
IF STAT THEN RETURN
IF AIX.SVC = AIX$SVC.ID<1,ADD.VC,SVC.SC> THEN GOTO I07B
IF AIX.SVC NE "" THEN
MATREAD SVC FROM SVC.FILE,AIX.SVC ELSE
TEXT = "No such service"; GOSUB ERROR; AIX$SVC.ID<1,ADD.VC> = PRIOR.SERVICE
GOSUB D08; GOTO I07A
END
LOCATE AIX.SVC IN AIX$SVC.ID<1,ADD.VC> BY "AL" SETTING SVC.SC ELSE
INS AIX.SVC BEFORE AIX$SVC.ID<1,ADD.VC,SVC.SC>
INS "" BEFORE AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC>
INS "" BEFORE AIX$TIERS<1,ADD.VC,SVC.SC>
INS "" BEFORE AIX$TSTAT<1,ADD.VC,SVC.SC>
END
I07B: * INPUT OUTLET QUANTITY
CALL INPUT.DATA(AIX$CONN.OUTLETS,68,LN,"L6","1,":ADD.VC:",":SVC.SC,"","","",RSP,STAT)
IF STAT THEN RETURN
* INPUT TIER NUMBER
CALL INPUT.DATA(AIX$TIERS,75,LN,"L1","1,":ADD.VC:",":SVC.SC,"","","",RSP,STAT)
AIX$TSTAT<1,ADD.VC,SVC.SC> = 0
IF STAT THEN RETURN ELSE GOSUB D08; GOTO I07A
END ELSE
DEL AIX$SVC.ID<1,ADD.VC,SVC.SC>
DEL AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC>
DEL AIX$TIERS<1,ADD.VC,SVC.SC>
DEL AIX$TSTAT<1,ADD.VC,SVC.SC>
GOSUB D08; GOTO I07A
END
UNTIL RSP = "" DO REPEAT
GOSUB DISPLAY.SVC.ADDRESSES; GOSUB DISPLAY.ADD.SVCS
RETURN
D08: * DISPLAY SERVICES AT AN ADDRESS
LN = 14; SVC.SC = 1; MAX.SC = NUM.SERVED+1; IF MAX.SC LT 9 THEN MAX.SC = 9
PRINT @(0,13):SVC.HDR:
* ID = AIX$ACT.ID<1,ADD.VC>; FULL.ACT.ID = ""
* IF ID THEN CALL MOD11.DIGIT(ID,CD); FULL.ACT.ID = ID:"-":CD
LOOP
ADD.SVC = AIX$SVC.ID<1,ADD.VC,SVC.SC> "L#8"
ADD.OUTLETS = AIX$CONN.OUTLETS<1,ADD.VC,SVC.SC> "R#6"
ADD.TIER = AIX$TIERS<1,ADD.VC,SVC.SC> "R#5"
ADD.TSTAT = AIX$TSTAT<1,ADD.VC,SVC.SC> "R#3"
IF SVC.SC = 1 THEN
TMP.ADD.ID = AIX$SVC.ADD.ID<1,ADD.VC>; ADD.LINE = ""; TMP.STAT = ""
IF TMP.ADD.ID NE "" THEN
GOSUB D06
STREET = STREET:", ":CITY
ADD.LINE = " ":TMP.STAT "R#2":APT "R#8":HOUSE "R#7":" ":STREET "L#22"
END ELSE
ADD.LINE = ""
END
PRINT @(0,LN):ADD.VC:ADD.LINE "L#32":
ID = AIX$ACT.ID<1,ADD.VC>; FULL.ACT.ID = ""; ACT.STAT = ""
IF ID THEN 
CALL MOD11.DIGIT(ID,CD); FULL.ACT.ID = ID:"-":CD
READV ACT.STAT FROM ACT.FILE,ID,2 ELSE ACT.STAT = ""
END ELSE ACT.STAT = ""
PRINT @(43,LN):" ":ACT.STAT:" ":FULL.ACT.ID "L#9":
END ELSE
PRINT @(0,LN):CLL:
END
SVC.LN = " ":SVC.SC:" ":ADD.SVC:ADD.OUTLETS:ADD.TIER:ADD.TSTAT
PRINT @(55,LN):SVC.LN:
LN = LN+1
SVC.SC = SVC.SC+1
UNTIL AIX$SVC.ID<1,ADD.VC,SVC.SC> = "" DO REPEAT
LOOP UNTIL SVC.SC GE MAX.SC DO
PRINT @(0,LN):CLL:
LN = LN+1; SVC.SC = SVC.SC+1
REPEAT
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:; TEXT = ""
RETURN
!
DEL.CALL: *
* DELETE ONLY IF BILLING STATUS IS NOT INSTALLED
IF AIX.INSTALLED THEN
TEXT = "You can't delete this device"; GOSUB ERROR; STAT = 1
END
RETURN
!
$INCLUDE IBP CLS.ROUTINE
END
~MAINT.EVENT.PVM.PVE~
*PROGRAM:           SH.MAINT.EVENT.PVM.PVE
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      16 MAR 94 22:08:47
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
*INPUT.END*
*
*
SCR.ID = "MAINT.EVENT.PVM.PVE"
RELEASE.ID = "2"
REF = ONE; REDISP = FALSE; NEW = FALSE
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
*
OPEN "COM" TO COM.FILE ELSE
PRINT CLB:"COM File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "CNT" TO CNT.FILE ELSE
PRINT CLB:"CNT File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "PAR" TO PAR.FILE ELSE
PRINT CLB:"PAR File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:"ACC File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
*
*REF.LNS*
DIM TDL(1)
VALID.REFS = "CH"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "PVM" TO PVM.FILE ELSE TEXT = "Can't open PVM"; GOSUB ERROR; STOP
OPEN "COM" TO COM.FILE ELSE TEXT = "Can't open COM"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
*READ.LNS*
I01.MAX = 999
READ PPV.EVENT.CLASSES FROM COM.FILE,"PPV.EVENT.CLASSES" ELSE PPV.EVENT.CLASSES = EMPTY
READ PPV.RATE.CLASSES FROM COM.FILE,"PPV.RATE.CLASSES" ELSE PPV.RATE.CLASSES = EMPTY
*
*
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*READ.END*
CALL SH.SUBR.SCR.MAINT.EVENT.PVM.PVE(PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM,LCK.FILE,MAT TDL,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,POS.LOC,POS.REF)
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
*SCR.END*
*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
*MAIN.LNS*
NEXT.ITEM: *
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY; GOSUB GET.KEY
IF PVM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN GOTO FINISH
IF NOT(DISP.ONLY) THEN
LOOP
CALL SYS.ITM.LCK("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
MATREAD PVM FROM PVM.FILE,PVM.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT PVM = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
TEXT = "Not on file"; GOSUB ERROR; GOTO UNLOCK
END
*
!
*
CHANGES: *
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*
!
*
UPDATE: *
MATWRITE PVM ON PVM.FILE,PVM.ID
UPDATED = TRUE
*
!
*
UNLOCK: *
CALL SYS.ITM.RLS("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
!
*
FINISH: *
*
*FIN.LNS*
IF STAT EQ 999 THEN STOP
GOTO NEXT.ITEM
*FIN.END*
*MAIN.END*
*
!
*
DISP.BG: *
*
IF NOT(REDISP) THEN MAT TDL = EMPTY
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                         PPV Event Details Maintenance                          ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Event:":RVE:"":
PRINT @(0,4):CLS:"                                                       ":RVB:"Defaults:":RVE:"":
PRINT @(0,6):CLS:"":RVB:"Sched. (YYMM):":RVE:"               ":RVB:"Ln#":RVE:" ":RVB:"..Date...":RVE:"  ":RVB:".Time":RVE:"  ":RVB:"Rate Cl.":RVE:"  ":RVB:"Sub. Cl.":RVE:"   ":RVB:"Event#":RVE:"":
PRINT @(0,7):CLS:"":RVB:"Distributor:  ":RVE:"":
PRINT @(0,8):CLS:"":RVB:"Studio:       ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"Channel Code: ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"Duration:     ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"Debut Date:   ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"Prog Class:   ":RVE:"":
PRINT @(0,13):CLS:"":RVB:"Mrkt Class:   ":RVE:"":
PRINT @(0,14):CLS:"":RVB:"Star Rating:  ":RVE:"":
PRINT @(0,15):CLS:"":RVB:"Guide Rating: ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
IF REDISP THEN
REDISP = 99
TEMP = PVM.ID; FOR ID.CN = ONE TO 1; PVM.ID.SAVE<ID.CN> = "!":PVM.ID.SAVE<ID.CN>; NEXT ID.CN; GOSUB GET.KEY; PVM.ID = TEMP
END
*
*
!
*
PRINT @(16,3):PVM$DESC "L#25":
PRINT @(47,3):PVM$CL "L#6":; LN = 3; GOSUB T01
PRINT @(16,6):PVM$PROGMO "L#4":
PRINT @(16,7):PVM$DISTR "L#6":
PRINT @(16,8):PVM$STUDIO "L#6":
PRINT @(16,9):PVM$CH.CODE "L#3":
PRINT @(16,10):OCONV(PVM$DUR,"MT") "L#5":
PRINT @(16,11):OCONV(PVM$DEBUT.DT,"D2") "L#9":
PRINT @(16,12):PVM$PROG.CL "L#6":
PRINT @(16,13):PVM$MRKT.CL "L#6":
PRINT @(16,14):PVM$STARS "L#1":
PRINT @(16,15):PVM$RATING "L#5":
PRINT @(52,5):PVM$RATE.CL "L#6":
PRINT @(62,5):PVM$RATE.CL.SUB "L#6":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01; IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 1
ON ID.CN GOSUB K01
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PVM.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
FOR ID.CN = ONE TO 1
IF ID.CN EQ ONE THEN PVM.ID = PVM.ID.SAVE<ID.CN> ELSE PVM.ID = PVM.ID:PVM.ID.SAVE<ID.CN>
NEXT ID.CN
*
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+MAINT.EVENT.PVM.PVE: ":PVM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PVM.ID.SAVE<1>
CALL INPUT.DATA.SG1("PVM.ID","ID",FLD,8,3,"L6","6",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,8,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
PVM.ID.SAVE<1> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.EVENT.PVM.PVE(PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM,LCK.FILE,MAT TDL,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
I01: *
*
IF NEW THEN
LOCATE EMPTY IN PVM$PVE.DT<ONE> SETTING VC ELSE NULL
DYN = "N"
END ELSE
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
IF NOT(LN.LOC) THEN
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
END ELSE
DYN = TDL(1); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
LN.LOC = ZERO
END
IF DYN EQ EMPTY OR DYN = "^" THEN RETURN
IF DYN EQ "N" THEN
LOCATE EMPTY IN PVM$PVE.DT<ONE> SETTING VC ELSE NULL
END ELSE
IF NOT(DYN MATCHES "0N") THEN PRINT BELL:; GOTO I01
IF NOT(DYN) THEN PRINT BELL:; GOTO I01
VC = DYN
IF PVM$PVE.DT<ONE,VC> EQ EMPTY THEN PRINT BELL:; GOTO I01
LOOP
PRINT CLB:"Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
END
END
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN EQ "D" THEN
DEL PVM$PVE.DT<ONE,VC>
DEL PVM$PVE.TM<ONE,VC>
DEL PVM$PVE.RATE.CL<ONE,VC>
DEL PVM$PVE.RATE.CL.SUB<ONE,VC>
TDL(1) = -ABS(TDL(1))
DYN = "D"; GOSUB D01; IF STAT EQ 999 THEN RETURN
GOTO I01
END
END ELSE
IF VC GT I01.MAX THEN IF NEW AND DYN EQ "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is ":I01.MAX; GOSUB ERROR; GOTO I01
END
INS EMPTY BEFORE PVM$PVE.DT<ONE,VC>
INS EMPTY BEFORE PVM$PVE.TM<ONE,VC>
INS EMPTY BEFORE PVM$PVE.RATE.CL<ONE,VC>
INS EMPTY BEFORE PVM$PVE.RATE.CL.SUB<ONE,VC>
INS EMPTY BEFORE PVM$EVENT.NUMS<ONE,VC>
IF DYN EQ "I" THEN TDL(1) = -ABS(TDL(1)) ELSE IF NOT(TDL(1)) THEN TDL(1) = ONE
END
GOSUB D01; IF STAT EQ 999 THEN RETURN
LN = MOD(VC - ONE,14) + 7
FOR SUB.REF = ONE TO 4
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 4
END ELSE
IF SUB.REF EQ ONE THEN IF RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
GOTO I01
*
I01A: *
*
IF PVM$PVE.DT<ONE,VC> EQ " " THEN PVM$PVE.DT<ONE,VC> = EMPTY
PRINT @(30,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("PVM$PVE","18",PVM$PVE.DT,33,LN,"L9","9",ONE:",":VC,"D2","OP":VM:"OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,33,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF RSP EQ EMPTY THEN IF DYN NE "N" THEN PRINT BELL:; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("PVM$PVE","19",PVM$PVE.TM,44,LN,"L5","5",ONE:",":VC,"MT","OP":VM:"TM","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,44,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("PVM$PVE","23",PVM$PVE.RATE.CL,52,LN,"L6","6",ONE:",":VC,"","OP":VM:"EQ":SVM:"@":PPV.RATE.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,52,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("PVM$PVE","24",PVM$PVE.RATE.CL.SUB,62,LN,"L6","6",ONE:",":VC,"","OP":VM:"EQ":SVM:"@":PPV.RATE.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,62,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
D01: *
*
SAVE.VC = VC; SAVE.LN = LN
IF TDL(1) LT ZERO OR REDISP THEN TDL(1) = ABS(TDL(1)) ELSE
IF VC GE TDL(1) THEN IF VC LE TDL(1) + 13 THEN RETURN
END
IF TDL(1) THEN VC = VC-MOD(VC - ONE,14); CLEAR = ONE ELSE VC = ONE; CLEAR = ZERO
TOP.LOC = EMPTY; IF VC LT ONE THEN VC = ONE
LOOP
FOR LN = 7 TO 20 UNTIL PVM$PVE.DT<ONE,VC> = EMPTY
IF LN EQ 7 THEN TOP.LOC = VC
PRINT @(30,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":OCONV(PVM$PVE.DT<ONE,VC>,"D2") "L#9":
PRINT @(44,LN):OCONV(PVM$PVE.TM<ONE,VC>,"MT") "L#5":
PRINT @(52,LN):PVM$PVE.RATE.CL<ONE,VC> "L#6":
PRINT @(62,LN):PVM$PVE.RATE.CL.SUB<ONE,VC> "L#6":
PRINT @(73,LN):PVM$EVENT.NUMS<ONE,VC> "L#4":
VC = VC + ONE
NEXT LN
IF TDL(1) OR PVM$PVE.DT<ONE,VC> EQ EMPTY THEN RSP = EMPTY ELSE
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP EQ "RE" THEN VC = ONE; RSP = "Y"
IF RSP EQ "P" THEN
VC = TOP.LOC - 14
IF VC LT ZERO THEN VC = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
WHILE RSP = "Y" DO LN = 7; GOSUB C01 REPEAT
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TDL(1) = TOP.LOC
VC = SAVE.VC; LN = SAVE.LN
RETURN
C01: *
FOR LN = LN TO 20
PRINT @(30,LN):SPACE(12):
PRINT @(44,LN):SPACE(5):
PRINT @(52,LN):SPACE(6):
PRINT @(62,LN):SPACE(6):
PRINT @(73,LN):SPACE(4):
NEXT LN
RETURN
*
!
*
T01: *
*
TRN.FLD = PVM$CL
LOCATE TRN.FLD IN PPV.EVENT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.EVENT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(55,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(55,LN):SPACE(25):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~MAINT.PPV.EVENT.CLASS~
*PROGRAM:           MAINT.EVENT.CLASS
* AUTHOR:            H HORSMAN
* DATE WRITTEN:      16 SEP 92
!
INPUT DISPLAY.ONLY
VERSION = " (R:?.?)"
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(1)
VALID.REFS = "IN"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
PAR.ID = ""; GOSUB GET.KEY; IF PAR.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
END
IF STAT THEN GOTO UNLOCK
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = "" ELSE NEW = 1; PAR = ""
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 1
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT CLB:"Enter CHange, DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = 1
!
UNLOCK: *
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
TITLE = "PPV Event Classification Maintenance":VERSION
$INCLUDE IBP DISPLAY.SCREEN.HEADER
PRINT @(0,3):"                       ":RVB:"Class ":RVE:"   ":RVB:"Event Classification Name":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = ""; GOSUB D01; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
PAR.ID = "EVENT.CLASSIFICATIONS"
RETURN
!
GET.DATA: *
ON REF GOSUB I01
RETURN
!
I01:  PRINT CLB:"Enter CODE: ":
FLD = ""; CALL INPUT.DATA(FLD,12,23,"L6",1,"","SE}OP","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I01
IF FLD = "" THEN RETURN
LOCATE FLD IN PAR<1> BY "AL" SETTING VC THEN
PRINT CLB:FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL PAR<1,VC>
DEL PAR<2,VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
DYNAMIC = "D"; GOSUB D01; IF STAT = 999 THEN RETURN
GOTO I01
END
END ELSE
IF PAR<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I01
END
INS FLD BEFORE PAR<1,VC>
INS "" BEFORE PAR<2,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB D01; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,17)+4
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB I01B
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 2
NEXT SUB.REF
GOTO I01
I01A: CALL INPUT.DATA(PAR,23,LN,"L6",1:",":VC,"","","",RSP,STAT)
RETURN
I01B: CALL INPUT.DATA(PAR,32,LN,"L25",2:",":VC,"","","",RSP,STAT)
RETURN
D01: SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+16 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,17)+4; PRINT @(23,LN):PAR<1,VC> "L#6":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,17); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 4 TO 20 UNTIL PAR<1,VC> = ""
IF LN = 4 THEN TOP.LOC = VC
PRINT @(23,LN):PAR<1,VC> "L#6":
PRINT @(32,LN):PAR<2,VC> "L#25":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR PAR<1,VC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 4; GOSUB C01 REPEAT
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
C01: FOR LN = LN TO 20
PRINT @(23,LN):SPACE(6):
PRINT @(32,LN):SPACE(25):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~MAINT.PPV.RATES~
*PROGRAM:           MAINT.PPV.RATES
* VERSION: 920928 ?.?  NEW
*
* DERSCRIPTION:    MAINTAIN PPV RATES BY CLASSIFICATION
*
* COPYRIGHT       AXION COMPUTER SYSTEMS LTD.
*   1992             ALL RIGHTS RESERVED
!
INPUT DISPLAY.ONLY
*
VERSION = " (R:?.?)"
$INCLUDE IBP STANDARD.FUNCTIONS
*
DIM PPV.RTE(5)
EQUATE PPV.RTE$CLASS      TO PPV.RTE(1)
EQUATE PPV.RTE$DESC       TO PPV.RTE(2)
EQUATE PPV.RTE$RATE.AMT   TO PPV.RTE(3)
EQUATE PPV.RTE$RATE.AREAS TO PPV.RTE(4)
EQUATE PPV.RTE$TAX.NAMES  TO PPV.RTE(5)
*
$INCLUDE IBP TAX.DIM
$INCLUDE IBP TAX.EQUATES
*
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "TAX" TO TAX.FILE ELSE TEXT = "Can't open TAX"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ RATE.AREAS FROM PAR.FILE,"RATE.AREAS" ELSE RATE.AREAS = ""
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
* GOSUB MODIFY.ACTIVS; *CUSTOM*
*
AC = ""; RVC = ""; RSC = ""
DIM TOP.DISP.LOC(16)
VALID.REFS = "DS":AM:"RT":AM:"TX"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
*CUSTOM* GOSUB DISPLAY.BACKGROUND
PAR.ID = ""; GOSUB GET.KEY; IF PAR.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
END
IF STAT THEN GOTO UNLOCK
MATREAD PPV.RTE FROM PAR.FILE,PAR.ID THEN NEW = "" ELSE NEW = 1; MAT PPV.RTE = ""
GOSUB READ.CALL; IF STAT THEN GOTO UNLOCK
TITLE = "Pay Per View Rate Maintenance":VERSION
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
GOSUB DISPLAY.BACKGROUND; *CUSTOM*
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
PRINT @(25,3):PPV.RTE$CLASS<1,RVC> "L#5":
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 3
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT CLB:"Enter screen ref., DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
GOSUB DEL.CALL; IF STAT = 999 THEN GOTO UNLOCK ELSE IF STAT THEN GOTO CHANGES
GOTO UPDATE; *CUSTOM*
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
MATWRITE PPV.RTE ON PAR.FILE,PAR.ID
UPDATED = 1
!
UNLOCK: *
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
GOTO NEXT.ITEM; *CUSTOM*
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,3):CLS:
PRINT @(0,3):RVB:"    Rate Class .........":RVE:
PRINT @(0,5):RVB:"DS> Description.........":RVE:
PRINT @(0,7):RVB:"RT> Rate Amount ....... ":RVE:
PRINT @(0,10):RVB:"TX> Rate Area":RVE:
PRINT @(15,10):RVB:"Applicable Taxes (separate with commas)":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
PRINT @(25,3):PPV.RTE$CLASS<1,RVC> "L#5":
PRINT @(25,5):PPV.RTE$DESC<1,RVC> "L#30":; LN = 7; GOSUB T03
PRINT @(25,7):RATE.AMOUNT:
LN = 11; GOSUB D03
* DYNAMIC = ""; GOSUB D16; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
PAR.ID = "PPV.RATES"
RETURN
!
GET.DATA: *
ON REF GOSUB I01,I02,I03
RETURN
!
I01: CALL INPUT.DATA(PPV.RTE$DESC,25,5,"L30",1:",":RVC,"","","",RSP,STAT); RETURN
*
I02: CALL INPUT.DATA(PPV.RTE$RATE.AMT,25,7,"R8",1:",":RVC,"MD2","NU","",RSP,STAT)
IF STAT THEN RETURN ELSE LN = 7
GOSUB T03
RETURN
*
*#
I03:  PRINT CLB:"Enter rate area for tax: ":
FLD = ""; CALL INPUT.DATA(FLD,25,23,"L2",1,"","SE}OP}OP}LF|0|2}EQ|@":RATE.AREAS<1>:"@","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I03
IF FLD = "" THEN RETURN
LOCATE FLD IN PPV.RTE$RATE.AREAS<1,RVC> BY "AL" SETTING RSC THEN
PRINT CLB:"Ref. TX> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL PPV.RTE$RATE.AREAS<1,RVC,RSC>
DEL PPV.RTE$TAX.NAMES<1,RVC,RSC>
TOP.DISP.LOC(10) = -ABS(TOP.DISP.LOC(10))
DYNAMIC = "D"; GOSUB D03; IF STAT = 999 THEN RETURN
GOTO I03
END
END ELSE
IF PPV.RTE$RATE.AREAS<1,RVC,RSC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF RVC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I03
END
INS FLD BEFORE PPV.RTE$RATE.AREAS<1,RVC,RSC>
INS "" BEFORE PPV.RTE$TAX.NAMES<1,RVC,RSC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(10) = -ABS(TOP.DISP.LOC(10)) ELSE IF NOT(TOP.DISP.LOC(10)) THEN TOP.DISP.LOC(10) = 1
END
GOSUB D03; IF STAT = 999 THEN RETURN
LN = MOD(RSC-1,12)+11
FOR SUB.REF = 1 TO 1
ON SUB.REF GOSUB I03B
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 2
NEXT SUB.REF
GOTO I03
I03A: CALL INPUT.DATA(PPV.RTE$RATE.AREAS,15,LN,"L2",1:",":RVC:",":RSC,"","OP}LF|0|2}EQ|@":RATE.AREAS<1>:"@","",RSP,STAT)
RETURN
I03B: CALL INPUT.DATA(PPV.RTE$TAX.NAMES,15,LN,"L30",1:",":RVC:",":RSC,"","","",RSP,STAT)
*CUSTOM* FOLLOWING 5 LINES
TAX.NAMES = PPV.RTE$TAX.NAMES<1,RVC,RSC>; LOC = 1
LOOP TAX.NAME = FIELD(TAX.NAMES,",",LOC) UNTIL TAX.NAME = "" DO
IF TAX.NAME[1,1] = "+" THEN TAX.NAME = TAX.NAME[2,99]
MATREAD TAX FROM TAX.FILE,TAX.NAME ELSE TEXT = "Tax ":TAX.NAME:" is invalid"; GOSUB ERROR; GOTO I03B
LOC = LOC+1
REPEAT
RETURN
D03: SAVE.RSC = RSC
IF TOP.DISP.LOC(10) < 0 THEN TOP.DISP.LOC(10) = ABS(TOP.DISP.LOC(10)) ELSE
IF RSC >= TOP.DISP.LOC(10) THEN IF RSC <= TOP.DISP.LOC(10)+11 THEN
IF DYNAMIC = "N" THEN LN = MOD(RSC-1,12)+11; PRINT @(4,LN):PPV.RTE$RATE.AREAS<1,RVC,RSC> "L#3":
RETURN
END
END
IF TOP.DISP.LOC(10) THEN RSC = RSC-MOD(RSC-1,12); CLEAR = 1 ELSE RSC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 11 TO 21 UNTIL PPV.RTE$RATE.AREAS<1,RVC,RSC> = ""
IF LN = 11 THEN TOP.LOC = RVC
PRINT @(4,LN):PPV.RTE$RATE.AREAS<1,RVC,RSC> "L#3":
PRINT @(15,LN):PPV.RTE$TAX.NAMES<1,RVC,RSC> "L#30":
RSC = RSC+1
NEXT LN
IF TOP.DISP.LOC(10) OR PPV.RTE$RATE.AREAS<1,RVC,RSC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 11; GOSUB C03 REPEAT
IF CLEAR THEN GOSUB C03 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(10) = TOP.LOC
RSC = SAVE.RSC
RETURN
C03: FOR LN = LN TO 21
PRINT @(4,LN):SPACE(3):
PRINT @(15,LN):SPACE(30):
NEXT LN
RETURN
!
T03: RATE.AMOUNT  = OCONV(PPV.RTE$RATE.AMT<1,RVC>,"MR2M") "R#8"; RETURN
T04: PRINT @(4,LN):FLD "L#3":; RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
DEL.CALL: *
CLASS = PPV.RTE$CLASS<1,RVC>
*
* DELETE ONLY ONE RATE CLASS FROM ITEM
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN STAT = 1; RETURN
DEL PPV.RTE$CLASS<1,RVC>
DEL PPV.RTE$DESC<1,RVC>
DEL PPV.RTE$RATE.AMT<1,RVC>
DEL PPV.RTE$RATE.AREAS<1,RVC>
DEL PPV.RTE$TAX.NAMES<1,RVC>
RETURN
!
READ.CALL: *
TITLE = "Select Rate Class for Maintenance":VERSION
* DISPLAY WORK ORDER TYPES THEN SELECT ONE
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
TITLE<2> = RVB:"Rate ":RVE
TITLE<3> = RVB:"Class":RVE:"  ":RVB:"Description":RVE
PRINT @(2,3):TITLE<2>:@(42,3):TITLE<2>:
PRINT @(2,4):TITLE<3>:@(42,4):TITLE<3>:
IF NEW THEN MAT PPV.RTE = ""
VC = 1; CL = 2; LN = 5
LOOP CLASS = PPV.RTE$CLASS<1,VC> UNTIL CLASS = "" DO
PRINT @(CL,LN):CLASS "L#5":"  ":PPV.RTE$DESC<1,VC> "L#30":
LN = LN+1; IF LN > 20 THEN IF CL = 2 THEN CL = 42; LN = 5 ELSE VC = 999
VC = VC+1
REPEAT
PRINT @(10,22):CLL:"Enter Rate Class: ":
INPUT RSP:; IF RSP = "KILL" OR RSP = "" THEN
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STOP
END
IF RSP MATCHES "1N" THEN RSP = "0":RSP
IF NEW THEN PPV.RTE$CLASS<1,1> = RSP; RVC = 1; RETURN
LOCATE RSP IN PPV.RTE$CLASS<1> BY "AL" SETTING RVC THEN RETURN
NEW = 1
FOR AC = 1 TO 5
INS "" BEFORE PPV.RTE(AC)<1,RVC>
NEXT AC
PPV.RTE$CLASS<1,RVC> = RSP
RETURN
!
REMOVE.DIRECTION: *
DIRECTION = TRN.FLD[LEN(TRN.FLD),1]
IF DIRECTION # "+" THEN IF DIRECTION # "-" THEN RETURN
TRN.FLD = TRN.FLD[1,LEN(TRN.FLD)-1]
RETURN
END
~MAINT.TRANS.PPV~
*PROGRAM:           MAINT.TRANS.PPV
* AUTHOR:            H HORSMAN
* DESCRIPTION:       FROM SH.MAINT.TRANS.ADJ
* DATE WRITTEN:      23-MAR-93
!
INPUT DISPLAY.ONLY
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "PAR" TO PAR.FILE ELSE TEXT = "Can't open PAR"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = 0; * REV ONLY
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""
*
AC = ""; VC = ""; SC = ""
DIM TOP.DISP.LOC(1)
VALID.REFS = "TT"
!
NEXT.ITEM: *
STAT = ""; UPDATED = ""
GOSUB DISPLAY.BACKGROUND
PAR.ID = ""; GOSUB GET.KEY; IF PAR.ID = "" THEN STOP
IF NOT(DISPLAY.ONLY) THEN
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STAT = LCK.STAT
END
IF STAT THEN GOTO UNLOCK
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = "" ELSE NEW = 1; PAR = ""
IF NOT(NEW) THEN
GOSUB DISPLAY.FOREGROUND; IF STAT = 999 THEN GOTO UNLOCK
IF DISPLAY.ONLY THEN
LOOP
PRINT CLB:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP = "RE" DO
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
REPEAT
STOP
END
END ELSE
IF DISPLAY.ONLY THEN
PRINT CLB:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP = "" OR RSP = "N" THEN GOTO UNLOCK
UNTIL RSP = "Y" DO PRINT BELL: REPEAT
FOR REF = 1 TO 1
GOSUB GET.DATA
IF STAT = 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT > 0 THEN REF = REF-1 ELSE REF = REF-2; IF REF < 0 THEN REF = 0
NEXT REF
NEW = ""
END
!
CHANGES: *
PRINT CLB:"Enter CHange, DElete, REdisplay, KILL or <cr> to update: ":
INPUT RSP:
BEGIN CASE
CASE RSP = "KILL"; GOTO UNLOCK
CASE RSP = "END"; GOTO UNLOCK
CASE RSP = ""; GOTO UPDATE
CASE RSP = "DE"
PRINT CLB:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP # "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP = "RE"
GOSUB DISPLAY.BACKGROUND
TEMP = PAR.ID; PAR.ID = "!":PAR.ID; GOSUB GET.KEY; PAR.ID = TEMP
GOSUB DISPLAY.FOREGROUND
CASE RSP = "CH"; REF = 1; GOSUB GET.DATA
CASE 1; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT = 999 THEN GOTO UNLOCK
GOTO CHANGES
!
UPDATE: *
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = 1
!
UNLOCK: *
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
STOP
!
DISPLAY.BACKGROUND: *
MAT TOP.DISP.LOC = ""
PRINT @(0,0):CLS:
PRINT @(0,0):RVB:OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME)+1)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":RVE:
PRINT @(0,1):RVB:"                 Pay Per View Transaction Types Maintenance                     ":RVE:
PRINT @(0,3):RVB:"Type":RVE:"        ":RVB:"Statement description":RVE:"         ":RVB:"  Late notice?":RVE:"    ":RVB:"Following trans type":RVE:
RETURN
!
DISPLAY.FOREGROUND: *
DYNAMIC = ""; GOSUB D01; IF STAT = 999 THEN RETURN
RETURN
!
GET.KEY: *
PAR.ID = "TRANS.TYPES.PPV"
RETURN
!
GET.DATA: *
ON REF GOSUB I01
RETURN
!
I01:  PRINT CLB:"Enter transaction type: ":
FLD = ""; CALL INPUT.DATA(FLD,24,23,"L2",1,"","SE":VM:"OP":VM:"LF":SVM:"0":SVM:"2","",RSP,STAT)
IF STAT = 999 THEN RETURN
IF STAT THEN TEXT = RSP<2>; GOSUB ERROR; GOTO I01
IF FLD = "" THEN RETURN
LOCATE FLD IN PAR<1> BY "AL" SETTING VC THEN
PRINT CLB:FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
IF RSP # "Y" THEN DYNAMIC = ""; PRINT CLB: ELSE
DEL PAR<1,VC>
DEL PAR<2,VC>
DEL PAR<4,VC>
DEL PAR<3,VC>
TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1))
DYNAMIC = "D"; GOSUB D01; IF STAT = 999 THEN RETURN
GOTO I01
END
END ELSE
IF PAR<1,VC> = "" THEN DYNAMIC = "N" ELSE DYNAMIC = "I"
IF VC > 99 THEN IF NEW AND DYNAMIC = "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is 99"; GOSUB ERROR; GOTO I01
END
INS FLD BEFORE PAR<1,VC>
INS "" BEFORE PAR<2,VC>
INS "" BEFORE PAR<4,VC>
INS "" BEFORE PAR<3,VC>
IF DYNAMIC = "I" THEN TOP.DISP.LOC(1) = -ABS(TOP.DISP.LOC(1)) ELSE IF NOT(TOP.DISP.LOC(1)) THEN TOP.DISP.LOC(1) = 1
END
GOSUB D01; IF STAT = 999 THEN RETURN
LN = MOD(VC-1,17)+4
FOR SUB.REF = 1 TO 3
ON SUB.REF GOSUB I01B,I01C,I01D
IF STAT = 999 THEN RETURN
IF STAT THEN IF STAT > 0 THEN SUB.REF = SUB.REF-1 ELSE SUB.REF = SUB.REF-2; IF SUB.REF < 0 THEN SUB.REF = 4
NEXT SUB.REF
GOTO I01
I01A: CALL INPUT.DATA(PAR,0,LN,"L2",1:",":VC,"","LF":SVM:"0":SVM:"2","",RSP,STAT)
RETURN
I01B: CALL INPUT.DATA(PAR,12,LN,"L25",2:",":VC,"","","",RSP,STAT)
RETURN
I01C: CALL INPUT.DATA(PAR,42,LN,"L1",4:",":VC,"","DF":SVM:"N":VM:"EQ":SVM:"Y":SVM:"N","",RSP,STAT)
RETURN
I01D: CALL INPUT.DATA(PAR,60,LN,"L2",3:",":VC,"","OP":VM:"LF":SVM:"0":SVM:"2","",RSP,STAT)
RETURN
D01: SAVE.VC = VC
IF TOP.DISP.LOC(1) < 0 THEN TOP.DISP.LOC(1) = ABS(TOP.DISP.LOC(1)) ELSE
IF VC >= TOP.DISP.LOC(1) THEN IF VC <= TOP.DISP.LOC(1)+16 THEN
IF DYNAMIC = "N" THEN LN = MOD(VC-1,17)+4; PRINT @(0,LN):PAR<1,VC> "L#2":
RETURN
END
END
IF TOP.DISP.LOC(1) THEN VC = VC-MOD(VC-1,17); CLEAR = 1 ELSE VC = 1; CLEAR = 0
TOP.LOC = ""
LOOP
FOR LN = 4 TO 20 UNTIL PAR<1,VC> = ""
IF LN = 4 THEN TOP.LOC = VC
PRINT @(0,LN):PAR<1,VC> "L#2":
PRINT @(12,LN):PAR<2,VC> "L#25":
PRINT @(42,LN):PAR<4,VC> "L#1":
PRINT @(60,LN):PAR<3,VC> "L#2":
VC = VC+1
NEXT LN
IF TOP.DISP.LOC(1) OR PAR<1,VC> = "" THEN RSP = "" ELSE
PRINT CLB:"Display more (Y/<cr>)? ":
INPUT RSP:; IF RSP = "KILL" THEN STAT = 999; RETURN
END
WHILE RSP = "Y" DO LN = 4; GOSUB C01 REPEAT
IF CLEAR THEN GOSUB C01 ELSE CLEAR = 1
IF TOP.LOC THEN TOP.DISP.LOC(1) = TOP.LOC
VC = SAVE.VC
RETURN
C01: FOR LN = LN TO 20
PRINT @(0,LN):SPACE(2):
PRINT @(12,LN):SPACE(25):
PRINT @(42,LN):SPACE(1):
PRINT @(60,LN):SPACE(2):
NEXT LN
RETURN
!
ERROR: *
IF TEXT = "" THEN RETURN
PRINT BELL:CLB:TEXT[1,80]:; IF LEN(TEXT) < 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
!
END
~PPV.BILLING~
XSUBROUTINE PPV.BILLING(LCK.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,STAT,LCK.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ,BATCH.HEADER,CONTROL.DATE,A.PERIOD,BATCH.NUM,ENTRY.TYPE,SINGLE,ACT.ID,PVM.ID)
*PROGRAM:   PPV.BILLING
* VERSION: 930728 ?.2  ADDED REPORT.PERIOD TO RPT.ID.
* PRIOR: 920916 ?.?  NEW
* DESCRIPTION: PER PER VIEW BILLING
*              1) PROCESSES A BATCH OF PAY PER VIEW TRANSACTIONS
*              2) GENERATES A PPV BILLING TRANSACTION FOR EACH TRANSACTION 
*                 PLACING THE TOTAL AMOUNT IN THE CAJ TRANSACTION.
*              3) UPDATES ACCOUNT'S ATR FOR EACH TRANSACTION
*              4) UPDATES ACG FOR THE BATCH
*              NOTES:
*              UPDATING OF ACG IS BYPASSED IN CASH.LIST.POST
*              BATCH IS LISTED BY CASH.LIST.POST
* TESTING:     USES LOAD.TST
*              CNT.TST$X WILL NOT WRITE ATR,ACT,ACG
*              IN TRANS.LIST.POST.
*
VS = "1.2"; RELEASE = " (1.2)"
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP ACG.DIM
$INCLUDE IBP ACG.EQUATES
$INCLUDE IBP SAVE.ACG.DIM
$INCLUDE IBP SAVE.ACG.EQUATES
$INCLUDE IBP ATR.DIM
$INCLUDE IBP ATR.EQUATES
$INCLUDE IBP RTE.DIM
$INCLUDE IBP RTE.EQUATES
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP TAX.DIM
$INCLUDE IBP TAX.EQUATES
$INCLUDE IBP RPT.PPV.DIM
$INCLUDE IBP RPT.PPV.EQUATES
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
!
DIM TAX.TABLE(5); MAT TAX.TABLE = ""; STUDIO = ""; * RESERVED
*
CALL BILLING.SUBR.OPEN(STAT,ACT.FILE,ACG.FILE,ATR.FILE,ATH.FILE,ADD.FILE,EFT.FILE,SVC.FILE,RTE.FILE,TAX.FILE,PAR.FILE,CNT.FILE,LCK.FILE)
OPEN "PVM" TO PVM.FILE ELSE PRINT CLB:"Can't open PVM":; INPUT TMP:
OPEN "CAJ" TO CAJ.FILE ELSE PRINT CLB:"Can't open CAJ":; INPUT TMP:
OPEN "PPV.RPT" TO RPT.FILE ELSE PRINT CLB:"Can't open RPT":; INPUT TMP:
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:
* LCK.F = 0; * REV ONLY
*
READ A.PERIOD FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE A.PERIOD = ""
*
READV CURR.PER FROM COM.FILE,"CURR.PPV.REPORT.PERIOD",2 ELSE CURR.PER = A.PERIOD
DAY = 31; MTH = CURR.PER[3,2]; YEAR = CURR.PER[1,2]
LOOP
CURR.PER.END.DATE = ICONV(MTH:" ":DAY:" ":YEAR,"D")
WHILE CURR.PER.END.DATE EQ "" DO DAY = DAY-1 REPEAT
*
NEXT.PER = CURR.PER+1
IF NEXT.PER[3,2] > 12 THEN NEXT.PER = NEXT.PER+88
*
SYS.APPL.SUB = "BI"; CNT.TST.ID = SYS.APPL.SUB
GOSUB LOAD.TST
*
LCK.TYPE = -3
CDT = CONTROL.DATE; T.RUN.START = TIME(); CTD = DATE(); B.F.DATE = ""; B.CTR = 0
T.EVENT.RENT = 0; E.CTR = 0; TRAN.ERR = ""; EQU CAJ.ERROR TO 1; SNGL = 0; * TEMPORARY
ST.ZONE = ""; ZONE = ""; MAT ACG = ""; B.NET = 0; AMOUNT = 0
TAX.READ = 0; MTH = ""; DAY = ""; YEAR = ""; LAST.RATE.AREA = ""; CAJ.ERRORS = 0
!
*
** BATCH.SOURCE = FIELD(BATCH.HEADER,"*",1)
** BATCH.STATUS = FIELD(BATCH.HEADER,"*",2)
** ENTRY.DATE = FIELD(BATCH.HEADER,"*",3); * IS GENERATE DATE
** ENTRY.TIME = FIELD(BATCH.HEADER,"*",4); * IS GENERATE TIME
** POST.DATE = FIELD(BATCH.HEADER,"*",5)
** POST.TIME = FIELD(BATCH.HEADER,"*",6)
** BUS.DATE = FIELD(BATCH.HEADER,"*",7)
** EFF.DATE = FIELD(BATCH.HEADER,"*",8)
** BATCH.TOTAL = 0
** ENTERED.TOTAL = 0
** ADJUST.TOTAL = FIELD(BATCH.HEADER,"*",11)
** DEFAULT.TYPE = FIELD(BATCH.HEADER,"*",12)
** ITEM.COUNT = FIELD(BATCH.HEADER,"*",13)
** OPER = FIELD(BATCH.HEADER,"*",14)
** DEL.STATUS = FIELD(BATCH.HEADER,"*",15)
** LPT.DATE = FIELD(BATCH.HEADER,"*",16)
** LPT.TM = FIELD(BATCH.HEADER,"*",17)
** CLASS = FIELD(BATCH.HEADER,"*",18)
** INP.SOURCE = FIELD(BATCH.HEADER,"*",19)
** BATCH.LST = FIELD(BATCH.HEADER,"*",20)
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
OPER = OPERATOR
TDY = DATE()
TMP = OCONV(TDY,"D2-")
MTH = TMP[1,2]
DAY = TMP[4,2]
YEAR = TMP[7,2]
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:
LOOP
ACCTG.DATE = ICONV(MTH:"-":DAY:"-":YEAR,"D")
UNTIL ACCTG.DATE DO
DAY = DAY-1
REPEAT
!
START: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering PPV.BILLING. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
AC = 1
PRINT @(10,16):"Validating PPV Event Numbers":
*
LOOP TRAN = CAJ<AC> UNTIL TRAN = "" DO
*
TRAN.EVENTS = TRAN<1,8>
SVC = 1
LOOP TRAN.EVENT = TRAN.EVENTS<1,1,SVC> UNTIL TRAN.EVENT = "" DO
PVE.ID = TRAN.EVENT
MATREAD PVE FROM PVE.FILE,PVE.ID ELSE 
MAT PVE = ""
INS "Invalid PPV Event Number ":TRAN.EVENT BEFORE CAJ<AC,7,SVC>
CAJ<AC,20,SVC> = CAJ.ERROR
CAJ.ERRORS = CAJ.ERRORS+1
IF CNT.TST$ID THEN
PRINT @(0,17):CAJ<AC,7,SVC>:
IF CNT.TST$CR THEN PRINT CLB:"Enter <cr>: ":; INPUT TMP:
END
END; * of PVE not on file
*
IF NOT(CAJ<AC,20,SVC>) THEN
PVM.ID = PVE$PVM.ID
MATREAD PVM FROM PVM.FILE,PVM.ID ELSE
INS "Invalid PPV Master Event" BEFORE CAJ<AC,7,SVC>
CAJ.ERRORS = CAJ.ERRORS+1
CAJ<AC,20,SVC> = CAJ.ERROR
IF CNT.TST$LBL THEN
PRINT @(0,18):CAJ<AC,7,SVC>:
IF CNT.TST$CR THEN PRINT CLB:"Enter <cr>: ":; INPUT TMP:
END
END
END
IF CAJ.ERRORS THEN PRINT @(10,19):"Errors detected: ":CAJ.ERRORS "R#6":
*
SVC = SVC+1
REPEAT
*
AC = AC+1
REPEAT
*
IF NOT(SINGLE) THEN
AC = 1
LOOP TRAN = CAJ<AC> UNTIL TRAN = "" DO
*
ACT.ID = TRAN<1,1>; CD = ACT.ID[7,1]; ACT.ID = ACT.ID[1,6]
TRAN.TYPE = TRAN<1,2>
IF TRAN.TYPE = "" THEN TRAN.TYPE = DEFAULT.TYPE
TRAN.AMOUNT = TRAN<1,3>
TRAN.DESC = TRAN<1,4>
TRAN.OLD.ACT = TRAN<1,5>
TRAN.MESSAGES = TRAN<1,6>
TRAN.ERRORS = TRAN<1,7>
TRAN.EVENTS = TRAN<1,8>
TRAN.RSVD = TRAN<1,9>
TRAN.POST = TRAN<1,10>
TRAN.ERR  = TRAN<1,20>
*
GOSUB BILL.ACT
PRINT @(5,15):CLL:"Uploads processed: ":B.CTR "R#5":" Events: ":E.CTR "R#5":
*
AC = AC+1
REPEAT
END ELSE
GOSUB BILL.ACT
END
GOTO FINISH
!
BILL.ACT: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering BILL.ACT. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
LOOP
CALL SYS.ITM.LCK("ACT",ACT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ACT file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
LOOP
CALL SYS.ITM.LCK("ATR",ACT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock ATR file - item ":ACT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
MATREAD ACT FROM ACT.FILE,ACT.ID THEN
*
RATE.TYPE = ACT$RATE.TYPE
PRINT @(10,11):CLL:"Now posting transaction on account no. ":ACT.ID:"-":CD
MATREAD ATR FROM ATR.FILE,ACT.ID ELSE MAT ATR = ""
READV GEO FROM ADD.FILE,ACT$ADD.ID,12 ELSE GEO = ""
ZONE = FIELD(GEO,"*",1); IF LEN(ZONE) = 1 THEN ZONE = "0":ZONE
*
*
T.EVENT.RENT = 0; TTX.AMTS = ""; TAX.NAMES = ""; TAX.AMTS = ""; CALC.TAX.AMT = ""; COMPOUND.AMT = ""
TRNT = ""; TTX.NAMES = ""; MTHLY.TAX.AMT = ""; COMPOUND.MTHLY = ""; MTHLY.TAX.NAME = ""
*
AMOUNT = 0; SC = 1; RVC = 1; DMT = 0; DFAMT = 0; TDAMT = 0; RENT = 0
*
*
CALL PACK.NUMBER(TDY,TM); INS TM BEFORE ATR$EFF.DATES<1,1>
CALL PACK.NUMBER(ENTRY.DATE,TM); INS TM BEFORE ATR$ENTRY.DATES<1,1>
CALL PACK.NUMBER(A.PERIOD,TM); INS TM BEFORE ATR$ENTRY.PERIODS<1,1>
INS "V" BEFORE ATR$TYPES<1,1>
INS BATCH.NUM BEFORE ATR$REFS<1,1>
INS "" BEFORE ATR$TOTAL.AMTS<1,1>
INS "" BEFORE ATR$DESCS<1,1>
INS "" BEFORE ATR$SVC.TYPES<1,1>
INS "" BEFORE ATR$SVC.QNTYS<1,1>
INS "" BEFORE ATR$SVC.AMTS<1,1>
INS "" BEFORE ATR$SVC.FROM.DATES<1,1>
INS "" BEFORE ATR$SVC.TO.DATES<1,1>
*
LOOP EVENT = TRAN.EVENTS<1,1,RVC> UNTIL EVENT = "" DO
*
IF NOT(CAJ<AC,20,RVC>) THEN
*
MATREAD PVE FROM PVE.FILE,EVENT ELSE MAT PVE = ""
PVM.ID = PVE$PVM.ID
SHOW.DATE = PVE$DT
SHOW.TIME = PVE$TM
PVE.RATE.CL = PVE$RATE.CL
PVE.RATE.CL.SUB = PVE$RATE.CL.SUB
*
MATREAD PVM FROM PVM.FILE,PVM.ID ELSE MAT PVM = ""
EVENT.CL = PVM$CL
PROG.CL = PVM$PROG.CL
MRKT.CL = PVM$MRKT.CL
EVENT.DESC = PVM$DESC
RATE.CL = PVM$RATE.CL
RATE.CL.SUB = PVM$RATE.CL.SUB
DISTR = PVM$DISTR
STUDIO = PVM$STUDIO
CH.CODE = PVM$CH.CODE
RATE.AREA = FIELD(GEO,"*",5)
*
RTE.ID.TYPE = "PPV*":RATE.CL:"*":RATE.CL.SUB:"*":RATE.TYPE
RTE.ID.STD = "PPV*":RATE.CL:"*":RATE.CL.SUB:"*STD"
RTE.ID = "PPV*":RATE.CL:"*":RATE.CL.SUB
RTE.ON.FILE = TRUE
MATREAD RTE FROM RTE.FILE,RTE.ID.TYPE ELSE
MATREAD RTE FROM RTE.FILE,RTE.ID.STD  ELSE
MATREAD RTE FROM RTE.FILE,RTE.ID ELSE
RTE.ON.FILE = FALSE
END
END
END
*
*
IF RTE.ON.FILE THEN
*
EVENT.RENT = RTE$AMTS<1>
*
* **** RPT FILE UPDATE ****
IF SHOW.DATE GT CURR.PER.END.DATE THEN RPT.PERIOD = NEXT.PER ELSE RPT.PERIOD = CURR.PER
RPT.ID = "PPV*":RPT.PERIOD:"*":DISTR:"*":STUDIO
GOSUB RPT.UPDATE
RPT.ID = RPT.ID:"*":EVENT.CL
GOSUB RPT.UPDATE
RPT.ID = RPT.ID:"**":ZONE
GOSUB RPT.UPDATE
*
DEBUG
TAX.NAMES = RTE$TAX.NAMES
LOCATE RATE.AREA IN RTE$AREAS<1> BY "AR" SETTING LOC THEN
AREA.TAX.NAMES = RTE$AREA.TAX.NAMES<1,LOC>
END ELSE AREA.TAX.NAMES = ""
IF TAX.NAMES NE "" AND AREA.TAX.NAMES NE "" THEN TAX.NAMES = TAX.NAMES:","
IF AREA.TAX.NAMES NE "" THEN TAX.NAMES = TAX.NAMES:AREA.TAX.NAMES
GOSUB GET.TAX.DATA
TAX.NAMES = ""; TXN = 1
*
LOOP UNTIL TAX.TABLE(TXN) = "" DO
*
TAX.ON.RENTS = TAX.TABLE(TXN)<5>
*
IF TAX.ON.RENTS THEN
*
TAX.NAME = TAX.TABLE(TXN)<1>
FULL.TAX.NAME = TAX.NAME
IF TAX.NAME[1,1] EQ "+" THEN TAX.NAME = TAX.NAME[2,99]; COMPOUND.FLAG = 1 ELSE COMPOUND.FLAG = 0
LOCATE SHOW.DATE IN TAX.TABLE(TXN)<3> BY "DR" SETTING TAX.VC ELSE TAX.VC = 1
TAX.RATE = TAX.TABLE(TXN)<4,TAX.VC>
*
IF TAX.RATE THEN
LOCATE TAX.NAME IN TAX.NAMES SETTING LOC ELSE TAX.NAMES<LOC> = TAX.NAME
IF COMPOUND.FLAG THEN TEMP = COMPOUND.AMT ELSE TEMP = 0
CALC.TAX.AMT = (OCONV((EVENT.RENT+TEMP)*(TAX.RATE/10),"MR0"))/1000
TAX.AMTS<LOC> = TAX.AMTS<LOC>+CALC.TAX.AMT
COMPOUND.AMT = COMPOUND.AMT+CALC.TAX.AMT
MTHLY.TAX.NAME = MTHLY.TAX.NAME:",":FULL.TAX.NAME
IF COMPOUND.FLAG THEN TEMP = COMPOUND.MTHLY ELSE TEMP = 0
CALC.TAX.AMT = (EVENT.RENT+TEMP)*(OCONV((TAX.RATE/10),"MR0"))/1000
MTHLY.TAX.AMT = MTHLY.TAX.AMT:",":CALC.TAX.AMT
COMPOUND.MTHLY = COMPOUND.MTHLY+CALC.TAX.AMT
END; * of TAX.RATE
*
END; * of TAX.ON.RENTS
*
TXN = TXN+1
*
DEBUG
CAJ<AC,6> = CAJ<AC,6>:EVENT:", "
REPEAT
*
*
AMOUNT = AMOUNT+EVENT.RENT
*
IF CNT.TST$ID THEN
PRINT CLB:"Event ":EVENT:" has been billed for ":EVENT.RENT:
IF CNT.TST$CR THEN PRINT " Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
ATR$SVC.TYPES<1,1,SC> = "i":PVM.ID:"*":EVENT.CL
ATR$SVC.QNTYS<1,1,SC> = "1"
CALL PACK.NUMBER(EVENT.RENT,TM); ATR$SVC.AMTS<1,1,SC> = TM
CALL PACK.NUMBER(SHOW.DATE,TM); ATR$SVC.FROM.DATES<1,1,SC> = TM
CALL PACK.NUMBER(SHOW.TIME,TM); ATR$SVC.TO.DATES<1,1,SC> = TM
*
T.EVENT.RENT = T.EVENT.RENT+EVENT.RENT
*
E.CTR = E.CTR+1; SC = SC+1
*
END ELSE
INS "*** ERROR *** Missing Rate for Event ":EVENT BEFORE CAJ<AC,7,SVC>
MAT RTE = EMPTY
EVENT.RENT = EMPTY; TAX.NAMES = EMPTY; AREA.TAX.NAMES = EMPTY
END; * of RTE.ON.FILE
*
END; * of NOT(CAJ<AC,20,RVC>)
*
RVC = RVC+1
*
REPEAT
*
IF ZONE # ST.ZONE THEN
GOSUB WRITE.ACG
ST.ZONE = ZONE
MAT ACG = ""
END
*
TRANS.TYPE = "rIPV"
GOSUB ACG.UPDATE
*
TAC = 1
LOOP TAX.NAME = TAX.NAMES<TAC> UNTIL TAX.NAME = "" DO
OTHER.TAX.NAME = ""
IF TAX.NAME[1,2] = "O*" THEN OTHER.TAX.NAME = 1; TAX.NAME = TAX.NAME[3,99]
LOCATE TAX.NAME IN TTX.NAMES SETTING LOC ELSE TTX.NAMES<LOC> = TAX.NAME
TTX.AMTS<LOC> = TTX.AMTS<LOC>+TAX.AMTS<TAC>
TAC = TAC+1
REPEAT
*
TAC = 1
LOOP TAX.NAME = TTX.NAMES<TAC> UNTIL TAX.NAME = "" DO
TAX.AMT = OCONV(TTX.AMTS<TAC>,"MR0")
IF TAX.AMT THEN
TRANS.TYPE = "t":TAX.NAME
AMOUNT = TAX.AMT
GOSUB ACG.UPDATE
ATR$SVC.TYPES<1,1,SC> = "t*":TAX.NAME
CALL PACK.NUMBER(TAX.AMT,TM); ATR$SVC.AMTS<1,1,SC> = TM
TRNT = TRNT+TAX.AMT
SC = SC+1
END
TAC = TAC+1
REPEAT
*
TRNT = TRNT+T.EVENT.RENT
CALL PACK.NUMBER(TRNT,TM); ATR$TOTAL.AMTS<1,1> = TM
BATCH.TOTAL = BATCH.TOTAL+TRNT
ACT$BALANCE = ACT$BALANCE+TRNT
*
CAJ<AC,3> = TRNT
*
AGD = FIELD(ACT$AGED.AMTS,"*",1)+TRNT
AGD<2> = FIELD(ACT$AGED.AMTS,"*",2)
AGD<3> = FIELD(ACT$AGED.AMTS,"*",3)
AGD<4> = FIELD(ACT$AGED.AMTS,"*",4)
BEGIN CASE
CASE AGD<4>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>:"*":AGD<3>:"*":AGD<4>
CASE AGD<3>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>:"*":AGD<3>
CASE AGD<2>; ACT$AGED.AMTS = AGD<1>:"*":AGD<2>
CASE 1;       ACT$AGED.AMTS = AGD<1>
END CASE
*
** * **** RPT FILE UPDATE ****
** IF SHOW.DATE GT CURR.PER.END.DATE THEN RPT.PERIOD = NEXT.PER ELSE RPT.PERIOD = CURR.PER
** RPT.ID = "PPV*":RPT.PERIOD:"*":DISTR:"*":STUDIO
** GOSUB RPT.UPDATE
** RPT.ID = RPT.ID:"*":EVENT.CL
** GOSUB RPT.UPDATE
** RPT.ID = RPT.ID:"**":ZONE
** GOSUB RPT.UPDATE
*
IF ATR.FLAG THEN MATWRITE ATR ON ATR.FILE,ACT.ID
IF ACT.FLAG THEN MATWRITE ACT ON ACT.FILE,ACT.ID
*
B.CTR = B.CTR+1
*
*
END ELSE
*
**** ACCOUNT NOT ON FILE
*
END; * of read ACT
*
CALL SYS.ITM.RLS("ACT",ACT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
CALL SYS.ITM.RLS("ATR",ACT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
IF CNT.TST$ID THEN
PRINT CLB:"Account has been billed for ":TRNT:
IF CNT.TST$CR THEN PRINT " Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
RETURN
!
RPT.UPDATE: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering RPT.UPDATE. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
LOOP
CALL SYS.ITM.LCK("RPT",RPT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock RPT file - item ":RPT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
MATREAD RPT FROM RPT.FILE,RPT.ID ELSE MAT RPT = ""
*
LOCATE PVM.ID IN RPT$CURR.EVENTS<1> BY "AL" SETTING RPT.VC ELSE
INS PVM.ID BEFORE RPT$CURR.EVENTS<1,RPT.VC>
INS ""      BEFORE RPT$CURR.PRICES<1,RPT.VC>
INS ""      BEFORE RPT$CURR.BUYS<1,RPT.VC>
INS ""      BEFORE RPT$CURR.REVERSALS<1,RPT.VC>
END
*
LOCATE EVENT.RENT IN RPT$CURR.PRICES<1,RPT.VC> BY "AR" SETTING RPT.SC ELSE
INS EVENT.RENT BEFORE RPT$CURR.PRICES<1,RPT.VC,RPT.SC>
INS ""         BEFORE RPT$CURR.BUYS<1,RPT.VC,RPT.SC>
INS ""         BEFORE RPT$CURR.REVERSALS<1,RPT.VC,RPT.SC>
END
*
RPT$CURR.BUYS<1,RPT.VC,RPT.SC> = RPT$CURR.BUYS<1,RPT.VC,RPT.SC>+1
*
IF ALL.FLAG THEN MATWRITE RPT ON RPT.FILE,RPT.ID
CALL SYS.ITM.RLS("RPT",RPT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
RETURN
!
ACG.UPDATE: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering ACG.UPDATE. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
LOCATE "b" IN ACG$SOURCES<1> BY "AL" SETTING SOURCE.LOC ELSE
INS "b" BEFORE ACG$SOURCES<1,SOURCE.LOC>
INS "" BEFORE ACG$TRANS.TYPES<1,SOURCE.LOC>
INS "" BEFORE ACG$AMOUNTS<1,SOURCE.LOC>
INS "" BEFORE ACG$COUNTS<1,SOURCE.LOC>
END
LOCATE TRANS.TYPE IN ACG$TRANS.TYPES<1,SOURCE.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRANS.TYPE BEFORE ACG$TRANS.TYPES<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>
END
ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC> = ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>+AMOUNT
ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC> = ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>+1
RETURN
!
WRITE.ACG: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering WRITE.ACG. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
IF ST.ZONE # "" THEN
ACG.ID = ST.ZONE:"*":ACCTG.DATE
LOOP
LOOP
CALL SYS.ITM.LCK("ACG",ACG.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO
PRINT @(0,22):CLL:"You must unlock ACG file - item ":ACG.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
MATREAD SAVE.ACG FROM ACG.FILE,ACG.ID ELSE MAT SAVE.ACG = ""
ACG.VC = 1
LOOP SOURCE = ACG$SOURCES<1,ACG.VC> UNTIL SOURCE = "" DO
LOCATE SOURCE IN SAVE.ACG$SOURCES<1> BY "AL" SETTING SOURCE.LOC ELSE
INS SOURCE BEFORE SAVE.ACG$SOURCES<1,SOURCE.LOC>
INS "" BEFORE SAVE.ACG$TRANS.TYPES<1,SOURCE.LOC>
INS "" BEFORE SAVE.ACG$AMOUNTS<1,SOURCE.LOC>
INS "" BEFORE SAVE.ACG$COUNTS<1,SOURCE.LOC>
END
ACG.SC = 1
LOOP TRANS.TYPE = ACG$TRANS.TYPES<1,ACG.VC,ACG.SC> UNTIL TRANS.TYPE = "" DO
LOCATE TRANS.TYPE IN SAVE.ACG$TRANS.TYPES<1,SOURCE.LOC> BY "AL" SETTING TRANS.LOC ELSE
INS TRANS.TYPE BEFORE SAVE.ACG$TRANS.TYPES<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE SAVE.ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>
INS "" BEFORE SAVE.ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>
END
SAVE.ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC> = SAVE.ACG$AMOUNTS<1,SOURCE.LOC,TRANS.LOC>+ACG$AMOUNTS<1,ACG.VC,ACG.SC>
SAVE.ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC> = SAVE.ACG$COUNTS<1,SOURCE.LOC,TRANS.LOC>+ACG$COUNTS<1,ACG.VC,ACG.SC>
ACG.SC = ACG.SC+1
REPEAT
ACG.VC = ACG.VC+1
REPEAT
IF ACG.FLAG THEN MATWRITE SAVE.ACG ON ACG.FILE,ACG.ID
CALL SYS.ITM.RLS("ACG",ACG.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
UNTIL ACG.ID[1,1] = "$" DO ACG.ID = "$":ST.ZONE:"*":CDT REPEAT
END
RETURN
!
GET.TAX.DATA: *
IF CNT.TST$LBL THEN PRINT CLB:"GET.TAX.DATA":; INPUT TMP:
* TAX.TABLE(TXN)<1> - TAX NAME
* TAX.TABLE(TXN)<2> - RELEVENT TAX.TABLE VC
* TAX.TABLE(TXN)<3> - EFF. DATES
* TAX.TABLE(TXN)<4> - TAX RATES (%)
* TAX.TABLE(TXN)<5> - TAX APPLIC. TO RENTAL
* TAX.TABLE(TXN)<6> - TAX APPLIC. TO SALES
* TAX.TABLE(TXN)<7> - TAX APPLIC. TO OTHER CHARGES
*
IF RATE.AREA = LAST.RATE.AREA THEN RETURN
TXN = 1; TXN1 = 1
LOOP TAX.ID = FIELD(TAX.NAMES<1>,",",TXN1) UNTIL TAX.ID = "" OR TXN = 5 DO
TAX.TABLE(TXN) = TAX.ID
IF TAX.ID[1,1] = "+" THEN TAX.ID = TAX.ID[2,99]
MATREAD TAX FROM TAX.FILE,TAX.ID THEN
TMP = ",":TAX$EXEMPT.RATE.TYPES:","; TMP1 = ",":FIELD(ACT$RATE.TYPE,"*",1):","
IF INDEX(TMP,TMP1,1) THEN TAX.TABLE(TXN) = ""; TXN = TXN-1 ELSE
TAX.TABLE(TXN)<3> = TAX$EFF.DATES
TAX.TABLE(TXN)<4> = TAX$TAX.RATES
IF TAX$RENTAL.AMT.FLAG = "Y" THEN TAX.TABLE(TXN)<5> = 1
IF TAX$SALES.AMT.FLAG = "Y" THEN TAX.TABLE(TXN)<6> = 1
END
END
TXN = TXN+1; TXN1 = TXN1+1
REPEAT
LAST.RATE.AREA = RATE.AREA
RETURN
!
FINISH: *
IF CNT.TST$LBL THEN
PRINT CLB:"Entering FINISH. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
POST.DATE = TDY; POST.TIME = TIME()
ENTERED.TOTAL = BATCH.TOTAL
** BATCH.HEADER = BATCH.SOURCE:"*":BATCH.STATUS:"*":ENTRY.DATE:"*":ENTRY.TIME:"*":POST.DATE:"*":POST.TIME:"*"
** BATCH.HEADER = BATCH.HEADER:BUS.DATE:"*":EFF.DATE:"*":BATCH.TOTAL:"*":ENTERED.TOTAL:"*"
** BATCH.HEADER = BATCH.HEADER:ADJUST.TOTAL:"*":DEFAULT.TYPE:"*":ITEM.COUNT:"*":OPER:"*"
** BATCH.HEADER = BATCH.HEADER:DEL.STATUS:"*":LPT.DATE:"*":LPT.TM:"*":CLASS:"*":INP.SOURCE:"*":BATCH.LST
*
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
*
IF ALL.FLAG THEN WRITE BATCH.HEADER:AM:CAJ ON CAJ.FILE,BATCH.NUM
GOSUB WRITE.ACG
*
IF CNT.TST$LBL THEN
PRINT CLB:"Exiting FINISH. ":
IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
$INCLUDE IBP CLS.ROUTINE
!
END
~PPV.SUBR.UPD.PVM.XREF~
SUBROUTINE PPV.SUBR.UPD.PVM.XREF(MAT PVE,PVE.ID,STAT)
* AUTHOR:            XXX
* DESCRIPTION: USED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      09 JUL 93 03:03:44
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
*
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
*
*INPUT.LNS*
* INPUT DISP.ONLY:
* INPUT AUTO.RUN:
*INPUT.END*
*
*
SCR.ID = "GET.PVE.XREF"
RELEASE.ID = ""
*
LOCATE FLD IN PVM$PVE.XREF<ONE> BY "AL" SETTING VC THEN
PRINT CLB:"Ref. EV> ":FLD:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN DYN = EMPTY; PRINT CLB: ELSE
DEL PVM$PVE.XREF<ONE,VC>
DEL PVM$PVE.DT<ONE,VC>
DEL PVM$PVE.TM<ONE,VC>
DEL PVM$PVE.COMP<ONE,VC>
DEL PVM$PVE.ELP.TM<ONE,VC>
DEL PVM$PVE.ID<ONE,VC>
TDL(2) = -ABS(TDL(2))
DYN = "D"; GOSUB D02; IF STAT EQ 999 THEN RETURN
GOTO I02
END
END ELSE
IF PVM$PVE.XREF<ONE,VC> EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
IF VC GT I02.MAX THEN IF NEW AND DYN EQ "N" THEN RETURN ELSE
TEXT = "Max. entries allowed is ":I02.MAX; GOSUB ERROR; GOTO I02
END
INS FLD BEFORE PVM$PVE.XREF<ONE,VC>
INS EMPTY BEFORE PVM$PVE.DT<ONE,VC>
INS EMPTY BEFORE PVM$PVE.TM<ONE,VC>
INS EMPTY BEFORE PVM$PVE.COMP<ONE,VC>
INS EMPTY BEFORE PVM$PVE.ELP.TM<ONE,VC>
INS EMPTY BEFORE PVM$PVE.ID<ONE,VC>
IF DYN EQ "I" THEN TDL(2) = -ABS(TDL(2)) ELSE IF NOT(TDL(2)) THEN TDL(2) = ONE
END
*
*
RETURN
*
END
~PRINT.AIX.BY.CO~
*PROGRAM: PRINT.AIX.BY.CO
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION: LISTS AIX BY AI.CO (ONE OR ALL).
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1994              ALL RIGHTS RESERVED
*  
* AUTHOR:          HARVEY HORSMAN
!
VS = "  1.0"; RELEASE = " (R:3.0)"
TITLE = "List Addressable Devices by Company":VS
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP; STOP
OPEN "AIX" TO AIX.FILE ELSE PRINT "Can't open AIX":; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM":; INPUT RSP; STOP
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
READ AI.COS FROM COM.FILE,"AI.COS" ELSE AI.COS = ""
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
!
INPUT AUTO.RUN
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
CO = CURRENT.RUN<1,2>
END ELSE
*
LN = 8
LOOP CO.LIT = AI.COS<2,LN-7> UNTIL CO.LIT = "" DO
PRINT @(10,LN):CO.LIT:
LN = LN+1
REPEAT
*
LOOP
PRINT @(0,LN+1):CLS:
PRINT @(0,LN+2):CLL:"Enter Company to print or <cr> for ALL: ":; INPUT CO:
IF CO = "KILL" THEN STOP
IF CO = "" THEN
CO = "ALL"
END ELSE
LOCATE CO IN AI.COS<2> SETTING LOC ELSE CO = ""
END
WHILE CO = "" DO PRINT BELL: REPEAT
*
CALL AUTO.LOADER("PRINT.PVM.DETAIL",CO,"AIX List")
END
*
IF CO NE "ALL" THEN
EXLN = '= "':CO:'"'
END ELSE
EXLN = 'BY CO'
END
PRINT @(0,15):EXLN:CLL:
* EXECUTE 'SSELECT AIX ':EXLN; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
EXECUTE 'SSELECT AIX ':EXLN, //SELECT. > SLIST
REPORT.TITLE = "Addressable Devices for Co = ":CO
$INCLUDE IBP REPORT.HEADER
*
* EXLN = 'LIST AIX SPACE CO ACT.ID START.DATE STOP.DATE AI.CODE GROUP ERROR  HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":': (P)'; * REV ONLY
* EXECUTE EXLN; * REV ONLY
*
* ULT ONLY
EXLN = 'LIST AIX CO ACT.ID START.DATE STOP.DATE AI.CODE GROUP ERROR  HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":': (P)'
* ULT ONLY
EXECUTE EXLN, //SELECT. < SLIST
STOP
!
END
~PRINT.COUNTS.PPV.DISTR~
*PROGRAM:         PRINT.PPV.COUNTS.DISTR
* VERSION: 940901 1.3  CORRECTED FOR DISTR/STUDIO CHANGE.
* PRIOR: 940828 1.3  ADDED REPORTING BY COMPANY.
* PRIOR: 940814 1.2  EXTENSIVE CHANGES: CONTROLS USED, ETC.
* COPIED TO IN.BP.AI 2-NOV-93.
* VERSION: 930728 1.1  ADDED REPORT PERIOD TO RPT.ID
* PRIOR: 921004 1.0  NEW
* AUTHOR:         H HORSMAN - AXION
*
* COPYRIGHT       AXION COMPUTER SYSTEMS LTD.
*   1992             ALL RIGHTS RESERVED
*
* DESCRIPTION:    PRINT PPV BUYS BY DISTR/STUDIO
!
VERSION = " (R:1.3)"
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP RPT.PPV.DIM
$INCLUDE IBP RPT.PPV.EQUATES
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
*
OPEN "RPT" TO RPT.FILE ELSE PRINT "Can't open file RPT"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open file PVM"; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open file COM"; INPUT RSP; STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
D.TITLE = "Print Distributor/Studio Buys":VERSION
PRINT @(0,1):(SPACE(40-LEN(D.TITLE)/2):D.TITLE) "L#80":RVE:
INPUT AUTO.RUN
*
READ CURR.ACCTG.PER FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE PRINT "Can't read CNT CURR.ACCTG.PERIOD"; INPUT RSP; STOP
READ PPV.UPDATE FROM COM.FILE,"CURR.PPV.REPORT.PERIOD" ELSE PPV.UPDATE = ""
LAST.UPDATE = OCONV(PPV.UPDATE<1>,"D2")
CURR.REPORT.PER = PPV.UPDATE<2>
LAST.UPD.PER    = PPV.UPDATE<3>
READ DISTRIBUTORS FROM COM.FILE,"PPV.DISTRIBUTORS" ELSE DISTRIBUTORS = ""
*
READ SYS.TST FROM CNT.FILE,"PPV.TEST" ELSE SYS.TST = 0
$INCLUDE IBP SYSTEM.TEST
*
CO.LAST = ""; DISTR.STUDIO.LAST = ""; DISTR.LAST = ""; STUDIO.LAST = ""; EVENT.STR = ""; PRICE.STR = ""; BUY.STR = ""; REVERSAL.STR = ""
MTHS = "January":VM:"February":VM:"March":VM:"April":VM:"May":VM:"June":VM:"July":VM:"August":VM:"September":VM:"October":VM:"November":VM:"December"
!
*
IF DIS.PROG THEN
PRINT CLB:"Entering PRINT.PPV.COUNTS.DISTR. ":
IF DIS.PROG > 1 THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
IF AUTO.RUN THEN READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
DISTR.LAST = ""; STUDIO.LAST = ""; S.CTR = 0; CTR = 0; CLS.COL = 0; CLS.ROW = 3; GOSUB CLS.ROUTINE
STC = 0; TBUY = 0; TREV = 0; TNET = 0; TEXP = 0
CBUY = 0; CREV = 0; CNET = 0; CEXP = 0
DTC = 0; GBUY = 0; GREV = 0; GNET = 0; GEXP = 0
!
IF AUTO.RUN THEN REPORT.PERIOD = CURRENT.RUN<1,2>; CO = CURRENT.RUN<1,3> ELSE
*
* PRINT @(10,8):CLL:"The Current Accounting Period is ":CURR.ACCTG.PER:
IF LAST.UPDATE NE "" THEN
PRINT @(10,10):CLS:"The last update was on ":LAST.UPDATE:" for reporting period ":LAST.UPD.PER:
END
*
LOOP
PRINT @(10,12):CLL:"Enter Period to report (format YYMM): ":LAST.UPD.PER:
PRINT @(48,12):
INPUT ENTERED.PERIOD:
IF ENTERED.PERIOD = "KILL" THEN STOP
TEXT = ""
IF ENTERED.PERIOD = "" THEN ENTERED.PERIOD = LAST.UPD.PER
IF NOT(ENTERED.PERIOD MATCHES "4N") THEN TEXT = "please use format YYMM" ELSE
IF ENTERED.PERIOD[3,2] < "01" OR ENTERED.PERIOD[3,2] > "12" THEN TEXT = "month not 01-12" ELSE
IF ENTERED.PERIOD > CURR.ACCTG.PER THEN TEXT = "cannot be beyond ":CURR.ACCTG.PER
END
END
IF TEXT # "" THEN
PRINT @(0,23):TEXT:" - press <cr> ":; INPUT RSP:; IF RSP = "KILL" THEN STOP
END
UNTIL TEXT = "" DO
REPEAT
REPORT.PERIOD = ENTERED.PERIOD
PRIOR.PERIOD = REPORT.PERIOD-1; IF PRIOR.PERIOD[3,2] = 0 THEN PRIOR.PERIOD = PRIOR.PERIOD-88
*
LOOP
PRINT @(10,14):CLL:"Enter Company or <cr> for consolidated report: ":
INPUT ONE.CO:
IF ONE.CO = "KILL" THEN STOP
IF ONE.CO = "CR" THEN CO.NAME = "C/R TV Cable, Inc."
IF ONE.CO = "" THEN CO.NAME = "Consolidated"
IF CO.NAME = "" THEN TEXT = ONE.CO:" is not a valid entry"
IF TEXT # "" THEN
PRINT @(0,23):TEXT:" - press <cr> ":; INPUT RSP:; IF RSP = "KILL" THEN STOP
END
UNTIL TEXT = "" DO
REPEAT
*
RUN.NAME = "Print Distr. Buys"
INPUTS = REPORT.PERIOD:VM:ONE.CO
END
D.TITLE2 = " for ":MTHS<1,REPORT.PERIOD[3,2]>:" 19":REPORT.PERIOD[1,2]
*
!
*
REPORT.SEL: *
*
PRINT @(0,2):RVB:(SPACE(40-LEN(D.TITLE2)/2):D.TITLE2<2>) "L#80":RVE:
IF NOT(AUTO.RUN) THEN CALL AUTO.LOADER("PRINT.PPV.COUNTS.DISTR",INPUTS,RUN.NAME)
PGS = 0; LNS = 999; PRINT @(0,12):
***IF ONE.CO NE "" THEN
EXLN = 'WITH CO = ':'"':ONE.CO:'"':' AND WITH RPT.TYPE = ':'"':"PPV":'"':' AND WITH ACCTG.PER = ':'"':REPORT.PERIOD:'"':' BY DISTR BY STUDIO'
*** END ELSE
*** EXLN = 'WITH CO NE ':'"':ONE.CO:'"':' AND WITH RPT.TYPE = ':'"':"PPV":'"':' AND WITH ACCTG.PER = ':'"':REPORT.PERIOD:'"':' BY CO BY DISTR BY STUDIO'
*** END
IF TEST.FL THEN PRINT @(0,17):EXLN:
EXECUTE 'SSELECT RPT ':EXLN
*%%MDD%%=PRINT
*%%MDD%%=PRINT SEL.ERROR
*%%MDD%%=IF SEL.ERROR<1,1> EQ "401" THEN GOTO ENDIT
*
!
*
MAIN: *
*
IF DIS.SUB THEN
PRINT CLB:"Entering MAIN. ":
IF DIS.SUB > 1 THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
LOOP
*
READNEXT RPT.ID ELSE RPT.ID = "@"
*
UNTIL RPT.ID = "@" DO
*
*
DISTR  = FIELD(RPT.ID,"*",3)
STUDIO = FIELD(RPT.ID,"*",4)
CLASS  = FIELD(RPT.ID,"*",5)
CO     = FIELD(RPT.ID,"*",6)
ZONE   = FIELD(RPT.ID,"*",7)
*
IF (CO = "" AND CLASS EQ "") OR (CO NE "" AND ZONE NE "") THEN
*
DISTR.STUDIO = DISTR:STUDIO
*
MATREAD RPT FROM RPT.FILE,RPT.ID THEN
*
IF STUDIO NE DISTR THEN S.CTR = CTR+1 ELSE CTR = CTR+1
UPDATE.PERIOD = RPT$UPDATE.PERIOD
PRINT @(13,16):CLL:"Distr.: ":DISTR:"  ":CTR "R#5":
IF STUDIO NE DISTR THEN PRINT @(13,17):CLL:"Studio: ":STUDIO:"  ":S.CTR "R#5":
*
IF ONE.CO NE "" AND DISTR.STUDIO NE DISTR.STUDIO.LAST AND DISTR.STUDIO.LAST NE "" THEN
PGS = 0
GOSUB PRINT.DISTR
END
*
GOSUB ACCUM.DISTR
*
END; * of read
*
* IF ONE.CO NE "" AND CO NE CO.LAST AND CO.LAST NE "" THEN
* GOSUB PRINT.CO
* END
* CO.LAST = CO
*
DISTR.LAST = DISTR; STUDIO.LAST = STUDIO; DISTR.STUDIO.LAST = DISTR.STUDIO
*
END; * of co & class empty OR co and zone not empty
*
*
REPEAT
*
!
*
DISTR.LAST = DISTR; STUDIO.LAST = STUDIO; GOSUB PRINT.DISTR
*
*
* IF ONE.CO NE "" THEN
* CO.LAST = CO; GOSUB PRINT.CO
* END
!
*
ENDIT: *
*
IF DIS.SUB THEN
PRINT CLB:"Entering ENDIT. ":
IF DIS.SUB > 1 THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
STOP
*
!
*
ACCUM.DISTR: *
*
IF DIS.SUB THEN
PRINT CLB:"Entering ACCUM.DISTR. ":
IF DIS.SUB > 1 THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
RPT.VC = 1; RPT.SVC = 1; STR.VAL = 1
* IF MULTI THEN MAX.VAL = 3 ELSE MAX.VAL = 2
*
LOCATE REPORT.PERIOD IN RPT$UPDATE.PERIOD<1> BY "AL" SETTING RPT.VC THEN
*
LOOP UNTIL RPT$EVENTS<1,RPT.VC> = "" DO 
*
EVENT = RPT$EVENTS<1,RPT.VC> 
*
LOCATE EVENT IN EVENT.STR BY "AL" SETTING DTC ELSE
INS EVENT BEFORE EVENT.STR<DTC>
INS "" BEFORE PRICE.STR<DTC>
INS "" BEFORE BUY.STR<DTC>
INS "" BEFORE REVERSAL.STR<DTC>
END
*
LOOP UNTIL RPT$PRICES<1,RPT.VC,RPT.SVC> = "" DO
PRICE = RPT$PRICES<1,RPT.VC,RPT.SVC> 
*
LOCATE PRICE IN PRICE.STR<DTC> BY "AR" SETTING STC ELSE
INS PRICE BEFORE PRICE.STR<DTC,STC>
INS "" BEFORE BUY.STR<DTC,STC>
INS "" BEFORE REVERSAL.STR<DTC,STC>
END
*
BUY.STR<DTC,STC> = BUY.STR<DTC,STC> + RPT$BUYS<1,RPT.VC,RPT.SVC>
REVERSAL.STR<DTC,STC> = REVERSAL.STR<DTC,STC> + RPT$REVERSALS<1,RPT.VC,RPT.SVC>
RPT.SVC = RPT.SVC+1 
REPEAT
*
RPT.VC = RPT.VC+1; RPT.SVC = 1
*
REPEAT
*
END
*
RETURN
*
!
*
PRINT.DISTR: *
*
IF DIS.SUB THEN
PRINT CLB:"Entering PRINT.DISTR. ":
IF DIS.SUB > 1 THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
LNS = 999; MARGIN = 10
*
LOCATE DISTR.LAST IN DISTRIBUTORS<1> BY "AL" SETTING LOC THEN
DISTR.NAME = DISTRIBUTORS<2,LOC>
END
*
PRINT @(0,18):CLL:"Printing PPV Buys for Distr: ":DISTR.NAME:
IF STUDIO.LAST NE "" THEN
LOCATE STUDIO.LAST IN DISTRIBUTORS<1> BY "AL" SETTING LOC THEN
STUDIO.NAME = DISTRIBUTORS<2,LOC>
PRINT @(21,19):CLL:"Studio: ":STUDIO.NAME:
END ELSE STUDIO.NAME = ""
END ELSE STUDIO.NAME = ""
CALL PRINTER.ON(STAT); IF STAT THEN STOP
*
HDR1A = "     Event                            " "L#44"
HDR2A = "Item  Code  Event Title               " "L#44"
HDR1B = "Retail" "R#11"
HDR2B = " Price" "R#11"
HDR1C = " Gross" "R#11"
HDR2C = "  Buys" "R#11"
HDR1D = "         " "R#11"
HDR2D = "Reversals" "R#11"
HDR1E = "   Net" "R#11"
HDR2E = "  Buys" "R#11"
HDR1F = "   Retail" "R#11"
HDR2F = "    Total" "R#11"
HDR1 = HDR1A:"  ":HDR1B:"  ":HDR1C:"  ":HDR1D:"  ":HDR1E:"  ":HDR1F
HDR2 = HDR2A:"  ":HDR2B:"  ":HDR2C:"  ":HDR2D:"  ":HDR2E:"  ":HDR2F
*
DTC = 0; GBUY = 0; GREV = 0; GNET = 0; GEXP = 0
*
LOOP DTC = DTC+1 UNTIL EVENT.STR<DTC> = "" DO
*
PRINT
LNS = LNS+1
EVENT.NUM = EVENT.STR<DTC>
EVENT.LINE = SPACE(MARGIN+1):DTC "R#2":"   "
EVENT.LINE = EVENT.LINE:EVENT.NUM "L#6"
READV EVENT.DESC FROM PVM.FILE,EVENT.NUM,2 ELSE EVENT.DESC = ""
EVENT.LINE = EVENT.LINE:EVENT.DESC "L#30"
TEST.LNS = COUNT(PRICE.STR<DTC>,VM)+1
IF TEST.LNS > 1 THEN TEST.LNS = TEST.LNS+1
*
IF LNS+TEST.LNS > 60 THEN
PGS = PGS+1; LNS = 4
PRINT FF:TIMEDATE() "L#25":(SPACE(40-LEN(CO.NAME)/2):CO.NAME) "L#80":("Page ":PGS) "R#25"
P.TITLE = "PPV Buys as of ":OCONV(LAST.UPDATE,"D2"):" for period ":REPORT.PERIOD
P.TITLE = P.TITLE:" For Distributor: ":DISTR.NAME
PRINT SPACE(65-LEN(P.TITLE)/2):P.TITLE
*
IF STUDIO.NAME NE "" THEN
P.TITLE<2> ="Studio: ":STUDIO.NAME
PRINT SPACE(65-LEN(P.TITLE<2>)/2):P.TITLE<2>
LNS = LNS+1
END
*
PRINT
PRINT SPACE(MARGIN):HDR1
PRINT SPACE(MARGIN):HDR2
PRINT; LNS = LNS+3
*
END
*
LNS = LNS + TEST.LNS
STC = 0; TBUY = 0; TREV = 0; TNET = 0; TEXP = 0
*
LOOP STC = STC+1 UNTIL PRICE.STR<DTC,STC> = "" DO
*
B.LINE = OCONV(PRICE.STR<DTC,STC>,"MR2") "R#13"
C.LINE = BUY.STR<DTC,STC> "R#13"
D.LINE = REVERSAL.STR<DTC,STC> "R#13"
NET.BUYS = BUY.STR<DTC,STC>-REVERSAL.STR<DTC,STC>
E.LINE = NET.BUYS "R#13"
EXT.PRICE = PRICE.STR<DTC,STC>*NET.BUYS
F.LINE = OCONV(EXT.PRICE,"MR2ZM") "R#13"
P.LINE = B.LINE:C.LINE:D.LINE:E.LINE:F.LINE
IF STC = 1 THEN
PRINT EVENT.LINE:"  ":P.LINE
END ELSE
PRINT SPACE(MARGIN+44):P.LINE
END
TBUY = TBUY+BUY.STR<DTC,STC>
TREV = TREV+REVERSAL.STR<DTC,STC>
TNET = TNET+NET.BUYS
TEXP = TEXP+EXT.PRICE
P.LINE = ""
*
REPEAT
*
GBUY = GBUY+TBUY; GREV = GREV+TREV; GNET = GNET+TNET; GEXP = GEXP+TEXP
CBUY = CBUY+TBUY; CREV = CREV+TREV; CNET = CNET+TNET; CEXP = CEXP+TEXP
TEXP = OCONV(TEXP,"MR2ZM")
* PRICE TOTALS
IF STC > 2 THEN PRINT SPACE(MARGIN+56):TBUY "R#13":"*":TREV "R#13":"*":TNET "R#13":"*":TEXP "R#13":"*"
*
REPEAT
*
GEXP = OCONV(GEXP,"MR2ZM")
PRINT; PRINT
* DISTR TOTALS
IF DTC > 2 THEN PRINT SPACE(MARGIN+12):"Totals" "L#45":GBUY "R#13":GREV "R#13":GNET "R#13":GEXP "R#13"
PRINTER OFF
EVENT.STR = ""; PRICE.STR = ""; BUY.STR = ""; REVERSAL.STR = ""
*
RETURN
*
!
*
* PRINT.CO: *
* *
* ***** CO AREA
*
* RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
END
~PRINT.DISC.MEMOS~
*PROGRAM:          PRINT.DISC.MEMOS
* VERSION: 910814 REV  TO HANDLE ADDRESSABLE ACCOUNTS
* PRIOR: 900911 2.4  MOVE.INS.OF.CALL.DATE.CORRECT.PRINT.DATE.TO.TODAY
* PRIOR: 900730 2.3  INS.P.IN.CALL.FUP
* PRIOR: 900717 2.2  ADD.INS.OF.CALL.FUP
* PRIOR: 900530 2.1  FIX LAST.BILLING.DATE LOC
* PRIOR: 900404 1.9
* PRIOR: 891211 NEW
* DESCRIPTION:     PRINT DISCONNECT MEMOS
*                    SEND.TO.AI (PAR DELINQ.DISCONNECT = 1)
*                    IF SEND.TO.AI AND ADDRESSABLE THEN MEMO IS NOT PRINTED
* COPYRIGHT:       AXION COMPUTER SYSTEMS LTD.
*   1989               ALL RIGHTS RESERVED
!
$INCLUDE IBP STANDARD.FUNCTIONS
*OVERRIDE
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
$INCLUDE IBP DLQ.DIM
$INCLUDE IBP DLQ.EQUATES
$INCLUDE IBP WKO.DIM
$INCLUDE IBP WKO.EQUATES
*
OPEN "ACT" TO ACT.FILE ELSE PRINT "Can't open file ACT"; INPUT RSP; STOP
OPEN "DLQ" TO DLQ.FILE ELSE PRINT "Can't open file DLQ"; INPUT RSP; STOP
OPEN "STT" TO STT.FILE ELSE PRINT "Can't open file STT"; INPUT RSP; STOP
OPEN "ADD" TO ADD.FILE ELSE PRINT "Can't open file ADD"; INPUT RSP; STOP
OPEN "SVC" TO SVC.FILE ELSE PRINT "Can't open file SVC"; INPUT RSP; STOP
OPEN "WKO" TO WKO.FILE ELSE PRINT "Can't open file WKO"; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open file PAR"; INPUT RSP; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "EFT" TO EFT.FILE ELSE PRINT "Can't open file EFT"; INPUT RSP; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS"; INPUT RSP; STOP
*
READ SYS.TST FROM CNT.FILE,"DELINQ.TEST" ELSE SYS.TST = 0
$INCLUDE IBP SYSTEM.TEST
PASS.CTR = 0; SUSPEND.CTR = 0; PREV.PROC.CTR = 0; NOT.DLQ.CTR = 0; DISC.ACTION.CTR = 0
PRINT.CTR = 0; DISC.CTR = 0; DISC.PEND.CTR = 0; NO.ACTION.CTR = 0; BLANK.CTR = 0
AI.CTR = 0; LOCKED.CTR = 0
ROUTINE.TYPE = "WORK.ORDERS.BATCH"; LINE = ""; WKO.IDS = ""
READ SEND.TO.AI FROM PAR.FILE,"DELINQ.DISCONNECT" ELSE SEND.TO.AI = 0
READ NEXT.MEMO.NUM FROM CNT.FILE,"NEXT.MEMO.NUM" ELSE NEXT.MEMO.NUM = 00001
NEXT.MEMO.NUM = (NEXT.MEMO.NUM+100000)[2,5]
MEMO.NUM = "M":NEXT.MEMO.NUM
READ ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE ROUTINES = ""
LOCATE ROUTINE.TYPE IN ROUTINES<1> SETTING LOC THEN ROUTINE.NAME = ROUTINES<2,LOC> ELSE ROUTINE.NAME = "STANDARD"
ROUTINE.NAME = "WORK.ORDERS.":ROUTINE.NAME
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>; CONTROL.DT = CO.DATA<2,1,1>
VERSION = " (R:1.?)"
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Select and Print Disconnect Memos":VERSION
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
READ WOT FROM PAR.FILE,"WORK.ORDER.TYPES" ELSE WOT = ""
LOCATE "DM" IN WOT<1> BY "AL" SETTING LOC ELSE LOC = 0
IF NOT(LOC) THEN
PRINT CLB:"Can't proceed. Work Order Type 'DM' has not been defined. Enter <cr>: ":; INPUT TMP:
STOP
END
READ LAST.BILLING.DATE FROM CNT.FILE,"LAST.BILLING.DATE" ELSE LAST.BILLING.DATE = ""
READ RESULT.CODES FROM PAR.FILE,"DELINQ.RESULT.CODES" ELSE RESULT.CODES = ""
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = ""
READ CREDIT.CRITERIA FROM PAR.FILE,"CREDIT.CRITERIA" ELSE CREDIT.CRITERIA = ""
MIN.DELINQ.AMT = CREDIT.CRITERIA<1>; IF NOT(MIN.DELINQ.AMT) THEN MIN.DELINQ.AMT = 100
RELOOP: *
STAT = 3; OUT.DATE = "(none)"; OUT.MSG = "   (none)"
CALL DELINQ.CYCLE.SELECT(AC,LATEST.BILL.DATE,SCANNED.ON,EARLIEST.DISC.DATE,BILLING.RUN.NUM,CREDIT.STATUS,MEMO.DATE,PRINT.DATE,STAT)
IF STAT = 999 THEN STOP
IF MEMO.DATE = "" THEN
PRINT CLB:"There are no memos to print. Enter <cr> ":; INPUT TMP:; STOP
END
*
PRINT @(0,2):CLS
OPER = ""; VC = AC
PRINT @(0,5):CLL:"Please enter your operator number: ":
CALL INPUT.DATA(OPER,36,5,6,"1,,,*1","","EQ":SVM:"@":OPERATORS:"@","",RSP,STAT)
LOCATE OPER IN OPERATORS<1> BY "AL" SETTING LOC ELSE NULL
IF LOC THEN OPER.NAME = OPERATORS<2,LOC> ELSE OPER.NAME = ""
PRINT @(45,5):CLL:OPER.NAME:
OPER.NAME = "by ":OPER.NAME
*
MEMO.SCH.DATE = OCONV(DATE()+1,"D2")
PRINT @(0,8):CLL:"Memo Scheduled Date Option":
PRINT @(0,9):CLL:"Enter a new date, '\' to clear it, or <cr> to accept: ":MEMO.SCH.DATE:
CALL INPUT.DATA(MEMO.SCH.DATE,54,9,9,"1,1","D2","DT","",RSP,STAT)
IF STAT < 0 OR STAT = 999 THEN STOP
IF MEMO.SCH.DATE NE "" THEN MEMO.OUT.DATE = OCONV(MEMO.SCH.DATE,"D2")
LN = 11
*
IF SEND.TO.AI THEN
AI.SCH.DATE = OCONV(DATE(),"D2")
PRINT @(0,LN):CLL:"AI Scheduled Date Option":
PRINT @(0,LN+1):CLL:"Enter a new date, '\' to clear it, or <cr> to accept: ":AI.SCH.DATE:
CALL INPUT.DATA(AI.SCH.DATE,54,LN+1,9,"1,1","D2","DT","",RSP,STAT)
IF STAT < 0 OR STAT = 999 THEN STOP
IF AI.SCH.DATE NE "" THEN AI.OUT.DATE = OCONV(AI.SCH.DATE,"D2")
LN = LN+3
END
*
MEMO.MESSAGE = "**************** Disconnect Drop *****************"
AI.MESSAGE = "******* Send via the Addressable Interface *******"
PRINT @(0,LN):CLL:"Memo Message Option: ":
PRINT @(0,LN+1):CLL:"Enter a new message, '\' to clear it, or <cr> to accept :":
CALL INPUT.DATA(MEMO.MESSAGE,21,LN+2,50,1,"","SE","",RSP,STAT); IF STAT < 0 THEN STOP
IF MEMO.MESSAGE NE "" THEN OUT.MSG = MEMO.MESSAGE
LN = LN+4
PRINT @(0,LN):CLL:"Sorting option: by Geographic Area by Street Number":
LOOP
PRINT @(0,LN+1):CLL:"Do you want to sort the Disconnect Memos? (N/<cr>): ":; INPUT RSP
IF RSP = "KILL" THEN STOP
IF RSP = "" THEN SORT = 1; SORT.MSG = "Yes, by "
IF RSP = "N" THEN SORT = 0; RSP = ""; SORT.MSG = "No"
UNTIL RSP = "" DO PRINT BELL: REPEAT
IF SORT THEN
REPORT.NAME = TITLE
PRINT @(0,3):CLS:; VC = 4
CALL VERIFY.REPORT.PARAMS(VC,REPORT.NAME,PROG.NAME,AREA.CODE,AREA.SELECTION,AREA.DESCRIPTION,ZONE.POSITION,SVC.SELECTION,SVC.DESCRIPTION,SERVICES.DETAIL,RESP,REPORT.PARMS)
IF RSP = "N" THEN
PRINT @(0,3):CLS:
AUT = "M"; AREA.SELECTION = ""
CALL SELECT.AREA(AREA.SELECTION,PAR.FILE,ZONE.POSITION,AREA.DESCRIPTION,AREA.CODE,AUT,CO.NAME,STAT)
IF STAT = 999 THEN STOP
END
BEGIN CASE
CASE ZONE.POSITION = 2; AREA.CODE = "SA"
CASE ZONE.POSITION = 3; AREA.CODE = "SG"
CASE ZONE.POSITION = 4; AREA.CODE = "FL"
CASE ZONE.POSITION = 5; AREA.CODE = "RA"
CASE ZONE.POSITION = 6; AREA.CODE = "MUN"
CASE ZONE.POSITION = 7; AREA.CODE = "CNTY"
CASE ZONE.POSITION = 8; AREA.CODE = "SP"
CASE ZONE.POSITION = 9; AREA.CODE = "SALES"
CASE 1; STOP
END CASE
SORT.MSG = SORT.MSG:AREA.DESCRIPTION:" by Street Number"
END
*
PRINT @(0,3):CLS
PRINT @(5,5):CLL:"Disconnect Memos will be generated ":OPER.NAME:" for:":
PRINT @(5,7):CLL:"Latest Bill Date     : ":OCONV(LATEST.BILL.DATE,"D2") "R#9":
PRINT @(5,8):CLL:"Scanned on           : ":OCONV(SCANNED.ON,"D2") "R#9":
PRINT @(5,9):CLL:"Credit Status        : ":CREDIT.STATUS "R#9":
PRINT @(5,10):CLL:"Billing Run Number   : ":BILLING.RUN.NUM "R#9":
PRINT @(5,11):CLL:"Memo Scheduled Date  : ":MEMO.OUT.DATE "R#9":
PRINT @(5,12):CLL:"Starting Memo Number : ":MEMO.NUM "R#9":
PRINT @(5,13):CLL:"Memo Message         : ":OUT.MSG:
PRINT @(5,14):CLL:"Sorting option       : ":SORT.MSG:
IF SEND.TO.AI THEN
PRINT @(5,16):CLL:"AI Scheduled Date    : ":AI.OUT.DATE "R#9":
PRINT @(5,17):CLL:"AI Message           : ":AI.MESSAGE:
LN = 19
END ELSE LN = 16
LOOP
PRINT @(10,LN):CLL:"Enter A(bandon), R(eselect), or <cr> to commence: ":
INPUT RSP:; IF RSP = "A" OR RSP = "KILL" THEN STOP
IF RSP = "R" THEN PRINT @(0,3):CLS:; GOTO RELOOP
UNTIL RSP = "" DO PRINT BELL: REPEAT
LIST.NAME = "DLQ*":LATEST.BILL.DATE
EXLN = "GET-LIST ":LIST.NAME
* ULT ONLY
EXECUTE EXLN, //SELECT. > DLQ.ID.LIST
* EXECUTE EXLN; * REV ONLY
IF SORT THEN
PRINT "Now sorting...":
EXLN = "BY ":AREA.CODE:" BY STT"
* ULT ONLY
EXECUTE 'SSELECT DLQ ':EXLN, //SELECT. < DLQ.ID.LIST, //SELECT. > DLQ.ID.LIST
* EXECUTE 'SSELECT DLQ ':EXLN; * REV ONLY
END
!
LOOP
NEXT.DLQ: *
* ULT ONLY
READNEXT DLQ.ID FROM DLQ.ID.LIST ELSE GOTO FINISH
* READNEXT DLQ.ID ELSE GOTO FINISH; * REV ONLY
UNTIL DLQ.ID = "@@@" DO
CALL LOCK.ITEM(DLQ.FILE,"DLQ",DLQ.ID,LCK.FILE,STAT); IF STAT > 0 THEN LOCKED.CTR = LOCKED.CTR+1; GOTO NEXT.DLQ
MATREAD DLQ FROM DLQ.FILE,DLQ.ID ELSE MAT DLQ = ""
LOCATE LATEST.BILL.DATE IN DLQ$SCAN.DATE<1> SETTING VC ELSE GOTO NEXT.DLQ
SC = 1
LOOP
CALL.FUP = DLQ$CALL.FUP<1,1,SC>
IF CALL.FUP = "D" THEN DISC.ACTION.CTR = DISC.ACTION.CTR+1; GOTO NEXT.DLQ
IF CALL.FUP = "S" THEN SUSPEND.CTR = SUSPEND.CTR+1; GOTO NEXT.DLQ
UNTIL CALL.FUP = "" DO SC = SC+1 REPEAT
LOCATE "M" IN DLQ$CALL.TYPE<1,1> SETTING LOC ELSE LOC = 0
IF LOC THEN PREV.PROC.CTR = PREV.PROC.CTR+1; GOTO NEXT.DLQ
LOCATE "F" IN DLQ$CALL.TYPE<1,1> SETTING LOC ELSE LOC = 0
IF NOT(LOC) THEN BLANK.CTR = BLANK.CTR+1; GOTO NEXT.DLQ
MATREAD ACT FROM ACT.FILE,DLQ.ID ELSE GOTO NEXT.DLQ
INS DATE() BEFORE DLQ$CALL.DATE<1,VC,1>; * 11SEP90 *
IF ACT$STAT NE "A" THEN 
DISC.CTR = DISC.CTR+1
INS "N" BEFORE DLQ$CALL.FUP<1,VC,1>
GOTO WRITE.DLQ
END
IF ACT$CREDIT.STATUS LT CREDIT.STATUS THEN
NOT.DLQ.CTR = NOT.DLQ.CTR+1
INS "C" BEFORE DLQ$CALL.FUP<1,VC,1>
GOTO WRITE.DLQ
END
READV AIX.ID FROM ADD.FILE,ACT$ADD.ID,23 ELSE AIX.ID = ""
IF (AIX.ID # "" AND SEND.TO.AI) THEN ADDRESSABLE = 1 ELSE ADDRESSABLE = 0
INS "P" BEFORE DLQ$CALL.FUP<1,VC,1>
DLQ$MEMO.DATA<1,VC,1> = "M":NEXT.MEMO.NUM:"*":MEMO.SCH.DATE
WKO.ID = "M":NEXT.MEMO.NUM
MAT WKO = ""
IF ADDRESSABLE THEN
SCH.DATE = AI.SCH.DATE
SCH.TYPE = "AI"
EFF.DATE = SCH.DATE
MESSAGE = AI.MESSAGE
AI.CTR = AI.CTR+1
END ELSE
WKO.IDS<-1> = WKO.ID
DLQ.IDS<-1> = DLQ.ID
SCH.DATE = MEMO.SCH.DATE
EFF.DATE = DATE()
MESSAGE = OUT.MSG
PRINT.CTR = PRINT.CTR+1
END
WKO$ACT.ID = DLQ.ID
WKO$ADD.ID = ACT$ADD.ID
WKO$TYPE = "DM"
WKO$STAT = "P"
WKO$SCH.DATE = SCH.DATE
WKO$SCH.TIME = "C"
WKO$ENTRY.DATE = DLQ$CALL.DATE<1,VC,1>
WKO$EFF.DATE = EFF.DATE
WKO$ACTIVS = "I"
WKO$ACTIV.QNTYS = -1
WKO$MESSAGE = SPACE(13):MESSAGE
MATWRITE WKO ON WKO.FILE,WKO.ID
IF DIS.ITEM THEN LINE = " now generating: ":DLQ.ID:" Credit Status: ":ACT$CREDIT.STATUS:" balance owing: ":ACT$BALANCE "MR2M" ELSE LINE = ""
PRINT @(0,16):CLL:"To be printed: ":PRINT.CTR:LINE:
IF SEND.TO.AI THEN PRINT @(0,17):CLL:"To be sent via the AI: ":AI.CTR:
NEXT.MEMO.NUM = NEXT.MEMO.NUM+1
NEXT.MEMO.NUM = (NEXT.MEMO.NUM+100000)[2,5]
WRITE.DLQ: *
INS "M" BEFORE DLQ$CALL.TYPE<1,VC,1>
INS OPER BEFORE DLQ$CALL.OPERATOR<1,VC,1>
INS "" BEFORE DLQ$CALL.RESULT<1,VC,1>
INS "" BEFORE DLQ$CALL.COMMENT<1,VC,1>
INS "" BEFORE DLQ$CALL.FUP<1,VC,1>
CALL LOCK.ITEM(DLQ.FILE,"DLQ",DLQ.ID,LCK.FILE,STAT); IF STAT > 0 THEN GOTO NEXT.DLQ
MATWRITE DLQ ON DLQ.FILE,DLQ.ID
UPDATED = ""
CALL UNLOCK.ITEM(DLQ.FILE,"DLQ",DLQ.ID,LCK.FILE)
REPEAT
!
FINISH: *
IF WKO.IDS NE "" THEN
MEMO.IDS = WKO.IDS
PRINT @(0,17):CLL:"Now printing Memos...":
CALL @ROUTINE.NAME(WKO.IDS,ACT.FILE,ADD.FILE,STT.FILE,SVC.FILE,WKO.FILE,PAR.FILE,EFT.FILE,LCK.FILE)
LOOP UNTIL MEMO.IDS = "" DO
PRINT @(0,18):CLL:"Now deleting Memos...":
DLQ.ID = DLQ.IDS<1>
CALL LOCK.ITEM(DLQ.FILE,"DLQ",DLQ.ID,LCK.FILE,STAT)
MATREAD DLQ FROM DLQ.FILE,DLQ.ID ELSE MAT DLQ = ""
LOCATE LATEST.BILL.DATE IN DLQ$SCAN.DATE<1> SETTING VC ELSE VC = 1
DLQ$CALL.FUP<1,VC,1> = "P"
MATWRITE DLQ ON DLQ.FILE,DLQ.ID
CALL UNLOCK.ITEM(DLQ.FILE,"DLQ",DLQ.ID,LCK.FILE)
WKO.ID = MEMO.IDS<1>
DELETE WKO.FILE,WKO.ID
DEL MEMO.IDS<1>
DEL DLQ.IDS<1>
REPEAT
END
*
PRINT @(0,1):RVB:(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
PRINT @(0,2):CLS
PRINT @(15,6):CLL:"Processing completed.":
PRINT @(15,8):CLL:"Memos not printed for:":
PRINT @(17,9):CLL:"No longer Credit Status ":CREDIT.STATUS:"   ":NOT.DLQ.CTR "R#6":
PRINT @(17,10):CLL:"No longer Active            ":DISC.CTR "R#6":
PRINT @(17,11):CLL:"Further action suspended    ":SUSPEND.CTR "R#6":
PRINT @(17,12):CLL:"Not flagged for a Memo      ":BLANK.CTR "R#6":
PRINT @(17,13):CLL:"Already actioned for discon ":DISC.ACTION.CTR "R#6":
PRINT @(17,14):CLL:"Previously processed        ":PREV.PROC.CTR "R#6":
PRINT @(17,15):CLL:"Locked by another user      ":LOCKED.CTR "R#6":
PRINT @(15,17):CLL:"Disconnects generated:":
PRINT @(17,18):CLL:"Printed                 :     ":PRINT.CTR "R#6":
IF SEND.TO.AI THEN
PRINT @(17,19):CLL:"Sent via the AI         :     ":AI.CTR "R#6":
END
PRINT CLB:"Enter <cr>...":; INPUT TMP:
* CALL LOCK.ITEM(CNT.FILE,"CNT","LAST.BILLING.DATE",LCK.FILE,STAT); IF STAT > 0 THEN STAT = 999; RETURN; * REV ONLY
READU LAST.BILLING.DATE FROM CNT.FILE,"LAST.BILLING.DATE" ELSE NULL; * ULT ONLY
* READ LAST.BILLING.DATE FROM CNT.FILE,"LAST.BILLING.DATE" ELSE LAST.BILLING.DATE = ""; * REV ONLY
LOCATE DATE() IN LAST.BILLING.DATE<AC,22> BY "DR" SETTING LOC THEN
LAST.BILLING.DATE<AC,23,LOC> = LAST.BILLING.DATE<AC,23,LOC>+PRINT.CTR
END ELSE
INS "" BEFORE LAST.BILLING.DATE<AC,22,1>
INS "" BEFORE LAST.BILLING.DATE<AC,23,1>
LAST.BILLING.DATE<AC,22,1> = DATE()
LAST.BILLING.DATE<AC,23,1> = PRINT.CTR
LAST.BILLING.DATE<AC,24,1> = AI.CTR
END
WRITE LAST.BILLING.DATE ON CNT.FILE,"LAST.BILLING.DATE"
* CALL UNLOCK.ITEM(CNT.FILE,"CNT","LAST.BILLING.DATE",LCK.FILE); * REV ONLY
RELEASE CNT.FILE,"LAST.BILLING.DATE"; * ULT ONLY
WRITE NEXT.MEMO.NUM ON CNT.FILE,"NEXT.MEMO.NUM"
STOP
!
END
~PRINT.PPV.BUYS.PA~
*PROGRAM: PRINT.PPV.BUYS.PA
* VERSION: 940911 1.0  NEW
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
* DESCRIPTION:  PRINT UPLOADED PPV BUYS BY DATE BY GROUP BY DVC.ID.
!
$INCLUDE IBP STANDARD.FUNCTIONS
INPUT AUTO.RUN:
VERSION = "( 1.0)"; VS = VERSION
*
*
$INCLUDE IBP XPV.DIM
$INCLUDE IBP XPV.EQUATES
*
OPEN "CNT" TO CNT.FILE ELSE STOP
OPEN "PAR" TO PAR.FILE ELSE STOP
OPEN "XPV" TO XPV.FILE ELSE STOP
!
*
READ SYS.TST FROM CNT.FILE,"PPV.TEST" ELSE SYS.TST = ""
$INCLUDE IBP SYSTEM.TEST
IF TEST.FL THEN VERSION = VERSION:" **** TEST MODE ****"
*
*
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = "Unknown"
CO.NAME = CO.DATA<1>
*
*
PRINT @(0,0):CLS:
TITLE = "Print Uploaded Impulse PPV Buys":VERSION
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
IF NOT(AUTO.RUN) THEN
*
LOOP
PRINT @(0,6):"Unbilled uploaded item will be printed":
PRINT @(0,7):"Enter an Upload Date or <cr> for all: ":; INPUT UPLOAD.DATE:
IF UPLOAD.DATE EQ "" THEN UPLOAD.DATE = "ALL" ELSE UPLOAD.DATE = ICONV(UPLOAD.DATE,"D")
UNTIL UPLOAD.DATE NE "" DO PRINT BELL: REPEAT
GROUP = ""
*
CALL AUTO.LOADER("PRINT.PPV.BUYS.PA",UPLOAD.DATE:VM:GROUP,"Upl PPV Buys")
END ELSE
READ CURRENT.RUN FROM CNT.FILE,"CURRENT.RUN" ELSE STOP
UPLOAD.DATE = CURRENT.RUN<1,2>
END
IF UPLOAD.DATE = "ALL" THEN UPLOAD.DATE = ""
*
!
*
PRINT @(0,10):
IF UPLOAD.DATE NE "" THEN
EXLN.DT = ' AND WITH DATE = "':UPLOAD.DATE:'" '
END ELSE EXLN.DT = ""
EXLN = 'WITH DONE NE "Y"':EXLN.DT:' BY DATE BY GROUP BY SEQ BY-EXP EVENT.NUMS'
IF TEST.FL THEN PRINT EXLN:
*
EXECUTE 'SSELECT XPV ':EXLN, //SELECT. > XPV.ID.LIST
*
*EXLN = 'LIST XPV GROUP DATE SEQ DVC.ID CO ACCOUNT EVENT.NUMS EVENT.DUR ERROR HEADING "'D'              Unbilled Uploaded PPV Buys              Page 'P'" ID-SUPP (P)'
****EXLN = 'LIST XPV BREAK-ON GROUP "':"'DL'":' Total events group ':"'V'":' is " BREAK-ON DATE "':"'DL'":' No. events for ':"'V'":' is " SEQ DVC.ID CO BREAK-ON ACCOUNT "':"'DLR'":'" EVENT.NUMS EVENT.DUR ERROR TOTAL COUNT HEADING "':"'D'              Unbilled Uploaded PPV Buys              Page 'P'":'" ID-SUPP (P)'
EXLN = 'LIST XPV BREAK-ON GROUP "':"'DL'":'GR" BREAK-ON DATE "':"'DL'":'Upld Date" SEQ DVC.ID CO BREAK-ON ACCOUNT "':"'DLR'":'Account" TOTAL COUNT EVENT.NUMS EVENT.DUR ERROR HEADING "':"'D'              Unbilled Uploaded PPV Buys              Page 'P'":'" ID-SUPP GRAND-TOTAL "Total number of events: " (P)'
*****EXLN = 'LIST XPV BREAK-ON GROUP "':"'DL'":'" BREAK-ON DATE "':"'DL'":'" SEQ DVC.ID CO BREAK-ON ACCOUNT "':"'DLR'":'" EVENT.NUMS EVENT.DUR TOTAL COUNT ERROR HEADING "':"'D'              Unbilled Uploaded PPV Buys              Page 'P'":'" ID-SUPP (P)'
**EXLN = 'LIST XPV GROUP DATE SEQ DVC.ID CO ACCOUNT EVENT.NUMS EVENT.DUR ERROR HEADING "':"'D'              Unbilled Uploaded PPV Buys              Page 'P'":'" ID-SUPP (P)'
* EXLN = 'LIST PVE PVM.ID CL DEBUT.DT PURGE.DT RUN.TM CH.CODE DESC DT TM DUR EVENT.NUM DOWNLOADED DLL.ERR ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" DBL-SPC (P)'
IF TEST.FL THEN PRINT EXLN:
EXECUTE EXLN, //SELECT. < XPV.ID.LIST
*
!
*
*
STOP
*
!
END
~PRINT.PPV.CH.SCH~
*PROGRAM: PRINT.PVM.CH.SCH
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       PRINT PPV EVENTS BY YYMM BY CHANNEL
*                    R.T = 0 is channel by month
*                    R.T = 1 is month by event number
!
VS = "  1.1"; RELEASE = " (R:?.?)"
TITLE = "Print PPV Program Schedule (Month and Channel)":VS
*
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open PVM":; INPUT RSP; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT "Can't open PVE":; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM":; INPUT RSP; STOP
OPEN "MD" TO MD.FILE ELSE PRINT "Can't open MD":; INPUT RSP; STOP
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
READ PPV.CHANNELS FROM COM.FILE,"PPV.CHANNELS" ELSE PPV.CHANNELS = ""
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
CH = ""; PERIOD = ""; TEXT = ""
!
INPUT AUTO.RUN
INPUT R.T
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
PERIOD = CURRENT.RUN<1,2>
CH  = CURRENT.RUN<1,3>
R.T = CURRENT.RUN<1,4>
END ELSE
*
LOOP
PRINT @(0,10):CLS:
PRINT @(10,10):CLL:"Enter Event Program Month (YYMM) for printing: ":; INPUT PERIOD:
IF PERIOD = "KILL" THEN STOP
IF NOT(PERIOD MATCHES "4N") THEN TEXT = "please use format YYMM" ELSE
IF PERIOD[3,2] < "01" OR PERIOD[3,2] > "12" THEN TEXT = "month not 01-12"
END
IF TEXT NE "" THEN
PRINT CLB:TEXT:" Enter <cr>: ":BELL:; INPUT TMP:; TEXT = ""; PERIOD = ""; PRINT CLB:
END
WHILE PERIOD = "" DO REPEAT
*
IF NOT(R.T) THEN
LOOP
PRINT @(10,12):CLL:"Enter Channel Code for printing: ":; INPUT CH:
IF CH = "KILL" THEN STOP
LOCATE CH IN PPV.CHANNELS<1> BY "AL" SETTING LOC ELSE
LOCATE CH IN PPV.CHANNELS<2> BY "AR" SETTING LOC ELSE
CH = ""
END
END
WHILE CH = "" DO PRINT BELL: REPEAT
END
*
!
*
CALL AUTO.LOADER("PRINT.PPV.CH.SCH",PERIOD:VM:CH:VM:R.T,"Channel-Sched")
*
*
END
*
!
*
IF R.T THEN
EXEC.VERB = 'SSELECT PVE WITH PROGMO = "':PERIOD:'" BY EVENT.NUM'
END ELSE
EXEC.VERB = 'SSELECT PVE WITH PROGMO = "':PERIOD:'" AND WITH CH.CODE = "':CH:'" BY DT BY TM'
END
*
**PRINT @(0,15):EXEC.VERB:CLL:
*
* EXECUTE EXEC.VERB; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
*%%ULT%%=EXECUTE EXEC.VERB, //SELECT. > SLIST
*
*%%XXX%%=IF SEL.ERROR<1,1> = "401" THEN
*%%XXX%%=PRINT SEL.ERROR
*%%XXX%%=STOP
*%%XXX%%=END
*
!
*
IF R.T THEN
*
REPORT.TITLE = "All PPV Events for the month of ":PERIOD
$INCLUDE IBP REPORT.HEADER
*
* EXEC.VERB = 'LIST PVE SPACE PVM.ID DISTR STUDIO CL DEBUT.DT RUN.TM PURGE.DT CH.CODE DESC DT DUR EVENT.NUM ID-SUPP HEADING "'REPORT.HEADER:REPORT.TITLE:" ":'" DBL-SPC (P)'; * REV ONLY
* EXECUTE EXEC.VERB; * REV ONLY
*
* ULT ONLY
EXEC.VERB1A = 'LIST PVE PVM.ID DISTR STUDIO CL'
EXEC.VERB1B = ' DEBUT.DT PURGE.DT RUN.TM CH.CODE DESC DT TM EVENT.NUM'
EXEC.VERB1C = ' ID-SUPP'
EXEC.VERB1D = ' HEADING "'REPORT.HEADER
EXEC.VERB1E = REPORT.TITLE:" ":'" DBL-SPC (P)'
*
EXEC.VERB1 = EXEC.VERB1A:EXEC.VERB1B:EXEC.VERB1C:EXEC.VERB1D:EXEC.VERB1E
*
PRINT
PRINT EXEC.VERB
PRINT EXEC.VERB1
*
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
*%%ULT%%=EXECUTE EXEC.VERB1, //SELECT. < SLIST
CASE OPSYS EQ "M"
*****%%MDD%%=EXECUTE EXEC.VERB, //IN. < EXEC.VERB1
PROC = 'PQN':AM:'C':AM:'CCCC':AM:'C':AM
PROC = PROC:'H':EXEC.VERB:AM:'STON':AM
**PROC = PROC:'H':EXEC.VERB1:'<':AM
PROC = PROC:'H':EXEC.VERB1A:'<<':AM
PROC = PROC:'H':EXEC.VERB1B:'<<':AM
PROC = PROC:'H':EXEC.VERB1C:'<<':AM
PROC = PROC:'H':EXEC.VERB1D:'<<':AM
PROC = PROC:'H':EXEC.VERB1E:'<':AM
PROC = PROC:'P':AM:'C':AM:'CCCC':AM:'C':'RTN'
WRITE PROC ON MD.FILE,'PRINT.PPV.CH.SCH.PROC1'
*%%MDD%%=EXECUTE 'PRINT.PPV.CH.SCH.PROC1'
CASE TRUE
EXECUTE EXEC.VERB
END CASE
*
END ELSE
*
REPORT.TITLE = "Program Schedule for Channel ":CH:" for the month of ":PERIOD
$INCLUDE IBP REPORT.HEADER
*
* EXEC.VERB1 = 'LIST PVE SPACE PVM.ID DISTR STUDIO CL RATE.CL RATE.CL.SUB DEBUT.DT RUN.TM PURGE.DT CH.CODE DESC DUR EVENT.NUM BREAK-ON DT TM ID-SUPP HEADING "'REPORT.HEADER:REPORT.TITLE:" ":'" DBL-SPC (P)'; * REV ONLY
* EXECUTE EXEC.VERB1; * REV ONLY
*
* ULT ONLY
EXEC.VERB1A = 'LIST PVE PVM.ID DISTR STUDIO CL RATE.CL RATE.CL.SUB'
EXEC.VERB1B = ' DEBUT.DT PURGE.DT RUN.TM CH.CODE DESC DUR EVENT.NUM'
EXEC.VERB1C = ' BREAK-ON DT TM ID-SUPP'
EXEC.VERB1D = ' HEADING "':REPORT.HEADER
EXEC.VERB1E = REPORT.TITLE:" ":'" DBL-SPC (P)'
*
EXEC.VERB1 = EXEC.VERB1A:EXEC.VERB1B:EXEC.VERB1C:EXEC.VERB1D:EXEC.VERB1E
*
PRINT
PRINT EXEC.VERB
PRINT EXEC.VERB1
*
BEGIN CASE
CASE OPSYS EQ "U"
* ULT ONLY
*%%ULT%%=EXECUTE EXEC.VERB1, //SELECT. < SLIST
CASE OPSYS EQ "M"
*****%%MDD%%=EXECUTE EXEC.VERB, //IN. < EXEC.VERB1
PROC = 'PQN':AM:'C':AM:'CCCC':AM:'C':AM
PROC = PROC:'H':EXEC.VERB:AM:'STON':AM
**PROC = PROC:'H':EXEC.VERB1:'<':AM
PROC = PROC:'H':EXEC.VERB1A:'<<':AM
PROC = PROC:'H':EXEC.VERB1B:'<<':AM
PROC = PROC:'H':EXEC.VERB1C:'<<':AM
PROC = PROC:'H':EXEC.VERB1D:'<<':AM
PROC = PROC:'H':EXEC.VERB1E:'<':AM
PROC = PROC:'P':AM:'C':AM:'CCCC':AM:'C':'RTN'
WRITE PROC ON MD.FILE,'PRINT.PPV.CH.SCH.PROC'
*%%MDD%%=EXECUTE 'PRINT.PPV.CH.SCH.PROC'
CASE TRUE
EXECUTE EXEC.VERB
END CASE
*
!
*
END
*
!
*
STOP
!
END
~PRINT.PPV.DNLD.RPT~
*PROGRAM: PRINT.PVM.DNLD.RPT
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       PRINT PPV EVENTS BY YYMM BY CHANNEL
*                    SHOWING DOWNLOAD FLAG AND ERROR
!
VS = "  1.1"; RELEASE = " (R:?.?)"
TITLE = "Print PPV Download Report (Month and Channel)":VS
*
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open PVM":; INPUT RSP; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT "Can't open PVE":; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM":; INPUT RSP; STOP
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
READ PPV.CHANNELS FROM COM.FILE,"PPV.CHANNELS" ELSE PPV.CHANNELS = ""
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
CH = ""; PERIOD = ""; TEXT = ""
!
INPUT AUTO.RUN
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
PER = CURRENT.RUN<1,2>
CH  = CURRENT.RUN<1,3>
END ELSE
*
LOOP
PRINT @(0,10):CLS:
PRINT @(10,10):CLL:"Enter Event Program Month (YYMM) for printing: ":; INPUT PERIOD:
IF PERIOD = "KILL" THEN STOP
IF NOT(PERIOD MATCHES "4N") THEN TEXT = "please use format YYMM" ELSE
IF PERIOD[3,2] < "01" OR PERIOD[3,2] > "12" THEN TEXT = "month not 01-12"
END
IF TEXT NE "" THEN
PRINT CLB:TEXT:" Enter <cr>: ":BELL:; INPUT TMP:; TEXT = ""; PERIOD = ""; PRINT CLB:
END
WHILE PERIOD = "" DO REPEAT
*
LOOP
PRINT @(10,12):CLL:"Enter Channel Code for printing: ":; INPUT CH:
IF CH = "KILL" THEN STOP
LOCATE CH IN PPV.CHANNELS<1> BY "AL" SETTING LOC ELSE
LOCATE CH IN PPV.CHANNELS<2> BY "AR" SETTING LOC ELSE
CH = ""
END
END
WHILE CH = "" DO PRINT BELL: REPEAT
*
CALL AUTO.LOADER("PRINT.PPV.DNLD.RPT",PERIOD:VM:CH,"Download Rpt.")
END
*
EXLN = 'SSELECT PVE WITH PROGMO = "':PERIOD:'" AND WITH CH.CODE = "':CH:'" BY DT BY TM'
PRINT @(0,15):EXLN:CLL:
* EXECUTE EXLN; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
EXECUTE EXLN, //SELECT. > SLIST
REPORT.TITLE = "IPPV Download Report for Channel ":CH:" for the month of ":PERIOD
$INCLUDE IBP REPORT.HEADER
*
* EXLN = 'LIST PVE SPACE PVM.ID CL DEBUT.DT RUN.TM PURGE.DT CH.CODE DESC DT TM DUR EVENT.NUM DOWNLOADED DLL.ERR ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" DBL-SPC (P)'; * REV ONLY
* EXECUTE EXLN; * REV ONLY
*
* ULT ONLY
EXLN = 'LIST PVE PVM.ID CL DEBUT.DT PURGE.DT RUN.TM CH.CODE DESC DT TM DUR EVENT.NUM DOWNLOADED DLL.ERR ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" DBL-SPC (P)'
* ULT ONLY
EXECUTE EXLN, //SELECT. < SLIST
STOP
!
END
~PRINT.PVM.ALPHA~
*PROGRAM: PRINT.PVM.ALPHA
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       PRINT PVM MASTERS ALPHABETICALLY BY YYMM
*                    USED AS A REFERENCE BY THE CSRs.
!
VS = "  1.0"; RELEASE = " (R:3.0)"
TITLE = "Print PPV Masters Alphabetically (for a Month)":VS
*
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open PVM":; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM":; INPUT RSP; STOP
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
READ PPV.CHANNELS FROM COM.FILE,"PPV.CHANNELS" ELSE PPV.CHANNELS = ""
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
CH = ""; PERIOD = ""; TEXT = ""
!
INPUT AUTO.RUN
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
PERIOD = CURRENT.RUN<1,2>
END ELSE
*
LOOP
PRINT @(0,10):CLS:
PRINT @(10,10):CLL:"Enter Event Program Month (YYMM) for printing: ":; INPUT PERIOD:
IF PERIOD = "KILL" THEN STOP
IF NOT(PERIOD MATCHES "4N") THEN TEXT = "please use format YYMM" ELSE
IF PERIOD[3,2] < "01" OR PERIOD[3,2] > "12" THEN TEXT = "month not 01-12"
END
IF TEXT NE "" THEN
PRINT CLB:TEXT:" Enter <cr>: ":BELL:; INPUT TMP:; TEXT = ""; PERIOD = ""; PRINT CLB:
END
WHILE PERIOD = "" DO REPEAT
*
CALL AUTO.LOADER("PRINT.PPV.CH.SCH",PERIOD,"PVM Alpha")
END
*
EXLN = 'SSELECT PVM WITH PROGMO = "':PERIOD:'"'
PRINT @(0,15):EXLN:CLL:
* EXECUTE EXLN; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
EXECUTE EXLN, //SELECT. > SLIST
*
REPORT.TITLE = "Alphabetical List of All PPV Events for the month of ":PERIOD
$INCLUDE IBP REPORT.HEADER
*
* EXLN = 'LIST PVM DESC CH.CODE HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" (P)'; * REV ONLY
* EXECUTE EXLN; * REV ONLY
*
* ULT ONLY
EXLN = 'LIST PVM DESC CH.CODE HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" (P)'
* ULT ONLY
EXECUTE EXLN, //SELECT. < SLIST
*
STOP
!
END
~PRINT.PVM.BY.CMP~
*PROGRAM:           PRINT.PVM.BY.CMP
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       PRINT PPV EVENT MASTER BY COMPONENT (CHANNEL)
!
VS = "  1.0"; RELEASE = " (R:2.9)"
TITLE = "PPV Master Events by Component":RELEASE
*
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open PVM":; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM":; INPUT RSP; STOP
*
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = ""
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
INPUT AUTO.RUN
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
COMP = CURRENT.RUN<1,2>
END ELSE
LOOP
PRINT @(10,10):CLL:"Enter Channel for printing or <cr> for all:":; INPUT COMP:
IF COMP = "KILL" THEN STOP
IF COMP = "" THEN COMP = "ALL"
IF COMP NE "ALL" THEN
LOCATE COMP IN COMPONENTS<1> BY "AL" SETTING LOC ELSE LOC = ""
IF NOT(LOC) THEN COMP = ""
END
WHILE COMP = "" DO
PRINT BELL:
REPEAT
CALL AUTO.LOADER("PRINT.PVM.BY.SUPPLIER",COMP,"PVM-Comp. ":COMP)
END
*
EXLN = 'SSELECT PVM BY COMP BY DISTR BY STUDIO'
IF COMP NE "ALL" THEN EXLN = EXLN:' WITH COMP = "':COMP:'"'
PRINT @(0,15):EXLN:CLL:
* EXECUTE EXLN; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
EXECUTE EXLN, //SELECT. > SLIST
REPORT.TITLE = "Event Masters by Component for ":COMP
$INCLUDE IBP REPORT.HEADER
*
* EXLN = 'LIST PVM SPACE BREAK-ON COMP DISTR STUDIO EVENT.ID DESC COMP DEBUT.DT PURGE.DT CL RATE.CL RATE.CL.SUB PROG.CL MRKT.CL RUN.TM ELP.TM STARS RATING PVE.ID PVE.DT PVE.TM CLASS ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" (P)'; * REV ONLY
* EXECUTE EXLN; * REV ONLY
*
* ULT ONLY
EXLN = 'LIST PVM BREAK-ON COMP DISTR STUDIO EVENT.ID DESC COMP DEBUT.DT PURGE.DT CL RATE.CL RATE.CL.SUB PROG.CL MRKT.CL RUN.TM ELP.TM STARS RATING PVE.ID PVE.DT PVE.TM CLASS ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" (P)'
* ULT ONLY
EXECUTE EXLN, //SELECT. < SLIST
STOP
!
END
~PRINT.PVM.BY.DISTR~
*PROGRAM:           PRINT.PVM.BY.SUPPLIER
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       PRINT PPV EVENT MASTER BY DISTRIBUTOR
!
VS = "  1.0"; RELEASE = " (R:2.9)"
TITLE = "PPV Master Events by Distributor":RELEASE
*
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP:; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open PVM":; INPUT RSP:; STOP
*
READ DISTRIBUTORS FROM PAR.FILE,"DISTRIBUTORS" ELSE DISTRIBUTORS = ""
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
INPUT AUTO.RUN
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
DISTR = CURRENT.RUN<1,2>
END ELSE
LOOP
PRINT @(10,10):CLL:"Enter Distributor for printing or <cr> for all:":; INPUT DISTR:
IF DISTR = "KILL" THEN STOP
IF DISTR = "" THEN DISTR = "ALL"
IF DISTR NE "ALL" THEN
LOCATE DISTR IN DISTRIBUTORS<1> BY "AL" SETTING LOC ELSE LOC = ""
IF NOT(LOC) THEN DISTR = ""
END
WHILE DISTR = "" DO
PRINT BELL:
REPEAT
CALL AUTO.LOADER("PRINT.PVM.BY.SUPPLIER",DISTR,"PVM-Distr ":DISTR)
END
*
EXLN = 'SSELECT PVM BY DISTR BY STUDIO'
IF DISTR NE "ALL" THEN EXLN = EXLN:' WITH DISTR = "':DISTR:'"'
PRINT @(0,15):EXLN:CLL:
* EXECUTE EXLN; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
EXECUTE EXLN, //SELECT. > SLIST
REPORT.TITLE = "Event Masters by Distributor for ":DISTR
$INCLUDE IBP REPORT.HEADER
*
* EXLN = 'LIST PVM SPACE BREAK-ON DISTR STUDIO EVENT.ID DESC COMP DEBUT.DT PURGE.DT CL RATE.CL RATE.CL.SUB PROG.CL MRKT.CL RUN.TM ELP.TM STARS RATING PVE.ID PVE.DT PVE.TM CLASS ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" (P)'; * REV ONLY
* EXECUTE EXLN; * REV ONLY
*
* ULT ONLY
EXLN = 'LIST PVM BREAK-ON DISTR STUDIO EVENT.ID DESC COMP DEBUT.DT PURGE.DT CL RATE.CL RATE.CL.SUB PROG.CL MRKT.CL RUN.TM ELP.TM STARS RATING PVE.ID PVE.DT PVE.TM CLASS ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" (P)'
* ULT ONLY
EXECUTE EXLN, //SELECT. < SLIST
STOP
!
END
~PRINT.PVM.DETAIL~
*PROGRAM: PRINT.PVM.DETAIL
* VERSION: 940412 1.1  CHANGED TO PROCESS PVE RECORDS.
* AUTHOR:            H HORSMAN - AXION
* DESCRIPTION:       PRINT PPV EVENT DETAILS OF ONE MASTER
!
VS = "  1.1"; RELEASE = " (R:?.?)"
TITLE = "Print the Details of an Event Master":VS
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT "Can't open PAR":; INPUT RSP; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT "Can't open PVM":; INPUT RSP; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT "Can't open PVE":; INPUT RSP; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open COM":; INPUT RSP; STOP
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
READ PPV.CHANNELS FROM COM.FILE,"PPV.CHANNELS" ELSE PPV.CHANNELS = ""
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
!
INPUT AUTO.RUN
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
EVENT.CODE = CURRENT.RUN<1,2>
END ELSE
*
LOOP
PRINT @(0,10):CLS:
PRINT @(0,10):CLL:"Enter the Event Code to be printed: ":; INPUT EVENT.CODE
IF EVENT.CODE = "KILL" OR EVENT.CODE = "" THEN STOP
MATREAD PVM FROM PVM.FILE,EVENT.CODE ELSE EVENT.CODE = ""
WHILE EVENT.CODE = "" DO PRINT BELL: REPEAT
PVM.DESC = PVM$DESC
*
CALL AUTO.LOADER("PRINT.PVM.DETAIL",EVENT.CODE,"Event Details")
END
*
EXLN = 'WITH PVM.ID = "':EVENT.CODE:'" BY DT BY TM'
PRINT @(0,15):EXLN:CLL:
* EXECUTE 'SSELECT PVE ':EXLN; * REV ONLY
* IF @LAST.ERROR = 401 THEN STOP; * REV ONLY
* ULT ONLY
EXECUTE 'SSELECT PVE ':EXLN, //SELECT. > SLIST
REPORT.TITLE = "Event details for the Event ":EVENT.CODE:" - ":PVM.DESC
$INCLUDE IBP REPORT.HEADER
*
* EXLN = 'LIST PVE SPACE DISTR STUDIO CL RATE.CL RATE.CL.SUB DEBUT.DT RUN.TM PURGE.DT CH.CODE DUR DT TM RATE.CL RATE.CL.SUB EVENT.NUMS ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" DBL-SPC (P)'; * REV ONLY
* EXECUTE EXLN; * REV ONLY
*
* ULT ONLY
EXLN = 'LIST PVE DISTR STUDIO CL RATE.CL RATE.CL.SUB DEBUT.DT PURGE.DT RUN.TM CH.CODE DUR DT TM RATE.CL RATE.CL.SUB EVENT.NUMS ID-SUPP HEADING "':"":REPORT.HEADER:REPORT.TITLE:" ":'" DBL-SPC (P)'
* ULT ONLY
EXECUTE EXLN, //SELECT. < SLIST
STOP
!
END
~PURGE.PPV.BUYS.PA~
*PROGRAM: PURGE.PPV.BUYS.PA
* VERSION: 940418 1.0  NEW
VS = " V:1.0"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1993              ALL RIGHTS RESERVED
*  
* AUTHOR:          HARVEY HORSMAN
* DESCRIPTION:     THIS PROGRAM PURGES THE XPV FILE.
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP XPV.DIM
$INCLUDE IBP XPV.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "BI"
*
OPEN "XPV" TO XPV.FILE ELSE PRINT "Can't open file XPV":; INPUT RSP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT":; INPUT RSP:; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS":; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = -5
STAT = FALSE
*
*
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CONTROL.DATE = CO.NAME<2,1>; CO.NAME = CO.NAME<1,1> ELSE CO.NAME = ""; CONTROL.DATE = DATE()
*
TITLE = "Purge Uploaded IPPV Buys"
*
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
XPV.CTR = 0; MAT XPV = EMPTY
*
*
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
GOSUB LOAD.TST
IF CNT.TST$ON THEN VS = VS:"*** TEST MODE ***"
*
!
* Write auto.run
EXEC.VERB = "RUN BP.AI PURGE.PPV.BUYS.PA"
EXEC.IN = EMPTY
EXEC.DESC = "Purge IPPV Buys"
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
!
* Process items
*
START: *
IF CNT.TST$LBL THEN PRINT CLB:"Start ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
IF NOT(AUTO.RUN) THEN
PRINT @(10,18):CLL:"Enter <cr> to proceed or KILL to stop: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
END
*
PRINT @(0,18):
EXLN = 'WITH DONE = "Y"'
* ULT ONLY
EXECUTE 'SSELECT XPV ':EXLN, //SELECT. > XPV.VALID.ID.LIST
* EXECUTE 'SSELECT XPV ':EXLN; * REV ONLY
*
!
NEXT: *
IF CNT.TST$LBL THEN PRINT CLB:"Next ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
* ULT ONLY
READNEXT XPV.ID FROM XPV.VALID.ID.LIST ELSE STOP
* READNEXT XPV.ID ELSE STOP; * REV ONLY
*
DELETE XPV.FILE,XPV.ID
*
*
XPV.CTR = XPV.CTR+1
PRINT @(10,10):"Deleting Uploaded Details: ":XPV.CTR "R#4":"  ":XPV.ID:
*
GOTO NEXT
*
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
END
~SH.MAINT.AI.CH.ERRORS~
*PROGRAM:           SH.MAINT.AI.CH.ERRORS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.1)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:29:44
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.CH.ERRORS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.CH.ERRORS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.1"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.CH.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CI"
TDC(1) = 13
TDT(1) = 9
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                Addressable Interface Channel Status Maintenance                ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"AI Code":RVE:"":
PRINT @(0,4):CLS:"                                                       ":RVB:"         T":RVE:"":
PRINT @(0,5):CLS:"                                                       ":RVB:"T  D M   r Min's.":RVE:"":
PRINT @(0,6):CLS:"                                                       ":RVB:"y  i n L i Pause. .Var.":RVE:"":
PRINT @(0,7):CLS:"          ":RVB:"Command":RVE:"                                      ":RVB:"p  s g o e before .to..":RVE:"":
PRINT @(0,8):CLS:"          ":RVB:"Std A/I":RVE:"   ":RVB:"Description              ":RVE:"     ":RVB:"Func":RVE:" ":RVB:"e  p r g s Retry. .Set.":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.CH.ERRORS +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.CH.ERRORS."
FLD = RSP
COM.ID.SAVE<1> = "AI.CH.ERRORS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,9,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,9,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
COM.ID.SAVE<2> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN AI.TYPES<ONE> SETTING LOC THEN TRN.FLD = AI.TYPES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(15,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(15,LN):SPACE(25):
RETURN
*
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.CH.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L3","5","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 11
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E,I01F,I01G,I01H,I01I,I01J,I01K
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 11
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<2,VC>
INS EMPTY BEFORE COM<3,VC>
INS EMPTY BEFORE COM<4,VC>
INS EMPTY BEFORE COM<5,VC>
INS EMPTY BEFORE COM<6,VC>
INS EMPTY BEFORE COM<7,VC>
INS EMPTY BEFORE COM<8,VC>
INS EMPTY BEFORE COM<9,VC>
INS EMPTY BEFORE COM<10,VC>
INS EMPTY BEFORE COM<11,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<2,VC>
DEL COM<3,VC>
DEL COM<4,VC>
DEL COM<5,VC>
DEL COM<6,VC>
DEL COM<7,VC>
DEL COM<8,VC>
DEL COM<9,VC>
DEL COM<10,VC>
DEL COM<11,VC>
*
RETURN
*
I01A: *
*
IF COM<1,VC> EQ " " THEN COM<1,VC> = EMPTY
PRINT @(7,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","1",COM,10,LN,"L3","5",1:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,10,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","2",COM,14,LN,"L3","5",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,14,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","3",COM,20,LN,"L25","25",3:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,20,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("COM","4",COM,50,LN,"L3","3",4:",":VC,"","OP":VM:"EQ":SVM:"ON":SVM:"OFF":SVM:"UP":SVM:"DN":SVM:"NUL","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,50,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("COM","5",COM,55,LN,"L2","2",5:",":VC,"","OP":VM:"EQ":SVM:"ON":SVM:"OFF":SVM:"UP":SVM:"DN":SVM:"NUL":SVM:"DATA":SVM:"PORT":SVM:"CMND":SVM:"TOUT":SVM:"STAT":SVM:"FUNC","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,55,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
I01F: *
*
CALL INPUT.DATA.SG1("COM","6",COM,58,LN,"L1","1",6:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,58,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01F
RETURN
*
I01G: *
*
CALL INPUT.DATA.SG1("COM","7",COM,60,LN,"L1","1",7:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,60,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01G
RETURN
*
I01H: *
*
CALL INPUT.DATA.SG1("COM","8",COM,62,LN,"L1","1",8:",":VC,"","EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,62,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01H
RETURN
*
I01I: *
*
CALL INPUT.DATA.SG1("COM","9",COM,64,LN,"L1","1",9:",":VC,"","NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,64,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01I
RETURN
*
I01J: *
*
CALL INPUT.DATA.SG1("COM","10",COM,67,LN,"L4","5",10:",":VC,"","NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,67,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01J
RETURN
*
I01K: *
*
CALL INPUT.DATA.SG1("COM","11",COM,73,LN,"L5","15",11:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,73,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01K
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#3":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#3":
PRINT @(14,LN):COM<2,VC> "L#3":
PRINT @(20,LN):COM<3,VC> "L#25":
PRINT @(50,LN):COM<4,VC> "L#3":
PRINT @(55,LN):COM<5,VC> "L#2":
PRINT @(58,LN):COM<6,VC> "L#1":
PRINT @(60,LN):COM<7,VC> "L#1":
PRINT @(62,LN):COM<8,VC> "L#1":
PRINT @(64,LN):COM<9,VC> "L#1":
PRINT @(67,LN):COM<10,VC> "L#4":
PRINT @(73,LN):COM<11,VC> "L#5":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(7,LN.TMP):SPACE(6):
PRINT @(14,LN.TMP):SPACE(3):
PRINT @(20,LN.TMP):SPACE(25):
PRINT @(50,LN.TMP):SPACE(3):
PRINT @(55,LN.TMP):SPACE(2):
PRINT @(58,LN.TMP):SPACE(1):
PRINT @(60,LN.TMP):SPACE(1):
PRINT @(62,LN.TMP):SPACE(1):
PRINT @(64,LN.TMP):SPACE(1):
PRINT @(67,LN.TMP):SPACE(4):
PRINT @(73,LN.TMP):SPACE(5):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.CHANNELS~
*PROGRAM:           SH.MAINT.AI.CHANNELS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:31:58
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "PLANT"
SYS.PROG = "MAINT.AI.CHANNELS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.CHANNELS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "SVC" TO SVC.FILE ELSE FILE.NAME = "SVC"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
SVC.ID = EMPTY; SVC.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 132
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CO"
TDC(1) = 10
TDT(1) = 8
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                        Channels by AI Code Maintenance                         ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"  AI Code ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"Service  ":RVE:" ":RVB:"Chan":RVE:" ":RVB:"Component                ":RVE:"  ":RVB:"Prog/Distr ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"  Name   ":RVE:" ":RVB:" ###":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.CHANNELS +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.CHANNELS."
FLD = RSP
COM.ID.SAVE<1> = "AI.CHANNELS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,12,4,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,12,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,23,23,"L8","8","1","","SE":VM:"OP":VM:"OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,23,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 2
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<3,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<3,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,0,LN,"L8","8",1:",":VC,"","OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN ELSE GOSUB T01
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,11,LN,"L3","3",3:",":VC,"","OP":VM:"MA":SVM:"0N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,11,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
IF STAT THEN RETURN ELSE GOSUB T02
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):COM<1,VC> "L#8":; GOSUB T01
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):COM<1,VC> "L#8":; GOSUB T01
PRINT @(11,LN):COM<3,VC> "L#3":; GOSUB T02
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(8):; GOSUB TC01
PRINT @(11,LN.TMP):SPACE(3):; GOSUB TC02
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
T01: *
*
TRN.FLD = COM<1,VC>
LOCATE TRN.FLD IN COMPONENTS<ONE> SETTING LOC THEN TRN.FLD = COMPONENTS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(15,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(15,LN):SPACE(25):
RETURN
T02: *
*
TRN.FLD = COM<1,VC>
LOCATE TRN.FLD IN COMPONENTS<1> SETTING LOC THEN TRN.FLD = COMPONENTS<8,LOC> ELSE TRN.FLD = EMPTY
PRINT @(44,LN):TRN.FLD "L#8":
RETURN
*
TC02: *
PRINT @(44,LN):SPACE(8):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.CMD.CNTRL~
*PROGRAM:           SH.MAINT.AI.CMD.CNTRL
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:33:48
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.CMD.CNTRL"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.CMD.CNTRL"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIICMD.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIICMD.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.CMD.CNTRL(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AIICMD.ID = EMPTY; COM.AIICMD.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CI"
TDC(1) = 17
TDT(1) = 5
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AIICMD.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AIICMD.ID.SAVE = EMPTY
END ELSE
COM.AIICMD.ID = EMPTY; COM.AIICMD.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AIICMD.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.AIICMD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD COM.AIICMD FROM COM.FILE,COM.AIICMD.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AIICMD = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.AIICMD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.AIICMD.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AIICMD ON COM.FILE,COM.AIICMD.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                  Addressable Interfacer Commands Maintenance                   ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Intfc. Code":RVE:"                                          ":RVB:"# of ":RVE:"  ":RVB:"Resp ":RVE:"  ":RVB:" Cmd ":RVE:"":
PRINT @(0,4):CLS:"       ":RVB:"l#":RVE:" ":RVB:"Command":RVE:"   ":RVB:"Description                   ":RVE:"   ":RVB:"Tries":RVE:"  ":RVB:"Pause":RVE:"  ":RVB:"Logs ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AIICMD.ID
FOR ID.CN = ONE TO 2; COM.AIICMD.ID.SAVE<ID.CN> = "!":COM.AIICMD.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AIICMD.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.AIICMD.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.AIICMD.ID = EMPTY
COM.AIICMD.ID = COM.AIICMD.ID:COM.AIICMD.ID.SAVE<1>
COM.AIICMD.ID = COM.AIICMD.ID:COM.AIICMD.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.CMD.CNTRL +Itm:":COM.AIICMD.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.COMMANDS."
FLD = RSP
COM.AIICMD.ID.SAVE<1> = "AI.COMMANDS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.AIICMD.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,15,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,15,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.AIICMD.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.CMD.CNTRL(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AIICMD.RCVD",FLD,9,23,"L4","4","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM.AIICMD$RCVD<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 5
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 5
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM.AIICMD$RCVD<ONE> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM.AIICMD$RCVD<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM.AIICMD$RCVD<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$DESC<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$RETRY<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$PAUSE<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$LOG<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM.AIICMD$RCVD<ONE,VC>
DEL COM.AIICMD$DESC<ONE,VC>
DEL COM.AIICMD$RETRY<ONE,VC>
DEL COM.AIICMD$PAUSE<ONE,VC>
DEL COM.AIICMD$LOG<ONE,VC>
*
RETURN
*
I01A: *
*
IF COM.AIICMD$RCVD<ONE,VC> EQ " " THEN COM.AIICMD$RCVD<ONE,VC> = EMPTY
PRINT @(7,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","AIICMD.RCVD",COM.AIICMD$RCVD,10,LN,"L4","4",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,10,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.DESC",COM.AIICMD$DESC,20,LN,"L30","30",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,20,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.RETRY",COM.AIICMD$RETRY,55,LN,"L1","1",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,55,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.PAUSE",COM.AIICMD$PAUSE,61,LN,"L3","3",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,61,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.LOG",COM.AIICMD$LOG,69,LN,"L1","1",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,69,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AIICMD$RCVD<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIICMD$RCVD<ONE,VC> "L#4":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AIICMD$RCVD<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIICMD$RCVD<ONE,VC> "L#4":
PRINT @(20,LN):COM.AIICMD$DESC<ONE,VC> "L#30":
PRINT @(55,LN):COM.AIICMD$RETRY<ONE,VC> "L#1":
PRINT @(61,LN):COM.AIICMD$PAUSE<ONE,VC> "L#3":
PRINT @(69,LN):COM.AIICMD$LOG<ONE,VC> "L#1":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(7,LN.TMP):SPACE(7):
PRINT @(20,LN.TMP):SPACE(30):
PRINT @(55,LN.TMP):SPACE(1):
PRINT @(61,LN.TMP):SPACE(3):
PRINT @(69,LN.TMP):SPACE(1):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.COMMANDS~
*PROGRAM:           SH.MAINT.AI.COMMANDS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:36:45
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.COMMANDS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.COMMANDS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIICMD.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIICMD.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.COMMANDS(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AIICMD.ID = EMPTY; COM.AIICMD.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CI"
TDC(1) = 17
TDT(1) = 5
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AIICMD.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AIICMD.ID.SAVE = EMPTY
END ELSE
COM.AIICMD.ID = EMPTY; COM.AIICMD.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AIICMD.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.AIICMD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD COM.AIICMD FROM COM.FILE,COM.AIICMD.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AIICMD = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.AIICMD.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.AIICMD.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AIICMD ON COM.FILE,COM.AIICMD.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                  Addressable Interfacer Commands Maintenance                   ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Intfc. Code":RVE:"                                          ":RVB:" Cmd ":RVE:"  ":RVB:" Box ":RVE:"  ":RVB:" Box ":RVE:"":
PRINT @(0,4):CLS:"       ":RVB:"l#":RVE:" ":RVB:"Command":RVE:"   ":RVB:"Description                   ":RVE:"   ":RVB:"Actv?":RVE:"  ":RVB:"Sel.?":RVE:"  ":RVB:"Cmd.?":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AIICMD.ID
FOR ID.CN = ONE TO 2; COM.AIICMD.ID.SAVE<ID.CN> = "!":COM.AIICMD.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AIICMD.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.AIICMD.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.AIICMD.ID = EMPTY
COM.AIICMD.ID = COM.AIICMD.ID:COM.AIICMD.ID.SAVE<1>
COM.AIICMD.ID = COM.AIICMD.ID:COM.AIICMD.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.COMMANDS +Itm:":COM.AIICMD.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.COMMANDS."
FLD = RSP
COM.AIICMD.ID.SAVE<1> = "AI.COMMANDS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.AIICMD.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,15,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,15,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.AIICMD.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.COMMANDS(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AIICMD.RCVD",FLD,9,23,"L4","4","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM.AIICMD$RCVD<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 5
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 5
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM.AIICMD$RCVD<ONE> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM.AIICMD$RCVD<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM.AIICMD$RCVD<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$DESC<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$CMD.ACTV<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$BOX.SEL<ONE,VC>
INS EMPTY BEFORE COM.AIICMD$BOX.CMD<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM.AIICMD$RCVD<ONE,VC>
DEL COM.AIICMD$DESC<ONE,VC>
DEL COM.AIICMD$CMD.ACTV<ONE,VC>
DEL COM.AIICMD$BOX.SEL<ONE,VC>
DEL COM.AIICMD$BOX.CMD<ONE,VC>
*
RETURN
*
I01A: *
*
IF COM.AIICMD$RCVD<ONE,VC> EQ " " THEN COM.AIICMD$RCVD<ONE,VC> = EMPTY
PRINT @(7,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","AIICMD.RCVD",COM.AIICMD$RCVD,10,LN,"L4","4",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,10,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.DESC",COM.AIICMD$DESC,20,LN,"L30","30",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,20,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.CMD.ACTV",COM.AIICMD$CMD.ACTV,55,LN,"L1","1",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,55,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.BOX.SEL",COM.AIICMD$BOX.SEL,62,LN,"L1","1",ONE:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,62,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("COM","AIICMD.BOX.CMD",COM.AIICMD$BOX.CMD,69,LN,"L1","1",ONE:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,69,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AIICMD$RCVD<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIICMD$RCVD<ONE,VC> "L#4":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AIICMD$RCVD<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIICMD$RCVD<ONE,VC> "L#4":
PRINT @(20,LN):COM.AIICMD$DESC<ONE,VC> "L#30":
PRINT @(55,LN):COM.AIICMD$CMD.ACTV<ONE,VC> "L#1":
PRINT @(62,LN):COM.AIICMD$BOX.SEL<ONE,VC> "L#1":
PRINT @(69,LN):COM.AIICMD$BOX.CMD<ONE,VC> "L#1":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(7,LN.TMP):SPACE(7):
PRINT @(20,LN.TMP):SPACE(30):
PRINT @(55,LN.TMP):SPACE(1):
PRINT @(62,LN.TMP):SPACE(1):
PRINT @(69,LN.TMP):SPACE(1):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.CYPHER.KEYS~
*PROGRAM:           SH.MAINT.AI.CYPHER.KEYS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:39:51
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.CYPHER.KEYS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.CYPHER.KEYS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "AK"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.CYPHER.KEYS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 4
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "AK"
TDC(1) = 4
TDT(1) = 9
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                             Cypher Key Maintenance                             ":RVE:"":
PRINT @(0,7):CLS:"                              ":RVB:"    Active keys: (0-31)":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 1; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
PAR.ID = "AI.CYPHER.KEYS"
PAR.ID.SAVE<ONE> = "AI.CYPHER.KEYS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.CYPHER.KEYS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.CYPHER.KEYS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PAR","1",FLD,9,23,"L2","2","1","","SE":VM:"OP":VM:"MA":SVM:"0N":VM:"LO":SVM:"0":VM:"HI":SVM:"31","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PAR<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 1
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 1
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PAR<1> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PAR<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PAR<1,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PAR<1,VC>
*
RETURN
*
I01A: *
*
IF PAR<1,VC> EQ " " THEN PAR<1,VC> = EMPTY
PRINT @(34,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("PAR","1",PAR,37,LN,"L2","2",1:",":VC,"","OP":VM:"MA":SVM:"0N":VM:"LO":SVM:"0":VM:"HI":SVM:"31","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,37,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PAR<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(34,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":PAR<1,VC> "L#2":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PAR<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(34,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":PAR<1,VC> "L#2":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(34,LN.TMP):SPACE(5):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.ERRORS~
*PROGRAM:           SH.MAINT.AI.ERRORS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:41:33
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.ERRORS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.ERRORS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
0
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.ERRORS(TDL.REC,XYZ.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY

*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND .ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN .ID.SAVE = EMPTY
END ELSE
.ID = EMPTY; .ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF .ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE 0.FILE,.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*

UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = .ID
FOR ID.CN = ONE TO 0; .ID.SAVE<ID.CN> = "!":.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
.ID = TEMP
END
*
*
!
*
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 0
ON ID.CN GOSUB 
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 0 AND .ID.SAVE<0> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*

* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.ERRORS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.ERRORS(TDL.REC,XYZ.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB 
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*

*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.HERRORS~
*PROGRAM:           SH.MAINT.AI.HERRORS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:42:46
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.HERRORS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.HERRORS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIHERR.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIHERR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.HERRORS(TDL.REC,COM.AIHERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIHERR.ID,MAT COM.AIHERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AIHERR.ID = EMPTY; COM.AIHERR.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CI"
TDC(1) = 15
TDT(1) = 7
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AIHERR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AIHERR.ID.SAVE = EMPTY
END ELSE
COM.AIHERR.ID = EMPTY; COM.AIHERR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AIHERR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.AIHERR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD COM.AIHERR FROM COM.FILE,COM.AIHERR.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AIHERR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.AIHERR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.AIHERR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AIHERR ON COM.FILE,COM.AIHERR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                Addressable Interface Handler Errors Maintenance                ":RVE:"":
PRINT @(0,3):CLS:"                                                          ":RVB:"      T":RVE:"":
PRINT @(0,4):CLS:"                                                          ":RVB:"D M   r Sec's.":RVE:"":
PRINT @(0,5):CLS:"                                                          ":RVB:"i n L i Pause. .Var.":RVE:"":
PRINT @(0,6):CLS:"                                                          ":RVB:"s g o e before .to..":RVE:"":
PRINT @(0,7):CLS:"":RVB:"l#":RVE:"  ":RVB:"Error #":RVE:" ":RVB:"Description                        ":RVE:" ":RVB:"Func":RVE:" ":RVB:"Type":RVE:" ":RVB:"p r g s Retry. .Set.":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AIHERR.ID
FOR ID.CN = ONE TO 1; COM.AIHERR.ID.SAVE<ID.CN> = "!":COM.AIHERR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AIHERR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.AIHERR.ID = "AI.HERRORS"
COM.AIHERR.ID.SAVE<ONE> = "AI.HERRORS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.HERRORS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.HERRORS(TDL.REC,COM.AIHERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIHERR.ID,MAT COM.AIHERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AIHERR.STD",FLD,9,23,"L3","5","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM.AIHERR$STD<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 10
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E,I01F,I01G,I01H,I01I,I01J
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 10
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM.AIHERR$STD<ONE> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM.AIHERR$STD<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM.AIHERR$STD<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$DESC<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$FUNC<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$TYPE<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$DISP<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$MNGR<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$LOG<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$RETRY<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$PAUSE<ONE,VC>
INS EMPTY BEFORE COM.AIHERR$VAR<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM.AIHERR$STD<ONE,VC>
DEL COM.AIHERR$DESC<ONE,VC>
DEL COM.AIHERR$FUNC<ONE,VC>
DEL COM.AIHERR$TYPE<ONE,VC>
DEL COM.AIHERR$DISP<ONE,VC>
DEL COM.AIHERR$MNGR<ONE,VC>
DEL COM.AIHERR$LOG<ONE,VC>
DEL COM.AIHERR$RETRY<ONE,VC>
DEL COM.AIHERR$PAUSE<ONE,VC>
DEL COM.AIHERR$VAR<ONE,VC>
*
RETURN
*
I01A: *
*
IF COM.AIHERR$STD<ONE,VC> EQ " " THEN COM.AIHERR$STD<ONE,VC> = EMPTY
PRINT @(3,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","AIHERR.STD",COM.AIHERR$STD,6,LN,"L3","5",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,6,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.DESC",COM.AIHERR$DESC,12,LN,"L35","100",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,12,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.FUNC",COM.AIHERR$FUNC,48,LN,"L4","8",ONE:",":VC,"","OP":VM:"EQ":SVM:"ON":SVM:"OFF":SVM:"UP":SVM:"DN":SVM:"NUL","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,48,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.TYPE",COM.AIHERR$TYPE,53,LN,"L4","8",ONE:",":VC,"","OP":VM:"EQ":SVM:"ON":SVM:"OFF":SVM:"UP":SVM:"DN":SVM:"NUL":SVM:"DATA":SVM:"PORT":SVM:"CMND":SVM:"TOUT":SVM:"STAT":SVM:"FUNC","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,53,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.DISP",COM.AIHERR$DISP,58,LN,"L1","1",ONE:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,58,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
I01F: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.MNGR",COM.AIHERR$MNGR,60,LN,"L1","1",ONE:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,60,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01F
RETURN
*
I01G: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.LOG",COM.AIHERR$LOG,62,LN,"L1","1",ONE:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,62,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01G
RETURN
*
I01H: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.RETRY",COM.AIHERR$RETRY,64,LN,"L1","1",ONE:",":VC,"","NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,64,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01H
RETURN
*
I01I: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.PAUSE",COM.AIHERR$PAUSE,66,LN,"L4","5",ONE:",":VC,"","NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,66,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01I
RETURN
*
I01J: *
*
CALL INPUT.DATA.SG1("COM","AIHERR.VAR",COM.AIHERR$VAR,73,LN,"L5","15",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,73,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01J
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AIHERR$STD<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(3,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIHERR$STD<ONE,VC> "L#3":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AIHERR$STD<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(3,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIHERR$STD<ONE,VC> "L#3":
PRINT @(12,LN):COM.AIHERR$DESC<ONE,VC> "L#35":
PRINT @(48,LN):COM.AIHERR$FUNC<ONE,VC> "L#4":
PRINT @(53,LN):COM.AIHERR$TYPE<ONE,VC> "L#4":
PRINT @(58,LN):COM.AIHERR$DISP<ONE,VC> "L#1":
PRINT @(60,LN):COM.AIHERR$MNGR<ONE,VC> "L#1":
PRINT @(62,LN):COM.AIHERR$LOG<ONE,VC> "L#1":
PRINT @(64,LN):COM.AIHERR$RETRY<ONE,VC> "L#1":
PRINT @(66,LN):COM.AIHERR$PAUSE<ONE,VC> "L#4":
PRINT @(73,LN):COM.AIHERR$VAR<ONE,VC> "L#5":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(3,LN.TMP):SPACE(6):
PRINT @(12,LN.TMP):SPACE(35):
PRINT @(48,LN.TMP):SPACE(4):
PRINT @(53,LN.TMP):SPACE(4):
PRINT @(58,LN.TMP):SPACE(1):
PRINT @(60,LN.TMP):SPACE(1):
PRINT @(62,LN.TMP):SPACE(1):
PRINT @(64,LN.TMP):SPACE(1):
PRINT @(66,LN.TMP):SPACE(4):
PRINT @(73,LN.TMP):SPACE(5):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.IERRORS~
*PROGRAM:           SH.MAINT.AI.IERRORS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:46:17
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.IERRORS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.IERRORS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIIERR.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIIERR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.IERRORS(TDL.REC,COM.AIIERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIIERR.ID,MAT COM.AIIERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AIIERR.ID = EMPTY; COM.AIIERR.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CH"
TDC(1) = 13
TDT(1) = 9
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AIIERR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AIIERR.ID.SAVE = EMPTY
END ELSE
COM.AIIERR.ID = EMPTY; COM.AIIERR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AIIERR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.AIIERR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD COM.AIIERR FROM COM.FILE,COM.AIIERR.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AIIERR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.AIIERR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.AIIERR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AIIERR ON COM.FILE,COM.AIIERR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                    Addressable Interface Errors Maintenance                    ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Intfc Code":RVE:"":
PRINT @(0,4):CLS:"                                                 ":RVB:"      T":RVE:"":
PRINT @(0,5):CLS:"                                                 ":RVB:"D M   r Sec's.":RVE:"":
PRINT @(0,6):CLS:"                                                 ":RVB:"i n L i Pause.":RVE:"":
PRINT @(0,7):CLS:"          ":RVB:"Command":RVE:"                                ":RVB:"s g o e before":RVE:"":
PRINT @(0,8):CLS:"          ":RVB:"Std A/I":RVE:" ":RVB:"Description              ":RVE:" ":RVB:"Type":RVE:" ":RVB:"p r g s Retry.":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AIIERR.ID
FOR ID.CN = ONE TO 2; COM.AIIERR.ID.SAVE<ID.CN> = "!":COM.AIIERR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AIIERR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.AIIERR.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.AIIERR.ID = EMPTY
COM.AIIERR.ID = COM.AIIERR.ID:COM.AIIERR.ID.SAVE<1>
COM.AIIERR.ID = COM.AIIERR.ID:COM.AIIERR.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.IERRORS +Itm:":COM.AIIERR.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.IERRORS."
FLD = RSP
COM.AIIERR.ID.SAVE<1> = "AI.IERRORS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.AIIERR.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,12,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,12,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.AIIERR.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.IERRORS(TDL.REC,COM.AIIERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIIERR.ID,MAT COM.AIIERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AIIERR.STD",FLD,9,23,"L3","5","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM.AIIERR$STD<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 9
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E,I01F,I01G,I01H,I01I
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 9
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM.AIIERR$STD<ONE> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM.AIIERR$STD<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM.AIIERR$STD<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$RCVD<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$DESC<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$TYPE<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$DISP<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$MNGR<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$LOG<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$RETRY<ONE,VC>
INS EMPTY BEFORE COM.AIIERR$PAUSE<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM.AIIERR$STD<ONE,VC>
DEL COM.AIIERR$RCVD<ONE,VC>
DEL COM.AIIERR$DESC<ONE,VC>
DEL COM.AIIERR$TYPE<ONE,VC>
DEL COM.AIIERR$DISP<ONE,VC>
DEL COM.AIIERR$MNGR<ONE,VC>
DEL COM.AIIERR$LOG<ONE,VC>
DEL COM.AIIERR$RETRY<ONE,VC>
DEL COM.AIIERR$PAUSE<ONE,VC>
*
RETURN
*
I01A: *
*
IF COM.AIIERR$STD<ONE,VC> EQ " " THEN COM.AIIERR$STD<ONE,VC> = EMPTY
PRINT @(7,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","AIIERR.STD",COM.AIIERR$STD,10,LN,"L3","5",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,10,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.RCVD",COM.AIIERR$RCVD,14,LN,"L3","5",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,14,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.DESC",COM.AIIERR$DESC,18,LN,"L25","100",ONE:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,18,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.TYPE",COM.AIIERR$TYPE,44,LN,"L4","8",ONE:",":VC,"","OP":VM:"EQ":SVM:"OK":SVM:"FATL":SVM:"WARN":SVM:"STAT":SVM:"INFO","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,44,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.DISP",COM.AIIERR$DISP,49,LN,"L1","1",ONE:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,49,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
I01F: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.MNGR",COM.AIIERR$MNGR,51,LN,"L1","1",ONE:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,51,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01F
RETURN
*
I01G: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.LOG",COM.AIIERR$LOG,53,LN,"L1","1",ONE:",":VC,"","EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,53,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01G
RETURN
*
I01H: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.RETRY",COM.AIIERR$RETRY,55,LN,"L1","1",ONE:",":VC,"","NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,55,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01H
RETURN
*
I01I: *
*
CALL INPUT.DATA.SG1("COM","AIIERR.PAUSE",COM.AIIERR$PAUSE,57,LN,"L6","6",ONE:",":VC,"","NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,57,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01I
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AIIERR$STD<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIIERR$STD<ONE,VC> "L#3":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AIIERR$STD<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM.AIIERR$STD<ONE,VC> "L#3":
PRINT @(14,LN):COM.AIIERR$RCVD<ONE,VC> "L#3":
PRINT @(18,LN):COM.AIIERR$DESC<ONE,VC> "L#25":
PRINT @(44,LN):COM.AIIERR$TYPE<ONE,VC> "L#4":
PRINT @(49,LN):COM.AIIERR$DISP<ONE,VC> "L#1":
PRINT @(51,LN):COM.AIIERR$MNGR<ONE,VC> "L#1":
PRINT @(53,LN):COM.AIIERR$LOG<ONE,VC> "L#1":
PRINT @(55,LN):COM.AIIERR$RETRY<ONE,VC> "L#1":
PRINT @(57,LN):COM.AIIERR$PAUSE<ONE,VC> "L#6":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(7,LN.TMP):SPACE(6):
PRINT @(14,LN.TMP):SPACE(3):
PRINT @(18,LN.TMP):SPACE(25):
PRINT @(44,LN.TMP):SPACE(4):
PRINT @(49,LN.TMP):SPACE(1):
PRINT @(51,LN.TMP):SPACE(1):
PRINT @(53,LN.TMP):SPACE(1):
PRINT @(55,LN.TMP):SPACE(1):
PRINT @(57,LN.TMP):SPACE(6):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.MISC~
*PROGRAM:           SH.MAINT.AI.MISC
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:49:40
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.MISC"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.MISC"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(4); MAT TDL = EMPTY
DIM TDH(4); MAT TDH = EMPTY
DIM TDI(4); MAT TDI = EMPTY
DIM TDX(4); MAT TDX = ONE
DIM SAVE.TDX(4); MAT SAVE.TDX = EMPTY
DIM TDM(4); MAT TDM = EMPTY
DIM TDS(4); MAT TDS = EMPTY
DIM TDR(4); MAT TDR = EMPTY
DIM TDC(4); MAT TDC = EMPTY
DIM TDT(4); MAT TDT = EMPTY
VALID.REFS = "TY":AM:"SY":AM:"GR":AM:"BX"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.MISC(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 4
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 4
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"           Miscellaneous Addressable Interface Parameters Maintenance           ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"TY> Type of equipment         ":RVE:"":
PRINT @(0,5):CLS:"":RVB:"    Starting system address   ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"SY>      system id            ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"GR>      group number         ":RVE:"":
PRINT @(0,8):CLS:"":RVB:"BX>      box number           ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 1; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
*
!
*
PRINT @(32,3):PAR<1> "L#8":
*
!
*
PRINT @(32,6):PAR<2,1> "L#4":
*
!
*
PRINT @(32,7):PAR<2,2> "L#4":
*
!
*
PRINT @(32,8):PAR<2,3> "L#4":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
PAR.ID = "AI.MISCELLANEOUS"
PAR.ID.SAVE<ONE> = "AI.MISCELLANEOUS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.MISC +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.MISC(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03,I04
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("PAR","1",PAR,32,3,"L8","8",1,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,32,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("PAR","2",PAR,32,6,"L4","4",2:",":1,"","OP":VM:"MA":SVM:"0N":VM:"LO":SVM:"1":VM:"HI":SVM:"64","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,32,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
I03: *
CALL INPUT.DATA.SG1("PAR","2",PAR,32,7,"L4","4",2:",":2,"","DF":SVM:"1":VM:"OP":VM:"LO":SVM:"1":VM:"HI":SVM:"1023","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,32,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03
RETURN
I04: *
CALL INPUT.DATA.SG1("PAR","2",PAR,32,8,"L4","4",2:",":3,"","DF":SVM:"144":VM:"OP":VM:"NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,32,8,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I04
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.PORT~
*PROGRAM:           SH.MAINT.AI.PORT
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:51:18
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"
SYS.PROG = "MAINT.AI.PORT"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.PORT"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(4); MAT TDL = EMPTY
DIM TDH(4); MAT TDH = EMPTY
DIM TDI(4); MAT TDI = EMPTY
DIM TDX(4); MAT TDX = ONE
DIM SAVE.TDX(4); MAT SAVE.TDX = EMPTY
DIM TDM(4); MAT TDM = EMPTY
DIM TDS(4); MAT TDS = EMPTY
DIM TDR(4); MAT TDR = EMPTY
DIM TDC(4); MAT TDC = EMPTY
DIM TDT(4); MAT TDT = EMPTY
VALID.REFS = "NA":AM:"IT":AM:"CP":AM:"MP"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.PORT(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 4
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 4
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                     Maintain Handler Head End Information                      ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Head End  ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"NA> Head End Name   ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"IT> Interface Type  ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"CP> Control Port    ":RVE:"":
PRINT @(0,8):CLS:"":RVB:"MP> Monitor Port    ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
*
!
*
PRINT @(22,4):COM<4> "L#25":
*
!
*
PRINT @(22,6):COM<1> "L#2":
*
!
*
PRINT @(22,7):COM<2> "L#3":
*
!
*
PRINT @(22,8):COM<3> "L#3":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM = COM:COM.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.PORT +Itm:":COM
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TYPE."
FLD = RSP
COM.ID.SAVE<1> = "AI.TYPE."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,12,3,"L2","2",1,"","OP":VM:"MA":SVM:"2X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,12,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.PORT(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03,I04
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("COM","4",COM,22,4,"L25","50",4,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,22,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("COM","1",COM,22,6,"L2","4",1,"","MA":SVM:"2X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
I03: *
CALL INPUT.DATA.SG1("COM","2",COM,22,7,"L3","4",2,"","MA":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03
RETURN
I04: *
CALL INPUT.DATA.SG1("COM","3",COM,22,8,"L3","4",3,"","MA":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,8,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I04
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.PROMPTS~
*PROGRAM:           SH.MAINT.AI.PROMPTS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:52:48
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.PROMPTS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.PROMPTS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.PROMPTS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CI"
TDC(1) = 16
TDT(1) = 6
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                   Addressable Interface Prompts Maintenance                    ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Interface Type ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"Ln":RVE:" ":RVB:"Description                                                           ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.PROMPTS +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TALKER.MSGS."
FLD = RSP
COM.ID.SAVE<1> = "AI.TALKER.MSGS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,17,3,"L2","2",1,"","OP":VM:"MA":SVM:"2X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,17,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.PROMPTS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","0",FLD,9,23,"L75","75","1","","SE":VM:"OP":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM,AM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
AC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 1
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 1
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; AC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; AC = TDX(REF)
INX.STR = COM<AC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; AC = TDX(REF)
INS FLD BEFORE COM<AC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; AC = TDX(REF)
DEL COM<AC>
*
RETURN
*
I01A: *
*
IF COM<AC> EQ " " THEN COM<AC> = EMPTY
PRINT @(0,LN):SPACE(2-LEN(AC)):RVB:AC:RVE:" ":
CALL INPUT.DATA.SG1("COM","0",COM,3,LN,"L75","75",AC,"","OP":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,3,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM,AM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):SPACE(TWO - LEN(AC)):RVB:AC:RVE:" ":COM<AC> "L#75":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
AC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<AC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
AC = TDX(REF)
PRINT @(0,LN):SPACE(TWO - LEN(AC)):RVB:AC:RVE:" ":COM<AC> "L#75":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(78):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.SYS.ERRORS~
*PROGRAM:           SH.MAINT.AI.SYS.ERRORS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:54:32
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.SYS.ERRORS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.SYS.ERRORS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.SYS.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CI"
TDC(1) = 16
TDT(1) = 6
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                Addressable Interface System Errors Maintenance                 ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"System Type    ":RVE:"":
PRINT @(0,4):CLS:"          ":RVB:"Command":RVE:"   ":RVB:"Description              ":RVE:"     ":RVB:"Func":RVE:" ":RVB:"Type":RVE:" ":RVB:"Disp":RVE:" ":RVB:"Mngr":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.SYS.ERRORS +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.SYS.ERRORS."
FLD = RSP
COM.ID.SAVE<1> = "AI.SYS.ERRORS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,17,3,"L2","2",1,"","OP":VM:"MA":SVM:"5X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,17,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.SYS.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L4","4","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 6
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E,I01F
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 6
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<2,VC>
INS EMPTY BEFORE COM<3,VC>
INS EMPTY BEFORE COM<4,VC>
INS EMPTY BEFORE COM<5,VC>
INS EMPTY BEFORE COM<6,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<2,VC>
DEL COM<3,VC>
DEL COM<4,VC>
DEL COM<5,VC>
DEL COM<6,VC>
*
RETURN
*
I01A: *
*
IF COM<1,VC> EQ " " THEN COM<1,VC> = EMPTY
PRINT @(7,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","1",COM,10,LN,"L4","4",1:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,10,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","2",COM,20,LN,"L25","25",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,20,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","3",COM,50,LN,"L3","3",3:",":VC,"","OP":VM:"EQ":SVM:"ON":SVM:"OFF":SVM:"UP":SVM:"DN":SVM:"NUL","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,50,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("COM","4",COM,55,LN,"L4","4",4:",":VC,"","OP":VM:"EQ":SVM:"ON":SVM:"OFF":SVM:"UP":SVM:"DN":SVM:"NUL":SVM:"DATA":SVM:"PORT":SVM:"CMND":SVM:"TOUT":SVM:"STAT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,55,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("COM","5",COM,60,LN,"L1","1",5:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,60,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
I01F: *
*
CALL INPUT.DATA.SG1("COM","6",COM,65,LN,"L1","1",6:",":VC,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,65,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01F
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#4":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(7,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#4":
PRINT @(20,LN):COM<2,VC> "L#25":
PRINT @(50,LN):COM<3,VC> "L#3":
PRINT @(55,LN):COM<4,VC> "L#4":
PRINT @(60,LN):COM<5,VC> "L#1":
PRINT @(65,LN):COM<6,VC> "L#1":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(7,LN.TMP):SPACE(7):
PRINT @(20,LN.TMP):SPACE(25):
PRINT @(50,LN.TMP):SPACE(3):
PRINT @(55,LN.TMP):SPACE(4):
PRINT @(60,LN.TMP):SPACE(1):
PRINT @(65,LN.TMP):SPACE(1):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.TYPE~
*PROGRAM:           SH.MAINT.AI.TYPE
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.2)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:56:33
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.TYPE"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.TYPE"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.2"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(23); MAT TDL = EMPTY
DIM TDH(23); MAT TDH = EMPTY
DIM TDI(23); MAT TDI = EMPTY
DIM TDX(23); MAT TDX = ONE
DIM SAVE.TDX(23); MAT SAVE.TDX = EMPTY
DIM TDM(23); MAT TDM = EMPTY
DIM TDS(23); MAT TDS = EMPTY
DIM TDR(23); MAT TDR = EMPTY
DIM TDC(23); MAT TDC = EMPTY
DIM TDT(23); MAT TDT = EMPTY
VALID.REFS = "OP":AM:"IT":AM:"PO":AM:"MP":AM:"CT":AM:"GW":AM:"ON":AM:"OF":AM:"CL":AM:"TM":AM:"CP":AM:"LP":AM:"RP":AM:"SP":AM:"SF":AM:"MW":AM:"RF":AM:"DT":AM:"TC":AM:"TS":AM:"TD":AM:"CD":AM:"TI"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.TYPE(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I18.MAX = 99
TDM(18) = I18.MAX
TDS(18) = 1
TDR(18) = "DT"
TDC(18) = 6
TDT(18) = 16
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = EMPTY
READ OPERATORS FROM PAR.FILE,"OPERATORS" ELSE OPERATORS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AI.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AI.ID.SAVE = EMPTY
END ELSE
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AI.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AI = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 23
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 23
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.AI.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                   Addressable System Type Master Maintenance                   ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"AI Code":RVE:"":
PRINT @(0,5):CLS:"":RVB:"OP> Changed by      ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"IT> Interface Type  ":RVE:"                    ":RVB:"Request Up/Down":RVE:"":
PRINT @(0,8):CLS:"":RVB:"PO> Interface Port  ":RVE:"                    ":RVB:"Interface is   ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"MP> Monitor Port    ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"CT> Cutoff time for current  ":RVE:"           ":RVB:"Request On/Off ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"    day's billing            ":RVE:"           ":RVB:"Interface is   ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"GW> General uses a Window    ":RVE:"           ":RVB:"ON> Send On ":RVE:"        ":RVB:"OF> Send Off":RVE:"":
PRINT @(0,13):CLS:"":RVB:"Last Function  ":RVE:"                         ":RVB:"CL> Command Logging ":RVE:"":
PRINT @(0,14):CLS:"":RVB:"Last Command   ":RVE:"                         ":RVB:"TM> Test Mode       ":RVE:"":
PRINT @(0,15):CLS:"":RVB:"CP> Char cyc  ":RVE:"      ":RVB:"DT>Dvc":RVE:" ":RVB:"Mnft":RVE:" ":RVB:"Addrs":RVE:" ":RVB:"Tiers":RVE:"          ":RVB:"Roll a truck for W/O's    ":RVE:"":
PRINT @(0,16):CLS:"":RVB:"LP> Line cyc  ":RVE:"                                       ":RVB:"TC> Conn TS> Svc  TD> Disc":RVE:"":
PRINT @(0,17):CLS:"":RVB:"RP> Rsp. sec  ":RVE:"":
PRINT @(0,18):CLS:"":RVB:"SP> Min. sec  ":RVE:"":
PRINT @(0,19):CLS:"":RVB:"SF> Scan sec  ":RVE:"                                             ":RVB:"CD> Chan. Down ":RVE:"":
PRINT @(0,20):CLS:"":RVB:"MW> Max. sec  ":RVE:"                                             ":RVB:"TI> Tier Index ":RVE:"":
PRINT @(0,21):CLS:"":RVB:"RF> Reset sec ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AI.ID
FOR ID.CN = ONE TO 2; COM.AI.ID.SAVE<ID.CN> = "!":COM.AI.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AI.ID = TEMP
END
*
*
!
*
PRINT @(22,5):COM.AI$OPER "L#6":; LN = 5; GOSUB T02
*
!
*
PRINT @(22,7):COM.AI$TYPE "L#2":
PRINT @(57,7):COM.AI$UP.DN "L#2":
PRINT @(61,7):OCONV(COM.AI$UP.DN.DT,"D2") "L#9":
PRINT @(71,7):OCONV(COM.AI$UP.DN.TM,"MTS") "L#8":
PRINT @(57,8):COM.AI$UP.DN.STAT "L#2":
PRINT @(61,8):OCONV(COM.AI$UP.DN.C.DT,"D2") "L#9":
PRINT @(71,8):OCONV(COM.AI$UP.DN.C.TM,"MTS") "L#8":
*
!
*
PRINT @(22,8):COM.AI$COMMPORT "L#3":
*
!
*
PRINT @(22,9):COM.AI$MONITOR.PORT "L#3":
*
!
*
PRINT @(31,11):OCONV(COM.AI$BILL.CUTOFF.TM,"MTS") "L#9":
*
!
*
PRINT @(31,12):COM.AI$GENIE.WINDOW "L#1":
PRINT @(57,10):COM.AI$ON.OFF "L#3":
PRINT @(61,10):OCONV(COM.AI$ON.OFF.DT,"D2") "L#9":
PRINT @(71,10):OCONV(COM.AI$ON.OFF.TM,"MTS") "L#8":
PRINT @(57,11):COM.AI$ON.OFF.STAT "L#3":
PRINT @(61,11):OCONV(COM.AI$ON.OFF.C.DT,"D2") "L#9":
PRINT @(71,11):OCONV(COM.AI$ON.OFF.C.TM,"MTS") "L#8":
*
!
*
PRINT @(55,12):COM.AI$SEND.ON "L#1":
*
!
*
PRINT @(75,12):COM.AI$SEND.OFF "L#1":
PRINT @(17,13):COM.AI$FUNC "L#3":
PRINT @(21,13):OCONV(COM.AI$FUNC.DT,"D2") "L#9":
PRINT @(31,13):OCONV(COM.AI$FUNC.TM,"MTS") "L#8":
PRINT @(17,14):COM.AI$COMMAND "L#3":
PRINT @(21,14):OCONV(COM.AI$COMMAND.DT,"D2") "L#9":
PRINT @(31,14):OCONV(COM.AI$COMMAND.TM,"MTS") "L#8":
*
!
*
PRINT @(62,13):COM.AI$LOGGING "L#1":
*
!
*
PRINT @(62,14):COM.AI$TEST.MODE "L#1":
*
!
*
PRINT @(15,15):COM.AI$PAUSE.CHAR "L#4":
*
!
*
PRINT @(15,16):COM.AI$PAUSE.LINE "L#4":
*
!
*
PRINT @(15,17):COM.AI$PAUSE.RESP "L#4":
*
!
*
PRINT @(15,18):COM.AI$STD.PAUSE "L#3":
*
!
*
PRINT @(15,19):COM.AI$SCAN.FREQ "L#3":
*
!
*
PRINT @(15,20):COM.AI$MAX.PAUSE "L#3":
*
!
*
PRINT @(15,21):COM.AI$RESET.FREQ "L#4":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D18
IF STAT EQ 999 THEN RETURN
*
!
*
PRINT @(58,17):COM.AI$CONN.ROLL "L#1":
*
!
*
PRINT @(67,17):COM.AI$CHNG.ROLL "L#1":
*
!
*
PRINT @(76,17):COM.AI$DISC.ROLL "L#1":
*
!
*
PRINT @(76,19):COM.AI$CHAN.DN.BRDCST "L#1":
*
!
*
PRINT @(76,20):COM.AI$INDEXED "L#1":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.AI.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.AI.ID = EMPTY
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<1>
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.TYPE +Itm:":COM.AI.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TYPE."
FLD = RSP
COM.AI.ID.SAVE<1> = "AI.TYPE."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.AI.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,9,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,9,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
COM.AI.ID.SAVE<2> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN AI.TYPES<ONE> SETTING LOC THEN TRN.FLD = AI.TYPES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(22,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(22,LN):SPACE(25):
RETURN
*
*
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07,I08,I09,I10,I11,I12,I13,I14,I15,I16,I17,I18,I19,I20,I21,I22,I23
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("COM","AI.25",COM.AI$OPER,22,5,"L6","6",1,"","EQ":SVM:"@":OPERATORS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 5; GOSUB T02
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("COM","AI.3",COM.AI$TYPE,22,7,"L2","2",1,"","OP":VM:"EQ":SVM:"O":SVM:"I":SVM:"B":VM:"MA":SVM:"1X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
I03: *
CALL INPUT.DATA.SG1("COM","AI.12",COM.AI$COMMPORT,22,8,"L3","3",1,"","OP":VM:"MA":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,8,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03
RETURN
I04: *
CALL INPUT.DATA.SG1("COM","AI.57",COM.AI$MONITOR.PORT,22,9,"L3","3",1,"","OP":VM:"MA":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,9,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I04
RETURN
I05: *
CALL INPUT.DATA.SG1("COM","AI.6",COM.AI$BILL.CUTOFF.TM,31,11,"L9","9",1,"MTS","OP":VM:"","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,31,11,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I05
RETURN
I06: *
CALL INPUT.DATA.SG1("COM","AI.58",COM.AI$GENIE.WINDOW,31,12,"L1","1",1,"","OP":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,31,12,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I06
RETURN
I07: *
CALL INPUT.DATA.SG1("COM","AI.59",COM.AI$SEND.ON,55,12,"L1","1",1,"","EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,55,12,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I07
RETURN
I08: *
CALL INPUT.DATA.SG1("COM","AI.60",COM.AI$SEND.OFF,75,12,"L1","1",1,"","EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,75,12,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I08
RETURN
I09: *
CALL INPUT.DATA.SG1("COM","AI.19",COM.AI$LOGGING,62,13,"L1","1",1,"","DF":SVM:"N":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,62,13,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I09
RETURN
I10: *
CALL INPUT.DATA.SG1("COM","AI.20",COM.AI$TEST.MODE,62,14,"L1","1",1,"","DF":SVM:"0":VM:"MA":SVM:"1N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,62,14,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I10
RETURN
I11: *
CALL INPUT.DATA.SG1("COM","AI.54",COM.AI$PAUSE.CHAR,15,15,"L4","4",1,"","DF":SVM:"5":VM:"MA":SVM:"0N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,15,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I11
RETURN
I12: *
CALL INPUT.DATA.SG1("COM","AI.55",COM.AI$PAUSE.LINE,15,16,"L4","4",1,"","DF":SVM:"15":VM:"MA":SVM:"0N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,16,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I12
RETURN
I13: *
CALL INPUT.DATA.SG1("COM","AI.56",COM.AI$PAUSE.RESP,15,17,"L4","4",1,"","DF":SVM:"15":VM:"MA":SVM:"0N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,17,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I13
RETURN
I14: *
CALL INPUT.DATA.SG1("COM","AI.36",COM.AI$STD.PAUSE,15,18,"L3","3",1,"","DF":SVM:"15":VM:"MA":SVM:"1N":SVM:"2N":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,18,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I14
RETURN
I15: *
CALL INPUT.DATA.SG1("COM","AI.40",COM.AI$SCAN.FREQ,15,19,"L3","3",1,"","DF":SVM:"60":VM:"MA":SVM:"1N":SVM:"2N":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,19,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I15
RETURN
I16: *
CALL INPUT.DATA.SG1("COM","AI.37",COM.AI$MAX.PAUSE,15,20,"L3","3",1,"","DF":SVM:"60":VM:"MA":SVM:"1N":SVM:"2N":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,20,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I16
RETURN
I17: *
CALL INPUT.DATA.SG1("COM","AI.39",COM.AI$RESET.FREQ,15,21,"L4","4",1,"","DF":SVM:"600":VM:"MA":SVM:"1N":SVM:"2N":SVM:"3N":SVM:"4N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,21,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I17
RETURN
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,Y18,ERROR,ERROR,ERROR,ERROR,ERROR
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,I18.KEY,ERROR,ERROR,ERROR,ERROR,ERROR
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D18,ERROR,ERROR,ERROR,ERROR,ERROR
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,X18,ERROR,ERROR,ERROR,ERROR,ERROR
IF INX.FOUND THEN
PRINT CLB:"Ref. ":TDR(REF):"> ":FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D18,ERROR,ERROR,ERROR,ERROR,ERROR
END ELSE
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,R18,ERROR,ERROR,ERROR,ERROR,ERROR
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D18,ERROR,ERROR,ERROR,ERROR,ERROR
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,A18,ERROR,ERROR,ERROR,ERROR,ERROR
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D18,ERROR,ERROR,ERROR,ERROR,ERROR
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I18.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AI.DVC.UNIT",FLD,9,23,"L6","8","1","","SE":VM:"OP":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I18: *
*
TDI(REF) = DCOUNT(COM.AI$DVC.UNIT<ONE>,VM)
TDL.REF = 18; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I18.INP: *
*
FOR SUB.REF = 2 TO 4
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I18A,I18B,I18C,I18D
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,R18,ERROR,ERROR,ERROR,ERROR,ERROR
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D18
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 4
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D18
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I18
*
RETURN
*
*
X18: *
*
LOCATE INX.STR IN COM.AI$DVC.UNIT<ONE> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y18: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM.AI$DVC.UNIT<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A18: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM.AI$DVC.UNIT<ONE,VC>
INS EMPTY BEFORE COM.AI$DB.PREFIX<ONE,VC>
INS EMPTY BEFORE COM.AI$ADDR.PER.UNIT<ONE,VC>
INS EMPTY BEFORE COM.AI$TIER.PER.UNIT<ONE,VC>
*
RETURN
*
!
*
R18: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM.AI$DVC.UNIT<ONE,VC>
DEL COM.AI$DB.PREFIX<ONE,VC>
DEL COM.AI$ADDR.PER.UNIT<ONE,VC>
DEL COM.AI$TIER.PER.UNIT<ONE,VC>
*
RETURN
*
I18A: *
*
CALL INPUT.DATA.SG1("COM","AI.DVC.UNIT",COM.AI$DVC.UNIT,20,LN,"L6","8",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,20,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I18A
RETURN
*
I18B: *
*
CALL INPUT.DATA.SG1("COM","AI.DB.PREFIX",COM.AI$DB.PREFIX,28,LN,"L2","2",ONE:",":VC,"","OP":VM:"MA":SVM:"2X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,28,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I18B
RETURN
*
I18C: *
*
CALL INPUT.DATA.SG1("COM","AI.ADDR.PER.UNIT",COM.AI$ADDR.PER.UNIT,33,LN,"L3","3",ONE:",":VC,"","OP":VM:"NU":VM:"LO":SVM:"1":VM:"HI":SVM:"132","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,33,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I18C
RETURN
*
I18D: *
*
CALL INPUT.DATA.SG1("COM","AI.TIER.PER.UNIT",COM.AI$TIER.PER.UNIT,39,LN,"L3","3",ONE:",":VC,"","OP":VM:"NU":VM:"LO":SVM:"1":VM:"HI":SVM:"132","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,39,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I18D
RETURN
*
D18: *
*
SAVE.REF = REF; REF = 18
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AI$DVC.UNIT<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(20,LN):COM.AI$DVC.UNIT<ONE,VC> "L#6":
LN.REDISP = FALSE
GOTO D18.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D18.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AI$DVC.UNIT<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(20,LN):COM.AI$DVC.UNIT<ONE,VC> "L#6":
PRINT @(28,LN):COM.AI$DB.PREFIX<ONE,VC> "L#2":
PRINT @(33,LN):COM.AI$ADDR.PER.UNIT<ONE,VC> "L#3":
PRINT @(39,LN):COM.AI$TIER.PER.UNIT<ONE,VC> "L#3":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D18.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,C18,ERROR,ERROR,ERROR,ERROR,ERROR
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D18.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C18: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(20,LN.TMP):SPACE(6):
PRINT @(28,LN.TMP):SPACE(2):
PRINT @(33,LN.TMP):SPACE(3):
PRINT @(39,LN.TMP):SPACE(3):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
I19: *
CALL INPUT.DATA.SG1("COM","AI.47",COM.AI$CONN.ROLL,58,17,"L1","1",1,"","DF":SVM:"Y":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,58,17,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I19
RETURN
I20: *
CALL INPUT.DATA.SG1("COM","AI.48",COM.AI$CHNG.ROLL,67,17,"L1","1",1,"","DF":SVM:"Y":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,67,17,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I20
RETURN
I21: *
CALL INPUT.DATA.SG1("COM","AI.46",COM.AI$DISC.ROLL,76,17,"L1","1",1,"","DF":SVM:"Y":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,76,17,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I21
RETURN
I22: *
CALL INPUT.DATA.SG1("COM","AI.49",COM.AI$CHAN.DN.BRDCST,76,19,"L1","1",1,"","DF":SVM:"Y":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,76,19,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I22
RETURN
I23: *
CALL INPUT.DATA.SG1("COM","AI.45",COM.AI$INDEXED,76,20,"L1","1",1,"","DF":SVM:"N":VM:"EQ":SVM:"Y":SVM:"N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,76,20,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I23
RETURN
*
!
*
T02: *
*
TRN.FLD = COM.AI$OPER
LOCATE TRN.FLD IN OPERATORS<ONE> SETTING LOC THEN TRN.FLD = OPERATORS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(30,LN):TRN.FLD "L#15":
RETURN
*
TC02: *
PRINT @(30,LN):SPACE(15):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.TYPE.32~
*PROGRAM:           SH.MAINT.AI.TYPE.32
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (2.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:00:54
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.TYPE.32"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.TYPE.32"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "2.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "DT":AM:"IT":AM:"SE"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.TYPE.32(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I03.MAX = 99
TDM(3) = I03.MAX
TDS(3) = 1
TDR(3) = "SE"
TDC(3) = 8
TDT(3) = 14
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AI.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AI.ID.SAVE = EMPTY
END ELSE
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AI.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
GOSUB READB.C; IF STAT THEN GOTO UNLOCK
MATREAD COM.AI FROM COM.FILE,COM.AI.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AI = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 3
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 3
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AI ON COM.FILE,COM.AI.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                  AI Maintenance  -  Single Address - 32 Tiers                  ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"AI Code":RVE:"":
PRINT @(0,5):CLS:"":RVB:"     Description    ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"     Interface Type ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"     Port Number    ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"DT> Device Type     ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"IT> Interface Type  ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"SE> Default":RVE:"         ":RVB:"Connected":RVE:"           ":RVB:"Device":RVE:"":
PRINT @(0,13):CLS:"    ":RVB:"Service":RVE:"         ":RVB:"Outlets  ":RVE:"           ":RVB:" Tier ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AI.ID
FOR ID.CN = ONE TO 2; COM.AI.ID.SAVE<ID.CN> = "!":COM.AI.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AI.ID = TEMP
END
*
*
!
*
PRINT @(22,5):COM.AI$NAME "L#25":
PRINT @(22,6):COM.AI$TYPE "L#1":
PRINT @(22,7):COM.AI$COMMPORT "L#3":
*
!
*
PRINT @(22,9):DVC.TYPE "L#8":
PRINT @(22,9):; REDISP = TRUE; LOCATE DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING VC THEN PRINT COM.AI$DVC.UNIT<ONE,VC> "L#8": ELSE VC = ONE; PRINT COM.AI$DVC.UNIT<ONE,VC> "L#8":
*
!
*
PRINT @(22,10):COM.AI$DB.PREFIX<ONE,VC> "L#2":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D03
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.AI.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.AI.ID = EMPTY
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<1>
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.TYPE.32 +Itm:":COM.AI.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TYPE."
FLD = RSP
COM.AI.ID.SAVE<1> = "AI.TYPE."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.AI.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,9,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,9,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.AI.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.TYPE.32(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("DVC","AI.0",DVC.TYPE,22,9,"L8","8",ONE,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,9,".",STD.SUBR.NAME,PROCBUF,STAT)
REDISP = TRUE; GOSUB DISP.BG; GOSUB DISP.FG
RETURN
I02: *
CALL INPUT.DATA.SG1("COM","AI.1",COM.AI$DB.PREFIX,22,10,"L2","2",ONE:",":VC,"","OP":VM:"MA":SVM:"2X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,10,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB ERROR,ERROR,Y03
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB ERROR,ERROR,I03.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB ERROR,ERROR,D03
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB ERROR,ERROR,X03
IF INX.FOUND THEN
PRINT CLB:"Ref. ":TDR(REF):"> ":FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END ELSE
ON REF GOSUB ERROR,ERROR,R03
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,ERROR,D03
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB ERROR,ERROR,A03
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,ERROR,D03
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I03.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AI.DF.SVCS.ONE",FLD,16,23,"L7","7","1","","SE":VM:"OP":VM:"":VM:"MA":SVM:"0X","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,16,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I03: *
*
TDI(REF) = DCOUNT(COM.AI$DF.SVCS.ONE<ONE,VC>,SVM)
TDL.REF = 3; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
SC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I03.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I03A,I03B,I03C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,ERROR,R03
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D03
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D03
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I03
*
RETURN
*
*
X03: *
*
LOCATE INX.STR IN COM.AI$DF.SVCS.ONE<ONE,VC> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; SC = TDX(REF)
*
RETURN
*
*
Y03: *
*
TDX(REF) = INX.LOC; SC = TDX(REF)
INX.STR = COM.AI$DF.SVCS.ONE<ONE,VC,SC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A03: *
*
TDX(REF) = INX.LOC; SC = TDX(REF)
INS FLD BEFORE COM.AI$DF.SVCS.ONE<ONE,VC,SC>
INS EMPTY BEFORE COM.AI$DF.COUT.ONE<ONE,VC,SC>
INS EMPTY BEFORE COM.AI$DF.TIER.ONE<ONE,VC,SC>
*
RETURN
*
!
*
R03: *
*
TDX(REF) = INX.LOC; SC = TDX(REF)
DEL COM.AI$DF.SVCS.ONE<ONE,VC,SC>
DEL COM.AI$DF.COUT.ONE<ONE,VC,SC>
DEL COM.AI$DF.TIER.ONE<ONE,VC,SC>
*
RETURN
*
I03A: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.SVCS.ONE",COM.AI$DF.SVCS.ONE,4,LN,"L7","7",ONE:",":VC:",":SC,"","":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,4,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03A
RETURN
*
I03B: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.COUT.ONE",COM.AI$DF.COUT.ONE,24,LN,"L5","5",ONE:",":VC:",":SC,"","NU":VM:"DF":SVM:"1":VM:"LO":SVM:"0","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,24,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03B
RETURN
*
I03C: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.TIER.ONE",COM.AI$DF.TIER.ONE,42,LN,"L2","2",ONE:",":VC:",":SC,"","OP":VM:"LO":SVM:"0":VM:"HI":SVM:"32","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,42,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03C
RETURN
*
D03: *
*
SAVE.REF = REF; REF = 03
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AI$DF.SVCS.ONE<ONE,VC>,SVM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(4,LN):COM.AI$DF.SVCS.ONE<ONE,VC,SC> "L#7":
LN.REDISP = FALSE
GOTO D03.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D03.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
SC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AI$DF.SVCS.ONE<ONE,VC,SC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
SC = TDX(REF)
PRINT @(4,LN):COM.AI$DF.SVCS.ONE<ONE,VC,SC> "L#7":
PRINT @(24,LN):COM.AI$DF.COUT.ONE<ONE,VC,SC> "L#5":
PRINT @(42,LN):COM.AI$DF.TIER.ONE<ONE,VC,SC> "L#2":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D03.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,ERROR,C03
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D03.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C03: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(4,LN.TMP):SPACE(7):
PRINT @(24,LN.TMP):SPACE(5):
PRINT @(42,LN.TMP):SPACE(2):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
READB.C: *
VC = ONE; DVC.TYPE = EMPTY
RETURN
*
!
*
END
~SH.MAINT.AI.TYPE.EIGHT~
*PROGRAM:           SH.MAINT.AI.TYPE.EIGHT
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (2.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:03:49
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.TYPE.EIGHT"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.TYPE.EIGHT"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "2.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SE"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM.AI" TO COM.AI.FILE ELSE FILE.NAME = "COM.AI"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.TYPE.EIGHT(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SE"
TDC(1) = 8
TDT(1) = 12
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AI.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AI.ID.SAVE = EMPTY
END ELSE
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AI.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM.AI",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD COM.AI FROM COM.AI.FILE,COM.AI.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AI = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM.AI",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AI ON COM.AI.FILE,COM.AI.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"            Addressable Interface Maintenance  -  Multiple Addresses            ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Control Port   ":RVE:"":
PRINT @(0,5):CLS:"":RVB:"    Description     ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"    Interface Type  ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"    Interface Code  ":RVE:"":
PRINT @(0,8):CLS:"":RVB:"    Port Number     ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"SE> Default    ":RVE:"     ":RVB:"Connected      ":RVE:"     ":RVB:"Device    ":RVE:"":
PRINT @(0,11):CLS:"":RVB:" Services      ":RVE:"     ":RVB:"Outlets        ":RVE:"     ":RVB:" Tier     ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AI.ID
FOR ID.CN = ONE TO 2; COM.AI.ID.SAVE<ID.CN> = "!":COM.AI.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AI.ID = TEMP
END
*
*
!
*
PRINT @(22,5):COM.AI$NAME "L#25":
PRINT @(22,6):COM.AI$TYPE "L#1":
PRINT @(22,7): "L#2":
PRINT @(22,8):COM.AI$PORT "L#3":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.AI.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.AI.ID = EMPTY
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<1>
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.TYPE.EIGHT +Itm:":COM.AI.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TYPE."
FLD = RSP
COM.AI.ID.SAVE<1> = "AI.TYPE."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.AI.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,16,3,"L3","3",1,"","OP":VM:"MA":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,16,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.AI.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.TYPE.EIGHT(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AI.DF.SVCS.EIGHT",FLD,17,23,"L10","10","1","","SE":VM:"OP":VM:"":VM:"MA":SVM:"0X","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,17,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM.AI$DF.SVCS.EIGHT<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM.AI$DF.SVCS.EIGHT<ONE> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM.AI$DF.SVCS.EIGHT<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM.AI$DF.SVCS.EIGHT<ONE,VC>
INS EMPTY BEFORE COM.AI$DF.COUT.EIGHT<ONE,VC>
INS EMPTY BEFORE COM.AI$DF.TIER.EIGHT<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM.AI$DF.SVCS.EIGHT<ONE,VC>
DEL COM.AI$DF.COUT.EIGHT<ONE,VC>
DEL COM.AI$DF.TIER.EIGHT<ONE,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.SVCS.EIGHT",COM.AI$DF.SVCS.EIGHT,2,LN,"L10","10",ONE:",":VC,"","":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,2,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.COUT.EIGHT",COM.AI$DF.COUT.EIGHT,22,LN,"L5","5",ONE:",":VC,"","":VM:"NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.TIER.EIGHT",COM.AI$DF.TIER.EIGHT,42,LN,"L2","2",ONE:",":VC,"","OP":VM:"LO":SVM:"0":VM:"HI":SVM:"8","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,42,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
REDISP = TRUE; GOSUB DISP.BG; GOSUB DISP.FG
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AI$DF.SVCS.EIGHT<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(2,LN):COM.AI$DF.SVCS.EIGHT<ONE,VC> "L#10":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AI$DF.SVCS.EIGHT<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(2,LN):COM.AI$DF.SVCS.EIGHT<ONE,VC> "L#10":
PRINT @(22,LN):COM.AI$DF.COUT.EIGHT<ONE,VC> "L#5":
PRINT @(42,LN):COM.AI$DF.TIER.EIGHT<ONE,VC> "L#2":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(2,LN.TMP):SPACE(10):
PRINT @(22,LN.TMP):SPACE(5):
PRINT @(42,LN.TMP):SPACE(2):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.AI.TYPE.ONE~
*PROGRAM:           SH.MAINT.AI.TYPE.ONE
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (2.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:05:37
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.AI.TYPE.ONE"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.TYPE.ONE"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "2.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SE"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM.AI" TO COM.AI.FILE ELSE FILE.NAME = "COM.AI"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.TYPE.ONE(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SE"
TDC(1) = 15
TDT(1) = 7
READ AI.TYPES FROM COM.AI.FILE,"AI.TYPES" ELSE AI.TYPES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.AI.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.AI.ID.SAVE = EMPTY
END ELSE
COM.AI.ID = EMPTY; COM.AI.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.AI.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM.AI",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
GOSUB READB.C; IF STAT THEN GOTO UNLOCK
MATREAD COM.AI FROM COM.AI.FILE,COM.AI.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT COM.AI = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM.AI",COM.AI.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE COM.AI ON COM.AI.FILE,COM.AI.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"           AI Services/Tiers Defaults Maintenance  -  Single Address            ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"AI Code":RVE:"":
PRINT @(0,5):CLS:"":RVB:"SE> Default ":RVE:"        ":RVB:"Connected":RVE:"           ":RVB:"Device":RVE:"":
PRINT @(0,6):CLS:"    ":RVB:"Services":RVE:"        ":RVB:" Outlets ":RVE:"           ":RVB:" Tier ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.AI.ID
FOR ID.CN = ONE TO 2; COM.AI.ID.SAVE<ID.CN> = "!":COM.AI.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.AI.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.AI.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.AI.ID = EMPTY
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<1>
COM.AI.ID = COM.AI.ID:COM.AI.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.TYPE.ONE +Itm:":COM.AI.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TYPE."
FLD = RSP
COM.AI.ID.SAVE<1> = "AI.TYPE."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.AI.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,9,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,9,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
COM.AI.ID.SAVE<2> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN AI.TYPES<ONE> SETTING LOC THEN TRN.FLD = AI.TYPES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(15,LN):TRN.FLD "L#30":
RETURN
*
TC01: *
PRINT @(15,LN):SPACE(30):
RETURN
*
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.TYPE.ONE(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","AI.DF.SVCS.ONE",FLD,9,23,"L7","7","1","","SE":VM:"OP":VM:"":VM:"MA":SVM:"0X","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM.AI$DF.SVCS.ONE<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM.AI$DF.SVCS.ONE<ONE> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM.AI$DF.SVCS.ONE<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM.AI$DF.SVCS.ONE<ONE,VC>
INS EMPTY BEFORE COM.AI$DF.COUT.ONE<ONE,VC>
INS EMPTY BEFORE COM.AI$DF.TIER.ONE<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM.AI$DF.SVCS.ONE<ONE,VC>
DEL COM.AI$DF.COUT.ONE<ONE,VC>
DEL COM.AI$DF.TIER.ONE<ONE,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.SVCS.ONE",COM.AI$DF.SVCS.ONE,4,LN,"L7","7",ONE:",":VC,"","":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,4,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.COUT.ONE",COM.AI$DF.COUT.ONE,22,LN,"L5","5",ONE:",":VC,"","":VM:"NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","AI.DF.TIER.ONE",COM.AI$DF.TIER.ONE,42,LN,"L2","2",ONE:",":VC,"","OP":VM:"LO":SVM:"0":VM:"HI":SVM:"8","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,42,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
REDISP = TRUE; GOSUB DISP.BG; GOSUB DISP.FG
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM.AI$DF.SVCS.ONE<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(4,LN):COM.AI$DF.SVCS.ONE<ONE,VC> "L#7":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM.AI$DF.SVCS.ONE<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(4,LN):COM.AI$DF.SVCS.ONE<ONE,VC> "L#7":
PRINT @(22,LN):COM.AI$DF.COUT.ONE<ONE,VC> "L#5":
PRINT @(42,LN):COM.AI$DF.TIER.ONE<ONE,VC> "L#2":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(4,LN.TMP):SPACE(7):
PRINT @(22,LN.TMP):SPACE(5):
PRINT @(42,LN.TMP):SPACE(2):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
READB.C: *
VC = ONE
RETURN
*
!
*
END
~SH.MAINT.BARKERS~
*PROGRAM:           SH.MAINT.BARKERS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:07:27
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.BARKERS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.BARKERS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.BARKERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SC"
TDC(1) = 16
TDT(1) = 5
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                           Barker Channel Maintenance                           ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"Short name":RVE:"  ":RVB:"Description":RVE:"                 ":RVB:"Channel #":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 1; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
PAR.ID = "BARKER.CHANNELS"
PAR.ID.SAVE<ONE> = "BARKER.CHANNELS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.BARKERS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.BARKERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PAR","1",FLD,19,23,"L6","6","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PAR<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PAR<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PAR<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PAR<1,VC>
INS EMPTY BEFORE PAR<2,VC>
INS EMPTY BEFORE PAR<3,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PAR<1,VC>
DEL PAR<2,VC>
DEL PAR<3,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("PAR","1",PAR,0,LN,"L6","6",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("PAR","2",PAR,12,LN,"L25","25",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,12,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("PAR","3",PAR,40,LN,"L2","2",3:",":VC,"","OP":VM:"MA":SVM:"0N":VM:"LO":SVM:"1","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,40,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PAR<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PAR<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
PRINT @(12,LN):PAR<2,VC> "L#25":
PRINT @(40,LN):PAR<3,VC> "L#2":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(6):
PRINT @(12,LN.TMP):SPACE(25):
PRINT @(40,LN.TMP):SPACE(2):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.BRMNGR.MSG~
*PROGRAM:           SH.MAINT.BRMNGR.MSG
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:09:01
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "CNTRL"
SYS.PROG = "MAINT.BRMNGR.MSG"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.BRMNGR.MSG"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.BRMNGR.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I03.MAX = 8
TDM(3) = I03.MAX
TDS(3) = 0
TDR(3) = "MSG"
TDC(3) = 8
TDT(3) = 7
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 3
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 3
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                 Branch Manager/Supervisor Message Maintenance                  ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"EF> Effective Date/Time":RVE:"":
PRINT @(0,5):CLS:"":RVB:"EX> Expirary Date/Time":RVE:"":
PRINT @(0,7):CLS:"":RVB:"MSG> Message text...":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
*
!
*
PRINT @(25,3):OCONV(COM<2>,"D2") "L#10":
PRINT @(35,3):OCONV(COM<3>,"MTS") "L#8":
*
!
*
PRINT @(25,5):OCONV(COM<4>,"D2") "L#10":
PRINT @(35,5):OCONV(COM<5>,"MTS") "L#8":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D03
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "BRMNGR.MSG"
COM.ID.SAVE<ONE> = "BRMNGR.MSG"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.BRMNGR.MSG +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.BRMNGR.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
I01: *
*
FOR SUB.REF = ONE TO 2
IF SUB.REF GE SUB.REF.LOC THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 2
END ELSE
IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
RETURN
*
!
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","2",COM,25,3,"L10","10",2,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,25,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
*
!
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,35,3,"L8","8",3,"MTS","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,35,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
*
!
*
I02: *
*
FOR SUB.REF = ONE TO 2
IF SUB.REF GE SUB.REF.LOC THEN
ON SUB.REF GOSUB I02A,I02B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 2
END ELSE
IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
RETURN
*
!
*
I02A: *
*
CALL INPUT.DATA.SG1("COM","4",COM,25,5,"L10","10",4,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,25,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
I02B: *
*
CALL INPUT.DATA.SG1("COM","5",COM,35,5,"L8","8",5,"MTS","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,35,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB ERROR,ERROR,D03
END
*
ON REF GOSUB ERROR,ERROR,A03
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB ERROR,ERROR,D03
PRINT CLB:"Ref. ":TDR(REF):"> - Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,67,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,67,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB ERROR,ERROR,Y03
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB ERROR,ERROR,D03
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB ERROR,ERROR,Y03
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END ELSE
ON REF GOSUB ERROR,ERROR,R03
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,ERROR,D03
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,A03
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,ERROR,D03
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I03.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L35","35","1","","SE":VM:"OP":VM:"0P","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I03: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 3; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I03.INP: *
*
FOR SUB.REF = 1 TO 1
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I03A
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,ERROR,R03
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D03
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 1
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D03
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I03
*
RETURN
*
*
X03: *
*
LOCATE INX.STR IN COM<1> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
*
RETURN
*
!
*
R03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
*
RETURN
*
I03A: *
*
IF COM<1,VC> EQ " " THEN COM<1,VC> = EMPTY
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","1",COM,22,LN,"L35","35",1:",":VC,"","OP":VM:"0P","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,22,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03A
IF STAT THEN RETURN
RETURN
*
D03: *
*
SAVE.REF = REF; REF = 03
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(19,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#35":
LN.REDISP = FALSE
GOTO D03.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D03.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(19,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#35":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D03.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,ERROR,C03
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D03.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C03: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(19,LN.TMP):SPACE(38):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.CHANNELS~
*PROGRAM:           SH.MAINT.CHANNELS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:10:46
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "PLANT"
SYS.PROG = "MAINT.CHANNELS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.CHANNELS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "SVC" TO SVC.FILE ELSE FILE.NAME = "SVC"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
SVC.ID = EMPTY; SVC.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 132
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CO"
TDC(1) = 10
TDT(1) = 8
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                       Components by Headend Maintenance                        ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"  Headend ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"Component":RVE:" ":RVB:"Chan":RVE:" ":RVB:"Component                ":RVE:"  ":RVB:"Programmer ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"  Name   ":RVE:" ":RVB:" ###":RVE:" ":RVB:"Description              ":RVE:"  ":RVB:"....Code...":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.CHANNELS +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "COMPONENTS."
FLD = RSP
COM.ID.SAVE<1> = "COMPONENTS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,12,4,"L2","2",1,"","OP":VM:"MA":SVM:"2A","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,12,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.ID.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,23,23,"L8","8","1","","SE":VM:"OP":VM:"OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,23,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 2
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<3,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<3,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,0,LN,"L8","8",1:",":VC,"","OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN ELSE GOSUB T01
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,11,LN,"L3","3",3:",":VC,"","OP":VM:"MA":SVM:"0N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,11,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
IF STAT THEN RETURN ELSE GOSUB T02
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):COM<1,VC> "L#8":; GOSUB T01
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):COM<1,VC> "L#8":; GOSUB T01
PRINT @(11,LN):COM<3,VC> "L#3":; GOSUB T02
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(8):; GOSUB TC01
PRINT @(11,LN.TMP):SPACE(3):; GOSUB TC02
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
T01: *
*
TRN.FLD = COM<1,VC>
LOCATE TRN.FLD IN COMPONENTS<ONE> SETTING LOC THEN TRN.FLD = COMPONENTS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(15,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(15,LN):SPACE(25):
RETURN
T02: *
*
TRN.FLD = COM<1,VC>
LOCATE TRN.FLD IN COMPONENTS<1> SETTING LOC THEN TRN.FLD = COMPONENTS<8,LOC> ELSE TRN.FLD = EMPTY
PRINT @(44,LN):TRN.FLD "L#8":
RETURN
*
TC02: *
PRINT @(44,LN):SPACE(8):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.COMMAND.LIST~
*PROGRAM:           SH.MAINT.COMMAND.LIST
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:12:30
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "CNTRL"
SYS.PROG = "MAINT.COMMAND.LIST"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.COMMAND.LIST"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.COMMAND.LIST(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CO"
TDC(1) = 17
TDT(1) = 6
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                    General Inquiry Command List Maintenance                    ":RVE:"":
PRINT @(0,3):CLS:"                                             ":RVB:"RUNOFF file identifier:            ":RVE:"":
PRINT @(0,4):CLS:"                                             ":RVB:"   prefixed by CABLE. for narrative":RVE:"":
PRINT @(0,5):CLS:"":RVB:"Command":RVE:"     ":RVB:"Command description           ":RVE:"   ":RVB:"               CABLE.? for help    ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 1; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
PAR.ID = "COMMAND.LIST"
PAR.ID.SAVE<ONE> = "COMMAND.LIST"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.COMMAND.LIST +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.COMMAND.LIST(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PAR","1",FLD,16,23,"L2","2","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,16,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PAR<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PAR<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PAR<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PAR<1,VC>
INS EMPTY BEFORE PAR<2,VC>
INS EMPTY BEFORE PAR<3,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PAR<1,VC>
DEL PAR<2,VC>
DEL PAR<3,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("PAR","1",PAR,0,LN,"L2","2",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("PAR","2",PAR,12,LN,"L30","30",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,12,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("PAR","3",PAR,45,LN,"L35","35",3:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,45,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PAR<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):PAR<1,VC> "L#2":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PAR<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):PAR<1,VC> "L#2":
PRINT @(12,LN):PAR<2,VC> "L#30":
PRINT @(45,LN):PAR<3,VC> "L#35":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(2):
PRINT @(12,LN.TMP):SPACE(30):
PRINT @(45,LN.TMP):SPACE(35):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.COMP.PROG~
*PROGRAM:           SH.MAINT.COMP.PROG
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:14:17
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "PLANT"
SYS.PROG = "MAINT.COMP.PROG"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.COMP.PROG"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.COMP.PROG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 132
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CO"
TDC(1) = 14
TDT(1) = 5
READ SUPPLIERS FROM COM.FILE,"SUPPLIERS" ELSE SUPPLIERS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                      Component to Programmer Maintenance                       ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Component":RVE:" ":RVB:"Chan":RVE:" ":RVB:"Programmer ":RVE:"  ":RVB:"Programmer                    ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"  Name   ":RVE:" ":RVB:" ###":RVE:" ":RVB:"....Code...":RVE:"  ":RVB:"Description                   ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "COMPONENTS"
COM.ID.SAVE<ONE> = "COMPONENTS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.COMP.PROG +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.COMP.PROG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,23,23,"L8","8","1","","SE":VM:"OP":VM:"OP":VM:"","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,23,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<3,VC>
INS EMPTY BEFORE COM<8,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<3,VC>
DEL COM<8,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,0,LN,"L8","8",1:",":VC,"","OP":VM:"","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,11,LN,"L3","3",3:",":VC,"","OP":VM:"MA":SVM:"1N":SVM:"2N":SVM:"3N":VM:"DF":SVM:"0","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,11,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","8",COM,17,LN,"L8","8",8:",":VC,"","OP":VM:"EQ":SVM:"@":SUPPLIERS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
IF STAT THEN RETURN ELSE GOSUB T01
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):COM<1,VC> "L#8":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):COM<1,VC> "L#8":
PRINT @(11,LN):COM<3,VC> "L#3":
PRINT @(17,LN):COM<8,VC> "L#8":; GOSUB T01
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(8):
PRINT @(11,LN.TMP):SPACE(3):
PRINT @(17,LN.TMP):SPACE(8):; GOSUB TC01
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
T01: *
*
TRN.FLD = COM<8,VC>
LOCATE TRN.FLD IN SUPPLIERS<ONE> SETTING LOC THEN TRN.FLD = SUPPLIERS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(28,LN):TRN.FLD "L#30":
RETURN
*
TC01: *
PRINT @(28,LN):SPACE(30):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.DISP.MSG~
*PROGRAM:           SH.MAINT.DISP.MSG
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:15:57
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "CNTRL"
SYS.PROG = "MAINT.DISP.MSG"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.DISP.MSG"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.DISP.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I03.MAX = 8
TDM(3) = I03.MAX
TDS(3) = 0
TDR(3) = "MSG"
TDC(3) = 8
TDT(3) = 7
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 3
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 3
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                         Dispatcher Message Maintenance                         ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"EF> Effective Date/Time":RVE:"":
PRINT @(0,5):CLS:"":RVB:"EX> Expirary Date/Time":RVE:"":
PRINT @(0,7):CLS:"":RVB:"MSG> Message text...":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
*
!
*
PRINT @(25,3):OCONV(COM<2>,"D2") "L#10":
PRINT @(35,3):OCONV(COM<3>,"MTS") "L#8":
*
!
*
PRINT @(25,5):OCONV(COM<4>,"D2") "L#10":
PRINT @(35,5):OCONV(COM<5>,"MTS") "L#8":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D03
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "DISP.MSG"
COM.ID.SAVE<ONE> = "DISP.MSG"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.DISP.MSG +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.DISP.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
I01: *
*
FOR SUB.REF = ONE TO 2
IF SUB.REF GE SUB.REF.LOC THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 2
END ELSE
IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
RETURN
*
!
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","2",COM,25,3,"L10","10",2,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,25,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
*
!
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,35,3,"L8","8",3,"MTS","OP":VM:"","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,35,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
*
!
*
I02: *
*
FOR SUB.REF = ONE TO 2
IF SUB.REF GE SUB.REF.LOC THEN
ON SUB.REF GOSUB I02A,I02B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 2
END ELSE
IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
RETURN
*
!
*
I02A: *
*
CALL INPUT.DATA.SG1("COM","4",COM,25,5,"L10","10",4,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,25,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
I02B: *
*
CALL INPUT.DATA.SG1("COM","5",COM,35,5,"L8","8",5,"MTS","OP":VM:"","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,35,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB ERROR,ERROR,D03
END
*
ON REF GOSUB ERROR,ERROR,A03
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB ERROR,ERROR,D03
PRINT CLB:"Ref. ":TDR(REF):"> - Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,67,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,67,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB ERROR,ERROR,Y03
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB ERROR,ERROR,D03
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB ERROR,ERROR,Y03
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END ELSE
ON REF GOSUB ERROR,ERROR,R03
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,ERROR,D03
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,A03
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,ERROR,D03
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I03.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L35","35","1","","SE":VM:"OP":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I03: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 3; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I03.INP: *
*
FOR SUB.REF = 1 TO 1
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I03A
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,ERROR,R03
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D03
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 1
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D03
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I03
*
RETURN
*
*
X03: *
*
LOCATE INX.STR IN COM<1> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
*
RETURN
*
!
*
R03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
*
RETURN
*
I03A: *
*
IF COM<1,VC> EQ " " THEN COM<1,VC> = EMPTY
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","1",COM,22,LN,"L35","35",1:",":VC,"","OP":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,22,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03A
IF STAT THEN RETURN
RETURN
*
D03: *
*
SAVE.REF = REF; REF = 03
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(19,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#35":
LN.REDISP = FALSE
GOTO D03.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D03.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(19,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#35":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D03.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,ERROR,C03
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D03.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C03: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(19,LN.TMP):SPACE(38):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.EVENT.PVM~
*PROGRAM:           SH.MAINT.EVENT.PVM
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (2)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:18:47
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.EVENT.PVM"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.EVENT.PVM"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "2"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(16); MAT TDL = EMPTY
DIM TDH(16); MAT TDH = EMPTY
DIM TDI(16); MAT TDI = EMPTY
DIM TDX(16); MAT TDX = ONE
DIM SAVE.TDX(16); MAT SAVE.TDX = EMPTY
DIM TDM(16); MAT TDM = EMPTY
DIM TDS(16); MAT TDS = EMPTY
DIM TDR(16); MAT TDR = EMPTY
DIM TDC(16); MAT TDC = EMPTY
DIM TDT(16); MAT TDT = EMPTY
VALID.REFS = "DS":AM:"SM":AM:"DB":AM:"CC":AM:"DR":AM:"SD":AM:"DU":AM:"RT":AM:"RC":AM:"RS":AM:"EC":AM:"PC":AM:"MC":AM:"ST":AM:"GU":AM:"PU"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "PVM" TO PVM.FILE ELSE FILE.NAME = "PVM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.EVENT.PVM(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
READ PPV.DISTRIBUTORS FROM COM.FILE,"PPV.DISTRIBUTORS" ELSE PPV.DISTRIBUTORS = EMPTY
READ PPV.RATE.CLASSES FROM COM.FILE,"PPV.RATE.CLASSES" ELSE PPV.RATE.CLASSES = EMPTY
READ PPV.EVENT.CLASSES FROM COM.FILE,"PPV.EVENT.CLASSES" ELSE PPV.EVENT.CLASSES = EMPTY
READ PPV.MRKT.CLASSES FROM COM.FILE,"PPV.MRKT.CLASSES" ELSE PPV.MRKT.CLASSES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PVM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PVM.ID.SAVE = EMPTY
END ELSE
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PVM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD PVM FROM PVM.FILE,PVM.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT PVM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 16
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 16
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PVM.FILE,PVM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE PVM ON PVM.FILE,PVM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                          PPV Event Master Maintenance                          ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"  Master Event ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"DS> Description":RVE:"":
PRINT @(0,6):CLS:"":RVB:"SM> Sch. (YYMM)":RVE:"         ":RVB:"DB> Debut Date  ":RVE:"            ":RVB:"CC> Ch. Code    ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"DR> Distr      ":RVE:"":
PRINT @(0,8):CLS:"":RVB:"SD> Studio     ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"DU> Duration   ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"RT> Run Time   ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"RC> Rate Class ":RVE:"":
PRINT @(0,13):CLS:"":RVB:"RS>  Sub-Class ":RVE:"":
PRINT @(0,15):CLS:"":RVB:"EC> Event Class":RVE:"":
PRINT @(0,16):CLS:"":RVB:"PC> Prog Class ":RVE:"":
PRINT @(0,17):CLS:"":RVB:"MC> Mrkt Class ":RVE:"":
PRINT @(0,19):CLS:"":RVB:"ST> Star Rating":RVE:"         ":RVB:"GU> Guide Rating":RVE:"           ":RVB:"PU> Purge Date ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PVM.ID
FOR ID.CN = ONE TO 1; PVM.ID.SAVE<ID.CN> = "!":PVM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PVM.ID = TEMP
END
*
*
!
*
PRINT @(17,4):PVM$DESC "L#25":
*
!
*
PRINT @(17,6):PVM$PROGMO "L#6":
*
!
*
PRINT @(41,6):OCONV(PVM$DEBUT.DT,"D2") "L#9":
*
!
*
PRINT @(69,6):PVM$CH.CODE "L#3":
*
!
*
PRINT @(17,7):PVM$DISTR "L#6":; LN = 7; GOSUB T01
*
!
*
PRINT @(17,8):PVM$STUDIO "L#6":; LN = 8; GOSUB T02
*
!
*
PRINT @(17,9):OCONV(PVM$DUR,"MT") "L#5":
*
!
*
PRINT @(17,10):OCONV(PVM$RUN.TM,"MT") "L#5":
*
!
*
PRINT @(17,12):PVM$RATE.CL "L#6":; LN = 12; GOSUB T03
*
!
*
PRINT @(17,13):PVM$RATE.CL.SUB "L#6":; LN = 13; GOSUB T04
*
!
*
PRINT @(17,15):PVM$CL "L#6":; LN = 15; GOSUB T05
*
!
*
PRINT @(17,16):PVM$PROG.CL "L#6":; LN = 16; GOSUB T06
*
!
*
PRINT @(17,17):PVM$MRKT.CL "L#6":; LN = 17; GOSUB T07
*
!
*
PRINT @(17,19):PVM$STARS "L#1":
*
!
*
PRINT @(41,19):PVM$RATING "L#5":
*
!
*
PRINT @(67,19):OCONV(PVM$PURGE.DT,"D2") "L#9":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 1
ON ID.CN GOSUB K01
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PVM.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
PVM.ID = EMPTY
PVM.ID = PVM.ID:PVM.ID.SAVE<1>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.EVENT.PVM +Itm:":PVM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PVM.ID.SAVE<1>
CALL INPUT.DATA.SG1("PVM.ID","ID",FLD,17,3,"L6","6",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,17,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
PVM.ID.SAVE<1> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.EVENT.PVM(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07,I08,I09,I10,I11,I12,I13,I14,I15,I16
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("PVM$DESC","2",PVM$DESC,17,4,"L25","25",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,17,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("PVM$PROGMO","1",PVM$PROGMO,17,6,"L6","6",1,"","OP":VM:"4N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
I03: *
CALL INPUT.DATA.SG1("PVM$DEBUT","5",PVM$DEBUT.DT,41,6,"L9","9",1,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,41,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03
RETURN
I04: *
CALL INPUT.DATA.SG1("PVM$CH","16",PVM$CH.CODE,69,6,"L3","3",1,"","OP":VM:"3X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,69,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I04
RETURN
I05: *
CALL INPUT.DATA.SG1("PVM$DISTR","3",PVM$DISTR,17,7,"L6","6",1,"","OP":VM:"EQ":SVM:"@":PPV.DISTRIBUTORS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 7; GOSUB T01
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I05
RETURN
I06: *
CALL INPUT.DATA.SG1("PVM$STUDIO","4",PVM$STUDIO,17,8,"L6","6",1,"","OP":VM:"EQ":SVM:"@":PPV.DISTRIBUTORS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,8,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 8; GOSUB T02
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I06
RETURN
I07: *
CALL INPUT.DATA.SG1("PVM$DUR","13",PVM$DUR,17,9,"L5","5",1,"MT","OP":VM:"MT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,9,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I07
RETURN
I08: *
CALL INPUT.DATA.SG1("PVM$RUN","12",PVM$RUN.TM,17,10,"L5","5",1,"MT","OP":VM:"MT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,10,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I08
RETURN
I09: *
CALL INPUT.DATA.SG1("PVM$RATE","10",PVM$RATE.CL,17,12,"L6","6",1,"","OP":VM:"EQ":SVM:"@":PPV.RATE.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,12,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 12; GOSUB T03
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I09
RETURN
I10: *
CALL INPUT.DATA.SG1("PVM$RATE","11",PVM$RATE.CL.SUB,17,13,"L6","6",1,"","OP":VM:"EQ":SVM:"@":PPV.RATE.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,13,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 13; GOSUB T04
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I10
RETURN
I11: *
CALL INPUT.DATA.SG1("PVM$CL","7",PVM$CL,17,15,"L6","6",1,"","OP":VM:"EQ":SVM:"@":PPV.EVENT.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,15,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 15; GOSUB T05
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I11
RETURN
I12: *
CALL INPUT.DATA.SG1("PVM$PROG","8",PVM$PROG.CL,17,16,"L6","6",1,"","OP":VM:"EQ":SVM:"@":PPV.EVENT.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,16,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 16; GOSUB T06
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I12
RETURN
I13: *
CALL INPUT.DATA.SG1("PVM$MRKT","9",PVM$MRKT.CL,17,17,"L6","6",1,"","OP":VM:"EQ":SVM:"@":PPV.MRKT.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,17,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 17; GOSUB T07
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I13
RETURN
I14: *
CALL INPUT.DATA.SG1("PVM$STARS","14",PVM$STARS,17,19,"L1","1",1,"","OP":VM:"NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,19,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I14
RETURN
I15: *
CALL INPUT.DATA.SG1("PVM$RATING","15",PVM$RATING,41,19,"L5","5",1,"","OP":VM:"EQ":SVM:"PG":SVM:"ADULT":SVM:"RESTR":SVM:"GEN","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,41,19,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I15
RETURN
I16: *
CALL INPUT.DATA.SG1("PVM$PURGE","6",PVM$PURGE.DT,67,19,"L9","9",1,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,67,19,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I16
RETURN
*
!
*
T01: *
*
TRN.FLD = PVM$DISTR
LOCATE TRN.FLD IN PPV.DISTRIBUTORS<ONE> SETTING LOC THEN TRN.FLD = PPV.DISTRIBUTORS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(24,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(24,LN):SPACE(25):
RETURN
T02: *
*
TRN.FLD = PVM$STUDIO
LOCATE TRN.FLD IN PPV.DISTRIBUTORS<ONE> SETTING LOC THEN TRN.FLD = PPV.DISTRIBUTORS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(24,LN):TRN.FLD "L#25":
RETURN
*
TC02: *
PRINT @(24,LN):SPACE(25):
RETURN
T03: *
*
TRN.FLD = PVM$RATE.CL
LOCATE TRN.FLD IN PPV.RATE.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.RATE.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(24,LN):TRN.FLD "L#25":
RETURN
*
TC03: *
PRINT @(24,LN):SPACE(25):
RETURN
T04: *
*
TRN.FLD = PVM$RATE.CL.SUB
LOCATE TRN.FLD IN PPV.RATE.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.RATE.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(24,LN):TRN.FLD "L#25":
RETURN
*
TC04: *
PRINT @(24,LN):SPACE(25):
RETURN
T05: *
*
TRN.FLD = PVM$CL
LOCATE TRN.FLD IN PPV.EVENT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.EVENT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(24,LN):TRN.FLD "L#25":
RETURN
*
TC05: *
PRINT @(24,LN):SPACE(25):
RETURN
T06: *
*
TRN.FLD = PVM$PROG.CL
LOCATE TRN.FLD IN PPV.EVENT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.EVENT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(24,LN):TRN.FLD "L#25":
RETURN
*
TC06: *
PRINT @(24,LN):SPACE(25):
RETURN
T07: *
*
TRN.FLD = PVM$MRKT.CL
LOCATE TRN.FLD IN PPV.MRKT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.MRKT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(24,LN):TRN.FLD "L#25":
RETURN
*
TC07: *
PRINT @(24,LN):SPACE(25):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.EVENT.PVM.PVE~
*PROGRAM:           SH.MAINT.EVENT.PVM.PVE
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (2)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:20:56
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.EVENT.PVM.PVE"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.EVENT.PVM.PVE"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "2"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "PVM" TO PVM.FILE ELSE FILE.NAME = "PVM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.EVENT.PVM.PVE(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 999
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CH"
TDC(1) = 14
TDT(1) = 7
READ PPV.EVENT.CLASSES FROM COM.FILE,"PPV.EVENT.CLASSES" ELSE PPV.EVENT.CLASSES = EMPTY
READ PPV.RATE.CLASSES FROM COM.FILE,"PPV.RATE.CLASSES" ELSE PPV.RATE.CLASSES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PVM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PVM.ID.SAVE = EMPTY
END ELSE
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PVM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD PVM FROM PVM.FILE,PVM.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT PVM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
TEXT = "Not on file"; GOSUB ERROR; GOTO UNLOCK
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE PVM ON PVM.FILE,PVM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                         PPV Event Details Maintenance                          ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Event:":RVE:"":
PRINT @(0,4):CLS:"                                                   ":RVB:"      Defaults:      ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"Sched. (YYMM):":RVE:"               ":RVB:"Ln#":RVE:" ":RVB:"..Date...":RVE:"  ":RVB:".Time":RVE:"  ":RVB:"RateCl":RVE:"  ":RVB:"Sub.Cl":RVE:"  ":RVB:" Dur ":RVE:"  ":RVB:"Event#":RVE:"":
PRINT @(0,7):CLS:"":RVB:"Distributor:  ":RVE:"":
PRINT @(0,8):CLS:"":RVB:"Studio:       ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"Channel Code: ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"Debut Date:   ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"Purge Date:   ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"Prog Class:   ":RVE:"":
PRINT @(0,13):CLS:"":RVB:"Mrkt Class:   ":RVE:"":
PRINT @(0,14):CLS:"":RVB:"Star Rating:  ":RVE:"":
PRINT @(0,15):CLS:"":RVB:"Guide Rating: ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PVM.ID
FOR ID.CN = ONE TO 1; PVM.ID.SAVE<ID.CN> = "!":PVM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PVM.ID = TEMP
END
*
*
!
*
PRINT @(16,3):PVM$DESC "L#25":
PRINT @(47,3):PVM$CL "L#6":; LN = 3; GOSUB T01
PRINT @(16,6):PVM$PROGMO "L#4":
PRINT @(16,7):PVM$DISTR "L#6":
PRINT @(16,8):PVM$STUDIO "L#6":
PRINT @(16,9):PVM$CH.CODE "L#3":
PRINT @(16,10):OCONV(PVM$DEBUT.DT,"D2") "L#9":
PRINT @(16,11):OCONV(PVM$PURGE.DT,"D2") "L#9":
PRINT @(16,12):PVM$PROG.CL "L#6":
PRINT @(16,13):PVM$MRKT.CL "L#6":
PRINT @(16,14):PVM$STARS "L#1":
PRINT @(16,15):PVM$RATING "L#5":
PRINT @(51,5):PVM$RATE.CL "L#6":
PRINT @(59,5):PVM$RATE.CL.SUB "L#6":
PRINT @(67,5):OCONV(PVM$DUR,"MT") "L#5":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 1
ON ID.CN GOSUB K01
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PVM.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
PVM.ID = EMPTY
PVM.ID = PVM.ID:PVM.ID.SAVE<1>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.EVENT.PVM.PVE +Itm:":PVM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PVM.ID.SAVE<1>
CALL INPUT.DATA.SG1("PVM.ID","ID",FLD,8,3,"L6","6",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,8,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
PVM.ID.SAVE<1> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.EVENT.PVM.PVE(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PVM$PVE","18",FLD,9,23,"L9","9","1","D2","SE":VM:"OP":VM:"OP":VM:"DT","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = OCONV(FLD,"D2")
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PVM$PVE.DT<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 5
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 5
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PVM$PVE.DT<ONE> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PVM$PVE.DT<ONE,VC>
INX.STR.OUT = OCONV(INX.STR,"D2")
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PVM$PVE.DT<ONE,VC>
INS EMPTY BEFORE PVM$PVE.TM<ONE,VC>
INS EMPTY BEFORE PVM$PVE.RATE.CL<ONE,VC>
INS EMPTY BEFORE PVM$PVE.RATE.CL.SUB<ONE,VC>
INS EMPTY BEFORE PVM$PVE.DUR<ONE,VC>
INS EMPTY BEFORE PVM$EVENT.NUMS<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PVM$PVE.DT<ONE,VC>
DEL PVM$PVE.TM<ONE,VC>
DEL PVM$PVE.RATE.CL<ONE,VC>
DEL PVM$PVE.RATE.CL.SUB<ONE,VC>
DEL PVM$PVE.DUR<ONE,VC>
DEL PVM$EVENT.NUMS<ONE,VC>
*
RETURN
*
I01A: *
*
IF PVM$PVE.DT<ONE,VC> EQ " " THEN PVM$PVE.DT<ONE,VC> = EMPTY
PRINT @(30,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("PVM$PVE","18",PVM$PVE.DT,33,LN,"L9","9",ONE:",":VC,"D2","OP":VM:"OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,33,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("PVM$PVE","19",PVM$PVE.TM,44,LN,"L5","5",ONE:",":VC,"MT","OP":VM:"TM","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,44,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("PVM$PVE","23",PVM$PVE.RATE.CL,51,LN,"L6","6",ONE:",":VC,"","OP":VM:"EQ":SVM:"@":PPV.RATE.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,51,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("PVM$PVE","24",PVM$PVE.RATE.CL.SUB,59,LN,"L6","6",ONE:",":VC,"","OP":VM:"EQ":SVM:"@":PPV.RATE.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,59,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("PVM$PVE","20",PVM$PVE.DUR,67,LN,"L5","5",ONE:",":VC,"MT","OP":VM:"TM","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,67,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
I01F: *
*
PRINT @(75,LN):PVM$EVENT.NUMS<ONE,VC> "L#4":
*
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PVM$PVE.DT<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(30,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":OCONV(PVM$PVE.DT<ONE,VC>,"D2") "L#9":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PVM$PVE.DT<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(30,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":OCONV(PVM$PVE.DT<ONE,VC>,"D2") "L#9":
PRINT @(44,LN):OCONV(PVM$PVE.TM<ONE,VC>,"MT") "L#5":
PRINT @(51,LN):PVM$PVE.RATE.CL<ONE,VC> "L#6":
PRINT @(59,LN):PVM$PVE.RATE.CL.SUB<ONE,VC> "L#6":
PRINT @(67,LN):OCONV(PVM$PVE.DUR<ONE,VC>,"MT") "L#5":
PRINT @(75,LN):PVM$EVENT.NUMS<ONE,VC> "L#4":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(30,LN.TMP):SPACE(12):
PRINT @(44,LN.TMP):SPACE(5):
PRINT @(51,LN.TMP):SPACE(6):
PRINT @(59,LN.TMP):SPACE(6):
PRINT @(67,LN.TMP):SPACE(5):
PRINT @(75,LN.TMP):SPACE(4):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
T01: *
*
TRN.FLD = PVM$CL
LOCATE TRN.FLD IN PPV.EVENT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.EVENT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(55,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(55,LN):SPACE(25):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.HEADEND~
*PROGRAM:           SH.MAINT.HEADEND
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:23:25
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "PLANT"
SYS.PROG = "MAINT.HEADEND"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.HEADEND"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "NA":AM:"CP"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.HEADEND(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 2
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 2
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                     Maintain Handler Head End Information                      ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Head End  ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"NA> Head End Name   ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"CP> Control Port    ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
*
!
*
PRINT @(22,4):COM<2> "L#25":
*
!
*
PRINT @(22,6):COM<1> "L#3":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM = COM:COM.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.HEADEND +Itm:":COM
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TYPE."
FLD = RSP
COM.ID.SAVE<1> = "AI.TYPE."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,12,3,"L2","2",1,"","OP":VM:"MA":SVM:"2X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,12,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.SAVE<2> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.HEADEND(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("COM","2",COM,22,4,"L25","50",2,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,22,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("COM","1",COM,22,6,"L3","4",1,"","LF":SVM:"0":SVM:"3":VM:"MA":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,22,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.INTFC.MSG~
*PROGRAM:           SH.MAINT.INTFC.MSG
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:24:51
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "CNTRL"
SYS.PROG = "MAINT.INTFC.MSG"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.INTFC.MSG"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.INTFC.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I03.MAX = 8
TDM(3) = I03.MAX
TDS(3) = 0
TDR(3) = "MSG"
TDC(3) = 8
TDT(3) = 9
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 3
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 3
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                   Addressable Interface Message Maintenance                    ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"AI Code":RVE:"":
PRINT @(0,5):CLS:"":RVB:"EF> Effective Date/Time":RVE:"":
PRINT @(0,7):CLS:"":RVB:"EX> Expirary Date/Time":RVE:"":
PRINT @(0,9):CLS:"":RVB:"MSG> Message text...":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
*
!
*
PRINT @(25,5):OCONV(COM<2>,"D2") "L#10":
PRINT @(35,5):OCONV(COM<3>,"MTS") "L#8":
*
!
*
PRINT @(25,7):OCONV(COM<4>,"D2") "L#10":
PRINT @(35,7):OCONV(COM<5>,"MTS") "L#8":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D03
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.INTFC.MSG +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "INTFC.MSG."
FLD = RSP
COM.ID.SAVE<1> = "INTFC.MSG."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,9,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,9,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
COM.ID.SAVE<2> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN AI.TYPES<ONE> SETTING LOC THEN TRN.FLD = AI.TYPES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(15,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(15,LN):SPACE(25):
RETURN
*
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.INTFC.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
I01: *
*
FOR SUB.REF = ONE TO 2
IF SUB.REF GE SUB.REF.LOC THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 2
END ELSE
IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
RETURN
*
!
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","2",COM,25,5,"L10","10",2,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,25,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
*
!
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,35,5,"L8","8",3,"MTS","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,35,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
*
!
*
I02: *
*
FOR SUB.REF = ONE TO 2
IF SUB.REF GE SUB.REF.LOC THEN
ON SUB.REF GOSUB I02A,I02B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT THEN
IF STAT EQ 999 THEN RETURN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT ZERO THEN SUB.REF = 2
END ELSE
IF SUB.REF EQ ONE AND RSP EQ EMPTY THEN RETURN
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
RETURN
*
!
*
I02A: *
*
CALL INPUT.DATA.SG1("COM","4",COM,25,7,"L10","10",4,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,25,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
I02B: *
*
CALL INPUT.DATA.SG1("COM","5",COM,35,7,"L8","8",5,"MTS","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,35,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB ERROR,ERROR,D03
END
*
ON REF GOSUB ERROR,ERROR,A03
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB ERROR,ERROR,D03
PRINT CLB:"Ref. ":TDR(REF):"> - Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,67,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,67,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB ERROR,ERROR,Y03
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB ERROR,ERROR,D03
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB ERROR,ERROR,Y03
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,X03
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END ELSE
ON REF GOSUB ERROR,ERROR,R03
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,ERROR,D03
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB ERROR,ERROR,A03
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,ERROR,D03
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I03.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L35","35","1","","SE":VM:"OP":VM:"0P","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I03: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 3; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I03.INP: *
*
FOR SUB.REF = 1 TO 1
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I03A
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,ERROR,R03
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D03
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 1
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D03
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I03
*
RETURN
*
*
X03: *
*
LOCATE INX.STR IN COM<1> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
*
RETURN
*
!
*
R03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
*
RETURN
*
I03A: *
*
IF COM<1,VC> EQ " " THEN COM<1,VC> = EMPTY
PRINT @(19,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("COM","1",COM,22,LN,"L35","35",1:",":VC,"","OP":VM:"0P","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,22,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03A
IF STAT THEN RETURN
RETURN
*
D03: *
*
SAVE.REF = REF; REF = 03
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(19,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#35":
LN.REDISP = FALSE
GOTO D03.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D03.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(19,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":COM<1,VC> "L#35":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D03.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,ERROR,C03
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D03.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C03: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(19,LN.TMP):SPACE(38):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.INTFC.TYPES~
*PROGRAM:           SH.MAINT.INTFC.TYPES
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:26:47
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.INTFC.TYPES"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.INTFC.TYPES"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "OP"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.INTFC.TYPES(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "OP"
TDC(1) = 17
TDT(1) = 4
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                  Addressable Interface Controller Maintenance                  ":RVE:"":
PRINT @(0,3):CLS:"                    ":RVB:"Code":RVE:"  ":RVB:"Controller Make and Model     ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "INTFC.TYPES"
COM.ID.SAVE<ONE> = "INTFC.TYPES"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.INTFC.TYPES +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.INTFC.TYPES(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,13,23,"L2","2","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,13,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 2
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<2,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<2,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,21,LN,"L2","2",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,21,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","2",COM,26,LN,"L30","30",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,26,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(21,LN):COM<1,VC> "L#2":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(21,LN):COM<1,VC> "L#2":
PRINT @(26,LN):COM<2,VC> "L#30":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(21,LN.TMP):SPACE(2):
PRINT @(26,LN.TMP):SPACE(30):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.MANUFACTURER~
*PROGRAM:           SH.MAINT.MANUFACTURER
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:28:21
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "PLANT"
SYS.PROG = "MAINT.MANUFACTURER"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.MANUFACTURER"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SU"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.MANUFACTURER(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SU"
TDC(1) = 14
TDT(1) = 5
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                      Equipment Manufacturers Maintenance                       ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Manufacturer":RVE:"   ":RVB:"Addr":RVE:"":
PRINT @(0,4):CLS:"":RVB:"   Code     ":RVE:"   ":RVB:"Code":RVE:" ":RVB:"Description                   ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "EQUIP.MANUFACTURERS"
COM.ID.SAVE<ONE> = "EQUIP.MANUFACTURERS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.MANUFACTURER +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.MANUFACTURER(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,27,23,"L8","8","1","","SE":VM:"OP":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,27,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<3,VC>
INS EMPTY BEFORE COM<2,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<3,VC>
DEL COM<2,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,3,LN,"L8","8",1:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,3,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,16,LN,"L2","2",3:",":VC,"","OP":VM:"MA":SVM:"2X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,16,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","2",COM,20,LN,"L30","30",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,20,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(3,LN):COM<1,VC> "L#8":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(3,LN):COM<1,VC> "L#8":
PRINT @(16,LN):COM<3,VC> "L#2":
PRINT @(20,LN):COM<2,VC> "L#30":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(3,LN.TMP):SPACE(8):
PRINT @(16,LN.TMP):SPACE(2):
PRINT @(20,LN.TMP):SPACE(30):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PPV.CHANNELS~
*PROGRAM:           SH.MAINT.PPV.CHANNELS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:29:59
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "PLANT"
SYS.PROG = "MAINT.PPV.CHANNELS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PPV.CHANNELS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 9
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CH"
TDC(1) = 10
TDT(1) = 8
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                      PPV Channels by AI Code Maintenance                       ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"  AI Code ":RVE:"":
PRINT @(0,5):CLS:"":RVB:"Chan":RVE:"                             ":RVB:"Chan":RVE:" ":RVB:"Encoder":RVB:"Encoder":RVE:"":
PRINT @(0,6):CLS:"":RVB:"Num.":RVE:" ":RVB:"Channel Description      ":RVE:"   ":RVB:"Code":RVE:" ":RVB:" Group ":RVB:" Member":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PPV.CHANNELS +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.CHANNELS."
FLD = RSP
COM.ID.SAVE<1> = "AI.CHANNELS."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,12,3,"L4","4",1,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,12,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
COM.ID.SAVE<2> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN AI.TYPES<ONE> SETTING LOC THEN TRN.FLD = AI.TYPES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(22,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(22,LN):SPACE(25):
RETURN
*
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,12,23,"L3","3","1","","SE":VM:"OP":VM:"OP":VM:"MA":SVM:"3N","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,12,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 5
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D,I01E
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 5
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<2,VC>
INS EMPTY BEFORE COM<3,VC>
INS EMPTY BEFORE COM<4,VC>
INS EMPTY BEFORE COM<5,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<2,VC>
DEL COM<3,VC>
DEL COM<4,VC>
DEL COM<5,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,0,LN,"L3","3",1:",":VC,"","OP":VM:"MA":SVM:"3N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","2",COM,7,LN,"L25","25",2:",":VC,"","OP":VM:"MA":SVM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,7,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","3",COM,34,LN,"L3","3",3:",":VC,"","OP":VM:"","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,34,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("COM","4",COM,42,LN,"L2","2",4:",":VC,"","OP":VM:"MA":SVM:"2N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,42,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("COM","5",COM,49,LN,"L2","2",5:",":VC,"","OP":VM:"MA\2N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,49,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):COM<1,VC> "L#3":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):COM<1,VC> "L#3":
PRINT @(7,LN):COM<2,VC> "L#25":
PRINT @(34,LN):COM<3,VC> "L#3":
PRINT @(42,LN):COM<4,VC> "L#2":
PRINT @(49,LN):COM<5,VC> "L#2":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(3):
PRINT @(7,LN.TMP):SPACE(25):
PRINT @(34,LN.TMP):SPACE(3):
PRINT @(42,LN.TMP):SPACE(2):
PRINT @(49,LN.TMP):SPACE(2):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PPV.DISTRIBUTORS~
*PROGRAM:           SH.MAINT.PPV.DISTRIBUTORS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.1)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:31:48
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.PPV.DISTRIBUTORS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PPV.DISTRIBUTORS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.1"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.DISTRIBUTORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 999
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CL"
TDC(1) = 15
TDT(1) = 6
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                       Maintain PPV Distributors/Studios                        ":RVE:"":
PRINT @(0,5):CLS:"                    ":RVB:" Code   ":RVE:"  ":RVB:"      Description        ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "PPV.DISTRIBUTORS"
COM.ID.SAVE<ONE> = "PPV.DISTRIBUTORS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PPV.DISTRIBUTORS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.DISTRIBUTORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L6","6","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 2
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<2,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<2,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,21,LN,"L6","6",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,21,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","2",COM,30,LN,"L25","50",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,30,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(21,LN):COM<1,VC> "L#6":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(21,LN):COM<1,VC> "L#6":
PRINT @(30,LN):COM<2,VC> "L#25":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(21,LN.TMP):SPACE(6):
PRINT @(30,LN.TMP):SPACE(25):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PPV.EVENT~
*PROGRAM:           SH.MAINT.PPV.EVENT
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:33:24
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "BILL"
SYS.PROG = "MAINT.PPV.EVENT"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PPV.EVENT"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(8); MAT TDL = EMPTY
DIM TDH(8); MAT TDH = EMPTY
DIM TDI(8); MAT TDI = EMPTY
DIM TDX(8); MAT TDX = ONE
DIM SAVE.TDX(8); MAT SAVE.TDX = EMPTY
DIM TDM(8); MAT TDM = EMPTY
DIM TDS(8); MAT TDS = EMPTY
DIM TDR(8); MAT TDR = EMPTY
DIM TDC(8); MAT TDC = EMPTY
DIM TDT(8); MAT TDT = EMPTY
VALID.REFS = "PM":AM:"CH":AM:"RC":AM:"RS":AM:"SD":AM:"ST":AM:"DU":AM:"DN"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "PVE" TO PVE.FILE ELSE FILE.NAME = "PVE"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PVM" TO PVM.FILE ELSE FILE.NAME = "PVM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.EVENT(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PVE.ID = EMPTY; PVE.ID.SAVE = EMPTY
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PVE.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PVE.ID.SAVE = EMPTY
END ELSE
PVE.ID = EMPTY; PVE.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PVE.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PVE",PVE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD PVE FROM PVE.FILE,PVE.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT PVE = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PVE",PVE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 8
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 8
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PVE.FILE,PVE.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE PVE ON PVE.FILE,PVE.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                          Maintain Pay Per View Events                          ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"    Event Number":RVE:"":
PRINT @(0,5):CLS:"":RVB:"    Master Event":RVE:"":
PRINT @(0,8):CLS:"":RVB:"PM> Program Mo. ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"CH> Channel     ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"RC> Rate Class  ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"RS>      Sub-Cl ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"SD> Show Date   ":RVE:"":
PRINT @(0,13):CLS:"":RVB:"ST> Show Time   ":RVE:"":
PRINT @(0,14):CLS:"":RVB:"DU> Duration    ":RVE:"":
PRINT @(0,15):CLS:"":RVB:"DN> Downloaded  ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PVE.ID
FOR ID.CN = ONE TO 1; PVE.ID.SAVE<ID.CN> = "!":PVE.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PVE.ID = TEMP
END
*
*
!
*
PRINT @(19,5):PVE$PVM.ID "L#6":
*
!
*
PRINT @(19,8):PVE$PROGMO "L#4":
*
!
*
PRINT @(19,9):PVE$CH.CODE "L#3":
*
!
*
PRINT @(19,10):PVE$RATE.CL "L#6":
*
!
*
PRINT @(19,11):PVE$RATE.CL.SUB "L#6":
*
!
*
PRINT @(19,12):OCONV(PVE$DT,"D2") "L#9":
*
!
*
PRINT @(19,13):OCONV(PVE$TM,"MT") "L#5":
*
!
*
PRINT @(19,14):OCONV(PVE$DUR,"MT") "L#5":
*
!
*
PRINT @(19,15):PVE$DOWNLOADED "L#1":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 1
ON ID.CN GOSUB K01
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PVE.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
PVE.ID = EMPTY
PVE.ID = PVE.ID:PVE.ID.SAVE<1>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PPV.EVENT +Itm:":PVE.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PVE.ID.SAVE<1>
CALL INPUT.DATA.SG1("PVE.ID","ID",FLD,19,3,"L9","9",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,19,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
PVE.ID.SAVE<1> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.EVENT(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07,I08
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("PVE$PROGMO","0",PVE$PROGMO,19,8,"L4","4",ONE,"","OP":VM:"4N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,8,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("PVE$CH","0",PVE$CH.CODE,19,9,"L3","3",ONE,"","OP":VM:"0N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,9,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
I03: *
CALL INPUT.DATA.SG1("PVE$RATE","0",PVE$RATE.CL,19,10,"L6","6",ONE,"","OP":VM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,10,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03
RETURN
I04: *
CALL INPUT.DATA.SG1("PVE$RATE","0",PVE$RATE.CL.SUB,19,11,"L6","6",ONE,"","OP":VM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,11,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I04
RETURN
I05: *
CALL INPUT.DATA.SG1("PVE$DT","0",PVE$DT,19,12,"L9","9",ONE,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,12,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I05
RETURN
I06: *
CALL INPUT.DATA.SG1("PVE$TM","0",PVE$TM,19,13,"L5","5",ONE,"MT","OP":VM:"TM","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,13,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I06
RETURN
I07: *
CALL INPUT.DATA.SG1("PVE$DUR","0",PVE$DUR,19,14,"L5","5",ONE,"MT","OP":VM:"TM","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,14,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I07
RETURN
I08: *
CALL INPUT.DATA.SG1("PVE$DOWNLOADED","0",PVE$DOWNLOADED,19,15,"L1","1",ONE,"","OP":VM:"OP":SVM:"Y":SVM:"N":SVM:"NUL","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,15,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I08
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PPV.EVENT.CLASS~
*PROGRAM:           SH.MAINT.PPV.EVENT.CLASS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.1)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:35:20
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.PPV.EVENT.CLASS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PPV.EVENT.CLASS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.1"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.EVENT.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 999
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CL"
TDC(1) = 15
TDT(1) = 6
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                      Maintain Pay Per View Event Classes                       ":RVE:"":
PRINT @(0,5):CLS:"                    ":RVB:" Class  ":RVE:"  ":RVB:"      Description        ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "PPV.EVENT.CLASSES"
COM.ID.SAVE<ONE> = "PPV.EVENT.CLASSES"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PPV.EVENT.CLASS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.EVENT.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L6","6","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 2
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<2,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<2,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,21,LN,"L6","6",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,21,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","2",COM,30,LN,"L25","50",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,30,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(21,LN):COM<1,VC> "L#6":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(21,LN):COM<1,VC> "L#6":
PRINT @(30,LN):COM<2,VC> "L#25":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(21,LN.TMP):SPACE(6):
PRINT @(30,LN.TMP):SPACE(25):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PPV.EVENTS~
*PROGRAM:           SH.MAINT.PPV.EVENTS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:37:08
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "BILL"
SYS.PROG = "MAINT.PPV.EVENTS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PPV.EVENTS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(8); MAT TDL = EMPTY
DIM TDH(8); MAT TDH = EMPTY
DIM TDI(8); MAT TDI = EMPTY
DIM TDX(8); MAT TDX = ONE
DIM SAVE.TDX(8); MAT SAVE.TDX = EMPTY
DIM TDM(8); MAT TDM = EMPTY
DIM TDS(8); MAT TDS = EMPTY
DIM TDR(8); MAT TDR = EMPTY
DIM TDC(8); MAT TDC = EMPTY
DIM TDT(8); MAT TDT = EMPTY
VALID.REFS = "PM":AM:"CH":AM:"RC":AM:"RS":AM:"SD":AM:"ST":AM:"DU":AM:"DN"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "PVE" TO PVE.FILE ELSE FILE.NAME = "PVE"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "PVM" TO PVM.FILE ELSE FILE.NAME = "PVM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.EVENTS(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PVE.ID = EMPTY; PVE.ID.SAVE = EMPTY
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PVE.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PVE.ID.SAVE = EMPTY
END ELSE
PVE.ID = EMPTY; PVE.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PVE.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PVE",PVE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD PVE FROM PVE.FILE,PVE.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT PVE = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PVE",PVE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 8
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 8
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PVE.FILE,PVE.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE PVE ON PVE.FILE,PVE.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                          Maintain Pay Per View Events                          ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"    Event Number":RVE:"":
PRINT @(0,5):CLS:"":RVB:"    Master Event":RVE:"":
PRINT @(0,8):CLS:"":RVB:"PM> Program Mo. ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"CH> Channel     ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"RC> Rate Class  ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"RS>      Sub-Cl ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"SD> Show Date   ":RVE:"":
PRINT @(0,13):CLS:"":RVB:"ST> Show Time   ":RVE:"":
PRINT @(0,14):CLS:"":RVB:"DU> Duration    ":RVE:"":
PRINT @(0,15):CLS:"":RVB:"DN> Downloaded  ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PVE.ID
FOR ID.CN = ONE TO 1; PVE.ID.SAVE<ID.CN> = "!":PVE.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PVE.ID = TEMP
END
*
*
!
*
PRINT @(19,5):PVE$PVM.ID "L#6":
*
!
*
PRINT @(19,8):PVE$PROGMO "L#4":
*
!
*
PRINT @(19,9):PVE$CH.CODE "L#3":
*
!
*
PRINT @(19,10):PVE$RATE.CL "L#6":
*
!
*
PRINT @(19,11):PVE$RATE.CL.SUB "L#6":
*
!
*
PRINT @(19,12):OCONV(PVE$DT,"D2") "L#9":
*
!
*
PRINT @(19,13):OCONV(PVE$TM,"MT") "L#5":
*
!
*
PRINT @(19,14):OCONV(PVE$DUR,"MT") "L#5":
*
!
*
PRINT @(19,15):PVE$DOWNLOADED "L#1":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 1
ON ID.CN GOSUB K01
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PVE.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
PVE.ID = EMPTY
PVE.ID = PVE.ID:PVE.ID.SAVE<1>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PPV.EVENTS +Itm:":PVE.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PVE.ID.SAVE<1>
CALL INPUT.DATA.SG1("PVE.ID","ID",FLD,19,3,"L9","9",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,19,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
PVE.ID.SAVE<1> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.EVENTS(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07,I08
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("PVE$PROGMO","0",PVE$PROGMO,19,8,"L4","4",ONE,"","OP":VM:"4N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,8,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("PVE$CH","0",PVE$CH.CODE,19,9,"L3","3",ONE,"","OP":VM:"0N","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,9,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
I03: *
CALL INPUT.DATA.SG1("PVE$RATE","0",PVE$RATE.CL,19,10,"L6","6",ONE,"","OP":VM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,10,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03
RETURN
I04: *
CALL INPUT.DATA.SG1("PVE$RATE","0",PVE$RATE.CL.SUB,19,11,"L6","6",ONE,"","OP":VM:"0X","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,11,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I04
RETURN
I05: *
CALL INPUT.DATA.SG1("PVE$DT","0",PVE$DT,19,12,"L9","9",ONE,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,12,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I05
RETURN
I06: *
CALL INPUT.DATA.SG1("PVE$TM","0",PVE$TM,19,13,"L5","5",ONE,"MT","OP":VM:"TM","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,13,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I06
RETURN
I07: *
CALL INPUT.DATA.SG1("PVE$DUR","0",PVE$DUR,19,14,"L5","5",ONE,"MT","OP":VM:"TM","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,14,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I07
RETURN
I08: *
CALL INPUT.DATA.SG1("PVE$DOWNLOADED","0",PVE$DOWNLOADED,19,15,"L1","1",ONE,"","OP":VM:"OP":SVM:"Y":SVM:"N":SVM:"NUL","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,15,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I08
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PPV.RATE.CLASS~
*PROGRAM:           SH.MAINT.PPV.RATE.CLASS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.1)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:39:08
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.PPV.RATE.CLASS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PPV.RATE.CLASS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.1"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.RATE.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 999
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "CL"
TDC(1) = 15
TDT(1) = 6
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                       Maintain Pay Per View Rate Classes                       ":RVE:"":
PRINT @(0,5):CLS:"                    ":RVB:" Class  ":RVE:"  ":RVB:"      Description        ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "PPV.RATE.CLASSES"
COM.ID.SAVE<ONE> = "PPV.RATE.CLASSES"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PPV.RATE.CLASS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.RATE.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,9,23,"L6","6","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 2
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<2,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<2,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,21,LN,"L6","6",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,21,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","2",COM,30,LN,"L25","50",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,30,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(21,LN):COM<1,VC> "L#6":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(21,LN):COM<1,VC> "L#6":
PRINT @(30,LN):COM<2,VC> "L#25":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(21,LN.TMP):SPACE(6):
PRINT @(30,LN.TMP):SPACE(25):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PPV.RATES~
*PROGRAM:           SH.MAINT.PPV.RATES
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:41:23
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "BILL"
SYS.PROG = "MAINT.PPV.RATES"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PPV.RATES"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "PC":AM:"TX":AM:"AT"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP RTE.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP RTE.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "RTE" TO RTE.FILE ELSE FILE.NAME = "RTE"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.RATES(TDL.REC,RTE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,RTE.FILE,RTE.ID,MAT RTE,COM.FILE,COM.ID,COM.ID.SAVE,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
RTE.ID = EMPTY; RTE.ID.SAVE = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I03.MAX = 999
TDM(3) = I03.MAX
TDS(3) = 1
TDR(3) = "AT"
TDC(3) = 7
TDT(3) = 14
READ PPV.RATE.CLASSES FROM COM.FILE,"PPV.RATE.CLASSES" ELSE PPV.RATE.CLASSES = EMPTY
READ RATE.TYPES FROM PAR.FILE,"RATE.TYPES" ELSE RATE.TYPES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND RTE.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN RTE.ID.SAVE = EMPTY
END ELSE
RTE.ID = EMPTY; RTE.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF RTE.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("RTE",RTE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD RTE FROM RTE.FILE,RTE.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT RTE = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("RTE",RTE.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 3
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 3
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE RTE.FILE,RTE.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE RTE ON RTE.FILE,RTE.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                          Maintain Pay Per View Rates                           ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Rate Class     ":RVE:"":
PRINT @(0,5):CLS:"":RVB:"Rate Sub-Class ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"Rate Type      ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"PC> Price      ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"TX> Taxes for  ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"    All Areas  ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"AT> Rate":RVE:"":
PRINT @(0,13):CLS:"":RVB:"    Area":RVE:"  ":RVB:"            Taxes             ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = RTE.ID
FOR ID.CN = ONE TO 7; RTE.ID.SAVE<ID.CN> = "!":RTE.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
RTE.ID = TEMP
END
*
*
!
*
PRINT @(17,9):OCONV(RTE$AMTS,"MR2ZM") "L#9":
*
!
*
PRINT @(17,10):RTE$TAX.NAMES "L#30":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D03
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 7
ON ID.CN GOSUB K01,K02,K03,K04,K05,K06,K07
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 3 AND RTE.ID.SAVE<3> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
RTE.ID = EMPTY
RTE.ID = RTE.ID:RTE.ID.SAVE<1>
RTE.ID = RTE.ID:RTE.ID.SAVE<2>
RTE.ID = RTE.ID:RTE.ID.SAVE<3>
RTE.ID = RTE.ID:RTE.ID.SAVE<4>
RTE.ID = RTE.ID:RTE.ID.SAVE<5>
RTE.ID = RTE.ID:RTE.ID.SAVE<6>
RTE.ID = RTE.ID:RTE.ID.SAVE<7>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PPV.RATES +Itm:":RTE.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "PPV"
FLD = RSP
RTE.ID.SAVE<1> = "PPV"
RETURN
*
K02: *
STAT = ZERO
RSP = "*"
FLD = RSP
RTE.ID.SAVE<2> = "*"
RETURN
*
K03: *
IF STAT LT ZERO THEN RETURN
FLD = RTE.ID.SAVE<3>
CALL INPUT.DATA.SG1("","ID",FLD,17,3,"L6","6",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,17,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
RTE.ID.SAVE<3> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN PPV.RATE.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.RATE.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(25,LN):SPACE(25):
RETURN
*
*
K04: *
STAT = ZERO
RSP = "*"
FLD = RSP
RTE.ID.SAVE<4> = "*"
RETURN
*
K05: *
IF STAT LT ZERO THEN RETURN
FLD = RTE.ID.SAVE<5>
CALL INPUT.DATA.SG1("","ID",FLD,17,5,"L6","6",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,17,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 5; GOSUB T02
RTE.ID.SAVE<5> = RSP
RETURN
*
T02: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN PPV.RATE.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.RATE.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC02: *
PRINT @(25,LN):SPACE(25):
RETURN
*
*
K06: *
STAT = ZERO
RSP = "*"
FLD = RSP
RTE.ID.SAVE<6> = "*"
RETURN
*
K07: *
IF STAT LT ZERO THEN RETURN
FLD = RTE.ID.SAVE<7>
CALL INPUT.DATA.SG1("","ID",FLD,17,7,"L3","3",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,17,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 7; GOSUB T03
RTE.ID.SAVE<7> = RSP
RETURN
*
T03: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN RATE.TYPES<ONE> SETTING LOC THEN TRN.FLD = RATE.TYPES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC03: *
PRINT @(25,LN):SPACE(25):
RETURN
*
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.RATES(TDL.REC,RTE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,RTE.FILE,RTE.ID,MAT RTE,COM.FILE,COM.ID,COM.ID.SAVE,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("RTE$AMTS","0",RTE$AMTS,17,9,"L9","9",ONE,"MR2ZM","OP":VM:"NU","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,17,9,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("RTE$TAX","0",RTE$TAX.NAMES,17,10,"L30","100",ONE,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,17,10,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB ERROR,ERROR,Y03
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB ERROR,ERROR,I03.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB ERROR,ERROR,D03
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB ERROR,ERROR,X03
IF INX.FOUND THEN
PRINT CLB:"Ref. ":TDR(REF):"> ":FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB ERROR,ERROR,D03
END ELSE
ON REF GOSUB ERROR,ERROR,R03
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,ERROR,D03
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB ERROR,ERROR,A03
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,ERROR,D03
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I03.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("RTE$AREAS","0",FLD,13,23,"L2","2","1","","SE":VM:"OP":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,13,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I03: *
*
TDI(REF) = DCOUNT(RTE$AREAS<ONE>,VM)
TDL.REF = 3; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I03.INP: *
*
FOR SUB.REF = 2 TO 2
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I03A,I03B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,ERROR,R03
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D03
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D03
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I03
*
RETURN
*
*
X03: *
*
LOCATE INX.STR IN RTE$AREAS<ONE> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = RTE$AREAS<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE RTE$AREAS<ONE,VC>
INS EMPTY BEFORE RTE$AREA.TAX.NAMES<ONE,VC>
*
RETURN
*
!
*
R03: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL RTE$AREAS<ONE,VC>
DEL RTE$AREA.TAX.NAMES<ONE,VC>
*
RETURN
*
I03A: *
*
CALL INPUT.DATA.SG1("RTE$AREAS","0",RTE$AREAS,4,LN,"L2","2",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,4,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03A
RETURN
*
I03B: *
*
CALL INPUT.DATA.SG1("RTE$AREA","0",RTE$AREA.TAX.NAMES,10,LN,"L30","100",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,10,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03B
RETURN
*
D03: *
*
SAVE.REF = REF; REF = 03
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(RTE$AREAS<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(4,LN):RTE$AREAS<ONE,VC> "L#2":
LN.REDISP = FALSE
GOTO D03.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D03.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND RTE$AREAS<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(4,LN):RTE$AREAS<ONE,VC> "L#2":
PRINT @(10,LN):RTE$AREA.TAX.NAMES<ONE,VC> "L#30":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D03.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,ERROR,C03
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D03.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C03: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(4,LN.TMP):SPACE(2):
PRINT @(10,LN.TMP):SPACE(30):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PVM.EVENT.NUMS~
*PROGRAM:           SH.MAINT.PVM.EVENT.NUMS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (2)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:43:35
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.PVM.EVENT.NUMS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PVM.EVENT.NUMS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "2"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "PVM" TO PVM.FILE ELSE FILE.NAME = "PVM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PVM.EVENT.NUMS(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 999
TDM(1) = I01.MAX
TDS(1) = 0
TDR(1) = "CH"
TDC(1) = 14
TDT(1) = 7
READ PPV.EVENT.CLASSES FROM COM.FILE,"PPV.EVENT.CLASSES" ELSE PPV.EVENT.CLASSES = EMPTY
READ PPV.RATE.CLASSES FROM COM.FILE,"PPV.RATE.CLASSES" ELSE PPV.RATE.CLASSES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PVM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PVM.ID.SAVE = EMPTY
END ELSE
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PVM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD PVM FROM PVM.FILE,PVM.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT PVM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
TEXT = "Not on file"; GOSUB ERROR; GOTO UNLOCK
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE PVM ON PVM.FILE,PVM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                          PPV Event Number Maintenance                          ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Event:":RVE:"":
PRINT @(0,4):CLS:"                                                       ":RVB:"Defaults:":RVE:"":
PRINT @(0,6):CLS:"":RVB:"Sched. (YYMM):":RVE:"               ":RVB:"Ln#":RVE:" ":RVB:"..Date...":RVE:"  ":RVB:".Time":RVE:"  ":RVB:"Rate Cl.":RVE:"  ":RVB:"Sub. Cl.":RVE:"   ":RVB:"Event#":RVE:"":
PRINT @(0,7):CLS:"":RVB:"Distributor:  ":RVE:"":
PRINT @(0,8):CLS:"":RVB:"Studio:       ":RVE:"":
PRINT @(0,9):CLS:"":RVB:"Channel Code: ":RVE:"":
PRINT @(0,10):CLS:"":RVB:"Duration:     ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"Debut Date:   ":RVE:"":
PRINT @(0,12):CLS:"":RVB:"Prog Class:   ":RVE:"":
PRINT @(0,13):CLS:"":RVB:"Mrkt Class:   ":RVE:"":
PRINT @(0,14):CLS:"":RVB:"Star Rating:  ":RVE:"":
PRINT @(0,15):CLS:"":RVB:"Guide Rating: ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PVM.ID
FOR ID.CN = ONE TO 1; PVM.ID.SAVE<ID.CN> = "!":PVM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PVM.ID = TEMP
END
*
*
!
*
PRINT @(16,3):PVM$DESC "L#25":
PRINT @(47,3):PVM$CL "L#6":; LN = 3; GOSUB T01
PRINT @(16,6):PVM$PROGMO "L#4":
PRINT @(16,7):PVM$DISTR "L#6":
PRINT @(16,8):PVM$STUDIO "L#6":
PRINT @(16,9):PVM$CH.CODE "L#3":
PRINT @(16,10):OCONV(PVM$DUR,"MT") "L#5":
PRINT @(16,11):OCONV(PVM$DEBUT.DT,"D2") "L#9":
PRINT @(16,12):PVM$PROG.CL "L#6":
PRINT @(16,13):PVM$MRKT.CL "L#6":
PRINT @(16,14):PVM$STARS "L#1":
PRINT @(16,15):PVM$RATING "L#5":
PRINT @(52,5):PVM$RATE.CL "L#6":
PRINT @(62,5):PVM$RATE.CL.SUB "L#6":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 1
ON ID.CN GOSUB K01
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PVM.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
PVM.ID = EMPTY
PVM.ID = PVM.ID:PVM.ID.SAVE<1>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PVM.EVENT.NUMS +Itm:":PVM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PVM.ID.SAVE<1>
CALL INPUT.DATA.SG1("PVM.ID","ID",FLD,8,3,"L6","6",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,8,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
PVM.ID.SAVE<1> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PVM.EVENT.NUMS(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.REG: *
*
IF NEW OR NOT(TDI(REF)) OR DYN EQ "N" THEN
*
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
ON REF GOSUB A01
DYN = "N"
*
END ELSE
*
*
IF SAVE.DYN EQ "I" THEN
SAVE.REFLN = SAVE.REFLN + ONE
DYN = SAVE.REFLN; INX.LOC = SAVE.REFLN
END ELSE IF NOT(LN.LOC) THEN
IF NOT(SYS11.FL) THEN
DYN = EMPTY
ON REF GOSUB D01
PRINT CLB:"Enter line no., N(ext line) or <cr> if okay: ":
END
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFLN",DYN,46,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,46,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF DYN EQ EMPTY THEN INX.STR = EMPTY; STAT = -ONE; RETURN
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.REG.EXIT; * : *
END
END ELSE
DYN = TDL(REF); IF DYN THEN DYN = DYN - ONE
DYN = DYN + LN.LOC
INX.LOC = DYN
ON REF GOSUB Y01
LN.LOC = ZERO
END
*
IF DYN EQ EMPTY THEN RETURN
IF DYN EQ "^" THEN STAT = -ONE; RETURN
*
IF SAVE.DYN EQ "I" THEN
DYN = "I"
*
END ELSE IF DYN EQ "N" THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "N"
ON REF GOSUB D01
END
*
*
END ELSE
*
IF NOT(DYN MATCHES "0N") THEN DYN = ZERO
IF NOT(NUM(DYN)) THEN DYN = ZERO
IF NOT(DYN) THEN
GOTO VTY.INP.REG.EXIT; * : *
END
*
INX.LOC = DYN
REFLN = DYN
ON REF GOSUB Y01
IF INX.STR EQ EMPTY OR INX.LOC GT TDI(REF) THEN
FLD =EMPTY; INX.STR = EMPTY
ON REF GOSUB X01
PRINT BELL:
END
*
SAVE.REFLN = INX.LOC
IF INX.LOC LT TDL(REF) OR INX.LOC GT TDL(REF) + TDC(REF) - ONE THEN
DYN = "E"
ON REF GOSUB D01
END
*
LOOP
PRINT CLB:TDR(REF):"(":INX.LOC:"), Enter I(nsert), D(elete) or <cr> to change line: ":
DYN = EMPTY
CALL INPUT.DATA.SG1("COM","REFFUNC",DYN,62,23,"L5","5","1","","SE":VM:"OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"1",TC.FUNC,62,23,".",STD.SUBR.NAME,PROCBUF,STAT)
IF DYN EQ "KILL" OR STAT EQ 999 THEN STAT = 999; RETURN
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; DYN = EMPTY
UNTIL DYN EQ "I" OR DYN EQ "D" OR DYN EQ EMPTY DO PRINT BELL: REPEAT
*
END; * of DYN EQ "N"
*
*
END; * of NEW
*
SAVE.DYN = DYN
*
IF NOT(DYN EQ "I" OR DYN EQ "N") THEN
IF DYN NE "D" THEN
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.REG; * : *
END
END ELSE
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.REG.EXIT; * : *
END
FLD = EMPTY; INX.STR = EMPTY
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.REG.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PVM$PVE","18",FLD,9,23,"L9","9","1","D2","SE":VM:"OP":VM:"OP":VM:"DT","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,9,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = OCONV(FLD,"D2")
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PVM$PVE.DT<ONE>,VM)
TDL.REF = 1; GOSUB VTY.INP.REG; * : *
*
IF STAT THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 1 TO 2
IF SUB.REF GE SUB.REF.LOC - 0 THEN
ON SUB.REF GOSUB I01A,I01B
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 1 THEN SUB.REF = 2
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PVM$PVE.DT<ONE> SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PVM$PVE.DT<ONE,VC>
INX.STR.OUT = OCONV(INX.STR,"D2")
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PVM$PVE.DT<ONE,VC>
INS EMPTY BEFORE PVM$PVE.TM<ONE,VC>
INS EMPTY BEFORE PVM$PVE.RATE.CL<ONE,VC>
INS EMPTY BEFORE PVM$PVE.RATE.CL.SUB<ONE,VC>
INS EMPTY BEFORE PVM$EVENT.NUMS<ONE,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PVM$PVE.DT<ONE,VC>
DEL PVM$PVE.TM<ONE,VC>
DEL PVM$PVE.RATE.CL<ONE,VC>
DEL PVM$PVE.RATE.CL.SUB<ONE,VC>
DEL PVM$EVENT.NUMS<ONE,VC>
*
RETURN
*
I01A: *
*
IF PVM$PVE.DT<ONE,VC> EQ " " THEN PVM$PVE.DT<ONE,VC> = EMPTY
PRINT @(30,LN):SPACE(2-LEN(VC)):RVB:VC:RVE:" ":
CALL INPUT.DATA.SG1("PVM$PVE","18",PVM$PVE.DT,33,LN,"L9","9",ONE:",":VC,"D2","OP":VM:"OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,33,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
IF STAT THEN RETURN
RETURN
*
I01B: *
*
PRINT @(44,LN):OCONV(PVM$PVE.TM<ONE,VC>,"MT") "L#5":
*
RETURN
*
I01C: *
*
PRINT @(52,LN):PVM$PVE.RATE.CL<ONE,VC> "L#6":
*
RETURN
*
I01D: *
*
PRINT @(62,LN):PVM$PVE.RATE.CL.SUB<ONE,VC> "L#6":
*
RETURN
*
I01E: *
*
CALL INPUT.DATA.SG1("PVM$EVENT","22",PVM$EVENT.NUMS,73,LN,"L4","4",ONE:",":VC,"","OP":VM:"","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,73,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01E
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PVM$PVE.DT<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(30,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":OCONV(PVM$PVE.DT<ONE,VC>,"D2") "L#9":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PVM$PVE.DT<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(30,LN):SPACE(TWO - LEN(VC)):RVB:VC:RVE:" ":OCONV(PVM$PVE.DT<ONE,VC>,"D2") "L#9":
PRINT @(44,LN):OCONV(PVM$PVE.TM<ONE,VC>,"MT") "L#5":
PRINT @(52,LN):PVM$PVE.RATE.CL<ONE,VC> "L#6":
PRINT @(62,LN):PVM$PVE.RATE.CL.SUB<ONE,VC> "L#6":
PRINT @(73,LN):PVM$EVENT.NUMS<ONE,VC> "L#4":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(30,LN.TMP):SPACE(12):
PRINT @(44,LN.TMP):SPACE(5):
PRINT @(52,LN.TMP):SPACE(6):
PRINT @(62,LN.TMP):SPACE(6):
PRINT @(73,LN.TMP):SPACE(4):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
T01: *
*
TRN.FLD = PVM$CL
LOCATE TRN.FLD IN PPV.EVENT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = PPV.EVENT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(55,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(55,LN):SPACE(25):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PVM.PVE.XREF~
*PROGRAM:           SH.MAINT.PVM.PVE.XREF
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:45:57
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.PVM.PVE.XREF"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PVM.PVE.XREF"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "DS":AM:"EV"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "PVM" TO PVM.FILE ELSE FILE.NAME = "PVM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PVM.PVE.XREF(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I02.MAX = 99
TDM(2) = I02.MAX
TDS(2) = 1
TDR(2) = "EV"
TDC(2) = 10
TDT(2) = 10
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PVM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PVM.ID.SAVE = EMPTY
END ELSE
PVM.ID = EMPTY; PVM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PVM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
MATREAD PVM FROM PVM.FILE,PVM.ID THEN NEW = FALSE ELSE NEW = TRUE; MAT PVM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PVM",PVM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 2
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 2
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PVM.FILE,PVM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
MATWRITE PVM ON PVM.FILE,PVM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                          Event Master Detail Listing                           ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Event ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"DS> Description":RVE:"":
PRINT @(0,9):CLS:"                ":RVB:"EV> ":RVB:"..Date...":RVE:" ":RVB:"..Time...":RVE:" ":RVB:"Component":RVE:" ":RVB:"Duration.":RVE:" ":RVB:"PVE.Event":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PVM.ID
FOR ID.CN = ONE TO 1; PVM.ID.SAVE<ID.CN> = "!":PVM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PVM.ID = TEMP
END
*
*
!
*
PRINT @(16,4):PVM$DESC "L#25":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D02
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 1
ON ID.CN GOSUB K01
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PVM.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
PVM.ID = EMPTY
PVM.ID = PVM.ID:PVM.ID.SAVE<1>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PVM.PVE.XREF +Itm:":PVM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PVM.ID.SAVE<1>
CALL INPUT.DATA.SG1("PVM.ID","ID",FLD,8,3,"L8","8",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,8,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
PVM.ID.SAVE<1> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PVM.PVE.XREF(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("PVM$DESC","2",PVM$DESC,16,4,"L25","25",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,16,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB ERROR,Y02
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB ERROR,I02.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB ERROR,D02
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB ERROR,X02
IF INX.FOUND THEN
PRINT CLB:"Ref. ":TDR(REF):"> ":FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB ERROR,D02
END ELSE
ON REF GOSUB ERROR,R02
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,D02
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB ERROR,A02
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,D02
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I02.KEY: *
*
FLD = EMPTY
CALL GET.PVE.XREF("PVM$PVE","0",PVM$PVE,15,23,"L0","0","1","","SE":VM:"OP":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,15,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I02: *
*
TDI(REF) = DCOUNT(PVM$PVE.XREF<ONE>,VM)
TDL.REF = 2; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I02.INP: *
*
FOR SUB.REF = 2 TO 6
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I02A,I02B,I02C,I02D,I02E,I02F
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,R02
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D02
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 6
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D02
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I02
*
RETURN
*
*
X02: *
*
LOCATE INX.STR IN PVM$PVE.XREF<ONE> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y02: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PVM$PVE.XREF<ONE,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A02: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PVM$PVE.XREF<ONE,VC>
INS EMPTY BEFORE PVM$PVE.DT<ONE,VC>
INS EMPTY BEFORE PVM$PVE.TM<ONE,VC>
INS EMPTY BEFORE PVM$PVE.COMP<ONE,VC>
INS EMPTY BEFORE PVM$PVE.ELP.TM<ONE,VC>
INS EMPTY BEFORE PVM$PVE.ID<ONE,VC>
*
RETURN
*
!
*
R02: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PVM$PVE.XREF<ONE,VC>
DEL PVM$PVE.DT<ONE,VC>
DEL PVM$PVE.TM<ONE,VC>
DEL PVM$PVE.COMP<ONE,VC>
DEL PVM$PVE.ELP.TM<ONE,VC>
DEL PVM$PVE.ID<ONE,VC>
*
RETURN
*
I02A: *
*
CALL INPUT.DATA.SG1("PVM$PVE","0",PVM$PVE.XREF,4,LN,"L0","0",ONE:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,4,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02A
RETURN
*
I02B: *
*
CALL INPUT.DATA.SG1("PVM$PVE","18",PVM$PVE.DT,20,LN,"L9","9",ONE:",":VC,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,20,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02B
RETURN
*
I02C: *
*
CALL INPUT.DATA.SG1("PVM$PVE","19",PVM$PVE.TM,30,LN,"L8","8",ONE:",":VC,"MTS","OP":VM:"","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,30,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02C
RETURN
*
I02D: *
*
CALL INPUT.DATA.SG1("PVM$PVE","0",PVM$PVE.COMP,40,LN,"L8","8",ONE:",":VC,"","EQ":SVM:"@":COMPONENTS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,40,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02D
RETURN
*
I02E: *
*
CALL INPUT.DATA.SG1("PVM$PVE","0",PVM$PVE.ELP.TM,50,LN,"L8","8",ONE:",":VC,"MTS","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,50,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02E
RETURN
*
I02F: *
*
CALL INPUT.DATA.SG1("PVM$PVE","0",PVM$PVE.ID,60,LN,"L9","9",ONE:",":VC,"","OP":VM:"FI",.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,60,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02F
RETURN
*
D02: *
*
SAVE.REF = REF; REF = 02
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PVM$PVE.XREF<ONE>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(4,LN):PVM$PVE.XREF<ONE,VC> "L#0":
LN.REDISP = FALSE
GOTO D02.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D02.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PVM$PVE.XREF<ONE,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(4,LN):PVM$PVE.XREF<ONE,VC> "L#0":
PRINT @(20,LN):OCONV(PVM$PVE.DT<ONE,VC>,"D2") "L#9":
PRINT @(30,LN):OCONV(PVM$PVE.TM<ONE,VC>,"MTS") "L#8":
PRINT @(40,LN):PVM$PVE.COMP<ONE,VC> "L#8":
PRINT @(50,LN):OCONV(PVM$PVE.ELP.TM<ONE,VC>,"MTS") "L#8":
PRINT @(60,LN):PVM$PVE.ID<ONE,VC> "L#9":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D02.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,C02
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D02.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C02: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(4,LN.TMP):SPACE(0):
PRINT @(20,LN.TMP):SPACE(9):
PRINT @(30,LN.TMP):SPACE(8):
PRINT @(40,LN.TMP):SPACE(8):
PRINT @(50,LN.TMP):SPACE(8):
PRINT @(60,LN.TMP):SPACE(9):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.PVM.XREF~
*PROGRAM:           SH.MAINT.PVM.XREF
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:48:07
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.PVM.XREF"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.PVM.XREF"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(13); MAT TDL = EMPTY
DIM TDH(13); MAT TDH = EMPTY
DIM TDI(13); MAT TDI = EMPTY
DIM TDX(13); MAT TDX = ONE
DIM SAVE.TDX(13); MAT SAVE.TDX = EMPTY
DIM TDM(13); MAT TDM = EMPTY
DIM TDS(13); MAT TDS = EMPTY
DIM TDR(13); MAT TDR = EMPTY
DIM TDC(13); MAT TDC = EMPTY
DIM TDT(13); MAT TDT = EMPTY
VALID.REFS = "DE":AM:"DB":AM:"PU":AM:"ST":AM:"CO":AM:"CL":AM:"SC":AM:"MC":AM:"RC":AM:"RS":AM:"RA":AM:"TA":AM:"CO"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "SVC" TO SVC.FILE ELSE FILE.NAME = "SVC"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PVM.XREF(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
SVC.ID = EMPTY; SVC.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I13.MAX = 99
TDM(13) = I13.MAX
TDS(13) = 1
TDR(13) = "CO"
TDC(13) = 4
TDT(13) = 12
READ STUDIOS FROM COM.FILE,"STUDIOS" ELSE STUDIOS = EMPTY
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
READ EVENT.CLASSES FROM COM.FILE,"EVENT.CLASSES" ELSE EVENT.CLASSES = EMPTY
READ MRKT.CLASSES FROM COM.FILE,"MRKT.CLASSES" ELSE MRKT.CLASSES = EMPTY
READ RATE.CLASSES FROM COM.FILE,"RATE.CLASSES" ELSE RATE.CLASSES = EMPTY
READ CHANNELS FROM COM.FILE,"CHANNELS" ELSE CHANNELS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 13
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 13
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                         Service Components Maintenance                         ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Event ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"DE> Description":RVE:"":
PRINT @(0,5):CLS:"                                                       ":RVB:"DB> Debut ":RVE:"":
PRINT @(0,6):CLS:"":RVB:"CL>       Class":RVE:"                                        ":RVB:"PU> Purge ":RVE:"":
PRINT @(0,7):CLS:"":RVB:"SC>   Sub-Class":RVE:"                                        ":RVB:"ST> Studio":RVE:"":
PRINT @(0,8):CLS:"":RVB:"MC> Mrkt Class ":RVE:"":
PRINT @(0,9):CLS:"                                                       ":RVB:"CO>mponent":RVE:"":
PRINT @(0,10):CLS:"":RVB:"Component Programmers Showing Event               ":RVE:"":
PRINT @(0,11):CLS:"":RVB:"Component   ":RVE:"as":RVB:"Ch# ":RVB:"Description           ":RVB:"Programmer":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 2; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
*
!
*
PRINT @(16,4):COM$DESC "L#25":
*
!
*
PRINT @(66,5):OCONV(COM$DEBUT.DT,"D2") "L#10":
*
!
*
PRINT @(66,6):OCONV(COM$PURGE.DT,"D2") "L#10":
*
!
*
PRINT @(66,7):COM$DISTR "L#8":; LN = 7; GOSUB T01
*
!
*
PRINT @(66,9):COM$COMP "L#8":
*
!
*
PRINT @(16,6):COM$CL "L#8":; LN = 6; GOSUB T02
*
!
*
PRINT @(16,7):COM$PROG.CL "L#8":; LN = 7; GOSUB T03
*
!
*
PRINT @(16,8):COM$MRKT.CL "L#8":; LN = 8; GOSUB T04
*
!
*
PRINT @(16,10):COM$RATE.CL "L#8":; LN = 10; GOSUB T05
*
!
*
PRINT @(21,11):COM$RATE.CL.SUB "L#8":; LN = 11; GOSUB T06
*
!
*
PRINT @(65,5):OCONV(COM<5>,"MR2ZM") "L#10":
*
!
*
PRINT @(65,6):COM<6> "L#10":
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D13
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 2
ON ID.CN GOSUB K01,K02
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND COM.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.PVM.XREF +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<1>
CALL INPUT.DATA.SG1("COM.ID","ID",FLD,8,3,"L8","8",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,8,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.ID.SAVE<1> = RSP
RETURN
*
K02: *
STAT = ZERO
RSP = "*ALL"
FLD = RSP
COM.ID.SAVE<2> = "*ALL"
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PVM.XREF(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02,I03,I04,I05,I06,I07,I08,I09,I10,I11,I12,I13
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("COM$DESC","0",COM$DESC,16,4,"L25","25",ONE,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,16,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("COM$DEBUT","0",COM$DEBUT.DT,66,5,"L10","10",ONE,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,66,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
I03: *
CALL INPUT.DATA.SG1("COM$PURGE","0",COM$PURGE.DT,66,6,"L10","10",ONE,"D2","OP":VM:"DT","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,66,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I03
RETURN
I04: *
CALL INPUT.DATA.SG1("COM$DISTR","0",COM$DISTR,66,7,"L8","8",ONE,"","OP":VM:"EQ":SVM:"@":STUDIOS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,66,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 7; GOSUB T01
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I04
RETURN
I05: *
CALL INPUT.DATA.SG1("COM$COMP","0",COM$COMP,66,9,"L8","8",ONE,"","OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,66,9,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I05
RETURN
I06: *
CALL INPUT.DATA.SG1("COM$CL","0",COM$CL,16,6,"L8","8",ONE,"","OP":VM:"EQ":SVM:"@":EVENT.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,16,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 6; GOSUB T02
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I06
RETURN
I07: *
CALL INPUT.DATA.SG1("COM$PROG","0",COM$PROG.CL,16,7,"L8","8",ONE,"","OP":VM:"EQ":SVM:"@":EVENT.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,16,7,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 7; GOSUB T03
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I07
RETURN
I08: *
CALL INPUT.DATA.SG1("COM$MRKT","0",COM$MRKT.CL,16,8,"L8","8",ONE,"","OP":VM:"EQ":SVM:"@":MRKT.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,16,8,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 8; GOSUB T04
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I08
RETURN
I09: *
CALL INPUT.DATA.SG1("COM$RATE","0",COM$RATE.CL,16,10,"L8","8",ONE,"","OP":ESC:"":VM:"":VM:"EQ":SVM:"*1":SVM:"RATE.CLASSES","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,16,10,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 10; GOSUB T05
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I09
RETURN
I10: *
CALL INPUT.DATA.SG1("COM$RATE","0",COM$RATE.CL.SUB,21,11,"L8","8",ONE,"","OP":VM:"EQ":SVM:"@":RATE.CLASSES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,21,11,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN ELSE LN = 11; GOSUB T06
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I10
RETURN
I11: *
CALL INPUT.DATA.SG1("COM","5",COM,65,5,"L10","10",5,"MR2ZM","NU":VM:"LO":SVM:"0","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,65,5,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I11
RETURN
I12: *
CALL INPUT.DATA.SG1("COM","6",COM,65,6,"L10","20",6,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,65,6,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I12
RETURN
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,Y13
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,I13.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D13
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,X13
IF INX.FOUND THEN
PRINT CLB:"Ref. ":TDR(REF):"> ":FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D13
END ELSE
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,R13
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D13
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,A13
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,D13
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I13.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","10",FLD,18,23,"L8","8","1","","SE":VM:"OP":VM:"OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,18,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I13: *
*
TDI(REF) = DCOUNT(COM<10>,VM)
TDL.REF = 13; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I13.INP: *
*
FOR SUB.REF = 2 TO 4
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I13A,I13B,I13C,I13D
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,R13
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D13
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 4
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D13
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I13
*
RETURN
*
*
X13: *
*
LOCATE INX.STR IN COM<10> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y13: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<10,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A13: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<10,VC>
INS EMPTY BEFORE COM<10,VC>
*
RETURN
*
!
*
R13: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<10,VC>
DEL COM<10,VC>
*
RETURN
*
I13A: *
*
CALL INPUT.DATA.SG1("COM","10",COM,4,LN,"L8","8",10:",":VC,"","OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,4,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I13A
IF STAT THEN RETURN ELSE GOSUB T07
RETURN
*
I13B: *
*
CALL INPUT.DATA.SG1("COM","10",COM,18,LN,"L25","25",10:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,18,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I13B
IF STAT THEN RETURN ELSE GOSUB T08
RETURN
*
D13: *
*
SAVE.REF = REF; REF = 13
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<10>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(4,LN):COM<10,VC> "L#8":; GOSUB T07
LN.REDISP = FALSE
GOTO D13.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D13.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<10,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(4,LN):COM<10,VC> "L#8":; GOSUB T07
PRINT @(18,LN):COM<10,VC> "L#25":; GOSUB T08
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D13.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,ERROR,C13
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D13.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C13: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(4,LN.TMP):SPACE(8):; GOSUB TC07
PRINT @(18,LN.TMP):SPACE(25):; GOSUB TC08
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN STUDIOS<ONE> SETTING LOC THEN TRN.FLD = STUDIOS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(55,LN):TRN.FLD "L#20":
RETURN
*
TC01: *
PRINT @(55,LN):SPACE(20):
RETURN
T02: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN EVENT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = EVENT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC02: *
PRINT @(25,LN):SPACE(25):
RETURN
T03: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN EVENT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = EVENT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC03: *
PRINT @(25,LN):SPACE(25):
RETURN
T04: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN MRKT.CLASSES<ONE> SETTING LOC THEN TRN.FLD = MRKT.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC04: *
PRINT @(25,LN):SPACE(25):
RETURN
T05: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN RATE.CLASSES<ONE> SETTING LOC THEN TRN.FLD = RATE.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC05: *
PRINT @(25,LN):SPACE(25):
RETURN
T06: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN RATE.CLASSES<ONE> SETTING LOC THEN TRN.FLD = RATE.CLASSES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(25,LN):TRN.FLD "L#25":
RETURN
*
TC06: *
PRINT @(25,LN):SPACE(25):
RETURN
T07: *
*
TRN.FLD = COM<10,VC>
LOCATE TRN.FLD IN COMPONENTS<1> SETTING LOC THEN TRN.FLD = COMPONENTS<3,LOC> ELSE TRN.FLD = EMPTY
PRINT @(14,LN):TRN.FLD "L#3":
RETURN
*
TC07: *
PRINT @(14,LN):SPACE(3):
RETURN
T08: *
*
TRN.FLD = COM<10,VC>
LOCATE TRN.FLD IN CHANNELS<1> SETTING LOC THEN TRN.FLD = CHANNELS<3,LOC> ELSE TRN.FLD = EMPTY
PRINT @(40,LN):TRN.FLD "L#8":
RETURN
*
TC08: *
PRINT @(40,LN):SPACE(8):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.SERVICE.CHANNELS~
*PROGRAM:           SH.MAINT.SERVICE.CHANNELS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:50:38
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "PARAMS"
SYS.PROG = "MAINT.SERVICE.CHANNELS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.SERVICE.CHANNELS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "CLO":AM:"CHI"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "SVC" TO SVC.FILE ELSE FILE.NAME = "SVC"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.SERVICE.CHANNELS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
SVC.ID = EMPTY; SVC.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
READ COMPONENTS FROM PAR.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 2
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 2
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                           Service Component Channels                           ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Service":RVE:"":
PRINT @(0,4):CLS:"":RVB:"Component":RVE:"":
PRINT @(0,6):CLS:"          ":RVB:"       Channel / Tag Number Cross Reference       ":RVE:"":
PRINT @(0,11):CLS:"          ":RVB:"                 Channels 1 to 50                 ":RVE:"":
PRINT @(0,12):CLS:"          ":RVB:"         1         2         3         4         5":RVE:"":
PRINT @(0,13):CLS:"          ":RVB:"12345678901234567890123456789012345678901234567890":RVE:"":
PRINT @(0,16):CLS:"          ":RVB:"                Channels 51 to 100                ":RVE:"":
PRINT @(0,17):CLS:"          ":RVB:"                                                 1":RVE:"":
PRINT @(0,18):CLS:"          ":RVB:"5        6         7         8         9         0":RVE:"":
PRINT @(0,19):CLS:"          ":RVB:"12345678901234567890123456789012345678901234567890":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 3; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
*
!
*
PRINT @(10,11):PAR<3> "L#50":
*
!
*
PRINT @(10,17):PAR<4> "L#50":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 3
ON ID.CN GOSUB K01,K02,K03
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 1 AND PAR.ID.SAVE<1> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
PAR.ID = EMPTY
PAR.ID = PAR.ID:PAR.ID.SAVE<1>
PAR.ID = PAR.ID:PAR.ID.SAVE<2>
PAR.ID = PAR.ID:PAR.ID.SAVE<3>
*
GOSUB IDE.C
*
*
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.SERVICE.CHANNELS +Itm:":PAR.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
IF STAT LT ZERO THEN RETURN
FLD = PAR.ID.SAVE<1>
CALL INPUT.DATA.SG1("PAR.ID","ID",FLD,10,3,"L8","8",1,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,10,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
PAR.ID.SAVE<1> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
READV TRN.FLD FROM SVC.FILE,TR.FLD,1 ELSE TRN.FLD = EMPTY
PRINT @(20,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(20,LN):SPACE(25):
RETURN
*
*
K02: *
STAT = ZERO
RSP = "*"
FLD = RSP
PAR.ID.SAVE<2> = "*"
RETURN
*
K03: *
IF STAT LT ZERO THEN RETURN
FLD = PAR.ID.SAVE<3>
CALL INPUT.DATA.SG1("PAR.ID","ID",FLD,10,4,"L5","5",1,"","EQ":SVM:"@":COMPONENTS<3>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,10,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 4; GOSUB T02
PAR.ID.SAVE<3> = RSP
RETURN
*
T02: *
*
TRN.FLD = PAR<2>
LOCATE TRN.FLD IN COMPONENTS<3> SETTING LOC THEN TRN.FLD = COMPONENTS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(20,LN):TRN.FLD "L#25":
RETURN
*
TC02: *
PRINT @(20,LN):SPACE(25):
RETURN
*
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.SERVICE.CHANNELS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("PAR","3",PAR,10,11,"L50","50",3,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,10,11,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("PAR","4",PAR,10,17,"L50","50",4,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,10,17,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
IDE.C: *
READV SVC.DESC FROM SVC.FILE,PAR.ID.SAVE<1>,ONE THEN PRINT @(20,3):SVC.DESC "L#25": ELSE NULL
RETURN
*
!
*
END
~SH.MAINT.SERVICE.TIERS~
*PROGRAM:           SH.MAINT.SERVICE.TIERS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:52:08
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "MAINT.SERVICE.TIERS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.SERVICE.TIERS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "SVC" TO SVC.FILE ELSE FILE.NAME = "SVC"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.SERVICE.TIERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
SVC.ID = EMPTY; SVC.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SC"
TDC(1) = 16
TDT(1) = 5
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                         Service Components Maintenance                         ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"Component":RVE:"   ":RVB:"Description":RVE:"                 ":RVB:"Channel number(s)":RVE:"   ":RVB:"Parental control":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 1; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
PAR.ID = "COMPONENTS"
PAR.ID.SAVE<ONE> = "COMPONENTS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.SERVICE.TIERS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.SERVICE.TIERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PAR","1",FLD,18,23,"L6","6","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,18,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PAR<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 4
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 4
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PAR<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PAR<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PAR<1,VC>
INS EMPTY BEFORE PAR<2,VC>
INS EMPTY BEFORE PAR<3,VC>
INS EMPTY BEFORE PAR<4,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PAR<1,VC>
DEL PAR<2,VC>
DEL PAR<3,VC>
DEL PAR<4,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("PAR","1",PAR,0,LN,"L6","6",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("PAR","2",PAR,12,LN,"L25","25",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,12,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("PAR","3",PAR,40,LN,"L17","17",3:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,40,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("PAR","4",PAR,60,LN,"L16","16",4:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,60,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PAR<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PAR<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
PRINT @(12,LN):PAR<2,VC> "L#25":
PRINT @(40,LN):PAR<3,VC> "L#17":
PRINT @(60,LN):PAR<4,VC> "L#16":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(6):
PRINT @(12,LN.TMP):SPACE(25):
PRINT @(40,LN.TMP):SPACE(17):
PRINT @(60,LN.TMP):SPACE(16):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.SUPPLIERS~
*PROGRAM:           SH.MAINT.SUPPLIERS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:53:45
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "SVCS"
SYS.PROG = "MAINT.SUPPLIERS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.SUPPLIERS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SU"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.SUPPLIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SU"
TDC(1) = 14
TDT(1) = 5
READ COMPONENTS FROM COM.FILE,"COMPONENTS" ELSE COMPONENTS = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                       Component Programmers Maintenance                        ":RVE:"":
PRINT @(0,3):CLS:"":RVB:"Programmer":RVE:"  ":RVB:"Component":RVE:" ":RVB:"Programmer                    ":RVE:"  ":RVB:"Component                ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"  Code  ":RVE:"    ":RVB:"  Name   ":RVE:" ":RVB:"Description                   ":RVE:"  ":RVB:"Description              ":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 1; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
COM.ID = "SUPPLIERS"
COM.ID.SAVE<ONE> = "SUPPLIERS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.SUPPLIERS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.SUPPLIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("COM","1",FLD,27,23,"L8","8","1","","SE":VM:"OP":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,27,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(COM<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN COM<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = COM<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE COM<1,VC>
INS EMPTY BEFORE COM<3,VC>
INS EMPTY BEFORE COM<2,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL COM<1,VC>
DEL COM<3,VC>
DEL COM<2,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("COM","1",COM,1,LN,"L8","8",1:",":VC,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,1,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("COM","3",COM,12,LN,"L8","8",3:",":VC,"","OP":VM:"EQ":SVM:"@":COMPONENTS<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,12,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
IF STAT THEN RETURN ELSE GOSUB T01
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("COM","2",COM,22,LN,"L30","30",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,22,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(COM<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(1,LN):COM<1,VC> "L#8":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND COM<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(1,LN):COM<1,VC> "L#8":
PRINT @(12,LN):COM<3,VC> "L#8":; GOSUB T01
PRINT @(22,LN):COM<2,VC> "L#30":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(1,LN.TMP):SPACE(8):
PRINT @(12,LN.TMP):SPACE(8):; GOSUB TC01
PRINT @(22,LN.TMP):SPACE(30):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
T01: *
*
TRN.FLD = COM<3,VC>
LOCATE TRN.FLD IN COMPONENTS<ONE> SETTING LOC THEN TRN.FLD = COMPONENTS<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(54,LN):TRN.FLD "L#25":
RETURN
*
TC01: *
PRINT @(54,LN):SPACE(25):
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.MAINT.TIERS~
*PROGRAM:           SH.MAINT.TIERS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 (1.0)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:55:25
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
INPUT DISP.ONLY:
AUTO.RUN = 0
INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "KBIL"
SYS.APPL.SUB = "AI"
SYS.PROG = "MAINT.TIERS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.TIERS"
*ID.END*
*
SYS.PROG.TYPE = "PROG"
RELEASE.ID = "1.0"
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "CLO":AM:"CHI"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.TIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
PORT.KEY = PORT
LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
READ GENERIC FROM COM.FILE,"GENERIC" ELSE
IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
END
END
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
COM.ID = EMPTY; COM.ID.SAVE = EMPTY
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = EMPTY
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND COM.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN COM.ID.SAVE = EMPTY
END ELSE
COM.ID = EMPTY; COM.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF COM.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
*SUB.RTN*
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ COM FROM COM.FILE,COM.ID THEN NEW = FALSE ELSE NEW = TRUE; COM = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("COM",COM.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 2
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 2
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter screen ref., DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE COM.FILE,COM.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE COM ON COM.FILE,COM.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
*SUB.RTN*
END
END ELSE
IF STAT EQ 999 THEN STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                       AI Tier to Channel Cross-reference                       ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"                  Tier   ":RVE:"":
PRINT @(0,6):CLS:"          ":RVB:"       Channel / Tag Number Cross Reference       ":RVE:"":
PRINT @(0,11):CLS:"          ":RVB:"                 Channels 1 to 50                 ":RVE:"":
PRINT @(0,12):CLS:"          ":RVB:"         1         2         3         4         5":RVE:"":
PRINT @(0,13):CLS:"          ":RVB:"12345678901234567890123456789012345678901234567890":RVE:"":
PRINT @(0,16):CLS:"          ":RVB:"                Channels 51 to 100                ":RVE:"":
PRINT @(0,17):CLS:"          ":RVB:"                                                 1":RVE:"":
PRINT @(0,18):CLS:"          ":RVB:"5        6         7         8         9         0":RVE:"":
PRINT @(0,19):CLS:"          ":RVB:"12345678901234567890123456789012345678901234567890":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = COM.ID
FOR ID.CN = ONE TO 4; COM.ID.SAVE<ID.CN> = "!":COM.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
COM.ID = TEMP
END
*
*
!
*
PRINT @(10,14):COM<1> "L#50":
*
!
*
PRINT @(10,20):COM<2> "L#50":
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 4
ON ID.CN GOSUB K01,K02,K03,K04
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 2 AND COM.ID.SAVE<2> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*
COM.ID = EMPTY
COM.ID = COM.ID:COM.ID.SAVE<1>
COM.ID = COM.ID:COM.ID.SAVE<2>
COM.ID = COM.ID:COM.ID.SAVE<3>
COM.ID = COM.ID:COM.ID.SAVE<4>
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.TIERS +Itm:":COM.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
K01: *
STAT = ZERO
RSP = "AI.TIER."
FLD = RSP
COM.ID.SAVE<1> = "AI.TIER."
RETURN
*
K02: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<2>
CALL INPUT.DATA.SG1("","ID",FLD,27,3,"L8","8",1,"","OP":VM:"EQ":SVM:"@":AI.TYPES<ONE>:"@","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,27,3,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
LN = 3; GOSUB T01
COM.ID.SAVE<2> = RSP
RETURN
*
T01: *
*
TRN.FLD = RSP
LOCATE TRN.FLD IN AI.TYPES<ONE> SETTING LOC THEN TRN.FLD = AI.TYPES<TWO,LOC> ELSE TRN.FLD = EMPTY
PRINT @(40,LN):TRN.FLD "L#30":
RETURN
*
TC01: *
PRINT @(40,LN):SPACE(30):
RETURN
*
*
K03: *
STAT = ZERO
RSP = "*"
FLD = RSP
COM.ID.SAVE<3> = "*"
RETURN
*
K04: *
IF STAT LT ZERO THEN RETURN
FLD = COM.ID.SAVE<4>
CALL INPUT.DATA.SG1("","ID",FLD,27,4,"L5","5",1,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,"1",1,"0",TC.FUNC,27,4,".",STD.SUBR.NAME,PROCBUF,STAT)
IF STAT THEN RETURN
COM.ID.SAVE<4> = RSP
RETURN
*
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.TIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01,I02
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
I01: *
CALL INPUT.DATA.SG1("COM","1",COM,10,14,"L50","50",1,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,10,14,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01
RETURN
I02: *
CALL INPUT.DATA.SG1("COM","2",COM,10,20,"L50","50",2,"","OP","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,10,20,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I02
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.CH.ERRORS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.CH.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                Addressable Interface Channel Status Maintenance" "L#80"
PRINT 
PRINT "AI Code" "L#7":SPACE(2):COM.ID.SAVE<2> "L#4"
PRINT SPACE(55):"         T" "L#10"
PRINT SPACE(55):"T  D M   r Min's." "L#17"
PRINT SPACE(55):"y  i n L i Pause. .Var." "L#23"
PRINT SPACE(10):"Command" "L#7":SPACE(38):"p  s g o e before .to.." "L#23"
PRINT SPACE(10):"Std A/I" "L#7":SPACE(3):"Description" "L#25":SPACE(5):"Func" "L#4":SPACE(1):"e  p r g s Retry. .Set." "L#23"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":COM<1,TDL(1) + 0> "L#3":SPACE(1):COM<2,TDL(1) + 0> "L#3":SPACE(3):COM<3,TDL(1) + 0> "L#25":SPACE(5):COM<4,TDL(1) + 0> "L#3":SPACE(2):COM<5,TDL(1) + 0> "L#2":SPACE(1):COM<6,TDL(1) + 0> "L#1":SPACE(1):COM<7,TDL(1) + 0> "L#1":SPACE(1):COM<8,TDL(1) + 0> "L#1":SPACE(1):COM<9,TDL(1) + 0> "L#1":SPACE(2):COM<10,TDL(1) + 0> "L#4":SPACE(2):COM<11,TDL(1) + 0> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":COM<1,TDL(1) + 1> "L#3":SPACE(1):COM<2,TDL(1) + 1> "L#3":SPACE(3):COM<3,TDL(1) + 1> "L#25":SPACE(5):COM<4,TDL(1) + 1> "L#3":SPACE(2):COM<5,TDL(1) + 1> "L#2":SPACE(1):COM<6,TDL(1) + 1> "L#1":SPACE(1):COM<7,TDL(1) + 1> "L#1":SPACE(1):COM<8,TDL(1) + 1> "L#1":SPACE(1):COM<9,TDL(1) + 1> "L#1":SPACE(2):COM<10,TDL(1) + 1> "L#4":SPACE(2):COM<11,TDL(1) + 1> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":COM<1,TDL(1) + 2> "L#3":SPACE(1):COM<2,TDL(1) + 2> "L#3":SPACE(3):COM<3,TDL(1) + 2> "L#25":SPACE(5):COM<4,TDL(1) + 2> "L#3":SPACE(2):COM<5,TDL(1) + 2> "L#2":SPACE(1):COM<6,TDL(1) + 2> "L#1":SPACE(1):COM<7,TDL(1) + 2> "L#1":SPACE(1):COM<8,TDL(1) + 2> "L#1":SPACE(1):COM<9,TDL(1) + 2> "L#1":SPACE(2):COM<10,TDL(1) + 2> "L#4":SPACE(2):COM<11,TDL(1) + 2> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":COM<1,TDL(1) + 3> "L#3":SPACE(1):COM<2,TDL(1) + 3> "L#3":SPACE(3):COM<3,TDL(1) + 3> "L#25":SPACE(5):COM<4,TDL(1) + 3> "L#3":SPACE(2):COM<5,TDL(1) + 3> "L#2":SPACE(1):COM<6,TDL(1) + 3> "L#1":SPACE(1):COM<7,TDL(1) + 3> "L#1":SPACE(1):COM<8,TDL(1) + 3> "L#1":SPACE(1):COM<9,TDL(1) + 3> "L#1":SPACE(2):COM<10,TDL(1) + 3> "L#4":SPACE(2):COM<11,TDL(1) + 3> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":COM<1,TDL(1) + 4> "L#3":SPACE(1):COM<2,TDL(1) + 4> "L#3":SPACE(3):COM<3,TDL(1) + 4> "L#25":SPACE(5):COM<4,TDL(1) + 4> "L#3":SPACE(2):COM<5,TDL(1) + 4> "L#2":SPACE(1):COM<6,TDL(1) + 4> "L#1":SPACE(1):COM<7,TDL(1) + 4> "L#1":SPACE(1):COM<8,TDL(1) + 4> "L#1":SPACE(1):COM<9,TDL(1) + 4> "L#1":SPACE(2):COM<10,TDL(1) + 4> "L#4":SPACE(2):COM<11,TDL(1) + 4> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":COM<1,TDL(1) + 5> "L#3":SPACE(1):COM<2,TDL(1) + 5> "L#3":SPACE(3):COM<3,TDL(1) + 5> "L#25":SPACE(5):COM<4,TDL(1) + 5> "L#3":SPACE(2):COM<5,TDL(1) + 5> "L#2":SPACE(1):COM<6,TDL(1) + 5> "L#1":SPACE(1):COM<7,TDL(1) + 5> "L#1":SPACE(1):COM<8,TDL(1) + 5> "L#1":SPACE(1):COM<9,TDL(1) + 5> "L#1":SPACE(2):COM<10,TDL(1) + 5> "L#4":SPACE(2):COM<11,TDL(1) + 5> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":COM<1,TDL(1) + 6> "L#3":SPACE(1):COM<2,TDL(1) + 6> "L#3":SPACE(3):COM<3,TDL(1) + 6> "L#25":SPACE(5):COM<4,TDL(1) + 6> "L#3":SPACE(2):COM<5,TDL(1) + 6> "L#2":SPACE(1):COM<6,TDL(1) + 6> "L#1":SPACE(1):COM<7,TDL(1) + 6> "L#1":SPACE(1):COM<8,TDL(1) + 6> "L#1":SPACE(1):COM<9,TDL(1) + 6> "L#1":SPACE(2):COM<10,TDL(1) + 6> "L#4":SPACE(2):COM<11,TDL(1) + 6> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":COM<1,TDL(1) + 7> "L#3":SPACE(1):COM<2,TDL(1) + 7> "L#3":SPACE(3):COM<3,TDL(1) + 7> "L#25":SPACE(5):COM<4,TDL(1) + 7> "L#3":SPACE(2):COM<5,TDL(1) + 7> "L#2":SPACE(1):COM<6,TDL(1) + 7> "L#1":SPACE(1):COM<7,TDL(1) + 7> "L#1":SPACE(1):COM<8,TDL(1) + 7> "L#1":SPACE(1):COM<9,TDL(1) + 7> "L#1":SPACE(2):COM<10,TDL(1) + 7> "L#4":SPACE(2):COM<11,TDL(1) + 7> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":COM<1,TDL(1) + 8> "L#3":SPACE(1):COM<2,TDL(1) + 8> "L#3":SPACE(3):COM<3,TDL(1) + 8> "L#25":SPACE(5):COM<4,TDL(1) + 8> "L#3":SPACE(2):COM<5,TDL(1) + 8> "L#2":SPACE(1):COM<6,TDL(1) + 8> "L#1":SPACE(1):COM<7,TDL(1) + 8> "L#1":SPACE(1):COM<8,TDL(1) + 8> "L#1":SPACE(1):COM<9,TDL(1) + 8> "L#1":SPACE(2):COM<10,TDL(1) + 8> "L#4":SPACE(2):COM<11,TDL(1) + 8> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":COM<1,TDL(1) + 9> "L#3":SPACE(1):COM<2,TDL(1) + 9> "L#3":SPACE(3):COM<3,TDL(1) + 9> "L#25":SPACE(5):COM<4,TDL(1) + 9> "L#3":SPACE(2):COM<5,TDL(1) + 9> "L#2":SPACE(1):COM<6,TDL(1) + 9> "L#1":SPACE(1):COM<7,TDL(1) + 9> "L#1":SPACE(1):COM<8,TDL(1) + 9> "L#1":SPACE(1):COM<9,TDL(1) + 9> "L#1":SPACE(2):COM<10,TDL(1) + 9> "L#4":SPACE(2):COM<11,TDL(1) + 9> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":COM<1,TDL(1) + 10> "L#3":SPACE(1):COM<2,TDL(1) + 10> "L#3":SPACE(3):COM<3,TDL(1) + 10> "L#25":SPACE(5):COM<4,TDL(1) + 10> "L#3":SPACE(2):COM<5,TDL(1) + 10> "L#2":SPACE(1):COM<6,TDL(1) + 10> "L#1":SPACE(1):COM<7,TDL(1) + 10> "L#1":SPACE(1):COM<8,TDL(1) + 10> "L#1":SPACE(1):COM<9,TDL(1) + 10> "L#1":SPACE(2):COM<10,TDL(1) + 10> "L#4":SPACE(2):COM<11,TDL(1) + 10> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":COM<1,TDL(1) + 11> "L#3":SPACE(1):COM<2,TDL(1) + 11> "L#3":SPACE(3):COM<3,TDL(1) + 11> "L#25":SPACE(5):COM<4,TDL(1) + 11> "L#3":SPACE(2):COM<5,TDL(1) + 11> "L#2":SPACE(1):COM<6,TDL(1) + 11> "L#1":SPACE(1):COM<7,TDL(1) + 11> "L#1":SPACE(1):COM<8,TDL(1) + 11> "L#1":SPACE(1):COM<9,TDL(1) + 11> "L#1":SPACE(2):COM<10,TDL(1) + 11> "L#4":SPACE(2):COM<11,TDL(1) + 11> "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":COM<1,TDL(1) + 12> "L#3":SPACE(1):COM<2,TDL(1) + 12> "L#3":SPACE(3):COM<3,TDL(1) + 12> "L#25":SPACE(5):COM<4,TDL(1) + 12> "L#3":SPACE(2):COM<5,TDL(1) + 12> "L#2":SPACE(1):COM<6,TDL(1) + 12> "L#1":SPACE(1):COM<7,TDL(1) + 12> "L#1":SPACE(1):COM<8,TDL(1) + 12> "L#1":SPACE(1):COM<9,TDL(1) + 12> "L#1":SPACE(2):COM<10,TDL(1) + 12> "L#4":SPACE(2):COM<11,TDL(1) + 12> "L#5"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.CHANNELS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                        Channels by AI Code Maintenance" "L#80"
PRINT 
PRINT 
PRINT "  AI Code" "L#10":SPACE(2):COM.ID.SAVE<2> "L#4"
PRINT 
PRINT "Service" "L#9":SPACE(1):"Chan" "L#4":SPACE(1):"Component" "L#25":SPACE(2):"Prog/Distr" "L#11"
PRINT "  Name" "L#9":SPACE(1):" ###" "L#4"
PRINT COM<1,TDL(1) + 0> "L#8":SPACE(3):COM<3,TDL(1) + 0> "L#3"
PRINT COM<1,TDL(1) + 1> "L#8":SPACE(3):COM<3,TDL(1) + 1> "L#3"
PRINT COM<1,TDL(1) + 2> "L#8":SPACE(3):COM<3,TDL(1) + 2> "L#3"
PRINT COM<1,TDL(1) + 3> "L#8":SPACE(3):COM<3,TDL(1) + 3> "L#3"
PRINT COM<1,TDL(1) + 4> "L#8":SPACE(3):COM<3,TDL(1) + 4> "L#3"
PRINT COM<1,TDL(1) + 5> "L#8":SPACE(3):COM<3,TDL(1) + 5> "L#3"
PRINT COM<1,TDL(1) + 6> "L#8":SPACE(3):COM<3,TDL(1) + 6> "L#3"
PRINT COM<1,TDL(1) + 7> "L#8":SPACE(3):COM<3,TDL(1) + 7> "L#3"
PRINT COM<1,TDL(1) + 8> "L#8":SPACE(3):COM<3,TDL(1) + 8> "L#3"
PRINT COM<1,TDL(1) + 9> "L#8":SPACE(3):COM<3,TDL(1) + 9> "L#3"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.CMD.CNTRL~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.CMD.CNTRL(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIICMD.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIICMD.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                  Addressable Interfacer Commands Maintenance" "L#80"
PRINT 
PRINT "Intfc. Code" "L#11":SPACE(4):COM.AIICMD.ID.SAVE<2> "L#4":SPACE(34):"# of" "L#5":SPACE(2):"Resp" "L#5":SPACE(2):" Cmd" "L#5"
PRINT SPACE(7):"l#" "L#2":SPACE(1):"Command" "L#7":SPACE(3):"Description" "L#30":SPACE(3):"Tries" "L#5":SPACE(2):"Pause" "L#5":SPACE(2):"Logs" "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 0> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 0> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 0> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 0> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 0> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 1> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 1> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 1> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 1> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 1> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 2> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 2> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 2> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 2> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 2> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 3> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 3> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 3> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 3> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 3> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 4> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 4> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 4> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 4> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 4> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 5> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 5> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 5> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 5> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 5> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 6> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 6> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 6> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 6> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 6> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 7> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 7> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 7> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 7> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 7> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 8> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 8> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 8> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 8> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 8> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 9> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 9> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 9> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 9> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 9> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 10> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 10> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 10> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 10> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 10> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 11> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 11> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 11> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 11> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 11> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 12> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 12> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 12> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 12> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 12> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 13)):TDL(1) + 13:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 13> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 13> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 13> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 13> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 13> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 14)):TDL(1) + 14:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 14> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 14> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 14> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 14> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 14> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 15)):TDL(1) + 15:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 15> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 15> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 15> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 15> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 15> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 16)):TDL(1) + 16:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 16> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 16> "L#30":SPACE(5):COM.AIICMD$RETRY<ONE,TDL(1) + 16> "L#1":SPACE(5):COM.AIICMD$PAUSE<ONE,TDL(1) + 16> "L#3":SPACE(5):COM.AIICMD$LOG<ONE,TDL(1) + 16> "L#1"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.COMMANDS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.COMMANDS(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIICMD.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIICMD.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                  Addressable Interfacer Commands Maintenance" "L#80"
PRINT 
PRINT "Intfc. Code" "L#11":SPACE(4):COM.AIICMD.ID.SAVE<2> "L#4":SPACE(34):" Cmd" "L#5":SPACE(2):" Box" "L#5":SPACE(2):" Box" "L#5"
PRINT SPACE(7):"l#" "L#2":SPACE(1):"Command" "L#7":SPACE(3):"Description" "L#30":SPACE(3):"Actv?" "L#5":SPACE(2):"Sel.?" "L#5":SPACE(2):"Cmd.?" "L#5"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 0> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 0> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 0> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 0> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 0> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 1> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 1> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 1> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 1> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 1> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 2> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 2> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 2> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 2> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 2> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 3> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 3> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 3> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 3> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 3> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 4> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 4> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 4> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 4> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 4> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 5> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 5> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 5> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 5> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 5> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 6> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 6> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 6> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 6> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 6> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 7> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 7> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 7> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 7> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 7> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 8> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 8> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 8> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 8> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 8> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 9> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 9> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 9> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 9> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 9> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 10> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 10> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 10> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 10> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 10> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 11> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 11> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 11> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 11> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 11> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 12> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 12> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 12> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 12> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 12> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 13)):TDL(1) + 13:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 13> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 13> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 13> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 13> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 13> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 14)):TDL(1) + 14:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 14> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 14> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 14> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 14> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 14> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 15)):TDL(1) + 15:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 15> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 15> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 15> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 15> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 15> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 16)):TDL(1) + 16:" ":COM.AIICMD$RCVD<ONE,TDL(1) + 16> "L#4":SPACE(6):COM.AIICMD$DESC<ONE,TDL(1) + 16> "L#30":SPACE(5):COM.AIICMD$CMD.ACTV<ONE,TDL(1) + 16> "L#1":SPACE(6):COM.AIICMD$BOX.SEL<ONE,TDL(1) + 16> "L#1":SPACE(6):COM.AIICMD$BOX.CMD<ONE,TDL(1) + 16> "L#1"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.CYPHER.KEYS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.CYPHER.KEYS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "AK"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                             Cypher Key Maintenance" "L#80"
PRINT 
PRINT 
PRINT 
PRINT 
PRINT 
PRINT SPACE(30):"    Active keys: (0-31)" "L#23"
PRINT 
PRINT SPACE(37):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":PAR<1,TDL(1) + 0> "L#2"
PRINT SPACE(37):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":PAR<1,TDL(1) + 1> "L#2"
PRINT SPACE(37):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":PAR<1,TDL(1) + 2> "L#2"
PRINT SPACE(37):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":PAR<1,TDL(1) + 3> "L#2"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.ERRORS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.ERRORS(TDL.REC,XYZ.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
0
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.HERRORS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.HERRORS(TDL.REC,COM.AIHERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIHERR.ID,MAT COM.AIHERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIHERR.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIHERR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                Addressable Interface Handler Errors Maintenance" "L#80"
PRINT 
PRINT SPACE(58):"      T" "L#7"
PRINT SPACE(58):"D M   r Sec's." "L#14"
PRINT SPACE(58):"i n L i Pause. .Var." "L#20"
PRINT SPACE(58):"s g o e before .to.." "L#20"
PRINT "l#" "L#2":SPACE(2):"Error #" "L#7":SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":COM.AIHERR$STD<ONE,TDL(1) + 0> "L#3":COM.AIHERR$DESC<ONE,TDL(1) + 0> "L#35":COM.AIHERR$FUNC<ONE,TDL(1) + 0> "L#4":COM.AIHERR$TYPE<ONE,TDL(1) + 0> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 0> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 0> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":COM.AIHERR$STD<ONE,TDL(1) + 1> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 1> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 1> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 1> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 1> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 1> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":COM.AIHERR$STD<ONE,TDL(1) + 2> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 2> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 2> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 2> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 2> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 2> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":COM.AIHERR$STD<ONE,TDL(1) + 3> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 3> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 3> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 3> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 3> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 3> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":COM.AIHERR$STD<ONE,TDL(1) + 4> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 4> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 4> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 4> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 4> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 4> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":COM.AIHERR$STD<ONE,TDL(1) + 5> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 5> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 5> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 5> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 5> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 5> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":COM.AIHERR$STD<ONE,TDL(1) + 6> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 6> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 6> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 6> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 6> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 6> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":COM.AIHERR$STD<ONE,TDL(1) + 7> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 7> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 7> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 7> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 7> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 7> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":COM.AIHERR$STD<ONE,TDL(1) + 8> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 8> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 8> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 8> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 8> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 8> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":COM.AIHERR$STD<ONE,TDL(1) + 9> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 9> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 9> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 9> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 9> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 9> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":COM.AIHERR$STD<ONE,TDL(1) + 10> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 10> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 10> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 10> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 10> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 10> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":COM.AIHERR$STD<ONE,TDL(1) + 11> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 11> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 11> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 11> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 11> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 11> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":COM.AIHERR$STD<ONE,TDL(1) + 12> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 12> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 12> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 12> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 12> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 12> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 13)):TDL(1) + 13:" ":COM.AIHERR$STD<ONE,TDL(1) + 13> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 13> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 13> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 13> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 13> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 13> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 13> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 13> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 13> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 13> "L#5"
PRINT SPACE(6):SPACE(TWO - LEN(TDL(1) + 14)):TDL(1) + 14:" ":COM.AIHERR$STD<ONE,TDL(1) + 14> "L#3":SPACE(3):COM.AIHERR$DESC<ONE,TDL(1) + 14> "L#35":SPACE(1):COM.AIHERR$FUNC<ONE,TDL(1) + 14> "L#4":SPACE(1):COM.AIHERR$TYPE<ONE,TDL(1) + 14> "L#4":SPACE(1):COM.AIHERR$DISP<ONE,TDL(1) + 14> "L#1":SPACE(1):COM.AIHERR$MNGR<ONE,TDL(1) + 14> "L#1":SPACE(1):COM.AIHERR$LOG<ONE,TDL(1) + 14> "L#1":SPACE(1):COM.AIHERR$RETRY<ONE,TDL(1) + 14> "L#1":SPACE(1):COM.AIHERR$PAUSE<ONE,TDL(1) + 14> "L#4":SPACE(3):COM.AIHERR$VAR<ONE,TDL(1) + 14> "L#5"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.IERRORS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.IERRORS(TDL.REC,COM.AIIERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIIERR.ID,MAT COM.AIIERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIIERR.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIIERR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                    Addressable Interface Errors Maintenance" "L#80"
PRINT 
PRINT "Intfc Code" "L#10":SPACE(2):COM.AIIERR.ID.SAVE<2> "L#4"
PRINT SPACE(49):"      T" "L#7"
PRINT SPACE(49):"D M   r Sec's." "L#14"
PRINT SPACE(49):"i n L i Pause." "L#14"
PRINT SPACE(10):"Command" "L#7":SPACE(32):"s g o e before" "L#14"
PRINT SPACE(10):"Std A/I" "L#7":SPACE(1):"Description" "L#25":SPACE(1):"Type" "L#4":SPACE(1):"p r g s Retry." "L#14"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":COM.AIIERR$STD<ONE,TDL(1) + 0> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 0> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 0> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 0> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 0> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 0> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":COM.AIIERR$STD<ONE,TDL(1) + 1> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 1> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 1> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 1> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 1> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 1> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":COM.AIIERR$STD<ONE,TDL(1) + 2> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 2> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 2> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 2> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 2> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 2> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":COM.AIIERR$STD<ONE,TDL(1) + 3> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 3> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 3> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 3> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 3> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 3> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":COM.AIIERR$STD<ONE,TDL(1) + 4> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 4> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 4> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 4> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 4> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 4> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":COM.AIIERR$STD<ONE,TDL(1) + 5> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 5> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 5> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 5> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 5> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 5> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":COM.AIIERR$STD<ONE,TDL(1) + 6> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 6> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 6> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 6> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 6> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 6> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":COM.AIIERR$STD<ONE,TDL(1) + 7> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 7> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 7> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 7> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 7> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 7> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":COM.AIIERR$STD<ONE,TDL(1) + 8> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 8> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 8> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 8> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 8> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 8> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":COM.AIIERR$STD<ONE,TDL(1) + 9> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 9> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 9> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 9> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 9> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 9> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":COM.AIIERR$STD<ONE,TDL(1) + 10> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 10> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 10> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 10> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 10> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 10> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":COM.AIIERR$STD<ONE,TDL(1) + 11> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 11> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 11> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 11> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 11> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 11> "L#6"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":COM.AIIERR$STD<ONE,TDL(1) + 12> "L#3":SPACE(1):COM.AIIERR$RCVD<ONE,TDL(1) + 12> "L#3":SPACE(1):COM.AIIERR$DESC<ONE,TDL(1) + 12> "L#25":SPACE(1):COM.AIIERR$TYPE<ONE,TDL(1) + 12> "L#4":SPACE(1):COM.AIIERR$DISP<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIIERR$MNGR<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIIERR$LOG<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIIERR$RETRY<ONE,TDL(1) + 12> "L#1":SPACE(1):COM.AIIERR$PAUSE<ONE,TDL(1) + 12> "L#6"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.MISC~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.MISC(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(4); MAT TDL = EMPTY
DIM TDH(4); MAT TDH = EMPTY
DIM TDI(4); MAT TDI = EMPTY
DIM TDX(4); MAT TDX = ONE
DIM SAVE.TDX(4); MAT SAVE.TDX = EMPTY
DIM TDM(4); MAT TDM = EMPTY
DIM TDS(4); MAT TDS = EMPTY
DIM TDR(4); MAT TDR = EMPTY
DIM TDC(4); MAT TDC = EMPTY
DIM TDT(4); MAT TDT = EMPTY
VALID.REFS = "TY":AM:"SY":AM:"GR":AM:"BX"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "           Miscellaneous Addressable Interface Parameters Maintenance" "L#80"
PRINT 
PRINT "TY> Type of equipment" "L#30":SPACE(2):PAR<1> "L#8"
PRINT 
PRINT "    Starting system address" "L#30"
PRINT "SY>      system id" "L#30":SPACE(2):PAR<2,1> "L#4"
PRINT "GR>      group number" "L#30":SPACE(2):PAR<2,2> "L#4"
PRINT "BX>      box number" "L#30":SPACE(2):PAR<2,3> "L#4"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.PORT~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.PORT(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(4); MAT TDL = EMPTY
DIM TDH(4); MAT TDH = EMPTY
DIM TDI(4); MAT TDI = EMPTY
DIM TDX(4); MAT TDX = ONE
DIM SAVE.TDX(4); MAT SAVE.TDX = EMPTY
DIM TDM(4); MAT TDM = EMPTY
DIM TDS(4); MAT TDS = EMPTY
DIM TDR(4); MAT TDR = EMPTY
DIM TDC(4); MAT TDC = EMPTY
DIM TDT(4); MAT TDT = EMPTY
VALID.REFS = "NA":AM:"IT":AM:"CP":AM:"MP"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                     Maintain Handler Head End Information" "L#80"
PRINT 
PRINT "Head End" "L#10":SPACE(2):COM.SAVE<2> "L#2"
PRINT "NA> Head End Name" "L#20":SPACE(2):COM<4> "L#25"
PRINT 
PRINT "IT> Interface Type" "L#20":SPACE(2):COM<1> "L#2"
PRINT "CP> Control Port" "L#20":SPACE(2):COM<2> "L#3"
PRINT "MP> Monitor Port" "L#20":SPACE(2):COM<3> "L#3"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.PROMPTS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.PROMPTS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                   Addressable Interface Prompts Maintenance" "L#80"
PRINT 
PRINT "Interface Type" "L#15":SPACE(2):COM.ID.SAVE<2> "L#2"
PRINT "Ln" "L#2":SPACE(1):"Description" "L#70"
PRINT 
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":COM<TDL(1) + 0> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":COM<TDL(1) + 1> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":COM<TDL(1) + 2> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":COM<TDL(1) + 3> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":COM<TDL(1) + 4> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":COM<TDL(1) + 5> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":COM<TDL(1) + 6> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":COM<TDL(1) + 7> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":COM<TDL(1) + 8> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":COM<TDL(1) + 9> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":COM<TDL(1) + 10> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":COM<TDL(1) + 11> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":COM<TDL(1) + 12> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 13)):TDL(1) + 13:" ":COM<TDL(1) + 13> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 14)):TDL(1) + 14:" ":COM<TDL(1) + 14> "L#75"
PRINT SPACE(3):SPACE(TWO - LEN(TDL(1) + 15)):TDL(1) + 15:" ":COM<TDL(1) + 15> "L#75"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.SYS.ERRORS~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.SYS.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                Addressable Interface System Errors Maintenance" "L#80"
PRINT 
PRINT "System Type" "L#15":SPACE(2):COM.ID.SAVE<2> "L#2"
PRINT SPACE(10):"Command" "L#7":SPACE(3):"Description" "L#25":SPACE(5):"Func" "L#4":SPACE(1):"Type" "L#4":SPACE(1):"Disp" "L#4":SPACE(1):"Mngr" "L#4"
PRINT 
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":COM<1,TDL(1) + 0> "L#4":SPACE(6):COM<2,TDL(1) + 0> "L#25":SPACE(5):COM<3,TDL(1) + 0> "L#3":SPACE(2):COM<4,TDL(1) + 0> "L#4":SPACE(1):COM<5,TDL(1) + 0> "L#1":SPACE(4):COM<6,TDL(1) + 0> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":COM<1,TDL(1) + 1> "L#4":SPACE(6):COM<2,TDL(1) + 1> "L#25":SPACE(5):COM<3,TDL(1) + 1> "L#3":SPACE(2):COM<4,TDL(1) + 1> "L#4":SPACE(1):COM<5,TDL(1) + 1> "L#1":SPACE(4):COM<6,TDL(1) + 1> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":COM<1,TDL(1) + 2> "L#4":SPACE(6):COM<2,TDL(1) + 2> "L#25":SPACE(5):COM<3,TDL(1) + 2> "L#3":SPACE(2):COM<4,TDL(1) + 2> "L#4":SPACE(1):COM<5,TDL(1) + 2> "L#1":SPACE(4):COM<6,TDL(1) + 2> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":COM<1,TDL(1) + 3> "L#4":SPACE(6):COM<2,TDL(1) + 3> "L#25":SPACE(5):COM<3,TDL(1) + 3> "L#3":SPACE(2):COM<4,TDL(1) + 3> "L#4":SPACE(1):COM<5,TDL(1) + 3> "L#1":SPACE(4):COM<6,TDL(1) + 3> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":COM<1,TDL(1) + 4> "L#4":SPACE(6):COM<2,TDL(1) + 4> "L#25":SPACE(5):COM<3,TDL(1) + 4> "L#3":SPACE(2):COM<4,TDL(1) + 4> "L#4":SPACE(1):COM<5,TDL(1) + 4> "L#1":SPACE(4):COM<6,TDL(1) + 4> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":COM<1,TDL(1) + 5> "L#4":SPACE(6):COM<2,TDL(1) + 5> "L#25":SPACE(5):COM<3,TDL(1) + 5> "L#3":SPACE(2):COM<4,TDL(1) + 5> "L#4":SPACE(1):COM<5,TDL(1) + 5> "L#1":SPACE(4):COM<6,TDL(1) + 5> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":COM<1,TDL(1) + 6> "L#4":SPACE(6):COM<2,TDL(1) + 6> "L#25":SPACE(5):COM<3,TDL(1) + 6> "L#3":SPACE(2):COM<4,TDL(1) + 6> "L#4":SPACE(1):COM<5,TDL(1) + 6> "L#1":SPACE(4):COM<6,TDL(1) + 6> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":COM<1,TDL(1) + 7> "L#4":SPACE(6):COM<2,TDL(1) + 7> "L#25":SPACE(5):COM<3,TDL(1) + 7> "L#3":SPACE(2):COM<4,TDL(1) + 7> "L#4":SPACE(1):COM<5,TDL(1) + 7> "L#1":SPACE(4):COM<6,TDL(1) + 7> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":COM<1,TDL(1) + 8> "L#4":SPACE(6):COM<2,TDL(1) + 8> "L#25":SPACE(5):COM<3,TDL(1) + 8> "L#3":SPACE(2):COM<4,TDL(1) + 8> "L#4":SPACE(1):COM<5,TDL(1) + 8> "L#1":SPACE(4):COM<6,TDL(1) + 8> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":COM<1,TDL(1) + 9> "L#4":SPACE(6):COM<2,TDL(1) + 9> "L#25":SPACE(5):COM<3,TDL(1) + 9> "L#3":SPACE(2):COM<4,TDL(1) + 9> "L#4":SPACE(1):COM<5,TDL(1) + 9> "L#1":SPACE(4):COM<6,TDL(1) + 9> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":COM<1,TDL(1) + 10> "L#4":SPACE(6):COM<2,TDL(1) + 10> "L#25":SPACE(5):COM<3,TDL(1) + 10> "L#3":SPACE(2):COM<4,TDL(1) + 10> "L#4":SPACE(1):COM<5,TDL(1) + 10> "L#1":SPACE(4):COM<6,TDL(1) + 10> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":COM<1,TDL(1) + 11> "L#4":SPACE(6):COM<2,TDL(1) + 11> "L#25":SPACE(5):COM<3,TDL(1) + 11> "L#3":SPACE(2):COM<4,TDL(1) + 11> "L#4":SPACE(1):COM<5,TDL(1) + 11> "L#1":SPACE(4):COM<6,TDL(1) + 11> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":COM<1,TDL(1) + 12> "L#4":SPACE(6):COM<2,TDL(1) + 12> "L#25":SPACE(5):COM<3,TDL(1) + 12> "L#3":SPACE(2):COM<4,TDL(1) + 12> "L#4":SPACE(1):COM<5,TDL(1) + 12> "L#1":SPACE(4):COM<6,TDL(1) + 12> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 13)):TDL(1) + 13:" ":COM<1,TDL(1) + 13> "L#4":SPACE(6):COM<2,TDL(1) + 13> "L#25":SPACE(5):COM<3,TDL(1) + 13> "L#3":SPACE(2):COM<4,TDL(1) + 13> "L#4":SPACE(1):COM<5,TDL(1) + 13> "L#1":SPACE(4):COM<6,TDL(1) + 13> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 14)):TDL(1) + 14:" ":COM<1,TDL(1) + 14> "L#4":SPACE(6):COM<2,TDL(1) + 14> "L#25":SPACE(5):COM<3,TDL(1) + 14> "L#3":SPACE(2):COM<4,TDL(1) + 14> "L#4":SPACE(1):COM<5,TDL(1) + 14> "L#1":SPACE(4):COM<6,TDL(1) + 14> "L#1"
PRINT SPACE(10):SPACE(TWO - LEN(TDL(1) + 15)):TDL(1) + 15:" ":COM<1,TDL(1) + 15> "L#4":SPACE(6):COM<2,TDL(1) + 15> "L#25":SPACE(5):COM<3,TDL(1) + 15> "L#3":SPACE(2):COM<4,TDL(1) + 15> "L#4":SPACE(1):COM<5,TDL(1) + 15> "L#1":SPACE(4):COM<6,TDL(1) + 15> "L#1"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.TYPE.32~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.TYPE.32(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "DT":AM:"IT":AM:"SE"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                  AI Maintenance  -  Single Address - 32 Tiers" "L#80"
PRINT 
PRINT "AI Code" "L#7":SPACE(2):COM.AI.ID.SAVE<2> "L#4"
PRINT 
PRINT "     Description" "L#20":SPACE(2):COM.AI$NAME "L#25"
PRINT "     Interface Type" "L#20":SPACE(2):COM.AI$TYPE "L#1"
PRINT "     Port Number" "L#20":SPACE(2):COM.AI$COMMPORT "L#3"
PRINT 
PRINT "DT> Device Type" "L#20":SPACE(2):; REDISP = TRUE; LOCATE DVC.TYPE IN COM.AI$DVC.UNIT<ONE> SETTING VC THEN PRINT COM.AI$DVC.UNIT<ONE,VC> "L#8": ELSE VC = ONE; PRINT COM.AI$DVC.UNIT<ONE,VC> "L#8"
PRINT "IT> Interface Type" "L#20":SPACE(2):COM.AI$DB.PREFIX<ONE,VC> "L#2"
PRINT 
PRINT "SE> Default" "L#11":SPACE(9):"Connected" "L#9":SPACE(11):"Device" "L#6"
PRINT SPACE(4):"Services" "L#7":SPACE(9):"Outlets " "L#9":SPACE(11):" Tier" "L#6"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 0> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 0> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 0> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 1> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 1> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 1> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 2> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 2> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 2> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 3> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 3> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 3> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 4> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 4> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 4> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 5> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 5> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 5> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 6> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 6> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 6> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,VC,TDL(3) + 7> "L#7":SPACE(13):COM.AI$DF.COUT.ONE<ONE,VC,TDL(3) + 7> "L#5":SPACE(13):COM.AI$DF.TIER.ONE<ONE,VC,TDL(3) + 7> "L#2"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.TYPE.EIGHT~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.TYPE.EIGHT(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SE"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "            Addressable Interface Maintenance  -  Multiple Addresses" "L#80"
PRINT 
PRINT "Control Port" "L#15":SPACE(1):COM.AI.ID.SAVE<2> "L#3"
PRINT 
PRINT "    Description" "L#20":SPACE(2):COM.AI$NAME "L#25"
PRINT "    Interface Type" "L#20":SPACE(2):COM.AI$TYPE "L#1"
PRINT "    Interface Code" "L#20":SPACE(2): "L#2"
PRINT "    Port Number" "L#20":SPACE(2):COM.AI$PORT "L#3"
PRINT 
PRINT "SE> Default" "L#15":SPACE(5):"Connected" "L#15":SPACE(5):"Device" "L#10"
PRINT " Services" "L#15":SPACE(5):"Outlets " "L#15":SPACE(5):" Tier" "L#10"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 0> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 0> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 0> "L#2"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 1> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 1> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 1> "L#2"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 2> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 2> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 2> "L#2"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 3> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 3> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 3> "L#2"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 4> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 4> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 4> "L#2"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 5> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 5> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 5> "L#2"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 6> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 6> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 6> "L#2"
PRINT SPACE(2):COM.AI$DF.SVCS.EIGHT<ONE,TDL(1) + 7> "L#10":SPACE(10):COM.AI$DF.COUT.EIGHT<ONE,TDL(1) + 7> "L#5":SPACE(15):COM.AI$DF.TIER.EIGHT<ONE,TDL(1) + 7> "L#2"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.AI.TYPE.ONE~
SUBROUTINE SH.SUBR.LPT.MAINT.AI.TYPE.ONE(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SE"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "           AI Services/Tiers Defaults Maintenance  -  Single Address" "L#80"
PRINT 
PRINT "AI Code" "L#7":SPACE(2):COM.AI.ID.SAVE<2> "L#4"
PRINT 
PRINT "SE> Default" "L#12":SPACE(8):"Connected" "L#9":SPACE(11):"Device" "L#6"
PRINT SPACE(4):"Services" "L#8":SPACE(8):" Outlets " "L#9":SPACE(11):" Tier" "L#6"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 0> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 0> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 0> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 1> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 1> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 1> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 2> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 2> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 2> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 3> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 3> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 3> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 4> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 4> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 4> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 5> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 5> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 5> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 6> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 6> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 6> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 7> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 7> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 7> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 8> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 8> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 8> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 9> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 9> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 9> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 10> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 10> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 10> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 11> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 11> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 11> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 12> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 12> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 12> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 13> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 13> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 13> "L#2"
PRINT SPACE(4):COM.AI$DF.SVCS.ONE<ONE,TDL(1) + 14> "L#7":SPACE(11):COM.AI$DF.COUT.ONE<ONE,TDL(1) + 14> "L#5":SPACE(15):COM.AI$DF.TIER.ONE<ONE,TDL(1) + 14> "L#2"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.BARKERS~
SUBROUTINE SH.SUBR.LPT.MAINT.BARKERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                           Barker Channel Maintenance" "L#80"
PRINT 
PRINT 
PRINT "Short name" "L#10":SPACE(2):"Description" "L#11":SPACE(17):"Channel #" "L#9"
PRINT PAR<1,TDL(1) + 0> "L#6":SPACE(6):PAR<2,TDL(1) + 0> "L#25":SPACE(3):PAR<3,TDL(1) + 0> "L#2"
PRINT PAR<1,TDL(1) + 1> "L#6":SPACE(6):PAR<2,TDL(1) + 1> "L#25":SPACE(3):PAR<3,TDL(1) + 1> "L#2"
PRINT PAR<1,TDL(1) + 2> "L#6":SPACE(6):PAR<2,TDL(1) + 2> "L#25":SPACE(3):PAR<3,TDL(1) + 2> "L#2"
PRINT PAR<1,TDL(1) + 3> "L#6":SPACE(6):PAR<2,TDL(1) + 3> "L#25":SPACE(3):PAR<3,TDL(1) + 3> "L#2"
PRINT PAR<1,TDL(1) + 4> "L#6":SPACE(6):PAR<2,TDL(1) + 4> "L#25":SPACE(3):PAR<3,TDL(1) + 4> "L#2"
PRINT PAR<1,TDL(1) + 5> "L#6":SPACE(6):PAR<2,TDL(1) + 5> "L#25":SPACE(3):PAR<3,TDL(1) + 5> "L#2"
PRINT PAR<1,TDL(1) + 6> "L#6":SPACE(6):PAR<2,TDL(1) + 6> "L#25":SPACE(3):PAR<3,TDL(1) + 6> "L#2"
PRINT PAR<1,TDL(1) + 7> "L#6":SPACE(6):PAR<2,TDL(1) + 7> "L#25":SPACE(3):PAR<3,TDL(1) + 7> "L#2"
PRINT PAR<1,TDL(1) + 8> "L#6":SPACE(6):PAR<2,TDL(1) + 8> "L#25":SPACE(3):PAR<3,TDL(1) + 8> "L#2"
PRINT PAR<1,TDL(1) + 9> "L#6":SPACE(6):PAR<2,TDL(1) + 9> "L#25":SPACE(3):PAR<3,TDL(1) + 9> "L#2"
PRINT PAR<1,TDL(1) + 10> "L#6":SPACE(6):PAR<2,TDL(1) + 10> "L#25":SPACE(3):PAR<3,TDL(1) + 10> "L#2"
PRINT PAR<1,TDL(1) + 11> "L#6":SPACE(6):PAR<2,TDL(1) + 11> "L#25":SPACE(3):PAR<3,TDL(1) + 11> "L#2"
PRINT PAR<1,TDL(1) + 12> "L#6":SPACE(6):PAR<2,TDL(1) + 12> "L#25":SPACE(3):PAR<3,TDL(1) + 12> "L#2"
PRINT PAR<1,TDL(1) + 13> "L#6":SPACE(6):PAR<2,TDL(1) + 13> "L#25":SPACE(3):PAR<3,TDL(1) + 13> "L#2"
PRINT PAR<1,TDL(1) + 14> "L#6":SPACE(6):PAR<2,TDL(1) + 14> "L#25":SPACE(3):PAR<3,TDL(1) + 14> "L#2"
PRINT PAR<1,TDL(1) + 15> "L#6":SPACE(6):PAR<2,TDL(1) + 15> "L#25":SPACE(3):PAR<3,TDL(1) + 15> "L#2"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.BRMNGR.MSG~
SUBROUTINE SH.SUBR.LPT.MAINT.BRMNGR.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                 Branch Manager/Supervisor Message Maintenance" "L#80"
PRINT 
PRINT "EF> Effective Date/Time" "L#23":SPACE(2):OCONV(COM<2>,"D2") "L#10":OCONV(COM<3>,"MTS") "L#8"
PRINT 
PRINT "EX> Expirary Date/Time" "L#22":SPACE(3):OCONV(COM<4>,"D2") "L#10":OCONV(COM<5>,"MTS") "L#8"
PRINT 
PRINT "MSG> Message text..." "L#20":SPACE(2):SPACE(TWO - LEN(TDL(3) + 0)):TDL(3) + 0:" ":COM<1,TDL(3) + 0> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 1)):TDL(3) + 1:" ":COM<1,TDL(3) + 1> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 2)):TDL(3) + 2:" ":COM<1,TDL(3) + 2> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 3)):TDL(3) + 3:" ":COM<1,TDL(3) + 3> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 4)):TDL(3) + 4:" ":COM<1,TDL(3) + 4> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 5)):TDL(3) + 5:" ":COM<1,TDL(3) + 5> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 6)):TDL(3) + 6:" ":COM<1,TDL(3) + 6> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 7)):TDL(3) + 7:" ":COM<1,TDL(3) + 7> "L#35"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.CHANNELS~
SUBROUTINE SH.SUBR.LPT.MAINT.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                       Components by Headend Maintenance" "L#80"
PRINT 
PRINT 
PRINT "  Headend" "L#10":SPACE(2):COM.ID.SAVE<2> "L#2"
PRINT 
PRINT "Component" "L#9":SPACE(1):"Chan" "L#4":SPACE(1):"Component" "L#25":SPACE(2):"Programmer" "L#11"
PRINT "  Name" "L#9":SPACE(1):" ###" "L#4":SPACE(1):"Description" "L#25":SPACE(2):"....Code..." "L#11"
PRINT COM<1,TDL(1) + 0> "L#8":SPACE(3):COM<3,TDL(1) + 0> "L#3"
PRINT COM<1,TDL(1) + 1> "L#8":SPACE(3):COM<3,TDL(1) + 1> "L#3"
PRINT COM<1,TDL(1) + 2> "L#8":SPACE(3):COM<3,TDL(1) + 2> "L#3"
PRINT COM<1,TDL(1) + 3> "L#8":SPACE(3):COM<3,TDL(1) + 3> "L#3"
PRINT COM<1,TDL(1) + 4> "L#8":SPACE(3):COM<3,TDL(1) + 4> "L#3"
PRINT COM<1,TDL(1) + 5> "L#8":SPACE(3):COM<3,TDL(1) + 5> "L#3"
PRINT COM<1,TDL(1) + 6> "L#8":SPACE(3):COM<3,TDL(1) + 6> "L#3"
PRINT COM<1,TDL(1) + 7> "L#8":SPACE(3):COM<3,TDL(1) + 7> "L#3"
PRINT COM<1,TDL(1) + 8> "L#8":SPACE(3):COM<3,TDL(1) + 8> "L#3"
PRINT COM<1,TDL(1) + 9> "L#8":SPACE(3):COM<3,TDL(1) + 9> "L#3"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.COMMAND.LIST~
SUBROUTINE SH.SUBR.LPT.MAINT.COMMAND.LIST(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                    General Inquiry Command List Maintenance" "L#80"
PRINT 
PRINT SPACE(45):"RUNOFF file identifier:            " "L#35"
PRINT SPACE(45):"   prefixed by CABLE. for narrative" "L#35"
PRINT "Command" "L#7":SPACE(5):"Command description           " "L#30":SPACE(3):"               CABLE.? for help    " "L#35"
PRINT PAR<1,TDL(1) + 0> "L#2":SPACE(10):PAR<2,TDL(1) + 0> "L#30":SPACE(3):PAR<3,TDL(1) + 0> "L#35"
PRINT PAR<1,TDL(1) + 1> "L#2":SPACE(10):PAR<2,TDL(1) + 1> "L#30":SPACE(3):PAR<3,TDL(1) + 1> "L#35"
PRINT PAR<1,TDL(1) + 2> "L#2":SPACE(10):PAR<2,TDL(1) + 2> "L#30":SPACE(3):PAR<3,TDL(1) + 2> "L#35"
PRINT PAR<1,TDL(1) + 3> "L#2":SPACE(10):PAR<2,TDL(1) + 3> "L#30":SPACE(3):PAR<3,TDL(1) + 3> "L#35"
PRINT PAR<1,TDL(1) + 4> "L#2":SPACE(10):PAR<2,TDL(1) + 4> "L#30":SPACE(3):PAR<3,TDL(1) + 4> "L#35"
PRINT PAR<1,TDL(1) + 5> "L#2":SPACE(10):PAR<2,TDL(1) + 5> "L#30":SPACE(3):PAR<3,TDL(1) + 5> "L#35"
PRINT PAR<1,TDL(1) + 6> "L#2":SPACE(10):PAR<2,TDL(1) + 6> "L#30":SPACE(3):PAR<3,TDL(1) + 6> "L#35"
PRINT PAR<1,TDL(1) + 7> "L#2":SPACE(10):PAR<2,TDL(1) + 7> "L#30":SPACE(3):PAR<3,TDL(1) + 7> "L#35"
PRINT PAR<1,TDL(1) + 8> "L#2":SPACE(10):PAR<2,TDL(1) + 8> "L#30":SPACE(3):PAR<3,TDL(1) + 8> "L#35"
PRINT PAR<1,TDL(1) + 9> "L#2":SPACE(10):PAR<2,TDL(1) + 9> "L#30":SPACE(3):PAR<3,TDL(1) + 9> "L#35"
PRINT PAR<1,TDL(1) + 10> "L#2":SPACE(10):PAR<2,TDL(1) + 10> "L#30":SPACE(3):PAR<3,TDL(1) + 10> "L#35"
PRINT PAR<1,TDL(1) + 11> "L#2":SPACE(10):PAR<2,TDL(1) + 11> "L#30":SPACE(3):PAR<3,TDL(1) + 11> "L#35"
PRINT PAR<1,TDL(1) + 12> "L#2":SPACE(10):PAR<2,TDL(1) + 12> "L#30":SPACE(3):PAR<3,TDL(1) + 12> "L#35"
PRINT PAR<1,TDL(1) + 13> "L#2":SPACE(10):PAR<2,TDL(1) + 13> "L#30":SPACE(3):PAR<3,TDL(1) + 13> "L#35"
PRINT PAR<1,TDL(1) + 14> "L#2":SPACE(10):PAR<2,TDL(1) + 14> "L#30":SPACE(3):PAR<3,TDL(1) + 14> "L#35"
PRINT PAR<1,TDL(1) + 15> "L#2":SPACE(10):PAR<2,TDL(1) + 15> "L#30":SPACE(3):PAR<3,TDL(1) + 15> "L#35"
PRINT PAR<1,TDL(1) + 16> "L#2":SPACE(10):PAR<2,TDL(1) + 16> "L#30":SPACE(3):PAR<3,TDL(1) + 16> "L#35"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.COMP.PROG~
SUBROUTINE SH.SUBR.LPT.MAINT.COMP.PROG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                      Component to Programmer Maintenance" "L#80"
PRINT 
PRINT "Component" "L#9":SPACE(1):"Chan" "L#4":SPACE(1):"Programmer" "L#11":SPACE(2):"Programmer" "L#30"
PRINT "  Name" "L#9":SPACE(1):" ###" "L#4":SPACE(1):"....Code..." "L#11":SPACE(2):"Description" "L#30"
PRINT COM<1,TDL(1) + 0> "L#8":SPACE(3):COM<3,TDL(1) + 0> "L#3":SPACE(3):COM<8,TDL(1) + 0> "L#8"
PRINT COM<1,TDL(1) + 1> "L#8":SPACE(3):COM<3,TDL(1) + 1> "L#3":SPACE(3):COM<8,TDL(1) + 1> "L#8"
PRINT COM<1,TDL(1) + 2> "L#8":SPACE(3):COM<3,TDL(1) + 2> "L#3":SPACE(3):COM<8,TDL(1) + 2> "L#8"
PRINT COM<1,TDL(1) + 3> "L#8":SPACE(3):COM<3,TDL(1) + 3> "L#3":SPACE(3):COM<8,TDL(1) + 3> "L#8"
PRINT COM<1,TDL(1) + 4> "L#8":SPACE(3):COM<3,TDL(1) + 4> "L#3":SPACE(3):COM<8,TDL(1) + 4> "L#8"
PRINT COM<1,TDL(1) + 5> "L#8":SPACE(3):COM<3,TDL(1) + 5> "L#3":SPACE(3):COM<8,TDL(1) + 5> "L#8"
PRINT COM<1,TDL(1) + 6> "L#8":SPACE(3):COM<3,TDL(1) + 6> "L#3":SPACE(3):COM<8,TDL(1) + 6> "L#8"
PRINT COM<1,TDL(1) + 7> "L#8":SPACE(3):COM<3,TDL(1) + 7> "L#3":SPACE(3):COM<8,TDL(1) + 7> "L#8"
PRINT COM<1,TDL(1) + 8> "L#8":SPACE(3):COM<3,TDL(1) + 8> "L#3":SPACE(3):COM<8,TDL(1) + 8> "L#8"
PRINT COM<1,TDL(1) + 9> "L#8":SPACE(3):COM<3,TDL(1) + 9> "L#3":SPACE(3):COM<8,TDL(1) + 9> "L#8"
PRINT COM<1,TDL(1) + 10> "L#8":SPACE(3):COM<3,TDL(1) + 10> "L#3":SPACE(3):COM<8,TDL(1) + 10> "L#8"
PRINT COM<1,TDL(1) + 11> "L#8":SPACE(3):COM<3,TDL(1) + 11> "L#3":SPACE(3):COM<8,TDL(1) + 11> "L#8"
PRINT COM<1,TDL(1) + 12> "L#8":SPACE(3):COM<3,TDL(1) + 12> "L#3":SPACE(3):COM<8,TDL(1) + 12> "L#8"
PRINT COM<1,TDL(1) + 13> "L#8":SPACE(3):COM<3,TDL(1) + 13> "L#3":SPACE(3):COM<8,TDL(1) + 13> "L#8"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.DISP.MSG~
SUBROUTINE SH.SUBR.LPT.MAINT.DISP.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                         Dispatcher Message Maintenance" "L#80"
PRINT 
PRINT "EF> Effective Date/Time" "L#23":SPACE(2):OCONV(COM<2>,"D2") "L#10":OCONV(COM<3>,"MTS") "L#8"
PRINT 
PRINT "EX> Expirary Date/Time" "L#22":SPACE(3):OCONV(COM<4>,"D2") "L#10":OCONV(COM<5>,"MTS") "L#8"
PRINT 
PRINT "MSG> Message text..." "L#20":SPACE(2):SPACE(TWO - LEN(TDL(3) + 0)):TDL(3) + 0:" ":COM<1,TDL(3) + 0> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 1)):TDL(3) + 1:" ":COM<1,TDL(3) + 1> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 2)):TDL(3) + 2:" ":COM<1,TDL(3) + 2> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 3)):TDL(3) + 3:" ":COM<1,TDL(3) + 3> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 4)):TDL(3) + 4:" ":COM<1,TDL(3) + 4> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 5)):TDL(3) + 5:" ":COM<1,TDL(3) + 5> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 6)):TDL(3) + 6:" ":COM<1,TDL(3) + 6> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 7)):TDL(3) + 7:" ":COM<1,TDL(3) + 7> "L#35"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.EVENT.PVM~
SUBROUTINE SH.SUBR.LPT.MAINT.EVENT.PVM(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(16); MAT TDL = EMPTY
DIM TDH(16); MAT TDH = EMPTY
DIM TDI(16); MAT TDI = EMPTY
DIM TDX(16); MAT TDX = ONE
DIM SAVE.TDX(16); MAT SAVE.TDX = EMPTY
DIM TDM(16); MAT TDM = EMPTY
DIM TDS(16); MAT TDS = EMPTY
DIM TDR(16); MAT TDR = EMPTY
DIM TDC(16); MAT TDC = EMPTY
DIM TDT(16); MAT TDT = EMPTY
VALID.REFS = "DS":AM:"SM":AM:"DB":AM:"CC":AM:"DR":AM:"SD":AM:"DU":AM:"RT":AM:"RC":AM:"RS":AM:"EC":AM:"PC":AM:"MC":AM:"ST":AM:"GU":AM:"PU"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                          PPV Event Master Maintenance" "L#80"
PRINT 
PRINT "  Master Event" "L#15":SPACE(2):PVM.ID.SAVE<1> "L#6"
PRINT "DS> Description" "L#15":SPACE(2):PVM$DESC "L#25"
PRINT 
PRINT "SM> Sch. (YYMM)" "L#15":SPACE(2):PVM$PROGMO "L#6":SPACE(1):"DB> Debut Date" "L#16":SPACE(1):OCONV(PVM$DEBUT.DT,"D2") "L#9":SPACE(2):"CC> Ch. Code" "L#16":SPACE(1):PVM$CH.CODE "L#3"
PRINT "DR> Distr" "L#15":SPACE(2):PVM$DISTR "L#6"
PRINT "SD> Studio" "L#15":SPACE(2):PVM$STUDIO "L#6"
PRINT "DU> Duration" "L#15":SPACE(2):OCONV(PVM$DUR,"MT") "L#5"
PRINT "RT> Run Time" "L#15":SPACE(2):OCONV(PVM$RUN.TM,"MT") "L#5"
PRINT 
PRINT "RC> Rate Class" "L#15":SPACE(2):PVM$RATE.CL "L#6"
PRINT "RS>  Sub-Class" "L#15":SPACE(2):PVM$RATE.CL.SUB "L#6"
PRINT 
PRINT "EC> Event Class" "L#15":SPACE(2):PVM$CL "L#6"
PRINT "PC> Prog Class" "L#15":SPACE(2):PVM$PROG.CL "L#6"
PRINT "MC> Mrkt Class" "L#15":SPACE(2):PVM$MRKT.CL "L#6"
PRINT 
PRINT "ST> Star Rating" "L#15":SPACE(2):PVM$STARS "L#1":SPACE(6):"GU> Guide Rating" "L#16":SPACE(1):PVM$RATING "L#5":SPACE(5):"PU> Purge Date" "L#15":SPACE(1):OCONV(PVM$PURGE.DT,"D2") "L#9"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.EVENT.PVM.PVE~
SUBROUTINE SH.SUBR.LPT.MAINT.EVENT.PVM.PVE(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                         PPV Event Details Maintenance" "L#80"
PRINT 
PRINT "Event:" "L#6":SPACE(2):PVM.ID.SAVE<1> "L#6":SPACE(2):PVM$DESC "L#25":SPACE(6):PVM$CL "L#6"
PRINT SPACE(51):"      Defaults:" "L#21"
PRINT SPACE(51):PVM$RATE.CL "L#6":SPACE(2):PVM$RATE.CL.SUB "L#6":SPACE(2):OCONV(PVM$DUR,"MT") "L#5"
PRINT "Sched. (YYMM):" "L#14":SPACE(2):PVM$PROGMO "L#4":SPACE(9):"Ln#" "L#3":SPACE(1):"..Date..." "L#9":SPACE(2):".Time" "L#5":SPACE(2):"RateCl" "L#6":SPACE(2):"Sub.Cl" "L#6":SPACE(2):" Dur" "L#5":SPACE(2):"Event#" "L#6"
PRINT "Distributor:" "L#14":SPACE(2):PVM$DISTR "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":PVM$PVE.DT<ONE,TDL(1) + 0> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 0> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 0> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 0> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 0> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 0> "L#4"
PRINT "Studio:" "L#14":SPACE(2):PVM$STUDIO "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":PVM$PVE.DT<ONE,TDL(1) + 1> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 1> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 1> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 1> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 1> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 1> "L#4"
PRINT "Channel Code:" "L#14":SPACE(2):PVM$CH.CODE "L#3":SPACE(14):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":PVM$PVE.DT<ONE,TDL(1) + 2> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 2> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 2> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 2> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 2> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 2> "L#4"
PRINT "Debut Date:" "L#14":SPACE(2):OCONV(PVM$DEBUT.DT,"D2") "L#9":SPACE(8):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":PVM$PVE.DT<ONE,TDL(1) + 3> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 3> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 3> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 3> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 3> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 3> "L#4"
PRINT "Purge Date:" "L#14":SPACE(2):OCONV(PVM$PURGE.DT,"D2") "L#9":SPACE(8):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":PVM$PVE.DT<ONE,TDL(1) + 4> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 4> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 4> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 4> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 4> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 4> "L#4"
PRINT "Prog Class:" "L#14":SPACE(2):PVM$PROG.CL "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":PVM$PVE.DT<ONE,TDL(1) + 5> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 5> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 5> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 5> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 5> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 5> "L#4"
PRINT "Mrkt Class:" "L#14":SPACE(2):PVM$MRKT.CL "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":PVM$PVE.DT<ONE,TDL(1) + 6> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 6> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 6> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 6> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 6> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 6> "L#4"
PRINT "Star Rating:" "L#14":SPACE(2):PVM$STARS "L#1":SPACE(16):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":PVM$PVE.DT<ONE,TDL(1) + 7> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 7> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 7> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 7> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 7> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 7> "L#4"
PRINT "Guide Rating:" "L#14":SPACE(2):PVM$RATING "L#5":SPACE(12):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":PVM$PVE.DT<ONE,TDL(1) + 8> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 8> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 8> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 8> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 8> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 8> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":PVM$PVE.DT<ONE,TDL(1) + 9> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 9> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 9> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 9> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 9> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 9> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":PVM$PVE.DT<ONE,TDL(1) + 10> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 10> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 10> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 10> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 10> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 10> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":PVM$PVE.DT<ONE,TDL(1) + 11> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 11> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 11> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 11> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 11> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 11> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":PVM$PVE.DT<ONE,TDL(1) + 12> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 12> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 12> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 12> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 12> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 12> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 13)):TDL(1) + 13:" ":PVM$PVE.DT<ONE,TDL(1) + 13> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 13> "L#5":SPACE(2):PVM$PVE.RATE.CL<ONE,TDL(1) + 13> "L#6":SPACE(2):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 13> "L#6":SPACE(2):PVM$PVE.DUR<ONE,TDL(1) + 13> "L#5":SPACE(3):PVM$EVENT.NUMS<ONE,TDL(1) + 13> "L#4"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.HEADEND~
SUBROUTINE SH.SUBR.LPT.MAINT.HEADEND(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "NA":AM:"CP"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                     Maintain Handler Head End Information" "L#80"
PRINT 
PRINT "Head End" "L#10":SPACE(2):COM.SAVE<2> "L#2"
PRINT "NA> Head End Name" "L#20":SPACE(2):COM<2> "L#25"
PRINT 
PRINT "CP> Control Port" "L#20":SPACE(2):COM<1> "L#3"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.INTFC.MSG~
SUBROUTINE SH.SUBR.LPT.MAINT.INTFC.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                   Addressable Interface Message Maintenance" "L#80"
PRINT 
PRINT "AI Code" "L#7":SPACE(2):COM.ID.SAVE<2> "L#4"
PRINT 
PRINT "EF> Effective Date/Time" "L#23":SPACE(2):OCONV(COM<2>,"D2") "L#10":OCONV(COM<3>,"MTS") "L#8"
PRINT 
PRINT "EX> Expirary Date/Time" "L#22":SPACE(3):OCONV(COM<4>,"D2") "L#10":OCONV(COM<5>,"MTS") "L#8"
PRINT 
PRINT "MSG> Message text..." "L#20":SPACE(2):SPACE(TWO - LEN(TDL(3) + 0)):TDL(3) + 0:" ":COM<1,TDL(3) + 0> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 1)):TDL(3) + 1:" ":COM<1,TDL(3) + 1> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 2)):TDL(3) + 2:" ":COM<1,TDL(3) + 2> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 3)):TDL(3) + 3:" ":COM<1,TDL(3) + 3> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 4)):TDL(3) + 4:" ":COM<1,TDL(3) + 4> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 5)):TDL(3) + 5:" ":COM<1,TDL(3) + 5> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 6)):TDL(3) + 6:" ":COM<1,TDL(3) + 6> "L#35"
PRINT SPACE(22):SPACE(TWO - LEN(TDL(3) + 7)):TDL(3) + 7:" ":COM<1,TDL(3) + 7> "L#35"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.INTFC.TYPES~
SUBROUTINE SH.SUBR.LPT.MAINT.INTFC.TYPES(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "OP"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                  Addressable Interface Controller Maintenance" "L#80"
PRINT 
PRINT SPACE(20):"Code  " "L#4":SPACE(2):"Controller Make and Model           " "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 0> "L#2":SPACE(3):COM<2,TDL(1) + 0> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 1> "L#2":SPACE(3):COM<2,TDL(1) + 1> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 2> "L#2":SPACE(3):COM<2,TDL(1) + 2> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 3> "L#2":SPACE(3):COM<2,TDL(1) + 3> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 4> "L#2":SPACE(3):COM<2,TDL(1) + 4> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 5> "L#2":SPACE(3):COM<2,TDL(1) + 5> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 6> "L#2":SPACE(3):COM<2,TDL(1) + 6> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 7> "L#2":SPACE(3):COM<2,TDL(1) + 7> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 8> "L#2":SPACE(3):COM<2,TDL(1) + 8> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 9> "L#2":SPACE(3):COM<2,TDL(1) + 9> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 10> "L#2":SPACE(3):COM<2,TDL(1) + 10> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 11> "L#2":SPACE(3):COM<2,TDL(1) + 11> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 12> "L#2":SPACE(3):COM<2,TDL(1) + 12> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 13> "L#2":SPACE(3):COM<2,TDL(1) + 13> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 14> "L#2":SPACE(3):COM<2,TDL(1) + 14> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 15> "L#2":SPACE(3):COM<2,TDL(1) + 15> "L#30"
PRINT SPACE(21):COM<1,TDL(1) + 16> "L#2":SPACE(3):COM<2,TDL(1) + 16> "L#30"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.MANUFACTURER~
SUBROUTINE SH.SUBR.LPT.MAINT.MANUFACTURER(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SU"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                      Equipment Manufacturers Maintenance" "L#80"
PRINT 
PRINT "Manufacturer" "L#12":SPACE(3):"Addr" "L#4"
PRINT "   Code" "L#12":SPACE(3):"Code" "L#4":SPACE(1):"Description" "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 0> "L#8":SPACE(5):COM<3,TDL(1) + 0> "L#2":SPACE(2):COM<2,TDL(1) + 0> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 1> "L#8":SPACE(5):COM<3,TDL(1) + 1> "L#2":SPACE(2):COM<2,TDL(1) + 1> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 2> "L#8":SPACE(5):COM<3,TDL(1) + 2> "L#2":SPACE(2):COM<2,TDL(1) + 2> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 3> "L#8":SPACE(5):COM<3,TDL(1) + 3> "L#2":SPACE(2):COM<2,TDL(1) + 3> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 4> "L#8":SPACE(5):COM<3,TDL(1) + 4> "L#2":SPACE(2):COM<2,TDL(1) + 4> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 5> "L#8":SPACE(5):COM<3,TDL(1) + 5> "L#2":SPACE(2):COM<2,TDL(1) + 5> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 6> "L#8":SPACE(5):COM<3,TDL(1) + 6> "L#2":SPACE(2):COM<2,TDL(1) + 6> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 7> "L#8":SPACE(5):COM<3,TDL(1) + 7> "L#2":SPACE(2):COM<2,TDL(1) + 7> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 8> "L#8":SPACE(5):COM<3,TDL(1) + 8> "L#2":SPACE(2):COM<2,TDL(1) + 8> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 9> "L#8":SPACE(5):COM<3,TDL(1) + 9> "L#2":SPACE(2):COM<2,TDL(1) + 9> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 10> "L#8":SPACE(5):COM<3,TDL(1) + 10> "L#2":SPACE(2):COM<2,TDL(1) + 10> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 11> "L#8":SPACE(5):COM<3,TDL(1) + 11> "L#2":SPACE(2):COM<2,TDL(1) + 11> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 12> "L#8":SPACE(5):COM<3,TDL(1) + 12> "L#2":SPACE(2):COM<2,TDL(1) + 12> "L#30"
PRINT SPACE(3):COM<1,TDL(1) + 13> "L#8":SPACE(5):COM<3,TDL(1) + 13> "L#2":SPACE(2):COM<2,TDL(1) + 13> "L#30"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PPV.CHANNELS~
SUBROUTINE SH.SUBR.LPT.MAINT.PPV.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                      PPV Channels by AI Code Maintenance" "L#80"
PRINT 
PRINT "  AI Code" "L#10":SPACE(2):COM.ID.SAVE<2> "L#4"
PRINT 
PRINT "Chan" "L#4":SPACE(29):"Chan" "L#4":SPACE(1):"Encoder" "L#7":"Encoder" "L#7"
PRINT "Num." "L#4":SPACE(1):"Channel Description" "L#25":SPACE(3):"Code" "L#4":SPACE(1):" Group" "L#7":" Member" "L#7"
PRINT 
PRINT COM<1,TDL(1) + 0> "L#3":SPACE(4):COM<2,TDL(1) + 0> "L#25":SPACE(2):COM<3,TDL(1) + 0> "L#3":SPACE(5):COM<4,TDL(1) + 0> "L#2":SPACE(5):COM<5,TDL(1) + 0> "L#2"
PRINT COM<1,TDL(1) + 1> "L#3":SPACE(4):COM<2,TDL(1) + 1> "L#25":SPACE(2):COM<3,TDL(1) + 1> "L#3":SPACE(5):COM<4,TDL(1) + 1> "L#2":SPACE(5):COM<5,TDL(1) + 1> "L#2"
PRINT COM<1,TDL(1) + 2> "L#3":SPACE(4):COM<2,TDL(1) + 2> "L#25":SPACE(2):COM<3,TDL(1) + 2> "L#3":SPACE(5):COM<4,TDL(1) + 2> "L#2":SPACE(5):COM<5,TDL(1) + 2> "L#2"
PRINT COM<1,TDL(1) + 3> "L#3":SPACE(4):COM<2,TDL(1) + 3> "L#25":SPACE(2):COM<3,TDL(1) + 3> "L#3":SPACE(5):COM<4,TDL(1) + 3> "L#2":SPACE(5):COM<5,TDL(1) + 3> "L#2"
PRINT COM<1,TDL(1) + 4> "L#3":SPACE(4):COM<2,TDL(1) + 4> "L#25":SPACE(2):COM<3,TDL(1) + 4> "L#3":SPACE(5):COM<4,TDL(1) + 4> "L#2":SPACE(5):COM<5,TDL(1) + 4> "L#2"
PRINT COM<1,TDL(1) + 5> "L#3":SPACE(4):COM<2,TDL(1) + 5> "L#25":SPACE(2):COM<3,TDL(1) + 5> "L#3":SPACE(5):COM<4,TDL(1) + 5> "L#2":SPACE(5):COM<5,TDL(1) + 5> "L#2"
PRINT COM<1,TDL(1) + 6> "L#3":SPACE(4):COM<2,TDL(1) + 6> "L#25":SPACE(2):COM<3,TDL(1) + 6> "L#3":SPACE(5):COM<4,TDL(1) + 6> "L#2":SPACE(5):COM<5,TDL(1) + 6> "L#2"
PRINT COM<1,TDL(1) + 7> "L#3":SPACE(4):COM<2,TDL(1) + 7> "L#25":SPACE(2):COM<3,TDL(1) + 7> "L#3":SPACE(5):COM<4,TDL(1) + 7> "L#2":SPACE(5):COM<5,TDL(1) + 7> "L#2"
PRINT COM<1,TDL(1) + 8> "L#3":SPACE(4):COM<2,TDL(1) + 8> "L#25":SPACE(2):COM<3,TDL(1) + 8> "L#3":SPACE(5):COM<4,TDL(1) + 8> "L#2":SPACE(5):COM<5,TDL(1) + 8> "L#2"
PRINT COM<1,TDL(1) + 9> "L#3":SPACE(4):COM<2,TDL(1) + 9> "L#25":SPACE(2):COM<3,TDL(1) + 9> "L#3":SPACE(5):COM<4,TDL(1) + 9> "L#2":SPACE(5):COM<5,TDL(1) + 9> "L#2"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PPV.DISTRIBUTORS~
SUBROUTINE SH.SUBR.LPT.MAINT.PPV.DISTRIBUTORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                       Maintain PPV Distributors/Studios" "L#80"
PRINT 
PRINT 
PRINT 
PRINT SPACE(20):" Code " "L#8":SPACE(2):"      Description" "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 0> "L#6":SPACE(3):COM<2,TDL(1) + 0> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 1> "L#6":SPACE(3):COM<2,TDL(1) + 1> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 2> "L#6":SPACE(3):COM<2,TDL(1) + 2> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 3> "L#6":SPACE(3):COM<2,TDL(1) + 3> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 4> "L#6":SPACE(3):COM<2,TDL(1) + 4> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 5> "L#6":SPACE(3):COM<2,TDL(1) + 5> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 6> "L#6":SPACE(3):COM<2,TDL(1) + 6> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 7> "L#6":SPACE(3):COM<2,TDL(1) + 7> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 8> "L#6":SPACE(3):COM<2,TDL(1) + 8> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 9> "L#6":SPACE(3):COM<2,TDL(1) + 9> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 10> "L#6":SPACE(3):COM<2,TDL(1) + 10> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 11> "L#6":SPACE(3):COM<2,TDL(1) + 11> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 12> "L#6":SPACE(3):COM<2,TDL(1) + 12> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 13> "L#6":SPACE(3):COM<2,TDL(1) + 13> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 14> "L#6":SPACE(3):COM<2,TDL(1) + 14> "L#25"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PPV.EVENT~
SUBROUTINE SH.SUBR.LPT.MAINT.PPV.EVENT(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(8); MAT TDL = EMPTY
DIM TDH(8); MAT TDH = EMPTY
DIM TDI(8); MAT TDI = EMPTY
DIM TDX(8); MAT TDX = ONE
DIM SAVE.TDX(8); MAT SAVE.TDX = EMPTY
DIM TDM(8); MAT TDM = EMPTY
DIM TDS(8); MAT TDS = EMPTY
DIM TDR(8); MAT TDR = EMPTY
DIM TDC(8); MAT TDC = EMPTY
DIM TDT(8); MAT TDT = EMPTY
VALID.REFS = "PM":AM:"CH":AM:"RC":AM:"RS":AM:"SD":AM:"ST":AM:"DU":AM:"DN"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                          Maintain Pay Per View Events" "L#80"
PRINT 
PRINT "    Event Number" "L#16":SPACE(3):PVE.ID.SAVE<1> "L#9"
PRINT 
PRINT "    Master Event" "L#16":SPACE(3):PVE$PVM.ID "L#6"
PRINT 
PRINT 
PRINT "PM> Program Mo." "L#16":SPACE(3):PVE$PROGMO "L#4"
PRINT "CH> Channel" "L#16":SPACE(3):PVE$CH.CODE "L#3"
PRINT "RC> Rate Class" "L#16":SPACE(3):PVE$RATE.CL "L#6"
PRINT "RS>      Sub-Cl" "L#16":SPACE(3):PVE$RATE.CL.SUB "L#6"
PRINT "SD> Show Date" "L#16":SPACE(3):OCONV(PVE$DT,"D2") "L#9"
PRINT "ST> Show Time" "L#16":SPACE(3):OCONV(PVE$TM,"MT") "L#5"
PRINT "DU> Duration" "L#16":SPACE(3):OCONV(PVE$DUR,"MT") "L#5"
PRINT "DN> Downloaded" "L#16":SPACE(3):PVE$DOWNLOADED "L#1"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PPV.EVENT.CLASS~
SUBROUTINE SH.SUBR.LPT.MAINT.PPV.EVENT.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                      Maintain Pay Per View Event Classes" "L#80"
PRINT 
PRINT 
PRINT 
PRINT SPACE(20):" Class" "L#8":SPACE(2):"      Description" "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 0> "L#6":SPACE(3):COM<2,TDL(1) + 0> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 1> "L#6":SPACE(3):COM<2,TDL(1) + 1> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 2> "L#6":SPACE(3):COM<2,TDL(1) + 2> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 3> "L#6":SPACE(3):COM<2,TDL(1) + 3> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 4> "L#6":SPACE(3):COM<2,TDL(1) + 4> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 5> "L#6":SPACE(3):COM<2,TDL(1) + 5> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 6> "L#6":SPACE(3):COM<2,TDL(1) + 6> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 7> "L#6":SPACE(3):COM<2,TDL(1) + 7> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 8> "L#6":SPACE(3):COM<2,TDL(1) + 8> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 9> "L#6":SPACE(3):COM<2,TDL(1) + 9> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 10> "L#6":SPACE(3):COM<2,TDL(1) + 10> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 11> "L#6":SPACE(3):COM<2,TDL(1) + 11> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 12> "L#6":SPACE(3):COM<2,TDL(1) + 12> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 13> "L#6":SPACE(3):COM<2,TDL(1) + 13> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 14> "L#6":SPACE(3):COM<2,TDL(1) + 14> "L#25"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PPV.EVENTS~
SUBROUTINE SH.SUBR.LPT.MAINT.PPV.EVENTS(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(8); MAT TDL = EMPTY
DIM TDH(8); MAT TDH = EMPTY
DIM TDI(8); MAT TDI = EMPTY
DIM TDX(8); MAT TDX = ONE
DIM SAVE.TDX(8); MAT SAVE.TDX = EMPTY
DIM TDM(8); MAT TDM = EMPTY
DIM TDS(8); MAT TDS = EMPTY
DIM TDR(8); MAT TDR = EMPTY
DIM TDC(8); MAT TDC = EMPTY
DIM TDT(8); MAT TDT = EMPTY
VALID.REFS = "PM":AM:"CH":AM:"RC":AM:"RS":AM:"SD":AM:"ST":AM:"DU":AM:"DN"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                          Maintain Pay Per View Events" "L#80"
PRINT 
PRINT "    Event Number" "L#16":SPACE(3):PVE.ID.SAVE<1> "L#9"
PRINT 
PRINT "    Master Event" "L#16":SPACE(3):PVE$PVM.ID "L#6"
PRINT 
PRINT 
PRINT "PM> Program Mo." "L#16":SPACE(3):PVE$PROGMO "L#4"
PRINT "CH> Channel" "L#16":SPACE(3):PVE$CH.CODE "L#3"
PRINT "RC> Rate Class" "L#16":SPACE(3):PVE$RATE.CL "L#6"
PRINT "RS>      Sub-Cl" "L#16":SPACE(3):PVE$RATE.CL.SUB "L#6"
PRINT "SD> Show Date" "L#16":SPACE(3):OCONV(PVE$DT,"D2") "L#9"
PRINT "ST> Show Time" "L#16":SPACE(3):OCONV(PVE$TM,"MT") "L#5"
PRINT "DU> Duration" "L#16":SPACE(3):OCONV(PVE$DUR,"MT") "L#5"
PRINT "DN> Downloaded" "L#16":SPACE(3):PVE$DOWNLOADED "L#1"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PPV.RATE.CLASS~
SUBROUTINE SH.SUBR.LPT.MAINT.PPV.RATE.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                       Maintain Pay Per View Rate Classes" "L#80"
PRINT 
PRINT 
PRINT 
PRINT SPACE(20):" Class" "L#8":SPACE(2):"      Description" "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 0> "L#6":SPACE(3):COM<2,TDL(1) + 0> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 1> "L#6":SPACE(3):COM<2,TDL(1) + 1> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 2> "L#6":SPACE(3):COM<2,TDL(1) + 2> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 3> "L#6":SPACE(3):COM<2,TDL(1) + 3> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 4> "L#6":SPACE(3):COM<2,TDL(1) + 4> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 5> "L#6":SPACE(3):COM<2,TDL(1) + 5> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 6> "L#6":SPACE(3):COM<2,TDL(1) + 6> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 7> "L#6":SPACE(3):COM<2,TDL(1) + 7> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 8> "L#6":SPACE(3):COM<2,TDL(1) + 8> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 9> "L#6":SPACE(3):COM<2,TDL(1) + 9> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 10> "L#6":SPACE(3):COM<2,TDL(1) + 10> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 11> "L#6":SPACE(3):COM<2,TDL(1) + 11> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 12> "L#6":SPACE(3):COM<2,TDL(1) + 12> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 13> "L#6":SPACE(3):COM<2,TDL(1) + 13> "L#25"
PRINT SPACE(21):COM<1,TDL(1) + 14> "L#6":SPACE(3):COM<2,TDL(1) + 14> "L#25"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PPV.RATES~
SUBROUTINE SH.SUBR.LPT.MAINT.PPV.RATES(TDL.REC,RTE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,RTE.FILE,RTE.ID,MAT RTE,COM.FILE,COM.ID,COM.ID.SAVE,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP RTE.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP RTE.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "PC":AM:"TX":AM:"AT"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                          Maintain Pay Per View Rates" "L#80"
PRINT 
PRINT "Rate Class" "L#15":SPACE(2):RTE.ID.SAVE<3> "L#6"
PRINT 
PRINT "Rate Sub-Class" "L#15":SPACE(2):RTE.ID.SAVE<5> "L#6"
PRINT 
PRINT "Rate Type" "L#15":SPACE(2):RTE.ID.SAVE<7> "L#3"
PRINT 
PRINT "PC> Price" "L#15":SPACE(2):OCONV(RTE$AMTS,"MR2ZM") "L#9"
PRINT "TX> Taxes for" "L#15":SPACE(2):RTE$TAX.NAMES "L#30"
PRINT "    All Areas" "L#15"
PRINT "AT> Rate" "L#8"
PRINT "    Area" "L#8":SPACE(2):"            Taxes" "L#30"
PRINT SPACE(4):RTE$AREAS<ONE,TDL(3) + 0> "L#2":SPACE(4):RTE$AREA.TAX.NAMES<ONE,TDL(3) + 0> "L#30"
PRINT SPACE(4):RTE$AREAS<ONE,TDL(3) + 1> "L#2":SPACE(4):RTE$AREA.TAX.NAMES<ONE,TDL(3) + 1> "L#30"
PRINT SPACE(4):RTE$AREAS<ONE,TDL(3) + 2> "L#2":SPACE(4):RTE$AREA.TAX.NAMES<ONE,TDL(3) + 2> "L#30"
PRINT SPACE(4):RTE$AREAS<ONE,TDL(3) + 3> "L#2":SPACE(4):RTE$AREA.TAX.NAMES<ONE,TDL(3) + 3> "L#30"
PRINT SPACE(4):RTE$AREAS<ONE,TDL(3) + 4> "L#2":SPACE(4):RTE$AREA.TAX.NAMES<ONE,TDL(3) + 4> "L#30"
PRINT SPACE(4):RTE$AREAS<ONE,TDL(3) + 5> "L#2":SPACE(4):RTE$AREA.TAX.NAMES<ONE,TDL(3) + 5> "L#30"
PRINT SPACE(4):RTE$AREAS<ONE,TDL(3) + 6> "L#2":SPACE(4):RTE$AREA.TAX.NAMES<ONE,TDL(3) + 6> "L#30"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PVM.EVENT.NUMS~
SUBROUTINE SH.SUBR.LPT.MAINT.PVM.EVENT.NUMS(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                          PPV Event Number Maintenance" "L#80"
PRINT 
PRINT "Event:" "L#6":SPACE(2):PVM.ID.SAVE<1> "L#6":SPACE(2):PVM$DESC "L#25":SPACE(6):PVM$CL "L#6"
PRINT SPACE(55):"Defaults:" "L#9"
PRINT SPACE(52):PVM$RATE.CL "L#6":SPACE(4):PVM$RATE.CL.SUB "L#6"
PRINT "Sched. (YYMM):" "L#14":SPACE(2):PVM$PROGMO "L#4":SPACE(9):"Ln#" "L#3":SPACE(1):"..Date..." "L#9":SPACE(2):".Time" "L#5":SPACE(2):"Rate Cl." "L#8":SPACE(2):"Sub. Cl." "L#8":SPACE(3):"Event#" "L#6"
PRINT "Distributor:" "L#14":SPACE(2):PVM$DISTR "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 0)):TDL(1) + 0:" ":PVM$PVE.DT<ONE,TDL(1) + 0> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 0> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 0> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 0> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 0> "L#4"
PRINT "Studio:" "L#14":SPACE(2):PVM$STUDIO "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 1)):TDL(1) + 1:" ":PVM$PVE.DT<ONE,TDL(1) + 1> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 1> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 1> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 1> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 1> "L#4"
PRINT "Channel Code:" "L#14":SPACE(2):PVM$CH.CODE "L#3":SPACE(14):SPACE(TWO - LEN(TDL(1) + 2)):TDL(1) + 2:" ":PVM$PVE.DT<ONE,TDL(1) + 2> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 2> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 2> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 2> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 2> "L#4"
PRINT "Duration:" "L#14":SPACE(2):OCONV(PVM$DUR,"MT") "L#5":SPACE(12):SPACE(TWO - LEN(TDL(1) + 3)):TDL(1) + 3:" ":PVM$PVE.DT<ONE,TDL(1) + 3> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 3> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 3> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 3> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 3> "L#4"
PRINT "Debut Date:" "L#14":SPACE(2):OCONV(PVM$DEBUT.DT,"D2") "L#9":SPACE(8):SPACE(TWO - LEN(TDL(1) + 4)):TDL(1) + 4:" ":PVM$PVE.DT<ONE,TDL(1) + 4> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 4> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 4> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 4> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 4> "L#4"
PRINT "Prog Class:" "L#14":SPACE(2):PVM$PROG.CL "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 5)):TDL(1) + 5:" ":PVM$PVE.DT<ONE,TDL(1) + 5> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 5> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 5> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 5> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 5> "L#4"
PRINT "Mrkt Class:" "L#14":SPACE(2):PVM$MRKT.CL "L#6":SPACE(11):SPACE(TWO - LEN(TDL(1) + 6)):TDL(1) + 6:" ":PVM$PVE.DT<ONE,TDL(1) + 6> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 6> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 6> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 6> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 6> "L#4"
PRINT "Star Rating:" "L#14":SPACE(2):PVM$STARS "L#1":SPACE(16):SPACE(TWO - LEN(TDL(1) + 7)):TDL(1) + 7:" ":PVM$PVE.DT<ONE,TDL(1) + 7> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 7> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 7> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 7> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 7> "L#4"
PRINT "Guide Rating:" "L#14":SPACE(2):PVM$RATING "L#5":SPACE(12):SPACE(TWO - LEN(TDL(1) + 8)):TDL(1) + 8:" ":PVM$PVE.DT<ONE,TDL(1) + 8> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 8> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 8> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 8> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 8> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 9)):TDL(1) + 9:" ":PVM$PVE.DT<ONE,TDL(1) + 9> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 9> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 9> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 9> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 9> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 10)):TDL(1) + 10:" ":PVM$PVE.DT<ONE,TDL(1) + 10> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 10> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 10> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 10> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 10> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 11)):TDL(1) + 11:" ":PVM$PVE.DT<ONE,TDL(1) + 11> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 11> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 11> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 11> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 11> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 12)):TDL(1) + 12:" ":PVM$PVE.DT<ONE,TDL(1) + 12> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 12> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 12> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 12> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 12> "L#4"
PRINT SPACE(33):SPACE(TWO - LEN(TDL(1) + 13)):TDL(1) + 13:" ":PVM$PVE.DT<ONE,TDL(1) + 13> "L#9":SPACE(2):PVM$PVE.TM<ONE,TDL(1) + 13> "L#5":SPACE(3):PVM$PVE.RATE.CL<ONE,TDL(1) + 13> "L#6":SPACE(4):PVM$PVE.RATE.CL.SUB<ONE,TDL(1) + 13> "L#6":SPACE(5):PVM$EVENT.NUMS<ONE,TDL(1) + 13> "L#4"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PVM.PVE.XREF~
SUBROUTINE SH.SUBR.LPT.MAINT.PVM.PVE.XREF(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "DS":AM:"EV"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                          Event Master Detail Listing" "L#80"
PRINT 
PRINT "Event" "L#6":SPACE(2):PVM.ID.SAVE<1> "L#8"
PRINT "DS> Description" "L#15":SPACE(1):PVM$DESC "L#25"
PRINT 
PRINT 
PRINT 
PRINT 
PRINT SPACE(16):"EV>" "L#4":"..Date..." "L#9":SPACE(1):"..Time..." "L#9":SPACE(1):"Component" "L#9":SPACE(1):"Duration." "L#9":SPACE(1):"PVE.Event" "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 0> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 0> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 0> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 0> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 0> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 0> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 1> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 1> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 1> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 1> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 1> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 1> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 2> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 2> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 2> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 2> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 2> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 2> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 3> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 3> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 3> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 3> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 3> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 3> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 4> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 4> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 4> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 4> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 4> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 4> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 5> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 5> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 5> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 5> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 5> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 5> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 6> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 6> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 6> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 6> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 6> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 6> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 7> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 7> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 7> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 7> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 7> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 7> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 8> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 8> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 8> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 8> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 8> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 8> "L#9"
PRINT SPACE(4):PVM$PVE.XREF<ONE,TDL(2) + 9> "L#0":SPACE(16):PVM$PVE.DT<ONE,TDL(2) + 9> "L#9":SPACE(1):PVM$PVE.TM<ONE,TDL(2) + 9> "L#8":SPACE(2):PVM$PVE.COMP<ONE,TDL(2) + 9> "L#8":SPACE(2):PVM$PVE.ELP.TM<ONE,TDL(2) + 9> "L#8":SPACE(2):PVM$PVE.ID<ONE,TDL(2) + 9> "L#9"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.PVM.XREF~
SUBROUTINE SH.SUBR.LPT.MAINT.PVM.XREF(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(13); MAT TDL = EMPTY
DIM TDH(13); MAT TDH = EMPTY
DIM TDI(13); MAT TDI = EMPTY
DIM TDX(13); MAT TDX = ONE
DIM SAVE.TDX(13); MAT SAVE.TDX = EMPTY
DIM TDM(13); MAT TDM = EMPTY
DIM TDS(13); MAT TDS = EMPTY
DIM TDR(13); MAT TDR = EMPTY
DIM TDC(13); MAT TDC = EMPTY
DIM TDT(13); MAT TDT = EMPTY
VALID.REFS = "DE":AM:"DB":AM:"PU":AM:"ST":AM:"CO":AM:"CL":AM:"SC":AM:"MC":AM:"RC":AM:"RS":AM:"RA":AM:"TA":AM:"CO"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                         Service Components Maintenance" "L#80"
PRINT 
PRINT "Event" "L#6":SPACE(2):COM.ID.SAVE<1> "L#8"
PRINT "DE> Description" "L#15":SPACE(1):COM$DESC "L#25"
PRINT SPACE(55):"DB> Debut" "L#10":OCONV(COM<5>,"MR2ZM") "L#10":OCONV(COM$DEBUT.DT,"D2") "L#10"
PRINT "CL>       Class" "L#15":SPACE(1):COM$CL "L#8":SPACE(31):"PU> Purge" "L#10":COM<6> "L#10":OCONV(COM$PURGE.DT,"D2") "L#10"
PRINT "SC>   Sub-Class" "L#15":SPACE(1):COM$PROG.CL "L#8":SPACE(31):"ST> Studio" "L#10":SPACE(1):COM$DISTR "L#8"
PRINT "MC> Mrkt Class" "L#15":SPACE(1):COM$MRKT.CL "L#8"
PRINT SPACE(55):"CO>mponent" "L#10":SPACE(1):COM$COMP "L#8"
PRINT "Component Programmers Showing Event" "L#50":COM$RATE.CL "L#8"
PRINT "Component" "L#12":SPACE(2):"Ch#" "L#4":"Description" "L#25":COM$RATE.CL.SUB "L#8":"Programmer" "L#10"
PRINT SPACE(4):COM<10,TDL(13) + 0> "L#8":SPACE(6):COM<10,TDL(13) + 0> "L#25"
PRINT SPACE(4):COM<10,TDL(13) + 1> "L#8":SPACE(6):COM<10,TDL(13) + 1> "L#25"
PRINT SPACE(4):COM<10,TDL(13) + 2> "L#8":SPACE(6):COM<10,TDL(13) + 2> "L#25"
PRINT SPACE(4):COM<10,TDL(13) + 3> "L#8":SPACE(6):COM<10,TDL(13) + 3> "L#25"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.SERVICE.CHANNELS~
SUBROUTINE SH.SUBR.LPT.MAINT.SERVICE.CHANNELS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "CLO":AM:"CHI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                           Service Component Channels" "L#80"
PRINT 
PRINT "Service" "L#7":SPACE(3):PAR.ID.SAVE<1> "L#8"
PRINT "Component" "L#9":SPACE(1):PAR.ID.SAVE<3> "L#5"
PRINT 
PRINT SPACE(10):"       Channel / Tag Number Cross Reference" "L#50"
PRINT 
PRINT 
PRINT 
PRINT 
PRINT SPACE(10):PAR<3> "L#50"
PRINT SPACE(10):"         1         2         3         4         5" "L#50"
PRINT SPACE(10):"12345678901234567890123456789012345678901234567890" "L#50"
PRINT 
PRINT 
PRINT SPACE(10):"                Channels 51 to 100" "L#50"
PRINT SPACE(10):PAR<4> "L#50"
PRINT SPACE(10):"5        6         7         8         9         0" "L#50"
PRINT SPACE(10):"12345678901234567890123456789012345678901234567890" "L#50"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.SERVICE.TIERS~
SUBROUTINE SH.SUBR.LPT.MAINT.SERVICE.TIERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                         Service Components Maintenance" "L#80"
PRINT 
PRINT 
PRINT "Component" "L#9":SPACE(3):"Description" "L#11":SPACE(17):"Channel number(s)" "L#17":SPACE(3):"Parental control" "L#16"
PRINT PAR<1,TDL(1) + 0> "L#6":SPACE(6):PAR<2,TDL(1) + 0> "L#25":SPACE(3):PAR<3,TDL(1) + 0> "L#17":SPACE(3):PAR<4,TDL(1) + 0> "L#16"
PRINT PAR<1,TDL(1) + 1> "L#6":SPACE(6):PAR<2,TDL(1) + 1> "L#25":SPACE(3):PAR<3,TDL(1) + 1> "L#17":SPACE(3):PAR<4,TDL(1) + 1> "L#16"
PRINT PAR<1,TDL(1) + 2> "L#6":SPACE(6):PAR<2,TDL(1) + 2> "L#25":SPACE(3):PAR<3,TDL(1) + 2> "L#17":SPACE(3):PAR<4,TDL(1) + 2> "L#16"
PRINT PAR<1,TDL(1) + 3> "L#6":SPACE(6):PAR<2,TDL(1) + 3> "L#25":SPACE(3):PAR<3,TDL(1) + 3> "L#17":SPACE(3):PAR<4,TDL(1) + 3> "L#16"
PRINT PAR<1,TDL(1) + 4> "L#6":SPACE(6):PAR<2,TDL(1) + 4> "L#25":SPACE(3):PAR<3,TDL(1) + 4> "L#17":SPACE(3):PAR<4,TDL(1) + 4> "L#16"
PRINT PAR<1,TDL(1) + 5> "L#6":SPACE(6):PAR<2,TDL(1) + 5> "L#25":SPACE(3):PAR<3,TDL(1) + 5> "L#17":SPACE(3):PAR<4,TDL(1) + 5> "L#16"
PRINT PAR<1,TDL(1) + 6> "L#6":SPACE(6):PAR<2,TDL(1) + 6> "L#25":SPACE(3):PAR<3,TDL(1) + 6> "L#17":SPACE(3):PAR<4,TDL(1) + 6> "L#16"
PRINT PAR<1,TDL(1) + 7> "L#6":SPACE(6):PAR<2,TDL(1) + 7> "L#25":SPACE(3):PAR<3,TDL(1) + 7> "L#17":SPACE(3):PAR<4,TDL(1) + 7> "L#16"
PRINT PAR<1,TDL(1) + 8> "L#6":SPACE(6):PAR<2,TDL(1) + 8> "L#25":SPACE(3):PAR<3,TDL(1) + 8> "L#17":SPACE(3):PAR<4,TDL(1) + 8> "L#16"
PRINT PAR<1,TDL(1) + 9> "L#6":SPACE(6):PAR<2,TDL(1) + 9> "L#25":SPACE(3):PAR<3,TDL(1) + 9> "L#17":SPACE(3):PAR<4,TDL(1) + 9> "L#16"
PRINT PAR<1,TDL(1) + 10> "L#6":SPACE(6):PAR<2,TDL(1) + 10> "L#25":SPACE(3):PAR<3,TDL(1) + 10> "L#17":SPACE(3):PAR<4,TDL(1) + 10> "L#16"
PRINT PAR<1,TDL(1) + 11> "L#6":SPACE(6):PAR<2,TDL(1) + 11> "L#25":SPACE(3):PAR<3,TDL(1) + 11> "L#17":SPACE(3):PAR<4,TDL(1) + 11> "L#16"
PRINT PAR<1,TDL(1) + 12> "L#6":SPACE(6):PAR<2,TDL(1) + 12> "L#25":SPACE(3):PAR<3,TDL(1) + 12> "L#17":SPACE(3):PAR<4,TDL(1) + 12> "L#16"
PRINT PAR<1,TDL(1) + 13> "L#6":SPACE(6):PAR<2,TDL(1) + 13> "L#25":SPACE(3):PAR<3,TDL(1) + 13> "L#17":SPACE(3):PAR<4,TDL(1) + 13> "L#16"
PRINT PAR<1,TDL(1) + 14> "L#6":SPACE(6):PAR<2,TDL(1) + 14> "L#25":SPACE(3):PAR<3,TDL(1) + 14> "L#17":SPACE(3):PAR<4,TDL(1) + 14> "L#16"
PRINT PAR<1,TDL(1) + 15> "L#6":SPACE(6):PAR<2,TDL(1) + 15> "L#25":SPACE(3):PAR<3,TDL(1) + 15> "L#17":SPACE(3):PAR<4,TDL(1) + 15> "L#16"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.SUPPLIERS~
SUBROUTINE SH.SUBR.LPT.MAINT.SUPPLIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SU"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                       Component Programmers Maintenance" "L#80"
PRINT 
PRINT "Programmer" "L#10":SPACE(2):"Component" "L#9":SPACE(1):"Programmer" "L#30":SPACE(2):"Component" "L#25"
PRINT "  Code" "L#8":SPACE(4):"  Name" "L#9":SPACE(1):"Description" "L#30":SPACE(2):"Description" "L#25"
PRINT SPACE(1):COM<1,TDL(1) + 0> "L#8":SPACE(3):COM<3,TDL(1) + 0> "L#8":SPACE(2):COM<2,TDL(1) + 0> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 1> "L#8":SPACE(3):COM<3,TDL(1) + 1> "L#8":SPACE(2):COM<2,TDL(1) + 1> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 2> "L#8":SPACE(3):COM<3,TDL(1) + 2> "L#8":SPACE(2):COM<2,TDL(1) + 2> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 3> "L#8":SPACE(3):COM<3,TDL(1) + 3> "L#8":SPACE(2):COM<2,TDL(1) + 3> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 4> "L#8":SPACE(3):COM<3,TDL(1) + 4> "L#8":SPACE(2):COM<2,TDL(1) + 4> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 5> "L#8":SPACE(3):COM<3,TDL(1) + 5> "L#8":SPACE(2):COM<2,TDL(1) + 5> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 6> "L#8":SPACE(3):COM<3,TDL(1) + 6> "L#8":SPACE(2):COM<2,TDL(1) + 6> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 7> "L#8":SPACE(3):COM<3,TDL(1) + 7> "L#8":SPACE(2):COM<2,TDL(1) + 7> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 8> "L#8":SPACE(3):COM<3,TDL(1) + 8> "L#8":SPACE(2):COM<2,TDL(1) + 8> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 9> "L#8":SPACE(3):COM<3,TDL(1) + 9> "L#8":SPACE(2):COM<2,TDL(1) + 9> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 10> "L#8":SPACE(3):COM<3,TDL(1) + 10> "L#8":SPACE(2):COM<2,TDL(1) + 10> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 11> "L#8":SPACE(3):COM<3,TDL(1) + 11> "L#8":SPACE(2):COM<2,TDL(1) + 11> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 12> "L#8":SPACE(3):COM<3,TDL(1) + 12> "L#8":SPACE(2):COM<2,TDL(1) + 12> "L#30"
PRINT SPACE(1):COM<1,TDL(1) + 13> "L#8":SPACE(3):COM<3,TDL(1) + 13> "L#8":SPACE(2):COM<2,TDL(1) + 13> "L#30"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.LPT.MAINT.TIERS~
SUBROUTINE SH.SUBR.LPT.MAINT.TIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*REF.LNS*
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "CLO":AM:"CHI"
*REF.END*
*
!
*
*REF.END*
*
CO.NAME = CO.DATA<ONE>
*
!
*
*
IF LPT.FL THEN
CALL LPT.SUBR.ON(LPT.STAT)
END
*
IF LPT.FL THEN
PRINT FF:
END ELSE
PRINT @(0,0):CLS:
IF REDISP THEN REDISP = FALSE
END
*
PRINT OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#11"
PRINT "                       AI Tier to Channel Cross-reference" "L#80"
PRINT 
PRINT SPACE(27):COM.ID.SAVE<2> "L#8"
PRINT "                  Tier" "L#25":SPACE(2):COM.ID.SAVE<4> "L#5"
PRINT 
PRINT SPACE(10):"       Channel / Tag Number Cross Reference" "L#50"
PRINT 
PRINT 
PRINT 
PRINT 
PRINT SPACE(10):"                 Channels 1 to 50" "L#50"
PRINT SPACE(10):"         1         2         3         4         5" "L#50"
PRINT SPACE(10):"12345678901234567890123456789012345678901234567890" "L#50"
PRINT SPACE(10):COM<1> "L#50"
PRINT 
PRINT SPACE(10):"                Channels 51 to 100" "L#50"
PRINT SPACE(10):"                                                 1" "L#50"
PRINT SPACE(10):"5        6         7         8         9         0" "L#50"
PRINT SPACE(10):"12345678901234567890123456789012345678901234567890" "L#50"
PRINT SPACE(10):COM<2> "L#50"
*
IF LPT.FL THEN
CALL LPT.SUBR.OFF(LPT.STAT)
CALL LPT.SUBR.CLOSE(LPT.STAT)
END
*
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.MAINT.AI.ERRORS~
SUBROUTINE SH.SUBR.MAINT.AI.ERRORS(TDL.REC,XYZ.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LOCKS.FILE)
*PROGRAM:           SH.MAINT.AI.ERRORS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 17:41:33
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
* INPUT DISP.ONLY:
* AUTO.RUN = 0
* INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "SH.SUBR.MAINT.AI.ERRORS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.AI.ERRORS"
*ID.END*
*
SYS.PROG.TYPE = "SUBR"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
0
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.AI.ERRORS(TDL.REC,XYZ.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
* PORT.KEY = PORT
* LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
* READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
* READ GENERIC FROM COM.FILE,"GENERIC" ELSE
* IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
* END
* END
* READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
* 
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND .ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN .ID.SAVE = EMPTY
END ELSE
.ID = EMPTY; .ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF .ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
RETURN
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE 0.FILE,.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*

UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
RETURN
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = .ID
FOR ID.CN = ONE TO 0; .ID.SAVE<ID.CN> = "!":.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
.ID = TEMP
END
*
*
!
*
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
FOR ID.CN = ONE TO 0
ON ID.CN GOSUB 
IF STAT EQ 999 THEN RETURN
IF REDISP EQ TRUE THEN GOSUB DISP.BG; GOSUB DISP.FG; STAT = ONE
IF STAT THEN IF STAT GT ZERO THEN ID.CN = ID.CN - ONE ELSE ID.CN = ID.CN - TWO; IF ID.CN LT ZERO THEN STAT = 999; RETURN
IF ID.CN EQ 0 AND .ID.SAVE<0> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN RETURN
NEXT ID.CN
*

* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.AI.ERRORS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.AI.ERRORS(TDL.REC,XYZ.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB 
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*

*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.SUBR.MAINT.BARKERS~
SUBROUTINE SH.SUBR.MAINT.BARKERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*PROGRAM:           SH.MAINT.BARKERS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:07:27
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
* INPUT DISP.ONLY:
* AUTO.RUN = 0
* INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "SH.SUBR.MAINT.BARKERS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.BARKERS"
*ID.END*
*
SYS.PROG.TYPE = "SUBR"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.BARKERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
* PORT.KEY = PORT
* LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
* READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
* READ GENERIC FROM COM.FILE,"GENERIC" ELSE
* IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
* END
* END
* READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
* PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SC"
TDC(1) = 16
TDT(1) = 5
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
RETURN
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
RETURN
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                           Barker Channel Maintenance                           ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"Short name":RVE:"  ":RVB:"Description":RVE:"                 ":RVB:"Channel #":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 1; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
PAR.ID = "BARKER.CHANNELS"
PAR.ID.SAVE<ONE> = "BARKER.CHANNELS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.BARKERS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.BARKERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PAR","1",FLD,19,23,"L6","6","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,19,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PAR<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 3
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 3
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PAR<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PAR<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PAR<1,VC>
INS EMPTY BEFORE PAR<2,VC>
INS EMPTY BEFORE PAR<3,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PAR<1,VC>
DEL PAR<2,VC>
DEL PAR<3,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("PAR","1",PAR,0,LN,"L6","6",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("PAR","2",PAR,12,LN,"L25","25",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,12,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("PAR","3",PAR,40,LN,"L2","2",3:",":VC,"","OP":VM:"MA":SVM:"0N":VM:"LO":SVM:"1","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,40,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PAR<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PAR<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
PRINT @(12,LN):PAR<2,VC> "L#25":
PRINT @(40,LN):PAR<3,VC> "L#2":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(6):
PRINT @(12,LN.TMP):SPACE(25):
PRINT @(40,LN.TMP):SPACE(2):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.SUBR.MAINT.PPV.EVENT~
SUBROUTINE SH.SUBR.MAINT.PPV.EVENT(TDL.REC,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LCK.FILE)
*PROGRAM:           SH.MAINT.PPV.EVENT
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      18 DEC 95 17:28:32
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
*
*INPUT.LNS*
* INPUT DISP.ONLY:
* AUTO.RUN = 0
* INPUT AUTO.RUN:
*INPUT.END*
*
*
SCR.ID = "MAINT.PPV.EVENT"
RELEASE.ID = ""
REF = ONE; REDISP = FALSE; NEW = FALSE
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
*
OPEN "COM" TO COM.FILE ELSE
PRINT CLB:"COM File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "CNT" TO CNT.FILE ELSE
PRINT CLB:"CNT File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
OPEN "PAR" TO PAR.FILE ELSE
PRINT CLB:"PAR File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE
PRINT CLB:"ACC File missing! ":
IF NOT(AUTO.RUN) THEN PRINT "Enter <cr> . . . ":; INPUT TMP:
STOP
END
*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = "MENU"; SYS.PROG = "MENU.HANDLER"; SYS.LOC = EMPTY
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*
0
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "LOCKS" TO LCK.FILE ELSE TEXT = "Can't open LOCKS"; GOSUB ERROR; STOP; * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.PPV.EVENT(TDL.REC,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LCK.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
* PORT.KEY = PORT
* LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
* READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
* READ GENERIC FROM COM.FILE,"GENERIC" ELSE
* IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
* END
* END
* READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
*MAIN.LNS*
NEXT.ITEM: *
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
.ID = EMPTY; .ID.SAVE = EMPTY; GOSUB GET.KEY
IF .ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 THEN GOTO FINISH
IF NOT(DISP.ONLY) THEN
LOOP
CALL LOCK.ITEM(.FILE,"",.ID,LCK.FILE,LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
READ  FROM .FILE,.ID THEN NEW = FALSE ELSE NEW = TRUE;  = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO NEXT.ITEM
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = ZERO
NEXT REF
NEW = EMPTY
END
*
!
*
CHANGES: *
TEXT = "Enter DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE .FILE,.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*
!
*
UPDATE: *
WRITE  ON .FILE,.ID
UPDATED = TRUE
*
!
*
UNLOCK: *
CALL UNLOCK.ITEM(.FILE,"",.ID,LCK.FILE)
*
!
*
FINISH: *
*
*FIN.LNS*
* IF STAT EQ 999 THEN STOP
* GOTO NEXT.ITEM
RETURN
*FIN.END*
*MAIN.END*
*
!
*
DISP.BG: *
*
RETURN
*
!
*
DISP.FG: *
*
IF REDISP THEN
REDISP = 99
TEMP = .ID; FOR ID.CN = ONE TO 1; .ID.SAVE<ID.CN> = "!":.ID.SAVE<ID.CN>; NEXT ID.CN; GOSUB GET.KEY; .ID = TEMP
END
*
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+MAINT.PPV.EVENT: ":.ID
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.PPV.EVENT(TDL.REC,ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LCK.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE
ON REF GOSUB 
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*

*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.SUBR.MAINT.SERVICE.TIERS~
SUBROUTINE SH.SUBR.MAINT.SERVICE.TIERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*PROGRAM:           SH.MAINT.SERVICE.TIERS
* AUTHOR:            XXX
* DESCRIPTION: GENERATED BY "SOURCEGEN" AND "ENTITY.INFO"
*                              (Axion)        (Macroscope)
*VS 12 JUL 96 ()
*  UTILITY PRODUCT BY Axion Computer Systems
*                              &
*                 Macroscope Design Matrix
*
!
*
* DATE WRITTEN:      12 JUL 96 18:52:08
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
*
*FUNC.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*FUNC.END*
*
!
*
*SEC.DIM*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*SEC.DIM.END*
*
*MNU.DIM*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*MNU.DIM.END*
*
*TST.DIM*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*TST.DIM.END*
*
!
*
*INPUT.LNS*
* INPUT DISP.ONLY:
* AUTO.RUN = 0
* INPUT AUTO.RUN:
*INPUT.END*
*
*SYS.LNS*
*ID.LNS*
SYS = EMPTY; SYS.APPL = "SYS"
SYS.APPL.SUB = ""
SYS.PROG = "SH.SUBR.MAINT.SERVICE.TIERS"
SYS.LOCT = "INIT"
LCK = EMPTY; LCK.ID = EMPTY; OPER = EMPTY; LCK.EXP.TM = EMPTY
LCK.FIL.ID = EMPTY; LCK.ITM.ID = EMPTY
LCK.TYPE = -3; LCK.STAT = FALSE; LCK.ELP = ZERO
*
SCR.ID = "MAINT.SERVICE.TIERS"
*ID.END*
*
SYS.PROG.TYPE = "SUBR"
RELEASE.ID = ""
DT = DATE(); TM = TIME(); ELP = ZERO
*SYS.END*
*
*CNTR.LNS*
*
*CNTR.VAR.LNS*
REF = ONE; REDISP = FALSE; LN.REDISP = FALSE; NEW = FALSE
DYN = EMPTY; SAVE.DYN = EMPTY; SAVE.REF = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
LPT.STAT = FALSE; LPT.FL = FALSE
LN.LOC = ZERO; SUB.REF.LOC = ZERO
FIXED = FALSE; NUMC = FALSE
FUNC.VC = ONE; FUNC.VC.OFFSET = ZERO; FUNC.LN = 23; FUNC.CL = ZERO
*CNTR.VAR.END*
*
*COM.LNS*
OPEN "COM" TO COM.FILE ELSE FILE.NAME = "COM"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*COM.END*
*
*CNT.LNS*
OPEN "CNT" TO CNT.FILE ELSE FILE.NAME = "CNT"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*CNT.END*
*
*PAR.LNS*
OPEN "PAR" TO PAR.FILE ELSE FILE.NAME = "PAR"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*
*SEC.LNS*
CALL.ID = EMPTY; PORT.KEY = EMPTY
PORT.KEY = (PORT+1000) "R#3"; CALL.ID = "MENU.":PORT.KEY
MATREAD PAR.MENU FROM PAR.FILE,CALL.ID ELSE MAT PAR.MENU = EMPTY
SEC.USER.ID = PAR.MENU$USER
*
CALL COPYWRIGHT(PAR.FILE,MAT PAR.MENU,MAT SEC.USER,SEC.USER.ID,STAT)
*SEC.END*
*PAR.END*
*
*ACC.LNS*
$INCLUDE IBP SYS.INCL.ACC.OPSYS
*
OPEN ACC.FILE.DICT,ACC.FILE.NAME TO ACC.FILE ELSE FILE.NAME = ACC.FILE.DICT:" ":ACC.FILE.NAME; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
*ACC.END*
*
*TST.LNS*
CNT.ID = EMPTY; CNT.TST.ID = SYS.APPL.SUB; CNT.ID.SAVE = EMPTY
GOSUB LOAD.TST; * : *
*TST.END*
*
*CNTR.END*
*
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
*OPEN.LNS
OPEN "SVC" TO SVC.FILE ELSE FILE.NAME = "SVC"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT)
OPEN "LOCKS" TO LCK.FILE ELSE FILE.NAME = "LOCKS"; CALL SYS.SUBR.OPEN.ERR(2,SYS.PROG,FILE.NAME,STAT); * ULT ONLY
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = ZERO; LCK.STAT = FALSE
*OPEN.END*
*
IF NOT(GENERIC) THEN
CALL SH.SUBR.SCR.MAINT.SERVICE.TIERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*REF.LNS*
END ELSE POS.LOC = EMPTY; POS.REF = EMPTY
*
*SCR.LNS*
*SUB.LNS*
* PORT.KEY = PORT
* LOOP WHILE LEN(PORT.KEY) LT 3 DO PORT.KEY = ZERO:PORT.KEY REPEAT
* READ GENERIC FROM COM.FILE,"GENERIC.":PORT.KEY ELSE
* READ GENERIC FROM COM.FILE,"GENERIC" ELSE
* IF OPSYS EQ "U" OR OPSYS EQ "M" THEN GENERIC = TRUE ELSE GENERIC = FALSE
* END
* END
* READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = EMPTY
* PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY
* SVC.ID = EMPTY; SVC.ID.SAVE = EMPTY
*SUB.END*
CO.NAME = CO.DATA<ONE,ONE>
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS.":PORT.KEY ELSE
READ CURSOR.KEYS FROM COM.FILE,"CURSOR.KEYS" ELSE
POS.LOC = EMPTY; POS.REF = EMPTY; CURSOR.KEYS = EMPTY
END
END
*
*SCR.END*
*
*READ.LNS*
I01.MAX = 99
TDM(1) = I01.MAX
TDS(1) = 1
TDR(1) = "SC"
TDC(1) = 16
TDT(1) = 5
*
*
*READ.END*
*
*INIT.LNS*
FIRST = TRUE; AC = EMPTY; VC = EMPTY; SC = EMPTY
INX.LOC = ZERO; INX.FOUND = FALSE
INX.STR = EMPTY; INX.STR.OUT = EMPTY
LN = ZERO; CL = ZERO; CL.LOC = ONE; CL.FIRST = TRUE
LN.HI = ZERO; LN.TMP = ZERO
CLEAR = TRUE
OLD.LN = ZERO; OLD.CL = ZERO; OLD.CL.LOC = ONE
NUMC = FALSE; TC.FILL = "."; MENU.NAME = EMPTY
TC.FUNC = EMPTY; STD.SUBR.NAME = EMPTY; MOD.CONV = EMPTY
STD.FUNC = EMPTY; CLEAR.FLAG = FALSE; RESET.SW = 999
SCR.LOCN = EMPTY; EXEC.VERB = EMPTY; EXEC.DESC = EMPTY
CR.FLAG = TRUE; LOCN = EMPTY
*INIT.END*
*
NEXT.ITEM: *
*MAIN.LNS*
*
STAT = FALSE; UPDATED = FALSE
GOSUB DISP.BG
*ID.INP.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
IF INDEX("6789",TYPE.RUN,ONE) THEN
TMP = FALSE; TMP1 = FALSE
IF TYPE.RUN EQ "8" THEN TMP1 = TRUE
IF TYPE.RUN EQ "8" AND PAR.ID EQ EMPTY THEN TMP = TRUE
IF TYPE.RUN EQ "9" AND NOT(FIRST) THEN TMP1 = TRUE
IF TYPE.RUN EQ "6" THEN TYPE.RUN = "1"
IF TYPE.RUN EQ "7" THEN TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
END ELSE TMP = TRUE; TMP1 = TRUE
IF NOT(TMP) THEN
IF TMP1 THEN PAR.ID.SAVE = EMPTY
END ELSE
PAR.ID = EMPTY; PAR.ID.SAVE = EMPTY; GOSUB GET.KEY
END
IF PAR.ID.SAVE<ONE> EQ EMPTY THEN STAT = 999
IF STAT EQ 999 AND SYS.PROG.TYPE EQ "SUBR" THEN
RETURN
END
IF STAT EQ 999 THEN GOTO FINISH
*ID.INP.END*
*
*FILE.LNS*
*LCK.LNS*1*
IF NOT(DISP.ONLY) THEN
LCK.STAT = LCK.TYPE
LOOP
CALL SYS.ITM.LCK("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
IF LCK.STAT EQ 999 THEN GOTO FINISH
WHILE LCK.STAT DO REPEAT
END
*LCK.END*1*
*
*READ.LNS*1*
READ PAR FROM PAR.FILE,PAR.ID THEN NEW = FALSE ELSE NEW = TRUE; PAR = EMPTY
*READ.END*1*
*
CALL SYS.ITM.RLS("PAR",PAR.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,LCK.EXP.TM,SYS.LOCT,"A","",LCK.STAT)
*FILE.END*
*
*DISP.LNS*
DYN = EMPTY
IF NOT(NEW) THEN
GOSUB DISP.FG; IF STAT EQ 999 THEN GOTO UNLOCK
IF DISP.ONLY THEN
LOOP
PRINT CLB2:"Enter REdisplay, PRinter or <cr> to end: ":
INPUT RSP:
WHILE RSP EQ "RE" OR RSP EQ "PR" DO
IF RSP EQ "RE" THEN
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
END ELSE
LPT.FL = TRUE
GOSUB DISP.LP
LPT.FL = FALSE
END
REPEAT
GOTO FINISH
END
END ELSE
IF DISP.ONLY THEN
PRINT CLB2:"Not on file - hit <cr> to end: ":
INPUT RSP:
GOTO NEXT.ITEM
END
LOOP
PRINT CLB2:"New item - Do you wish to add (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP EQ EMPTY OR RSP EQ "N" THEN GOTO UNLOCK
UNTIL RSP EQ "Y" DO PRINT BELL: REPEAT
FOR REF = ONE TO 1
GOSUB GET.DATA
IF STAT EQ 999 THEN GOTO UNLOCK
IF STAT THEN IF STAT GT ZERO THEN REF = REF - ONE ELSE REF = REF - TWO; IF REF LT ZERO THEN REF = 1
NEXT REF
NEW = EMPTY
END
*DISP.END*
*
*
!
*
CHANGES: *
*CHNG.LNS*
TEXT = "Enter CHange, DElete, REdisplay, PRinter, KILL or <cr> to update: "
PRINT CLB2:TEXT:
IF GENERIC THEN
INPUT RSP:
END ELSE
*
! Accept response from user
*
* If no cursor keys defined or generic
*
* PRINT @(ZERO,22):TEXT[1,75]:
* * ULT ONLY
* CLEARDATA; * REV ONLY
* CLEARSELECT; * REV ONLY
! Standard character input
*
LOOP
*
TC.FUNC = EMPTY; FLD = EMPTY; DEF = EMPTY; CONV = EMPTY
*CLLN = POS.REF<SCR.LOCN>; OLD.CL = CLLN<ONE,ONE> - ONE; OLD.LN = CLLN<ONE,TWO>
*OLD.CL = POS.REF<OLD.LN + ONE,OLD.CL.LOC>
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
IF CL THEN CL = CL - ONE
* LH = "L25"; LHM = 135
LOCN = "1"; MS = EMPTY; NO.PROMPT = FALSE
EDITS = EMPTY; EDIT.FILE = EMPTY
RSP.LN = 22; RSP.CL = LEN(TEXT) + ONE
LHM = 135; LH = 78 - RSP.CL - ONE
IF LH GT 5 THEN LH = 5
*
IF NOT(FIRST) THEN
*
CALL INPUT.DATA.SG1("COM","SCR.RSP",FLD,CL,LN,LH,LHM,LOCN,CONV,EDITS,EDIT.FILE,RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,FIXED,DEF.SUPP,TC.FUNC,RSP.CL,RSP.LN,TC.FILL,STD.SUBR.NAME,PROCBUF,STAT)
*
END ELSE TC.FUNC = "2"; FIRST = FALSE
*
CL.LOC = OLD.CL.LOC; LN = OLD.LN; CL = OLD.CL
*
IF TC.FUNC NE EMPTY THEN
CALL CURSOR.SUBR.POS(TC.FUNC,CL.LOC,CL,LN,OLD.CL.LOC,OLD.CL,OLD.LN,POS.REF,POS.RSP,POS.LOC,ORIG.LN,CL.MAX,LN.MAX,RSP.CL,RSP.LN,MENU.NAME,STD.FUNC,MAT SEC.USER,PAR.FILE,LCK.FILE,CO.DATA,MAT CNT.TST,MAT PAR.MENU,RSP,RSPBUF,PROCBUF,STAT)
IF LEN(EXEC.VERB) THEN
RESET.SW = 999; CR.FLAG = TRUE
GOSUB ENTER.STD.EXEC
EXEC.VERB = EMPTY; RSP = "RE"; TC.FUNC = EMPTY
END
END
*
WHILE TC.FUNC NE "9" AND (TC.FUNC NE EMPTY AND RSP EQ EMPTY) DO REPEAT
*
! Process response
*
RESET.SW = 999; TC.FUNC = EMPTY; TC.OUT = EMPTY
PRINT @(RSP.CL,RSP.LN):RSP MS:
*
END
BEGIN CASE
CASE RSP EQ "KILL"; STAT = 999; GOTO UNLOCK
CASE RSP EQ "END"; GOTO UNLOCK
CASE RSP EQ EMPTY; GOTO UPDATE
CASE RSP EQ "DE"
PRINT CLB2:"Delete - Are you sure (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO UNLOCK
IF RSP NE "Y" THEN GOTO CHANGES
DELETE PAR.FILE,PAR.ID; GOTO UNLOCK
CASE RSP EQ "RE"
GOSUB DISP.BG
DYN = EMPTY; REDISP = 99
GOSUB DISP.FG
CASE RSP EQ "PR"
LPT.FL = TRUE
DYN = EMPTY; REDISP = 99
GOSUB DISP.LP
LPT.FL = FALSE
CASE RSP EQ "CH"; REF = ONE; GOSUB GET.DATA
CASE ONE; LOCATE RSP IN VALID.REFS SETTING REF THEN GOSUB GET.DATA ELSE PRINT BELL:
END CASE
IF STAT EQ 999 THEN GOTO UNLOCK
GOTO CHANGES
*CHNG.END*
*
*
!
*
UPDATE: *
*UPDT.LNS*
*UPDT.LNS*1*
WRITE PAR ON PAR.FILE,PAR.ID
UPDATED = TRUE
*UPDT.END*
*
!
*
UNLOCK: *
*LCK.RELS.LNS*
*
LCK.RELS.1: *
*LCK.RELS.END*1*
*
*LCK.RELS.END*
*
!
*
FINISH: *
*
*FIN.LNS*
IF SYS.PROG.TYPE EQ "SUBR" THEN
RETURN
END ELSE
STOP
END
GOTO NEXT.ITEM
*FIN.END*
*
*MAIN.END*
*
!
*
DISP.BG: *
*
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
CLEAR = FALSE
PRINT @(0,0):CLS:"":RVB:"":OCONV(DATE(),"D2") "L#12":(SPACE(28-(((LEN(CO.NAME) + ONE)/2))):CO.NAME) "L#56":("Port ":PORT) "R#12":"":RVE:"":
PRINT @(0,1):CLS:"":RVB:"                         Service Components Maintenance                         ":RVE:"":
PRINT @(0,4):CLS:"":RVB:"Component":RVE:"   ":RVB:"Description":RVE:"                 ":RVB:"Channel number(s)":RVE:"   ":RVB:"Parental control":RVE:"":
RETURN
*
!
*
DISP.FG: *
*
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF SYS11.FL GE 3 THEN RETURN
IF REDISP THEN
REDISP = 99
TEMP = PAR.ID
FOR ID.CN = ONE TO 1; PAR.ID.SAVE<ID.CN> = "!":PAR.ID.SAVE<ID.CN>; NEXT ID.CN
GOSUB GET.KEY
PAR.ID = TEMP
END
*
IF NOT(REDISP) THEN DYN = EMPTY
GOSUB D01
IF STAT EQ 999 THEN RETURN
*
REDISP = FALSE
*
RETURN
*
!
*
GET.KEY: *
*
STAT = ZERO
*
PAR.ID = "COMPONENTS"
PAR.ID.SAVE<ONE> = "COMPONENTS"
* ULT ONLY
EXEC.VERB = "ACC.UPDATE"
* ULT ONLY
EXEC.IN = "+Rtn:MAINT.SERVICE.TIERS +Itm:":0
* ULT ONLY
EXECUTE EXEC.VERB, //IN. < EXEC.IN
EXEC.VERB = EMPTY
*
*
RETURN
*
!
*
DISP.LP: *
*
*
!
*
CALL SH.SUBR.LPT.MAINT.SERVICE.TIERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE)
*
!
*
*
RETURN
*
!
*
GET.DATA: *
NUMC = TRUE; DYN = EMPTY; SAVE.DYN = EMPTY
REFLN = EMPTY; SAVE.REFLN = EMPTY
ON REF GOSUB I01
NUMC = FALSE
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO GET.DATA
RETURN
*
!
*
*
!
*
VTY.INP.SRT: *
*
*
IF LN.LOC THEN
INX.LOC = TDL(REF); IF INX.LOC THEN INX.LOC = INX.LOC - ONE
INX.LOC = INX.LOC + LN.LOC
ON REF GOSUB Y01
FLD = INX.STR
LN.LOC = ZERO
END ELSE FLD = EMPTY
*
IF FLD EQ EMPTY THEN
*
PRINT CLB:"Enter ":TDR(REF):": ":
ON REF GOSUB I01.KEY
*
IF STAT EQ 999 THEN RETURN
INX.STR = FLD
IF REDISP THEN
GOSUB DISP.BG; GOSUB DISP.FG
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF STAT THEN
TEXT = RSP<TWO>; GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
*
IF FLD EQ EMPTY THEN
DYN = EMPTY
ON REF GOSUB D01
RETURN
END
*
END
*
INX.STR = FLD
ON REF GOSUB X01
IF INX.FOUND THEN
PRINT CLB:FLD.OUT:" - Delete it (Y/<cr>)? ":
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; RETURN
IF RSP NE "Y" THEN
DYN = EMPTY
PRINT CLB:
DYN = "E"
ON REF GOSUB D01
END ELSE
ON REF GOSUB R01
TDI(REF) = TDI(REF) - ONE
DYN = "D"
ON REF GOSUB D01
IF STAT EQ 999 THEN RETURN
LN.LOC = ZERO
GOTO VTY.INP.SRT; * : *
END
END ELSE
IF INX.STR EQ EMPTY THEN DYN = "N" ELSE DYN = "I"
*
IF INX.LOC GT TDM(REF) THEN
IF NEW AND DNY EQ "N" THEN FLD = EMPTY; RETURN
TEXT = "Max. entries allowed is ":TDM(REF); GOSUB ERROR
GOTO VTY.INP.SRT.EXIT; * : *
END
ON REF GOSUB A01
IF DYN NE "I" THEN
IF NOT(TDL(REF)) THEN TDL(REF) = ONE
END
END
IF STAT EQ 999 THEN RETURN
*
LN = MOD(INX.LOC - ONE,TDC(REF)) + TDT(REF)
IF DYN EQ "I" OR DYN EQ "N" THEN
LN.REDISP = TRUE
ON REF GOSUB D01
END
*
VTY.INP.SRT.EXIT: *
*
RETURN
*
*
I01.KEY: *
*
FLD = EMPTY
CALL INPUT.DATA.SG1("PAR","1",FLD,18,23,"L6","6","1","","SE":VM:"OP","",FLD,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,18,23,".",STD.SUBR.NAME,PROCBUF,STAT)
FLD.OUT = FLD
*
RETURN
*
*
I01: *
*
TDI(REF) = DCOUNT(PAR<1>,VM)
TDL.REF = 1; GOSUB VTY.INP.SRT; * : *
*
IF STAT THEN RETURN
IF FLD EQ EMPTY THEN RETURN
*
VC = TDX(REF); INX.LOC = TDX(REF)
*
!
*
I01.INP: *
*
FOR SUB.REF = 2 TO 4
IF SUB.REF GE SUB.REF.LOC - 1 THEN
ON SUB.REF GOSUB I01A,I01B,I01C,I01D
TC.FUNC = EMPTY; TC.OUT = EMPTY
IF STAT EQ 999 THEN RETURN
IF SUB.REF EQ ONE AND RSP EQ EMPTY AND STAT LE ZERO THEN
IF SAVE.DYN EQ "I" OR SAVE.DYN EQ "N" THEN
ON REF GOSUB R01
SAVE.DYN = EMPTY; SAVE.REFLN = EMPTY
IF TDX(REF) LE TDI(REF) THEN
GOSUB D01
END
RETURN
END
END
IF STAT THEN
IF STAT GT ZERO THEN SUB.REF = SUB.REF - ONE ELSE SUB.REF = SUB.REF - TWO
IF SUB.REF LT 2 THEN SUB.REF = 4
END
SUB.REF.LOC = ZERO
END
NEXT SUB.REF
SUB.REF.LOC = ZERO
*
IF DYN EQ "I" OR DYN EQ "N" THEN TDI(REF) = TDI(REF) + ONE
IF DYN EQ "I" THEN
IF TDX(REF) LT TDI(REF) THEN
GOSUB D01
END
IF STAT EQ 999 THEN RETURN
END
*
IF NOT(STAT) THEN GOTO I01
*
RETURN
*
*
X01: *
*
LOCATE INX.STR IN PAR<1> BY "AL" SETTING INX.LOC THEN
INX.FOUND = TRUE
END ELSE
INX.FOUND = FALSE
END
TDX(REF) = INX.LOC; VC = TDX(REF)
*
RETURN
*
*
Y01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INX.STR = PAR<1,VC>
INX.STR.OUT = INX.STR
*
RETURN
*
*
!
*
A01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
INS FLD BEFORE PAR<1,VC>
INS EMPTY BEFORE PAR<2,VC>
INS EMPTY BEFORE PAR<3,VC>
INS EMPTY BEFORE PAR<4,VC>
*
RETURN
*
!
*
R01: *
*
TDX(REF) = INX.LOC; VC = TDX(REF)
DEL PAR<1,VC>
DEL PAR<2,VC>
DEL PAR<3,VC>
DEL PAR<4,VC>
*
RETURN
*
I01A: *
*
CALL INPUT.DATA.SG1("PAR","1",PAR,0,LN,"L6","6",1:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,1,"0",TC.FUNC,0,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01A
RETURN
*
I01B: *
*
CALL INPUT.DATA.SG1("PAR","2",PAR,12,LN,"L25","25",2:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,12,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01B
RETURN
*
I01C: *
*
CALL INPUT.DATA.SG1("PAR","3",PAR,40,LN,"L17","17",3:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,40,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01C
RETURN
*
I01D: *
*
CALL INPUT.DATA.SG1("PAR","4",PAR,60,LN,"L16","16",4:",":VC,"","","",RSP,RSPBUF,RSPLOG,TRC,TM.MAX,REDISP,TT,PT,SEC.USER.ID,GENERIC,CURSOR.KEYS,NUMC,0,"0",TC.FUNC,60,LN,".",STD.SUBR.NAME,PROCBUF,STAT)
IF REDISP THEN GOSUB DISP.BG; GOSUB DISP.FG; GOTO I01D
RETURN
*
D01: *
*
SAVE.REF = REF; REF = 01
SAVE.TDX(REF) = TDX(REF); SAVE.LN = LN
TDI(REF) = DCOUNT(PAR<1>,VM)
*
IF TDX(REF) GE TDL(REF) AND TDX(REF) LE TDL(REF) + TDC(REF) - ONE THEN TDL.OK = TRUE ELSE TDL.OK = FALSE
*
BEGIN CASE
*
CASE REDISP OR NOT(TDL(REF))
LN.START = TDT(REF)
IF TDL(REF) LT ONE THEN TDL(REF) = ONE
TDX(REF) = TDL(REF)
TDL.OK = FALSE
*
CASE NOT(TDL.OK)
LN.START = TDT(REF)
TDL(REF) = TDX(REF) - MOD(TDX(REF) - ONE,TDC(REF))
TDX(REF) = TDL(REF)
*
CASE DYN EQ "N" OR DYN EQ "E" OR LN.REDISP
LN = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
LN.REDISP = FALSE
GOTO D01.EXIT
CASE DYN EQ "I" OR DYN EQ "D"
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
TDL.OK = FALSE
*
*
CASE DYN EQ EMPTY
LN.START = MOD(TDX(REF) - ONE,TDC(REF)) + TDT(REF)
*
CASE TRUE
GOTO D01.EXIT
*
END CASE
*
IF TDX(REF) LT ONE THEN TDX(REF) = ONE
*
LOOP
*
LN = LN.START
*
LOOP
*
VC = TDX(REF)
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
WHILE LN LE TDT(REF) + TDC(REF) - ONE AND PAR<1,VC> NE EMPTY AND SYS11.FL LT 3 DO
*
IF LN EQ TDT(REF) THEN TDL(REF) = TDX(REF)
IF NOT(TDL.OK) THEN
VC = TDX(REF)
PRINT @(0,LN):PAR<1,VC> "L#6":
PRINT @(12,LN):PAR<2,VC> "L#25":
PRINT @(40,LN):PAR<3,VC> "L#17":
PRINT @(60,LN):PAR<4,VC> "L#16":
END
LN = LN + ONE
TDX(REF) = TDX(REF) + ONE
*
REPEAT
*
IF REDISP OR TDI(REF) LE TDC(REF) OR SYS11.FL GE 3 THEN
RSP = EMPTY
END ELSE
IF INDEX("*I*D*E*N*","*":DYN:"*",ONE) THEN RSP = EMPTY ELSE
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
IF NOT(SYS11.FL) THEN
PRINT CLB:"Display more (Y or Next/Prev/REdisplay/<cr> to end)? ":
END
INPUT RSP:; IF RSP EQ "KILL" THEN STAT = 999; GOTO D01.EXIT
END
IF RSP EQ "RE" THEN TDX(REF) = ONE; RSP = "Y"
IF RSP EQ "P" THEN
TDX(REF) = TDL(REF) - TDC(REF)
IF TDX(REF) LT ZERO THEN TDX(REF) = ONE
RSP = "Y"
END
IF RSP EQ "N" THEN RSP = "Y"
END
*
WHILE RSP EQ "Y" DO
TDH(REF) = LN
LN.START = TDT(REF); LN = LN.START
IF TDX(REF) GT TDI(REF) THEN TDX(REF) = ONE
TDL.OK = FALSE
REPEAT
*
IF CLEAR OR LN LE TDH(REF) THEN
ON REF GOSUB C01
END ELSE TDH(REF) = LN
*
IF NOT(REDISP) AND DYN EQ EMPTY THEN SAVE.TDX(REF) = TDL(REF)
*
D01.EXIT: *
*
TDX(REF) = SAVE.TDX(REF); LN = SAVE.LN
REF = SAVE.REF
*
RETURN
*
C01: *
IF CLEAR THEN LN = TDT(REF); TDH(REF) = TDT(REF) + TDC(REF) - ONE
LN.HI = TDH(REF)
LN.TMP = LN - ONE
LOOP
SYS11.FL = SYSTEM(14) * (SEC.USER$BF GE 10)
LN.TMP = LN.TMP + ONE
WHILE LN.TMP LE LN.HI AND NOT(SYS11.FL) DO
PRINT @(0,LN.TMP):SPACE(6):
PRINT @(12,LN.TMP):SPACE(25):
PRINT @(40,LN.TMP):SPACE(17):
PRINT @(60,LN.TMP):SPACE(16):
REPEAT
TDH(REF) = LN
CLEAR = FALSE
RETURN
*
!
*
*
!
*
*ERR.LNS*
ERROR: *
IF TEXT EQ EMPTY THEN RETURN
PRINT BELL:CLB:TEXT[ONE,78]:; IF LEN(TEXT) LT 55 THEN PRINT " - Hit <cr> to continue ":
INPUT RSP:; PRINT CLB:
RETURN
*ERR.END*
*
!
*
SYS.DEBUG: *
*
DEBUG
*
RETURN
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
LOAD.STD.DATA: *
*
CALL SYS.SUBR.LOAD.STD.DATA(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,SEC.USER.ID,STD.FILE,MAT STD,STAT)
*
RETURN
*
!
*
ENTER.STD.SUBR: *
*
CALL SYS.SUBR.ENTER.STD.SUBR(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,STAT)
*
RETURN
*
!
*
ENTER.STD.EXEC: *
*
CALL SYS.SUBR.EXEC.STD.FUNC(STD.FUNC,STD.CONT,STD.SUBR.NAME,MAT SEC.USER,CALL.ID,PORT.KEY,STD.FILE,MAT STD,COM.FILE,GENERIC,PAR.FILE,LCK.FILE,MAT PAR.MENU,CO.DATA,DISP.ONLY,AUTO.RUN,MAT CNT.TST,REDISP,EXEC.VERB,EXEC.DESC,RESET.SW,MENU.NAME,SCR.LOCN,CR.FLAG,LCK.STAT,LCK.TYPE,LCK.ITM,LCK.RELS,EXEC.VERB.ID,EXEC.IN,ACC.FILE,STAT)
*
! Load test data
*
LOAD.TST: *
*
CALL TST.SUBR.LOAD(CNT.FILE,CNT.TST.ID,MAT CNT.TST,MAT SEC.USER,SEC.USER.ID,PAR.FILE,LCK.FILE,CNT.ID.SAVE,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,TYPE.RUN,PHAN.RUN,REDISP,SYS.APPL.SUB,RSPBUF,PROCBUF,TM.MAX,STAT)
*
RETURN
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.CH.ERRORS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.CH.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bg":AM:"bg":AM:"bg":AM:"bgbg":AM:"bgbgbgbg":AM:"CI|1|1C"
POS.REF = POS.REF:"I|1|2CI|1|3CI|1|4CI|1|5CI|1|6CI|1|7CI|1|8CI"
POS.REF = POS.REF:"|1|9CI|1|10CI|1|11":AM:"CI|2|1CI|2|2CI|2|3CI|2|4C"
POS.REF = POS.REF:"I|2|5CI|2|6CI|2|7CI|2|8CI|2|9CI|2|10CI|2|11":AM:""
POS.REF = POS.REF:"CI|3|1CI|3|2CI|3|3CI|3|4CI|3|5CI|3|6CI|3|7C"
POS.REF = POS.REF:"I|3|8CI|3|9CI|3|10CI|3|11":AM:"CI|4|1CI|4|2CI|4|3"
POS.REF = POS.REF:"CI|4|4CI|4|5CI|4|6CI|4|7CI|4|8CI|4|9CI|4|10"
POS.REF = POS.REF:"CI|4|11":AM:"CI|5|1CI|5|2CI|5|3CI|5|4CI|5|5CI|5|6"
POS.REF = POS.REF:"CI|5|7CI|5|8CI|5|9CI|5|10CI|5|11":AM:"CI|6|1CI|6|2"
POS.REF = POS.REF:"CI|6|3CI|6|4CI|6|5CI|6|6CI|6|7CI|6|8CI|6|9"
POS.REF = POS.REF:"CI|6|10CI|6|11":AM:"CI|7|1CI|7|2CI|7|3CI|7|4CI|7|5"
POS.REF = POS.REF:"CI|7|6CI|7|7CI|7|8CI|7|9CI|7|10CI|7|11":AM:"CI|8|"
POS.REF = POS.REF:"1CI|8|2CI|8|3CI|8|4CI|8|5CI|8|6CI|8|7CI|8|8"
POS.REF = POS.REF:"CI|8|9CI|8|10CI|8|11":AM:"CI|9|1CI|9|2CI|9|3CI|9|"
POS.REF = POS.REF:"4CI|9|5CI|9|6CI|9|7CI|9|8CI|9|9CI|9|10CI|9|"
POS.REF = POS.REF:"11":AM:"CI|10|1CI|10|2CI|10|3CI|10|4CI|10|5CI|10|6"
POS.REF = POS.REF:"CI|10|7CI|10|8CI|10|9CI|10|10CI|10|11":AM:"CI|11|1"
POS.REF = POS.REF:"CI|11|2CI|11|3CI|11|4CI|11|5CI|11|6CI|11|7C"
POS.REF = POS.REF:"I|11|8CI|11|9CI|11|10CI|11|11":AM:"CI|12|1CI|12|2C"
POS.REF = POS.REF:"I|12|3CI|12|4CI|12|5CI|12|6CI|12|7CI|12|8CI|"
POS.REF = POS.REF:"12|9CI|12|10CI|12|11":AM:"CI|13|1CI|13|2CI|13|3CI|"
POS.REF = POS.REF:"13|4CI|13|5CI|13|6CI|13|7CI|13|8CI|13|9CI|13"
POS.REF = POS.REF:"|10CI|13|11"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"09":AM:"55":AM:"55":AM:"55":AM:"1055":AM:"10205055":AM:"1014205055"
POS.LOC = POS.LOC:"586062646773":AM:"101420505558606264677"
POS.LOC = POS.LOC:"3":AM:"1014205055586062646773":AM:"1014205055"
POS.LOC = POS.LOC:"586062646773":AM:"1014205055586062646773"
POS.LOC = POS.LOC:"":AM:"1014205055586062646773":AM:"10142050555"
POS.LOC = POS.LOC:"86062646773":AM:"1014205055586062646773":AM:""
POS.LOC = POS.LOC:"1014205055586062646773":AM:"101420505558"
POS.LOC = POS.LOC:"6062646773":AM:"1014205055586062646773":AM:"1"
POS.LOC = POS.LOC:"014205055586062646773":AM:"101420505558"
POS.LOC = POS.LOC:"6062646773"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.CHANNELS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"bgkey":AM:"":AM:"bgbgbgbg":AM:"bgbg":AM:"CO|1|1CO|1|2":AM:"C"
POS.REF = POS.REF:"O|2|1CO|2|2":AM:"CO|3|1CO|3|2":AM:"CO|4|1CO|4|2":AM:"CO|5|1CO"
POS.REF = POS.REF:"|5|2":AM:"CO|6|1CO|6|2":AM:"CO|7|1CO|7|2":AM:"CO|8|1CO|8|2":AM:"CO|"
POS.REF = POS.REF:"9|1CO|9|2":AM:"CO|10|1CO|10|2"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"012":AM:"":AM:"0101542":AM:"010":AM:"011":AM:"011":AM:"011":AM:"011":AM:"0"
POS.LOC = POS.LOC:"11":AM:"011":AM:"011":AM:"011":AM:"011":AM:"011"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.CMD.CNTRL~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.CMD.CNTRL(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIICMD.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIICMD.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkeybgbgbg":AM:"bgbgbgbgbgbg":AM:"CI|1|1C"
POS.REF = POS.REF:"I|1|2CI|1|3CI|1|4CI|1|5":AM:"CI|2|1CI|2|2CI|2|3CI"
POS.REF = POS.REF:"|2|4CI|2|5":AM:"CI|3|1CI|3|2CI|3|3CI|3|4CI|3|5":AM:"CI|"
POS.REF = POS.REF:"4|1CI|4|2CI|4|3CI|4|4CI|4|5":AM:"CI|5|1CI|5|2CI|5"
POS.REF = POS.REF:"|3CI|5|4CI|5|5":AM:"CI|6|1CI|6|2CI|6|3CI|6|4CI|6|"
POS.REF = POS.REF:"5":AM:"CI|7|1CI|7|2CI|7|3CI|7|4CI|7|5":AM:"CI|8|1CI|8|2"
POS.REF = POS.REF:"CI|8|3CI|8|4CI|8|5":AM:"CI|9|1CI|9|2CI|9|3CI|9|4"
POS.REF = POS.REF:"CI|9|5":AM:"CI|10|1CI|10|2CI|10|3CI|10|4CI|10|5":AM:"CI|"
POS.REF = POS.REF:"11|1CI|11|2CI|11|3CI|11|4CI|11|5":AM:"CI|12|1CI|12"
POS.REF = POS.REF:"|2CI|12|3CI|12|4CI|12|5":AM:"CI|13|1CI|13|2CI|13|3"
POS.REF = POS.REF:"CI|13|4CI|13|5":AM:"CI|14|1CI|14|2CI|14|3CI|14|4C"
POS.REF = POS.REF:"I|14|5":AM:"CI|15|1CI|15|2CI|15|3CI|15|4CI|15|5":AM:"CI|"
POS.REF = POS.REF:"16|1CI|16|2CI|16|3CI|16|4CI|16|5":AM:"CI|17|1CI|17"
POS.REF = POS.REF:"|2CI|17|3CI|17|4CI|17|5"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"015536067":AM:"71020536067":AM:"1020556169"
POS.LOC = POS.LOC:"":AM:"1020556169":AM:"1020556169":AM:"1020556169":AM:"102"
POS.LOC = POS.LOC:"0556169":AM:"1020556169":AM:"1020556169":AM:"102055"
POS.LOC = POS.LOC:"6169":AM:"1020556169":AM:"1020556169":AM:"1020556169"
POS.LOC = POS.LOC:"":AM:"1020556169":AM:"1020556169":AM:"1020556169":AM:"102"
POS.LOC = POS.LOC:"0556169":AM:"1020556169":AM:"1020556169"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.COMMANDS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.COMMANDS(TDL.REC,COM.AIICMD.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIICMD.ID,MAT COM.AIICMD,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIICMD.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIICMD.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkeybgbgbg":AM:"bgbgbgbgbgbg":AM:"CI|1|1C"
POS.REF = POS.REF:"I|1|2CI|1|3CI|1|4CI|1|5":AM:"CI|2|1CI|2|2CI|2|3CI"
POS.REF = POS.REF:"|2|4CI|2|5":AM:"CI|3|1CI|3|2CI|3|3CI|3|4CI|3|5":AM:"CI|"
POS.REF = POS.REF:"4|1CI|4|2CI|4|3CI|4|4CI|4|5":AM:"CI|5|1CI|5|2CI|5"
POS.REF = POS.REF:"|3CI|5|4CI|5|5":AM:"CI|6|1CI|6|2CI|6|3CI|6|4CI|6|"
POS.REF = POS.REF:"5":AM:"CI|7|1CI|7|2CI|7|3CI|7|4CI|7|5":AM:"CI|8|1CI|8|2"
POS.REF = POS.REF:"CI|8|3CI|8|4CI|8|5":AM:"CI|9|1CI|9|2CI|9|3CI|9|4"
POS.REF = POS.REF:"CI|9|5":AM:"CI|10|1CI|10|2CI|10|3CI|10|4CI|10|5":AM:"CI|"
POS.REF = POS.REF:"11|1CI|11|2CI|11|3CI|11|4CI|11|5":AM:"CI|12|1CI|12"
POS.REF = POS.REF:"|2CI|12|3CI|12|4CI|12|5":AM:"CI|13|1CI|13|2CI|13|3"
POS.REF = POS.REF:"CI|13|4CI|13|5":AM:"CI|14|1CI|14|2CI|14|3CI|14|4C"
POS.REF = POS.REF:"I|14|5":AM:"CI|15|1CI|15|2CI|15|3CI|15|4CI|15|5":AM:"CI|"
POS.REF = POS.REF:"16|1CI|16|2CI|16|3CI|16|4CI|16|5":AM:"CI|17|1CI|17"
POS.REF = POS.REF:"|2CI|17|3CI|17|4CI|17|5"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"015536067":AM:"71020536067":AM:"1020556269"
POS.LOC = POS.LOC:"":AM:"1020556269":AM:"1020556269":AM:"1020556269":AM:"102"
POS.LOC = POS.LOC:"0556269":AM:"1020556269":AM:"1020556269":AM:"102055"
POS.LOC = POS.LOC:"6269":AM:"1020556269":AM:"1020556269":AM:"1020556269"
POS.LOC = POS.LOC:"":AM:"1020556269":AM:"1020556269":AM:"1020556269":AM:"102"
POS.LOC = POS.LOC:"0556269":AM:"1020556269":AM:"1020556269"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.CYPHER.KEYS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.CYPHER.KEYS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"":AM:"":AM:"":AM:"bg":AM:"":AM:"AK|1|1":AM:"AK|2|1":AM:"AK|3|1":AM:"AK|4|1"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "AK"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"":AM:"":AM:"":AM:"30":AM:"":AM:"37":AM:"37":AM:"37":AM:"37"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.ERRORS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.ERRORS(TDL.REC,XYZ.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr"
0
*REF.END*
*
*
!
*
POS.LOC = "0"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.HERRORS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.HERRORS(TDL.REC,COM.AIHERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIHERR.ID,MAT COM.AIHERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIHERR.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIHERR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bg":AM:"bg":AM:"bg":AM:"bg":AM:"bgbgCI|1|1CI|1|2CI|1|3CI|"
POS.REF = POS.REF:"1|4CI|1|5CI|1|6CI|1|7CI|1|8CI|1|9CI|1|10":AM:"CI|"
POS.REF = POS.REF:"2|1CI|2|2CI|2|3CI|2|4CI|2|5CI|2|6CI|2|7CI|2"
POS.REF = POS.REF:"|8CI|2|9CI|2|10":AM:"CI|3|1CI|3|2CI|3|3CI|3|4CI|3"
POS.REF = POS.REF:"|5CI|3|6CI|3|7CI|3|8CI|3|9CI|3|10":AM:"CI|4|1CI|4"
POS.REF = POS.REF:"|2CI|4|3CI|4|4CI|4|5CI|4|6CI|4|7CI|4|8CI|4|"
POS.REF = POS.REF:"9CI|4|10":AM:"CI|5|1CI|5|2CI|5|3CI|5|4CI|5|5CI|5|"
POS.REF = POS.REF:"6CI|5|7CI|5|8CI|5|9CI|5|10":AM:"CI|6|1CI|6|2CI|6|"
POS.REF = POS.REF:"3CI|6|4CI|6|5CI|6|6CI|6|7CI|6|8CI|6|9CI|6|1"
POS.REF = POS.REF:"0":AM:"CI|7|1CI|7|2CI|7|3CI|7|4CI|7|5CI|7|6CI|7|7"
POS.REF = POS.REF:"CI|7|8CI|7|9CI|7|10":AM:"CI|8|1CI|8|2CI|8|3CI|8|4"
POS.REF = POS.REF:"CI|8|5CI|8|6CI|8|7CI|8|8CI|8|9CI|8|10":AM:"CI|9|1"
POS.REF = POS.REF:"CI|9|2CI|9|3CI|9|4CI|9|5CI|9|6CI|9|7CI|9|8"
POS.REF = POS.REF:"CI|9|9CI|9|10":AM:"CI|10|1CI|10|2CI|10|3CI|10|4CI|"
POS.REF = POS.REF:"10|5CI|10|6CI|10|7CI|10|8CI|10|9CI|10|10":AM:"CI|1"
POS.REF = POS.REF:"1|1CI|11|2CI|11|3CI|11|4CI|11|5CI|11|6CI|11|"
POS.REF = POS.REF:"7CI|11|8CI|11|9CI|11|10":AM:"CI|12|1CI|12|2CI|12|3"
POS.REF = POS.REF:"CI|12|4CI|12|5CI|12|6CI|12|7CI|12|8CI|12|9C"
POS.REF = POS.REF:"I|12|10":AM:"CI|13|1CI|13|2CI|13|3CI|13|4CI|13|5CI"
POS.REF = POS.REF:"|13|6CI|13|7CI|13|8CI|13|9CI|13|10":AM:"CI|14|1CI|"
POS.REF = POS.REF:"14|2CI|14|3CI|14|4CI|14|5CI|14|6CI|14|7CI|14"
POS.REF = POS.REF:"|8CI|14|9CI|14|10":AM:"CI|15|1CI|15|2CI|15|3CI|15|"
POS.REF = POS.REF:"4CI|15|5CI|15|6CI|15|7CI|15|8CI|15|9CI|15|10"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"58":AM:"58":AM:"58":AM:"58":AM:"046124853586062646673":AM:""
POS.LOC = POS.LOC:"6124853586062646673":AM:"61248535860626"
POS.LOC = POS.LOC:"46673":AM:"6124853586062646673":AM:"612485358"
POS.LOC = POS.LOC:"6062646673":AM:"6124853586062646673":AM:"612"
POS.LOC = POS.LOC:"4853586062646673":AM:"61248535860626466"
POS.LOC = POS.LOC:"73":AM:"6124853586062646673":AM:"612485358606"
POS.LOC = POS.LOC:"2646673":AM:"6124853586062646673":AM:"6124853"
POS.LOC = POS.LOC:"586062646673":AM:"6124853586062646673":AM:"6"
POS.LOC = POS.LOC:"124853586062646673":AM:"612485358606264"
POS.LOC = POS.LOC:"6673"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.IERRORS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.IERRORS(TDL.REC,COM.AIIERR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AIIERR.ID,MAT COM.AIIERR,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AIIERR.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AIIERR.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bg":AM:"bg":AM:"bg":AM:"bgbg":AM:"bgbgbgbg":AM:"CH|1|1C"
POS.REF = POS.REF:"H|1|2CH|1|3CH|1|4CH|1|5CH|1|6CH|1|7CH|1|8CH"
POS.REF = POS.REF:"|1|9":AM:"CH|2|1CH|2|2CH|2|3CH|2|4CH|2|5CH|2|6CH|"
POS.REF = POS.REF:"2|7CH|2|8CH|2|9":AM:"CH|3|1CH|3|2CH|3|3CH|3|4CH|3"
POS.REF = POS.REF:"|5CH|3|6CH|3|7CH|3|8CH|3|9":AM:"CH|4|1CH|4|2CH|4|"
POS.REF = POS.REF:"3CH|4|4CH|4|5CH|4|6CH|4|7CH|4|8CH|4|9":AM:"CH|5|1"
POS.REF = POS.REF:"CH|5|2CH|5|3CH|5|4CH|5|5CH|5|6CH|5|7CH|5|8"
POS.REF = POS.REF:"CH|5|9":AM:"CH|6|1CH|6|2CH|6|3CH|6|4CH|6|5CH|6|6C"
POS.REF = POS.REF:"H|6|7CH|6|8CH|6|9":AM:"CH|7|1CH|7|2CH|7|3CH|7|4CH"
POS.REF = POS.REF:"|7|5CH|7|6CH|7|7CH|7|8CH|7|9":AM:"CH|8|1CH|8|2CH|"
POS.REF = POS.REF:"8|3CH|8|4CH|8|5CH|8|6CH|8|7CH|8|8CH|8|9":AM:"CH|9"
POS.REF = POS.REF:"|1CH|9|2CH|9|3CH|9|4CH|9|5CH|9|6CH|9|7CH|9|"
POS.REF = POS.REF:"8CH|9|9":AM:"CH|10|1CH|10|2CH|10|3CH|10|4CH|10|5C"
POS.REF = POS.REF:"H|10|6CH|10|7CH|10|8CH|10|9":AM:"CH|11|1CH|11|2CH|"
POS.REF = POS.REF:"11|3CH|11|4CH|11|5CH|11|6CH|11|7CH|11|8CH|11"
POS.REF = POS.REF:"|9":AM:"CH|12|1CH|12|2CH|12|3CH|12|4CH|12|5CH|12|6"
POS.REF = POS.REF:"CH|12|7CH|12|8CH|12|9":AM:"CH|13|1CH|13|2CH|13|3C"
POS.REF = POS.REF:"H|13|4CH|13|5CH|13|6CH|13|7CH|13|8CH|13|9"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"012":AM:"49":AM:"49":AM:"49":AM:"1049":AM:"10184449":AM:"101418444"
POS.LOC = POS.LOC:"951535557":AM:"101418444951535557":AM:"101418"
POS.LOC = POS.LOC:"444951535557":AM:"101418444951535557":AM:"1014"
POS.LOC = POS.LOC:"18444951535557":AM:"101418444951535557":AM:"1"
POS.LOC = POS.LOC:"01418444951535557":AM:"1014184449515355"
POS.LOC = POS.LOC:"57":AM:"101418444951535557":AM:"10141844495153"
POS.LOC = POS.LOC:"5557":AM:"101418444951535557":AM:"10141844495"
POS.LOC = POS.LOC:"1535557":AM:"101418444951535557"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.MISC~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.MISC(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgTY|1|1":AM:"":AM:"bg":AM:"bgSY|1|1":AM:"bgGR|1|1":AM:"bgBX|1|"
POS.REF = POS.REF:"1"
*
*REF.LNS*
DIM TDL(4); MAT TDL = EMPTY
DIM TDH(4); MAT TDH = EMPTY
DIM TDI(4); MAT TDI = EMPTY
DIM TDX(4); MAT TDX = ONE
DIM SAVE.TDX(4); MAT SAVE.TDX = EMPTY
DIM TDM(4); MAT TDM = EMPTY
DIM TDS(4); MAT TDS = EMPTY
DIM TDR(4); MAT TDR = EMPTY
DIM TDC(4); MAT TDC = EMPTY
DIM TDT(4); MAT TDT = EMPTY
VALID.REFS = "TY":AM:"SY":AM:"GR":AM:"BX"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"032":AM:"":AM:"0":AM:"032":AM:"032":AM:"032"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.PORT~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.PORT(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgNA|1|1":AM:"":AM:"bgIT|1|1":AM:"bgCP|1|1":AM:"bgM"
POS.REF = POS.REF:"P|1|1"
*
*REF.LNS*
DIM TDL(4); MAT TDL = EMPTY
DIM TDH(4); MAT TDH = EMPTY
DIM TDI(4); MAT TDI = EMPTY
DIM TDX(4); MAT TDX = ONE
DIM SAVE.TDX(4); MAT SAVE.TDX = EMPTY
DIM TDM(4); MAT TDM = EMPTY
DIM TDS(4); MAT TDS = EMPTY
DIM TDR(4); MAT TDR = EMPTY
DIM TDC(4); MAT TDC = EMPTY
DIM TDT(4); MAT TDT = EMPTY
VALID.REFS = "NA":AM:"IT":AM:"CP":AM:"MP"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"012":AM:"022":AM:"":AM:"022":AM:"022":AM:"022"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.PROMPTS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.PROMPTS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgbg":AM:"":AM:"CI|1|1":AM:"CI|2|1":AM:"CI|3|1":AM:"CI|4|1":AM:""
POS.REF = POS.REF:"CI|5|1":AM:"CI|6|1":AM:"CI|7|1":AM:"CI|8|1":AM:"CI|9|1":AM:"CI|10|1":AM:"CI|11|1"
POS.REF = POS.REF:"":AM:"CI|12|1":AM:"CI|13|1":AM:"CI|14|1":AM:"CI|15|1":AM:"CI|16|1"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"017":AM:"03":AM:"":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3":AM:"3"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.SYS.ERRORS~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.SYS.ERRORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgbgbgbgbgbg":AM:"":AM:"CI|1|1CI|1|2CI"
POS.REF = POS.REF:"|1|3CI|1|4CI|1|5CI|1|6":AM:"CI|2|1CI|2|2CI|2|3CI|"
POS.REF = POS.REF:"2|4CI|2|5CI|2|6":AM:"CI|3|1CI|3|2CI|3|3CI|3|4CI|3"
POS.REF = POS.REF:"|5CI|3|6":AM:"CI|4|1CI|4|2CI|4|3CI|4|4CI|4|5CI|4|"
POS.REF = POS.REF:"6":AM:"CI|5|1CI|5|2CI|5|3CI|5|4CI|5|5CI|5|6":AM:"CI|6|1"
POS.REF = POS.REF:"CI|6|2CI|6|3CI|6|4CI|6|5CI|6|6":AM:"CI|7|1CI|7|2"
POS.REF = POS.REF:"CI|7|3CI|7|4CI|7|5CI|7|6":AM:"CI|8|1CI|8|2CI|8|3C"
POS.REF = POS.REF:"I|8|4CI|8|5CI|8|6":AM:"CI|9|1CI|9|2CI|9|3CI|9|4CI"
POS.REF = POS.REF:"|9|5CI|9|6":AM:"CI|10|1CI|10|2CI|10|3CI|10|4CI|10|"
POS.REF = POS.REF:"5CI|10|6":AM:"CI|11|1CI|11|2CI|11|3CI|11|4CI|11|5"
POS.REF = POS.REF:"CI|11|6":AM:"CI|12|1CI|12|2CI|12|3CI|12|4CI|12|5CI"
POS.REF = POS.REF:"|12|6":AM:"CI|13|1CI|13|2CI|13|3CI|13|4CI|13|5CI|1"
POS.REF = POS.REF:"3|6":AM:"CI|14|1CI|14|2CI|14|3CI|14|4CI|14|5CI|14|"
POS.REF = POS.REF:"6":AM:"CI|15|1CI|15|2CI|15|3CI|15|4CI|15|5CI|15|6":AM:""
POS.REF = POS.REF:"CI|16|1CI|16|2CI|16|3CI|16|4CI|16|5CI|16|6"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"017":AM:"102050556065":AM:"":AM:"102050556065":AM:"10"
POS.LOC = POS.LOC:"2050556065":AM:"102050556065":AM:"102050556065"
POS.LOC = POS.LOC:"":AM:"102050556065":AM:"102050556065":AM:"102050556"
POS.LOC = POS.LOC:"065":AM:"102050556065":AM:"102050556065":AM:"102050"
POS.LOC = POS.LOC:"556065":AM:"102050556065":AM:"102050556065":AM:"1020"
POS.LOC = POS.LOC:"50556065":AM:"102050556065":AM:"102050556065":AM:"1"
POS.LOC = POS.LOC:"02050556065"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.TYPE~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.TYPE(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "bg":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bgOP|1|1":AM:"":AM:"bgIT|1|1bgIT|1|1IT|1"
POS.REF = POS.REF:"|1IT|1|1":AM:"bgPO|1|1bgIT|1|1IT|1|1IT|1|1":AM:"bgMP|"
POS.REF = POS.REF:"1|1":AM:"bgbgGW|1|1GW|1|1GW|1|1":AM:"bgCT|1|1bgGW|1|1"
POS.REF = POS.REF:"GW|1|1GW|1|1":AM:"bgGW|1|1bgON|1|1bgOF|1|1":AM:"bgOF"
POS.REF = POS.REF:"|1|1OF|1|1OF|1|1bgCL|1|1":AM:"bgOF|1|1OF|1|1OF|1"
POS.REF = POS.REF:"|1bgTM|1|1":AM:"bgCP|1|1bgbgbgbgbg":AM:"bgLP|1|1DT"
POS.REF = POS.REF:"|1|1DT|1|2DT|1|3DT|1|4bg":AM:"bgRP|1|1DT|2|1DT|2"
POS.REF = POS.REF:"|2DT|2|3DT|2|4TC|1|1TS|1|1TD|1|1":AM:"bgSP|1|1DT"
POS.REF = POS.REF:"|3|1DT|3|2DT|3|3DT|3|4":AM:"bgSF|1|1DT|4|1DT|4|2"
POS.REF = POS.REF:"DT|4|3DT|4|4bgCD|1|1":AM:"bgMW|1|1DT|5|1DT|5|2DT"
POS.REF = POS.REF:"|5|3DT|5|4bgTI|1|1":AM:"bgRF|1|1DT|6|1DT|6|2DT|6"
POS.REF = POS.REF:"|3DT|6|4"
*
*REF.LNS*
DIM TDL(23); MAT TDL = EMPTY
DIM TDH(23); MAT TDH = EMPTY
DIM TDI(23); MAT TDI = EMPTY
DIM TDX(23); MAT TDX = ONE
DIM SAVE.TDX(23); MAT SAVE.TDX = EMPTY
DIM TDM(23); MAT TDM = EMPTY
DIM TDS(23); MAT TDS = EMPTY
DIM TDR(23); MAT TDR = EMPTY
DIM TDC(23); MAT TDC = EMPTY
DIM TDT(23); MAT TDT = EMPTY
VALID.REFS = "OP":AM:"IT":AM:"PO":AM:"MP":AM:"CT":AM:"GW":AM:"ON":AM:"OF":AM:"CL":AM:"TM":AM:"CP":AM:"LP":AM:"RP":AM:"SP":AM:"SF":AM:"MW":AM:"RF":AM:"DT":AM:"TC":AM:"TS":AM:"TD":AM:"CD":AM:"TI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"09":AM:"":AM:"022":AM:"":AM:"02240576171":AM:"02240576171":AM:""
POS.LOC = POS.LOC:"022":AM:"040576171":AM:"03140576171":AM:"031405560"
POS.LOC = POS.LOC:"75":AM:"01721314062":AM:"01721314062":AM:"015202732"
POS.LOC = POS.LOC:"3853":AM:"0152028333953":AM:"015202833395867"
POS.LOC = POS.LOC:"76":AM:"01520283339":AM:"015202833395976":AM:"01520"
POS.LOC = POS.LOC:"2833395976":AM:"01520283339"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.TYPE.32~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.TYPE.32(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bg,|1|1":AM:"bg,|1|1":AM:"bg,|1|1":AM:"":AM:"bgDT|"
POS.REF = POS.REF:"1|1":AM:"bgIT|1|1":AM:"":AM:"bgbgbg":AM:"bgbgbg":AM:"SE|1|1SE|1|2SE|"
POS.REF = POS.REF:"1|3":AM:"SE|2|1SE|2|2SE|2|3":AM:"SE|3|1SE|3|2SE|3|3":AM:"SE|4"
POS.REF = POS.REF:"|1SE|4|2SE|4|3":AM:"SE|5|1SE|5|2SE|5|3":AM:"SE|6|1SE|6|"
POS.REF = POS.REF:"2SE|6|3":AM:"SE|7|1SE|7|2SE|7|3":AM:"SE|8|1SE|8|2SE|8|3"
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "DT":AM:"IT":AM:"SE"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"09":AM:"":AM:"022":AM:"022":AM:"022":AM:"":AM:"0022":AM:"022":AM:"":AM:"02040":AM:"420"
POS.LOC = POS.LOC:"40":AM:"42442":AM:"42442":AM:"42442":AM:"42442":AM:"42442":AM:"4244"
POS.LOC = POS.LOC:"2":AM:"42442":AM:"42442"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.TYPE.EIGHT~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.TYPE.EIGHT(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bg,|1|1":AM:"bg,|1|1":AM:"bg,|1|1":AM:"bg,|1|"
POS.REF = POS.REF:"1":AM:"":AM:"bgbgbg":AM:"bgbgbg":AM:"SE|1|1SE|1|2SE|1|3":AM:"SE|2|1S"
POS.REF = POS.REF:"E|2|2SE|2|3":AM:"SE|3|1SE|3|2SE|3|3":AM:"SE|4|1SE|4|2SE"
POS.REF = POS.REF:"|4|3":AM:"SE|5|1SE|5|2SE|5|3":AM:"SE|6|1SE|6|2SE|6|3":AM:"SE|"
POS.REF = POS.REF:"7|1SE|7|2SE|7|3":AM:"SE|8|1SE|8|2SE|8|3"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SE"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"016":AM:"":AM:"022":AM:"022":AM:"022":AM:"022":AM:"":AM:"02040":AM:"02040":AM:"2"
POS.LOC = POS.LOC:"2242":AM:"22242":AM:"22242":AM:"22242":AM:"22242":AM:"22242":AM:"222"
POS.LOC = POS.LOC:"42":AM:"22242"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.AI.TYPE.ONE~
SUBROUTINE SH.SUBR.SCR.MAINT.AI.TYPE.ONE(TDL.REC,COM.AI.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.AI.FILE,COM.AI.ID,MAT COM.AI,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP COM.AI.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP COM.AI.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bgbgbg":AM:"bgbgbg":AM:"SE|1|1SE|1|2SE"
POS.REF = POS.REF:"|1|3":AM:"SE|2|1SE|2|2SE|2|3":AM:"SE|3|1SE|3|2SE|3|3":AM:"SE|"
POS.REF = POS.REF:"4|1SE|4|2SE|4|3":AM:"SE|5|1SE|5|2SE|5|3":AM:"SE|6|1SE|6"
POS.REF = POS.REF:"|2SE|6|3":AM:"SE|7|1SE|7|2SE|7|3":AM:"SE|8|1SE|8|2SE|8|"
POS.REF = POS.REF:"3":AM:"SE|9|1SE|9|2SE|9|3":AM:"SE|10|1SE|10|2SE|10|3":AM:"SE|"
POS.REF = POS.REF:"11|1SE|11|2SE|11|3":AM:"SE|12|1SE|12|2SE|12|3":AM:"SE|13"
POS.REF = POS.REF:"|1SE|13|2SE|13|3":AM:"SE|14|1SE|14|2SE|14|3":AM:"SE|15|1"
POS.REF = POS.REF:"SE|15|2SE|15|3"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SE"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"09":AM:"":AM:"02040":AM:"42040":AM:"42242":AM:"42242":AM:"42242":AM:""
POS.LOC = POS.LOC:"42242":AM:"42242":AM:"42242":AM:"42242":AM:"42242":AM:"42242":AM:"4"
POS.LOC = POS.LOC:"2242":AM:"42242":AM:"42242":AM:"42242":AM:"42242":AM:"42242"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.BARKERS~
SUBROUTINE SH.SUBR.SCR.MAINT.BARKERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"bgbgbg":AM:"SC|1|1SC|1|2SC|1|3":AM:"SC|2|1SC|2"
POS.REF = POS.REF:"|2SC|2|3":AM:"SC|3|1SC|3|2SC|3|3":AM:"SC|4|1SC|4|2SC|4|"
POS.REF = POS.REF:"3":AM:"SC|5|1SC|5|2SC|5|3":AM:"SC|6|1SC|6|2SC|6|3":AM:"SC|7|1"
POS.REF = POS.REF:"SC|7|2SC|7|3":AM:"SC|8|1SC|8|2SC|8|3":AM:"SC|9|1SC|9|2"
POS.REF = POS.REF:"SC|9|3":AM:"SC|10|1SC|10|2SC|10|3":AM:"SC|11|1SC|11|2SC|"
POS.REF = POS.REF:"11|3":AM:"SC|12|1SC|12|2SC|12|3":AM:"SC|13|1SC|13|2SC|13"
POS.REF = POS.REF:"|3":AM:"SC|14|1SC|14|2SC|14|3":AM:"SC|15|1SC|15|2SC|15|3"
POS.REF = POS.REF:"":AM:"SC|16|1SC|16|2SC|16|3"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"01240":AM:"01240":AM:"01240":AM:"01240":AM:"01240":AM:"012"
POS.LOC = POS.LOC:"40":AM:"01240":AM:"01240":AM:"01240":AM:"01240":AM:"01240":AM:"0124"
POS.LOC = POS.LOC:"0":AM:"01240":AM:"01240":AM:"01240":AM:"01240":AM:"01240"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.BRMNGR.MSG~
SUBROUTINE SH.SUBR.SCR.MAINT.BRMNGR.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgEF|1|1EF|1|1":AM:"":AM:"bgEX|1|1EX|1|1":AM:"":AM:"bgMSG"
POS.REF = POS.REF:"|1|1":AM:"MSG|2|1":AM:"MSG|3|1":AM:"MSG|4|1":AM:"MSG|5|1":AM:"MSG|6|1":AM:"MSG|7"
POS.REF = POS.REF:"|1":AM:"MSG|8|1"
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"02535":AM:"":AM:"02535":AM:"":AM:"022":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.CHANNELS~
SUBROUTINE SH.SUBR.SCR.MAINT.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"bgkey":AM:"":AM:"bgbgbgbg":AM:"bgbgbgbg":AM:"CO|1|1CO"
POS.REF = POS.REF:"|1|2":AM:"CO|2|1CO|2|2":AM:"CO|3|1CO|3|2":AM:"CO|4|1CO|4|2":AM:"CO|"
POS.REF = POS.REF:"5|1CO|5|2":AM:"CO|6|1CO|6|2":AM:"CO|7|1CO|7|2":AM:"CO|8|1CO|8"
POS.REF = POS.REF:"|2":AM:"CO|9|1CO|9|2":AM:"CO|10|1CO|10|2"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"012":AM:"":AM:"0101542":AM:"0101542":AM:"011":AM:"011":AM:"011":AM:"0"
POS.LOC = POS.LOC:"11":AM:"011":AM:"011":AM:"011":AM:"011":AM:"011":AM:"011"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.COMMAND.LIST~
SUBROUTINE SH.SUBR.SCR.MAINT.COMMAND.LIST(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bg":AM:"bg":AM:"bgbgbg":AM:"CO|1|1CO|1|2CO|1|3":AM:"CO|2|1"
POS.REF = POS.REF:"CO|2|2CO|2|3":AM:"CO|3|1CO|3|2CO|3|3":AM:"CO|4|1CO|4|2"
POS.REF = POS.REF:"CO|4|3":AM:"CO|5|1CO|5|2CO|5|3":AM:"CO|6|1CO|6|2CO|6|3":AM:"C"
POS.REF = POS.REF:"O|7|1CO|7|2CO|7|3":AM:"CO|8|1CO|8|2CO|8|3":AM:"CO|9|1CO"
POS.REF = POS.REF:"|9|2CO|9|3":AM:"CO|10|1CO|10|2CO|10|3":AM:"CO|11|1CO|11|"
POS.REF = POS.REF:"2CO|11|3":AM:"CO|12|1CO|12|2CO|12|3":AM:"CO|13|1CO|13|2"
POS.REF = POS.REF:"CO|13|3":AM:"CO|14|1CO|14|2CO|14|3":AM:"CO|15|1CO|15|2CO"
POS.REF = POS.REF:"|15|3":AM:"CO|16|1CO|16|2CO|16|3":AM:"CO|17|1CO|17|2CO|1"
POS.REF = POS.REF:"7|3"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"45":AM:"45":AM:"01245":AM:"01245":AM:"01245":AM:"01245":AM:"01245"
POS.LOC = POS.LOC:"":AM:"01245":AM:"01245":AM:"01245":AM:"01245":AM:"01245":AM:"01245":AM:"0"
POS.LOC = POS.LOC:"1245":AM:"01245":AM:"01245":AM:"01245":AM:"01245":AM:"01245":AM:"01"
POS.LOC = POS.LOC:"245"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.COMP.PROG~
SUBROUTINE SH.SUBR.SCR.MAINT.COMP.PROG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgbgbgbg":AM:"bgbgbgbg":AM:"CO|1|1CO|1|2CO|1"
POS.REF = POS.REF:"|3":AM:"CO|2|1CO|2|2CO|2|3":AM:"CO|3|1CO|3|2CO|3|3":AM:"CO|4|"
POS.REF = POS.REF:"1CO|4|2CO|4|3":AM:"CO|5|1CO|5|2CO|5|3":AM:"CO|6|1CO|6|2"
POS.REF = POS.REF:"CO|6|3":AM:"CO|7|1CO|7|2CO|7|3":AM:"CO|8|1CO|8|2CO|8|3":AM:""
POS.REF = POS.REF:"CO|9|1CO|9|2CO|9|3":AM:"CO|10|1CO|10|2CO|10|3":AM:"CO|11"
POS.REF = POS.REF:"|1CO|11|2CO|11|3":AM:"CO|12|1CO|12|2CO|12|3":AM:"CO|13|1"
POS.REF = POS.REF:"CO|13|2CO|13|3":AM:"CO|14|1CO|14|2CO|14|3"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CO"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"0101528":AM:"0101528":AM:"01117":AM:"01117":AM:"01117"
POS.LOC = POS.LOC:"":AM:"01117":AM:"01117":AM:"01117":AM:"01117":AM:"01117":AM:"01117":AM:"0"
POS.LOC = POS.LOC:"1117":AM:"01117":AM:"01117":AM:"01117":AM:"01117"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.DISP.MSG~
SUBROUTINE SH.SUBR.SCR.MAINT.DISP.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgEF|1|1EF|1|1":AM:"":AM:"bgEX|1|1EX|1|1":AM:"":AM:"bgMSG"
POS.REF = POS.REF:"|1|1":AM:"MSG|2|1":AM:"MSG|3|1":AM:"MSG|4|1":AM:"MSG|5|1":AM:"MSG|6|1":AM:"MSG|7"
POS.REF = POS.REF:"|1":AM:"MSG|8|1"
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"02535":AM:"":AM:"02535":AM:"":AM:"022":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.EVENT.PVM~
SUBROUTINE SH.SUBR.SCR.MAINT.EVENT.PVM(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgDS|1|1":AM:"":AM:"bgSM|1|1bgDB|1|1bgC"
POS.REF = POS.REF:"C|1|1":AM:"bgDR|1|1":AM:"bgSD|1|1":AM:"bgDU|1|1":AM:"bgRT|1|1":AM:"":AM:"bg"
POS.REF = POS.REF:"RC|1|1":AM:"bgRS|1|1":AM:"":AM:"bgEC|1|1":AM:"bgPC|1|1":AM:"bgMC|1|1":AM:"":AM:"b"
POS.REF = POS.REF:"gST|1|1bgGU|1|1bgPU|1|1"
*
*REF.LNS*
DIM TDL(16); MAT TDL = EMPTY
DIM TDH(16); MAT TDH = EMPTY
DIM TDI(16); MAT TDI = EMPTY
DIM TDX(16); MAT TDX = ONE
DIM SAVE.TDX(16); MAT SAVE.TDX = EMPTY
DIM TDM(16); MAT TDM = EMPTY
DIM TDS(16); MAT TDS = EMPTY
DIM TDR(16); MAT TDR = EMPTY
DIM TDC(16); MAT TDC = EMPTY
DIM TDT(16); MAT TDT = EMPTY
VALID.REFS = "DS":AM:"SM":AM:"DB":AM:"CC":AM:"DR":AM:"SD":AM:"DU":AM:"RT":AM:"RC":AM:"RS":AM:"EC":AM:"PC":AM:"MC":AM:"ST":AM:"GU":AM:"PU"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"017":AM:"017":AM:"":AM:"01724415269":AM:"017":AM:"017":AM:"017":AM:"0"
POS.LOC = POS.LOC:"17":AM:"":AM:"017":AM:"017":AM:"":AM:"017":AM:"017":AM:"017":AM:"":AM:"01724415167"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.EVENT.PVM.PVE~
SUBROUTINE SH.SUBR.SCR.MAINT.EVENT.PVM.PVE(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey,|1|1,|1|1":AM:"bg":AM:",|1|1,|1|1,|1|1":AM:"bg"
POS.REF = POS.REF:",|1|1bgbgbgbgbgbgbg":AM:"bg,|1|1CH|1|1CH|1|2"
POS.REF = POS.REF:"CH|1|3CH|1|4CH|1|5CH|1|6":AM:"bg,|1|1CH|2|1CH|2|"
POS.REF = POS.REF:"2CH|2|3CH|2|4CH|2|5CH|2|6":AM:"bg,|1|1CH|3|1CH|3"
POS.REF = POS.REF:"|2CH|3|3CH|3|4CH|3|5CH|3|6":AM:"bg,|1|1CH|4|1CH|"
POS.REF = POS.REF:"4|2CH|4|3CH|4|4CH|4|5CH|4|6":AM:"bg,|1|1CH|5|1CH"
POS.REF = POS.REF:"|5|2CH|5|3CH|5|4CH|5|5CH|5|6":AM:"bg,|1|1CH|6|1C"
POS.REF = POS.REF:"H|6|2CH|6|3CH|6|4CH|6|5CH|6|6":AM:"bg,|1|1CH|7|1"
POS.REF = POS.REF:"CH|7|2CH|7|3CH|7|4CH|7|5CH|7|6":AM:"bg,|1|1CH|8|1"
POS.REF = POS.REF:"CH|8|2CH|8|3CH|8|4CH|8|5CH|8|6":AM:"bg,|1|1CH|9|"
POS.REF = POS.REF:"1CH|9|2CH|9|3CH|9|4CH|9|5CH|9|6":AM:"CH|10|1CH|10"
POS.REF = POS.REF:"|2CH|10|3CH|10|4CH|10|5CH|10|6":AM:"CH|11|1CH|11|2"
POS.REF = POS.REF:"CH|11|3CH|11|4CH|11|5CH|11|6":AM:"CH|12|1CH|12|2C"
POS.REF = POS.REF:"H|12|3CH|12|4CH|12|5CH|12|6":AM:"CH|13|1CH|13|2CH|"
POS.REF = POS.REF:"13|3CH|13|4CH|13|5CH|13|6":AM:"CH|14|1CH|14|2CH|14"
POS.REF = POS.REF:"|3CH|14|4CH|14|5CH|14|6"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"081647":AM:"51":AM:"515967":AM:"016293344515967"
POS.LOC = POS.LOC:"74":AM:"016334451596775":AM:"016334451596775":AM:"0"
POS.LOC = POS.LOC:"16334451596775":AM:"016334451596775":AM:"016"
POS.LOC = POS.LOC:"334451596775":AM:"016334451596775":AM:"016334"
POS.LOC = POS.LOC:"451596775":AM:"016334451596775":AM:"016334451"
POS.LOC = POS.LOC:"596775":AM:"334451596775":AM:"334451596775":AM:"334"
POS.LOC = POS.LOC:"451596775":AM:"334451596775":AM:"334451596775"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.HEADEND~
SUBROUTINE SH.SUBR.SCR.MAINT.HEADEND(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgNA|1|1":AM:"":AM:"bgCP|1|1"
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "NA":AM:"CP"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"012":AM:"022":AM:"":AM:"022"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.INTFC.MSG~
SUBROUTINE SH.SUBR.SCR.MAINT.INTFC.MSG(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bgEF|1|1EF|1|1":AM:"":AM:"bgEX|1|1EX|1|1"
POS.REF = POS.REF:"":AM:"":AM:"bgMSG|1|1":AM:"MSG|2|1":AM:"MSG|3|1":AM:"MSG|4|1":AM:"MSG|5|1":AM:"MSG|6"
POS.REF = POS.REF:"|1":AM:"MSG|7|1":AM:"MSG|8|1"
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "EF":AM:"EX":AM:"MSG"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"09":AM:"":AM:"02535":AM:"":AM:"02535":AM:"":AM:"022":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22":AM:"22"
POS.LOC = POS.LOC:"":AM:"22"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.INTFC.TYPES~
SUBROUTINE SH.SUBR.SCR.MAINT.INTFC.TYPES(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgbg":AM:"OP|1|1OP|1|2":AM:"OP|2|1OP|2|2":AM:"OP|3|1O"
POS.REF = POS.REF:"P|3|2":AM:"OP|4|1OP|4|2":AM:"OP|5|1OP|5|2":AM:"OP|6|1OP|6|2":AM:"OP"
POS.REF = POS.REF:"|7|1OP|7|2":AM:"OP|8|1OP|8|2":AM:"OP|9|1OP|9|2":AM:"OP|10|1OP"
POS.REF = POS.REF:"|10|2":AM:"OP|11|1OP|11|2":AM:"OP|12|1OP|12|2":AM:"OP|13|1OP|1"
POS.REF = POS.REF:"3|2":AM:"OP|14|1OP|14|2":AM:"OP|15|1OP|15|2":AM:"OP|16|1OP|16|"
POS.REF = POS.REF:"2":AM:"OP|17|1OP|17|2"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "OP"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"2026":AM:"2126":AM:"2126":AM:"2126":AM:"2126":AM:"2126":AM:"2126":AM:"21"
POS.LOC = POS.LOC:"26":AM:"2126":AM:"2126":AM:"2126":AM:"2126":AM:"2126":AM:"2126":AM:"2126":AM:"2126"
POS.LOC = POS.LOC:"":AM:"2126":AM:"2126"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.MANUFACTURER~
SUBROUTINE SH.SUBR.SCR.MAINT.MANUFACTURER(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgbg":AM:"bgbgbg":AM:"SU|1|1SU|1|2SU|1|3":AM:"SU|2|1"
POS.REF = POS.REF:"SU|2|2SU|2|3":AM:"SU|3|1SU|3|2SU|3|3":AM:"SU|4|1SU|4|2"
POS.REF = POS.REF:"SU|4|3":AM:"SU|5|1SU|5|2SU|5|3":AM:"SU|6|1SU|6|2SU|6|3":AM:"S"
POS.REF = POS.REF:"U|7|1SU|7|2SU|7|3":AM:"SU|8|1SU|8|2SU|8|3":AM:"SU|9|1SU"
POS.REF = POS.REF:"|9|2SU|9|3":AM:"SU|10|1SU|10|2SU|10|3":AM:"SU|11|1SU|11|"
POS.REF = POS.REF:"2SU|11|3":AM:"SU|12|1SU|12|2SU|12|3":AM:"SU|13|1SU|13|2"
POS.REF = POS.REF:"SU|13|3":AM:"SU|14|1SU|14|2SU|14|3"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SU"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"015":AM:"01520":AM:"31620":AM:"31620":AM:"31620":AM:"31620":AM:""
POS.LOC = POS.LOC:"31620":AM:"31620":AM:"31620":AM:"31620":AM:"31620":AM:"31620":AM:"3"
POS.LOC = POS.LOC:"1620":AM:"31620":AM:"31620":AM:"31620"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PPV.CHANNELS~
SUBROUTINE SH.SUBR.SCR.MAINT.PPV.CHANNELS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bgbgbgbg":AM:"bgbgbgbgbg":AM:"":AM:"CH|1|1"
POS.REF = POS.REF:"CH|1|2CH|1|3CH|1|4CH|1|5":AM:"CH|2|1CH|2|2CH|2|3"
POS.REF = POS.REF:"CH|2|4CH|2|5":AM:"CH|3|1CH|3|2CH|3|3CH|3|4CH|3|5":AM:"C"
POS.REF = POS.REF:"H|4|1CH|4|2CH|4|3CH|4|4CH|4|5":AM:"CH|5|1CH|5|2CH"
POS.REF = POS.REF:"|5|3CH|5|4CH|5|5":AM:"CH|6|1CH|6|2CH|6|3CH|6|4CH|"
POS.REF = POS.REF:"6|5":AM:"CH|7|1CH|7|2CH|7|3CH|7|4CH|7|5":AM:"CH|8|1CH|8"
POS.REF = POS.REF:"|2CH|8|3CH|8|4CH|8|5":AM:"CH|9|1CH|9|2CH|9|3CH|9|"
POS.REF = POS.REF:"4CH|9|5":AM:"CH|10|1CH|10|2CH|10|3CH|10|4CH|10|5"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"012":AM:"":AM:"0333845":AM:"05333845":AM:"":AM:"07344249":AM:"0"
POS.LOC = POS.LOC:"7344249":AM:"07344249":AM:"07344249":AM:"07344249"
POS.LOC = POS.LOC:"":AM:"07344249":AM:"07344249":AM:"07344249":AM:"073442"
POS.LOC = POS.LOC:"49":AM:"07344249"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PPV.DISTRIBUTORS~
SUBROUTINE SH.SUBR.SCR.MAINT.PPV.DISTRIBUTORS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"":AM:"bgbg":AM:"CL|1|1CL|1|2":AM:"CL|2|1CL|2|2":AM:"CL|3|1"
POS.REF = POS.REF:"CL|3|2":AM:"CL|4|1CL|4|2":AM:"CL|5|1CL|5|2":AM:"CL|6|1CL|6|2":AM:""
POS.REF = POS.REF:"CL|7|1CL|7|2":AM:"CL|8|1CL|8|2":AM:"CL|9|1CL|9|2":AM:"CL|10|1"
POS.REF = POS.REF:"CL|10|2":AM:"CL|11|1CL|11|2":AM:"CL|12|1CL|12|2":AM:"CL|13|1CL"
POS.REF = POS.REF:"|13|2":AM:"CL|14|1CL|14|2":AM:"CL|15|1CL|15|2"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"":AM:"2030":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2"
POS.LOC = POS.LOC:"130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"21"
POS.LOC = POS.LOC:"30"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PPV.EVENT~
SUBROUTINE SH.SUBR.SCR.MAINT.PPV.EVENT(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bg,|1|1":AM:"":AM:"":AM:"bgPM|1|1":AM:"bgCH|1|1":AM:"bg"
POS.REF = POS.REF:"RC|1|1":AM:"bgRS|1|1":AM:"bgSD|1|1":AM:"bgST|1|1":AM:"bgDU|1|1":AM:"bg"
POS.REF = POS.REF:"DN|1|1"
*
*REF.LNS*
DIM TDL(8); MAT TDL = EMPTY
DIM TDH(8); MAT TDH = EMPTY
DIM TDI(8); MAT TDI = EMPTY
DIM TDX(8); MAT TDX = ONE
DIM SAVE.TDX(8); MAT SAVE.TDX = EMPTY
DIM TDM(8); MAT TDM = EMPTY
DIM TDS(8); MAT TDS = EMPTY
DIM TDR(8); MAT TDR = EMPTY
DIM TDC(8); MAT TDC = EMPTY
DIM TDT(8); MAT TDT = EMPTY
VALID.REFS = "PM":AM:"CH":AM:"RC":AM:"RS":AM:"SD":AM:"ST":AM:"DU":AM:"DN"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"019":AM:"":AM:"019":AM:"":AM:"":AM:"019":AM:"019":AM:"019":AM:"019":AM:"019":AM:"019":AM:"0"
POS.LOC = POS.LOC:"19":AM:"019"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PPV.EVENT.CLASS~
SUBROUTINE SH.SUBR.SCR.MAINT.PPV.EVENT.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"":AM:"bgbg":AM:"CL|1|1CL|1|2":AM:"CL|2|1CL|2|2":AM:"CL|3|1"
POS.REF = POS.REF:"CL|3|2":AM:"CL|4|1CL|4|2":AM:"CL|5|1CL|5|2":AM:"CL|6|1CL|6|2":AM:""
POS.REF = POS.REF:"CL|7|1CL|7|2":AM:"CL|8|1CL|8|2":AM:"CL|9|1CL|9|2":AM:"CL|10|1"
POS.REF = POS.REF:"CL|10|2":AM:"CL|11|1CL|11|2":AM:"CL|12|1CL|12|2":AM:"CL|13|1CL"
POS.REF = POS.REF:"|13|2":AM:"CL|14|1CL|14|2":AM:"CL|15|1CL|15|2"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"":AM:"2030":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2"
POS.LOC = POS.LOC:"130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"21"
POS.LOC = POS.LOC:"30"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PPV.EVENTS~
SUBROUTINE SH.SUBR.SCR.MAINT.PPV.EVENTS(TDL.REC,PVE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVE.FILE,PVE.ID,MAT PVE,PVM.FILE,PVM.ID,PVM.ID.SAVE,MAT PVM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVE.EQUATES
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bg,|1|1":AM:"":AM:"":AM:"bgPM|1|1":AM:"bgCH|1|1":AM:"bg"
POS.REF = POS.REF:"RC|1|1":AM:"bgRS|1|1":AM:"bgSD|1|1":AM:"bgST|1|1":AM:"bgDU|1|1":AM:"bg"
POS.REF = POS.REF:"DN|1|1"
*
*REF.LNS*
DIM TDL(8); MAT TDL = EMPTY
DIM TDH(8); MAT TDH = EMPTY
DIM TDI(8); MAT TDI = EMPTY
DIM TDX(8); MAT TDX = ONE
DIM SAVE.TDX(8); MAT SAVE.TDX = EMPTY
DIM TDM(8); MAT TDM = EMPTY
DIM TDS(8); MAT TDS = EMPTY
DIM TDR(8); MAT TDR = EMPTY
DIM TDC(8); MAT TDC = EMPTY
DIM TDT(8); MAT TDT = EMPTY
VALID.REFS = "PM":AM:"CH":AM:"RC":AM:"RS":AM:"SD":AM:"ST":AM:"DU":AM:"DN"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"019":AM:"":AM:"019":AM:"":AM:"":AM:"019":AM:"019":AM:"019":AM:"019":AM:"019":AM:"019":AM:"0"
POS.LOC = POS.LOC:"19":AM:"019"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PPV.RATE.CLASS~
SUBROUTINE SH.SUBR.SCR.MAINT.PPV.RATE.CLASS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"":AM:"bgbg":AM:"CL|1|1CL|1|2":AM:"CL|2|1CL|2|2":AM:"CL|3|1"
POS.REF = POS.REF:"CL|3|2":AM:"CL|4|1CL|4|2":AM:"CL|5|1CL|5|2":AM:"CL|6|1CL|6|2":AM:""
POS.REF = POS.REF:"CL|7|1CL|7|2":AM:"CL|8|1CL|8|2":AM:"CL|9|1CL|9|2":AM:"CL|10|1"
POS.REF = POS.REF:"CL|10|2":AM:"CL|11|1CL|11|2":AM:"CL|12|1CL|12|2":AM:"CL|13|1CL"
POS.REF = POS.REF:"|13|2":AM:"CL|14|1CL|14|2":AM:"CL|15|1CL|15|2"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CL"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"":AM:"2030":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2"
POS.LOC = POS.LOC:"130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"2130":AM:"21"
POS.LOC = POS.LOC:"30"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PPV.RATES~
SUBROUTINE SH.SUBR.SCR.MAINT.PPV.RATES(TDL.REC,RTE.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,RTE.FILE,RTE.ID,MAT RTE,COM.FILE,COM.ID,COM.ID.SAVE,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP RTE.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP RTE.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"":AM:"bgkey":AM:"":AM:"bgkey":AM:"":AM:"bgPC|1|1":AM:"bgTX|1|"
POS.REF = POS.REF:"1":AM:"bg":AM:"bg":AM:"bgbg":AM:"AT|1|1AT|1|2":AM:"AT|2|1AT|2|2":AM:"AT|3|1A"
POS.REF = POS.REF:"T|3|2":AM:"AT|4|1AT|4|2":AM:"AT|5|1AT|5|2":AM:"AT|6|1AT|6|2":AM:"AT"
POS.REF = POS.REF:"|7|1AT|7|2"
*
*REF.LNS*
DIM TDL(3); MAT TDL = EMPTY
DIM TDH(3); MAT TDH = EMPTY
DIM TDI(3); MAT TDI = EMPTY
DIM TDX(3); MAT TDX = ONE
DIM SAVE.TDX(3); MAT SAVE.TDX = EMPTY
DIM TDM(3); MAT TDM = EMPTY
DIM TDS(3); MAT TDS = EMPTY
DIM TDR(3); MAT TDR = EMPTY
DIM TDC(3); MAT TDC = EMPTY
DIM TDT(3); MAT TDT = EMPTY
VALID.REFS = "PC":AM:"TX":AM:"AT"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"017":AM:"":AM:"017":AM:"":AM:"017":AM:"":AM:"017":AM:"017":AM:"0":AM:"0":AM:"010":AM:"410":AM:"41"
POS.LOC = POS.LOC:"0":AM:"410":AM:"410":AM:"410":AM:"410":AM:"410"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PVM.EVENT.NUMS~
SUBROUTINE SH.SUBR.SCR.MAINT.PVM.EVENT.NUMS(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey,|1|1,|1|1":AM:"bg":AM:",|1|1,|1|1":AM:"bg,|1|1"
POS.REF = POS.REF:"bgbgbgbgbgbg":AM:"bg,|1|1CH|1|1CH|1|2CH|1|3C"
POS.REF = POS.REF:"H|1|4CH|1|5":AM:"bg,|1|1CH|2|1CH|2|2CH|2|3CH|2|4"
POS.REF = POS.REF:"CH|2|5":AM:"bg,|1|1CH|3|1CH|3|2CH|3|3CH|3|4CH|3|5"
POS.REF = POS.REF:"":AM:"bg,|1|1CH|4|1CH|4|2CH|4|3CH|4|4CH|4|5":AM:"bg,|"
POS.REF = POS.REF:"1|1CH|5|1CH|5|2CH|5|3CH|5|4CH|5|5":AM:"bg,|1|1CH"
POS.REF = POS.REF:"|6|1CH|6|2CH|6|3CH|6|4CH|6|5":AM:"bg,|1|1CH|7|1C"
POS.REF = POS.REF:"H|7|2CH|7|3CH|7|4CH|7|5":AM:"bg,|1|1CH|8|1CH|8|2"
POS.REF = POS.REF:"CH|8|3CH|8|4CH|8|5":AM:"bg,|1|1CH|9|1CH|9|2CH|9|3"
POS.REF = POS.REF:"CH|9|4CH|9|5":AM:"CH|10|1CH|10|2CH|10|3CH|10|4CH|"
POS.REF = POS.REF:"10|5":AM:"CH|11|1CH|11|2CH|11|3CH|11|4CH|11|5":AM:"CH|12"
POS.REF = POS.REF:"|1CH|12|2CH|12|3CH|12|4CH|12|5":AM:"CH|13|1CH|13|2"
POS.REF = POS.REF:"CH|13|3CH|13|4CH|13|5":AM:"CH|14|1CH|14|2CH|14|3C"
POS.REF = POS.REF:"H|14|4CH|14|5"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "CH"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"081647":AM:"55":AM:"5262":AM:"016293344516172":AM:"01"
POS.LOC = POS.LOC:"63344526273":AM:"0163344526273":AM:"016334452"
POS.LOC = POS.LOC:"6273":AM:"0163344526273":AM:"0163344526273":AM:"01"
POS.LOC = POS.LOC:"63344526273":AM:"0163344526273":AM:"016334452"
POS.LOC = POS.LOC:"6273":AM:"0163344526273":AM:"3344526273":AM:"334452"
POS.LOC = POS.LOC:"6273":AM:"3344526273":AM:"3344526273":AM:"334452627"
POS.LOC = POS.LOC:"3"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PVM.PVE.XREF~
SUBROUTINE SH.SUBR.SCR.MAINT.PVM.PVE.XREF(TDL.REC,PVM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PVM.FILE,PVM.ID,MAT PVM,COM.FILE,COM.ID,COM.ID.SAVE,COM,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP PVM.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP PVM.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgDS|1|1":AM:"":AM:"":AM:"":AM:"":AM:"bgbgbgbgbgbg":AM:"EV|"
POS.REF = POS.REF:"1|1EV|1|2EV|1|3EV|1|4EV|1|5EV|1|6":AM:"EV|2|1EV|2"
POS.REF = POS.REF:"|2EV|2|3EV|2|4EV|2|5EV|2|6":AM:"EV|3|1EV|3|2EV|3|"
POS.REF = POS.REF:"3EV|3|4EV|3|5EV|3|6":AM:"EV|4|1EV|4|2EV|4|3EV|4|4"
POS.REF = POS.REF:"EV|4|5EV|4|6":AM:"EV|5|1EV|5|2EV|5|3EV|5|4EV|5|5"
POS.REF = POS.REF:"EV|5|6":AM:"EV|6|1EV|6|2EV|6|3EV|6|4EV|6|5EV|6|6":AM:"E"
POS.REF = POS.REF:"V|7|1EV|7|2EV|7|3EV|7|4EV|7|5EV|7|6":AM:"EV|8|1EV"
POS.REF = POS.REF:"|8|2EV|8|3EV|8|4EV|8|5EV|8|6":AM:"EV|9|1EV|9|2EV|"
POS.REF = POS.REF:"9|3EV|9|4EV|9|5EV|9|6":AM:"EV|10|1EV|10|2EV|10|3E"
POS.REF = POS.REF:"V|10|4EV|10|5EV|10|6"
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "DS":AM:"EV"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"08":AM:"016":AM:"":AM:"":AM:"":AM:"":AM:"162030405060":AM:"420304050"
POS.LOC = POS.LOC:"60":AM:"42030405060":AM:"42030405060":AM:"420304050"
POS.LOC = POS.LOC:"60":AM:"42030405060":AM:"42030405060":AM:"42030405"
POS.LOC = POS.LOC:"060":AM:"42030405060":AM:"42030405060":AM:"4203040"
POS.LOC = POS.LOC:"5060"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.PVM.XREF~
SUBROUTINE SH.SUBR.SCR.MAINT.PVM.XREF(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgDE|1|1":AM:"bgRA|1|1DB|1|1":AM:"bgCL|1|"
POS.REF = POS.REF:"1bgTA|1|1PU|1|1":AM:"bgSC|1|1bgST|1|1":AM:"bgMC|1|1":AM:"b"
POS.REF = POS.REF:"gCO|1|1":AM:"bgRC|1|1":AM:"bgbgbgRS|1|1bg":AM:"CO|1|1CO|1|"
POS.REF = POS.REF:"2":AM:"CO|2|1CO|2|2":AM:"CO|3|1CO|3|2":AM:"CO|4|1CO|4|2"
*
*REF.LNS*
DIM TDL(13); MAT TDL = EMPTY
DIM TDH(13); MAT TDH = EMPTY
DIM TDI(13); MAT TDI = EMPTY
DIM TDX(13); MAT TDX = ONE
DIM SAVE.TDX(13); MAT SAVE.TDX = EMPTY
DIM TDM(13); MAT TDM = EMPTY
DIM TDS(13); MAT TDS = EMPTY
DIM TDR(13); MAT TDR = EMPTY
DIM TDC(13); MAT TDC = EMPTY
DIM TDT(13); MAT TDT = EMPTY
VALID.REFS = "DE":AM:"DB":AM:"PU":AM:"ST":AM:"CO":AM:"CL":AM:"SC":AM:"MC":AM:"RC":AM:"RS":AM:"RA":AM:"TA":AM:"CO"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"08":AM:"016":AM:"556566":AM:"016556566":AM:"0165566":AM:"0"
POS.LOC = POS.LOC:"16":AM:"5566":AM:"016":AM:"014182140":AM:"418":AM:"418":AM:"418":AM:"418"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.SERVICE.CHANNELS~
SUBROUTINE SH.SUBR.SCR.MAINT.SERVICE.CHANNELS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgkey":AM:"bgkey":AM:"":AM:"bg":AM:"":AM:"":AM:"":AM:"":AM:"CLO|1|1":AM:"bg":AM:"bg":AM:"":AM:"":AM:"bg":AM:"C"
POS.REF = POS.REF:"HI|1|1":AM:"bg":AM:"bg"
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "CLO":AM:"CHI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"010":AM:"010":AM:"":AM:"10":AM:"":AM:"":AM:"":AM:"":AM:"10":AM:"10":AM:"10":AM:"":AM:"":AM:"10":AM:"10":AM:"10":AM:"10"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.SERVICE.TIERS~
SUBROUTINE SH.SUBR.SCR.MAINT.SERVICE.TIERS(TDL.REC,PAR.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,PAR.FILE,PAR.ID,PAR,SVC.FILE,SVC.ID,SVC.ID.SAVE,MAT SVC,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
$INCLUDE IBP SVC.DIM
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP SVC.EQUATES
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"":AM:"bgbgbgbg":AM:"SC|1|1SC|1|2SC|1|3SC|1|4":AM:"S"
POS.REF = POS.REF:"C|2|1SC|2|2SC|2|3SC|2|4":AM:"SC|3|1SC|3|2SC|3|3SC"
POS.REF = POS.REF:"|3|4":AM:"SC|4|1SC|4|2SC|4|3SC|4|4":AM:"SC|5|1SC|5|2SC|"
POS.REF = POS.REF:"5|3SC|5|4":AM:"SC|6|1SC|6|2SC|6|3SC|6|4":AM:"SC|7|1SC|7"
POS.REF = POS.REF:"|2SC|7|3SC|7|4":AM:"SC|8|1SC|8|2SC|8|3SC|8|4":AM:"SC|9|"
POS.REF = POS.REF:"1SC|9|2SC|9|3SC|9|4":AM:"SC|10|1SC|10|2SC|10|3SC|"
POS.REF = POS.REF:"10|4":AM:"SC|11|1SC|11|2SC|11|3SC|11|4":AM:"SC|12|1SC|12"
POS.REF = POS.REF:"|2SC|12|3SC|12|4":AM:"SC|13|1SC|13|2SC|13|3SC|13|4"
POS.REF = POS.REF:"":AM:"SC|14|1SC|14|2SC|14|3SC|14|4":AM:"SC|15|1SC|15|2S"
POS.REF = POS.REF:"C|15|3SC|15|4":AM:"SC|16|1SC|16|2SC|16|3SC|16|4"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SC"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"":AM:"0124060":AM:"0124060":AM:"0124060":AM:"0124060":AM:""
POS.LOC = POS.LOC:"0124060":AM:"0124060":AM:"0124060":AM:"0124060":AM:"0124"
POS.LOC = POS.LOC:"060":AM:"0124060":AM:"0124060":AM:"0124060":AM:"0124060":AM:"0"
POS.LOC = POS.LOC:"124060":AM:"0124060":AM:"0124060":AM:"0124060"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.SUPPLIERS~
SUBROUTINE SH.SUBR.SCR.MAINT.SUPPLIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"bgbgbgbg":AM:"bgbgbgbg":AM:"SU|1|1SU|1|2SU|1"
POS.REF = POS.REF:"|3":AM:"SU|2|1SU|2|2SU|2|3":AM:"SU|3|1SU|3|2SU|3|3":AM:"SU|4|"
POS.REF = POS.REF:"1SU|4|2SU|4|3":AM:"SU|5|1SU|5|2SU|5|3":AM:"SU|6|1SU|6|2"
POS.REF = POS.REF:"SU|6|3":AM:"SU|7|1SU|7|2SU|7|3":AM:"SU|8|1SU|8|2SU|8|3":AM:""
POS.REF = POS.REF:"SU|9|1SU|9|2SU|9|3":AM:"SU|10|1SU|10|2SU|10|3":AM:"SU|11"
POS.REF = POS.REF:"|1SU|11|2SU|11|3":AM:"SU|12|1SU|12|2SU|12|3":AM:"SU|13|1"
POS.REF = POS.REF:"SU|13|2SU|13|3":AM:"SU|14|1SU|14|2SU|14|3"
*
*REF.LNS*
DIM TDL(1); MAT TDL = EMPTY
DIM TDH(1); MAT TDH = EMPTY
DIM TDI(1); MAT TDI = EMPTY
DIM TDX(1); MAT TDX = ONE
DIM SAVE.TDX(1); MAT SAVE.TDX = EMPTY
DIM TDM(1); MAT TDM = EMPTY
DIM TDS(1); MAT TDS = EMPTY
DIM TDR(1); MAT TDR = EMPTY
DIM TDC(1); MAT TDC = EMPTY
DIM TDT(1); MAT TDT = EMPTY
VALID.REFS = "SU"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"0122254":AM:"0122254":AM:"11222":AM:"11222":AM:"11222"
POS.LOC = POS.LOC:"":AM:"11222":AM:"11222":AM:"11222":AM:"11222":AM:"11222":AM:"11222":AM:"1"
POS.LOC = POS.LOC:"1222":AM:"11222":AM:"11222":AM:"11222":AM:"11222"
*
RETURN; * To calling program
*
!
*
END
~SH.SUBR.SCR.MAINT.TIERS~
SUBROUTINE SH.SUBR.SCR.MAINT.TIERS(TDL.REC,COM.ID.SAVE,MAT CNT.TST,CNT.TST.ID,TT,GENERIC,CURSOR.KEYS,NUMC,CO.DATA,DISP.ONLY,AUTO.RUN,REDISP,LPT.FL,TYPE.RUN,PHAN.RUN,RSPBUF,PROCBUF,TM.MAX,STAT,COM.FILE,COM.ID,COM,PAR.FILE,PAR.ID,PAR.ID.SAVE,PAR,LOCKS.FILE,POS.LOC,POS.REF)
*
*
$INCLUDE IBP STANDARD.FUNCTIONS.SUBR
*OVERRIDE
*
$INCLUDE IBP SEC.USER.DIM
$INCLUDE IBP SEC.USER.EQUATES
*
$INCLUDE IBP PAR.MENU.DIM
$INCLUDE IBP PAR.MENU.EQUATES
*
$INCLUDE IBP SEC.USER.ON
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
*
*DIM.LNS*
DIM STD(50); MAT STD = EMPTY
*DIM.END*
*
*EQU.LNS*
$INCLUDE IBP STANDARD.FUNCTIONS.CLB
*EQU.END*
*
POS.REF = "hdr":AM:"bg":AM:"":AM:"key":AM:"bgkey":AM:"":AM:"bg":AM:"":AM:"":AM:"":AM:"":AM:"bg":AM:"bg":AM:"bg":AM:"CLO|1|1":AM:"":AM:"bg":AM:"bg"
POS.REF = POS.REF:"":AM:"bg":AM:"bg":AM:"CHI|1|1"
*
*REF.LNS*
DIM TDL(2); MAT TDL = EMPTY
DIM TDH(2); MAT TDH = EMPTY
DIM TDI(2); MAT TDI = EMPTY
DIM TDX(2); MAT TDX = ONE
DIM SAVE.TDX(2); MAT SAVE.TDX = EMPTY
DIM TDM(2); MAT TDM = EMPTY
DIM TDS(2); MAT TDS = EMPTY
DIM TDR(2); MAT TDR = EMPTY
DIM TDC(2); MAT TDC = EMPTY
DIM TDT(2); MAT TDT = EMPTY
VALID.REFS = "CLO":AM:"CHI"
*REF.END*
*
!
*
*REF.END*
*
*
!
*
POS.LOC = "0":AM:"0":AM:"":AM:"27":AM:"027":AM:"":AM:"10":AM:"":AM:"":AM:"":AM:"":AM:"10":AM:"10":AM:"10":AM:"10":AM:"":AM:"10":AM:"10":AM:"10":AM:"10":AM:"10"
*
RETURN; * To calling program
*
!
*
END
~SPLIT.PPV.BUYS.PA~
*PROGRAM: SPLIT.PPV.BUYS.PA
* VERSION: 950508 1.6  Changed error handling (wrong error type or not printing). Imported 08-MAY-95.
* PRIOR: 950507 1.5  Add separate Validation Counters (VAL.VAL/ERR/TOT & EVENT.MAN).
* PRIOR: 941120 1.4  SERIAL#, CO.PREFIX VALIDATION MOVE IN FROM SPLIT.
*                      RESTRUCTURED AT MATREAD ACT.
* PRIOR: 941011 1.3  WAS NOT RESETTING EVENT.BAD BEFORE EACH EVENT.
* PRIOR: 940807 1.2  IF DURATION NOT 15 DO NOT BILL, FIX ONE EVENT ERROR
*                    TO NOT REJECT VALID EVENTS FOR AN ACCOUNT.
* PRIOR: 921213 1.0  SPLIT AND BATCH IMPULSE PPV BUYS BY COMPANY.
*** EXPORTED TO FCI 20NOV94
*** IMPORTED FROM FCI 15NOV94
*** IMPORTED FROM FCI, CHANGED PER 1.2, AND EXPORTED TO FCI 07AUG94.
VS = " V:1.6"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1993              ALL RIGHTS RESERVED
*  
* AUTHOR:          HARVEY HORSMAN
* DESCRIPTION:     THIS PROGRAM PROCESSES THE XPV FILE.
* The data is output to the CAJ files for each company into valid and
* error batches. The errors identified are:
* 1) Device not on file.
* 2) Invalid company.
* 3) Device not attached to an account.
* 4) No Event Master for the Event Detail.
* 5) Manual pricing is required.
* This file can be uploaded to the host more than once per day. It con-
* tains PPV Buys to be applied to customer acccounts. There can be more
* than one day to process at a time. Buys for all three companies can
* be present and are handled appropriately through file pointers.
!
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP ACT.DIM
$INCLUDE IBP ACT.EQUATES
*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
*
$INCLUDE IBP CNT.XPVCTL.DIM
$INCLUDE IBP CNT.XPVCTL.EQUATES
*
$INCLUDE IBP XPV.DIM
$INCLUDE IBP XPV.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
!
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "BI"
SYS.PROG = "SPLIT.PPV.BUYS.PA"
*
* Open files
*
OPEN "XPV" TO XPV.FILE ELSE PRINT "Can't open file XPV":; INPUT RSP:; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT "Can't open file PVE":; INPUT RSP:; STOP
OPEN "AIX" TO AIX.FILE ELSE PRINT "Can't open file AIX":; INPUT RSP:; STOP
OPEN "COM" TO COM.FILE ELSE PRINT "Can't open file COM":; INPUT RSP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT RSP:; STOP
* ULT ONLY
OPEN "LOCKS" TO LCK.FILE ELSE PRINT "Can't open file LOCKS":; INPUT RSP:; STOP
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.TYPE = -5
STAT = FALSE
*
MAX.DESC = ONE; DESC.LEN = 5; INPUT.DESC = "N"
*
TITLE = "AI"
TITLE1 = "Validate Uploaded Terminal IDs":VS
TRANS.CLASS = 'b'; TRANS.ITEM = "TRANS.TYPES.BIL"
*
MAT XPV = EMPTY; MAT CNT.XPVCTL = EMPTY
SOURCE = "B"; LC.SOURCE = CHAR(SEQ(SOURCE)+32)
OPERATOR = "AI"; OPER = OPERATOR; DEFAULT.TYPE = "IP"; ITEM.COUNT = 0
BATCH.STATUS = "E"; ENTRY.TIME = EMPTY; ENTRY.DATE = EMPTY
POST.DATE = EMPTY; POST.TIME = EMPTY; BUS.DATE = EMPTY; EFF.DATE = EMPTY
TRANS.TYPES = EMPTY; BATCH.DEL.STATUS = FALSE
BATCH.TYPE = EMPTY; BATCH.LPT.DT = EMPTY; BATCH.LPT.TM = EMPTY
***BATCH.CLASS = EMPTY; BATCH.INP.SOURCE = EMPTY; BATCH.LST = EMPTY
BATCH.SOURCE = SOURCE; BATCH.CLASS = "3"; BATCH.INP.SOURCE = "5"; BATCH.LST = EMPTY
BATCH.TILL = EMPTY; XTR.POST.REG = ""; XTR.POST.ERR = ""; XTR.POST.OTH = ""
RUN.TRANS.CLASS = TRANS.CLASS
RUN.SOURCE = SOURCE; CNT.TST$LBL = ""
RUN.LC.SOURCE = LC.SOURCE
*
XPV.DT.CURR = DATE(); XPV.DT.CURR.ID = EMPTY; XPV.DT = EMPTY; XPV.REC.TYPE.NEXT = EMPTY
VAL.ERRORS = ""; XPV.SEQ = ZERO; XPV.SEQ.LAST = ZERO; XPV.REC.TOT.CN = ZERO; XPV.REC.ERR.CN = ZERO
ATM = 1; XPV.REC.VAL.CN = ZERO; XPV.EVENT.VAL.CN = ZERO; XPV.EVENT.ERR.CN = ZERO; XPV.EVENT.TOT.CN = ZERO
XPV.VAL.VAL.CN = ZERO; XPV.VAL.ERR.CN = ZERO; XPV.VAL.TOT.CN = ZERO
XPV.EVENT.MAN.CN = ZERO; XPV.TYPE = EMPTY; XPV.BAT = ZERO; XPV.BAT.LAST = ZERO
*
START: *
PRINT @(0,3):CLS:
IF CNT.TST$LBL THEN PRINT CLB:"Start ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
READ AI.COS FROM COM.FILE,"AI.COS" ELSE AI.COS = ""
MATREAD CNT.XPVCTL FROM CNT.FILE,"XPV.CTL" ELSE MAT CNT.XPVCTL = EMPTY
LOCATE DATE() IN CNT.XPVCTL$SPLIT.DT<1> BY "DL" SETTING LOC THEN
LOOP
PRINT @(5,3):CLL:"Uploaded PPV Buys have already been processed today.":
PRINT @(5,4):CLL:"Do you still want to proceed? (Y/<cr>): ":; INPUT TMP:
IF TMP = "" THEN STOP
UNTIL TMP = "Y" DO PRINT BELL REPEAT
END
*
READ A.PER FROM CNT.FILE,"CURRENT.ACCTG.PERIOD" ELSE A.PER = ""
READV CURR.PER FROM COM.FILE,"CURR.PPV.REPORT.PERIOD",2 ELSE CURR.PER = A.PER
DAY = 31; MTH = CURR.PER[3,2]; YEAR = CURR.PER[1,2]
*
ENTERED.PERIOD = CURR.PER
LOOP
PRINT @(0,5):"Enter Next Report Period or <cr> to use the Current Report Period: ":CURR.PER:
PRINT @(67,5):
INPUT ENTERED.PERIOD:
IF ENTERED.PERIOD = "KILL" THEN STOP
TEXT = ""
IF ENTERED.PERIOD = "" THEN ENTERED.PERIOD = CURR.PER
IF NOT(ENTERED.PERIOD MATCHES "4N") THEN TEXT = "please use format YYMM"
IF TEXT NE "" THEN
PRINT CLB:TEXT:" - press <cr> ":; INPUT RSP:; IF RSP = "KILL" THEN STOP
END
UNTIL TEXT = "" DO
REPEAT
CURR.PER = ENTERED.PERIOD
*
NEXT.PER = CURR.PER+1
*
*
CO.PRE = EMPTY; CO.FIRST = TRUE
BATCH.SOURCE = SOURCE; BATCH.CLASS.CURR = 3; BATCH.SOURCE.CURR = 5
GOSUB OPEN.COMPANY
*
*
GOSUB LOAD.TST
IF CNT.TST$ON THEN VS = VS:"*** TEST MODE ***"
*
!
* Write auto.run
EXEC.VERB = "RUN BP.AI SPLIT.PPV.BUYS.PA"
EXEC.IN = CURR.PER
EXEC.DESC = "Split IPPV Buys"
EXEC.INS = BATCH.CLASS.CURR
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
!
* Load control
*
READ ATR.FLAG FROM CNT.FILE,"ATR.FLAG" ELSE ATR.FLAG = TRUE
READ ACG.FLAG FROM CNT.FILE,"ACG.FLAG" ELSE ACG.FLAG = TRUE
READ ACT.FLAG FROM CNT.FILE,"ACT.FLAG" ELSE ACT.FLAG = TRUE
READ ALL.FLAG FROM CNT.FILE,"ALL.FLAG" ELSE ALL.FLAG = TRUE
IF NOT(ALL.FLAG) THEN ATR.FLAG = FALSE; ACG.FLAG = FALSE; ACT.FLAG = FALSE
*
* $INCLUDE IBP CASH.INCL.LCK.XTR
*
* IF STAT THEN STOP
*
DOLLAR.EDIT = EMPTY; STAT = EMPTY; POSTED.BATCHES = EMPTY
!
* Process items
*
* Validate XPV file
*
VALIDATE.FILE: *
IF CNT.TST$LBL THEN PRINT CLB:"Validate ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
*Select the XPV file by date*sequence number
PRINT @(0,18):
EXLN = 'WITH DONE = ""'
* ULT ONLY
EXECUTE 'SSELECT XPV ':EXLN, //SELECT. > XPV.VALID.ID.LIST
* EXECUTE 'SSELECT XPV ':EXLN; * REV ONLY
*
* Read next record
*
LOOP
* ULT ONLY
READNEXT XPV.ID FROM XPV.VALID.ID.LIST ELSE
XPV.ID = "@@@"; * ULT ONLY
PRINT BELL:; * ULT ONLY
END; * ULT ONLY
* READNEXT XPV.ID ELSE XPV.ID = "@@@"; * REV ONLY
MATREAD XPV FROM XPV.FILE,XPV.ID ELSE MAT XPV = EMPTY
*
XPV.DT = OCONV(FIELD(XPV.ID,"*",ONE),"D2")
XPV.SEQ = FIELD(XPV.ID,"*",TWO)
AIX.ID  = FIELD(XPV.ID,"*",3)
XPV.EVENTS = XPV$EVENT.NUMS
XPV.ACCOUNT = XPV$ACCOUNT
*
UNTIL XPV.ID = "@@@" DO
*
XPV.ERROR   = ""; XPV.STAT = ""
MATREAD AIX FROM AIX.FILE,AIX.ID THEN
XPV.CO = XPV.ACCOUNT[1,1]
LOCATE XPV.CO IN AI.COS<1> BY "AR" SETTING LOC ELSE XPV.ERROR = 2; XPV.STAT = "Invalid Co."
END ELSE
XPV.ERROR = 1
XPV.ACCOUNT = "000000"
XPV.STAT = "Unknown Terminal"
END
*
* 950507 * IF XPV.ERROR THEN XPV.STAT = "Error" ELSE XPV.STAT = XPV.ACCOUNT
XPV.VAL.TOT.CN = XPV.VAL.TOT.CN+1
PRINT @(10,10):"Count: ":XPV.REC.TOT.CN "R#5":"  Terminal: ":AIX.ID:"  Account: ":XPV.STAT:
*
IF NOT(XPV.ERROR) THEN
XPV.VAL.VAL.CN = XPV.VAL.VAL.CN+1
END ELSE
*
XPV$ERROR = XPV.ERROR
VAL.ERRORS<1,ATM> = AIX.ID
VAL.ERRORS<2,ATM> = XPV.DT
VAL.ERRORS<3,ATM> = XPV.SEQ
VAL.ERRORS<4,ATM> = XPV.EVENTS
*
*
* END
XPV.VAL.ERR.CN = XPV.VAL.ERR.CN+1; ATM = ATM+1
END
*
XPV$DONE = "V"
*
IF CNT.TST$X THEN
PRINT CLB:"Validate completed for ":XPV.ID:". Enter <cr>: ":; INPUT TMP:
END
MATWRITE XPV ON XPV.FILE,XPV.ID
REPEAT
!
*
SPLIT.XPV: *
IF CNT.TST$LBL THEN PRINT CLB:"Split ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
TITLE1 = "Process and Batch by Company"
IF NOT(STAT) THEN
*
PRINT @(ZERO,6):CLL:SPACE(40 - LEN(TITLE1) / TWO + .5):RVB:TITLE1:RVE:
*
*Select the XPV file by date by Company
PRINT @(0,18):
EXLN = 'WITH DONE EQ "V" BY DATE BY ACCT'
EXECUTE 'SSELECT XPV ':EXLN
*
* Init fields
*
XPV.DT.CURR = DATE(); XPV.DT.CURR.ID = EMPTY; XPV.DT = EMPTY
CO.NO = EMPTY; CO.NO.LAST = EMPTY
BAT.CN = ZERO; BAT.CN.BAD = ZERO
CAJ = EMPTY; CAJ.BAD = EMPTY
ITEM.COUNT = ZERO; ANY.FAILED = FALSE; ANY.SPLIT = FALSE
BATCH.TOTAL = ZERO; BATCH.TOTAL.BAD = ZERO
ENTERED.TOTAL = ZERO; ENTERED.TOTAL.BAD = ZERO
ADJUST.TOTAL = ZERO; ADJUST.TOTAL.BAD = ZERO
XPV.REC.TYPE = EMPTY
*
* Main Loop
*
LOOP
*
*Read next id
*
READNEXT XPV.ID ELSE
XPV.ID = "@@@"
PRINT BELL:
END
IF XPV.ID NE "@@@" THEN
MATREAD XPV FROM XPV.FILE,XPV.ID ELSE MAT XPV = EMPTY
PRINT @(25,10):XPV.ID "L#16":
END
*
XPV.DT   = OCONV(FIELD(XPV.ID,"*",ONE),"D2")
XPV.SEQ  = FIELD(XPV.ID,"*",TWO)
DVC.ID   = FIELD(XPV.ID,"*",3)
XPV.ACCOUNT = XPV$ACCOUNT
XPV.ERROR   = XPV$ERROR
CO.NO       = XPV$ACC
XPV.AI.CODE = XPV$AI.CODE
EVENTS      = XPV$EVENT.NUMS
DURS        = XPV$DUR
*
TRANS = EMPTY; TRANS.BAD = EMPTY
EVENT.GOOD = EMPTY; EVENT.BAD = EMPTY; TRANS.ERR = FALSE
*
UNTIL XPV.ID EQ "@@@" OR STAT DO
XPV.REC.TOT.CN = XPV.REC.TOT.CN+1
*
*
* Build Trans information
TRANS<ONE,6> = " Date ":XPV.DT:" Seq ":XPV.SEQ:" Dvc ":DVC.ID:" "
*
* Load transactions type
TRANS<ONE,TWO> = "IP"
*
* Load description (blank because IP is predefined and looked up)
TRANS<ONE,4> = EMPTY
*
* Load Error Trans
TRANS.BAD = TRANS
*
*
*Close batches if Company changed and its not an empty Co. (error).
IF CO.NO NE "" AND CO.NO NE CO.NO.LAST THEN
GOSUB CHANGE.COMPANY
END
*
IF XPV.ERROR THEN
IF XPV.ERROR = 1 THEN
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:"Uploaded Terminal ID not on file"
END ELSE
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:"Invalid Account Prefix (CO)"
END
XPV.REC.ERR.CN = XPV.REC.ERR.CN+1
END ELSE
*
XPV.REC.VAL.CN = XPV.REC.VAL.CN+1
*
* Read account
MATREAD ACT FROM ACT.FILE,XPV.ACCOUNT THEN
*
*Process Event Numbers
*
VC = 1
LOOP EVENT.ID = TRIM(EVENTS<1,VC>) UNTIL EVENT.ID = "" DO
*
* Check max batch size
IF CO.NO NE EMPTY AND BAT.CN GE 100 THEN
BATCH.STATUS = "C"
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO; BATCH.TOTAL = ZERO; ENTERED.TOTAL = ZERO
END
*
IF CO.NO NE EMPTY AND BAT.CN.BAD GE 50 THEN
SAVE.CAJ = CAJ; SAVE.BAT.CN = BAT.CN
SAVE.BATCH.TOTAL = BATCH.TOTAL; SAVE.ENTERED.TOTAL = ENTERED.TOTAL
BATCH.STATUS = "E"
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = SAVE.CAJ; BAT.CN = SAVE.BAT.CN
BATCH.TOTAL = SAVE.BATCH.TOTAL; ENTERED.TOTAL = SAVE.ENTERED.TOTAL
END
*
EVENT.GOOD = FALSE; EVENT.BAD = FALSE
XPV.EVENT.TOT.CN = XPV.EVENT.TOT.CN+1
EVENT.ID = XPV.AI.CODE:"*":("0000":EVENT.ID) "R#4"
MATREAD PVE FROM PVE.FILE,EVENT.ID ELSE MAT PVE = ""; EVENT.BAD = TRUE
IF EVENT.BAD THEN
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:"Event ":EVENT.ID:" not on file"
XPV.EVENT.ERR.CN = XPV.EVENT.ERR.CN+1
END ELSE
IF (PVE$RATE.CL = "MANUAL") OR (PVE$RATE.CL.SUB = "MANUAL") THEN
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:"Event ":EVENT.ID:" is manual pricing"
XPV.EVENT.MAN.CN = XPV.EVENT.MAN.CN+1
EVENT.BAD = TRUE
END ELSE
IF DURS<1,VC> NE "15" THEN
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:"Event ":EVENT.ID:" Dur. ":DURS<1,VC>:" not billed"
EVENT.BAD = TRUE
END ELSE
*
AIX.ID  = FIELD(XPV.ID,"*",3)
MATREAD AIX FROM AIX.FILE,AIX.ID ELSE MAT AIX = ""
EVENT.DT = PVE$DT
HIT = FALSE; AVC = 1
LOOP ACT.ID = AIX$ACT.ID<1,AVC> UNTIL ACT.ID = "" DO
IF EVENT.DT GE AIX$START.DATE<1,AVC> AND (EVENT.DT LE AIX$STOP.DATE<1,AVC> OR AIX$STOP.DATE<1,AVC> = "") THEN HIT = TRUE; XPV.ACCOUNT = ACT.ID
AVC = AVC+1
REPEAT
*
IF NOT(HIT) THEN
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:"No active account during ":OCONV(EVENT.DT,"D2"):" for Event ":EVENT.ID:" "
EVENT.BAD = TRUE
END ELSE
*
TRANS<ONE,8> = TRANS<ONE,8>:EVENT.ID:SVM
XPV.EVENT.VAL.CN = XPV.EVENT.VAL.CN+1
EVENT.GOOD = TRUE
END; * of hit on event
*
END; * of valid duration
*
END; * of not manual
*
END; * of event on file
*
VC = VC+1
*
REPEAT
*
END ELSE
* of valid acct #
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:XPV.ACCOUNT:" Account not on file"
TRANS.ERR = TRUE
END; * of account not on file
*
END; * of not xpv.error
*
*
*Write into batch
*
IF XPV.ACCOUNT NE "" THEN
CALL MOD11.DIGIT(XPV.ACCOUNT,CD)
TRANS.ACCT = XPV.ACCOUNT:CD
END ELSE TRANS.ACCT = "0000000"
*
IF EVENT.GOOD THEN
*
TRANS<ONE,ONE> = TRANS.ACCT
*
*Increment batch detail count
BAT.CN = BAT.CN + ONE
*
*Write into batch
CAJ<-ONE> = TRANS
*
END
*
IF (TRANS.ERR OR EVENT.BAD OR XPV.ERROR) THEN
*
*Place events in error trans.
IF TRANS.ERR OR XPV.ERROR THEN
EVC = 1; ETEXT = ". Unbilled events: "
LOOP E.ID = EVENTS<1,EVC> UNTIL E.ID = "" DO
ETEXT = ETEXT:E.ID:", "
EVC = EVC+1
REPEAT
TRANS.BAD<ONE,7> = TRANS.BAD<ONE,7>:ETEXT
END
*
*Increment batch detail count
BAT.CN.BAD = BAT.CN.BAD + ONE
*
*Write into batch
TRANS.BAD<ONE,ONE> = TRANS.ACCT
CAJ.BAD<-ONE> = TRANS.BAD
*
END
*
XPV$DONE = "Y"
*
IF CNT.TST$X THEN
PRINT CLB:"Processing complete for :":XPV.ID:" Enter <cr>: ":; INPUT TMP:
END
*
MATWRITE XPV ON XPV.FILE,XPV.ID
*
! Next record
REPEAT
*
*
CO.NO = "@@@"; IF CO.NO.LAST = "" THEN CO.NO.LAST = CO.NO
*
GOSUB CHANGE.COMPANY
*
END; * of STAT
*
!
*
* End of program
*
FINISH: *
IF CNT.TST$LBL THEN PRINT CLB:"Finish ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
IF XPV.REC.TOT.CN THEN
*
* Update Control Record
*
MATREAD CNT.XPVCTL FROM BASE.CNT.FILE,"XPV.CTL" ELSE MAT CNT.XPVCTL = EMPTY
INS XPV.DT.CURR        BEFORE CNT.XPVCTL$SPLIT.DT<ONE,ONE>
INS XPV.REC.VAL.CN     BEFORE CNT.XPVCTL$REC.VAL.CN<ONE,ONE>
INS XPV.REC.ERR.CN     BEFORE CNT.XPVCTL$REC.ERR.CN<ONE,ONE>
INS XPV.REC.TOT.CN     BEFORE CNT.XPVCTL$REC.TOT.CN<ONE,ONE>
INS XPV.EVENT.VAL.CN   BEFORE CNT.XPVCTL$EVENT.VAL.CN<ONE,ONE>
INS XPV.EVENT.ERR.CN   BEFORE CNT.XPVCTL$EVENT.ERR.CN<ONE,ONE>
INS XPV.EVENT.TOT.CN   BEFORE CNT.XPVCTL$EVENT.TOT.CN<ONE,ONE>
INS XPV.EVENT.MAN.CN   BEFORE CNT.XPVCTL$EVENT.MAN.CN<ONE,ONE>
INS XPV.VAL.VAL.CN     BEFORE CNT.XPVCTL$VAL.VAL.CN<ONE,ONE>
INS XPV.VAL.ERR.CN     BEFORE CNT.XPVCTL$VAL.ERR.CN<ONE,ONE>
INS XPV.VAL.TOT.CN     BEFORE CNT.XPVCTL$VAL.TOT.CN<ONE,ONE>
*
* Clean the Control Record
*
LOOP
TMP = DCOUNT(CNT.XPVCTL$SPLIT.DT,VM)
WHILE TMP GT 15 AND NOT(STAT) DO
DEL CNT.XPVCTL$SPLIT.DT<ONE,16>
DEL CNT.XPVCTL$REC.VAL.CN<ONE,16>
DEL CNT.XPVCTL$REC.ERR.CN<ONE,16>
DEL CNT.XPVCTL$REC.TOT.CN<ONE,16>
DEL CNT.XPVCTL$EVENT.VAL.CN<ONE,16>
DEL CNT.XPVCTL$EVENT.ERR.CN<ONE,16>
DEL CNT.XPVCTL$EVENT.TOT.CN<ONE,16>
DEL CNT.XPVCTL$EVENT.MAN.CN<ONE,16>
DEL CNT.XPVCTL$VAL.VAL.CN<ONE,16>
DEL CNT.XPVCTL$VAL.ERR.CN<ONE,16>
DEL CNT.XPVCTL$VAL.TOT.CN<ONE,16>
REPEAT
*
MATWRITE CNT.XPVCTL ON BASE.CNT.FILE,"XPV.CTL"
END
*
IF VAL.ERRORS NE "" THEN
PRINTER ON
PRINT "                Validation Errors from IPPV Split"
PRINT
PRINT
ATM = 1
LOOP UNTIL VAL.ERRORS<1,ATM> EQ "" DO
PRINT SPACE(15):VAL.ERRORS<1,ATM>:"  Date ":VAL.ERRORS<2,ATM>:"  Seq ":VAL.ERRORS<3,ATM>:"  Events ":VAL.ERRORS<4,ATM>
PRINT
ATM = ATM+1
REPEAT
PRINTER OFF
END
*
*
*
IF STAT AND NOT(AUTO.RUN) THEN PRINT BELL:; INPUT RSP:
*
! Unlock control info
*
$INCLUDE IBP CASH.INCL.RELS.XTR
*
WRITEV CURR.PER ON COM.FILE,"CURR.PPV.REPORT.PERIOD",2
*
STOP
!
*
* Subroutines
*
OPEN.BATCH: *
IF CNT.TST$LBL THEN PRINT CLB:"Open Batch ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
BATCH.TOTAL = ZERO; BATCH.TOTAL.BAD = ZERO
ENTERED.TOTAL = ZERO; ENTERED.TOTAL.BAD = ZERO
ADJUST.TOTAL = ZERO; ADJUST.TOTAL.BAD = ZERO
ITEM.COUNT = ZERO
*
RETURN
!
*
* Subroutine
*
CLOSE.BATCH: *
IF CNT.TST$LBL THEN PRINT CLB:"Close Batch ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
ADJUST.TOTAL = ZERO
ENTRY.DATE = DATE()
ENTRY.TIME = OCONV(TIME(),"MT")
ITEM.COUNT = BAT.CN
BUS.DATE = CONTROL.DT
EFF.DATE = DATE()
IF NOT(EFF.DATE) THEN
EFF.DATE = DATE()
END ELSE
*YYMMDD
EFF.DATE = EFF.DATE[3,TWO]:"/":EFF.DATE[5,TWO]:"/":EFF.DATE[ONE,TWO]
EFF.DATE = ICONV(EFF.DATE,"D2/")
END
POST.TIME = EMPTY
*
$INCLUDE IBP.CASH CASH.INCL.NEXT.BATCH
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
IF BATCH.STATUS EQ "C" THEN
XTR.POST.REG<-ONE> = BATCH.NUM
END ELSE
XTR.POST.ERR<-ONE> = BATCH.NUM
END
*
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
RETURN
!
*
* Company info
*
OPEN.COMPANY: *
IF CNT.TST$LBL THEN PRINT CLB:"Open Company ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
OPEN CO.PRE:"ACT" TO ACT.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"ACT":; INPUT RSP:; STAT = 999; RETURN
OPEN CO.PRE:"CAJ" TO CAJ.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"CAJ":; INPUT RSP:; STAT = 999; RETURN
OPEN CO.PRE:"PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"PAR":; INPUT RSP:; STAT = 999; RETURN
OPEN CO.PRE:"CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open ":CO.PRE:"CNT":; INPUT RSP:; STAT = 999; RETURN
OPEN "CNT" TO BASE.CNT.FILE ELSE PRINT CLB:"Can't open ":"CNT":; INPUT RSP:; STAT = 999; RETURN
* OPEN "ADD" TO BASE.ADD.FILE ELSE PRINT CLB:"Can't open ":"ADD":; INPUT RSP:; STAT = 999; RETURN
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.TYPE
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
XTR.ID.FUNC = "POST"
XTR.ID.PREF = "XPV"
XTR.ID.SUFF = "REG"
XTR.POST.REG = EMPTY; XTR.POST.ERR = EMPTY; XTR.POST.OTH = EMPTY
*
IF NOT(CO.FIRST) THEN
*
$INCLUDE IBP.CASH CASH.INCL.LOAD.LISTS
*
END
*
CO.FIRST = FALSE
*
PRINT @(ZERO,6):SPACE(40 - LEN(TITLE1) / TWO + .5):RVB:TITLE1:
PRINT @(ZERO,8):"Company: ":FIELD(CO.PRE,".",ONE):" ":CO.NAME:
PRINT @(ZERO,10):"Item being processed: ":RVE:
*
RETURN
!
*
* Company change
*
CHANGE.COMPANY: *
IF CNT.TST$LBL THEN PRINT CLB:"Change Company ":; IF CNT.TST$CR THEN INPUT TMP:; PRINT CLB:
*
*Close Company batches
*
IF CO.NO.LAST NE EMPTY AND BAT.CN THEN 
BATCH.STATUS = "C"
ITEM.COUNT = BAT.CN
GOSUB CLOSE.BATCH
CAJ = EMPTY; BAT.CN = ZERO
BATCH.TOTAL = ZERO; ENTERED.TOTAL = EMPTY
END
*
IF CO.NO.LAST NE EMPTY AND BAT.CN.BAD THEN 
CAJ = CAJ.BAD; BAT.CN = BAT.CN.BAD
ITEM.COUNT = BAT.CN
BATCH.TOTAL = BATCH.TOTAL.BAD; ENTERED.TOTAL = ENTERED.TOTAL.BAD
BATCH.STATUS = "E"
GOSUB CLOSE.BATCH
CAJ.BAD = EMPTY; BAT.CN.BAD = ZERO
BATCH.TOTAL.BAD = ZERO; ENTERED.TOTAL.BAD = ZERO
CAJ = EMPTY; BAT.CN = ZERO
BATCH.TOTAL = ZERO; ENTERED.TOTAL = EMPTY
END
*
! Update posting list
*
IF CO.NO.LAST NE EMPTY THEN
*
$INCLUDE IBP.CASH CASH.INCL.UPD.LISTS
*
END
*
! Update control info
*
IF CO.NO NE "@@@" AND CO.NO NE CO.NO.LAST THEN
CO.NO.LAST = CO.NO
LOCATE CO.NO IN CNT.XPVCTL$CO.NO.PRE<ONE> SETTING LOC ELSE
LOC = ONE; TRANS.BAD = TRUE
END
CO.PRE = CNT.XPVCTL$CO.NO.PRE<ONE,LOC>
IF LEN(CO.PRE) THEN CO.PRE = CO.PRE:"."
GOSUB OPEN.COMPANY
END; * of company change
*
RETURN
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
!
END
~SYS.PORT.CYCLE~
*PROGRAM: SYS.PORT.CYCLE
*
* : *PROGRAM: CONTROL.AI.UTILITY
* : *  Account Cyclical Execution Utility...
*
! * : ***
! * : ***
* : * INITialization
* : * FUNCtions
$INCLUDE IBP STANDARD.FUNCTIONS
! * : ***
* : * TABLes
! * : ***
DIM PORTS(200)
! * : ***
* : * DEFinitions
! * : ***
! * : ***
* : * INternal DEFinitions
! * : ***
*
*INCLUDE IBP STATUS.VAR.EQUATES
! * : ***
! * : ***
* : * INternal VARiables
TEXT = EMPTY
TF = TRUE
*
* : * FUNCtion INPut
*INPUT FUNC
*
* : * OPEN files
OPEN "MD" TO MD.FILE ELSE TEXT<-ONE> = "Can't open MD"; GOSUB ERROR; STOP
OPEN "PL" TO PL.FILE ELSE TEXT<-ONE> = "Can't open PL"; GOSUB ERROR; STOP
OPEN "LOCKS" TO LOCKS.FILE ELSE TEXT<-ONE> = "Can't open LOCKS"; GOSUB ERROR; STOP
OPEN "CNT" TO CNT.FILE ELSE TEXT<-ONE> = "Can't open CNT"; GOSUB ERROR; STOP
OPEN "PAR" TO PAR.FILE ELSE TEXT<-ONE> = "Can't open PAR"; GOSUB ERROR; STOP
*
* : * INternal CoNTRoL
LOOP UNTIL LEN(PORT) GT 2 DO PORT = ZERO:PORT REPEAT
READ CO.NAME FROM CNT.FILE,"CO.DATA" THEN CO.NAME = CO.NAME<ONE,ONE> ELSE CO.NAME = EMPTY
SYS.RSP = "*END*CONTINUE*KILL*STOP*ABORT*TCL*PROMPT*PROMPT.RECURSIVE*DEBUG*"
*
!
*
* : * MAIN routine
*
READ PORTS.QUEUE FROM CNT.FILE,"PORTS.QUEUE" THEN
*
!
READ EXEC.STACK FROM CNT.FILE,"PORTS.QUEUE*STACK*":PORT THEN
*
DELETE CNT.FILE,"PORTS.QUEUE*STACK*":PORT
EXEC.SOURCE = "CONTINUED"
*
END ELSE
*
EXEC.STACK = PORTS.QUEUE<PORT+ONE>
EXEC.SOURCE = "QUEUE"
*
END
*
IF LEN(EXEC.STACK) THEN
*
PRINT RVB:"::::::":RVE:SPACE(58):RVB:"::::::":RVE
PRINT RVB:"::::::":RVE:SPACE(58):RVB:"::::::":RVE
TMP.STACK = EXEC.STACK
PRINT RVB:":::::: ":("(":EXEC.SOURCE:") ":TMP.STACK<ONE,ONE>) "L#56":" ::::::":RVE
LOOP
DEL TMP.STACK<ONE,ONE>
WHILE LEN(TMP.STACK) DO
PRINT RVB:":::+++ ":(" ":SPACE(LEN(EXEC.SOURCE)):"  ":TMP.STACK<ONE,ONE>) "L#56":" +++:::":RVE
REPEAT
PRINT RVB:"::::::":RVE:SPACE(58):RVB:"::::::":RVE
PRINT RVB:STR(":",70):RVE
*
END
*
!
*
LOOP
*
WHILE LEN(EXEC.STACK) DO
*
EXEC.VERB.STACK = EXEC.STACK<ONE,ONE>
DEL EXEC.STACK<ONE,ONE>
WRITE EXEC.STACK ON CNT.FILE,"PORTS.QUEUE*STACK*":PORT
PRINT RVB:"!!!":RVE
PRINT RVB:"!!!":RVE
PRINT RVB:"!!! ":EXEC.VERB.STACK:" !!!":RVE
PRINT RVB:"!!!":RVE
*
EXEC.VERB = EXEC.VERB.STACK<ONE,ONE,ONE>
DEL EXEC.VERB.STACK<ONE,ONE,ONE>
*
IF INDEX(SYS.RSP,"*":EXEC.VERB:"*",1) THEN
*
PRINT ".."
PRINT ".."
PRINT ".."
PRINT ".. ":EXEC.VERB
*
PROC.VERB = EMPTY
WRITE.FLAG = TRUE
*
BEGIN CASE
*
CASE EXEC.VERB EQ "STOP"
 PROC.VERB = "STOP"
EXEC.VERB = EMPTY
*
CASE EXEC.VERB EQ "END" OR EXEC.VERB = "CONTINUE"
 PROC.VERB = "CONTINUE"
EXEC.VERB = EMPTY
WRITE.FLAG = FALSE
*
CASE EXEC.VERB EQ "ABORT" OR EXEC.VERB EQ "TCL" OR EXEC.VERB = "KILL"
 PROC.VERB = EXEC.VERB
EXEC.VERB = EMPTY
WRITE.FLAG = FALSE
*
CASE EXEC.VERB EQ "PROMPT" OR EXEC.VERB EQ "PROMPT.RECURSIVE"
IF EXEC.VERB EQ "PROMPT.RECURSIVE" THEN EXEC.STACK = EXEC.VERB:VM:EXEC.STACK
EXEC.VERB = EMPTY
PRINT ".."
RSP.CONT = TRUE
LOOP
PRINT BELL:
PRINT "...+++ ":; INPUT RSP:
IF INDEX(SYS.RSP,"*":RSP:"*",ONE) THEN RSP.CONT = FALSE
IF LEN(RSP) THEN
EXEC.STACK = RSP:VM:EXEC.STACK
END
UNTIL RSP EQ EMPTY OR NOT(RSP.CONT) DO
PRINT "   == ":EXEC.STACK
REPEAT
PRINT ".."
PRINT ".."
PRINT ".."
PRINT RVB:"...... ":EXEC.STACK:" ......":RVE
PRINT ".."
*
CASE EXEC.VERB EQ "DEBUG"
EXEC.VERB = EMPTY
DEBUG
*
*
END CASE
*
*
IF PROC.VERB NE EMPTY THEN
*
IF WRITE.FLAG THEN
WRITE EXEC.STACK ON CNT.FILE,"PORTS.QUEUE*STACK*":PORT
END ELSE
READ EXEC.STACK FROM CNT.FILE,"PORTS.QUEUE*STACK*":PORT THEN
DELETE CNT.FILE,"PORTS.QUEUE*STACK*":PORT
END
END; * of write.flag
*
PROCWRITE PROC.VERB
PRINT ".."
PRINT ".."
PRINT ".."
STOP
*
END; * of proc.verb
*
*
END; * of System Level Verb
*
!
*
IF EXEC.VERB NE EMPTY THEN
*
EXEC.INP = EMPTY; EXEC.OUT = EMPTY
EXEC.INP.MAX = DCOUNT(EXEC.VERB.STACK,SVM)
EXEC.OUT.FLAG = FALSE
*
IF EXEC.INP.MAX THEN
LOOP WHILE LEN(EXEC.VERB.STACK) DO
TMP = EXEC.VERB.STACK<ONE,ONE,ONE>
IF TMP EQ "//OUT." THEN
EXEC.OUT.FLAG = TRUE
EXEC.INP.MAX = EXEC.INP.MAX - ONE
END ELSE
EXEC.INP<-ONE> = TMP
END
DEL EXEC.VERB.STACK<ONE,ONE,ONE>
REPEAT
END; * of inps
*
!
*
IF NOT(EXEC.OUT.FLAG) THEN
*
IF EXEC.INP.MAX THEN
EXECUTE EXEC.VERB, //IN. < EXEC.INP
END ELSE
EXECUTE EXEC.VERB
END
*
END ELSE
*
IF EXEC.INP.MAX THEN
EXECUTE EXEC.VERB, //IN. < EXEC.INP, //OUT. > EXEC.OUT
END ELSE
EXECUTE EXEC.VERB, //OUT. > EXEC.OUT
END
*
LOOP WHILE LEN(EXEC.OUT) DO
PRINT "______ ":EXEC.OUT<ONE>
DEL EXEC.OUT<ONE>
REPEAT
*
END; * of no outs / outs
*
RQM; RQM; RQM; RQM
*
END; * of not empty
*
REPEAT; * for stacked executions
*
*
*
END; * of read
*
STOP
*
ERROR: *
PRINT TEXT
RETURN
*
END
~TEST1~
*PROGRAM: TEST1
*
*
*
PRINT TIME()
INPUT TMP,170: FOR 1 ELSE TMP = ""
PRINT TIME()
*
PRINT TIME()
INPUT TMP,170: FOR 10 ELSE TMP = ""
PRINT TIME()
*
PRINT TIME()
INPUT TMP,170: FOR 100 ELSE TMP = ""
PRINT TIME()
*
STOP
END
~TMP.WKO~
X*PROGRAM: AI.SEND.WKO
RESELECT: *
IF SCH.DATE NE LAST.SCH.DATE THEN
EXLN = 'DELETE-LIST ':"AI*":LAST.SCH.DATE
LAST.AI.SEND.WKO = ""
PRINT @(0,22):
EXECUTE EXLN
END
LIST.NAME = "AI*":SCH.DATE
PRINT @(0,22):
EXLN = "GET-LIST ":LIST.NAME
* ULT ONLY
EXECUTE EXLN, //SELECT. > WKO.ID.LIST
* EXECUTE EXLN; * REV ONLY
* IF TEST.FL THEN PRINT CLB:@LAST.ERROR<2>:" ":@LAST.ERROR:; INPUT TMP:; * REV ONLY
* IF @LAST.ERROR = "202" THEN; * REV ONLY
* ULT ONLY
IF WKO.ID.LIST = "" THEN
CLS.COL = 10; CLS.ROW = 13; GOSUB CLS.ROUTINE
PRINT "Selecting ":OCONV(SCH.DATE,"D2"):" work orders for processing...":
PRINT @(0,22):
*
* REV SELECT
* EXECUTE 'SSELECT WKO WITH SCH.TYPE = "AI" AND WITH NO PRINT.DATE AND WITH STAT = "P" AND WITH SCH.DATE AND WITH SCH.DATE <= "':OCONV(SCH.DATE,"D2"):'"'; * REV ONLY
* IF @LAST.ERROR = 401 THEN PRINT CLB:"There were no Work Orders to be processed":; STOP; * REV ONLY
* IF TEST.FL THEN PRINT CLB:@LAST.ERROR<2>:" ":@LAST.ERROR:; INPUT TMP:; * REV ONLY
*
* ULT/MDD SELECTS
EXECUTE 'SSELECT WKO WITH SCH.TYPE = "AI" AND WITH STAT # "C""X" AND WITH NO PD AND WITH SD AND WITH SD <= "':OCONV(SD,"D2"):'" ', //SELECT. > WKO.ID.LIST; * ULT ONLY
*%%MDD%%=PRINT
*%%MDD%%=PRINT SEL.ERROR
*
*
* IF @LAST.ERROR = "202" THEN; * REV ONLY
* ULT ONLY
IF WKO.ID.LIST = "" THEN
IF AUTO.RUN THEN STOP
PRINT CLB:"There are no Work Orders for ":OCONV(SCH.DATE,"D2"):". Enter <cr> ":; INPUT TMP:; STOP
END
*
*
EXECUTE "SAVE-LIST AI*":SCH.DATE
END
PRINT @(0,22):
*
* ULT ONLY
EXECUTE "GET-LIST AI*":SCH.DATE, //SELECT. > WKO.ID.LIST
* EXECUTE "GET-LIST AI*":SCH.DATE; * REV ONLY
* IF TEST.FL THEN PRINT CLB:@LAST.ERROR<2>:" ":@LAST.ERROR:; INPUT TMP:; * REV ONLY
PRINT @(0,22):
*
IF NOT(AUTO.RUN) AND RUN.TYPE = 2 THEN
LOOP
PRINT @(5,10):CLL:"Enter a starting Work Order no. or <cr> for the 1st Work Order: ":; INPUT TMP:
IF TMP = "KILL" THEN STOP
IF TMP = "" THEN HIT = 1 ELSE HIT = 0
IF TMP NE "" THEN START.ID = TMP; TMP = ""
UNTIL TMP = "" DO PRINT BELL: REPEAT
END
!
~TRANS.LIST.POST~
X*PROGRAM: CASH.LIST.POST 
* VERSION: 921009 1.2   REVISED-FOR-PPV.BILLING
* PRIOR: 920531  1.1  REVISED-FOR-PAY-PER-VIEW
* PRIOR: 910611 1.0  NEW
EQU VS TO " (R:1.2)"
* COPYRIGHT        AXION COMPUTER SYSTEMS LTD.
*   1991              ALL RIGHTS RESERVED
*  
* AUTHOR:          DAVID HORSMAN
* DESCRIPTION:     THIS PROGRAM PROCESSES THE XTR BATCHES
*                  FROM THE XTR.POST CONTROL ITEM.
*  
* DATE WRITTEN:    29 JUN 91
* MODIFICATIONS:   DATE       NAME        DESCRIPTION
!  * TITLE = "Process Transactions" * : *
$INCLUDE IBP GENERAL.COMMON.AREA
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
*INCLUDE IBP AAX.DIM
*INCLUDE IBP AAX.EQUATES
*NCLUDE IBP ACG.DIM
* $INCLUDE IBP ACG.EQUATES
*NCLUDE IBP SAVE.ACG.DIM
*INCLUDE IBP SAVE.ACG.EQUATES
*NCLUDE IBP ACT.DIM
*INCLUDE IBP ACT.EQUATES
*NCLUDE IBP ADD.DIM
*INCLUDE IBP ADD.EQUATES
*NCLUDE IBP ATR.DIM
*INCLUDE IBP ATR.EQUATES
*NCLUDE IBP EFT.DIM
*INCLUDE IBP EFT.EQUATES
*
$INCLUDE IBP CNT.CSH.DIM
$INCLUDE IBP CNT.CSH.EQUATES
*
*
MAT CNT.CSH = EMPTY
*
! OPEN files * : *
*
SYS.PROG = "CASH.LIST.POST"; VERSION = "2.0"
STAT = FALSE; PHAN.RUN = TRUE
*
CALL TRANS.SUBR.OPEN.LIST.POST(CAJ.FILE)
IF STAT THEN STOP
*
* LCK.FILE = ZERO; * REV ONLY
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.TYPE = -3; LCK.STAT = FALSE
STAT = FALSE; INPUTS = EMPTY
*
*
! Special parameters for fixing posting run aborts * : *
*
XTR.POST = EMPTY; XTR.POST.ERR = EMPTY; XTR.POST.OTH = EMPTY
XTR.ID.PREF = EMPTY; XTR.ID.FUNC = EMPTY; XTR.ID.SUFF = EMPTY
ENTRY.MODE = ZERO
*
CALL TRANS.SUBR.LOAD.CNTRL(CNT.CSH.ID,MAT CNT.CSH)
IF STAT THEN STOP
IF STAT THEN STOP
*
! Put up screen header * : *
*
$INCLUDE IBP SYS.INCL.LOAD.CO
*
$INCLUDE IBP SYS.INCL.SCR.CO
*
EXEC.REPORT = SCR.CO
TITLEA = "Batched Transactions Processing"
TMP = (SPACE(40-LEN(TITLEA)/2):TITLEA) "L#80"
EXEC.REPORT<-ONE> = TMP
*
! Load auto * : *
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
! Load Responses or auto.run info * : *
*
IF NOT(AUTO.RUN) THEN
*
CSH.TYPE = ZERO; CSH.TYPE.CURR = ZERO
INPUT CSH.TYPE.SEL:
FROM.LIST = INDEX(CSH.TYPE.SEL,"L",ONE)
PHAN.RUN = INDEX(CSH.TYPE.SEL,"P",ONE)
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ONE):CLS:RVB:TMP:RVE:
* 0 Regular Posting Run
* L From a get-list
* P Phantom Mode
*
BATCH.CLASS = EMPTY; BATCH.CLASS.CURR = EMPTY; BATCH.CLASS.TMP = EMPTY
INPUT BATCH.CLASS.SEL:
* 0 Regular Adjustments (ADJ)
* 1 Regular Payments    (PMT)
* 2 Regular Deposits    (DEP)
* 3 Special Billing     (BIL)
* 6 All Batch Types
*
BATCH.SOURCE = EMPTY; BATCH.SOURCE.CURR = EMPTY; BATCH.SOURCE.TMP = EMPTY
INPUT BATCH.SOURCE.SEL:
* 0 Cash.or.Adj Entry    (REG)
* 3 Counter Cash         (CTR)
* 4 Lockbox Transactions (XTR)
* 5 Pay-Per-View Charges (BIL)
* 6 All batch sources
*
INPUT DT.OPEN.SEL:
EXEC.VERB.SEL = EMPTY
IF DT.OPEN.SEL[ONE,3] EQ "SEL" THEN EXEC.VERB.SEL = DT.OPEN.SEL[4,9999]
INPUT PORT.SEL:
INPUT USER.VALID.SEL:
INPUT LPT.DETAIL.SEL:
INPUT POST.FL:
* 
! Perform Screen Selection Criteria * : *
*
CALL TRANS.SUBR.LIST.SELECT(TITLE,MAT CNT.CSH,CNT.CSH.ID,CHSU,CSHU.ID,CSHUD,CSHUD.ID,CONTROL.DT,CSH.TYPE.SEL,EXEC.VERB.SEL,BATCH.CLASS.SEL,BATCH.SOURCE.SEL,DT.OPEN.SEL,PORT.SEL,USER.VALID.SEL,LPT.DETAIL.SEL,POST.FL,INPUTS,AUTO.RUN,PHAN.RUN)
IF STAT THEN STOP
*
! Update Inputs for auto.run * : *
*
INPUTS          = CSH.TYPE.SEL
INPUTS<ONE,TWO> = BATCH.CLASS.SEL
INPUTS<ONE,3>   = BATCH.SOURCE.SEL
INPUTS<ONE,4>   = DT.OPEN.SEL
INPUTS<ONE,5>   = PORT.SEL
INPUTS<ONE,6>   = USER.VALID.SEL
INPUTS<ONE,7>   = LPT.DETAIL.SEL
INPUTS<ONE,8>   = POST.FL
INPUTS<ONE,9>   = EXEC.VERB.SEL
*
END ELSE
*
! This is an auto run * : *
*
CSH.TYPE.SEL     = CURRENT.RUN<ONE,TWO>
BATCH.CLASS.SEL  = CURRENT.RUN<ONE,3>
BATCH.SOURCE.SEL = CURRENT.RUN<ONE,4>
DT.OPEN.SEL      = CURRENT.RUN<ONE,5>
PORT.SEL         = CURRENT.RUN<ONE,6>
USER.VALID.SEL   = CURRENT.RUN<ONE,7>
LPT.DETAIL.SEL   = CURRENT.RUN<ONE,8>
POST.FL          = CURRENT.RUN<ONE,9>
EXEC.VERB.SEL    = CURRENT.RUN<ONE,10>
*
IF NOT(PHAN.RUN) THEN PRINT @(ZERO,ONE):RVB:TMP:RVE:
*
END
*
*
! Update auto * : *
*
*
EXEC.VERB = "RUN BP CASH.LIST.POST"
EXEC.IN = INPUTS
EXEC.DESC = "Post Batches from Lists  ":CSH.TYPE.SEL:",":BATCH.SOURCE.SEL:",":BATCH.CLASS.SEL
*
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
$INCLUDE IBP SYS.INCL.UPD.AUTO
END
*
! Initialize program * : *
*
BATCH.SOURCE.CURR = EMPTY; BATCH.TYPE.CURR = BATCH.CLASS.SEL[ONE,ONE]
DT.OPEN.CURR = EMPTY; PORT.CURR = EMPTY; USER.VALID.CURR = EMPTY
LIST.TO.POST = EMPTY; FROM.LIST = FALSE; END.OF.LIST = FALSE
*
FROM.LIST = INDEX(CSH.TYPE.SEL,"L",ONE)
*
PHAN.RUN = INDEX(CSH.TYPE.SEL,"P",ONE)
*
IF LEN(EXEC.VERB.SEL) THEN FROM.LIST = TRUE
*
CALL TRANS.SUBR.CLASS.PARSE(BATCH.CLASS.SEL)
IF STAT THEN STOP
IF BATCH.CLASS.SEL EQ "6" THEN BATCH.CLASS.SEL   = "0123"
*
CALL TRANS.SUBR.SOURCE.PARSE(BATCH.SOURCE.SEL)
IF STAT THEN STOP
IF BATCH.SOURCE.SEL EQ "6" THEN BATCH.SOURCE.SEL = "0345"
*
! Call program initialization and lock control info * : *
*
BATCH.CLASS.CURR = BATCH.CLASS.SEL[ONE,ONE]
BATCH.SOURCE.CURR = BATCH.SOURCE.SEL[ONE,ONE]
*
$INCLUDE IBP.CASH CASH.INCL.LCK.CNTRL
*
CALL TRANS.SUBR.ENTRY.INIT(ATR.FLAG,ACG.FLAG,ACT.FLAG,ALL.FLAG,CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*
$INCLUDE IBP.CASH CASH.INCL.RELS.CNTRL
*
! Lock out transmissions and other updates to transactions * : *
*
$INCLUDE IBP.CASH CASH.INCL.LCK.XTR
*
IF STAT THEN STOP
*
!!
*
! Start of program * : *
*
START: *
*
BUS.DATE = EMPTY
EFF.DATE = EMPTY
POST.DATE = EMPTY
POST.TIME = EMPTY
OPERATOR = EMPTY
DEFAULT.TYPE = EMPTY
BATCH.DEL.STATUS = EMPTY
BATCH.TYPE = EMPTY
BATCH.LPT.DT = EMPTY
BATCH.LPT.TM = EMPTY
BATCH.INP.SOURCE = EMPTY
BATCH.LST = EMPTY
*
!
*
LPT.DETAIL.FL = INDEX(LPT.DETAIL.SEL,"D",ONE)
LPT.SUMMARY.FL = INDEX(LPT.DETAIL.SEL,"S",ONE)
LPT.PMT.TYP.FL = INDEX(LPT.DETAIL.SEL,"Y",ONE)
LPT.FL = NOT(INDEX(LPT.DETAIL.SEL,"T",ONE))
IF NOT(LPT.FL) THEN LPT.FL = INDEX(LPT.DETAIL.SEL,"P",ONE)
*
LN.TOP = 6; LN.BOT = 20; LN.HDR.TOP = TWO
LPT.STAT = FALSE; LPT.CN = ZERO
LPT.PG = ONE; LPT.LN = 99; LPT.LN.MAX = 55
IF NOT(LPT.FL) THEN LPT.LN.MAX = 19
LPT.HEADER = "Status Description" "L#24":" S ":"Batch" "L#9":" ":"Oper." "L#5"
LPT.HEADER = LPT.HEADER:" ":"Bus.Date" "L#10":"Per." "L#5":" "
LPT.HEADER = LPT.HEADER:"Post.Date" "L#10"
LPT.HEADER = LPT.HEADER:"Print.Dt" "L#10"
*
IF NOT(LPT.FL) THEN LPT.HEADER = LPT.HEADER:CR:LF:SPACE(10)
LPT.HEADER = LPT.HEADER:"Total.Amt" "R#9":" ":"Entry.Amt" "R#9":" ":"Adj.Amt" "R#9"
*
IF LPT.PMT.TYP.FL THEN
LPT.HEADER = LPT.HEADER:CR:LF
IF LPT.FL THEN LPT.HEADER = LPT.HEADER:SPACE(68) ELSE LPT.HEADER = LPT.HEADER:SPACE(10)
LPT.HEADER = LPT.HEADER:"Total.Chq" "R#9":" ":"Total.Crd" "R#9":" ":"Total.Dbt" "R#9":" ":"Total.Csh" "R#9"
END
*
LPT.TEXT = EMPTY
*
LPT.BATCH.TOTAL = EMPTY; LPT.ENTERED.TOTAL = EMPTY; LPT.ADJUST.TOTAL = EMPTY
LPT.TOTAL.CHQ = EMPTY; LPT.TOTAL.CRD = EMPTY; LPT.TOTAL.CSH = EMPTY; LPT.TOTAL.CDC = EMPTY
*
CNTR.PREV = EMPTY
CNTR.CURR = EMPTY
CNTR.FIRST = TRUE
CNTR.TOTAL = EMPTY
* 1 *    * 2 *    * 3 *    * 4 *    * 5 *    * 6 *    * 7 *            
* CO     TRAN     TRAN   LIST.TYPE  ENTRY    ENTRY    ENTRY
* TOTS  SOURCE   CLASS  REG/ERR/OTH  DATE     PORT   OPERATOR
*
* ENTERED  ADJUSTMENTS  CONTROL
*
* CASH     CHEQUES      CREDIT CARDS    DEBIT CARDS
*
!
*
BATCH.CLASS.TMP = BATCH.CLASS.SEL
BATCH.SOURCE.TMP = BATCH.SOURCE.SEL
CSH.TYPE.CURR = CSH.TYPE.SEL[ONE,ONE]
*
! Main loop * : *
*
MAIN.LOOP: *
*
! Loop for all types processing * : *
*
LOOP WHILE (NOT(FROM.LIST) AND LEN(BATCH.SOURCE.TMP)) OR (FROM.LIST AND NOT(END.OF.LIST)) DO
*
! Process next source * : *
*
BATCH.SOURCE.CURR = BATCH.SOURCE.TMP[ONE,ONE]
BATCH.SOURCE.TMP = BATCH.SOURCE.TMP[TWO,9999]
BATCH.CLASS.TMP = BATCH.CLASS.SEL
*
LOOP WHILE (NOT(FROM.LIST) AND LEN(BATCH.CLASS.TMP)) OR (FROM.LIST AND NOT(END.OF.LIST)) DO
*
BATCH.CLASS.CURR = BATCH.CLASS.TMP[ONE,ONE]
BATCH.CLASS.TMP = BATCH.CLASS.TMP[TWO,9999]
*
! Examine type of run * : *
*
CALL TRANS.SUBR.BATCH.ANAL(CAJ.FILE,COM.FILE,CNT.CSH.ID,MAT CNT.CSH,FROM.LIST,BATCH.CLASS.CURR.DESC,BATCH.SOURCE.CURR.DESC,XTR.ID.PREF,XTR.ID.FUNC,BATCH.TYPE,CLASS.CN.MAX,AUTO.RUN,PHAN.RUN,MAX.DESC,DESC.LEN,INPUT.DESC,BATCH.CLASS.CURR,TITLE,TRANS.CLASS,TRANS.SUB.CLASS,TRANS.ITEM,BATCH.SOURCE.CURR)
*
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.INIT
*
IF STAT THEN
*
TMP = "Error in ":ACCT:" on type ":BATCH.CLASS.CURR:BATCH.SOURCE.CURR:" ":XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF:". Error #: ":STAT
EXEC.REPORT<-ONE> = TMP
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 10 UNTIL SYSTEM(11)
* FOR TMP = ONE TO 10; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
EXEC.REPORT<-ONE> = "CASH IN ":ACCT:" ERR ":STAT+0:" ON ":XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
*
STAT = FALSE
*
END; * of STAT
*
IF POST.FL THEN TITLE = "Post " ELSE TITLE = "Report on "
IF NOT(LPT.DETAIL.FL) THEN TITLE = "Summary ":TITLE
TITLE = TITLE:BATCH.CLASS.CURR.DESC:" Batches "
IF FROM.LIST THEN TITLE = TITLE:"from a List "
TITLEA = TITLE:"    ":VS
CLS.COL = ZERO; CLS.ROW = 7; GOSUB CLS.ROUTINE
PRINT @(ZERO,7):RVB:(SPACE(40-LEN(TITLEA)/2):TITLEA) "L#80":RVE:
*
! Read List info * : *
*
IF NOT(PHAN.RUN) THEN
CLS.COL = ZERO; CLS.ROW = 9; GOSUB CLS.ROUTINE
END
IF NOT(FROM.LIST) THEN
PRINT "Load List . . .   ":
$INCLUDE IBP.CASH CASH.INCL.LOAD.LISTS
END
*
! Loop for class of list (regular or errors) * : *
*
! 2 Cycles for balanced and error batches * : *
*
FOR XTR.TYPE.CN = ONE TO CLASS.CN.MAX
*
! Read XTR Post record * : *
*
IF NOT(FROM.LIST) THEN
*
IF XTR.TYPE.CN EQ ONE THEN
XTR.ID.SUFF = "REG"
LIST.TO.POST.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.TO.POST = XTR.POST.REG
RUN.CLASS = "REGULAR"
END ELSE IF XTR.TYPE.CN EQ TWO THEN
XTR.ID.SUFF = "ERR"
LIST.TO.POST.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.TO.POST = XTR.POST.ERR
RUN.CLASS = "ERRORS"
END ELSE
XTR.ID.SUFF = "OTH"
LIST.TO.POST.ID = XTR.ID.PREF:".":XTR.ID.FUNC:".":XTR.ID.SUFF
LIST.TO.POST = XTR.POST.OTH
RUN.CLASS = "OTHER"
END
*
! Process list * : *
*
IF NOT(FROM.LIST) AND LIST.TO.POST EQ EMPTY THEN
*
TMP = "There are no ":BATCH.CLASS.CURR.DESC:", type ":RUN.CLASS:" to post."
EXEC.REPORT<-ONE> = TMP
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 3 UNTIL SYSTEM(11)
* FOR TMP = ONE TO 3; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
EXEC.REPORT<-ONE> = "CASH IN ":ACCT:" NO ":RUN.CLASS:" POSTED"
*
STAT = 200
*
END
*
END ELSE
*
! From a list * : *
*
IF EXEC.VERB.SEL NE EMPTY THEN
PRINT EXEC.VERB
* ULT ONLY
EXECUTE EXEC.VERB.SEL, //SELECT. > CAJ.ID.LIST
* EXECUTE EXEC.VERB.SEL; * REV ONLY
END
*
END; * of not(FROM.LIST)
*
! Display batches * : *
*
IF LPT.DETAIL.FL THEN
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.BG
END ELSE IF NOT(PHAN.RUN) THEN
CLS.COL = ZERO; CLS.ROW = 13; GOSUB CLS.ROUTINE
END
*
! Loop thru batches * : *
*
XTR.CN = ZERO
IF NOT(FROM.LIST) THEN
XTR.CN.MAX = DCOUNT(LIST.TO.POST,AM)
END ELSE
XTR.CN.MAX = 99999
END
*
LOOP
*
! Read next batch * : *
*
XTR.CN = XTR.CN + ONE; CONT = TRUE
IF NOT(FROM.LIST) THEN
CAJ.ID = LIST.TO.POST<XTR.CN>
BATCH.NUM = ("00000":CAJ.ID) "R#5"
IF (CAJ.ID EQ EMPTY AND (NOT(LEN(LIST.TO.POST)) OR XTR.CN GT XTR.CN.MAX)) THEN CONT = FALSE
END ELSE IF END.OF.LIST THEN
CONT = FALSE; CAJ.ID = EMPTY; BATCH.NUM = EMPTY
END ELSE
* ULT ONLY
READNEXT CAJ.ID FROM CAJ.ID.LIST ELSE
* READNEXT CAJ.ID ELSE; * REV ONLY
CAJ.ID = EMPTY; CONT = FALSE; END.OF.LIST = TRUE
END
BATCH.NUM = ("00000":CAJ.ID) "R#5"
END
*
WHILE CONT AND NOT(STAT) DO
*
IF NOT(PHAN.RUN) THEN PRINT @(ZERO):BATCH.NUM:"  ":
*
$INCLUDE IBP.CASH CASH.INCL.LCK.BATCH
*
READ CAJ FROM CAJ.FILE,BATCH.NUM THEN
*
! Extract Header * : *
*
BATCH.HEADER = CAJ<ONE>; DEL CAJ<ONE>
*
$INCLUDE IBP.CASH CASH.INCL.EXT.HDR
*
! Validate Batch * : *
*
VALID = TRUE
*
CALL TRANS.SUBR.VALIDATE.BATCH(VALID,BATCH.HEADER,DT.OPEN.SEL,DT.OPEN.LOC,PORT.SEL,PORT.LOC,USER.VALID.SEL,USER.VALID.LOC,BATCH.CLASS.CURR,BATCH.SOURCE.CURR)
*
IF VALID THEN
*
*
! Display Background * : *
*
IF LPT.DETAIL.FL THEN
$INCLUDE IBP.CASH CASH.INCL.OR.ADJ.HDR.FG
END
*
! Set Control Current
*
CNTR.CURR<ONE> = "*"
CNTR.CURR<TWO> = BATCH.SOURCE
CNTR.CURR<3>   = BATCH.CLASS
CNTR.CURR<4>   = XTR.ID.SUFF
CNTR.CURR<5>   = ENTRY.DATE
CNTR.CURR<6>   = BATCH.TILL
CNTR.CURR<7>   = OPERATOR
IF CNTR.FIRST THEN
CNTR.FIRST = FALSE; CNTR.PREV = CNTR.CURR
END
*
! Call Impulse Pay Per View Billing * : *
*
IF LPT.DETAIL.FL THEN
IF POST.FL THEN
IF BATCH.STATUS EQ "C" THEN
*
SINGLE = 0; ACT.ID = ""; PVM.ID = ""
CALL PPV.BILLING(LCK.FILE,ACT.FILE,ATR.FILE,ADD.FILE,EFT.FILE,ACG.FILE,STAT,LCK.TYPE,CAJ,BATCH.HEADER,CONTROL.DT,A.PERIOD,BATCH.NUM,BATCH.TYPE,SINGLE,ACT.ID,PVM.ID)
*
BATCH.STATUS = FIELD(BATCH.HEADER,"*",2)
BATCH.TOTAL = FIELD(BATCH.HEADER,"*",9)
ENTERED.TOTAL = FIELD(BATCH.HEADER,"*",10)
*
IF NOT(STAT) THEN BATCH.STATUS = "D"
*
END
END; * Of post.fl
END; * Of not S
*
! Call Printing routine * : *
*
IF NOT(LPT.DETAIL.FL) THEN
*
*
$INCLUDE IBP.CASH CASH.INCL.BATCH.DESC
*
LPT.CN = LPT.CN + ONE
*
! Detect Control Breaks * : *
*
CNTR.MIN = ZERO
LOOP
CNTR.MIN = CNTR.MIN + ONE
WHILE CNTR.CURR<CNTR.MIN> EQ CNTR.PREV<CNTR.MIN> AND CNTR.MIN LT 7 DO REPEAT
*
! Print Totals
*
IF CNTR.MIN LT 7 THEN
*
IF LPT.FL THEN CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
PRINT
PRINT "Totals" "R#9":" ":
*
FOR CNTR.CN = 7 TO CNTR.MIN STEP -ONE
*
* PRINT CLB:"TOT ":CNTR.CN
IF CNTR.CN GT ONE THEN
CNTR.TOTAL<CNTR.CN - ONE> = CNTR.TOTAL<CNTR.CN - ONE> + CNTR.TOTAL<CNTR.CN>
END
*
PRINT (CNTR.CN:" - ":CNTR.TOTAL<CNTR.CN>) "R#9":" ":
*
* Clear  Control Totals * : *
*
CNTR.TOTAL<CNTR.CN> = ZERO
*
NEXT CNTR.CN
*
PRINT
IF LPT.FL THEN CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
END
*
! Build Report Line * : *
*
*43
LPT.TEXT = BATCH.STATUS.DESC "L#24":" ":SOURCE "L#1":" ":BATCH.NUM "L#9":" ":OPERATOR "L#5"
*17
LPT.TEXT = LPT.TEXT:" ":OCONV(BUS.DATE,"D2") "L#9":" ":ACCTG.PERIOD "L#5":" "
*10
LPT.TEXT = LPT.TEXT:OCONV(POST.DATE,"D2") "L#10"
*9
LPT.TEXT = LPT.TEXT:OCONV(BATCH.LPT.DT,"D2") "L#9"
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF:"  Totals:" "L#10"
LPT.LN = LPT.LN + ONE
END
*
*30
LPT.TEXT = LPT.TEXT:OCONV(BATCH.TOTAL,"MR2") "R#9":" ":OCONV(ENTERED.TOTAL,"MR2") "R#9":" ":OCONV(ADJUST.TOTAL,"MR2") "R#9"
*
END; * of summary report
*
! Batch Detail Printing Routine * : *
*
IF (LPT.DETAIL.FL OR LPT.PMT.TYP.FL OR BATCH.LPT.DT EQ EMPTY OR ALL.FLAG) AND NOT(STAT) THEN
*
BATCH.TOTAL.CHQ = ZERO; BATCH.TOTAL.CRD = ZERO; BATCH.TOTAL.CSH = ZERO; BATCH.TOTAL.CDC = ZERO
*
CALL TRANS.SUBR.PRINT(CAJ,CO.NAME,ACCTG.PERIOD,BATCH.HEADER,BATCH.STATUS.DESC,BATCH.NUM,BATCH.TOTAL.CHQ,BATCH.TOTAL.CRD,BATCH.TOTAL.CDC,BATCH.TOTAL.CSH,CSH.TYPE,CSH.TYPE.CURR,TITLE,TRANS.TYPES,BATCH.CLASS.CURR,LPT.DETAIL.FL,LPT.PMT.TYP.FL,LPT.FL,LPT.STAT,MIN.DELINQ.AMT,MIN.MIN.DELINQ.STAT)
*
! Printer output * : *
*
IF LPT.PMT.TYP.FL THEN
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF:"Currency:" "L#10"
LPT.LN = LPT.LN + ONE
END ELSE
LPT.TEXT = LPT.TEXT:CR:LF:SPACE(68)
LPT.LN = LPT.LN + ONE
END
*
*30
LPT.TEXT = LPT.TEXT:OCONV(BATCH.TOTAL.CHQ,"MR2") "R#9":" ":OCONV(BATCH.TOTAL.CRD,"MR2") "R#9":" ":OCONV(BATCH.TOTAL.CDC,"MR2") "R#9":" ":OCONV(BATCH.TOTAL.CSH,"MR2") "R#9"
*
END
*
! Update print date and error batch status * : *
*
IF LPT.DETAIL.FL THEN
IF BATCH.STATUS EQ "D" THEN BATCH.STATUS = "P"
IF BATCH.STATUS EQ "E" THEN BATCH.STATUS = "R"
BATCH.LPT.DT = DATE()
BATCH.LPT.TM = TIME()
END
*
END; * Of E B U and not STAT
*
!  Print Report Line * : *
*
IF NOT(LPT.DETAIL.FL) THEN
*
!  Detect Page Break * : *
*
IF NOT(LPT.FL) THEN
LPT.TEXT = LPT.TEXT:CR:LF
LPT.LN = LPT.LN + ONE
END
LPT.LN = LPT.LN + ONE
*
IF LPT.LN GT LPT.LN.MAX THEN GOSUB LPT.PAGE
*
IF LPT.FL THEN CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
PRINT LPT.TEXT
*
IF LPT.FL THEN CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
*
! Accumulate Totals * : *
*
LPT.BATCH.TOTAL   = LPT.BATCH.TOTAL   + BATCH.TOTAL
LPT.ENTERED.TOTAL = LPT.ENTERED.TOTAL + ENTERED.TOTAL
LPT.ADJUST.TOTAL  = LPT.ADJUST.TOTAL  + ADJUST.TOTAL
*
LPT.TOTAL.CHQ = LPT.TOTAL.CHQ + BATCH.TOTAL.CHQ
LPT.TOTAL.CRD = LPT.TOTAL.CRD + BATCH.TOTAL.CRD
LPT.TOTAL.CSH = LPT.TOTAL.CSH + BATCH.TOTAL.CSH
LPT.TOTAL.CDC = LPT.TOTAL.CDC + BATCH.TOTAL.CDC
*
CNTR.TOTAL<7> = CNTR.TOTAL<7> + LPT.BATCH.TOTAL
END; * of summary report * : *
*
! Call Posting routine * : *
*
IF (BATCH.STATUS EQ "B" OR ALL.FLAG) AND LPT.DETAIL.FL AND NOT(STAT) THEN
*
* DON'T POST PPV. POST WON'T HANDLE ACG BILLING, TAXES, ETC.
IF NOT(BATCH.CLASS.SEL = 3) THEN
*
CALL TRANS.SUBR.POST(CAJ,CSH.TYPE,CSH.TYPE.CURR,RUN.SOURCE,RUN.LC.SOURCE,RUN.TRANS.CLASS,RUN.TRANS.SUB.CLASS,EFF.DATE,CONTROL.DT,CURR.ACCTG.PERIOD,BATCH.NUM,TRANS.TYPES,MIN.DELINQ.STAT,MIN.DELINQ.AMT,BUS.DATE,BATCH.CLASS.SEL,DEFAULT.TYPE,ATR.FLAG,ACG.FLAG,ACT.FLAG,BATCH.DEL.STATUS,ENTRY.MODE,TRANS.COUNT,BATCH.INP.SOURCE)
*
END
*
IF NOT(STAT) THEN
BATCH.STATUS = "P"
DEL LIST.TO.POST<XTR.CN>
XTR.CN = XTR.CN - ONE
XTR.CN.MAX = XTR.CN.MAX - ONE
END ELSE
BATCH.STATUS = "R"
* XTR.CN = XTR.CN + ONE
STAT = FALSE
END
*
POST.DATE = CONTROL.DT
POST.TIME = OCONV(TIME(),"MT")
*
END ELSE
* XTR.CN = XTR.CN + ONE
END; * of status B
*
* END ELSE
* XTR.CN = XTR.CN + ONE
* END; * of not an E or R and not STAT so post
*
! Update header * : *
*
* IF NOT(STAT) THEN
$INCLUDE IBP.CASH CASH.INCL.UPD.HDR
* END
*
END; * Of valid * : *
*
*
END ELSE
CAJ = EMPTY
* XTR.CN = XTR.CN + ONE
END
*
! Release batch * : *
*
$INCLUDE IBP.CASH CASH.INCL.RELS.BATCH
*
! Check status * : *
*
*  will clear STAT set by a bad batch or lock here
*
IF STAT THEN
*
TMP = "Error in ":ACCT:" on batch ":BATCH.NUM:" status ":BATCH.STATUS:". Error #: ":STAT
EXEC.REPORT<-ONE> = TMP
*
IF NOT(PHAN.RUN) THEN PRINT CLB:TMP:
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT " Enter <cr> . . . ":; INPUT TMP:
END ELSE IF NOT(PHAN.RUN) THEN
* ULT ONLY
FOR TMP = ONE TO 10 UNTIL SYSTEM(11)
* FOR TMP = ONE TO 10; * REV ONLY
PRINT BELL:
* ULT ONLY
EXECUTE "SLEEP 5"
NEXT TMP
END
*
EXEC.REPORT<-ONE> = "CASH IN ":ACCT:" ERR ":STAT+0:" ON ":BATCH.NUM
*
STAT = FALSE
*
END; * of STAT
*
! Next batch * : *
*
REPEAT
*
! Next XTR Posting Class Record * : *
*
IF NOT(FROM.LIST) THEN
IF XTR.TYPE.CN EQ ONE THEN
XTR.POST.REG = LIST.TO.POST
END ELSE IF XTR.TYPE.CN EQ TWO THEN
XTR.POST.ERR = LIST.TO.POST
END ELSE
XTR.POST.OTH = LIST.TO.POST
END
END
*
*
NEXT XTR.TYPE.CN
*
! Write lists out * : *
*
IF NOT(FROM.LIST) THEN
$INCLUDE IBP.CASH CASH.INCL.UPD.LISTS
END
*
! Next Class of Transaction * : *
*
REPEAT
*
! Next Source of Transaction * : *
*
REPEAT
*
! End of Report * : *
*
IF NOT(LPT.DETAIL.FL) AND LPT.CN THEN
*
* * : * Detect Page Break
*
IF LPT.LN GT LPT.LN.MAX THEN GOSUB LPT.PAGE
*
* * : *  Print report totals
*
**********
*
END
*
*
! End of program * : *
*
FINISH: *
*
$INCLUDE IBP.CASH CASH.INCL.RELS.XTR
*
*
STOP
*
!
*
$INCLUDE IBP.CASH CASH.INCL.IMPRINT
*
!
*
$INCLUDE IBP CLS.ROUTINE
*
!
*
CHECK.BALANCE: *
*
$INCLUDE IBP.CASH CASH.INCL.CHECK.BAL
*
RETURN
*
!
*
LPT.PAGE: *
*
*
*    Detect Page Break
*
IF LPT.LN GT LPT.LN.MAX THEN
*
IF LPT.FL THEN
CALL PRINTER.SUBR.ON(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
PRINT FF:
$INCLUDE IBP SYS.INCL.LPT.CO
END ELSE
IF NOT(AUTO.RUN OR PHAN.RUN) THEN
PRINT CLB:"Enter <cr> for next page . . . ":; INPUT TMP:
IF TMP EQ "KILL" THEN STAT = 999; RETURN
IF TMP EQ "END" THEN STAT = 999; RETURN
END
PRINT @(ZERO,ZERO):CLS:
$INCLUDE IBP SYS.INCL.SCR.CO
END
*
IF LPT.FL THEN
PRINT (SPACE(65 - LEN(TITLEA) / TWO):TITLEA) "L#130"
END ELSE
PRINT
PRINT (SPACE(40 - LEN(TITLEA) / TWO):TITLEA) "L#79"
END
*
PRINT
PRINT LPT.HEADER
PRINT
LPT.PG = LPT.PG + ONE; LPT.LN = 6
*
IF LPT.FL THEN
CALL PRINTER.SUBR.OFF(LPT.STAT); IF LPT.STAT AND NOT(STAT) THEN STAT = LPT.STAT
END
*
END
*
RETURN
*
*
END
~UPDATE.COUNTS.PPV.DISTR~
*PROGRAM:   UPDATE.COUNTS.PPV.DISTR
* VERSION: 950405 1.4  REVISED USER PROMPTS, CORRECTED UNASSIGNED VAR.
* PRIOR: 950205 1.3  CLARIFIED USER PROMPTS.
* PRIOR: 940814 1.2  EXTENSIVE CHANGES: RPT DICT, PERIODS, CONTROLS.
* COPIED TO IN.BP.AI 2-NOV-93.
* PRIOR: 930728 1.1  ADDED CURRENT REPORT PERIOD.
* PRIOR: 921004 1.0  NEW
* DESCRIPTION: UPDATE PPV DISTR COUNTS FOR REPORTING
VERSION = " (1.4)"
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP RPT.PPV.DIM
$INCLUDE IBP RPT.PPV.EQUATES
*
INPUT AUTO.RUN
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:
OPEN "RPT" TO RPT.FILE ELSE PRINT CLB:"Can't open RPT":; INPUT TMP:
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:
* LCK.F = 0; * REV ONLY
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = "Unknown Co"
READ CURR.PER FROM CNT.FILE,"CURR.ACCTG.PERIOD" ELSE CURR.PER = ""
READ PPV.UPDATE FROM COM.FILE,"CURR.PPV.REPORT.PERIOD" ELSE PPV.UPDATE = ""
READ SYS.TST FROM CNT.FILE,"PPV.TEST" ELSE SYS.TST = 0
$INCLUDE IBP SYSTEM.TEST
*
LCK.TYPE = -3
U.CTR = 0
*
*
PRINT @(0,0):CLS:
TITLE = "PPV Distributor Counts Update":VERSION
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
LAST.UPD.DATE = PPV.UPDATE<1>
CURR.RPT.PER  = PPV.UPDATE<2>
LAST.UPD.PER  = PPV.UPDATE<3>
LAST.UPD.DATE = OCONV(LAST.UPD.DATE<1>,"D2"); 
*
MTH = CURR.RPT.PER[3,2]; YEAR = CURR.RPT.PER[1,2]
MTH = MTH+1; IF MTH > 12 THEN MTH = MTH-12; YEAR = YEAR+1
YEAR = ("00":YEAR) "R#2"; MTH = ("00":MTH) "R#2"; TMP.UPD.PER = YEAR:MTH
*
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
THIS.UPD.PER = CURRENT.RUN<1,2>
END ELSE
IF LAST.UPD.DATE NE "" THEN
PRINT @(0,5):CLS:"The last update was on ":LAST.UPD.DATE:" for the Distributor reporting period ":LAST.UPD.PER:
END
THIS.UPD.PER = CURR.RPT.PER
*
LOOP
PRINT @(0,7):"The current period to be updated is ":CURR.RPT.PER:
PRINT @(0,9):CLS:"If this as the last update for the the above ":
PRINT @(0,10):CLS:"Report Period, enter 'Y' to advance the Report":
PRINT @(0,11):CLS:"Period to ":TMP.UPD.PER:" after updating is completed: ":
INPUT ADVANCE.PER:
IF ADVANCE.PER = "KILL" THEN STOP
IF ADVANCE.PER = "Y" THEN ADVANCE.PER = ""; NEXT.UPD.PER = TMP.UPD.PER ELSE NEXT.UPD.PER = THIS.UPD.PER
UNTIL ADVANCE.PER EQ "" DO PRINT BELL: REPEAT
*
PRINT @(10,13):CLL:"Updating:     ":THIS.UPD.PER:
IF THIS.UPD.PER NE NEXT.UPD.PER THEN
PRINT @(10,14):CLL:"Advancing to: ":NEXT.UPD.PER:
END ELSE
PRINT @(10,14):CLL:"No advance of Period":
END
*
INPUTS = THIS.UPD.PER
CALL AUTO.LOADER("UPDATE.COUNTS.PPV.DISTR",INPUTS,"Upd PPV Distr")
END
!
START: *
IF DIS.PROG THEN
PRINT CLB:"Entering UPDATE.COUNTS.PPV.DISTR. ":
IF DIS.PROG > 1 THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
PRINT @(0,18):
EXLN = 'WITH TYPE = "PPV" AND WITH ACCTG.PER = "':THIS.UPD.PER:'"'
IF TEST.FL THEN PRINT EXLN:
EXECUTE 'SSELECT RPT ':EXLN
!
NEXT: *
READNEXT RPT.ID ELSE GOTO FINISH
*
U.CTR = U.CTR+1
*
LOOP
CALL SYS.ITM.LCK("RPT",RPT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO
PRINT @(ZERO,22):CLL:"You must unlock RPT file - item ":RPT.ID:" then hit <cr> to continue ":; INPUT RSP:
REPEAT
*
MATREAD RPT FROM RPT.FILE,RPT.ID ELSE MAT RPT = ""
*
DISTR = FIELD(RPT.ID,"*",3)
STUDIO = FIELD(RPT.ID,"*",4)
*
RPT$UPDATE.PERIOD<1> = THIS.UPD.PER
RPT$EVENTS<1> = RPT$CURR.EVENTS<1>
RPT$PRICES<1> = RPT$CURR.PRICES<1>
RPT$BUYS<1>   = RPT$CURR.BUYS<1>
RPT$REVERSALS<1> = RPT$CURR.REVERSALS<1>
*
RPT$CURR.EVENTS<1> = ""
RPT$CURR.PRICES<1> = ""
RPT$CURR.BUYS<1> = ""
RPT$CURR.REVERSALS<1> = ""
*
MATWRITE RPT ON RPT.FILE,RPT.ID
CALL SYS.ITM.RLS("RPT",RPT.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
PRINT @(0,15):CLL:"Processed: ":U.CTR "R#6":
GOTO NEXT
!
FINISH: *
IF DIS.SUB THEN
PRINT CLB:"Entering FINISH. ":
IF DIS.SUB > 1 THEN PRINT "Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
*
PPV.UPDATE<1> = DATE()
PPV.UPDATE<2> = NEXT.UPD.PER
PPV.UPDATE<3> = THIS.UPD.PER
WRITE PPV.UPDATE ON COM.FILE,"CURR.PPV.REPORT.PERIOD"
*
STOP
!
$INCLUDE IBP CLS.ROUTINE
!
END
~UPDATE.PPV.EVENTS.PA~
*PROGRAM: UPDATE.PPV.EVENTS.PA
* VERSION: 940703  1.1  ADDED PVM$PVE.DUR, CALC PROGMO FROM PVM$PVE.DT.
* PRIOR 940328 1.0  NEW
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
* DESCRIPTION:  UPDATES PVE ITEMS FOR CHANGES MADE TO THE PVM ITEM.
*               IF AN EVENT IS ADDED, THE PVE ITEM MUST BE CREATED BY
*               RUNNING ASSIGN.EVENT.NUMS. THE NEW ITEM NOT BE ADDED
*               TO THE PVE FILE BY THIS PROGRAM.
*
*
* TEST MODE:  CNT.TST$X WILL NOT WRITE PVM FOR EVENT.NUMS
*             CNT.TST$Z WILL NOT WRITE PVE RECORDS
!
*
VERSION = " (1.1)"; VS = VERSION
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP PVM.DIM
$INCLUDE IBP PVM.EQUATES
*
$INCLUDE IBP PVE.DIM
$INCLUDE IBP PVE.EQUATES
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
!
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:; STOP
OPEN "PVM" TO PVM.FILE ELSE PRINT CLB:"Can't open PVM":; INPUT TMP:; STOP
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN "PVE" TO PVE.FILE ELSE PRINT CLB:"Can't open PVE":; INPUT TMP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:; STOP
* LCK.FILE = 0; * REV ONLY
!
*
LCK.TYPE = -3; LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.STAT = FALSE
START.NUM = EMPTY; TMP.EVENT.NUM = EMPTY 
*
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
AI.SRCE = "A"
*
GOSUB LOAD.TST
IF CNT.TST$ON THEN VERSION = VERSION:" **** TEST MODE ****"
*
*
IF CNT.TST$RTN THEN PRINT CLB:"UPDATE.PPV.EVENTS.PA":; IF CNT.TST$CR THEN INPUT TMP:
PRINT CLB:
*
READV CO.NAME FROM CNT.FILE,"CO.DATA",1 ELSE CO.NAME = "Unknown"
*
OVER = FALSE; UPLOADED.CTR = 0; ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
*
VALID.CTR = 0; UPLOAD.DATE = DATE()
*
PRINT @(0,0):CLS:
TITLE = "Update PPV Event Details":VERSION
$INCLUDE IBP DISPLAY.SCREEN.HEADER
LN = 4; SAVE.LN = 0
*
IF CNT.TST$X THEN
PRINT @(0,LN):"Update of PVM Master Event will be bypassed.":; LN = LN+1
END
*
IF CNT.TST$Z THEN
PRINT @(0,LN):"Write of PVE records will be bypassed.":; LN = LN+1
END
*
!
GET.INPUT: *
LN = LN+1
GET.LN = LN
*
READ AI.TYPES FROM COM.FILE,"AI.TYPES" ELSE AI.TYPES = ""
IF NOT(COUNT(AI.TYPES<1>,VM)) THEN AI.CODE = AI.TYPES<1>; AI.DESC = AI.TYPES<2> ELSE AI.CODE = ""; AI.DESC = ""
*
IF AI.CODE = "" THEN
LOOP
PRINT @(0,LN):CLL:"Enter the Addressable Interface Code: ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP ELSE IF AI.CODE = "" THEN STOP
LOCATE AI.CODE IN AI.TYPES<1> BY "AL" SETTING LOC THEN AI.DESC = AI.TYPES<2,LOC> ELSE
AI.CODE = ""
PRINT CLB:"That Addressable Interface has not been defined. Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
UNTIL AI.CODE NE "" DO REPEAT
END
LN = LN+1
PRINT @(10,LN):AI.DESC:; LN = LN+1
*
COM.ID = "NEXT.PPV.EVENT.NUM.":AI.CODE
!
NEXT.EVENT: *
*
LOOP
PRINT @(0,LN):CLS:"Enter the Master Event Code for updating of Event Details: ":; INPUT EVENT.CODE:
IF EVENT.CODE = "KILL" THEN STOP ELSE IF EVENT.CODE = "" THEN STOP
*
SAVE.LN = LN
*
LOOP
LCK.TYPE = 0
CALL SYS.ITM.LCK("PVM",EVENT.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
WHILE LCK.STAT DO REPEAT
MATREAD PVM FROM PVM.FILE,EVENT.CODE ELSE EVENT.CODE = ""
IF EVENT.CODE NE "" THEN
PRINT @(5,LN+1):CLL:EVENT.CODE:" - ":PVM$DESC:" - debuts on ":OCONV(PVM$DEBUT.DT,"D2"):
VC = 1; E.CTR = 0; ECHK.CTR = 0; ENUM.CTR = 0
LOCATE AI.CODE IN PVM$PVE.AI.CODES<1> SETTING AI.SVC ELSE AI.SVC = 1
LOOP EVENT.DT = PVM$PVE.DT<1,VC> UNTIL EVENT.DT = "" DO
E.CTR = E.CTR+1
MATREAD PVE FROM PVE.FILE,AI.CODE:"*":PVM$EVENT.NUMS<1,VC,AI.SVC> THEN
ENUM.CTR = ENUM.CTR+1 
END ELSE
ECHK.CTR = ECHK.CTR+1
END
VC = VC+1
REPEAT
END
UNTIL EVENT.CODE NE "" DO PRINT BELL: REPEAT
*
LN = LN+2
PRINT @(0,LN):"Number of Events to be unassigned: ":ECHK.CTR:; LN = LN+1
PRINT @(0,LN):"Number of Events to be updated: ":ENUM.CTR:; LN = LN+1
*
*
LN = LN+1; AVAIL.CTR = 0; EUSED.CTR = 0; TMP.EVENT.NUM = ""
*
PRINT CLB:"Press <cr> to start updating of event details, or 'KILL': ":
INPUT RESP:
IF RESP = "KILL" THEN GOTO UNLOCK
PRINT CLB:
* PRINT @(0,3):CLS:
*
!
MAIN.LOOP: *
LN = LN+2
PRINT @(0,LN):CLL:"Updating Event Numbers....":; LN = LN+1
*
LCK.TYPE = -4
*
*
INSERT.ON = 0; PREV.CTR = 0; UPD.CTR = 0; USED.CTR = 0; TMP.EVENT.NUM = ""
VC = 1
*
*
VC = 1
LOOP EVENT.NUM = PVM$EVENT.NUMS<1,VC> UNTIL EVENT.NUM = "" DO
CALL SYS.ITM.LCK("PVE",AI.CODE:"*":EVENT.NUM,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
*
MATREAD PVE FROM PVE.FILE,AI.CODE:"*":EVENT.NUM THEN
PVE$PVM.ID = EVENT.CODE
TMP.DT = OCONV(PVM$PVE.DT,"D2-")
TMP.YR = TMP.DT[7,2]
TMP.MO = TMP.DT[1,2]
PVE$PROGMO = TMP.YR:TMP.MO
PVE$CH.CODE = PVM$CH.CODE
IF PVM$PVE.RATE.CL<1,VC> NE "" THEN PVE$RATE.CL = PVM$PVE.RATE.CL<1,VC> ELSE PVE$RATE.CL = PVM$RATE.CL
IF PVM$PVE.RATE.CL.SUB<1,VC> NE "" THEN PVE$RATE.CL.SUB = PVM$PVE.RATE.CL.SUB<1,VC> ELSE PVE$RATE.CL.SUB = PVM$RATE.CL.SUB
PVE$DT = PVM$PVE.DT<1,VC>
PVE$TM = PVM$PVE.TM<1,VC>
IF PVM$PVE.DUR<1,VC> NE "" THEN PVE$DUR = PVM$PVE.DUR<1,VC> ELSE PVE$DUR = PVM$DUR
PVE$PURGE.DT = PVM$PURGE.DT
*
*
IF NOT(CNT.TST$Z) THEN MATWRITE PVE ON PVE.FILE,AI.CODE:"*":EVENT.NUM
*
END
*
CALL SYS.ITM.RLS("PVE",AI.CODE:"*":EVENT.NUM,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
VC = VC+1; UPD.CTR = UPD.CTR+1
*
PRINT @(0,LN+1):"Updated: ":UPD.CTR "R#4":
REPEAT
*
*
PRINT @(0,SAVE.LN):CLS:
LN = SAVE.LN
*
UNLOCK:
CALL SYS.ITM.RLS("PVM",EVENT.CODE,LCK.FILE,LCK.ID,LCK,LCK.TYPE,LCK.CLASS,LCK.PROG,LCK.RSRV,OPER,EXP.TM,TMPA,TMPB,TMPC,LCK.STAT)
*
LN = SAVE.LN
GOTO NEXT.EVENT
!
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT CLB:"Read Com Ai":; RQM; PRINT CLB:
*
$INCLUDE IBP AI.READ.COM.AI
*
RETURN
*
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
*
!
END
~UPLOAD.PPV.BUYS.PA~
*PROGRAM: UPLOAD.PPV.BUYS.PA
* VERSION: 950322 1.4  ADD OTHER.CTR (COLLECTION ERROR) & ERREV.CTR (EVENTS BUT COLL STATUS SET)
* PRIOR: 941005 1.3  ADD TIME() TO XPV RECORD.
* PRIOR: 940911 1.2  ADD GROUP TO XPV RECORD.
* PRIOR: 940420 1.1  ADDED CONTINUE UPLOAD OPTION (NEXT.DVC.ID = "XXXXXX"
*                      TRAP INTEFACE FATAL ERRORS AND STOP.
*
* COPYRIGHT:  AXION COMPUTER SYSTEMS LTD.
*    1994        ALL RIGHTS RESERVED
*
$INCLUDE IBP STANDARD.FUNCTIONS.DVC
*
EQU VERSION TO "(1.2)"
VS = VERSION
SYS = "PICK"; SYS.APPL = "KBIL"; SYS.APPL.SUB = "AI"
SYS.APPL.SUB = "AI"; SYS.PROG = "UPLOAD.PPV.BUYS.PA"; SYS.LOCT = EMPTY
SEC.USER.ID = ""; CURSOR.KEYS = ""; REC.ON = ""; REC.OFF = ""
*
!
*
* DESCRIPTION:  UPLOAD IMPULSE PPV EVENTS FROM PIONEER POC.
*               UPLOAD.MODE IS INPUT FROM THE MENUS:
*                         0 IS UPLOAD ONLY NOT PREVIOUSLY UPLOADED
*                         1 IS UPLOAD ALL PPV BUYS.
*               WRITES VALID RESPONSES IN THE XPV FILE.
*                  XPV ERR CODES SET ARE:
*                   1 - Unkown Terminal ID (not in AIX)
*                   2 - Invalid Company (based on 1st digit of acct #)
*
*               COLLECTION STATUS IS RECEIVED IN COM.AIP$GROUP.RSLT
*               AN XPV RECORD WILL NOT BE WRITTEN FOR COLLECTION
*               STATUSES OF:
*               0E - NO CALL IN (WILL CURRENTLY BE FOLLOWED UP ON BY THE
*                    PPV DEPT. FROM POC PRINT OUTS).
*                    ** IN FUTURE THESE MAY BE CAPTURED AND BE USED
*                       TO GENERATE A LIST OF 'NO PHONE INS' WHICH WILL
*                       CONTAIN NAME ADDRESS AND TELEPHONE NUMBER AND WILL
*                       SAVE THEM THE TIME OF LOOKING THEM UP FROM THE
*                       TERMINAL ID.
*               0F - NO DATA RECEIVED.
*
*
* TEST MODE: IF LIST.NAME IT WILL CONTAIN DVC.IDs AND:
*              -WILL BYPASS AI OFF/DN ERROR,
*              -WILL HAVE BAD DVC.IDs IN LIST TO CREATE DVC ERRORS
*              -WILL GENERATE EVENTS FROM DVC.IDs IN THE LIST
*               USING TST.GENS, A LOOP THRU FOR # EVENTS PER DVC.ID
*               AND CHECKING TST(20) - THE HIGHEST EVENT NUMBER TO GENERATE
*               AND MAKE EVERY 10TH EVENT AN ERROR EVENT
*            ALSO TEST CNT.TST$Z - NO XPV WRITE COMMAND ISSUED
*
!
*
$INCLUDE IBP CNT.TST.DIM
$INCLUDE IBP CNT.TST.EQUATES
*
$INCLUDE IBP COM.AIP.DIM
$INCLUDE IBP COM.AIP.EQUATES
*
$INCLUDE IBP COM.AI.DIM
$INCLUDE IBP COM.AI.EQUATES
*
$INCLUDE IBP COM.AIIERR.DIM
$INCLUDE IBP COM.AIIERR.EQUATES
*
$INCLUDE IBP COM.AIHERR.DIM
$INCLUDE IBP COM.AIHERR.EQUATES
*
$INCLUDE IBP AIX.DIM
$INCLUDE IBP AIX.EQUATES
*
$INCLUDE IBP XPV.DIM
$INCLUDE IBP XPV.EQUATES
*
$INCLUDE IBP AI.ERR.VAR.EQUATES
*
$INCLUDE IBP AI.TALK.VAR.EQUATES
*
!
*
INPUT AUTO.RUN
INPUT UPLOAD.MODE
*
$INCLUDE IBP AI.ERR.INIT
*
MAT CNT.TST = EMPTY
* CHECK.LN.MIN = 14; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
* OPER = ""; OPT.COMM = ""; CHECK.LEN = 36; CHECK.LN.HI = ZERO
OPER = ""; OPT.COM = ""
* IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
AI.TALK = EMPTY
*
* INPUT AUTO.RUN
IF NOT(AUTO.RUN) THEN
* INPUT UPLOAD.MODE
END ELSE
READ CURRENT.RUN FROM CNT.FILE,"CURRENT.RUN" ELSE STOP
UPLOAD.MODE = CURRENT.RUN<1,2>
AI.CODE     = CURRENT.RUN<1,3>
GROUP       = CURRENT.RUN<1,4>
END
*
OPEN "COM" TO COM.FILE ELSE PRINT CLB:"Can't open COM":; INPUT TMP:; STOP
OPEN "PAR" TO PAR.FILE ELSE PRINT CLB:"Can't open PAR":; INPUT TMP:; STOP
OPEN "AIX" TO AIX.FILE ELSE PRINT CLB:"Can't open AIX":; INPUT TMP:; STOP
*
OPEN "CNT" TO CNT.FILE ELSE PRINT CLB:"Can't open CNT":; INPUT TMP:; STOP
OPEN "XPV" TO XPV.FILE ELSE PRINT CLB:"Can't open XPV":; INPUT TMP:; STOP
OPEN "LOCKS" TO LCK.FILE ELSE PRINT CLB:"Can't open LOCKS":; INPUT TMP:; STOP
* LCK.FILE = 0; * REV ONLY
!
*
LCK.TYPE = -3; LCK.ITM = TRUE; LCK.RELS = FALSE; LCK.STAT = FALSE
MSG = EMPTY; TEXT = EMPTY; OUTPUTS = EMPTY; STATUS.CYCLE = FALSE
OPT.COMM = ""; TRANS.NUM = ""
COM.AI.ERR.DISP = TRUE; *10APR94*
REDISP = FALSE; ERR.DISP.ONLY = 5; ERR.LEN = 44
ERR.CL = 35; ERR.LN.MIN = 16; ERR.LN.MAX = 20; ERR.LN.HI = ZERO
DO.PROMPT = TRUE
STAT = FALSE
*
CHECK.LN.MIN = 16; CHECK.LN = CHECK.LN.MIN; CHECK.LN.MAX = 20
CHECK.LEN = 36; CHECK.LN.HI = ZERO
* IF NOT(DISP.ONLY) THEN STATUS.CYCLE = TRUE ELSE STATUS.CYCLE = FALSE
CHAN.ALL = FALSE; OPER = ""
*
*
AI.SRCE = "U"; LOG.REQUIRED = FALSE; DVC.LOC = ONE
SEND.STATUS = EMPTY
FAST.DISPLAY = FALSE; PORTS.LIST.BUILD = 9; AI.SCAN = TRUE
AI.CHK.ERR = ""; MAT COM.AIHERR = ""
*
!
*
GOSUB LOAD.TST; * : *
IF CNT.TST$ON THEN VS = VERSION:" **** TEST MODE ****"
*
TST.GENS = "1":AM:"2":AM:"3":AM:"4":AM:"5"
EVENT.NUM = 1; EVENT.HI = CNT.TST(21); IF EVENT.HI = "" THEN EVENT.HI = "00050"
DISP.EVENT = EMPTY
*
IF CNT.TST$RTN THEN PRINT @(60,20):"UPLOAD.PPV.BUYS.PA" "L#18":; IF CNT.TST$CR THEN INPUT TMP:
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE CO.DATA = "Unknown"
CO.NAME = CO.DATA<1>
READV CURR.PER FROM COM.FILE,"CURR.PPV.REPORT.PERIOD",2 ELSE CURR.PER = ""
READ LAST.PPV.UPLOAD FROM COM.FILE,"LAST.PPV.UPLOAD.DATE" ELSE LAST.PPV.UPLOAD = ""
READ AI.COS FROM COM.FILE,"AI.COS" ELSE
PRINT CLB:"AI.COS is missing from COM file. Correct and restart. ":
INPUT TMP:
STOP
END
*
READV AI.TYPES FROM COM.FILE,"AI.TYPES",1 ELSE AI.TYPES = ""
IF NOT(COUNT(AI.TYPES<1>,VM)) THEN AI.CODE = AI.TYPES<1> ELSE AI.CODE = ""
*
AI.ERROR = 0; OVER = FALSE; UPLOADED.CTR = 0; ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
OVER.SKIP = ZERO
*
OVER = FALSE; SEND.OK.CN = 0; SEND.ERROR.CTR = 0; EVENT.CTR = 0; ERROR.EVENT.CTR = 0
SEND.STATUS = EMPTY; SEND.CN = ZERO; SEND.ERR.CN = ZERO
SEND.ERR.CN.TOT = ZERO; SEND.ERR.CN.MAX = 10; SEND.ERR.PER.MAX = 5
*
OKCOLL.CTR = 0; NOCALL.CTR = 0; NODATA.CTR = 0; OTHER.CTR = 0; INVALID.DVC = 0; VALID.CTR = 0
EMPEV.CTR = 0; ERREV.CTR = 0
DUPE.CTR = 0; COMM.CTR = 0
UPLOAD.DATE = DATE()
DVC.ID = ""; NEXT.DVC.ID = ""; EVENT.NUMS = ""; EVENT.DUR = ""
ACT.ID = ""; XPV.ID = ""
MAT XPV = ""
AI.STATUS = ""; SEND.STATUS = ""; COLL.STATUS = ""
*
PRINT @(0,0):CLS:
TITLE = "Upload Impulse PPV Buys":VS
$INCLUDE IBP DISPLAY.SCREEN.HEADER
*
IF CNT.TST$ON THEN
IF CNT.TST$LIST.NAME NE "" THEN
PRINT @(0,5):"LIST.NAME is ":CNT.TST$LIST.NAME:
LOOP
PRINT @(0,6):"Transactions will be generated.":
PRINT @(0,7):"Enter a starting transaction number: ":; INPUT TRANS.NUM:
IF NOT(NUM(TRANS.NUM)) THEN TRANS.NUM = ""
UNTIL TRANS.NUM NE "" DO PRINT BELL: REPEAT
END ELSE
PRINT @(0,5):"Uploading thru the Interface.":
END
IF CNT.TST$Z THEN
PRINT @(0,7):"Interface will be bypassed.":
END ELSE
PRINT @(0,7):"Interface will be tested and used if OK.":
END
PRINT CLB:"Press <E> to continue, or 'KILL': ":
INPUT RESP:
IF RESP = "KILL" THEN STOP
PRINT CLB:
MAT COM.AIP = ""; RESP = ""; PRINT @(0,3):CLS:
END
!
GET.INPUT: *
*
LN = 3
*
LOOP
IF AI.CODE = "" THEN PRINT @(10,LN):CLL:"Enter the Addressable Interface Code: ":; INPUT AI.CODE:
IF AI.CODE = "KILL" THEN STOP
LCK.ITM = FALSE; LCK.RELS = FALSE
GOSUB READ.COM.AI; * : *
IF NOT(COM.AI.ON.FILE) THEN IF NOT(CNT.TST$ON) THEN 
AI.CODE = ""
PRINT CLB:"That Addressable Interface has not been defined. Enter <cr>: ":; INPUT TMP:; PRINT CLB:
END
UNTIL AI.CODE NE "" DO REPEAT
LOCATE AI.CODE IN AI.TYPES<1> BY "AL" SETTING LOC THEN AI.DESC = AI.TYPES<2,LOC>
PRINT @(0,LN+1):AI.DESC:
*
IF AI.ERROR AND CNT.TST$LIST.NAME = "" THEN
PRINT @(10,LN+2):"The AI is ":COM.AI$ON.OFF.STAT:" and ":COM.AI$UP.DN.STAT:"  Do want to try another AI? (Y/<cr>): ":; INPUT RESP:
AI.ERROR = 0
IF RESP = "Y" THEN PRINT @(10,LN):CLL:; RESP = ""; AI.CODE = ""; GOTO GET.INPUT
STOP
PRINT @(10,LN+2):CLL:
END
*
LCK.ITM = FALSE; LCK.RELS = FALSE
*
AI.SUFFIX = COM.AI$DB.PREFIX; COMMPORT = COM.AI$COMMPORT
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":AI.SUFFIX ELSE MAT COM.AIIERR = ""
*
*
LN = LN+3
IF CURR.PER NE "" THEN
PRINT @(18,LN):CLL:"The Current PPV Reporting Period is ":CURR.PER:; LN = LN+1
END
*
IF UPLOAD.MODE THEN MODE = "Continue " ELSE MODE = ""
PRINT @(18,LN):CLL:MODE:"Uploading from Addressable Interface ":AI.CODE:; LN = LN+1
*
*
* IF NOT(AUTO.RUN) THEN
* IF UPLOAD.DATE EQ LAST.PPV.UPLOAD<1,1> THEN
LN = LN+2; UL.AC = 1
PRINT @(0,LN):"Gr Uploaded                   |Last|Valid Device|Invalid Dvcs|  No  ":; LN = LN+1
PRINT @(0,LN):"Gr Upld.Date Started  Elapsed |Tran|CountsEvents|CountsEvents|Events":; LN = LN+1
*
LOOP UL.DATE = LAST.PPV.UPLOAD<UL.AC,1> UNTIL UL.DATE = "" OR UL.DATE # LAST.PPV.UPLOAD<1,1> OR LN GT 19 DO
PRINT @(0,LN):LAST.PPV.UPLOAD<UL.AC,23> "L#2":" ":
PRINT OCONV(LAST.PPV.UPLOAD<UL.AC,1>,"D2") "L#10":
PRINT OCONV(LAST.PPV.UPLOAD<UL.AC,3>,"MTS") "L#9":
PRINT OCONV(LAST.PPV.UPLOAD<UL.AC,4>,"MTS") "L#8":
*30
PRINT "|":
PRINT LAST.PPV.UPLOAD<UL.AC,2> "R#4":
PRINT "|":
*37
PRINT LAST.PPV.UPLOAD<UL.AC,5> "R#6":
PRINT LAST.PPV.UPLOAD<UL.AC,7> "R#6":
PRINT "|":
*50
PRINT LAST.PPV.UPLOAD<UL.AC,8> "R#6":
PRINT LAST.PPV.UPLOAD<UL.AC,9> "R#6":
PRINT "|":
*63
PRINT LAST.PPV.UPLOAD<UL.AC,10> "R#4":
*67
PRINT LAST.PPV.UPLOAD<UL.AC,11> "R#4"
*71
PRINT LAST.PPV.UPLOAD<UL.AC,13> "R#4"
*75
PRINT LAST.PPV.UPLOAD<UL.AC,18> "R#4"
*79
UL.AC = UL.AC+1; LN = LN+1
*
REPEAT
*
* END
* END
*
*
LN = LN+2
LOOP
PRINT @(18,LN):CLL:"Enter the Group to upload or <cr> for all: ":; INPUT GROUP:
IF GROUP = "KILL" THEN STOP
IF GROUP = "" THEN GROUP = "00"
IF NOT(NUM(GROUP)) THEN GROUP = ""
UNTIL GROUP NE "" DO REPEAT
GROUP = ("00":GROUP) "R#2"
*
*
!
*
IF NOT(AUTO.RUN) THEN
CALL AUTO.LOADER("UPLOAD.PPV.BUYS.PA",UPLOAD.MODE:VM:AI.CODE:VM:GROUP,"Upl PPV Buys")
END
** IF AUTO.RUN THEN LCK.TYPE = -8
*
!
*
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[Start] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
PRINT @(0,6):
START.TM = TIME(); LN = LN+2; IF LN GT 17 THEN LN = 17
*
IF CNT.TST$LIST.NAME NE "" THEN
EXECUTE 'GET-LIST ':CNT.TST$LIST.NAME
END
*
* SET DVC.ID TO UPLOAD FIRST BUY
DVC.ID = ""; NEXT.DVC.ID = ""; PREV.DVC.ID = ""
IF UPLOAD.MODE THEN NEXT.DVC.ID = "XXXXXX" ELSE NEXT.DVC.ID = "000000"
FIRST.SEND = TRUE
FIRST.DVC.ID = NEXT.DVC.ID
SYS11.RETRY = FALSE
*
ERROR.IND = EMPTY
*
LOOP
LCK.ITM = TRUE; LCK.RELS = TRUE
GOSUB READ.COM.AI; * : *
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[RdAI ] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
GOSUB INTFC.CHECK; * : *
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[Check] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
PRINT CLB:BELL:"The interface is not useable! Enter KILL or <cr> to retry . . . ":
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
INPUT TMP:
IF TMP EQ "KILL" THEN STOP
GOTO GET.INPUT
END ELSE OVER = TRUE
END
WHILE NOT(OVER) AND NOT(COM.AI.ON AND COM.AI.UP) AND NOT(AUTO.RUN) DO REPEAT
*
!
MAIN.LOOP: *
IF CNT.TST$LBL THEN PRINT @(7,23):BELL:"[Main loop] ":; IF CNT.TST$CR THEN INPUT TMP:
*
PRINT @(0,3):CLS:
LN = 3
GENS.VC = 1; GEN.VC = 1
*
LOOP UNTIL OVER DO
*
EVENT.NUMS = ""; EVENT.DUR = ""; DVC.ID = ""; COLL.STATUS = ""
* IF AI.STATUS LT 100 OR AI.STATUS GE 600 THEN AI.STATUS = FALSE
AI.STATUS = EMPTY
SEND.STATUS = EMPTY
*
* ACCEPT KEYBOARD INPUT
IF SYSTEM(11) THEN
PRINT CLB:"Enter (S)top or <cr> to continue: ":; INPUT TMP:
PRINT CLB:; IF TMP = "S" THEN ERROR.IND = "O"; GOTO FINISH
SYS11.RETRY = TRUE
LOOP
TMP = SYSTEM(11)
UNTIL NOT(TMP) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
END
*
!
*
IF CNT.TST$LIST.NAME NE "" THEN
*
READNEXT DVC.ID ELSE OVER = TRUE
*
IF (EVENT.NUM > EVENT.HI OR OVER) THEN OVER = TRUE; COM.AIP$END.UPL = "z"
*
* fill the XPV record with events to TST.GENS count
MAT XPV = ""; MAT COM.AIP = ""; TST.EVENTS = ""; TST.DUR = ""; EVENT.VC = 1
LOOP UNTIL EVENT.VC > TST.GENS<GENS.VC> DO
EVENT.ID = ("0000":EVENT.NUM) "R#4"
IF EVENT.ID[5,1] = 0 THEN EVENT.ID = "9":EVENT.ID[2,4]
TST.EVENTS<1,EVENT.VC> = EVENT.ID
TST.DUR<1,EVENT.VC> = ""
EVENT.NUM = EVENT.NUM+1; EVENT.VC = EVENT.VC+1
REPEAT
*
GENS.VC = GENS.VC+1
IF GENS.VC = 6 THEN GENS.VC = 1
COM.AIP$EVENT = TST.EVENTS
COM.AIP$EVENT.DUR = TST.DUR
COM.AIP$DVC.ID = DVC.ID
COM.AIP$TRAN.SEQ = TRANS.NUM
TRANS.NUM = TRANS.NUM+1
*
!
* Normal run
*
END ELSE
*
* GET ACTUAL DVC.ID AND EVENTS FROM NEXT TERMINAL
TRANS.TYPE = "UPB"; OPT.COMM<ONE> = TRANS.TYPE; HANDLER.COMMAND = TRANS.TYPE
MAT COM.AIP = EMPTY
OPT.PORT = PORT.KEY; OPT.DT = DATE(); OPT.TM = TIME(); AI.TALK = ""; COM.AIP$INTFC.STAT = ""; COM.AIP$ERR = ""
*
$INCLUDE IBP AI.LOAD.COM.AIP
*
COM.AIP$SVC.FUNC = "UPB"; COM.AIP$DVC.TYPE = AI.CODE
COM.AIP$OPER     = OPER
COM.AIP$SVC.EXTR = UPLOAD.MODE
COM.AIP$GROUP    = GROUP
COM.AIP$DVC.ID   = NEXT.DVC.ID
*
COM.AIP$EVENT = ""
COM.AIP$EVENT.DUR = ""
COM.AIP$GROUP.RSLT = ""
IF NOT(FIRST.SEND) THEN
COM.AIP$END.UPL = ""
END ELSE
COM.AIP$END.UPL = FIRST.DVC.ID
END
*
AI.DVC.NEXT.CN = ONE; SEND.COMM.CN = ONE
*
IF SYS11.RETRY THEN
COM.AIP$COMM.CN<ONE,SEND.COMM.CN,ONE> = ONE
SYS11.RETRY = FALSE
END
*
*
COM.ID = "AI*":AI.CODE:"*":PORT:"*":AI.DVC.NEXT.CN
COM.AIP.ID = "AI*":AI.CODE:"*":PORT:"*":AI.DVC.NEXT.CN
GOSUB WRITE.COMMAND; * : *
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[WrCMD] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
*
IF (AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*????
END
IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) THEN
ERR.IND = "F"
END.LIT = "Abnormal, Interface failure"
PRINT @(ZERO,22):CLL:"Upload stopped (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:") - ":END.LIT:".":
PRINT CLB:" Enter 'C' to continue or <cr> to end!! ":; INPUT TMP:
IF TMP NE "C" THEN
ERROR.IND = "F"; GOTO FINISH
END
END
*
* Wait for command to be processed
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
WF.C.FUNC = PORT.KEY; STAT = 0; GOSUB WAITFOR.COMMAND; * : *
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[Wait ] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
END
*
* Check transmission result
*
TMP.STAT = 0
***$INCLUDE IBP AI.INCL.UPDT.COM.AIP
*
DT = DATE(); TM = TIME()
** LOOP
** LCK.TYPE = -3
** CALL SYS.ITM.LCK("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","A","",LCK.STAT)
** LCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
** WHILE SYSTEM(11) LT 3 AND LCK.STAT AND LCK.STAT NE 998 AND LCK.ELP LE 90 DO REPEAT
** IF LCK.STAT THEN
** AI.STATUS = LCK.STAT + 900
** ERROR.IND = "F"; GOTO FINISH
** END ELSE
** LCK.COM.AIP = TRUE
** END
*
!
*
**IF LCK.COM.AIP THEN
**TMP.STAT = 0
****$INCLUDE IBP AI.INCL.UPDT.COM.AIP
**CALL SYS.ITM.RLS("COM",COM.AIP.ID,LCK.FILE,LCK.ID,LCK,LCK.TYPE,"1",SYS.PROG,"0",OPER,EXP.TM,"#","B","",LCK.STAT)
$INCLUDE IBP AI.INCL.UPDT.COM.AIP
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[UpAIP] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
**LCK.COM.AIP = FALSE
**END
*
*
IF TMP.STAT = 0 THEN TMP.STAT = ""; AI.STATUSES = ""
IF TMP.STAT NE "" THEN
IF AI.STATUS NE "" THEN
AI.STATUSES = TMP.STAT:AM:AI.STATUS
END ELSE
AI.STATUSES = TMP.STAT
END
END
*
IF AI.STATUSES NE "" THEN
VC = 1
LOOP TMP9 = AI.STATUSES<VC> UNTIL TMP9 = "" DO
LOCATE TMP9 IN COM.AIIERR$STD<1> SETTING LOC THEN
COM.AI.ERR      = COM.AI.ERR:AM:COM.AIIERR$STD<1,LOC>
COM.AI.ERR.TYPE = COM.AI.ERR.TYPE:AM:COM.AIIERR$TYPE<1,LOC>
COM.AI.ERR.DESC = COM.AI.ERR.DESC:AM:COM.AIIERR$DESC<1,LOC>
END
VC = VC+1
REPEAT
GOSUB INTFC.MESSAGES; GOSUB ERROR; * : *
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[Msgs ] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
END
*
*
**IF (AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
** ERROR.CTR = ERROR.CTR + 1
IF NOT(AI.STATUS LT 100 OR AI.STATUS GE 600) THEN
ERR.IND = "F"
END.LIT = "Abnormal, Interface failure"
PRINT @(ZERO,22):CLL:"Upload stopped (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:") - ":END.LIT:".":
PRINT CLB:" Enter 'C' to continue or <cr> to end!! ":; INPUT TMP:
IF TMP NE "C" THEN
ERROR.IND = "F"; GOTO FINISH
END
END
**END
*
LOOP WHILE NOT(COM.AI.ON AND COM.AI.UP) DO
LCK.ITM = TRUE; LCK.RELS = TRUE
GOSUB READ.COM.AI; * : *
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[Rd Ai] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
GOSUB INTFC.CHECK; * : *
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[Check] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
PRINT CLB:BELL:"The interface is not useable! Enter <cr> or KILL ... ":
INPUT TMP:
IF TMP EQ "KILL" THEN GOTO FINISH
END ELSE
GOTO FINISH
END
END
REPEAT
*
*
END; * of not test mode
*
!
**PRINT CLB:"MIDDLE ":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:",":COM.AIP$END.UPL:",":OVER:; INPUT TMP:
*
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
IF CNT.TST$X THEN
PRINT CLB:"Start process of uploaded item.":
PRINT "Enter <cr>: ":; INPUT TMP:
END
END
*
!
*
$INCLUDE IBP AI.INCL.WRITE.XPV
*
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:"[WrXPV] (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:")":
*
!
*
SEND.CN = SEND.CN + ONE
*950324*DGH*IF AI.STATUS LT 100 AND (NOT(SEND.STATUS) OR SEND.STATUS EQ ERR$CHECK.TOUT) THEN
IF NOT(AI.STATUS OR (SEND.STATUS AND SEND.STATUS NE ERR$CHECK.TOUT)) THEN
*
SEND.ERR.CN = ZERO
* PVE$DLL.ERR = ""
SEND.OK.CN = SEND.OK.CN + 1
SEND.ERR.PER = INT(SEND.ERR.CN.TOT / SEND.CN * 100)
PRINT @(ZERO,22):CLL:SEND.ERR.CN+0:" errors in a row, at ":SEND.ERR.PER:"%, [":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:"], (Total ":SEND.ERR.CN.TOT+0:").":
* PRINT @(40,EV.LN+1):CLL:"Event Details Uploaded: ":SEND.OK.CN "R#4":
* PRINT @(5,11):CLL:"Event Details Uploaded: ":SEND.OK.CN "R#4":
IF CNT.TST$ID THEN
PRINT @(15,23):CLL:"Completed upload of Event ":DISP.EVENT:
IF CNT.TST$Y THEN PRINT "Enter <cr>: ":; INPUT TMP:
END
*
END ELSE
*
SEND.ERR.CN = SEND.ERR.CN + ONE
SEND.ERR.CN.TOT = SEND.ERR.CN.TOT + ONE
SEND.ERROR.CTR = SEND.ERROR.CTR + 1
SEND.ERR.PER = INT(SEND.ERR.CN.TOT / SEND.CN * 100)
* PRINT @(15,23):CLL:SEND.ERR.CN+0:" errors in a row, at ":SEND.ERR.PER:"%, [":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:"], (Total ":SEND.ERR.CN.TOT+0:").":
PRINT @(ZERO,22):CLL:SEND.ERR.CN+0:" errors in a row, at ":SEND.ERR.PER:"%, [":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:"], (Total ":SEND.ERR.CN.TOT+0:").":
*
IF SEND.ERR.CN GT SEND.ERR.CN.MAX OR (SEND.ERR.PER GT SEND.ERR.PER.MAX AND SEND.ERR.CN GT 5) THEN
PRINT CLB:"Too many errors (":SEND.ERR.CN.TOT+0:")! Stopping the upload.":BELL:
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>: ":
INPUT TMP:
END
OVER = TRUE
END
*
PRINT @(15,23):CLL:"Error (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:") on Event: ":DISP.EVENT:"!!  Enter any key... ":BELL:
FOR TMP = 1 TO 5 UNTIL SYSTEM(11)
PRINT BELL:
EXECUTE "SLEEP 5"
NEXT TMP
LOOP
TMP1 = SYSTEM(11); * ULT ONLY
*TMP1 = TRUE; * REV ONLY
*
UNTIL NOT(TMP1) DO
RSP = EMPTY
RSP = OCONV(RSP,"U51EA")
REPEAT
*960517*DGH*IF CNT.TST$ID THEN
*960517*DGH*IF CNT.TST$Y THEN PRINT "Enter <cr>: ":; INPUT TMP:
*960517*DGH*END
IF CNT.TST$ID AND CNT.TST$Y THEN PRINT "Enter <cr>: ":; INPUT TMP:
IF CNT.TST$LBL THEN PRINT @(7,23):CLL:("Handler Send Error: ":COM.AIP$INTFC.ERR) "L#30":; IF CNT.TST$CR THEN PRINT "Enter <cr>: ":; INPUT TMP:
*
END; * of transmission error
*
*
IF NOT(COM.AI.ON AND COM.AI.UP) THEN
PRINT CLB:"The Handler is not ON and UP. Stopping the upload.":
IF NOT(AUTO.RUN) THEN
PRINT " Enter <cr>: ":
INPUT TMP:
END
OVER = TRUE
END
*
* END; * of not list.name
*
*
PRINT @(9,LN-1):CLL:"      Uploading Group: ":GROUP "R#6":"    Device: ":DVC.ID "L#20":
PRINT @(9,LN+0):CLL:"  Converters Uploaded: ":UPLOADED.CTR "R#6":"     Status: (":AI.STATUS + ZERO:"-":SEND.STATUS + ZERO:"-":COLL.STATUS:"-":XPV$ERROR:")":
PRINT @(9,LN+1):CLL:"                Empty: ":EMPEV.CTR "R#6":
PRINT @(9,LN+2):CLL:"                Valid: ":VALID.CTR "R#6":"  Events: ":EVENT.CTR "R#6":
PRINT @(9,LN+3):CLL:"          *** Invalid: ":ERROR.CTR "R#6":"  Events: ":ERROR.EVENT.CTR "R#6":"    Tot Devices: ":(EMPEV.CTR+VALID.CTR+ERROR.CTR) "R#6":
PRINT @(9,LN+4):CLL:"   Events & Coll Note: ":ERREV.CTR "R#6":"   Total: ":(EVENT.CTR+ERROR.EVENT.CTR) "R#6":
PRINT @(9,LN+5):CLL:"    Other Coll Errors: ":OTHER.CTR "R#6":
PRINT @(9,LN+6):CLL:"           No Call In: ":NOCALL.CTR "R#6":
PRINT @(9,LN+7):CLL:"          *** No Data: ":NODATA.CTR "R#6":"  TotColl: ":(OTHER.CTR+NOCALL.CTR+NODATA.CTR) "R#6":" vs ":OKCOLL.CTR "L#6":"  for ":(OTHER.CTR+NOCALL.CTR+NODATA.CTR+OKCOLL.CTR) "R#6":
PRINT @(9,LN+8):CLL:"            Comm Data: ":COMM.CTR "R#6":
PRINT @(9,LN+9):CLL:"            Dupe Data: ":DUPE.CTR "R#6":"     Good: ":OKCOLL.CTR "R#6":"      All Comm: ":(OTHER.CTR+NOCALL.CTR+NODATA.CTR+OKCOLL.CTR+COMM.CTR+DUPE.CTR) "R#6":
PRINT @(9,LN+10):CLL:"*** Total Comm Errors: ":SEND.ERR.CN.TOT "R#6":"     Good: ":SEND.OK.CN "R#6":"         Total: ":SEND.CN "R#6":
PRINT @(9,LN+11):CLL:"Interface Trans. Num.: ":TRANS.NUM "R#6":
*
*
REPEAT
*
ERROR.IND = "N"; GOTO FINISH; * : *
*
!
WRITE.COMMAND: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):"Write Command" "L#19":; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*
* @@@ COM.AIP REC LOAD
*
DT = DATE(); TM = TIME(); HEADEND = ""
LCK.ITM = TRUE; LCK.RELS = TRUE
* 250
*
LOOP
GOSUB READ.COM.AI; * : @
LCK.ELP = ((DATE() - DT) * 86400) + (TIME() - TM)
WHILE LCK.STAT AND LCK.STAT NE 998 AND LCK.ELP LE 60 DO REPEAT
*
IF LCK.STAT EQ 998 THEN
MSG.P = "Transaction cancelled - Interface info missing! Enter <cr>: "
END ELSE
IF LCK.STAT THEN
MSG.P = "Transaction cancelled - Interface locks error!! Again (Y/<cr>): "
END
END
IF LCK.STAT THEN
GOSUB DISPLAY.PROMPT; * : *
IF RSP EQ "Y" THEN STAT = FALSE; GOTO WRITE.COMMAND
**AI.STATUS = LCK.STAT; STAT = 999
STAT = 999
END
*
IF NOT(LCK.STAT) THEN
*
CALL AI.SUBR.WRITE.COMMAND(MAT COM.AI,COM.AI.ID,MAT COM.AIP,COM.AIP.ID,HANDLER.COMMAND,AI.STATUS,SEND.STATUS,AI.CODE,AI.SRCE,LCK.COM.AI,LCK.COM.AIP,LCK.TYPE,1,SYS.PROG,STAT)
*
END; * of not stat
*
**LOCATE PORT.KEY IN COM.AI$FUNC.PORT<ONE> SETTING PORT.LOC ELSE
**COM.AI$FUNC.PORT = COM.AI$FUNC.PORT:VM:PORT.KEY
**END
***
**MATWRITE COM.AI ON COM.FILE,COM.AI.ID
***
**LCK.ITM = TRUE; LCK.RELS = TRUE
**GOSUB READ.COM.AI.UNLOCK; * : *
*
RETURN
!
INTFC.CHECK: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Check Handler" "L#19":RVE:; RQM
*
*INCLUDE IBP AI.INCL.INTFC.CHECK: *
CALL AI.SUBR.INTFC.CHECK(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
RETURN
*
!
*
ERROR: *
*
$INCLUDE IBP SYS.INCL.ERROR
*
RETURN
*
!
WAITFOR.COMMAND: * WAIT FOR COMMAND TO BE ACCEPTED
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"WAIT FOR COMMAND" "L#19":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END 
*
*INCLUDE IBP AI.INCL.WAITFOR.COMMAND
CALL AI.SUBR.WAITFOR.COMMAND(LCK.TYPE,LCK.ITM,LCK.RELS,LCK.STAT,LCK.ELP.MAX,COMMPORT,AI.CODE,PORT.KEY,PORTS.LIST,PORTS.LIST.BUILD,PORTS.LIST.PREV,CHECK.LN,CHECK.LEN,CHECK.LN.MIN,CHECK.LN.MAX,CHECK.LN.HI,FAST.DISPLAY,ERR.DISP.ONLY,ERR.BELL,TEXT,OUTPUTS,ERR.LN.MIN,ERR.LN,ERR.LN.MAX,ERR.LN.HI,LAST.ERROR,ERR.LEN,ERR.FMT,ERR.CLB,ERR.CLS,ERR.CL,ERR.HDR,ERR.CR,MAT COM.AIHERR,MAT COM.AIP,COM.AIP.ID,COM.AIP.PORT,COM.AIP.PORT.FIRST,COM.AIP.ELP,COM.AIP.ON.FILE,MAT COM.AI,COM.AI.ID,COM.AI.RUN.ELP,COM.AI.ERR.DISP,COM.AI.ERR,COM.AI.ERR.TEXT,COM.AI.ERR.TYPE,COM.AI.ERR.FUNC,COM.AI.ON,COM.AI.UP,AI.SRCE,AI.CHK.ERR,AI.SCAN,COM.ID,MAT CNT.TST,CNT.TST.ID,CO.DATA,OFF.FLAG,AI.TALK,AI.STATUS,SEND.STATUS,SYS.PROG,STAT)
*
RETURN
!
READ.COM.AI: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Read Com Ai" "L#19":RVE:; RQM
*
$INCLUDE IBP AI.READ.COM.AI
*
IF NOT(COM.AI$ON.OFF = "ON" AND COM.AI$UP.DN.STAT = "UP") THEN
AI.ERROR = 1
END ELSE AI.ERROR = 0
*
AI.DVC.NEXT.CN = ONE; SEND.COMM.CN = ONE
COM.AIP.ID = "AI*":AI.CODE:"*":PORT.KEY:"*":AI.DVC.NEXT.CN
*
MATREAD COM.AIIERR FROM COM.FILE,"AI.IERRORS.":COM.AI$DB.PREFIX<ONE,DVC.LOC> ELSE MAT COM.AIIERR = EMPTY
MATREAD COM.AIHERR FROM COM.FILE,"AI.HERRORS" ELSE MAT COM.AIHERR = EMPTY
*
RETURN
*
!
!
DISPLAY.PROMPT: * DISPLAY MSG AND PROMPT 'ENTER <cr>' IF DO.PROMPT
LOOP
PRINT CLB:MSG.P:
IF DO.PROMPT THEN
IF NOT(AUTO.RUN OR SYSTEM(11)) THEN
INPUT TMP:; IF TMP EQ "KILL" THEN STAT = 999; RETURN
END ELSE TMP = EMPTY
END
TMP = ""
UNTIL TMP EQ EMPTY DO PRINT BELL: REPEAT
MSG.P = ""; DO.PROMPT = 1
RETURN
*
!
*
INTFC.MESSAGES: *
*
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Message Display" "L#19":RVE:; IF CNT.TST$CR THEN; INPUT TMP:; END ELSE; FOR TST.TMP = ONE TO CNT.TST$PAUSE; RQM; NEXT TST.TMP; END
*
$INCLUDE IBP AI.INCL.INTFC.MESSAGES
*
RETURN
*
!
FINISH: *
IF CNT.TST$LBL THEN PRINT @(60,TWO):RVB:"Finish " "L#19":RVE:; IF CNT.TST$CR THEN INPUT TMP:
*
END.DATE = DATE(); ELAPSED.TM = (END.DATE-UPLOAD.DATE)*86400+(TIME()-START.TM)
*
INS UPLOAD.DATE     BEFORE LAST.PPV.UPLOAD<1>
INS TRANS.NUM       BEFORE LAST.PPV.UPLOAD<1,2>
INS START.TM        BEFORE LAST.PPV.UPLOAD<1,3>
INS ELAPSED.TM      BEFORE LAST.PPV.UPLOAD<1,4>
INS UPLOADED.CTR    BEFORE LAST.PPV.UPLOAD<1,5>
INS VALID.CTR       BEFORE LAST.PPV.UPLOAD<1,6>
INS EVENT.CTR       BEFORE LAST.PPV.UPLOAD<1,7>
INS ERROR.CTR       BEFORE LAST.PPV.UPLOAD<1,8>
INS ERROR.EVENT.CTR BEFORE LAST.PPV.UPLOAD<1,9>
INS NODATA.CTR      BEFORE LAST.PPV.UPLOAD<1,10>
INS NOCALL.CTR      BEFORE LAST.PPV.UPLOAD<1,11>
INS ERROR.IND       BEFORE LAST.PPV.UPLOAD<1,12>
INS OTHER.CTR       BEFORE LAST.PPV.UPLOAD<1,13>
INS ERREV.CTR       BEFORE LAST.PPV.UPLOAD<1,14>
INS SEND.ERR.CN.TOT BEFORE LAST.PPV.UPLOAD<1,15>
INS SEND.OK.CN      BEFORE LAST.PPV.UPLOAD<1,16>
INS SEND.CN         BEFORE LAST.PPV.UPLOAD<1,17>
INS EMPEV.CTR       BEFORE LAST.PPV.UPLOAD<1,18>
INS OKCOLL.CTR      BEFORE LAST.PPV.UPLOAD<1,19>
INS AI.STATUS       BEFORE LAST.PPV.UPLOAD<1,20>
INS SEND.STATUS     BEFORE LAST.PPV.UPLOAD<1,21>
INS COLL.STATUS     BEFORE LAST.PPV.UPLOAD<1,22>
INS GROUP           BEFORE LAST.PPV.UPLOAD<1,23>
*
CN.MAX = DCOUNT(LAST.PPV.UPLOAD,AM)
LOOP WHILE CN.MAX GT 100 DO
PRINT @(0,23):CN.MAX:
DEL LAST.PPV.UPLOAD<CN.MAX>
CN.MAX = CN.MAX - 1
REPEAT
*
WRITE LAST.PPV.UPLOAD ON COM.FILE,"LAST.PPV.UPLOAD.DATE"
*
IF ERROR.IND = "O" THEN END.LIT = "by operator"
IF ERROR.IND = "F" THEN END.LIT = "Abnormal, Interface failure"
IF ERROR.IND = "N" THEN END.LIT = "completed succesfully"
PRINT @(ZERO,22):CLL:"Upload stopped (":AI.STATUS + ZERO:",":SEND.STATUS + ZERO:") - ":END.LIT:".":
PRINT CLB:" Enter <cr>: ":; INPUT TMP:
STOP
*
!
LOAD.TST: *
*
$INCLUDE IBP TST.INCL.LOAD
*
RETURN
!
END
