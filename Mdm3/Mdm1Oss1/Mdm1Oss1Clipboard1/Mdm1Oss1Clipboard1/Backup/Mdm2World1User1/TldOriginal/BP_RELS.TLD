~AXION.PROGLIST~
*PROGRAM: AXION.PROGLIST
*
* AUTHOR:            DAVID STERN - AXION
*
* DESCRIPTION:       FORMAT AND PRINT BASIC PROGRAMS IN FILE 'BP'
* DATE WRITTEN:      22 OCT 82
* DATE RELEASED:     22 OCT 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
$INCLUDE IBP STANDARD.FUNCTIONS
SYS.SYST = EMPTY; SYS.APPL = "SYS"; SYS.APPL.SUB = "CODE"
*
!
*
$INCLUDE IBP SYS.ERR.INIT
*
STAT = FALSE
LCK.TYPE = -3
LCK.ELP = ZERO; LCK.ELP.MAX = 60
LCK.ITM = TRUE; LCK.RELS = TRUE; LCK.STAT = LCK.TYPE
SYS.PROG = "AXION.PROGLIST"
PRINT @(ZERO,ZERO):CLS
PRINT TIMEDATE() "L#20":(SPACE(20 - LEN(SYS.PROG) / TWO):SYS.PROG) "L#40":(WHO) "R#19"
PRINT @(ZERO,3):
*
CNTRL.FL = ONE; FILE.NAME = "SYS"
OPEN "SYS" TO SYS.FILE ELSE
TEXT<-ONE> = "SYS File is missing!"
CALL SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
END
*
CNTRL.FL = ONE; FILE.NAME = "COM"
OPEN "COM" TO COM.FILE ELSE
TEXT<-ONE> = "COM File is missing!"
CALL SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
END
*
CNTRL.FL = ONE; FILE.NAME = "PAR"
OPEN "PAR" TO PAR.FILE ELSE
TEXT<-ONE> = "PAR File is missing!"
CALL SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
END
*
CNTRL.FL = ONE; FILE.NAME = "LOCKS"
OPEN "LOCKS" TO LCK.FILE ELSE
TEXT<-ONE> = "LOCKS File is missing!"
CALL SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
END
*
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
LINE.DISP = TERM.DISP
LINE.DISP = FALSE
*
$INCLUDE IBP SYS.INCL.LOAD.AUTO
*
!
*
FAST.PRINT = EMPTY; FIRST.PG = TRUE
*PRINT
PRINT "Enter equates parameter ({F}{X} 1 or 0): ":
IF AUTO.RUN THEN
EQUATES = CURRENT.RUN<ONE,TWO>
PRINT EQUATES
END ELSE INPUT EQUATES
IF EQUATES EQ "KILL" THEN STOP
IF EQUATES[ONE,ONE] EQ "F" THEN EQUATES = EQUATES[TWO,99]; FAST.PRINT = ONE 
*
*
IF FAST.PRINT THEN
*PRINT
PRINT "Enter Form Feed required between pages (1 or 0): ":
IF AUTO.RUN THEN
FAST.FF = CURRENT.RUN<ONE,3>
PRINT FAST.FF
END ELSE INPUT FAST.FF
IF FAST.FF EQ "KILL" THEN STOP
END ELSE FAST.FF = TRUE
*
*
*PRINT
PRINT "Enter file name: ":
IF AUTO.RUN THEN
FIL.NAME = CURRENT.RUN<ONE,4>
PRINT FIL.NAME
END ELSE INPUT FIL.NAME
IF FIL.NAME EQ "KILL" THEN STOP
*PRINT
*
**OPEN FIL.NAME TO PRG.FILE ELSE PRINT "File is missing!"; STOP
OPEN FIL.NAME TO PRG.FILE ELSE
CNTRL.FL = ONE; FILE.NAME = FIL.NAME
CALL SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
END
*
**OPEN "DICT",FIL.NAME TO PRG.FILE.DICT ELSE PRINT "Dict of file is missing!"; STOP
OPEN "DICT",FIL.NAME TO PRG.FILE.DICT ELSE
CNTRL.FL = ONE; FILE.NAME = "DICT ":FIL.NAME
CALL SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
END
*
*
*PRINT
*PRINT "Enter INCLUDE file name: ":; INPUT INCL.FIL.NAME
INCL.FIL.NAME = "IBP"
IF AUTO.RUN THEN
INCL.FIL.NAME = CURRENT.RUN<ONE,5>
* PRINT INCL.FIL.NAME
END ELSE
* INPUT INCL.FIL.NAME
END
PRINT "Enter INCLUDE file name: ":INCL.FIL.NAME
IF INCL.FIL.NAME EQ "KILL" THEN STOP
IF INCL.FIL.NAME EQ EMPTY THEN INCL.FIL.NAME = FIL.NAME
*PRINT
*
**OPEN INCL.FIL.NAME TO INCL.PRG.FILE ELSE PRINT "File is missing!"; STOP
OPEN INCL.FIL.NAME TO INCL.PRG.FILE ELSE
CNTRL.FL = ONE; FILE.NAME = INCL.FIL.NAME
CALL SYS.SUBR.OPEN.ERR(CNTRL.FL,SYS.SYST,FILE.NAME,STAT)
END
*
*
*PRINT
PRINT "Enter LIST name: ":
IF AUTO.RUN THEN
LIST.NAME = CURRENT.RUN<ONE,6>
PRINT LIST.NAME
END ELSE INPUT LIST.NAME
IF LIST.NAME EQ "KILL" THEN STOP
*
*
IF LIST.NAME NE EMPTY THEN
ITM.NAME = EMPTY
END ELSE
*PRINT
PRINT "Enter Item Name: ":
INPUT ITM.NAME
END
*
!
*
TMP = EQUATES
IF FAST.PRINT THEN TMP = "F":EQUATES
EXEC.IN = TMP
EXEC.IN<ONE,TWO> = FAST.FF
EXEC.IN<ONE,3>   = FILE.NAME
EXEC.IN<ONE,4>   = INCL.FIL.NAME
EXEC.IN<ONE,5>   = LIST.NAME
EXEC.IN<ONE,6>   = ITM.NAME
EXEC.VERB = "AXION.PROGLIST"
EXEC.DESC = "Code Analysis"
*
$INCLUDE IBP SYS.INCL.UPD.AUTO
*
!
*
DIM INCL.LINES(1500); MAX.LINES = 82
MAX.LINES = 60
*
DIM PROG.PAGES(100); MAT PROG.PAGES = EMPTY
PROG.MAP = EMPTY
*
!
*
PTY = EMPTY; PQUE = EMPTY; PQUE.FUNC = EMPTY
PTR.ON = EMPTY; PTR.OFF = EMPTY; REGF = EMPTY; COMF = EMPTY
C12.FONT = EMPTY; C12.FONT.CR = EMPTY
CRCOM78 = EMPTY; CRCOM72 = EMPTY; CRCOMF = EMPTY
LPI6 = EMPTY; LPI8 = EMPTY
STAT = EMPTY
*
CALL LPT.SUBR.OPEN(PAR.FILE,PTY,PQUE,PQUE.FUNC,PTR.ON,PTR.OFF,REGF,COMF,C12.FONT,C12.FONT.CR,CRCOM78,CRCOM72,CRCOMF,LPI6,LPI8,STAT)
*
* COMF = CHAR(27):"[;12m":CHAR(27):"[;44 G"; C12.FONT = CHAR(27):"[;11m":CHAR(27):"[;60 G"
* COMF = EMPTY; C12.FONT = EMPTY
*
IF EQUATES[ONE,ONE] EQ "X" THEN
EQUATES = EQUATES[TWO,9999]
REQD.FONT = C12.FONT
MAX.COLS  = 98
END ELSE
REQD.FONT = COMF
MAX.COLS  = 130
END
IF REQD.FONT EQ EMPTY THEN
REQD.FONT = REGF
MAX.COLS  = 80
END
*
* IF EQUATES[ONE,ONE] EQ "X" THEN EQUATES = EQUATES[TWO,ONE]; REQD.FONT = C12.FONT; MAX.COLS = 98 ELSE REQD.FONT = COMF; MAX.COLS = 130
PRINT @(ZERO,TWO):
CALL LPT.SUBR.ON(STAT)
PRINT REQD.FONT:
IF REQD.FONT EQ EMPTY THEN PRINT " ":
CALL LPT.SUBR.OFF(STAT)
IF EQUATES NE ONE THEN EQUATES = ZERO
*
FIRST = EMPTY
SECOND = EMPTY
LAST = EMPTY
*
EXPCT = EMPTY; EXPCT.TWO = EMPTY; EXPCT.THREE = EMPTY
TC = EMPTY; TC.CN = EMPTY
*
TAB.TABLE = EMPTY
TAB = ONE; CASE.FLAG = ZERO
TAB.ERR = FALSE
TAB.TABLE<ONE,ONE> = "ROUTINE"
TAB.TABLE<TWO,ONE> = EMPTY
TAB.TABLE<3,ONE>   = "END"
TAB.TABLE<4,ONE>   = ONE
TAB.TABLE<5,ONE>   = 999999
TAB.TABLE<6,ONE>   = EMPTY
TAB.TABLE<7,ONE>   = EMPTY
TAB.TABLE<8,ONE>   = EMPTY
TAB.TABLE<9,ONE>   = EMPTY
TAB.TABLE<10,ONE>  = EMPTY
TAB.STRING = "|  "
TAB.STRINGA = "+  "
LOOP UNTIL LEN(TAB.STRING) GT MAX.COLS DO TAB.STRING = TAB.STRING:TAB.STRING REPEAT
LOOP UNTIL LEN(TAB.STRINGA) GT MAX.COLS DO TAB.STRINGA = TAB.STRINGA:TAB.STRINGA REPEAT
*
END.OF.LIST = FALSE
END.OF.PROG = FALSE
FIRST.PASS = TRUE
*
!
*
MAIN: * READ EACH PROGRAM SELECTED
*
IF NOT(END.OF.LIST) THEN
IF LIST.NAME NE EMPTY THEN
READNEXT ITM.NAME ELSE
ITM.NAME = EMPTY
END.OF.LIST = ONE 
END
END
END
*
IF END.OF.LIST OR ITM.NAME EQ EMPTY THEN
PRINT @(40,4):"Enter item name: ":
IF AUTO.RUN THEN
ITM.NAME = EMPTY
END ELSE INPUT ITM.NAME
IF ITM.NAME EQ "KILL" THEN STOP
* END ELSE
* PRINT @(40,4):"Enter item name: ":ITM.NAME
END
*
IF ITM.NAME EQ EMPTY THEN
CALL LPT.SUBR.ON(STAT)
PRINT COMF:
STOP
END
*
**PRINT; PRINT ITM.NAME
IF TERM.DISP THEN
PRINT @(40,4):"Item Name: ":ITM.NAME "L#30":
END ELSE
PRINT; PRINT CLL:ITM.NAME
END
*
PROG.ID = ITM.NAME
IF TERM.DISP THEN PRINT @(ZERO,5):CLL:
INCL.PROG.ID = EMPTY
LINE.NUM = MAX.LINES; PAGE.NUM = ZERO
MAT PROG.PAGES = EMPTY
PROG.MAP = EMPTY
TAB = ONE; TAB.ERR = EMPTY; TAB.TABLE = EMPTY; CASE.FLAG = ZERO
*
TAB = ONE; CASE.FLAG = ZERO
TAB.ERR = FALSE
TAB.TABLE<ONE,ONE> = "ROUTINE"
TAB.TABLE<TWO,ONE> = EMPTY
TAB.TABLE<3,ONE>   = "END"
TAB.TABLE<4,ONE>   = ONE
TAB.TABLE<5,ONE>   = 999999
TAB.TABLE<6,ONE>   = EMPTY
TAB.TABLE<7,ONE>   = EMPTY
TAB.TABLE<8,ONE>   = EMPTY
TAB.TABLE<9,ONE>   = EMPTY
TAB.TABLE<10,ONE>  = EMPTY
*
*
PROG.MAP<-ONE> = ITM.NAME:VM:ONE:SVM:ZERO:SVM:ZERO:SVM:ZERO
LINE.FIRST = EMPTY
NUM = ONE; INCL.NUM = ONE; TRUE.NUM = ONE
ITM.NAME.LINE = "Program Listing - '":FILE.NAME:" ":ITM.NAME:"' - from account ":ACCT
END.OF.PROG = FALSE
IF TERM.DISP AND LINE.DISP THEN
PRINT @(0,17):CLS:">>[":
END
*
!
*
LOOP
*
READV LINE FROM PRG.FILE,PROG.ID,TRUE.NUM ELSE LINE = EMPTY
IF TRUE.NUM EQ ONE THEN LINE.FIRST = LINE; TAB.TABLE<ONE,ONE> = FIELD(LINE.FIRST," ",ONE)
IF LINE EQ EMPTY THEN
READV NEXT.LINE FROM PRG.FILE,PROG.ID,TRUE.NUM + ONE ELSE NEXT.LINE = EMPTY
IF NEXT.LINE EQ EMPTY THEN END.OF.PROG = TRUE
END
*
UNTIL END.OF.PROG DO
*
BEGIN CASE
CASE OPSYS EQ "M"
PRNUM = "(":TRUE.NUM:") ":NUM
CASE TRUE
PRNUM = TRUE.NUM
END CASE
*
PC = "."; PCP = PC
GOSUB PRINTLINE
*
TMP = TRIM(LINE)
IF TMP[ONE,ONE] EQ " " THEN TMP = TMP[TWO,99999]
IF TMP[LEN(TMP),ONE] EQ " " THEN TMP = TMP[ONE,LEN(TMP) - ONE]
*
INCL.FLAG = FALSE
BEGIN CASE
CASE LINE[ONE,9] EQ "$INCLUDE "
INCL.FLAG = ONE
CASE LINE[ONE,8] EQ "INCLUDE "
INCL.FLAG = TWO
END CASE
*
!
*
IF INCL.FLAG THEN
*
BEGIN CASE
*
CASE INCL.FLAG EQ ONE
INCL.PROG.ID = FIELD(TMP," ",3)
TMP.INCL.FIL.NAME = FIELD(TMP," ",TWO)
*
CASE TRUE
INCL.PROG.ID = FIELD(TMP," ",TWO)
TMP.INCL.FIL.NAME = FIELD(TMP," ",4)
*
END CASE
*
IF TMP.INCL.FIL.NAME NE INCL.FIL.NAME THEN
OPEN TMP.INCL.FIL.NAME TO INCL.PRG.FILE THEN
INCL.FIL.NAME = TMP.INCL.FIL.NAME
END ELSE
PRINT @(ZERO,5):BELL:TMP.INCL.FIL.NAME:" was not found!!!"
OPEN INCL.FIL.NAME TO INCL.PRG.FILE ELSE STOP
END; * of open
END; * of ibp name change
*
MATREAD INCL.LINES FROM INCL.PRG.FILE,INCL.PROG.ID ELSE MAT INCL.LINES = EMPTY
LOCATE INCL.PROG.ID IN PROG.MAP SETTING TMP.LOC THEN
PROG.MAP<TMP.LOC,-ONE> = TRUE.NUM:SVM:TAB:SVM:NUM:SVM:INCL.NUM
END ELSE
PROG.MAP<-ONE> = INCL.PROG.ID:VM:TRUE.NUM:SVM:TAB:SVM:NUM:SVM:INCL.NUM
END
*
IF INCL.FLAG AND EQUATES THEN
*
LINE = " ["
BEGIN CASE
CASE OPSYS EQ "M"
PRNUM = "(":TRUE.NUM:") ":NUM
CASE TRUE
PRNUM = TRUE.NUM
END CASE
PC = " ["
GOSUB PRINTLINE
INCL.NUM = ONE
*
!
*
LOOP
*
LINE = INCL.LINES(INCL.NUM)
IF INCL.NUM - ONE THEN PCP = "i" ELSE PCP = "I"
PC = PCP 
*
UNTIL LINE EQ EMPTY DO
*
BEGIN CASE
CASE OPSYS EQ "M"
NUM = NUM + ONE
PRNUM = "+":INCL.NUM:"-":NUM
CASE TRUE
PRNUM = "$":INCL.NUM
END CASE
*
GOSUB PRINTLINE
INCL.NUM = INCL.NUM + ONE
*
REPEAT
*
*
IF INCL.NUM GT ONE THEN
LINE = "] "
BEGIN CASE
CASE OPSYS EQ "M"
PRNUM = "(":TRUE.NUM:") ":NUM
CASE TRUE
PRNUM = TRUE.NUM
END CASE
PC = "] "
GOSUB PRINTLINE
END
* NUM = SAVE.NUM
*
END ELSE
IF OPSYS EQ "M" THEN
INCL.NUM = ONE
LOOP WHILE INCL.LINES(INCL.NUM) NE EMPTY DO
NUM = NUM + ONE
INCL.NUM = INCL.NUM + ONE
REPEAT
END
END; * of include and equates
END; * of include
*
PCP = "."
NUM = NUM + ONE
TRUE.NUM = TRUE.NUM + ONE
*
IF TERM.DISP THEN
IF NOT(MOD(NUM,100)) THEN
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,17):"<":INT(NUM/100):">>>[": ELSE PRINT PC:
END
END ELSE
IF NOT(MOD(NUM,1000)) THEN
PRINT; PRINT ITM.NAME:"<":NUM:">>>[":
END ELSE IF NOT(MOD(NUM,100)) THEN
PRINT; PRINT "<":NUM:">>>[":
END
END
*
$INCLUDE IBP SYS.INCL.11.ABORT
*
REPEAT
*
!
*
IF TAB NE ZERO THEN
IF TAB NE ONE OR (TAB EQ ONE AND (LINE.FIRST[ONE,5] NE "*PROG" AND LINE.FIRST[ONE,5] NE "*CODE")) THEN
TAB.ERR = 4
PRINT CLB:BELL:"FATAL ERROR, WRONG AMOUNT OF CODE,  HIT <Enter>: ":; INPUT TMP9:
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
END
END
*
PROG.PAGES(PAGE.NUM + ONE) = TRUE.NUM:VM:TAB:VM:NUM:VM:INCL.NUM:VM:INCL.PROG.ID:VM:INCL.FIL.NAME:VM:"END" 
*
IF INT(PAGE.NUM / TWO) NE PAGE.NUM / TWO THEN
IF NOT(FIRST.PG) THEN
CALL LPT.SUBR.ON(STAT)
PRINT FF:
CALL LPT.SUBR.OFF(STAT)
END
END
*
!
*
MATWRITE PROG.PAGES ON PRG.FILE.DICT,PROG.ID:"@LP"
WRITE WHO:AM:DATE():AM:TIME():AM:OPSYS ON PRG.FILE.DICT,PROG.ID:"@LP@DT"
WRITE TAB.TABLE ON PRG.FILE.DICT,PROG.ID:"@LP@TABLE"
WRITE PROG.MAP  ON PRG.FILE.DICT,PROG.ID:"@LP@MAP"
*
CALL LPT.SUBR.CLOSE(STAT)
*
ITM.NAME = EMPTY
GOTO MAIN
*
!
*
PRINTLINE: * ANALYSE AND PRINT LINE
*
TAB.LEFT = ZERO; TAB.RIGHT = ZERO; LABEL = EMPTY
LOOP WHILE LINE[ONE,ONE] EQ " " DO LINE = LINE[TWO,99999] REPEAT
LOOP WHILE LINE[LEN(LINE),ONE] EQ " " DO
LINE = LINE[ONE,LEN(LINE) - ONE]
REPEAT
*
IF NOT(LINE[ONE,ONE] EQ "!" OR LINE[ONE,ONE] EQ "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
*
!
*
IF TAB.LEFT THEN
*
** TAB.TABLE<5,TAB>   = NUM
** TAB.TABLE<TWO,TAB> = LAST
*
IF TAB - TAB.LEFT LT ZERO THEN
*
READV NEXT.LINE FROM PRG.FILE,PROG.ID,TRUE.NUM + ONE ELSE NEXT.LINE = EMPTY
IF NEXT.LINE EQ EMPTY THEN
PRINT CLB:BELL:"END OF CODE,  HIT <Enter>: ":; * INPUT TMP9:
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
END.OF.PROG = TRUE
TAB.ERR = 5
END ELSE
PRINT CLB:BELL:"FATAL ERROR, WRONG AMOUNT OF CODE,  HIT <Enter>: ":; INPUT TMP9:
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
TAB.ERR = ONE
END; * of next line not blank
TAB = ABS(TAB.LEFT)
*
END ELSE
*
TAB.TABLE<5,TAB - TAB.LEFT + ONE>   = NUM
TAB.TABLE<TWO,TAB - TAB.LEFT + ONE> = FIRST
TAB.TABLE<9,TAB - TAB.LEFT + ONE>   = LAST
*
END; * of tab lt zero
*
***
*
IF TERM.DISP OR TAB.ERR THEN
*
* PRINT @(0,3):PROG.ID
* IF TAB.ERR THEN PRINT CLS:
* IF TAB.ERR AND NOT(TERM.DISP) THEN PRINT; PRINT; PRINT
IF TAB.ERR THEN
IF TERM.DISP THEN
* PRINT CLS:
PRINT @(ZERO,5):"Structure!!!!" "L#20"
END ELSE
PRINT; PRINT; PRINT
END
END
TMP2 = DCOUNT(TAB.TABLE<ONE>,VM)
*
FOR TMP = ONE TO 10
FOR TMP1 = (TAB - TAB.LEFT + ONE) TO TMP2 UNTIL TMP1 GT 7
*
TMP3 = TRUE
IF TMP1 GT ONE THEN
IF (TAB.TABLE<4,TMP1> AND TAB.TABLE<4,TMP1> LT TAB.TABLE<4,TMP1 - ONE>) THEN TMP3 = FALSE
**END ELSE TMP3 = FALSE
END
*
* PRINT "TABLE":TMP:" ":TAB.TABLE<TMP,TMP1>
IF TMP3 THEN
PRINT @((TMP1 - ONE)*10,TMP + 5):TAB.TABLE<TMP,TMP1> "L#10"
END ELSE PRINT BELL:
*
NEXT TMP1
NEXT TMP
IF TERM.DISP THEN PRINT @(ZERO,16):"  NUM:":NUM:"  TAB:":TAB:"     L:"  :TAB.LEFT:"     R:"  :TAB.RIGHT:"     ERR:"  :TAB.ERR
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
*
END; * of term.disp
*
***
*
**IF TAB.TABLE<TWO,TAB - TAB.LEFT> NE TAB.TABLE<3,TAB - TAB.LEFT> THEN
*
LOCATE TAB.TABLE<TWO,TAB - TAB.LEFT + ONE> IN TAB.TABLE<3,TAB - TAB.LEFT + ONE> SETTING WORD.LOC ELSE 
PRINT @(0,22):TAB - TAB.LEFT + ONE:"||||":TAB.TABLE<TWO,TAB - TAB.LEFT + ONE>:"####":TAB.TABLE<3,TAB - TAB.LEFT + ONE>:"<<<<":
PRINT CLB:BELL:"FATAL ERROR, MISMATCH,  HIT <Enter>: ":; * INPUT TMP9:
IF NOT(END.OF.PROG) THEN
TAB.ERR = TWO
INPUT TMP9:
END ELSE PRINT " END.OF.PROG":
*
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
END; * of TABLE ERROR
*
*
TAB = TAB - TAB.LEFT
* TAB.ERR = FALSE
*
END; * of tab.left
*
!
*
INDENT = (TAB - 1)*3*(TAB GT ZERO); P.LINE = PRNUM "R#13":"  "
*
IF LINE[ONE,TWO] EQ "!!" THEN LINE.NUM = 9999; LINE = LINE[TWO,99999]
IF LINE[ONE,ONE] EQ "!" THEN
IF LEN(LINE) GT ONE THEN
TMP = "***  ":LINE[TWO,99999]:"  ":STR("*",MAX.COLS)
TMP = TMP[ONE,MAX.COLS - 20 - INDENT]
END ELSE
TMP = STR("*",MAX.COLS - 20 - INDENT)
END
P.LINE = P.LINE:SPACE(5):TAB.STRING[ONE,INDENT]:TMP
END ELSE
*
IF LEN(LABEL) LT 5 THEN P.LINE = P.LINE:LABEL "L#5":TAB.STRING[ONE,INDENT]:LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE EQ "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE NE EMPTY THEN P.LINE = P.LINE:SPACE(MAX.COLS - 5 - LEN(LABEL)):LINE
END
END; * of not !
*
CALL LPT.SUBR.ON(STAT)
*
LOOP GOSUB HEADER WHILE LEN(P.LINE) GT MAX.COLS DO
*
TC.CN = MAX.COLS
LOOP UNTIL P.LINE[TC.CN,ONE] EQ " " OR TC.CN EQ MAX.COLS - 30 OR TC.CN LE INDENT + 30 DO TC.CN = TC.CN - ONE REPEAT
IF TC.CN EQ MAX.COLS - 30 OR TC.CN LE INDENT + 30 THEN TC.CN = MAX.COLS
PRINT P.LINE[ONE,TC.CN]
IF TC.CN LE INDENT + 30 THEN
P.LINE = P.LINE[TC.CN + ONE,99999]
END ELSE
P.LINE = PRNUM "R#13":"++":SPACE(5):TAB.STRINGA[ONE,INDENT]:P.LINE[TC.CN + ONE,99999]
END
*
REPEAT
*
PRINT P.LINE
*
* TAB = TAB + TAB.RIGHT
IF TAB.RIGHT THEN
TAB = TAB + TAB.RIGHT
IF NOT(TAB.LEFT) THEN
TAB.TABLE<ONE,TAB> = FIRST
TAB.TABLE<TWO,TAB> = EMPTY
TAB.TABLE<4,TAB>   = NUM
* TAB.TABLE<5,TAB>   = ZERO
* TAB.TABLE<8,TAB>   = EMPTY
* TAB.TABLE<9,TAB>   = EMPTY
* TAB.TABLE<10,TAB>   = EMPTY
END ELSE
TAB.TABLE<10,TAB>   = FIRST
TAB.TABLE<8,TAB>    = NUM
TAB.TABLE<TWO,TAB>  = EMPTY
END
TAB.TABLE<3,TAB>   = EXPCT
* TAB.TABLE<4,TAB>   = NUM
* TAB.TABLE<5,TAB>   = ZERO
TAB.TABLE<6,TAB>   = EXPCT.TWO
TAB.TABLE<7,TAB>   = EXPCT.THREE
* TAB.TABLE<8,TAB>   = EMPTY
* TAB.TABLE<9,TAB>   = EMPTY
END
* TAB = TAB + TAB.RIGHT
*
IF TAB.ERR THEN
* PRINT CLB:BELL:"FATAL ERROR IN CODE,  HIT <Enter>: ":; INPUT TMP9:
**IF TERM.DISP THEN
**PRINT @(ZERO,5):CLL:
**END ELSE
PRINT
PRINT
**END
PRINT "!!!!!    STRUCTURAL ERROR (":TAB.ERR:")     !!!!!!!!! "
PRINT P.LINE
PRINT P.TABLE:"<<<<<"
END
***IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
*
CALL LPT.SUBR.OFF(STAT)
*
IF TAB.ERR THEN
PRINT @(ZERO,22):P.LINE
* PRINT CLB:BELL:"FATAL ERROR IN CODE,  HIT <Enter>: ":; INPUT TMP9:
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
END
*
*
IF NOT(TERM.DISP OR TAB.ERR) THEN 
PRINT PC:
END ELSE
IF TAB.LEFT OR TAB.RIGHT OR TAB.ERR THEN
**PRINT @(40,4):PROG.ID
TMP2 = DCOUNT(TAB.TABLE<ONE>,VM)
*
FOR TMP = 1 TO 10
FOR TMP1 = (TAB - TAB.LEFT + ONE) TO TMP2 UNTIL TMP1 GT 7
*
TMP3 = TRUE
IF TMP1 GT 1 THEN
IF (TAB.TABLE<4,TMP1> AND TAB.TABLE<4,TMP1> LT TAB.TABLE<4,TMP1 - ONE>) THEN TMP3 = FALSE
**END ELSE TMP3 = FALSE
END
*
* PRINT "TABLE":TMP:" ":TAB.TABLE<TMP,TMP1>
IF TMP3 THEN
PRINT @((TMP1 - 1)*10,TMP + 5):TAB.TABLE<TMP,TMP1> "L#10"
END ELSE PRINT BELL:
*
NEXT TMP1
NEXT TMP
PRINT @(ZERO,16):"  NUM:":NUM:"  TAB:":TAB:"     L:"  :TAB.LEFT:"     R:"  :TAB.RIGHT:"     ERR:"  :TAB.ERR
*
* @@@
* TMP2 = DCOUNT(TAB.TABLE<ONE>,VM)
* FOR TMP = 1 TO 10
* FOR TMP1 = 1 TO TMP2 UNTIL TMP1 GT 7
* PRINT @(TMP1*10,TMP+3):TAB.TABLE<TMP,TMP1> "L#10"
* NEXT TMP1
* NEXT TMP
* PRINT "  NUM:":NUM:"  TAB:":TAB:"     L:"  :TAB.LEFT:"     R:"  :TAB.RIGHT:"     ERR:"  :TAB.ERR
*
IF TAB.ERR THEN
PRINT CLB:BELL:"FATAL ERROR IN CODE (":FIELD("AMOUNT*MISMATCH*LOOPING*FOUR*AMTOK*","*",TAB.ERR):"),  HIT <Enter>: ":; INPUT TMP9:
END
*
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE PRINT PC:
*
END ELSE PRINT PC:
*
PC = PCP
END
*
*
RETURN
*
!
*
KEYWORD: * IDENTIFY KEY WORDS
*
EXPCT = EMPTY; EXPCT.TWO = EMPTY; EXPCT.THREE = EMPTY
GOSUB FIRSTWORD; * GET FIRST WORD
PC = " ":FIRST[ONE,3]:"|"
*
PCLBL = EMPTY
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),ONE] EQ ":" THEN
PCLBL = CR:LF:FIRST
LABEL = FIRST; LINE = LINE[LEN(FIRST) + TWO,99999]
LOOP WHILE LINE[ONE,ONE] EQ " " DO LINE = LINE[TWO,99999] REPEAT
GOSUB FIRSTWORD
END
*
*
BEGIN CASE
*
CASE FIRST EQ "IF" OR FIRST EQ "LOCATE" OR FIRST[ONE,4] EQ "READ" OR FIRST[ONE,7] EQ "MATREAD" OR FIRST EQ "WRITET" OR FIRST EQ "WEOF" OR FIRST EQ "OPEN"
GOSUB LASTWORD
IF LAST EQ "THEN" THEN TAB.RIGHT = ONE; EXPCT = "END"; EXPCT.TWO = "ELSE"
IF LAST EQ "ELSE" THEN TAB.RIGHT = ONE; EXPCT = "END"; EXPCT.TWO = EMPTY
**IF LAST EQ "THEN" OR LAST EQ "ELSE" THEN TAB.RIGHT = ONE; EXPCT = "END"
*
*
CASE FIRST EQ "LOOP"
GOSUB LASTWORD
**IF LAST NE "REPEAT" THEN TAB.RIGHT = ONE; EXPCT = "REPEAT"
*
IF LAST NE "REPEAT" THEN
TAB.RIGHT = ONE
*
IF LAST EQ "LOOP" THEN
**IF LAST EQ "WHILE" THEN EXPCT.TWO = "REPEAT"
**IF LAST EQ "UNTIL" THEN EXPCT.TWO = "REPEAT"
EXPCT = "WHILE":SVM:"UNTIL"
*XPCT.TWO = EMPTY
EXPCT.THREE = "REPEAT"
*
END ELSE IF LAST EQ "DO" THEN
EXPCT = "REPEAT"
*XPCT.TWO = EMPTY
*XPCT.THREE = EMPTY
*
END ELSE
*ERROR
TAB.ERR = 3
EXPCT = "REPEAT"
*XPCT.TWO = EMPTY
*XPCT.THREE = EMPTY
*
END
*
END; * of not a repeat
*
*
CASE FIRST EQ "WHILE" OR FIRST EQ "UNTIL"
TAB.LEFT = ONE
GOSUB LASTWORD
IF LAST NE "REPEAT" THEN TAB.RIGHT = ONE; EXPCT = "REPEAT"
*
CASE FIRST EQ "FOR"
TC.CN = INDEX(LINE," NEXT ",ONE)
IF NOT(TC.CN) THEN TAB.RIGHT = ONE; EXPCT = "NEXT"
*
CASE FIRST = "BEGIN"
TAB.RIGHT = ONE; EXPCT = "END"; EXPCT.TWO = "CASE"
CASE.FLAG = ONE 
*
CASE FIRST EQ "CASE"
TAB.RIGHT = ONE; EXPCT = "CASE"
IF CASE.FLAG = ONE THEN CASE.FLAG = ZERO ELSE TAB.LEFT = ONE 
*
CASE FIRST = "END" OR FIRST = "END;"
* IF LINE[TC.CN + ONE,4] EQ "CASE" THEN
IF SECOND EQ "CASE" THEN
TAB.LEFT = TWO; RETURN
END
TAB.LEFT = ONE
GOSUB LASTWORD
IF LAST EQ "THEN" OR LAST EQ "ELSE" THEN TAB.RIGHT = ONE; EXPCT = "END"
*
CASE FIRST = "NEXT" OR FIRST = "REPEAT"
TAB.LEFT = ONE 
*
CASE TRUE
IF PCLBL NE EMPTY THEN PC = PCLBL ELSE PC = PCP
*
END CASE
*
*
IF NOT(TAB.RIGHT) AND PCLBL EQ EMPTY THEN PC = PCP
IF TERM.DISP AND LINE.DISP THEN PRINT @(ZERO,18):"++[":CLL:PC: ELSE
* PRINT PC:
END
*
RETURN
*
!
*
FIRSTWORD: * GET FIRST WORD
*
$INCLUDE IBP SYS.INCL.FIRSTWORD
*
RETURN
*
!
*
LASTWORD: * GET LAST WORD
*
$INCLUDE IBP SYS.INCL.LASTWORD
*
RETURN
*
!
*
HEADER: * HEADER
*
LINE.NUM = LINE.NUM + ONE; IF LINE.NUM LT MAX.LINES THEN RETURN
*
MSK = "L#":MAX.COLS - 50
IF (FAST.PRINT) AND PAGE.NUM GE ONE THEN
CALL LPT.SUBR.CLOSE(STAT)
END
IF FAST.FF OR FIRST.PG THEN PRINT FF:
FIRST.PG = FALSE
PAGE.NUM = PAGE.NUM + ONE
PRINT TIMEDATE() "L#25":(SPACE((MAX.COLS / TWO - 25) - LEN(ITM.NAME.LINE) / TWO):ITM.NAME) MSK:("PAGE ":PAGE.NUM) "R#25":CR:LF
*
PROG.PAGES(PAGE.NUM) = TRUE.NUM:VM:TAB:VM:NUM:VM:INCL.NUM:VM:INCL.PROG.ID:VM:INCL.FIL.NAME
*
LINE.NUM = 5
*
RETURN
*
!
*
ERROR.DISP: *
*
CALL SYS.SUBR.ERROR(TEXT,ERR.LN.MIN,ERR.LN.MAX,ERR.LN.HI,ERR.CL,ERR.LN,ERR.LEN,ERR.CLS,ERR.CLB,ERR.HDR,ERR.FMT,ERR.CR,ERR.BELL,ERR.DISP.ONLY,STAT)
*
RETURN
*
*
END
~CLEAR.CHANGES~
*PROGRAM: CLEAR.CHANGES 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       CLEAR CHANGES FILES ON TARGET MACHINE...
* DATE WRITTEN:      04 DEC 86
* DATE RELEASED:     04 DEC 86
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Clear Change Files on Target Machine"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
READ FILE.LIST FROM CNT.FILE,"FILE.LIST" ELSE
PRINT @(0,23):"FILE.LIST not found on CNT -- press <cr> ":CLL:
INPUT RSP:
STOP
END
AC = 1
READ CHANGES.LOG FROM CNT.FILE,"CHANGES.LOG" ELSE CHANGES.LOG = ""
LOOP
FILE.NAME = FILE.LIST<AC>
UNTIL FILE.NAME = "" DO
IF FILE.NAME[1,4] = "ULT." THEN FILE.NAME = FILE.NAME[5,99]
DICT.NAME = ""; IF FILE.NAME[1,5] = "DICT." THEN DICT.NAME = "DICT "; FILE.NAME = FILE.NAME[6,99]
DISP.NAME = DICT.NAME:FILE.NAME
ERROR.PROGS = ""; SYNTAX.PROGS = ""
LOCATE DISP.NAME IN CHANGES.LOG<1> BY "AL" SETTING LOG.VC THEN
LOG.SC = 1
LOOP PROG.NAME = CHANGES.LOG<2,LOG.VC,LOG.SC> UNTIL PROG.NAME = "" DO
IF CHANGES.LOG<3,LOG.VC,LOG.SC> THEN ERROR.PROGS = ERROR.PROGS:",":PROG.NAME
IF CHANGES.LOG<4,LOG.VC,LOG.SC> THEN SYNTAX.PROGS = SYNTAX.PROGS:",":PROG.NAME
LOG.SC = LOG.SC+1
REPEAT
END
IF DICT.NAME = "" THEN DISP.NAME = "DATA ":DISP.NAME
DISP.NAME = DISP.NAME:".CHANGES"
PRINT @(0,3):CLS:DISP.NAME:"......"; PRINT; BYPASS = ""
IF ERROR.PROGS # "" OR SYNTAX.PROGS # "" THEN
ERROR.PROGS = ERROR.PROGS[2,9999]; SYNTAX.PROGS = SYNTAX.PROGS[2,9999]
IF ERROR.PROGS # "" THEN
PRINT "      Items with transmission errors:"
PRINT "            ":ERROR.PROGS
PRINT
END
IF SYNTAX.PROGS # "" THEN
PRINT "      Items with syntax errors:"
PRINT "            ":SYNTAX.PROGS:
END
LOOP
PRINT @(0,23):CLL:"Clear the change file anyway? ":; INPUT RSP:; IF RSP = "KILL" THEN STOP
IF RSP = "NO" THEN RSP = "N"
IF RSP = "YES" THEN RSP = "Y"
UNTIL RSP = "N" OR RSP = "Y" DO
PRINT BELL:
REPEAT
IF RSP = "N" THEN BYPASS = 1
END
IF NOT(BYPASS) THEN
PRINT @(40,3):RVB:"Clearing....":RVE:
EXECUTE "CLEAR-FILE ":DISP.NAME
END
AC = AC+1
REPEAT
STOP
!
END
~CODE.COMPILER~
*PROGRAM:           CODE.COMPILER
!
$INCLUDE DH.IBP SYS.COMMON
TERMINAL = "?"
$INCLUDE DH.IBP SYS.STANDARD.FUNCTIONS
*
$INCLUDE DH.IBP SYS.INCL.OFF.RSP
$INCLUDE DH.IBP SYS.INCL.TCL.RSP
$INCLUDE DH.IBP SYS.INCL.END.RSP
*
$INCLUDE DH.IBP SYS.INCL.SYS.RSP
$INCLUDE DH.IBP SYS.INCL.SYS.RSP.SYNONYM
*
SYS.PROG = "CODE.COMPILER"
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = "SYS"
SYS.ITEM = ""
SYS.RUN.ATTR = 12
SYS.RUN.MESSAGE = "Compile"
SYS.RUN.CODE = "COMPILE"
*
!
SYS.SLOC<1>= "SYS"
MAT STRUCT=''
OPEN "DH.SYS" TO SY.FILE ELSE
ERROR.TEXT = "No SYS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC<1>= "MENUS"
OPEN "DH.MENUS" TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC<1>= "MD"
OPEN "MD" TO MD.FILE ELSE
ERROR.TEXT = "No MD file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "READ"
*
*
USER.NAME = ""
$INCLUDE DH.IBP SYS.USER.NAME
MENU.NAME = ""; MENU.NUM = 1; MENU.APPL = "LOGON"; MENU.SUB.APPL = ""
MENU.GRP.APPL = ""; MENU.CONTROL = ""; PRMPTING = ""; TOPIC.KEY = ""
MAT STRUCT = ""
PORTD = ""; STRUCT(1) = 0; STRUCT(2) = ""; WAIT.FLAG = 1
DEFAULT.BP = "BP"
DEFAULT.ITEM = "NOTES"
OLD.FILE = ""; OLD.ITEM = ""
FILE.NAME = ""; FILE.ITEM = ""; SYS.RUN.TYPE = ""
!
USER.ABORT = ""
SYS.ABORT = ""
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
*
*
*
*INPUT.NEXT: *
LOOP
SYS.LOCT = "MAIN"
SYS.SLOC<1>= "INIT"
*
GOSUB GET.NEXT
*
IF NOT(SYS.ABORT OR USER.ABORT) THEN
EXEC.VERB = "COMPILE"
EXEC.PARAMS = ""
EXEC.RESULTS = ""
SYS.SLOC<1>= "EXECUTE"
EXECUTE EXEC.VERB:" ":FILE.NAME:" ":FILE.ITEM:" (M,E)", //IN. < EXEC.PARAMS, //OUT. > EXEC.RESULTS
PRINT
*X OPTION AND COPY ROUTINE CAN BE USED FOR APPL XREF
DISPL1.CN = INDEX(EXEC.RESULTS,"SUCCESSFUL COMPILE",1)
*IF NOT(DISPL1.CN) THEN DISPL1.CN = INDEX(EXEC.RESULTS,"COMPILE COMPLETED",1) = 0 
IF NOT(DISPL1.CN) THEN DISPL1.CN = INDEX(EXEC.RESULTS,"Successful compile",1)
*
GOSUB GET.COMPL
*
*
*PRINT "[=| "
*PRINT CLS:"[=| "
PRINT "[=| "
PRINT "[=| "
PRINT "[=| "
PRINT "[=| "
CLS.LO = 10
CLS.HI = 19
GOSUB SYS.CLEAR.PAGE.MID
PRINT @(0,5):"[=| "
IF DISPL1.CN EQ 0 THEN
WRITE EXEC.RESULTS ON INP.FILE.DICT,"@SYS@STAT@":SYS.RUN.CODE:"@":FILE.ITEM
EXECUTE "COPY DICT DEV @SYS@STAT@COMPILE@":FILE.ITEM:" (P)"
EXECUTE "COPY DICT DEV @SYS@STAT@COMPILE@":FILE.ITEM:" (T,N)"
ERROR.TEXT = "COMPILE NOT COMPLETED SEE @SYS@STAT@COMPILE@":FILE.ITEM
ERROR.CODE = "19001"
GOSUB ERROR.CONTROL
*PRINT @(0,5):CLS:"[=| ":
CLS.LO = 5
CLS.HI = 19
GOSUB SYS.CLEAR.PAGE.MID
PRINT @(0,5):"[=| ":
END ELSE
PRINT "[=| Delete error log item."
PRINT "[=| "
PRINT "[=| ":
DELETE INP.FILE.DICT,"@SYS@STAT@COMPILE@":FILE.ITEM
WRITE EXEC.RESULTS ON INP.FILE.DICT,"@SYS@MSTAT@":FILE.ITEM
END
*
*
OLD.BP = FILE.NAME
OLD.ITEM = FILE.ITEM
END; *# OF SYS.ABORT OR USER.ABORT
WHILE NOT(SYS.ABORT OR USER.ABORT) DO REPEAT
*
*STOP
GOTO END.OF.PROGRAM
*
$INCLUDE DH.IBP CODE.SUB.NEXT
*
$INCLUDE DH.IBP CODE.SUB.COMPL
*
$INCLUDE DH.IBP SYS.ERROR.STRUCT
*
!
*
END.OF.PROGRAM: * Normal termination
*
*
END
~CODE.CONVERT.TLD~
*PROGRAM: CODE.CONVERT.TLD
* PROGRAM:           CODE.CONVERT.TLD
!
* $INCLUDE IBP SYS.COMMON
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "SYS" TO SYS.FILE ELSE PRINT "CANT OPEN SYS"; STOP
*
READ TERM.DISP FROM SYS.FILE,"TERMINAL.DISPLAY" ELSE TERM.DISP = TRUE
*
*
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
*
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
*
SYS.PROG = "CODE.CONVERT.TLD"
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = "SYS"
SYS.ITEM = ""
SYS.RUN.ATTR = 61
SYS.RUN.MESSAGE = "TLD conversion"
SYS.RUN.CODE = "CODE.CONVERT.TLD"
*
!
SYS.SLOC = "SYS"
MAT STRUCT=''
OPEN "DH.SYS" TO SY.FILE ELSE
ERROR.TEXT = "No SYS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC = "MENUS"
OPEN "DH.MENUS" TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC = "MD"
OPEN "MD" TO MD.FILE ELSE
ERROR.TEXT = "No MD file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "READ"
*
*
USER.NAME = ""
$INCLUDE IBP SYS.USER.NAME
MENU.NAME = ""; MENU.NUM = 1; MENU.APPL = "LOGON"; MENU.SUB.APPL = ""
MENU.GRP.APPL = ""; MENU.CONTROL = ""; PRMPTING = ""; TOPIC.KEY = ""
MAT STRUCT = ""
PORTD = ""; STRUCT(1) = 0; STRUCT(2) = ""; WAIT.FLAG = 1
ITEM.CN = 0
DEFAULT.BP = "BP"
DEFAULT.ITEM = "NOTES"
OLD.FILE = ""; OLD.ITEM = ""
FILE.NAME = ""; FILE.ITEM = ""; SYS.RUN.TYPE = ""
!
USER.ABORT = ""
SYS.ABORT = ""
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
*
*
*
INPUT.NEXT: *
SYS.LOCT = "MAIN"
SYS.SLOC = "INIT"
SYS.ABORT = ""
USER.ABORT = ""
*
GOSUB GET.NEXT
*
OPEN FILE.NAME TO TLD.FILE ELSE SYS.ABORT = 1
ITEM.CN = ITEM.CN + 1
IF NOT(SYS.ABORT) THEN
*
READV ITEM FROM TLD.FILE,FILE.ITEM,1 ELSE SYS.ABORT = 1
IF NOT(SYS.ABORT) THEN
IF SYS.RUN.TYPE NE 2 OR (SYS.RUN.TYPE EQ 2 AND ITEM.CN LE 1) THEN
RSP = ""
ITEM = ""
DEL.LIST = ""
ERROR.CODE = "190021420"
ERROR.TEXT = "Delete overflow items? "
GOSUB ERROR.CONTROL
IF INDEX(YES,"*":ERROR.RSP:"*",1) THEN DEL.FLAG = 1 ELSE DEL.FLAG = ''
ERROR.CODE = "190021520"
ERROR.TEXT = "Convert from AUTO-LF? "
GOSUB ERROR.CONTROL
IF NOT(INDEX(YES,"*":ERROR.RSP:"*",1)) THEN AUTOLF.FLAG = 0 ELSE
AUTOLF.FLAG = 1
ERROR.CODE = "190021620"
ERROR.TEXT = "Prompt for each case? "
GOSUB ERROR.CONTROL
IF INDEX(NO,"*":ERROR.RSP:"*",1) THEN RSP = "GO" ELSE RSP = ""
END
END
NEXT.ITEM.ID = FILE.ITEM
ITEM.ID = ''
TLD.CONT = 1
HPL.ERR = ""; HPL.ERR.TXT = ""; STATUS = ""; PK.CNTRL = ""; REDIR = ""
*
PRINT
PRINT "#---####"
TLD.AM = DCOUNT(ITEM,AM)
TLD.AMC = FILE.ITEM[LEN(FILE.ITEM),1]
TCN = SEQ(TLD.AMC)
LOOP
GOSUB 109; * GET NEXT KEY
READ NEW.ITEM FROM TLD.FILE,ITEM.ID ELSE TLD.CONT = 0
WHILE TLD.CONT DO
TLD.AM = DCOUNT(NEW.ITEM,AM)
TLD.AMC = CHAR(TCN)
PRINT TLD.AMC:" - ":TLD.AM
ITEM = ITEM:AM:NEW.ITEM
NEW.ITEM = ""
IF DEL.FLAG THEN DEL.LIST<-1> = ITEM.ID
NEXT.ITEM.ID = ""
REPEAT
*
PRINT
PRINT
PRINT "Completed merges for overflow items . . . "
PRINT
PRINT
MAX.CN = DCOUNT(ITEM,AM)
PRINT FILE.ITEM:" has ":MAX.CN:" lines."
PRINT
*
IF AUTOLF.FLAG THEN
PRINT "Beginning AUTOLF conversions . . . "
PRINT
CN1 = 50
*
CN = 1
PRINT CN "R#4":" ":
FOR CN = 1 TO MAX.CN UNTIL USER.ABORT OR SYS.ABORT
TEMP1 = LEN(ITEM<CN>)
IF INT(TEMP1/79) * 79 EQ TEMP1 AND TEMP1 THEN
TEMP = ITEM<CN>
IF RSP NE "GO" THEN
PRINT
PRINT
PRINT
PRINT CN 'R#3':'*"""""""""""""""""""'
PRINT CN "R#3":"*":TEMP[1,70]
PRINT CN "R#3":"*":SPACE(15):TEMP[71,99]:RVB:"][":RVE:ITEM<CN+1>
PRINT CN "R#3":'*"""""""""""""""""""'
PRINT CN "R#3":"*":TEMP
PRINT CN "R#3":"*":ITEM<CN+1>
PRINT CN 'R#3':'*"""""""""""""""""""'
PRINT CN+2 "R#3":" ":ITEM<CN+2>
PRINT CN+3 "R#3":" ":ITEM<CN+3>
PRINT CN+4 "R#3":" ":ITEM<CN+4>
PRINT CN+5 "R#3":" ":ITEM<CN+5>
PRINT
PRINT "Merge? ":
END
IF RSP NE "GO" AND RSP NE "GO DISP" THEN INPUT RSP
IF INDEX(YES,"*":RSP:"*",1) OR RSP = "GO" OR RSP = "GO DISP" THEN
ITEM<CN> = ITEM<CN>:ITEM<CN+1>
DEL ITEM<CN+1,0,0>
IF RSP NE "GO" THEN
PRINT
PRINT CN "R#3":"*":ITEM<CN>
PRINT CN+1 "R#3":" ":ITEM<CN+1>
PRINT CN+2 "R#3":" ":ITEM<CN+2>
PRINT CN+3 "R#3":" ":ITEM<CN+3>
PRINT CN+4 "R#3":" ":ITEM<CN+4>
PRINT
PRINT
PRINT CN "R#4":" ":
END
PRINT "j":
CN = CN - 1
CN1 = CN1 + 1
END ELSE
IF RSP NE "GO" THEN PRINT CN "R#4":" ":
PRINT "s":
END
END ELSE
PRINT "*":
END; * of LEN = 79
CN1 = CN1 - 1
IF CN1 < 1 THEN PRINT; PRINT CN "R#4":" ":; CN1 = 50
$INCLUDE DH.BP SYS.INCL.11.ABORT
NEXT CN
*
END; * of AUTOLF.FLAG
*
IF NOT(SYS.ABORT) AND NOT(USER.ABORT) THEN
PRINT
PRINT
WRITE ITEM ON TLD.FILE,FILE.ITEM
PRINT FILE.ITEM:" updated."
PRINT
LOOP WHILE LEN(DEL.LIST) DO
DEL.ITEM = DEL.LIST<1>
DEL DEL.LIST<1,0,0>
IF DEL.ITEM NE FILE.ITEM THEN
DELETE TLD.FILE,DEL.ITEM
PRINT DEL.ITEM:" deleted."
END
REPEAT
PRINT
PRINT
END
PRINT BELL:
RQM; RQM; RQM
*
END; * of SYS.ABORT
END; * of SYS.ABORT
*EXEC.VERB = "ED"
*EXEC.PARAMS = "P1 .U10":SVM:"L20":SVM:".U10":SVM:"?":AM:"P2 A":SVM:"P1":AM:"P1":AM:"PD":AM:"?"
*EXEC.RESULTS = ""
*SYS.SLOC = "EXECUTE"
*EXECUTE EXEC.VERB:" ":FILE.NAME:" ":FILE.ITEM, //IN. < EXEC.PARAMS
*
*
GOSUB GET.COMPL
*
*
OLD.BP = FILE.NAME
OLD.ITEM = FILE.ITEM
GOTO INPUT.NEXT
*
STOP
*
$INCLUDE IBP CODE.SUB.NEXT
*
$INCLUDE IBP CODE.SUB.COMPL
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*@@@@END
     *#
     *#
109  *#  INCREMENT OR SET ITEM.ID
     *# 
     *# 
   IF NEXT.ITEM.ID = "" THEN
      IF ITEM.ID NE "" THEN
         LENGTH.ID = LEN(ITEM.ID)
         TC = ITEM.ID[LENGTH.ID,1]
         TCN = SEQ(TC) + 1
         IF TCN < 49 THEN
            ITEM.ID = ITEM.ID:"0"
         END ELSE IF TCN > 57 AND TCN < 65 THEN
            ITEM.ID = ITEM.ID[1,LENGTH.ID-1]:"A"
         END ELSE IF TCN > 90 THEN
            ITEM.ID = ITEM.ID[1,LENGTH.ID-1]:"Z1"
         END ELSE
            ITEM.ID = ITEM.ID[1,LENGTH.ID-1]:CHAR(TCN)
         END
      END ELSE
         ITEM.ID = "1"
      END
   END ELSE
      ITEM.ID = NEXT.ITEM.ID
   END
   NEXT.ITEM.ID = ""
   FIRST = FALSE
RETURN
     *# 
     *# 
9000 *#  ERROR HANDLING
     *#
CALL HARMONY.ERROR(HPL.ERR,HPL.ERR.TXT,STATUS,PK.CNTRL,REDIR)
*
RETURN
     *# 
     *# 
9100 *#  NON-SCREEL LOGGING TO ERROR FILE
     *#
CALL HARMONY.ERROR(HPL.ERR,HPL.ERR.TXT,STATUS,"4",REDIR)
*
RETURN
     *#
     *#
9900 *#  END OF ROUTINE
RETURN
*
END
~CODE.ED~
*PROGRAM:  CODE.ED
*#
$INCLUDE DH.IBP SYS.COMMON
TERMINAL = "?"
$INCLUDE DH.IBP SYS.STANDARD.FUNCTIONS
*#
$INCLUDE DH.IBP SYS.INCL.OFF.RSP
$INCLUDE DH.IBP SYS.INCL.TCL.RSP
$INCLUDE DH.IBP SYS.INCL.END.RSP
*#
$INCLUDE DH.IBP SYS.INCL.SYS.RSP
$INCLUDE DH.IBP SYS.INCL.SYS.RSP.SYNONYM
*#
SYS.PROG = "CODE.ED"
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = "SYS"
SYS.ITEM = ""
SYS.RUN.ATTR = 11
SYS.RUN.MESSAGE = "Edit"
SYS.RUN.CODE = "CODE.ED"
PRESTORE = "STD"
*#
!
SYS.SLOC = "SYS"
MAT STRUCT=''
OPEN "DH.SYS" TO SY.FILE ELSE
ERROR.TEXT = "[=| No SYS file"
ERROR.CODE = "21111"
GOSUB ERROR.CONTROL
END
*#
SYS.SLOC = "MENUS"
OPEN "DH.MENUS" TO MU.FILE ELSE
ERROR.TEXT = "[=| No MENUS file"
ERROR.CODE = "21111"
GOSUB ERROR.CONTROL
END
*#
SYS.SLOC = "MD"
OPEN "MD" TO MD.FILE ELSE
ERROR.TEXT = "[=| No MD file"
ERROR.CODE = "21111"
GOSUB ERROR.CONTROL
END
*#
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "READ"
*#
*#
USER.NAME = ""
$INCLUDE DH.IBP SYS.USER.NAME
MENU.NAME = ""; MENU.NUM = 1; MENU.APPL = "LOGON"; MENU.SUB.APPL = ""
MENU.GRP.APPL = ""; MENU.CONTROL = ""; PRMPTING = ""; TOPIC.KEY = ""
MAT STRUCT = ""
PORTD = ""; STRUCT(1) = 0; STRUCT(2) = ""; WAIT.FLAG = 1
DEFAULT.BP = "BP"
DEFAULT.ITEM = "NOTES"
OLD.FILE = ""; OLD.ITEM = ""
FILE.NAME = ""; FILE.ITEM = ""; SYS.RUN.TYPE = ""
!
USER.ABORT = ""
SYS.ABORT = ""
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
*
*
*
*#INPUT.NEXT: *
LOOP
*#INPUT.NEXT    
SYS.LOCT = "MAIN"
SYS.SLOC = "INIT"
*
GOSUB GET.NEXT
*
IF NOT(SYS.ABORT OR USER.ABORT) THEN
*EXEC.PARAMS = "P1 .U10":SVM:"L20":SVM:".U10":SVM:"?":AM:"P2 A":SVM:"P1":AM:"P1":AM:"PD":AM:"?"
EXEC.PARAMS = ''
*
EXEC.PARAMS<2> = "P1 .U10":SVM:"L20":SVM:".U10":SVM:"?"
EXEC.PARAMS<3> = "P2 .N20":SVM:"P1"
EXEC.PARAMS<4> = "P3 .U20":SVM:"P1"
EXEC.PARAMS<5> = "P4 A":SVM:"P1"
*EXEC.PARAMS = EXEC.PARAMS
EXEC.PARAMS<6> = "P5 F":SVM:"L9999/OPEN/":SVM:"L9999/READ/":SVM
EXEC.PARAMS<6> = EXEC.PARAMS<6>:"L9999/WRITE/":SVM:"L9999/DELETE/"
EXEC.PARAMS<7> = "P6 R/*/*#/"
EXEC.PARAMS<8> = "P7 R/*#//"
EXEC.PARAMS<9> = "P8 R//*#/"
EXEC.PARAMS<10> = "P9 S?"
EXEC.RESULTS = ""
RQM; *#
*IF SYSTEM(11) OR SYS.RUN.TYPE EQ 1 THEN
LOOP
IF SYSTEM(11) OR SYS.RUN.TYPE EQ 1 THEN
CONT = ''
**************12345678901234567890*
ERROR.CODE = "290020815020"
ERROR.TEXT = ''
*ERROR.TEXT = "[=| Enter the name of the prestore item to use: "
GOSUB ERROR.CONTROL
PRESTORE = ERROR.RSP
IF PRESTORE = "" THEN PRESTORE = "STD"
END ELSE ERROR.RSP = PRESTORE
*PRINT @(0,6):CLL:"[=| File: ":FILE.NAME:
*PRINT @(0,7):CLL:"[=| Item: ":FILE.ITEM:
PRINT @(0,8):CLL:"[=| Prestore: ":PRESTORE:
PRINT @(0,9):CLL:"[=| Started -   Date: ":OCONV(START.DATE,"D2"):
PRINT "  Time: ":OCONV(START.TIME,"MT"):
PRINT "  Required: ":OCONV(BP.RUNS<1,1,3>,"MTS")
PRINT "[=| ":
*
PRINT
*IF ERROR.RSP NE "" THEN
IF PRESTORE[1,5] EQ "EDIT " OR PRESTORE[1,5] EQ "EDIT " THEN
EXEC.VERB = "EDIT SYS @UTILS@ED@":STRUCT(2):"@PRESTORE@":PRESTORE[6,999]
EXEC.PARAMS = EXEC.PARAMS:AM:"P1":AM:"PD":AM:"?"
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS
CONT = 1
END ELSE 
READ TEMP FROM SY.FILE,"@UTILS@ED@":STRUCT(2):"@PRESTORE@":PRESTORE THEN
IF TEMP NE '' THEN
PRINT "[=| "
PRINT "[=| "
PRINT "[=| ":TEMP<1>
PRINT "[=| ":STR("*",30)
LOOP WHILE LEN(TEMP) DO
TEMP1 = TEMP<1>
PRINT "[=| ":TEMP1
IF TEMP1[1,1] NE "*" THEN
IF TEMP1[1,1] EQ "P" AND TEMP1[3,1] EQ " " AND NUM(TEMP1[2,1]) THEN
TEMP2 = TEMP1[2,1]
IF NUM(TEMP2) THEN
EXEC.PARAMS<TEMP2+1> = TEMP1
END ELSE EXEC.PARAMS<-1> = TEMP1
END ELSE
*EXEC.PARAMS = EXEC.PARAMS:AM:TEMP1
EXEC.PARAMS<-1> = TEMP1
END
END
DEL TEMP<1,0,0>
REPEAT
PRINT "[=| ":STR("*",30)
END ELSE
PRINT BELL:"[=| PRESTORE IS EMPTY!!"
RQM; RQM
END; *# OF TEMP NE ''
END ELSE
PRINT
PRINT
PRINT BELL:ERROR.RSP:" NOT on file!!!"
RQM; RQM
CONT = 1
END
END
*END
WHILE CONT DO PRINT "[=| ":STR("-",30) REPEAT
*END
*EXEC.PARAMS = EXEC.PARAMS:AM:"L5":AM:"?"
EXEC.PARAMS<-1> = "L5"
EXEC.PARAMS<-1> = "?"
SYS.SLOC = "EXECUTE"
EXEC.VERB = "ED ":FILE.NAME:" ":FILE.ITEM
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS
*
*
GOSUB GET.COMPL
*
*
OLD.BP = FILE.NAME
OLD.ITEM = FILE.ITEM
END; *# OF NOT(SYS.ABORT OR USER.ABORT)
WHILE NOT(SYS.ABORT OR USER.ABORT) DO REPEAT
*
GOTO END.OF.PROGRAM
*#
*#
*
$INCLUDE DH.IBP CODE.SUB.NEXT
*
$INCLUDE DH.IBP CODE.SUB.COMPL
*
$INCLUDE DH.IBP SYS.ERROR.STRUCT
*
!
*
END.OF.PROGRAM: * Normal End
*
*
END
~CODE.LOG.UTILS~
*PROGRAM:           CODE.LOG.UTILS
* AUTHOR :           DAVID HORSMAN
* DATE   :           08 MAY 87
!
$INCLUDE DH.BP SYS.COMMON
TERMINAL = "?"
$INCLUDE DH.BP SYS.STANDARD.FUNCTIONS
*
$INCLUDE DH.IBP SYS.INCL.OFF.RSP
$INCLUDE DH.IBP SYS.INCL.TCL.RSP
$INCLUDE DH.IBP SYS.INCL.END.RSP
*
$INCLUDE DH.IBP SYS.INCL.SYS.RSP
$INCLUDE DH.IBP SYS.INCL.SYS.RSP.SYNONYM
*
SYS.PROG = "CODE.LOG.UTILS"
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = "SYS"
SYS.ITEM = ""
*
!
SYS.SLOC = "SYS"
MAT STRUCT=''
OPEN "DH.SYS" TO SY.FILE ELSE
ERROR.TEXT = "No SYS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC = "MENUS"
OPEN "DH.MENUS" TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC = "MD"
OPEN "MD" TO MD.FILE ELSE
ERROR.TEXT = "No MD file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "READ"
*
*
USER.NAME = ""
$INCLUDE DH.BP SYS.USER.NAME
MENU.NAME = ""
MENU.NUM = 1
MENU.APPL = "LOGON"
MENU.SUB.APPL = ""
MENU.GRP.APPL = ""
MENU.CONTROL = ""
PRMPTING = ""
TOPIC.KEY = ""
MAT STRUCT = ""
PORTD = ""
STRUCT(1) = 0
STRUCT(2) = ""
WAIT.FLAG = 1
DEFAULT.BP = "BP"
DEFAULT.ITEM = "NOTES"
OLD.ITEM = ""
!
USER.ABORT = ""
SYS.ABORT = ""
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
*
*
ERROR.TEXT = "Enter run type (1 or 2): "
*ERROR.CODE = "19002"
*GOSUB ERROR.CONTROL
PRINT @(0,21):CLS:@(0,22):ERROR.TEXT:; INPUT ERROR.RSP:
SYS.RUN.TYPE = ERROR.RSP
IF NOT(NUM(SYS.RUN.TYPE)) THEN SYS.RUN.TYPE = 2
IF SYS.RUN.TYPE EQ 0 THEN SYS.RUN.TYPE = 3
IF SYS.RUN.TYPE NE 2 THEN
*SYS.RUN.TYPE = 1
SYS.DEFAULT.FLAG = 1
READ SYS.DEFAULTS FROM MD.FILE,"@SYS@DEFAULTS@CODE.ED@":USER.NAME:"@":PORT ELSE
SYS.DEFAULTS = AM:AM:AM:AM:"BP":AM:"NOTES"
END
DEFAULT.BP = SYS.DEFAULTS<5>
DEFAULT.ITEM = SYS.DEFAULTS<6>
END ELSE
SYS.DEFAULT.FLAG = 0
END
*
CODE.FILE = ""; CODE.PROG = ""
PRINT @(0,5):CLS:
PRINT @(0,10):"Enter file name: ":
IF SYS.RUN.TYPE = 2 THEN
FOR TEMP = 1 TO WAIT.FLAG + 2 UNTIL SYSTEM(11)
RQM
NEXT TEMP
END
IF SYSTEM(11) OR SYS.RUN.TYPE <> 2 THEN
INPUT CODE.FILE:
IF NOT(LEN(CODE.FILE)) THEN CODE.FILE = DEFAULT.BP
END ELSE CODE.FILE = DEFAULT.BP
*
INPUT.NEXT: *
*
CODE.PROG = ""
PRINT @(0,5):CLS:
PRINT @(0,10):"Enter file name: ":CODE.FILE:
READNEXT CODE.PROG ELSE
PRINT @(0,12):"Enter item name: ":
FOR TEMP = 1 TO WAIT.FLAG + 2 UNTIL SYSTEM(11)
RQM
NEXT TEMP
IF SYSTEM(11) OR SYS.RUN.TYPE <> 2 THEN
INPUT CODE.PROG:
IF NOT(LEN(CODE.PROG)) THEN CODE.PROG = DEFAULT.ITEM
END ELSE CODE.PROG = DEFAULT.ITEM
END
PRINT @(0,12):CLL:"Enter item name: ":CODE.PROG:
IF CODE.PROG EQ OLD.ITEM THEN CODE.PROG = ""
*
IF LEN(CODE.PROG) = 0 ! LEN(CODE.FILE) = 0 THEN STOP
*
IF SYS.RUN.TYPE EQ 3 THEN
SYS.DEFAULTS<5> = CODE.FILE
SYS.DEFAULTS<6> = CODE.PROG
DEFAULT.BP = CODE.FILE
DEFAULT.ITEM = CODE.PROG
WRITE SYS.DEFAULTS ON MD.FILE,"@SYS@DEFAULTS@CODE.ED@":USER.NAME:"@":PORT
END
*
CHECK.BP = 0
SYS.SLOC = CODE.FILE
OPEN CODE.FILE TO BP.FILE THEN CHECK.BP = 1 ELSE
CHECK.BP = 0
ERROR.TEXT = "No ":CODE.FILE:" file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
OPEN "DICT DEV" TO BP.FILE.DICT THEN CHECK.BP.DICT = 1 ELSE
CHECK.BP.DICT = 0
ERROR.TEXT = "No DICTionary for DEV file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.LOCT = "MAIN"
SYS.LOCT = "MAIN"
SYS.SLOC = "INIT"
PRINT @(0,5):CLS:
START.DATE = DATE()
START.TIME = TIME()
LN = 99
CN = 1
PG = 0
BP.RUNS = ""
READV TEMP FROM BP.FILE.DICT,"@SYS@PSTAT@":CODE.PROG,11 ELSE TEMP = ""
READV TEMP0 FROM BP.FILE.DICT,"@SYS@PSTAT@":CODE.PROG,12 ELSE TEMP0 = ""
READV TEMP1 FROM BP.FILE.DICT,"@SYS@PSTAT@":CODE.PROG,10 ELSE TEMP1 = ""
*#TEMP = BP.RUNS<11>
*#TEMP0 = BP.RUNS<12>
TEMP9 = 2
ERROR.RSP = ''
LOOP
PG = PG + 1
IF LN NE 99 THEN
PRINT @(0,21):CLL:'Enter <CR> . . .':
INPUT ERROR.RSP:
END
PRINT @(0,5):CLS:"File: ":CODE.FILE:@(60):"Page: ":PG
PRINT @(0,6):CLL:"Item: ":CODE.PROG:@(60):"Func: ":RVB:
IF NOT(TEMP9) THEN PRINT "Log lists":RVE ELSE
IF TEMP9 = 1 THEN PRINT "Compiles":RVE
IF TEMP9 = 2 THEN PRINT "Edits":RVE
END
PRINT @(0,7):CLL:"Started -   Date: ":OCONV(START.DATE,"D2"):
PRINT "  Time: ":OCONV(START.TIME,"MT"):
PRINT "  Required: ":OCONV(BP.RUNS<1,1,3>,"MTS")
PRINT CLL
PRINT CLL
LN = 9
LOOP WHILE LN < 20 AND ERROR.RSP <> "END" AND ERROR.RSP NE "end"  AND LEN(TEMP) DO
TEMP7 = TEMP<1,1>
TEMP = DELETE(TEMP,1,1,0)
IF NOT(LEN(TEMP)) AND LEN(TEMP0) THEN
TEMP = TEMP0
TEMP0 = ''
IF TEMP9 = 2 THEN TEMP9 = 1 ELSE TEMP9 = ''
LN = 90
END ELSE IF NOT(LEN(TEMP)) AND LEN(TEMP1) THEN
TEMP = TEMP1
TEMP1 = ''
TEMP9 = ''
LN = 90
END
IF LEN(TEMP7) THEN
TEMP3 = TEMP7<1,1,3>
TEMP2 = 0
LOOP WHILE TEMP3 > 86400 DO
TEMP2 = TEMP2 + 1
TEMP3 = TEMP3 - 86400
REPEAT
IF TEMP7<1,1,4> = USER.NAME THEN PRINT RVB:"*":RVE: ELSE PRINT " ":
PRINT RVB:CN "R#3":RVE:OCONV(TEMP7<1,1,1>,"D2"):" ":OCONV(TEMP7<1,1,2>,"MTS"):"  ":TEMP2 "R#3":" ":OCONV(TEMP3,"MTS"):"  ":TEMP7<1,1,4>:
IF TEMP7<1,1,4> = USER.NAME THEN PRINT RVB:"*":RVE ELSE PRINT
CN = CN + 1
LN = LN + 1
IF LN GE 90 THEN CN = 1
*
END
REPEAT
WHILE ERROR.RSP <> "END" AND ERROR.RSP NE "end"  AND LEN(TEMP) DO REPEAT
*
*
*
*
*PRINT
*PRINT;* PRINT;* PRINT
*
*#EXEC.VERB = "ED"
*#CODE.FILE = CODE.FILE
*#CODE.PROG = CODE.PROG
*#EXEC.PARAMS = "P1 .U10|L20|.U10|?":AM:"P2 A|P1":AM:"P1":AM:"PD":AM:"?"
EXEC.RESULTS = ""
*#SYS.SLOC = "EXECUTE"
*#EXECUTE EXEC.VERB:" ":CODE.FILE:" ":CODE.PROG, //IN. < EXEC.PARAMS
*#*
*
SYS.SLOC = "ANALYSIS"
GOSUB DISPLAY.ELP.TIME
ERROR.CODE = ""
EXEC.RESULTS = DELETE(EXEC.RESULTS,1)
EXEC.RESULTS = EXEC.RESULTS:OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MTS"):" ":USER.NAME:"  Log Listing completed"
ERROR.TEXT = ""
DISPL.CN = 0
LOOP
DISPL.CN = DISPL.CN + 1
ERROR.TEXT1 = EXEC.RESULTS<1>
ERROR.TEXT2 = EXEC.RESULTS<2>:EXEC.RESULTS<3>:EXEC.RESULTS<4>:EXEC.RESULTS<5>
WHILE LEN(EXEC.RESULTS) # 0 DO
IF LEN(ERROR.TEXT1) > 1 THEN
IF DISPL.CN # 1 THEN ERROR.TEXT = ERROR.TEXT:AM; ERROR.CODE = ERROR.CODE:AM
ERROR.TEXT = ERROR.TEXT:ERROR.TEXT1
IF LEN(ERROR.TEXT2) = 0 ! DISPL.CN = 1 THEN
IF INDEX(ERROR.TEXT1,"filed",1) = 0 THEN
ERROR.CODE = ERROR.CODE:"19001"
END ELSE ERROR.CODE = ERROR.CODE:"19000"
END ELSE ERROR.CODE = ERROR.CODE:"19000"
END
EXEC.RESULTS = DELETE(EXEC.RESULTS,1)
REPEAT
*
*
EXEC.RESULTS =ERROR.TEXT:AM:AM:AM:AM:AM:OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):" ":USER.NAME:" ":WHO
WRITE EXEC.RESULTS ON BP.FILE.DICT,"@SYS@ESTAT@LOG@":CODE.PROG
*
IF DISPL.CN > 3 THEN
EXECUTE "COPY DICT DEV @SYS@ESTAT@ED@":CODE.PROG:" (P)"
END
*
*
GOSUB DISPLAY.ELP.TIME
*
*
READ BP.RUNS FROM BP.FILE.DICT,"@SYS@PSTAT@":CODE.PROG ELSE BP.RUNS = ""
BP.RUNS<10> = START.DATE:SVM:START.TIME:SVM:ELP.TIME:SVM:USER.NAME:VM:BP.RUNS<10>
*BP.RUNS<13> = "1111111111111111111111111"
WRITE BP.RUNS ON BP.FILE.DICT,"@SYS@PSTAT@":CODE.PROG
*
*
GOSUB ERROR.CONTROL
*
IF SYS.RUN.TYPE = 1 THEN SYS.RUN.TYPE = 2
OLD.BP = CODE.FILE
OLD.ITEM = CODE.PROG
GOTO INPUT.NEXT
*
STOP
*
!
DISPLAY.ELP.TIME: * Subroutine to display elapsed.
*
END.DATE = DATE(); END.TIME = TIME()
IF END.DATE # START.DATE THEN
ELP.TIME = (86400 - START.TIME) + END.TIME
END ELSE
ELP.TIME = END.TIME - START.TIME
END
*
PRINT @(0,8):CLL:"Finished -  Date: ":OCONV(END.DATE,"D2"):
PRINT "  Time: ":OCONV(END.TIME,"MT"):
PRINT "  Elasped:  ":OCONV(ELP.TIME,"MTS"):
*
RETURN
*
$INCLUDE DH.BP SYS.ERROR.STRUCT
*
END
~CODE.PROGLIST~
SUBROUTINE CODE.PROGLIST
*PROGRAM: CODE.PROGLIST 
*
* AUTHOR: DAVID G. HORSMAN
*
!
$INCLUDE IBP SYS.COMMON
!
TERMINAL = "?"
$INCLUDE IBP STANDARD.FUNCTIONS
*
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
$INCLUDE IBP SYS.INCL.END.RSP
*
$INCLUDE IBP SYS.INCL.SYS.RSP
$INCLUDE IBP SYS.INCL.SYS.RSP.SYNONYM
*
SYS.PROG = "CODE.PROGLIST"
SYS.LOCT = "OPEN"
SYS.SLOC = "ERROR.CONTROL"
SYS.FILE = "SYS"
SYS.ITEM = ""
SYS.RUN.TYPE = 1
SYS.RUN.ATTR = 12
SYS.RUN.MESSAGE = "Compile"
SYS.RUN.CODE = "PROGLIST"
*
!
SYS.SLOC<1>= "SYS"
MAT STRUCT=''
OPEN "DH.SYS" TO SY.FILE ELSE
ERROR.TEXT = "No SYS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC<1>= "MENUS"
OPEN "DH.MENUS" TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC<1>= "MD"
OPEN "MD" TO MD.FILE ELSE
ERROR.TEXT = "No MD file"
ERROR.CODE = "11111"
GOSUB ERROR.CONTROL
END
*
CALL.FUNCTION = "MENU"
CALL.SUB.FUNCTION = "READ"
*
*
USER.NAME = ""
$INCLUDE IBP SYS.USER.NAME
MENU.NAME = ""; MENU.NUM = 1; MENU.APPL = "LOGON"; MENU.SUB.APPL = ""
MENU.GRP.APPL = ""; MENU.CONTROL = ""; PRMPTING = ""; TOPIC.KEY = ""
MAT STRUCT = ""
PORTD = ""; STRUCT(1) = 0; STRUCT(2) = ""; WAIT.FLAG = 1
DEFAULT.BP = "BP"
DEFAULT.ITEM = "NOTES"
OLD.FILE = ""; OLD.ITEM = ""
FILE.NAME = ""; FILE.ITEM = ""; SYS.RUN.TYPE = ""
!
USER.ABORT = ""
SYS.ABORT = ""
SYS.ITEM = "@SYS@USER@":USER.NAME
CALL SYS.USER.LOAD
*
*
*
*#INPUT.NEXT: *
LOOP
SYS.LOCT = "MAIN"
SYS.SLOC<1>= "INIT"
*
GOSUB GET.NEXT
*
EXEC.VERB = "PROGLIST"
EXEC.PARAMS = ""
EXEC.RESULTS = ""
SYS.SLOC<1>= "EXECUTE"
*#EXECUTE EXEC.VERB:" ":FILE.NAME:" ":FILE.ITEM:" (M,E)", //IN. < EXEC.PARAMS, //OUT. > EXEC.RESULTS
GOSUB MAIN
*# GOSUB MAIN
*X OPTION AND COPY ROUTINE CAN BE USED FOR APPL XREF
DISPL1.CN = INDEX(EXEC.RESULTS,"SUCCESSFUL PROGLIST",1)
*IF NOT(DISPL1.CN) THEN DISPL1.CN = INDEX(EXEC.RESULTS,"PROGLIST COMPLETED",1) = 0 
IF NOT(DISPL1.CN) THEN DISPL1.CN = INDEX(EXEC.RESULTS,"Successful listing",1)
*
GOSUB GET.COMPL
*
*
PRINT
PRINT CLS:
IF DISPL1.CN EQ 0 THEN
WRITE EXEC.RESULTS ON INP.FILE.DICT,"@SYS@STAT@":SYS.RUN.CODE:"@":FILE.ITEM
EXECUTE "COPY DICT DEV @SYS@STAT@PROGLIST@":FILE.ITEM:" (P)"
EXECUTE "COPY DICT DEV @SYS@STAT@PROGLIST@":FILE.ITEM:" (T,N)"
ERROR.TEXT = "PROGLIST NOT COMPLETED SEE @SYS@STAT@PROGLIST@":FILE.ITEM
ERROR.CODE = "19001"
GOSUB ERROR.CONTROL
PRINT @(0,0):CLS:
END ELSE
PRINT "Delete error log item."
DELETE INP.FILE.DICT,"@SYS@STAT@PROGLIST@":FILE.ITEM
WRITE EXEC.RESULTS ON INP.FILE.DICT,"@SYS@MSTAT@":FILE.ITEM
END
*
*
OLD.BP = FILE.NAME
OLD.ITEM = FILE.ITEM
*#GOTO INPUT.NEXT
WHILE NOT(SYS.ABORT OR USER.ABORT) DO REPEAT
*
*# RETURN ; *# to calling program
GOTO END.OF.PROGRAM
*
$INCLUDE IBP CODE.SUB.NEXT
*
$INCLUDE IBP CODE.SUB.COMPL
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
*#END
*#@@@@@
*#@@@@@
*#* PROGRAM:           PROGLIST.LARGE
*#*
*#$INCLUDE IBP SYS.COMMON
*#!
*#$INCLUDE IBP STANDARD.FUNCTIONS
*#*
*#*
*#DIM MODE.DESC(30), STAT.DESC(15)
*#*
*#$INCLUDE IBP SYS.INCL.USER.MODE.DESC
*#$INCLUDE IBP SYS.INCL.STATUS.CHECK
*#$INCLUDE IBP SYS.INCL.STATUS.DESC
*#$INCLUDE IBP SYS.INCL.LO.DEV.MODE
*#$INCLUDE IBP SYS.INCL.HI.DEV.MODE
*#$INCLUDE IBP SYS.INCL.HI.SALES.MODE
*#$INCLUDE IBP SYS.INCL.LO.TCL.MODE
*#$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
*#$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*#*
*#LN = 0
*#RELOOP = ""
*#PRINT
*#PRINT "Enter run type (1 or 2): ":
*#INPUT SYS.RUN.TYPE
*#*
*#*SYS.RUN.TYPE = 1 , INPUT 1 PROGRAM NAME FROM TYPE AHEAD
*#*SYS.RUN.TYPE = 2 , READ SELECTS THEN INPUT NAME FORM KEYBOARD
*#*
*#FONT.17 = CHAR(27):"[;12m":CHAR(27):"[;44 G"; FONT.12 = CHAR(27):"[;11m":CHAR(27):"[;60 G"
*#REQD.FONT = FONT.17; MAX.COLS = 130
*#OLD = ""
*#EQUATES = ""
*#DIM INCL.LINES(600)
*#MAX.LINES = 60
*#PRINT @(0,5):CLS:
*#*
*#*
*#PRINT @(0,5):CLL:"Enter file name: ":
*#IF SYS.RUN.TYPE = 2 THEN
*#IF NOT(SYSTEM(11)) THEN RQM
*#IF NOT(SYSTEM(11)) THEN RQM
*#END
*#IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
*#INPUT FILE.NAME:
*#END ELSE FILE.NAME = ""
*#PRINT @(17,5):CLL:FILE.NAME:
*#*
*#*
*#*
*#*
*#LOOP
*#PRINT @(0,7):CLS:"Enter item name: ":
*#FILE.ITEM = ""
*#IF SYS.RUN.TYPE = 2 AND NOT(RELOOP) THEN
*#READNEXT FILE.ITEM ELSE
*#FILE.ITEM = ""
*#RELOOP = SYS.RUN.TYPE
*#END
*#END ELSE FILE.ITEM = ""
*#*
*#IF FILE.ITEM = "" THEN
*#IF SYS.RUN.TYPE = 2 THEN
*#IF NOT(SYSTEM(11)) THEN RQM
*#IF NOT(SYSTEM(11)) THEN RQM
*#IF NOT(SYSTEM(11)) THEN RQM
*#IF NOT(SYSTEM(11)) THEN RQM
*#END
*#IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
*#INPUT FILE.ITEM:
*#END ELSE FILE.ITEM = ""
*#END
*#PRINT @(17,7):CLL:FILE.ITEM:
*#WHILE FILE.ITEM # "" AND FILE.ITEM # "END" DO
*#@@@@@@
*#@@@@@@
*#@@@@@@
*
*
MAIN: *# MAIN PRINTING ROUTINE
PRINT @(0,9):CLL:"Enter parameters (O,X,E): ":
IF SYS.RUN.TYPE = 3 THEN
*1
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
END
*0
IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
*1
IF SYSTEM(11) OR SYS.RUN.TYPE EQ 1 THEN
*2
ERROR.RSP = "E"
ERROR.TEXT = "Enter parameters (O,X,E): "
ERROR.CODE = "191020926001"
GOSUB ERROR.CONTROL
PARAMS = ERROR.RSP
*#INPUT PARAMS:
END ELSE PARAMS = "E"
*1
END ELSE PARAMS = "E"
*0
PRINT @(26,9):PARAMS:"     ":
LOOP
IF PARAMS[1,1] = "O" THEN OLD = 1 
IF PARAMS[1,1] = "X" THEN
*1
REQD.FONT = FONT.12; MAX.COLS = 98
END
*0
IF PARAMS[1,1] = "E" THEN EQUATES = 1
PARAMS = PARAMS[2,99]
WHILE PARAMS # "" DO REPEAT
PRINTER ON; PRINT REQD.FONT:; PRINTER OFF
*
*
*#!
*#MAIN: * READ EACH PROGRAM SELECTED
BP.FL.DH = ""; BP.FL = ""; BP.FL.UTL = ""; BP.FL.PRJ = ""; BP.FL.OLD = ""
IF FILE.NAME # "" THEN FILE.NAMES = FILE.NAME ELSE
*1
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@DEV@BP@FILES"
READ FILE.NAMES FROM SY.FILE,SYS.ITEM ELSE
*2
FILE.NAMES = "SYSTEM":AM:"MD":AM:"PL":AM:"SYS"
FILE.NAMES = FILE.NAMES:AM:"DH.BP"
END ; *# OF READ FILE NAMES
*1
PRINT @(17,5):CLL:FILE.NAME:
END ; *# OF FILE.NAME BLANK
*0
PRINT @(0,11):CLS:"> ":FILE.NAME:" - ":FILE.ITEM:" - ":
PROG = "Program Listing - '":FILE.NAME:" ":FILE.ITEM:"'"; LINE.NUM = MAX.LINES; PAGE.NUM = 0; TAB = 0
NUM = 1; CASE.FLAG = 0; LN = 6
TOT.NUM = 1
TOT.INCL = 0
BP.EMPTY = 0; CN = 0
PRINTER ON; GOSUB HEADER; PRINT SPACE(12):"-----FOUND ON---------"; PRINT; PRINTER OFF
PRINT @(50,5):CLL:"-----FOUND ON-------":
F.RSP = "ZZZZZ"
EXEC.STACK = ""
LOOP
CN = CN + 1
TEMP.NAME = FILE.NAMES<CN>
WHILE TEMP.NAME # "" DO
BP.FLAG = 1
OPEN TEMP.NAME TO INP.FILE ELSE BP.FLAG = ""
IF BP.FLAG THEN
*1
READV TEXT FROM INP.FILE,FILE.ITEM,1 THEN
*2
PRINT @(50,LN):TEMP.NAME:
PRINT "  ?":BELL:
IF SYS.RUN.TYPE NE 1 THEN
*3
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
END
*2
IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
*3
INPUT F.RSP:
END ELSE F.RSP = "Y"; PRINT F.RSP:
*2
IF F.RSP = "Y" THEN EXEC.STACK = EXEC.STACK:CN:AM
*#END ELSE EXEC.STACK = EXEC.STACK:CN:AM
*#*1
PRINTER ON; PRINT SPACE(12):TEMP.NAME; PRINTER OFF; LINE.NUM = LINE.NUM+1
LN = LN+1
IF LN > 19 THEN LN = 6
*# v of verify item is in file
*#    BAD?END ELSE BP.FLAG = ""
END ELSE
*1
*# file does not exist here.
PRINT @(0,23):CLL:TEMP.NAME:" is not in your account.":BELL:
RQM
RQM
END
*0
IF NOT(BP.FLAG) THEN
*1
PRINT @(0,23):CLL:FILE.ITEM:" is not on ":TEMP.NAME:".":; RQM
END
*0
REPEAT
PRINTER ON; PRINT; PRINT SPACE(12):STR("-",20); PRINT; PRINTER OFF; LINE.NUM=LINE.NUM+3
*
*
IF EXEC.STACK # "" THEN
*1
LOOP WHILE EXEC.STACK # "" DO
CN = EXEC.STACK<1>
IF CN > 0 THEN
*2
FILE.NAME = FILE.NAMES<CN>
IF FILE.NAME # "" THEN
*3
OPEN FILE.NAME TO INP.FILE ELSE CN = 0
END ELSE CN = 0
*2
IF CN > 0 THEN GOSUB PRINT.PROGRAM
END
*1
EXEC.STACK = DELETE(EXEC.STACK,1)
REPEAT
END
*0
*
*
IF SYS.RUN.TYPE NE 2 THEN RELOOP = SYS.RUN.TYPE
REPEAT
PRINTER ON; PRINT FONT.17:; PRINTER OFF; STOP
RETURN ; *# to MAIN loop.
*#???GOTO END.OF.PROGRAM
*
*
!
PRINT.PROGRAM: * PRINT EACH PROGRAM
PC.STORED = ""
PRINT @(0,11):CLS:"> ":FILE.NAME:" - ":FILE.ITEM
*:" - ":
PC.CN = 1
PROG = "Program Listing - '":FILE.NAME:" ":FILE.ITEM:"'"; TAB = 0; NUM = 1; CASE.FLAG = 0; LN = 0
BP.EMPTY = 0
PC = "*"
LOOP
LN = LN+1
LINE = ""
READV LINE FROM INP.FILE,FILE.ITEM,LN ELSE LINE = ""
IF LINE = "" THEN BP.EMPTY = BP.EMPTY+1 ELSE BP.EMPTY = 0
*
UNTIL BP.EMPTY > 5 DO
GOSUB PRINTLINE
IF LINE[1,1] = "$" AND EQUATES THEN
SAVE.NUM = NUM
NUM = ">>>>I"
INCL.FILE = FIELD(LINE," ",2)
INCL.PROG = FIELD(LINE," ",3)
INCL.FL = 1
OPEN INCL.FILE TO IINP.FILE ELSE INCL.FL = ""
IF INCL.FL THEN
READV TEST FROM IINP.FILE,INCL.PROG,1 ELSE INCL.FL = ""
END
IF INCL.FL THEN
PC = "I"
MATREAD INCL.LINES FROM IINP.FILE,INCL.PROG ELSE MAT INCL.LINES = ""
LINE = "*"; GOSUB PRINTLINE; INCL.NUM = 1
LOOP LINE = INCL.LINES(INCL.NUM) UNTIL LINE = "" DO
NUM = INCL.NUM:"I"
GOSUB PRINTLINE
INCL.NUM = INCL.NUM+1
TOT.INCL = TOT.INCL+1
TOT.NUM = TOT.NUM+1
REPEAT
IF INCL.NUM > 1 THEN LINE = "*"; GOSUB PRINTLINE
PC = "*"
END
NUM = SAVE.NUM
END
NUM = NUM+1
TOT.NUM = TOT.NUM + 1
REPEAT
*
IF PC.STORED # "" THEN
IF DCOUNT(PC.STORED,AM)+LINE.NUM+20 > MAX.LINES THEN LINE.NUM = MAX.LINES; PRINTER ON; GOSUB HEADER; PRINTER OFF
PRINTER ON
PRINT; PRINT
PRINT "TOTALS......  Lines printed: ":TOT.NUM "R#4"
PRINT "              Program lines: ":NUM "R#4"
PRINT "             Included lines: ":TOT.INCL "R#4"
PRINT
LINE.NUM = LINE.NUM+6
CN = 0
LOOP WHILE PC.STORED # "" DO PRINT PC.STORED<1>; LINE.NUM = LINE.NUM+1; PC.STORED = DELETE(PC.STORED,1) REPEAT 
PRINT
LINE.NUM = LINE.NUM + 1
PRINTER OFF
END
RETURN
!
!
!
PRINTLINE: * ANALYSE AND PRINT LINE
T.LEFT = 0; T.RIGHT = 0; LABEL = ""
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-T.LEFT; IF TAB < 0 THEN TAB = 0
INDENT = TAB*3; P.LINE = NUM "R#5":" "
INDENT.PR = ""
FOR TEMP = 1 TO TAB; INDENT.PR = INDENT.PR:"!  "; NEXT TEMP
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6):INDENT.PR:STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":INDENT.PR:LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE # "" THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
PRINTER ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]
P.LINE = SPACE(12):INDENT.PR:P.LINE[POS+1,999]
REPEAT
PRINT P.LINE; TAB = TAB+T.RIGHT; PRINTER OFF
PRINT PC:; PC.STORED = PC.STORED:PC
PC.CN = PC.CN + 1
IF PC.CN > 50 THEN
PRINT
PC.STORED = PC.STORED:AM
PC.CN = 1
END
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
BEGIN CASE
CASE FIRST = "IF" OR FIRST = "LOCATE" OR FIRST[1,4] = "READ" OR FIRST[1,7] = "MATREAD" OR FIRST = "WRITET" OR FIRST = "WEOF" OR FIRST = "OPEN"
GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "LOOP"; GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST NE "REPEAT;" THEN T.RIGHT = 1
CASE FIRST = "WHILE" OR FIRST = "UNTIL"; T.LEFT = 1; GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST NE "REPEAT;" THEN T.RIGHT = 1
CASE FIRST = "FOR"; POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN T.RIGHT = 1
CASE FIRST = "BEGIN"; T.RIGHT = 1; CASE.FLAG = 1
CASE FIRST = "CASE"; T.RIGHT = 1; IF CASE.FLAG = 1 THEN CASE.FLAG = 0 ELSE T.LEFT = 1
CASE FIRST = "END" OR FIRST = "END;"
IF LINE[POS+1,4] = "CASE" THEN T.LEFT = 2; RETURN
T.LEFT = 1; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "NEXT" OR FIRST = "REPEAT" OR FIRST = "REPEAT;"; T.LEFT = 1
END CASE
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
LASTWORD: * GET LAST WORD
POS = LEN(LINE)
LOOP WHILE LINE[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" OR NOT(POS) DO POS = POS-1 REPEAT
LAST = TRIM(LINE[POS+1,999])
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
MSK = "L#":MAX.COLS-50
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
PRINT FF:TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":LF
RETURN
*
!
END.OF.PROGRAM: * END OF PROGRAM
PRINTER CLOSE
*
*
*
END
END
~CODE.SCANNER~
*PROGRAM:          CODE.SCANNER
*@    FILE:          @ DH.BP
*@  AUTHOR:          @ DAVID HORSMAN
*@ COMPANY:          @ MACROSCOPE SYSTEMS
*@   APPLICATION:    @ SYSTEM UTILITIES
*@   DESCRIPTION:    @ Process DATA BASIC programs for analysis
*@  DATE WRITTEN:      22 OCT 82 originally by David Stern
*@                                 for Axion Computer Software Ltd.
*@ DATE RELEASED:    @ SCHEDULED 1.0     @ ?
*@                   @ Release 1.0 Doc   @ ?
*@                   @ Release 1.0 alpha @ ?
*@                   @ Release 1.0 beta  @ ?
*@                   @ Release 1.0       @ ?
*@                   @ SCHEDULED 2.0     @ ?
*@                   @ Release 2.0       @ ?
*@
*@ MODIFICATIONS:     DATE       NAME        DESCRIPTION
*@                    DD MMM YY
*
$INCLUDE DH.IBP SYS.COMMON
*
$INCLUDE DH.IBP STANDARD.FUNCTIONS
*
$INCLUDE DH.IBP SYS.INCL.OFF.RSP
$INCLUDE DH.IBP SYS.INCL.TCL.RSP
$INCLUDE DH.IBP SYS.INCL.END.RSP
*
$INCLUDE DH.IBP SYS.INCL.SYS.RSP
$INCLUDE DH.IBP SYS.INCL.SYS.RSP.SYNONYM
*
*
*#
*# Input run parameters.
*@
PRINT @(0,0):CLS:
PRINT @(0,5):CLL:'Print include lines? ':; INPUT I.UICL:; PRINT @(21):I.UICL:; *#
PRINT @(0,6):CLL:'Print documentation? ':; INPUT I.DOCI:; PRINT @(21):I.DOCI:; *#
PRINT @(0,7):CLL:'Use a previous release? ':; INPUT I.UOLD:; PRINT @(24):I.UOLD:; *#
PRINT @(0,8):CLL:'Which release (<CR> for current) ? ':; INPUT RELS:; PRINT @(35):RELS:; *#
PRINT @(0,9):CLL:'Which application (<CR> for default) ? ':; INPUT APPL:; PRINT @(39):APPL:; *#
PRINT @(0,10):CLL:'Use which file (<CR> for default) ? ':; INPUT FNAM:; PRINT @(36):FNAM:; *#
*#
*# Process run parameters
*#
*# Paper size and font (Report is 132).
IF I.UICL[1,1]='X' THEN
I.UICL=I.UICL[2,1]
*REQD.FONT=FONT.12
MAX.COLS=98
END ELSE
*REQD.FONT=FONT.17
MAX.COLS=130
ANAL.CN=0
END
PRINTER ON
*PRINT REQD.FONT:
PRINTER OFF
*#
*# Print lines from $INCLUDE files
*#
*# note: 'I' could mean special file installs
*#
FILE.INIT: *#*
IF I.UICL='Y' THEN
UICL='1'; I.UICL='YES'
INCL.FILE.NAME='IBP'
PRINT @(0,11):CLL:'Name of include file? ':; INPUT INCL.FILE.NAME:; *#
IF INCL.FILE.NAME='' THEN INCL.FILE.NAME='IBP'
PRINT @(22):INCL.FILE.NAME:
END ELSE UICL=''; INCL.FILE.NAME=FNAM
*
IF I.UOLD='Y' THEN
UOLD='1' ; I.UOLD='YES'
UOLD.FILE.NAME='OLD.':FNAM
END ELSE UOLD=''; UOLD.FILE.NAME=FNAM
*#
*# Open programs file.
OPEN FNAM TO BP.FILE ELSE
PRINT @(0,23):RELS:APPL:FNAM:' open unsuccessful, hit <CR>.':; *#
INPUT A$:
STOP
END
*
IF UOLD THEN
OPEN UOLD.FILE.NAME TO OLD.FILE ELSE PRINT 'FILE FOR PRIOR RELEASES MISSING.'
END
*#
*# Open $include file.
IF UICL THEN
OPEN INCL.FILE.NAME TO IBP.FILE ELSE
PRINT INCL.FILE.NAME:' open unsuccessful, hit <CR>.':; *#
INPUT A$:
STOP
END
END
*#
*#  PROGRAM CONTROL INFORMATION
*#
IF RELS # '' THEN F.PREF=RELS:'@' ELSE F.PREF=''
IF F.PREF # '' THEN F.PREF=F.PREF:APPL
IF F.PREF # '' THEN F.PREF=F.PREF:'@'
*
IF RELS # '' THEN P.PREF=RELS:'@' ELSE P.PREF=''
IF APPL # '' THEN P.PREF=P.PREF:APPL:'@'
*
*OPEN F.PREF:'VALUES' TO VL.FILE ELSE PRINT 'VALUES FILE MISSING.'
*#
*# Open program control files.
*#
*OPEN F.PREF:'DOCUMENTATION' TO DC.FILE ELSE PRINT 'DOCUMENTATION FILE MISSING.'
*
*OPEN F.PREF:'XREF' TO XR.FILE ELSE PRINT 'CROSS REF. FILE MISSING.'
*
*OPEN F.PREF:'STRUCTURE' TO ST.FILE ELSE PRINT 'STRUCTURE FILE MISSING.'
*
*
*OPEN 'WORK.REQD' TO WK.FILE ELSE PRINT 'WORK REQUIRED FILE MISSING'
*
*OPEN RELS:'SYS.VALUES': TO SY.FILE ELSE PRINT 'SYSTEM VALUES FILE MISSING.'
*#
*# Clear matrices for $includes, set max line number
DIM INCL.LINES(600); MAX.LN=60
*#
*# Main Loop  v v v v v v v v v v v v v v v v v v v v v v v v v v v v v
*#
MAIN: *#  Read each PROGRAM selected
*#
*# Readnext
READNEXT PROG.NAME ELSE
PRINTER ON
PRINT FONT.17
PRINTER OFF
PRINT
PRINT 'END OF PRINTING'
STOP
END
*#
*# Verify PROGRAM by reading first line
IF NOT(UOLD) THEN
READV LINE FROM BP.FILE,P.PREF:PROG.NAME,1 ELSE ERR=10; GOSUB ERROR.RTN; GOTO MAIN 
END ELSE
READV LINE FROM OLD.FILE,P.PREF:PROG.NAME,1 ELSE ERR=10; GOSUB ERROR.RTN; GOTO MAIN
END
PRINT; PRINT PROG.NAME
PROG="Program Listing - '":FNAM:" ":PROG.NAME:"'"
LINE.NO=MAX.LN; PAGE.NO=1; TAB=0; LINE.CN=1; CASE.FLAG=0
*#
*# Clear line xref strings
*#
INCL.LINE.XREF=''; CHAN.LINE.XREF=''; EXEC.LINE.XREF=''
CALL.LINE.XREF=''; PERF.LINE.XREF=''; GOSB.LINE.XREF=''
GOTO.LINE.XREF=''; P.LINE.XREF='';    LOOP.LINE.XREF=''
IFTH.LINE.XREF=''; CASE.LINE.XREF=''
PROG.LINE.XREF=''
PCHAR.END=''
*#
*# Clear DATA BASIC statement stacks
*#
INCL.LINE.STACK=''; CHAN.LINE.STACK=''; EXEC.LINE.STACK=''
CALL.LINE.STACK=''; PERF.LINE.STACK=''; GOSB.LINE.STACK=''
GOTO.LINE.STACK=''; P.LINE.STACK='';    LOOP.LINE.STACK=''
IFTH.LINE.STACK=''; CASE.LINE.STACK=''
PROG.LINE.STACK=''
PCHAR.END=''
*#
*# Clear other analysis variables
FIRST=''
PR.RELEASE='Release - ':RELS
ISAVE.LINE.CN=0
TERM.ANAL=0; ANAL.CN=0; SAVE.ANAL=0
PR.PARA='*INIT'
PROG.EOF=''
PCHAR='*'
POS.STR='CHAIN -EXECUTE -PERFORM -CALL -$INCLUDE -GOSUB -GOTO -NEXT -REPEAT-RETURN-'
*#
*# Process each line from the program
*#
PLOOP: *#  Processing loop - all lines.
LOOP
IF NOT(UOLD) THEN
*#
*# Read current program line (P.PREF:PROG.NAME,LINE.CN)
READV LINE FROM BP.FILE,P.PREF:PROG.NAME,LINE.CN ELSE PROG.EOF=1
END ELSE
READV LINE FROM OLD.FILE,P.PREF:PROG.NAME,LINE.CN ELSE PROG.EOF=1
END
IF LEN(LINE)=0 THEN PROG.EOF=1
*#
*# UNTIL PROG.EOF for loop statement
UNTIL PROG.EOF DO
PCHAR='*';  INCL.LINE.CN=0
PR.LINE.CN=LINE.CN 'R#4'
*#
GOSUB PRINTLINE; *# Process individual line.
*#
*# $include processing
IF LINE[1,8]='$INCLUDE' THEN IF UICL THEN
ISAVE.LINE.CN=LINE.CN
INCL.FILE.NAME=FIELD(LINE,' ',2)
INCL.PROG=FIELD(LINE,' ',3)
*#
*# Read $include item
MATREAD INCL.LINES FROM IBP.FILE,P.PREF:INCL.PROG ELSE MAT INCL.LINES=''
*WRK.ST=INCL.LINE.XREF; WRK.VL1=INCL.FILE.NAME; WRK.VL2=INCL.PROG
*GOSUB WRK.POP.LINE.XREF
*INCL.LINE.XREF=WRK.ST
INCL.LINE.XREF=INCL.LINE.XREF:VM:LINE.CN:SVM:INCL.FILE.NAME:' ':INCL.PROG
*# '!'
LINE='!'; GOSUB PRINTLINE; *#
*# '*'
LINE='*'; GOSUB PRINTLINE; *#
INCL.LINE.CN=1
LOOP LINE=INCL.LINES(INCL.LINE.CN) UNTIL LINE='' DO
PR.LINE.CN=ISAVE.LINE.CN 'R#4':'$  ':INCL.LINE.CN 'R#4'
GOSUB PRINTLINE; *#
INCL.LINE.CN=INCL.LINE.CN+1
REPEAT
IF INCL.LINE.CN > 1 THEN
*#
LINE='*'; GOSUB PRINTLINE; *#
END
LINE='*     FILE: ':INCL.FILE.NAME 'L#20':' PROGRAM: ':INCL.PROG
*#
GOSUB PRINTLINE; *#
LINE='*'; GOSUB PRINTLINE; *#
LINE='!'; GOSUB PRINTLINE; *#
LINE.CN=ISAVE.LINE.CN
ISAVE.LINE.CN=0
END
LINE.CN=LINE.CN+1
LINE.CN.TEST=LINE.CN - (INT(LINE.CN/50) *50)
IF LINE.CN.TEST=0 THEN PRINT ' ':LINE.CN
REPEAT
ERR=''
End.prog: * End of program
PRINT @(0,0):CLS:@(0,3):LINE.CN:' program lines printed.'
PRINT @(0,5):CLL:'Do you wish to file (SAVE) the analysis.':; *#
A$='Y'
*#   INPUT A$:
SAVE.ANAL=0
IF INDEX('*Y*y*Yes*YES*yes*OK**SAVE*FILE*','*':A$:'*',1) # 0 THEN
SAVE.ANAL=1
END ELSE IF A$='N' ! A$='NO' THEN PRINT 'not filed.': ELSE
IF A$='/' THEN GOTO End.prog
PRINT @(0,23):CLL:BELL:'You must enter "N" for no, or "Y" for yes. ':
RQM; RQM
ERR=1
GOTO End.prog
END
IF ERR THEN PRINT @(0,23):CLL:; ERR=''
Input.term: * output to terminal
PRINT @(0,8):CLL:'Would you like to view this on the terminal? ':; *#
A$='Y'
INPUT A$:
TERM.ANAL=0
IF INDEX('*Y*y*Yes*YES*yes*OK**SAVE*FILE*','*':A$:'*',1) # 0 THEN
TERM.ANAL=1
END ELSE IF A$='N' ! A$='NO' THEN PRINT 'not filed.': ELSE
IF A$='/' THEN GOTO End.prog
PRINT @(0,23):CLL:BELL:'You must enter "N" for no, or "Y" for yes. ':
RQM; RQM
ERR=1
GOTO Input.term
END
IF ERR THEN PRINT @(0,23):CLL:; ERR=''
*
Prog.analysis: * Print analysis of code. Save on file if required.
ANAL.CN=2
LOOP
IF ANAL.CN=1 THEN
IF NOT(TERM.ANAL) THEN ANAL.CN=0 ELSE
PRINTER OFF
PRINT @(0,0):CLS:
LINE.NO=999
MAX.LN=20
SAVE.ANAL=''
END
END ELSE IF ANAL.CN=2 THEN
PRINTER OFF
PRINT; PRINT; PRINT 'Printing analysis. ':
PRINTER ON
END
WHILE ANAL.CN > 0 DO
GOSUB HEADER
PRINT; PRINT; PRINT
LINE.NO=LINE.NO + 3
CN1=3
ANAL.STR=''; PREV.CHAR=''
CN=0
LOOP
CN=CN + 1
PCHAR=PCHAR.END[CN,1]
WHILE PCHAR # '' DO
PTEST=INDEX('*S*','*':PCHAR:'*',1)
IF PTEST # 0 THEN
IF PREV.CHAR # '^' THEN PRINT; GOSUB HEADER; CN1=CN1 + 1
PRINT PCHAR:
IF SAVE.ANAL THEN ANAL.STR<CN1>=ANAL.STR<CN1>:PCHAR
END ELSE
IF PCHAR='L' THEN PRINT '->>-':
PRINT PCHAR:
IF SAVE.ANAL THEN ANAL.STR<CN1>=ANAL.STR<CN1>:PCHAR
END
IF PCHAR='^' THEN
PRINT; GOSUB HEADER; CN1=CN1 + 1
END
IF PCHAR='R' THEN PRINT '-<<-':
IF INDEX('*W*U*E*C*@*P*I*','*':PCHAR:'*',1) # 0 THEN
PRINT ' ':
IF SAVE.ANAL THEN ANAL.STR<CN1>=ANAL.STR<CN1>:' '
END
IF ANAL.CN=2 THEN
PRINTER OFF
PRINT 'S':
PRINTER ON
END
PREV.CHAR=PCHAR
REPEAT
Prog.stacks: * Stacked values XREF
PRINT; CN1=CN1 + 1
*UPD.ATR=9
*WRK.ST=P.LINE.XREF
*GOSUB UPD.LINE.XREF
UPD.ATR=11; WRK.ST=CHAN.LINE.XREF; GOSUB UPD.LINE.XREF
UPD.ATR=12; WRK.ST=EXEC.LINE.XREF; GOSUB UPD.LINE.XREF
UPD.ATR=13; WRK.ST=PERF.LINE.XREF; GOSUB UPD.LINE.XREF
UDP.ATR=14; WRK.ST=CALL.LINE.XREF; GOSUB UPD.LINE.XREF
UPD.ATR=15; WRK.ST=INCL.LINE.XREF; GOSUB UPD.LINE.XREF
UPD.ATR=16; WRK.ST=GOSB.LINE.XREF; GOSUB UPD.LINE.XREF
UPD.ATR=17; WRK.ST=GOTO.LINE.XREF; GOSUB UPD.LINE.XREF
*
*
ANAL.CN=ANAL.CN - 1
IF ANAL.CN=1 THEN
PRINT; PRINT; PRINT 'LISTING COMPLETED.'
CN1=CN1 + 3
IF SAVE.ANAL THEN
ANAL.STR<CN1>='LISTING COMPLETED.'
WRITE ANAL.STR ON BP.FILE,'@ANAL@':PROG.NAME
END
END ELSE IF ANAL.CN=0 THEN
LINE.NO=999
GOSUB HEADER
END
REPEAT
*
Prog.close: * End of processing
PRINTER OFF
PRINT; PRINT; PRINT 'LISTING COMPLETED.'
CN1=CN1 + 3
IF SAVE.ANAL THEN ANAL.STR<CN1>='LISTING COMPLETED.'
PRINTER OFF
PRINT; PRINT 'DONE PROGRAM':; INPUT A$; *#
*
GOTO MAIN
PRINTLINE: *#  ANALYSE AND PRINT LINE
T.LEFT=0; T.RIGHT=0; LABEL=''
PR.LINE=LINE
LOOP WHILE PR.LINE[1,1]=' ' DO PR.LINE=PR.LINE[2,999] REPEAT
IF NOT(PR.LINE='!' OR PR.LINE[1,1]='*') THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB=TAB-T.LEFT
IF TAB < 0 THEN
PRINTER ON
PRINT '!!!!!!!!!!!!!'
PRINTER OFF
PRINT '!'
IF TAB < -1 THEN ERR=20; GOSUB ERROR.RTN; TAB=-1
END
INDENT=TAB*3; PR.PREF=PR.LINE.CN:' ':PR.PARA; PR.PREF=PR.PREF[1,11]:' '
P.INDENT=''
CN=0
LOOP CN=CN + 1 WHILE CN < TAB+1 DO P.INDENT=P.INDENT:'|  ' REPEAT
IF PR.LINE='!' THEN P.LINE=PR.PREF:SPACE(12):P.INDENT:STR('*',MAX.COLS-25-INDENT) ELSE
IF LEN(LABEL) < 11 THEN P.LINE=PR.PREF:LABEL 'L#12':P.INDENT:PR.LINE ELSE
P.LINE=PR.PREF:LABEL
IF PR.LINE='*' THEN P.LINE=P.LINE:' *' ELSE IF PR.LINE # '' THEN P.LINE=P.LINE:SPACE(12-LEN(LABEL)):' ':P.INDENT[LEN(LABEL)-13,INDENT]:PR.LINE
END
END
*
CN=0; POS=0
E.POS=999
S.POS=LEN(FIRST)+2
LOOP
CN=CN + 1
POS.WORD=FIELD(POS.STR,'-',CN)
WHILE POS.WORD # '' DO
CN1=0
LOOP
E.POS=999
CN1=CN1 + 1
POS=INDEX(PR.LINE[S.POS,E.POS],POS.WORD,CN1)
WHILE POS # 0 DO
POS=POS+S.POS+LEN(POS.WORD)-1
PCHAR=POS.WORD[1,1]
PCHAR1=''
IF POS.WORD='CHAIN ' THEN
PCHAR1='@'
E.POS=INDEX(PR.LINE[POS,999],"'",2)
IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS,999],'"',2)
IF E.POS=0 THEN E.POS=999
CHAN.LINE.XREF=CHAN.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+1,E.POS-1]
END ELSE IF POS.WORD='EXECUTE ' THEN
PCHAR='E'
E.POS=INDEX(PR.LINE[POS,999],"'",2)
IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS,999],'"',2)
IF E.POS=0 THEN E.POS=999
EXEC.LINE.XREF=EXEC.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+1,E.POS-1]
END ELSE IF POS.WORD='PERFORM ' THEN
PCHAR='P'
E.POS=INDEX(PR.LINE[POS,999],"'",2)
IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS,999],'"',2)
IF E.POS=0 THEN E.POS=999
PERF.LINE.XREF=PERF.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+1,E.POS-1]
END ELSE IF POS.WORD='CALL ' THEN
PCHAR='C'
E.POS=INDEX(PR.LINE[POS,999],')',1)
IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS,999],';',1)
IF E.POS=0 THEN E.POS=999
CALL.LINE.XREF=CALL.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS,E.POS]
END ELSE IF POS.WORD='GOSUB ' THEN
PCHAR='G'
E.POS=INDEX(PR.LINE[POS,999],' ',1)
E1.POS=INDEX(PR.LINE[POS,999],';',1)
IF E1.POS < E.POS ! E.POS=0 THEN E.POS=E1.POS
IF E.POS=0 THEN E.POS=999
GOSB.LINE.XREF=GOSB.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS,E.POS]
END ELSE IF POS.WORD='GOTO ' THEN
PCHAR='v'
E.POS=INDEX(PR.LINE[POS,999],' ',1)
E1.POS=INDEX(PR.LINE[POS,999],';',1)
IF E1.POS < E.POS ! E.POS=0 THEN E.POS=E1.POS
IF E.POS=0 THEN E.POS=999
GOTO.LINE.XREF=GOTO.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS,E.POS]
END ELSE IF POS.WORD='RETURN' THEN PCHAR1='>'
IF PCHAR1 # '' THEN PEND.CHAR=PEND.CHAR:PCHAR1
REPEAT
REPEAT
*
PRINTER ON
IF PCHAR='S' THEN
PRINT PR.PREF:LABEL:SPACE(12-LEN(LABEL)):' ':P.INDENT[LEN(LABEL)-13,INDENT]:STR('*',MAX.COLS-25-INDENT)
LINE.NO=LINE.NO + 1
END
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS=MAX.COLS
LOOP UNTIL P.LINE[POS,1]=' ' OR POS=MAX.COLS-30 DO POS=POS-1 REPEAT
IF POS=MAX.COLS-30 THEN POS=MAX.COLS
PRINT P.LINE[1,POS]
P.LINE=' +++' 'L#12':SPACE(12):P.INDENT:'+>> ':P.LINE[POS+1,999]
REPEAT
PRINT P.LINE
IF PCHAR='S' THEN
PRINT PR.PREF:LABEL:SPACE(12-LEN(LABEL)):' ':P.INDENT[LEN(LABEL)-13,INDENT]:'*'
LINE.NO=LINE.NO + 1
END
TAB=TAB+T.RIGHT
PRINTER OFF
IF ISAVE.LINE.CN # 0 THEN PCHAR='I'
IF (PCHAR # 'I' & PCHAR # '*') ! (PCHAR='I' & INCL.LINE.CN=1) THEN PCHAR.END=PCHAR.END:PCHAR
PRINT PCHAR:
RETURN
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
*
IF FIRST MATCHES '0N' OR FIRST[LEN(FIRST),1]=':' THEN
LABEL=FIRST
PR.PARA=LABEL:' ':STR('.',11)
PR.PARA=PR.PARA[1,10]:' '
PCHAR='S'
PR.LINE=PR.LINE[LEN(FIRST)+2,999]
LOOP WHILE PR.LINE[1,1]=' ' DO PR.LINE=PR.LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
*
GOSUB LASTWORD
*
*
BEGIN CASE
CASE FIRST='IF' OR FIRST='LOCATE' OR FIRST[1,4]='READ' OR FIRST[1,7]='MATREAD' OR FIRST='WRITET' OR FIRST='WEOF' OR FIRST='OPEN'
   IF LAST='THEN' OR LAST='ELSE' THEN
   T.RIGHT=1
   P.LINE.XREF=P.LINE.XREF:VM:LINE.CN:SVM:LAST
   END
   *
CASE FIRST='LOOP'
   IF LAST # 'REPEAT' THEN
   P.LINE.XREF=P.LINE.XREF:VM:FIRST
   IF INDEX(PR.LINE,' WHILE ',1) # 0 THEN P.LINE.XREF=P.LINE.XREF:' WHILE'
   IF INDEX(PR.LINE,' UNTIL ',1) # 0 THEN P.LINE.XREF=P.LINE.XREF:' UNTIL'
   IF LAST='DO' THEN P.LINE.XREF=P.LINE.XREF:' DO'
   T.RIGHT=1
   P.LINE.XREF=P.LINE.XREF:LINE.CN:SVM
   PCHAR='L'
   END ELSE PCHAR='#'
   *
CASE FIRST='WHILE' OR FIRST='UNTIL'
   T.LEFT=1
   IF LAST # 'REPEAT' THEN
   P.LINE.XREF=P.LINE.XREF:VM:FIRST
   IF LAST='DO' THEN P.LINE.XREF=P.LINE.XREF:' DO'
   T.RIGHT=1
   P.LINE.XREF=P.LINE.XREF:LINE.CN:SVM
   PCHAR=FIRST[1,1]
   END ELSE
   PCHAR=LAST[1,1]
   PEND.CHAR=PEND.CHAR:FIRST[1,1]
   END
   *
CASE FIRST='FOR'
   POS=INDEX(PR.LINE,' NEXT ',1)
   IF NOT(POS) THEN
   T.RIGHT=1; P.LINE.XREF=P.LINE.XREF:VM:LINE.CN:SVM:FIRST
   PCHAR=FIRST[1,1]
   END ELSE PCHAR='#'
   *
   !
   *
CASE FIRST='BEGIN'
   T.RIGHT=1
   P.LINE.XREF=P.LINE.XREF:VM:LINE.CN:SVM:FIRST
   CASE.FLAG=1
   *
CASE FIRST='CASE'
   T.RIGHT=1
   P.LINE.XREF=P.LINE.XREF:VM:LINE.CN:SVM:FIRST
   IF CASE.FLAG=1 THEN CASE.FLAG=0 ELSE T.LEFT=1
   *
CASE FIRST='END'
   IF PR.LINE[POS+1,4]='CASE' THEN T.LEFT=2; RETURN
   T.LEFT=1
   *
   !
   *
   IF LAST='THEN' OR LAST='ELSE' THEN
   T.RIGHT=1; P.LINE.XREF=P.LINE.XREF:VM:LAST
   END
   *
CASE FIRST='NEXT' OR FIRST='REPEAT'
   T.LEFT=1
   PCHAR=FIRST[1,1]
   *
CASE FIRST='RETURN'
   IF TAB < 1 THEN PCHAR='^' ELSE PCHAR='>'
   *
CASE FIRST='GOSUB'
   PCHAR='G'
   E.POS=INDEX(PR.LINE[POS+1,999],' ',1)
   E1.POS=INDEX(PR.LINE[POS+1,999],';',1)
   IF E1.POS < E.POS ! E.POS=0 THEN E.POS=E1.POS
   IF E.POS=0 THEN E.POS=999
   GOSB.LINE.XREF=GOSB.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+1,E.POS-1]
   *
CASE FIRST='GOTO'
   PCHAR='v'
   E.POS=INDEX(PR.LINE[POS+1,999],' ',1)
   E1.POS=INDEX(PR.LINE[POS+1,999],';',1)
   IF E1.POS < E.POS ! E.POS=0 THEN E.POS=E1.POS
   IF E.POS=0 THEN E.POS=999
   GOTO.LINE.XREF=GOTO.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+1,E.POS-1]
*
CASE FIRST='CALL'
   PCHAR='C'
   E.POS=INDEX(PR.LINE[POS+1,999],')',1)
   IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS+1,999],';',1)
   IF E.POS=0 THEN E.POS=999
   CALL.LINE.XREF=CALL.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+2,E.POS-1]
   *
CASE FIRST='EXECUTE'
   PCHAR='E'
   E.POS=INDEX(PR.LINE[POS+1,999],'"',2)
   IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS+1,999],"'",2)
   IF E.POS=0 THEN E.POS=999
   EXEC.LINE.XREF=EXEC.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+2,E.POS-1]
*
CASE FIRST='PERFORM'
   PCHAR='P'
   E.POS=INDEX(PR.LINE[POS+1,999],'"',2)
   IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS+1,999],"'",2)
   IF E.POS=0 THEN E.POS=999
   PERF.LINE.XREF=PERF.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+2,E.POS-1]
   *
CASE FIRST='CHAIN'
   PCHAR='@'
   E.POS=INDEX(PR.LINE[POS+1,999],"'",2)
   IF E.POS=0 THEN E.POS=INDEX(PR.LINE[POS+1,999],'"',2)
   IF E.POS=0 THEN E.POS=999
   CHAN.LINE.XREF=CHAN.LINE.XREF:VM:LINE.CN:SVM:PR.LINE[POS+2,E.POS-1]
   *
END CASE
*
*
RETURN
FIRSTWORD: * GET FIRST WORD
POS=1
LOOP CHAR=PR.LINE[POS,1] UNTIL CHAR=' ' OR CHAR='' DO POS=POS+1 REPEAT
FIRST=PR.LINE[1,POS-1]
RETURN
LASTWORD: * GET LAST WORD
LAST.POS=LEN(PR.LINE)
LOOP WHILE PR.LINE[LAST.POS,1]=' ' OR NOT(LAST.POS) DO LAST.POS=LAST.POS-1 REPEAT
LOOP CHAR=PR.LINE[LAST.POS,1] UNTIL CHAR=' ' OR CHAR='' OR NOT(LAST.POS) DO LAST.POS=LAST.POS-1 REPEAT
LAST=TRIM(PR.LINE[LAST.POS+1,999])
RETURN
HEADER: * HEADER
LINE.NO=LINE.NO+1; IF LINE.NO < MAX.LN THEN RETURN
IF TERM.ANAL & ANAL.CN=1 THEN
PRINT @(0,23):CLL:'Enter a <CR>..... ':; INPUT A$; *#
END
MSK='L#':MAX.COLS-50
PRINT FF:TIMEDATE() 'L#25':(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:('PAGE ':PAGE.NO) 'R#25':LF
PAGE.NO=PAGE.NO+1; LINE.NO=5
RETURN
ERROR.RTN: * ERROR MESSAGES
PRINT 'Error in SCANNER. Number: ':ERR:' . Enter a <CR>. ':; *#
INPUT A$; *#
RETURN
WRK.POP.LINE.XREF: * POP A VALUE ONTO A XREF STACK.
*
CN=0; CONT=1
LOOP
CN=CN + 1
IF WRK.ST<1,CN>='' THEN CONT=''
WHILE (WRK.ST<1,CN,1> # WRK.VL1 ! WRK.ST<1,CN,2> # WRK.VL2) & CONT DO REPEAT
IF NOT(CONT) THEN
IF LEN(WRK.ST) # 0 THEN WRK.ST=WRK.ST:VM
WRK.ST=WRK.ST:WRK.VL1:SVM:WRK.VL2:SVM:'*':LINE.CN:'*'
END ELSE
*IF WRK.ST<1,CN,3> # '' THEN WRK.ST<1,CN,3>=WRK.ST<1,CN,3>:'*'
WRK.ST<1,CN>=WRK.ST<1,CN>:LINE.CN:'*'
END
*
RETURN
UPD.LINE.XREF: * UPDATE and PRINT routine for stacked XREF.
Upd.top: * Return point for routine
WRITEV WRK.ST ON BP.FILE,'@XREF@':PROG.NAME,UPD.ATR
CN2=1
IF LINE.NO > MAX.LN - 6 THEN LINE.NO=999 ELSE PRINT; PRINT; CN1=CN1 + 2
GOSUB HEADER
GOSUB HEADER.ANAL
LOOP
CN2=CN2 + 1
WHILE WRK.ST<1,CN2> # '' DO
PR.LINE=WRK.ST<1,CN2,2> 'L#4':'  ':WRK.ST<1,CN2,1>
PRINT PR.LINE
GOSUB HEADER
IF LINE.NO=5 THEN GOSUB HEADER.ANAL
IF SAVE.ANAL THEN ANAL.STR<CN1>=PR.LINE
CN1=CN1 + 1
IF ANAL.CN=2 THEN
PRINTER OFF
PRINT WRK.HD[1,1]:
PRINTER ON
END
REPEAT
CN1=CN1 + 2
PRINT;PRINT
RETURN
HEADER.ANAL: * HEADER FOR PRINTING ANALYSIS
*
PR.LINE='LINE  REFERENCE..............       for '
WRK.HD=FIELD('********Program*Procs*Chain*Execute*Perform*Call*$Include*Gosub*Goto***','*',UPD.ATR)
PR.LINE=PR.LINE:WRK.HD
PRINT
PRINT PR.LINE
LINE.NO=LINE.NO + 2; CN1=CN1 + 1
IF SAVE.ANAL THEN ANAL.STR<CN1>=PR.LINE; CN1=CN1 + 1
RETURN
!
END
~CODE.SUB.COMPL~
*CODE.SEGMENT: CODE.SUB.COMPL
*
* DAVE H. 16 MAY 87
*
GET.COMPL: * COMPL NEXT FILE AND ITEM
!
SYS.LOCT<1> = "COMPL.NEXT"
SYS.SLOC<1> = "SYS.RUN.TYPE"
*
*
*
SYS.SLOC = "ANALYSIS"
GOSUB DISPLAY.ELP.TIME
LOOP WHILE EXEC.RESULTS<1> = '' AND LEN(EXEC.RESULTS) DO
EXEC.RESULTS = DELETE(EXEC.RESULTS,1)
REPEAT
*
GOSUB DISPLAY.ELP.TIME
*
EXEC.RESULTS = "FILE: ":FILE.NAME:"    ITEM: ":FILE.ITEM:AM:EXEC.RESULTS:AM:AM:OCONV(DATE(),"D2"):"    ":OCONV(TIME(),"MT"):" ":USER.NAME:" ":WHO:" ":OCONV(ELP.TIME,"MTS"):AM:SYS.RUN.MESSAGE:" completed":AM:AM
*
WRITE EXEC.RESULTS ON INP.FILE.DICT,"@SYS@ESTAT@":SYS.RUN.CODE:"@":FILE.ITEM
*
*
READ BP.RUNS FROM INP.FILE.DICT,"@SYS@PSTAT@":FILE.ITEM ELSE BP.RUNS = ""
BP.RUNS<SYS.RUN.ATTR> = START.DATE:SVM:START.TIME:SVM:ELP.TIME:SVM:USER.NAME:VM:BP.RUNS<SYS.RUN.ATTR>
*BP.RUNS<13> = "1111111111111111111111111"
WRITE BP.RUNS ON INP.FILE.DICT,"@SYS@PSTAT@":FILE.ITEM
*
*
RETURN
*
!
DISPLAY.ELP.TIME: * Subroutine to display elapsed.
*
END.DATE = DATE(); END.TIME = TIME()
IF END.DATE # START.DATE THEN
ELP.TIME = (86400 - START.TIME) + END.TIME
END ELSE
ELP.TIME = END.TIME - START.TIME
END
*
PRINT @(0,8):CLL:"[=| Finished -  Date: ":OCONV(END.DATE,"D2"):
PRINT "  Time: ":OCONV(END.TIME,"MT"):
PRINT "  Elasped:  ":OCONV(ELP.TIME,"MTS")
PRINT "[=| "
PRINT "[=| "
*
RETURN
*
~CODE.SUB.NEXT~
*CODE.SEGMENT: CODE.SUB.NEXT
*
* DAVE H. 16 MAY 87
*
GET.NEXT: * GET NEXT FILE AND ITEM
!
SYS.LOCT<1> = "GET.NEXT"
SYS.SLOC<1> = "SYS.RUN.TYPE"
*
*
*#IF NOT(SYS.RUN.TYPE) THEN
*#IF SYS.RUN.TYPE EQ 1 THEN
*
ERROR.TEXT = "[=| Enter run type (1 or 2 or 3): "
IF NOT(SYS.RUN.TYPE) THEN
IF SYSTEM(11) THEN SYS.FORCE = 2 ELSE SYS.FORCE = 3
ERROR.RSP = "1"
END ELSE
SYS.FORCE = 0
ERROR.RSP = SYS.RUN.TYPE
END
ERROR.CODE = "2900":SYS.FORCE:"0500001"
GOSUB ERROR.CONTROL
IF NOT(SYS.RUN.TYPE) THEN
IF ERROR.RSP NE '' THEN SYS.RUN.TYPE = ERROR.RSP
IF NOT(NUM(SYS.RUN.TYPE)) THEN SYS.RUN.TYPE = 1
IF SYS.RUN.TYPE EQ 0 THEN SYS.RUN.TYPE = 1
SYS.DEFAULT.FLAG = 1
READ SYS.DEFAULTS FROM MD.FILE,"@SYS@DEFAULTS@CODE.ED@":USER.NAME:"@":PORT ELSE
SYS.DEFAULTS = AM:AM:AM:AM:"BP":AM:"NOTES"
END
DEFUALT.FILE = SYS.DEFAULTS<5>
DEFAULT.ITEM = SYS.DEFAULTS<6>
*#END ELSE
*#SYS.DEFAULT.FLAG = 0
*#SYS.DEFAULTS = AM:AM:AM:AM:"BP":AM:"NOTES"
*#END
IF SYS.RUN.TYPE EQ 1 THEN SYS.FORCE = 2 ELSE SYS.FORCE = 3
END ; *# OF NOT(SYS.RUN.TYPE)
*
!
*
SYS.SLOC<1> = "FILE.NAME"
IF SYS.RUN.TYPE EQ 1 OR NOT(LEN(FILE.NAME)) OR SYSTEM(11) THEN
IF SYS.RUN.TYPE EQ 2 THEN SYS.FORCE = 2
FILE.ITEM = ""
CLS.LO = 10
CLS.HI = 19
GOSUB SYS.CLEAR.PAGE.MID
PRINT @(0,6):CLL:"[=| Enter file name: ":
ERROR.TEXT = "[=| Enter file name: "
ERROR.CODE = "2900":SYS.FORCE:"0600035"
IF SYS.RUN.TYPE NE 1 AND NOT(SYSTEM(11)) THEN
FOR TEMP = 1 TO WAIT.FLAG + 2 UNTIL SYSTEM(11)
RQM
NEXT TEMP
END
*IF SYS.RUN.TYPE EQ 1 OR SYSTEM(11) THEN
ERROR.RSP = FILE.NAME
GOSUB ERROR.CONTROL
IF ERROR.RSP NE '' AND SYS.FORCE THEN FILE.NAME = ERROR.RSP
IF NOT(LEN(FILE.NAME)) THEN FILE.NAME = DEFUALT.FILE
*END ELSE FILE.NAME = DEFUALT.FILE
END ; *# OF NOT(LEN(FILE.NAME)) OR SYSTEM(11)
*
!
*
RSP.NEXT: *
SYS.SLOC<1> = "FILE.ITEM"
*
LOOP
*#FILE.ITEM = ""
CLS.LO = 10
CLS.HI = 19
GOSUB SYS.CLEAR.PAGE.MID
PRINT @(0,6):CLL:"[=| Enter file name: ":FILE.NAME:
ERROR.TEXT = "[=| Enter item name: "
ERROR.RSP = FILE.ITEM
PRINT @(0,7):CLL:ERROR.TEXT:ERROR.RSP
ERROR.CODE = "2900":SYS.FORCE:"0700035"
READNEXT FILE.ITEM ELSE
PRINT @(0,7):"[=| Enter item name: ":
IF SYS.RUN.TYPE NE 1 AND NOT(SYSTEM(11)) THEN
FOR TEMP = 1 TO WAIT.FLAG + 2 UNTIL SYSTEM(11)
RQM
NEXT TEMP
END
IF SYS.RUN.TYPE EQ 1 OR SYSTEM(11) THEN
*#INPUT FILE.ITEM:
GOSUB ERROR.CONTROL
IF ERROR.RSP NE '' THEN FILE.ITEM = ERROR.RSP
IF NOT(LEN(FILE.ITEM)) THEN FILE.ITEM = DEFAULT.ITEM
END ELSE FILE.ITEM = DEFAULT.ITEM
END
PRINT @(0,7):CLL:"[=| Enter item name: ":FILE.ITEM
IF FILE.ITEM EQ OLD.ITEM THEN FILE.ITEM = ""
IF LEN(FILE.ITEM) = 0 ! LEN(FILE.NAME) = 0 THEN USER.ABORT = TRUE
*
WHILE FILE.ITEM = "*" DO
SYS.SLOC<1> = "SELECT LIST"
PRINT "[=| "
PRINT "[=| "
EXEC.VERB = "GET-LIST ":FILE.NAME
PRINT "[=| ":EXEC.VERB
EXECUTE EXEC.VERB
PRINT "[=| "
READNEXT FILE.ITEM ELSE
EXEC.PARAMS = "SAVE-LIST ":FILE.NAME
EXEC.VERB = "SSELECT ":FILE.NAME
PRINT "[=| ":EXEC.VERB
PRINT "[=| >":EXEC.PARAMS
PRINT "[=| >":
EXECUTE EXEC.VERB, //IN. < EXEC.PARAMS
PRINT "[=| "
END
EXEC.VERB = "GET-LIST ":FILE.NAME
PRINT "[=| ":EXEC.VERB
PRINT "[=| >":
EXECUTE EXEC.VERB
PRINT "[=| "
FILE.ITEM = ''
SYS.RUN.TYPE = 2
REPEAT
*
*
IF NOT(USER.ABORT OR SYS.ABORT) THEN
SYS.SLOC<1> = "DEFAULTS"
*IF SYS.RUN.TYPE NE 1 THEN
SYS.DEFAULTS<5> = FILE.NAME
SYS.DEFAULTS<6> = FILE.ITEM
DEFUALT.FILE = FILE.NAME
DEFAULT.ITEM = FILE.ITEM
WRITE SYS.DEFAULTS ON MD.FILE,"@SYS@DEFAULTS@CODE.ED@":USER.NAME:"@":PORT
PRINT "[=| "
PRINT "[=| Updated . . . "
PRINT "[=| "
*END
*
SYS.SLOC<1> = "OPEN"
CHECK.FILE = 0
SYS.SLOC<1> = FILE.NAME
OPEN FILE.NAME TO INP.FILE THEN CHECK.FILE = 1 ELSE
CHECK.FILE = 0
ERROR.TEXT = "[=| No ":FILE.NAME:" file"
ERROR.CODE = "21111"
GOSUB ERROR.CONTROL
END
*
OPEN "DICT DEV" TO INP.FILE.DICT THEN CHECK.FILE.DICT = 1 ELSE
CHECK.FILE.DICT = 0
ERROR.TEXT = "[=| No DICTionary for DEV file"
ERROR.CODE = "21111"
GOSUB ERROR.CONTROL
END
*
SYS.SLOC<1> = "STATS ATTR"
*#CLS.LO = 5
*#CLS.HI = 19
*#GOSUB SYS.CLEAR.PAGE.MID
START.DATE = DATE()
START.TIME = TIME()
PRINT @(0,5):CLL:"[=| Type: ":SYS.RUN.TYPE:
READV BP.RUNS FROM INP.FILE.DICT,"@SYS@PSTAT@":FILE.ITEM,SYS.RUN.ATTR ELSE BP.RUNS = ""
PRINT @(0,6):CLL:"[=| File: ":FILE.NAME:
PRINT @(0,7):CLL:"[=| Item: ":FILE.ITEM:
PRINT @(0,8):CLL:"[=| Prestore: ":
*#PRESTORE:
PRINT @(0,9):CLL:"[=| Started -   Date: ":OCONV(START.DATE,"D2"):
PRINT "  Time: ":OCONV(START.TIME,"MT"):
PRINT "  Required: ":OCONV(BP.RUNS<1,1,3>,"MTS")
PRINT "[=| ":
END; *# OF NOT(USER.ABORT OR SYS.ABORT)
*
EXEC.VERB = ""
EXEC.RESULTS = ""
EXEC.PARAMS = ""
*
*
RETURN
~CODES.CONVERT~
*PROGRAM: CODES.CONVERT
*
DIM CODES.IN.KEY(200), CODES.OUT.KEY(200)
DIM IN.CODES(100), OUT.CODES(100)
MAT OUT.CODES = ''
MAT IN.CODES = ''
MAT CODES.IN.KEY = ''
MAT CODES.OUT.KEY = ''
PROGRAM.CONTROL = 'CONTINUE'
LOCT = 1
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN 'SYS.STRUCTURE' TO SYSS ELSE STOP
LOCT = 2
OPEN 'MISC.CODES.DATA' TO IN.FILE ELSE PRINT '?'; STOP
LOCT = 3
OPEN 'MISC.CODES.DATA' TO OUT.FILE ELSE PRINT '??'; STOP
LOCT = 5
MATREAD CODES.IN.KEY FROM SYSS,'CODES.LIST' ELSE STOP
LOCT = 6
MATREAD CODES.OUT.KEY FROM SYSS,'OUT.CODES.LIST' ELSE STOP
LOCT = 7
KEY.COUNTER = 0
INPUT A$
PRINT
PRINT
LOOP
KEY.COUNTER = KEY.COUNTER + 1
WHILE PROGRAM.CONTROL # 'STOP' AND CODES.IN.KEY(KEY.COUNTER) # '' DO
MATREAD IN.CODES FROM IN.FILE,CODES.IN.KEY(KEY.COUNTER) ELSE STOP
MAT OUT.CODES = MAT IN.CODES
MATWRITE OUT.CODES ON OUT.FILE,CODES.OUT.KEY(KEY.COUNTER)
DELETE IN.FILE,CODES.IN.KEY(KEY.COUNTER)
PRINT 'Record ':CODES.IN.KEY(KEY.COUNTER):' now at ':CODES.OUT.KEY(KEY.COUNTER):'. Number ':KEY.COUNTER:'.'
IF KEY.COUNTER < 25 THEN RQM
IF KEY.COUNTER < 10 THEN RQM
IF KEY.COUNTER < 5  THEN RQM
IF KEY.COUNTER < 3  THEN RQM;RQM
REPEAT
END
~CODES.MAINT~
*PROGRAM: CODES.MAINT
*
******************** COMMENT AREA *************************************
*
*
* This program inputs and maintains miscellaneous codes to be used
* by programs.
*
*
*
* FILE: SYS.STRUCTURE
*
* KEY: 999-999
* |   |
* |   ----------------- SUB-CODE
* --------------------- CODE
*
* NAME OF FIELD           LENGTH     INPUT POSITION
* ---------------         -------    --------------
* CODE TYPE KEY           See Key    LIN:3,COL:21
* SHORT NAME              12         LIN>15,COL=3
* LONG NAME (DESCRIPTION) n * 40     LIN>15,COL=20
*
*
*
******************** INIT-SYSTEM AREA ******************************
EQUATE BELLS TO CHAR(7), SCR.CLR TO CHAR(12)
PROMPT ""
PRINT SCR.CLR
PERSONS.NAME='Dave'
******************** INIT-PROG-DATA ONLY ******************
PROG.SUB='INIT-PROG-DATA'
CURR.KEY.DISPLAY='000-000'
CURR.KEY=000000
CURR.KEY.INPUT='000-000'
KEY.MAX.NUM.LVL=2
LIN.POS=0; COL.POS=0
LIN.MSG=20; LIN.ENT=19
FUNCTION.NAMES='SUMMARY RECORD MAINTENANCE&SCREEN CODE LISTING&PRINTER CODES LISTING&ADD TO CODES&MODIFY CODES&DELETE CODES'
********************* INIT-PROG-FILE-OPEN *****************
*
* FILES USED: CODES FILE
*       CODE-TYPE SUMMARY RECORD
*       CODE DETAIL RECORD
*
*       KEY FORMATS:   999-999-XXXXX~~~XXXXX
*                      999-999
*                      999
*
*
PROG.SUB='INIT-PROG-FILE-OPEN'
FIL.NAM.1='MISC.CODES.DATA'
OPEN FIL.NAM.1 TO CODES ELSE
PRINT @(1,LIN.MSG):PERSONS.NAME:', there has been and error on the ':FIL.NAM.1:' open.'
STOP
END
* ENTER TIME RECORDS (START TIME,FUNCTION)
GOSUB 9110
******************** SCREEN DISPLAY AREA *************************
10PROG.SUB='SCREEN DISPLAY 1'
A$="CON'T:"
INPUT @(60,20):A$
PRINT SCR.CLR
A$='CODES MAINTENANCE AND DEFINITION PROGRAM'
PRINT @(40-(LEN(A$)/2),1):A$
********************* MAIN LOGIC AREA **********************************
PROG.SUB='MAIN LOGIC'
*
*INPUT KEY
GOSUB 1000  
IF CURR.KEY.INPUT='END' THEN GOTO 99999
*
*READ SUMMARY RECORD
GOSUB 1500  
IF REC.STATUS='NEW' THEN
IF FUNCT.TYPE='ADD' THEN
GOSUB 1600
END ELSE
GO TO 10
END
END
IF REC.STATUS='CAN' THEN GOTO 10
PRINT @(40-LEN(SUMM.REC<1>)/2,2):SUMM.REC<1>:
*
*INPUT FUNCTION - S,L,P,A/M/D
GOSUB 2000   
IF FUNCT.TYPE='END' THEN GOTO 99999
*
* SUMMARY RECORD MODIFY
IF FUNCT.TYPE='S' THEN
GOSUB 1600
GO TO 10
END
*
* LIST CODES ON SCREEN
IF FUNCT.TYPE='L' THEN GOSUB 3000
*
* PRINT CODES ON PRINTER
IF FUNCT.TYPE='P' THEN GOSUB 4000
*
* DETAIL RECORD MODIFY
IF FUNCT.TYPE='A' OR FUNCT.TYPE='M' OR FUNCT.TYPE='D' THEN GOSUB 5000
GOTO 10
******************** SCREEN-KEY INPUT AREA *************************
1000 PROG.SUB='KEY-SUMM INPUT'
LIN.POS=4
PRINT @(5,LIN.POS):'CODE TYPE KEY:':
INPUT @(21,LIN.POS):CURR.KEY.INPUT
IF CURR.KEY.INPUT='END' THEN
PRINT @(30,LIN.POS):'END requested.'
RETURN
END
*
*
ST.NUM=1; WRK.1=0; WRK.2=0
1010  ST.WRK.1=FIELD(CURR.KEY.INPUT,'-',ST.NUM)
WRK.1=COL1()
WRK.2=COL2()
IF WRK.2>0 AND LEN(ST.WRK.1)<3 AND ST.NUM<KEY.MAX.NUM.LVL+1 THEN
LOOP WHILE LEN(ST.WRK.1)<3 DO ST.WRK.1='0':ST.WRK.1 REPEAT
CURR.KEY.INPUT=CURR.KEY.INPUT[1,WRK.1]:ST.WRK.1:CURR.KEY.INPUT[WRK.2,(LEN(CURR.KEY.INPUT)-WRK.2+1)]
END
ST.NUM = ST.NUM + 1
IF ST.NUM<KEY.MAX.NUM.LVL+1 THEN GOTO 1010
CURR.KEY.SUMM=CURR.KEY.INPUT[1,(KEY.MAX.NUM.LVL*4-1)]:'@'
PRINT @(21,LIN.POS):CURR.KEY.SUMM
RETURN
******************** SUMMARY RECORD READ SUBROUTINE
1500PROG.SUB='SUMMARY RECORD READ'
LIN.POS=6; FUNCT.TYPE=''
PRINT @(1,LIN.MSG):PERSONS.NAME:', I am in the ':PROG.SUB:' subroutine.':SPACE(80-LEN(PERSONS.NAME)-LEN(PROG.SUB)-30):
YES.NO='NO'; REC.STATUS='OLD'
READ SUMM.REC FROM CODES,CURR.KEY.SUMM ELSE
PRINT @(1,LIN.MSG):'The record for ':CURR.KEY.SUMM:' does not exist.':BELLS:SPACE(80-LEN(CURR.KEY.SUMM)-35)
PRINT @(30,LIN.POS):'Add this record?':
INPUT @(46,LIN.POS):YES.NO
REC.STATUS='NEW'; SUMM.REC=''
END
IF YES.NO#'NO' AND YES.NO#'YES' THEN YES.NO='NO'
IF YES.NO='YES' THEN FUNCT.TYPE='ADD'
RETURN
******************** SUMMARY RECORD MODIFY SUBROUTINE
1600 PROG.SUB='SUMMARY RECORD MODIFY'
PRINT @(1,LIN.MSG):PERSONS.NAME:', I am in the ':PROG.SUB:' subroutine.':SPACE(80-LEN(PERSONS.NAME)-LEN(PROG.SUB)-30):
FUNCT.DONE='NO'
PRINT @(1,10):'SUMMARY RECORD DESCRIPTION':SPACE(50):
PRINT @(1,12):'1. SHORT NAME: ':SUMM.REC<1>:SPACE(65-LEN(SUMM.REC<1>)):
LIN.POS=1
PRINT @(1,14):'DESCRIPTION:':
LOOP LIN.POS=LIN.POS+1 WHILE LIN.POS<6 DO
PRINT @(20,LIN.POS+12):LIN.POS:'.  ':SUMM.REC<LIN.POS>:SPACE(80-LEN(SUMM.REC<LIN.POS>)-25):
REPEAT
LIN.WANTED=''
1610IF FUNCT.TYPE='ADD' AND FUNCT.DONE='NO' THEN
LIN.WANTED=LIN.WANTED+1
END ELSE
LIN.ALPHA=''
PRINT @(50,LIN.ENT):'Which line?':
INPUT @(62,LIN.ENT):LIN.ALPHA
IF LIN.ALPHA='' THEN LIN.ALPHA='0'
IF LIN.ALPHA='END' THEN LIN.ALPHA='0'
IF LIN.ALPHA='CAN' THEN
REC.STATUS='CAN'
RETURN
END
IF NOT(NUM(LIN.ALPHA)) THEN GOTO 1610
LIN.WANTED=LIN.ALPHA+0
END
IF LIN.WANTED>5 THEN
FUNCT.DONE='YES'
GOTO 1610
END
IF LIN.WANTED=0 THEN
GOSUB 1650
RETURN
END
1620IF LIN.WANTED=1 THEN
LIN.ADD=11
COL.POS=16
END ELSE
LIN.ADD=12
COL.POS=24
END
SUMM.VALUE=''
INPUT @(COL.POS,LIN.WANTED+LIN.ADD):SUMM.VALUE
PRINT @(LEN(SUMM.VALUE)+COL.POS,LIN.WANTED+LIN.ADD):SPACE(75-COL.POS-LEN(SUMM.VALUE)):
IF LIN.WANTED=1 THEN
IF LEN(SUMM.VALUE)>12 THEN
PRINT @(1,LIN.MSG):BELLS:'Your entry is too long, re-enter.':SPACE(40):
GOTO 1620
END
END
SUMM.REC<LIN.WANTED>=SUMM.VALUE
GOTO 1610
RETURN
1650 PRINT @(1,LIN.MSG):'UPDATED'
WRITE SUMM.REC ON CODES,CURR.KEY.SUMM
RETURN
******************** INPUT FUNCTION SUBROUTINE
2000 PROG.SUB='INPUT FUNCTION'
LIN.POS=6
PRINT @(1,LIN.MSG):PERSONS.NAME:', I am in the ':PROG.SUB:' subroutine.':SPACE(80-LEN(PERSONS.NAME)-LEN(PROG.SUB)-30):
PRINT @(5,LIN.POS):'Which fuction:':SPACE(55)
FUNCT.TYPE=''
INPUT @(21,LIN.POS):FUNCT.TYPE
IF FUNCT.TYPE='' THEN FUNCT.TYPE='A'
IF FUNCT.TYPE='END' THEN
PRINT @(30,LIN.POS):'END requested'
RETURN
END
FUNCT.TYPE=FUNCT.TYPE[1,1]
IF COUNT('SLPAMD',FUNCT.TYPE)=0 THEN
FUNCT.TYPE='NO FUNCTION ENTERED'
END ELSE
FUNCT.NUMBER=INDEX('SLPAMD',FUNCT.TYPE,1)
FUNCT.DESC=FIELD(FUNCTION.NAMES,'&',FUNCT.NUMBER)
PRINT @(30,LIN.POS):FUNCT.DESC:SPACE(45-LEN(FUNCT.DESC))
END
RETURN
******************** LIST CODES ON SCREEN SUBROUTINE
3000 PROG.SUB='SCREEN CODES LIST'
PRINT @(1,LIN.MSG):PERSONS.NAME:', I am in the ':PROG.SUB:' subroutine.':SPACE(80-LEN(PERSONS.NAME)-LEN(PROG.SUB)-30):
RETURN
******************** PRINT CODES ON PRINTER SUBROUTINE
4000 PROG.SUB='PRINTER CODES LIST'
PRINT @(1,LIN.MSG):PERSONS.NAME:', I am in the ':PROG.SUB:' subroutine.':SPACE(80-LEN(PERSONS.NAME)-LEN(PROG.SUB)-30):
RETURN
******************** DETAIL RECORD MODIFY SUBROUTINE
5000 PROG.SUB='DETAIL RECORDS MODIFY'
PRINT @(1,LIN.MSG):PERSONS.NAME:' I am in the ':PROG.SUB:' subroutine.':SPACE(80-LEN(PERSONS.NAME)-LEN(PROG.SUB)-30):
COL.POS=0; LIN.POS=10
PRINT @(1,8):'SHORT NAME  LONG NAME OF CODE':
PRINT @(1,9):'----------------------------------------------------':
5110 COL.POS=1
DETL.SHORT=''
INPUT @(COL.POS,LIN.POS):DETL.SHORT
IF DETL.SHORT='' THEN DETL.SHORT='END'
IF DETL.SHORT='END' THEN
PRINT @(COL.POS+15,LIN.POS):'END requested.':SPACE(65-COL.POS):
RETURN
END
IF LEN(DETL.SHORT)>12 THEN
PRINT @(1,LIN.MSG):PERSONS.NAME:' the SHORT NAME is longer than 12 charaters, re-enter.':SPACE(20-LEN(PERSONS.NAME)):
GOTO 5110
END
CURR.KEY.DETL=CURR.KEY.SUMM:DETL.SHORT
CURR.KEY.OK='NO'
READ DETL.REC FROM CODES,CURR.KEY.DETL ELSE
DETL.REC=''
IF FUNCT.TYPE='D' OR FUNCT.TYPE='M' THEN
PRINT @(1,LIN.MSG):BELLS:PERSONS.NAME:' this record does not exist, re-enter SHORT NAME.':SPACE(25-LEN(PERSONS.NAME)):
GOTO 5110
END ELSE CURR.KEY.OK='YES'
END
IF FUNCT.TYPE='A' AND CURR.KEY.OK='NO' THEN
PRINT @(1,LIN.MSG):BELLS:PERSONS.NAME:' this record already exists, re-enter SHORT NAME.':SPACE(25-LEN(PERSONS.NAME)):
GOTO 5110
END
5120  COL.POS=16
PRINT @(COL.POS,LIN.POS):DETL.REC<1,1>:SPACE(75-COL.POS-LEN(DETL.REC<1,1>)):
IF FUNCT.TYPE#'D' THEN
DETL.VALUE=''
INPUT @(COL.POS,LIN.POS):DETL.VALUE
IF LEN(DETL.VALUE)=0 THEN
DETL.VALUE=DETL.REC<1,1>
END
IF LEN(DETL.VALUE)>40 THEN
PRINT @(1,LIN.MSG):BELLS:PERSONS.NAME:' the LONG NAME cannot be longer than 40 characters, re-enter.':SPACE(15-LEN(PERSONS.NAME)):
PRINT @(COL.POS,LIN.POS):SPACE(75-COL.POS):
GOTO 5120
END
PRINT @(COL.POS,LIN.POS):DETL.VALUE:SPACE(40-LEN(DETL.VALUE)):
END
PRINT @(50,LIN.ENT):'OK?':
DETL.OK=''
INPUT @(54,LIN.ENT):DETL.OK
IF DETL.OK#'Y' AND DETL.OK#'YES' AND DETL.OK#'' THEN GOTO 5110
IF FUNCT.TYPE='D' THEN
DELETE CODES,CURR.KEY.DETL
END ELSE
DETL.REC<1,1>=DETL.VALUE
WRITE DETL.REC ON CODES,CURR.KEY.DETL
END
GOTO 5110
RETURN
******************** END OF PROGRAM **********************************
9110 RETURN
99999PROMPT '?'
END
~COMPARE.ALL~
*PROGRAM: COMPARE.ALL 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       LOAD COMPARE OF BP, IBP, BP.UTL, MENUS, PL, HLP INTO OVERNIGHT PROCESSING...
* DATE WRITTEN:      23 JAN 85
* DATE RELEASED:     23 JAN 85
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
INPUT AUTO.RUN
INPUT EXEC.FL
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "PL" TO PL.FILE ELSE PRINT "Can't open file PL"; INPUT RSP; STOP
OPEN "MD" TO MD.FILE ELSE PRINT "Can't open file MD"; INPUT RSP; STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Load COMPARE-ALL overnight processing"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
DT = OCONV(DATE(),"D2"); DT = DT[1,2]:DT[4,3]:DT[8,2]
READ COMPARE.SKELETON FROM PL.FILE,"COMPARE.SKELETON" ELSE
PRINT @(0,23):"COMPARE.SKELETON is missing from file PL -- press <cr>":
INPUT RSP:
STOP
END
*
IF NOT(AUTO.RUN) THEN
PROCS = ""; INPUTS = ""; DESCS = ""
PROCS<1> = "RUN BP.UTL COMPARE.ALL"; INPUTS<1> = ""; DESCS<1> = "Compare"
CALL AUTO.LOADER(PROCS,INPUTS,DESCS)
END
*
READ FILE.LIST FROM CNT.FILE,"FILE.LIST" ELSE
PRINT @(0,23):"FILE.LIST not found on CNT -- press <cr> ":CLL:
INPUT RSP:
STOP
END
AC = 1
LOOP
FILE.NAME = FILE.LIST<AC>
UNTIL FILE.NAME = "" DO
PROC = COMPARE.SKELETON
IF FILE.NAME[1,4] = "ULT." THEN FILE.NAME = FILE.NAME[5,99]
LIST.NAME = FILE.NAME
IX = INDEX(LIST.NAME,",",1); IF IX THEN LIST.NAME = LIST.NAME[1,IX-1]:".":LIST.NAME[IX+1,99]
DICT.NAME = ""; IF FILE.NAME[1,5] = "DICT." THEN DICT.NAME = "DICT "; FILE.NAME = FILE.NAME[6,99]
LOOP
IX = INDEX(PROC,"@@@@D",1)
WHILE IX DO
PROC = PROC[1,IX-1]:DICT.NAME:PROC[IX+5,9999]
REPEAT
LOOP
IX = INDEX(PROC,"@@@@F",1)
WHILE IX DO
PROC = PROC[1,IX-1]:FILE.NAME:PROC[IX+5,9999]
REPEAT
LOOP
IX = INDEX(PROC,"@@@@L",1)
WHILE IX DO
PROC = PROC[1,IX-1]:LIST.NAME:PROC[IX+5,9999]
REPEAT
LOOP
IX = INDEX(PROC,"@@@DT",1)
WHILE IX DO
PROC = PROC[1,IX-1]:DT:PROC[IX+5,9999]
REPEAT
WRITE PROC ON MD.FILE,"$$$COMPARE.ALL$$$"
IF EXEC.FL THEN
EXECUTE "$$$COMPARE.ALL$$$"
END
AC = AC+1
REPEAT
STOP
!
END
~COMPARE.PROG~
*PROGRAM: COMPARE.PROG 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       COMPARES VERSION OF A PROGRAM (OR OTHER ITEM) IN 
*                    <file.name> WITH THE ONE IN OLD.<file.name> AND OUTPUTS THE CHANGES
*                    INTO FILE <file.name>.CHANGES UNDER THE SAME ITEM ID.
*                    FORMAT OF <file.name>.CHANGES ITEM:
*                       ATTR 1: <byte total>,<cksum>,<byte total>,<cksum>
*                                      from CHECK-SUM verb:
*                                           . first are for change item less attr 1
*                                           . second are for item in <file.name>
*                       ATTR 2: <from>[-<to>] [,...]       (deletions from OLD.<file.name>)
*                       ATTR 3- <line#> <space> <line>
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT PGM.NAME:
NO.OLD = ""
IF PGM.NAME[1,8] = "*NO.OLD*" THEN
NO.OLD = 1
PGM.NAME = PGM.NAME[9,99]
END
DICT.NAME = ""; FL.NAME = TRIM(FIELD(PGM.NAME,";",1))
THIRD.PART = TRIM(FIELD(PGM.NAME,";",3))
PGM.NAME = TRIM(FIELD(PGM.NAME,";",2))
IF THIRD.PART # "" THEN DICT.NAME = FL.NAME; FL.NAME = PGM.NAME; PGM.NAME = THIRD.PART
IF PGM.NAME = "" THEN PGM.NAME = FL.NAME; FL.NAME = "BP"
IF FL.NAME[1,5] = "DICT " THEN DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
COMBINED.FL = TRIM(DICT.NAME:" ":FL.NAME)
OPEN DICT.NAME,FL.NAME TO BP.FILE ELSE PRINT "Can't find ":COMBINED.FL:; INPUT RSP:; STOP
COMBINED.OLD.FL = TRIM(DICT.NAME:" OLD.":FL.NAME)
OPEN DICT.NAME,"OLD.":FL.NAME TO OLD.FILE ELSE PRINT "Can't find ":COMBINED.OLD.FL:; INPUT RSP:; STOP
CH.NAME = FL.NAME:".CHANGES"
COMBINED.CHANGES = TRIM(DICT.NAME:" ":CH.NAME)
OPEN DICT.NAME,CH.NAME TO CH.FILE ELSE PRINT "Can't find ":COMBINED.CHANGES:; INPUT RSP:; STOP
IF NO.OLD THEN OLN = "" ELSE
READ OLN FROM OLD.FILE, PGM.NAME ELSE OLN = ""
END
READ NLN FROM BP.FILE, PGM.NAME ELSE PRINT PGM.NAME:" not in ":COMBINED.FL:; INPUT RSP:; STOP
EXLN = 'CHECK-SUM ':COMBINED.FL:' "':PGM.NAME:'"'
EXECUTE EXLN, //OUT. > CH.OUT
CHG = ""
CH.OUT = TRIM(CH.OUT<2>)
CH.OUT = FIELD(CH.OUT," ",3):",":FIELD(CH.OUT," ",12)
CHC = 1; *CHANGE COUNTER
NLC = 0; *BP COUNTER
NLCTR = 0; *OVERALL BP COUNTER
OLC = 0; *OLD.BP COUNTER
OLCTR = 0; *OVERALL OLD.BP COUNTER
MAX.NLC = COUNT(NLN,AM)+1
MAX.OLC = COUNT(OLN,AM)+1
LST.DLT = 9999; LST.RNG = ""
DELIM = "$$$":"%%%":"$$$"
LOOP
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
IF OLC > 49 THEN
OLN<OLC> = DELIM
TMP = INDEX(OLN,DELIM,1)
OLN = OLN[TMP+LEN(DELIM)+1,50000]
MAX.OLC = MAX.OLC-OLC
OLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
OLC = OLC+1
OLCTR = OLCTR+1
NEWL = NLN<NLC>
OLDL = OLN<OLC>
UNTIL OLC > MAX.OLC DO
IF NEWL # OLDL THEN
NLC1 = NLC
OLC1 = OLC
NXT.TRY: *
LOOP
NLC1 = NLC1+1
NEWL = NLN<NLC1>
UNTIL NLC1 > MAX.NLC OR NEWL = OLDL DO
REPEAT
IF NLC1 > MAX.NLC THEN
IF LST.DLT = OLCTR-1 THEN LST.RNG = OLCTR ELSE
IF LST.RNG THEN CHG<1> = CHG<1>:"-":LST.RNG; LST.RNG = ""
IF CHG<1> # "" THEN CHG<1> = CHG<1>:","
CHG<1> = CHG<1>:OLCTR
END
LST.DLT = OLCTR
NLC = NLC-1
NLCTR = NLCTR-1
END ELSE
FOR EQCTR = 1 TO 9 UNTIL NLN<NLC1+EQCTR> # OLN<OLC+EQCTR>
NEXT EQCTR
IF EQCTR < 9 THEN GOTO NXT.TRY
LOOP UNTIL NLC = NLC1 DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NLN<NLC>
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC1 = NLC1 - NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
REPEAT
END
END
REPEAT
LOOP UNTIL NLC > MAX.NLC DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NEWL
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
NEWL = NLN<NLC>
REPEAT
IF LST.RNG THEN CHG<1> = CHG<1>:"-":LST.RNG
WRITE CHG ON CH.FILE, PGM.NAME
EXLN = 'CHECK-SUM ':COMBINED.CHANGES:' "':PGM.NAME:'"'
EXECUTE EXLN, //OUT. > CH.OUTC
CH.OUTC = TRIM(CH.OUTC<2>)
CH.OUTC = FIELD(CH.OUTC," ",3):",":FIELD(CH.OUTC," ",12)
OLN = ""; NLN = ""; CHG = ""
READ CHG FROM CH.FILE, PGM.NAME ELSE PRINT "Just wrote it, now I can't find it":; INPUT RSP; STOP
CH.OUT = CH.OUTC:",":CH.OUT
INS CH.OUT BEFORE CHG<1>
WRITE CHG ON CH.FILE, PGM.NAME
END
~COMPARE.PROGS~
*PROGRAM: COMPARE.PROGS 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       COMPARE ALL PROGRAMS FROM <file.name> TO OLD.<file.name> FOR TRANSMISSION OF CHANGES
*
* DATE WRITTEN:      DD MMM YY
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
CO.NAME = OCONV("CO.DATA","TCNT;X;1;1")<1,1,1>
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Compare programs (or other files)"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
!
PRINT @(0,5):CLS:
INPUT AUTO.RUN
NO.OLD = 0; IF AUTO.RUN > 2 THEN NO.OLD = 1; AUTO.RUN = AUTO.RUN - 3
SELECT.DONE = 0; IF AUTO.RUN = 2 THEN SELECT.DONE = 1; AUTO.RUN = 0
IF AUTO.RUN THEN
READ CURRENT.RUN FROM CNT.FILE,"CURRENT.RUN" ELSE STOP
FL.NAME = CURRENT.RUN<1,2>
END ELSE
PRINT "FILE NAME <BP>: ":; INPUT FL.NAME
IF FL.NAME = "" THEN FL.NAME = "BP"
CALL AUTO.LOADER("COMPARE-PROGS",FL.NAME,"Compare ":FL.NAME)
END
PRINT @(0,5):CLS:
DICT.NAME = ""; IF FL.NAME[1,5] = "DICT " THEN DICT.NAME = "DICT "; FL.NAME = FL.NAME[6,99]
IF NOT(SELECT.DONE) THEN
EXLN = 'SSELECT ':DICT.NAME:FL.NAME:'.CHANGES # "$]"'
PRINT EXLN
EXECUTE EXLN, //SELECT. > X
IF X # "" THEN
EXLN = "DELETE ":DICT.NAME:FL.NAME:".CHANGES"
PRINT EXLN
EXECUTE EXLN, //SELECT. < X
END
EXLN = 'SSELECT ':DICT.NAME:FL.NAME:' # "$]"'
PRINT EXLN
EXECUTE EXLN, //SELECT. > FILE.ID.LIST
END
OPEN TRIM(DICT.NAME),FL.NAME TO FL.NUM ELSE STOP
SUMS = ""
DIFFERENCE.FOUND = ""
READ OLD.SUMS FROM FL.NUM, "CHECKSUMS.LIST" ELSE OLD.SUMS = ""
IF SELECT.DONE THEN DELETED.ITEMS = "" ELSE DELETED.ITEMS = OLD.SUMS
AC = 1
LOOP UNTIL DELETED.ITEMS<AC> = "" DO
DELETED.ITEMS<AC> = DELETED.ITEMS<AC,1>
AC = AC+1
REPEAT
PROCESS.DELETES = ""
NXT: *
IF PROCESS.DELETES THEN
ID = DELETED.ITEMS<PROCESS.DELETES>
PROCESS.DELETES = PROCESS.DELETES+1
IF ID = "" THEN STOP
END ELSE
READNEXT ID FROM FILE.ID.LIST ELSE
PROCESS.DELETES = 1
IF DELETED.ITEMS<1> # "" THEN
PRINTER ON
PRINT
PRINTER OFF
OLD.NAME = "OLD.":FL.NAME
CHG.NAME = FL.NAME:".CHANGES"
OPEN TRIM(DICT.NAME),CHG.NAME TO CHG.NUM ELSE STOP
OPEN TRIM(DICT.NAME),OLD.NAME TO OLD.NUM ELSE STOP
ITEM = "\\\DELETED\\\"
AC = 1
LOOP UNTIL DELETED.ITEMS<AC> = "" DO
ID = DELETED.ITEMS<AC>
WRITE ITEM ON CHG.NUM,ID
AC = AC+1
REPEAT
END
IF NOT(SELECT.DONE) THEN
WRITE OLD.SUMS ON FL.NUM,"CHECKSUMS.LIST1"
WRITE SUMS ON FL.NUM,"CHECKSUMS.LIST"
END
GOTO NXT
END
END
IF FL.NAME = "MD" THEN
READV DCODE FROM FL.NUM,ID,1 ELSE DCODE = ""
IF LEN(DCODE) < 3 AND DCODE[1,1] = "D" THEN GOTO NXT
END
IF ID[1,14] = "CHECKSUMS.LIST" THEN GOTO NXT
EXLN = 'CHECK-SUM ':DICT.NAME:FL.NAME:' "':ID:'"'
EXECUTE EXLN, //OUT. > BP.OUT
IF NO.OLD THEN OLD.OUT = "" ELSE
EXLN = 'CHECK-SUM ':DICT.NAME:'OLD.':FL.NAME:' "':ID:'"'
EXECUTE EXLN, //OUT. > OLD.OUT
END
PRINT @(0,5):CLS:
PRINT ID
IF NOT(NO.OLD) THEN
PRINT OLD.OUT<1>
PRINT OLD.OUT<2>
END
PRINT BP.OUT<1>
PRINT BP.OUT<2>
TCL.LINE = BP.OUT<2>
IF PROCESS.DELETES THEN
DELETE OLD.NUM,ID
CSUM = "\\\DELETED\\\"
END ELSE
POS = INDEX(TCL.LINE,"Cksum = ",1)
CSUM = FIELD(TCL.LINE[POS+8,99]," ",1)
LOCATE ID IN DELETED.ITEMS SETTING LOC THEN DEL DELETED.ITEMS<LOC>
END
SUMS<-1> = ID:VM:CSUM
IF OLD.OUT<2> # BP.OUT<2> THEN
PRINTER ON
IF NOT(DIFFERENCE.FOUND) THEN
DIFFERENCE.FOUND = -1
PRINT FF:
PRINT OCONV(DATE(),"D2"):"         Compare of all items in ":DICT.NAME:FL.NAME
PRINT
PRINT
PRINT "                                             Prior to change:              Current:                    bytes"
PRINT "Item.id....................................  ...bytes ......checksum       ...bytes ......checksum      diff"
PRINT
END
PRINT ID "L#45":
TMP = OLD.OUT<2>
GOSUB PARSE.IT
IF BYTES = "" THEN PRINT "Not on file            ": ELSE PRINT BYTES "R#8":CKSUM "R#15":
DIFF = BYTES
TMP = BP.OUT<2>
GOSUB PARSE.IT
IF BYTES = "" THEN PRINT "       Not on file            ": ELSE PRINT BYTES "R#15":CKSUM "R#15":
PRINT (BYTES-DIFF) "R#10"
PRINTER OFF
IF BYTES THEN
EXLN = DICT.NAME:FL.NAME:";":ID
IF NO.OLD THEN EXLN = "*NO.OLD*":EXLN
EXECUTE "RUN BP.UTL COMPARE.PROG", //IN. < EXLN
END
END
GOTO NXT
!
PARSE.IT: *
POS = INDEX(TMP,"Cksum = ",1)
IF NOT(POS) THEN CKSUM = "" ELSE CKSUM = FIELD(TMP[POS+8,99]," ",1)
POS = INDEX(TMP,"Total = ",1)
IF NOT(POS) THEN BYTES = "" ELSE BYTES = FIELD(TMP[POS+8,99]," ",1)
RETURN
!
END
~CONSOLIDATE.CHANGES~
*PROGRAM: CONSOLIDATE.CHANGES 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       CONSOLIDATES BP.CHANGES DATA INTO A SINGLE ITEM
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
PROMPT ""; AM = CHAR(254)
PRINT "WHICH FILE <BP.CHANGES>? ":; INPUT FL.NAME; IF FL.NAME = '' THEN FL.NAME = "BP.CHANGES"
DICT.NAME = ""; IF FL.NAME[1,5] = "DICT " THEN DICT.NAME = "DICT "; FL.NAME = FL.NAME[6,99]
OUTPUT.ID = OCONV(DATE(),"D2"); OUTPUT.ID = "$CHANGES.":OUTPUT.ID[1,2]:OUTPUT.ID[4,3]:OUTPUT.ID[8,2]
PRINT "OUTPUT ID  <":OUTPUT.ID:">? ":; INPUT ID; IF ID # '' THEN OUTPUT.ID = ID
OPEN TRIM(DICT.NAME),FL.NAME ELSE STOP
PRINT "CONSOLIDATE.CHANGES"
EXECUTE 'SSELECT ':DICT.NAME:FL.NAME:' # "$]"', //SELECT. > FILE.ID.LIST
PRINT "Enter max. size (def=15000): ":
INPUT MAX.SIZE
IF MAX.SIZE MATCHES "0N" AND MAX.SIZE > 500 THEN MAX.SIZE = MAX.SIZE-250 ELSE MAX.SIZE = 14750
PRINT
CONSOL.ITEM = ""
CON.AC = 1
WRITE.COUNT = 1
!
NEXT.ITEM: *
READNEXT ID FROM FILE.ID.LIST ELSE
IF CONSOL.ITEM # "" THEN GOSUB WRITE.ITEM
STOP
END
*
READ ITEM FROM ID ELSE GOTO NEXT.ITEM
PRINT ID
CONSOL.ITEM<CON.AC> = "%%%"; CON.AC = CON.AC+1
CONSOL.ITEM<CON.AC> = ID; CON.AC = CON.AC+1
MAX.AC = COUNT(ITEM,AM)+1
FOR AC = 1 TO MAX.AC
LINE = ITEM<AC>
IMAX = LEN(LINE); II = 1
LOOP UNTIL II > IMAX DO
NUMCHAR = SEQ(LINE[II,1])
IF NUMCHAR > 124 OR NUMCHAR = 27 THEN
IF NUMCHAR < 100 THEN NUMCHAR = "0":NUMCHAR
LINE = LINE[1,II-1]:CHAR(125):NUMCHAR:LINE[II+1,999]
II=II+3
IMAX = LEN(LINE)
END
II = II+1
REPEAT
LOOP UNTIL LEN(LINE) < 129 DO
CONSOL.ITEM<CON.AC> = LINE[1,120]
LINE = "...":SPACE(7):LINE[121,999]
CON.AC = CON.AC+1
REPEAT
CONSOL.ITEM<CON.AC> = LINE
CON.AC = CON.AC+1; IF LEN(CONSOL.ITEM) > MAX.SIZE AND AC > 2 THEN GOSUB WRITE.ITEM
NEXT AC
GOTO NEXT.ITEM
!
WRITE.ITEM: *
ID = OUTPUT.ID:".":CHAR(WRITE.COUNT+64)
PRINT; PRINT "  ":ID; PRINT
CONSOL.ITEM = "&&&":AM:"&&&":AM:"&&&":AM:"&&&":AM:"&&&":AM:CONSOL.ITEM
WRITE CONSOL.ITEM ON ID
WRITE.COUNT = WRITE.COUNT+1
CONSOL.ITEM = ""
CON.AC = 1
RETURN
END
~DH.BP.RELEASE.SAVE~
*PROGRAM: DH.BP.RELEASE.SAVE
*
DIM EI.DH.BP.KEY(200)
DIM REC.EI.DH.BP(1200)
MAT REC.EI.DH.BP = ''
MAT EI.DH.BP.KEY = ''
PC = 'To continue enter a "Y"'
LOCT = 1
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN 'SYS.STRUCTURE' TO SYSS ELSE STOP
LOCT = 2
OPEN 'DH.BP' TO DH.BP.FILE ELSE PRINT '?'; STOP
LOCT = 3
MATREAD EI.DH.BP.KEY FROM SYSS,'EI.DH.BP.LIST' ELSE STOP
LOCT = 4
KEY.COUNTER = 0
GOSUB REL.INPUT.SCREEN
PRINT @(10,10):PC:
INPUT CONT
IF CONT # 'Y' THEN GOTO Bottom
PRINT @(0,0):CLS:
PRINT
LOOP
KEY.COUNTER = KEY.COUNTER + 1
WHILE CONT = 'Y' AND EI.DH.BP.KEY(KEY.COUNTER) # '' DO
MATREAD REC.EI.DH.BP FROM DH.BP.FILE,EI.DH.BP.KEY(KEY.COUNTER) ELSE STOP
MATWRITE REC.EI.DH.BP ON DH.BP.FILE,REL.DATE:EI.DH.BP.KEY(KEY.COUNTER)
PRINT @(1):'Was ':EI.DH.BP.KEY(KEY.COUNTER):@(35):', now ':REL.DATE:EI.DH.BP.KEY(KEY.COUNTER):@(70):'. # ':KEY.COUNTER:'.'
IF KEY.COUNTER < 25 THEN RQM
IF KEY.COUNTER < 10 THEN RQM
IF KEY.COUNTER < 5  THEN RQM;RQM
IF KEY.COUNTER < 3  THEN RQM;RQM;RQM
REPEAT
GOTO Bottom
*
REL.INPUT.SCREEN: *#*
*
SC.top: PRINT @(0,0):CLS:
H1 = 'COPY ENTITY INFORMATION PROGRAMS TO A RELEASE'
PRINT @(40-(INT(LEN(H1)/2)),3):RVB:H1:RVE:
H2 = 'DENOTED BY "REL-YYMMDD-program.name"'
PRINT @(40-(INT(LEN(H2)/2)),5):RVB:H2:RVE:
L1 = 'Enter the release date: '
PRINT @(10,8):L1:
REL.DATE = OCONV(DATE(),'DD')
IF LEN(REL.DATE)<2 THEN REL.DATE = '0':REL.DATE
REL.DATE = OCONV(DATE(),'DM'):REL.DATE
IF LEN(REL.DATE)<4 THEN REL.DATE = '0':REL.DATE
REL.DATE = OCONV(DATE(),'D2Y'):REL.DATE
IF LEN(REL.DATE)<6 THEN REL.DATE = '0':REL.DATE
A$ = REL.DATE
INPUT @(12+LEN(L1),8):A$
IF LEN(A$) = 0 THEN A$ = REL.DATE
REL.DATE = A$
D.ERR = 0
IF REL.DATE MATCHES '6N' AND REL.DATE > (OCONV(DATE(),'D2Y') * 10000) & REL.DATE < ((OCONV(DATE(),'D2Y') + 5) * 10000) THEN
D.ERR = 0
END ELSE D.ERR = 1
IF D.ERR # 0 THEN PRINT BELL:'???':; RQM; RQM; GOTO SC.top
REL.DATE = 'REL-':REL.DATE:'-'
PRINT @(50,15):BELL:'Thank you.....':
RQM
RQM
RQM
RETURN
*
*
Bottom: *#*
*
PRINT
PRINT
PRINT 'OVER AND FINISHED, SO LONG CO-RADIATOR.'
RQM
PRINT BELL
PRINT
PRINT
PRINT
PRINT
END
~INSTALL.CHANGES~
*PROGRAM: INSTALL.CHANGES 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       INSTALL CHANGES ONTO ULTIMATE...
* DATE WRITTEN:      31 OCT 86
* DATE RELEASED:     31 OCT 86
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
INPUT AUTO.RUN
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
OPEN "PL" TO PL.FILE ELSE PRINT "Can't open file PL"; INPUT RSP; STOP
OPEN "MD" TO MD.FILE ELSE PRINT "Can't open file MD"; INPUT RSP; STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Install Kbil changes"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
LOOP
CH.DATE = OCONV(DATE(),"D2")
IF AUTO.RUN THEN
READ CURRENT.RUN FROM PAR.FILE,"CURRENT.RUN" ELSE STOP
CH.DATE = CURRENT.RUN<1,2>
END
PRINT @(20,10):CLL:"Date of changes: ":CH.DATE
IF NOT(AUTO.RUN) THEN
PRINT @(37,10):
INPUT RSP
IF RSP = "KILL" THEN STOP
IF RSP = "" THEN RSP = CH.DATE
CH.DATE = ICONV(RSP,"D")
IF CH.DATE # "" THEN CH.DATE = OCONV(CH.DATE,"D2"); PRINT @(37,10):CLL:CH.DATE
END
WHILE CH.DATE = "" DO
PRINT BELL:
REPEAT
*
READ INSTALL.SKELETON FROM PL.FILE,"INSTALL.SKELETON" ELSE
PRINT @(0,23):"INSTALL.SKELETON is missing from file PL -- press <cr>":
INPUT RSP:
STOP
END
*
IF NOT(AUTO.RUN) THEN
PROCS = ""; INPUTS = ""; DESCS = ""
PROCS<1> = "RUN BP.UTL INSTALL.CHANGES"; INPUTS<1> = CH.DATE; DESCS<1> = "Install"
CALL AUTO.LOADER(PROCS,INPUTS,DESCS)
END
*
READ FILE.LIST FROM CNT.FILE,"FILE.LIST" ELSE
PRINT @(0,23):"FILE.LIST not found on CNT -- press <cr> ":CLL:
INPUT RSP:
STOP
END
AC = 1
CHANGES.LOG = ""; WRITE CHANGES.LOG ON CNT.FILE,"CHANGES.LOG"
LOOP
FILE.NAME = FILE.LIST<AC>
UNTIL FILE.NAME = "" DO
PROC = INSTALL.SKELETON
IF FILE.NAME[1,4] = "ULT." THEN FILE.NAME = FILE.NAME[5,99]
LIST.NAME = FILE.NAME
IX = INDEX(LIST.NAME,",",1); IF IX THEN LIST.NAME = LIST.NAME[1,IX-1]:".":LIST.NAME[IX+1,99]
DICT.NAME = ""; IF FILE.NAME[1,5] = "DICT." THEN DICT.NAME = "DICT "; FILE.NAME = FILE.NAME[6,99]
OPEN TRIM(DICT.NAME),FILE.NAME:".CHANGES" TO CH.FILE THEN
CH.ID = "$CHANGES.":CH.DATE[1,2]:CH.DATE[4,3]:CH.DATE[8,2]:".A"
PRINT @(0,0):CLS:"Installing changes dated ":CH.DATE:" for ":DICT.NAME:FILE.NAME:":"
PRINT
READV CH.ATTR FROM CH.FILE,CH.ID,1 THEN
LOOP
IX = INDEX(PROC,"@@@@D",1)
WHILE IX DO
PROC = PROC[1,IX-1]:DICT.NAME:PROC[IX+5,9999]
REPEAT
LOOP
IX = INDEX(PROC,"@@@@F",1)
WHILE IX DO
PROC = PROC[1,IX-1]:FILE.NAME:PROC[IX+5,9999]
REPEAT
LOOP
IX = INDEX(PROC,"@@@@L",1)
WHILE IX DO
PROC = PROC[1,IX-1]:LIST.NAME:PROC[IX+5,9999]
REPEAT
LOOP
IX = INDEX(PROC,"@@@DT",1)
WHILE IX DO
PROC = PROC[1,IX-1]:CH.DATE:PROC[IX+5,9999]
REPEAT
WRITE PROC ON MD.FILE,"$$$INSTALL.CHANGES$$$"
EXECUTE "$$$INSTALL.CHANGES$$$"
END
END
AC = AC+1
REPEAT
STOP
!
END
~LMD.INSTALL~
*PROGRAM: LMD.INSTALL
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*
OPEN "LISTS" TO LST.FILE ELSE STOP
*
PRINT CLL:"[=! ":"Enter name of Accounts list (KBIL.ACCOUNTS): ":; INPUT ACCT.LIST.ID
IF ACCT.LIST.ID EQ EMPTY THEN ACCT.LIST.ID = "KBIL.ACCOUNTS"
IF ACCT.LIST.ID EQ "KILL" THEN STOP
*
READ ACCT.IDS FROM LST.FILE,ACCT.LIST.ID ELSE
ACCT.IDS = "PROGRAMS":AM:"DEMO"
END
*
!
*
PRINT CLL:"[=! ":"Enter name of Verbs lists (KBIL.VERB.LIST): ":; INPUT ITEM.LIST.ID
IF ITEM.LIST.ID EQ EMPTY THEN ITEM.LIST.ID = "KBIL.VERB.LIST"
IF ITEM.LIST.ID EQ "KILL" THEN STOP
*
READ ITEM.IDS FROM LST.FILE,ITEM.LIST.ID ELSE
PRINT CLL:"[=| ":"Enter item name: ":; INPUT ITEM.NAME
IF ITEM.NAME EQ EMPTY THEN STOP
IF ITEM.NAME EQ "KILL" THEN STOP
ITEM.IDS = ITEM.NAME
END
*
!
*
LOOP
PRINT CLL:"[=| ":"Enter file name: ":; INPUT FILE.NAME
IF FILE.NAME EQ "KILL" THEN STOP
WHILE FILE.NAME EQ EMPTY DO PRINT BELL: REPEAT
*
!
*
CONT = TRUE
CN = FALSE
ACCT.IDS.MAX = DCOUNT(ACCT.IDS,AM)
*
!
*
LOOP
*
***READNEXT ITEM.ID ELSE CONT = FALSE
LOOP
ITEM.ID = ITEM.IDS<ONE>
DEL ITEM.IDS<ONE>
WHILE ITEM.ID[ONE,ONE] EQ "*" DO REPEAT
IF ITEM.ID EQ EMPTY THEN CONT = FALSE
*
WHILE CONT DO
*
PRINT CLL:"[=| "
PRINT CLL:"[=| ":CN "R#3":") ":ITEM.ID
CN = CN + 1
*
!
*
FOR ACCT.ID.CN = ONE TO ACCT.IDS.MAX
*
PRINT "[=| Account: ":ACCT.IDS<ACCT.ID.CN>
*
EXEC.LINE = "MD.INSTALL ":FILE.NAME:" ":ITEM.ID:" ":ACCT.IDS<ACCT.ID.CN>
PRINT CLL:"[=| ":"Install ":EXEC.LINE:
*
EXECUTE EXEC.LINE
*
*
NEXT ACCT.IDS.CN
*
*
REPEAT
*
*
END
~MENU~
X*PROGRAM: MENU.HANDLER
*
* AUTHOR:            DAVID STERN - AXION
*                    DAVID HORSMAN - AXION
*
* DESCRIPTION:       FORMAT AND DISPLAY MENUS FROM FILE 'MENUS'
* DATE WRITTEN:      11 AUG 83
* DATE RELEASED:     DD MMM YY
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
*
*
* MODES: 0 - ERROR CONDITION
*
*        1 - SUMMARY OVERVIEW   - MARKETTING  - SALES DOC WITHIN MENUS
*
*        2 - SUMMARY            -     "       - SALES AND OPERATOR
*              DEMONSTRATION                     DOC. WITHIN MENUS
*
***** POINT WHERE PROGRAMS ARE EXECUTED.
*
*        3 - DETAILED           -     "       - OPERATOR DOC. WITHIN MENUS
*              DEMONSTRATION      TRAINING       AND FIELDS WITHIN PROGS.
*
***** POINT WHERE ACTUAL ENTRY OF DATA OCCURS.
*
*        4 - DETAILED ENTRY     - TRAINING    - OPERATOR DOC. PRIOR TO
*                                                ENTRY OF ALL FIELDS. LONG
*                                                FIELD NAMES.
*
*        5 - SUMMARY ENTRY      - TRAINING    - NO DOC. LONG FIELD NAMES.
*
*        6 - REGULAR MODE       - NORMAL      - NORMAL FIELD NAMES ARE USED
*                                  OPERATIONS    ,MULTIPLE SCREENS.
*
*        7 - DEVELOPMENT MODE   - DEVELOPMENT - CREATION OF NON-EXISTANT
*                                                PROCEDURES AND PROGRAMS
*
*        8 - DOCUMENTATION MODE - DOCUMENTING - CREATION OF VARIOUS LEVELS
*                                                OF DOCUMENTATION
*
*        9 - TEST MODE          - SYSTEMS     - TESTING OF SYSTEM USING
*                                   TESTING      TEST FILES.
*
*       10 - NOT IN USE
*
*       11 - MACH 01           - CONDENSED    - SHORTENED FIELD NAMES,
*                                  SCREENS       SINGLE SCREENS, COMBINED
*                                                MENUS, ETC.
*
*     > 11 - MACH 2 to 10      - AS PER MACH 01 BUT WITH PROGRESSIVELY
*                                  HIGHER TIME SLICES ASSIGNED TO USER.
*
*        
!
TERMINAL = '?'
*$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP STANDARD.FUNCTIONS
!
OPEN 'SYS' TO SY.FILE ELSE PRINT 'No SYS file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
OPEN 'MENUS' TO MU.FILE ELSE PRINT 'No MENUS file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
OPEN 'MD' TO MD.FILE ELSE PRINT 'No MD file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
OPEN 'ACC' TO AC.FILE ELSE PRINT 'No ACC file':; INPUT RSP:; CHAIN 'MENU-RUN OFF'
OPEN 'DICT','MAIL' TO MAIL.FILE THEN CHECK.MAIL = 1 ELSE CHECK.MAIL = ''
OPEN 'HLP' TO HLP.FILE ELSE PRINT 'No HLP file':; INPUT RSP:; STOP
OPEN 'TIME.RECS' TO TM.FILE THEN RECORD.TIME = 1 ELSE PRINT 'No TIME.RECS file':; INPUT RSP:; RECORD.TIME = ''
*
DIM MENU(100),ROUTE(100),PRMPT(100),VALIDS(100),VALID.USERS(100),TYPES(100),FILES(100),STEPS(100),SUBJT(100),USER(101)
*
CALL.ID = 'MENU.':PORT
INPUT MENU.NAME:
IF MENU.NAME = '' THEN GOSUB Log.in.to.menu
*
READ CO.DATA FROM MD.FILE,'CO.DATA' ELSE CO.DATA = ''
CO.NAME = CO.DATA<1,1,1>; CONTROL.DATE = CO.DATA<2,1,1>
*
SYS11.MODE = 0
MODE.PRINT = 0; SYS11.MODE = 0
*
* VERIFY DATE IF IT DOES NOT MATCH CONTROL (Don't worry if before 3:00 next morning!)
IF CONTROL.DATE # DATE() THEN IF NOT(DATE() = CONTROL.DATE+1 & TIME() < 10000) THEN CALL MAINT.CONTROL.DATE(CO.DATA,MD.FILE)
*
PRINT CLS:
RECORD.TIME.1 = ''
READ USER.NAME FROM SY.FILE,'MENU.USER.':PORT THEN RECORD.TIME.1 = 1 ELSE
PRINT; PRINT 'WHO IS THAT? ':
INPUT USER.NAME:
READ USER.DATA FROM SY.FILE,'@M@USER@':USER.NAME ELSE CHAIN 'MENU-RUN OFF'
IF USER.DATA<1> # USER.NAME THEN
READ USER.DATA FROM SY.FILE,'@M@USER@':USER.DATA<1> ELSE CHAIN 'MENU-RUN OFF'
END
USER.NAME = USER.DATA<1>
PRINT
PRINT 'Your password? ':
ECHO OFF; INPUT PASS.INPUT:; ECHO ON
IF PASS.INPUT # USER.DATA<2> THEN CHAIN 'MENU-RUN OFF'
IF LEN(USER.DATA<3,3>) = 0 THEN USER.DATA<3,3> = USER.DATA<3,1>
IF LEN(USER.DATA<3,4>) = 0 THEN USER.DATA<3,4> = 0
WRITE USER.NAME ON SY.FILE,'MENU.USER.':PORT
WRITE USER.DATA ON SY.FILE,'@M@USER@':USER.NAME:'@':PORT
END
READ USER.DATA FROM SY.FILE,'@M@USER@':USER.NAME:'@':PORT ELSE
DELETE SY.FILE,'@M@USER@':USER.NAME:'@':PORT
DELETE SY.FILE,'MENU.USER.':PORT
CHAIN 'MENU-RUN OFF'
END
OPER.MODE = USER.DATA<3,3>
MODE.PRINT = USER.DATA<3,4>
IF OPER.MODE = '' THEN OPER.MODE = USER.DATA<3,1>
IF OPER.MODE = '' THEN
READV OPER.MODE FROM AC.FILE,'OPER.MODES',PORT ELSE GOSUB 3000
USER.DATA<3,1> = OPER.MODE
USER.DATA<3,3> = OPER.MODE
END
IF LEN(OPER.MODE) = 0 ! OPER.MODE = 0 ! OPER.MODE > 20 THEN GOSUB 3000
SYS11.MODE = USER.DATA<3,2>
IF SYS11.MODE = '' THEN
READV SYS11.MODE FROM AC.FILE,'TYPE.AHEAD',PORT ELSE GOSUB 4000
USER.DATA<3,2> = SYS11.MODE
END
DIM MODE.DESC(20)
MATREAD MODE.DESC FROM SY.FILE,'@M@OPER.MODE.DESC' ELSE MAT MODE.DESC = 'READ ERROR on'; MODE.PRINT = 1
ROUTING = ''
LOOP
PRMPTING = ''
USER.NEW = 0
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE
IF OPER.MODE = 7 THEN
PRINT @(0,23):CLL:BELL:@(20):'Maintain menu? ':;INPUT A$
IF A$ = 'Y' THEN
CHAIN 'EI.MENUS.DEV M ':MENU.NAME
END ELSE
MENU.NAME = '/'
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE CHAIN 'MENU-RUN OFF'
END
END ELSE
MENU.NAME = '/'
MATREAD MENU FROM MU.FILE,MENU.NAME ELSE CHAIN 'MENU-RUN OFF'
END
END
*
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),'D2') 'L#20':(SPACE(20-LEN(CO.NAME)/2+.5):CO.NAME) 'L#40':('Port ':PORT) 'R#20':
*
PRINT @(0,1):OCONV(TIME(),'MTS') 'L#15':(SPACE(25-LEN(MENU(1)<1,6>)/2+.5):MENU(1)<1,6>) 'L#50':('Acct ':ACCT) 'R#15':
*
PRINT @(0,2):('User ':USER.DATA<1>) 'L#20':(SPACE(20-LEN(MENU(1)<1,1>)/2+.5):MENU(1)<1,1>) 'L#40':
*
IF MODE.PRINT = 1 THEN PRINT (MODE.DESC(OPER.MODE):' mode') 'R#20':RVE: ELSE PRINT SPACE(20):RVE: 
*
IF CHECK.MAIL THEN READ MAIL.ITEM FROM MAIL.FILE,ACCT THEN
IF MAIL.ITEM<1> # '' THEN PRINT @(10,10):BELL:'**** Mail for ':ACCT:' ****':; INPUT RSP; PRINT @(10,10):CLL:
END
*
IF USER.DATA<4> # MENU(1)<1,6> THEN USER.DATA<5> = ''; USER.DATA<4> = MENU(1)<1,6>
USER.KEY.WRK = '@M@STATUS@':USER.NAME:'@':MENU.NAME
MATREAD USER FROM SY.FILE,USER.KEY.WRK ELSE
MAT USER = ''
IF MENU(1)<1,2> = 1 THEN USER(1)<1,PORT+1> = USER.DATA<5> ELSE USER(1)<1,PORT+1> = ''
MATWRITE USER ON SY.FILE,USER.KEY.WRK
END
IF USER(1)<1,PORT+1> # '' & USER(1)<1,PORT+1> # ' ' THEN USER.DATA<5> = USER(1)<1,PORT+1>
Input.topic: IF (USER.DATA<5> = '' ! USER.DATA<5> = ' ') & MENU(1)<1,2> = 1 THEN
PRINT @(0,3):CLS:
PRINT @(20,15):CLL:BELL:MENU(1)<1,3>:
INPUT MENU.WRK:
USER.DATA<5> = MENU.WRK
USER(1)<1,PORT+1> = MENU.WRK
WRITEV USER(1) ON SY.FILE,USER.KEY.WRK,1
PRINT @(20,15):CLL:
END
WRITE USER.DATA ON SY.FILE,'@M@USER@':USER.NAME:'@':PORT
IF MENU(1)<1,2> = 1 & USER.DATA<5> # '' & USER.DATA<5> # ' ' THEN
USER.KEY = USER.KEY.WRK:'@':USER.DATA<5>
USER.NEW = 0
MATREAD USER FROM SY.FILE,USER.KEY ELSE
MAT USER = ''
USER(1)<1,PORT+1> = USER.DATA<5>
MATWRITE USER ON SY.FILE,USER.KEY
USER.NEW = 1
END
END
MAT ROUTE = ''; MAT PRMPT = ''; MAT VALID.USERS = ''; MAT TYPES = ''; MAT FILES = ''
MAT STEPS = ''; MAT SUBJT = ''
VALID.USER = ''; TYPING = ''; FILING = ''; STEPED = ''; SUBJCT = ''
AC = 3; CL = 22; LN = 4
LS = 999; NUM = 1
LOOP AC = AC + 1; LINE = MENU(AC) UNTIL LINE = '' ! AC = 100 DO
IF LINE<1,1> = '>' THEN
VALID.ACCTS = LINE<1,4>
VALID = 1
IF VALID.ACCTS # ' ' & VALID.ACCTS # '' THEN LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN CL = 2
END ELSE IF LINE<1,1>[1,1] # '*' & LINE<1,1>[1,1] # '+' THEN
NUM = NUM + 1
ST = LINE<1,8>
IF USER.NEW THEN USER(NUM) = 'Not started'
MENU(AC)<1,10> = USER(NUM)<1,1>
IF ST # '0' & ST # '' AND ST # ' ' THEN
IF ST < LS & USER(NUM)<1,1> # 'Complete' THEN LS = ST
END
END
REPEAT
IF USER.NEW = 1 THEN
MATWRITE USER ON SY.FILE,USER.KEY
USER.NEW = 0
END
MAX.AC = AC
LOOP NUM = NUM + 1 WHILE NUM < 101 & USER(NUM) # '' DO USER(NUM) = '' REPEAT
IF USER(NUM) # '' & NUM < MAX.AC + 1 THEN USER(NUM) = ''
*
NUM = 1; PR.FL = 0
FOR AC = 3 TO MAX.AC
LINE = MENU(AC)
VALID = 1; VALID.ACCTS = LINE<1,4>
IF VALID.ACCTS # ' ' & VALID.ACCTS # '' THEN LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN
TEXT = LINE<1,1>
IF TEXT = '>' THEN CL = 42; LN = 4; PRINT @(CL,LN): ELSE
*
IF TEXT[1,1] = '*' THEN
PR.FL = 0
IF TEXT # '*' THEN PRINT @(CL-2,LN):TEXT[2,99]
END ELSE IF TEXT[1,1] = '+' THEN
*
PRINT @(CL,LN):'    ':
IF LS> 0 & LS < 999 THEN PRINT '    ':
IF PR.FL = 1 THEN PRINT RVB:TEXT[2,99]:RVE: ELSE PRINT TEXT[2,99]:
END ELSE
*
ROUTE(NUM) = LINE<1,2>
PRMPT(NUM) = LINE<1,3>; IF PRMPT(NUM) = ' ' ! PRMPT(NUM) = '' THEN PRMPT(NUM) = NUM
VALIDS(NUM) = LINE<1,4>
VALID.USERS(NUM) = LINE<1,5>
TYPES(NUM) = LINE<1,6>
FILES(NUM) = LINE<1,7>
STEPS(NUM) = LINE<1,8>
SUBJT(NUM) = LINE<1,9>
IF TEXT # '' & TEXT # ' ' THEN PRINT @(CL,LN):RVB:PRMPT(NUM) 'R#3':RVE:
IF MENU(1)<1,8> = 'P' ! (STEPS(NUM) # '0' & STEPS(NUM) # '' & STEPS(NUM) # ' ') THEN
PRINT ' ':STEPS(NUM) 'R#2':'.':
END ELSE IF LS > 0 AND LS < 999 THEN PRINT '    ': ELSE PRINT '    ':
IF STEPS(NUM) # LS THEN PRINT ' ':TEXT ELSE
PRINT ' ':RVB:TEXT:RVE:'   ':LINE<1,10>:
PR.FL = 1
END
NUM = NUM+1
END
END
LN = LN+1
END
NEXT AC
PRMPTING = MENU.NAME; GOSUB Log.out.of.menu
*
*
IF USER.DATA<5> # '' & USER.DATA<5> # ' ' THEN PRINT @(0,3):CLL:MENU(1)<1,3>:' ':USER.DATA<5>: ELSE PRINT @(0,3):CLL:
*
LOOP
Input.rsp: RSP=''
SYS11.PR = 0
PRINT @(20,23):CLL:'Enter your choice: ':
IF SYS11.MODE = 1 THEN
SYS11.MODE.DATE=DATE()
SYS11.MODE.TIME=TIME()
LOOP WHILE SYSTEM(11) = 0 & LEN(RSP) = 0 DO
SYS11.M.N.DATE=DATE()
SYS11.M.N.TIME=TIME()
SYS11.ELP = SYS11.M.N.TIME - SYS11.MODE.TIME
IF SYS11.ELP > 10 THEN RQM
IF SYS11.M.N.DATE > SYS11.MODE.DATE ! SYS11.ELP > 60 THEN
IF OPER.MODE < 3 THEN RSP = 'BYE' ELSE
IF SYS11.ELP > 300 THEN
IF SYS11.PR = 0 THEN PRINT @(0,23):CLL:RVB:'WAIT status':RVE:@(20):'Enter your choice: ':
SYS11.PR = 1
RQM; RQM
END
IF SYS11.ELP > 7200 THEN RSP = 'OFF'
END
END
REPEAT
IF SYS11.PR # 0 THEN PRINT @(0,23):BELL:'Welcome back...':@(20):'Enter your choice: ':; RQM
END
IF LEN(RSP)=0 ! NOT(SYS11.MODE = 1) THEN INPUT RSP:
*
*
IF RSP = 'MODE' & (OPER.MODE > 3 ! USER.DATA<3,1> > 3) THEN
PRINT @(20,23):CLL:'Enter Mode #: ':; INPUT MODE.ENT:
IF MODE.ENT = 'PRINT' THEN
IF MODE.PRINT = 1 THEN MODE.PRINT = 0 ELSE MODE.PRINT = 1
USER.DATA<3,4> = MODE.PRINT
WRITE USER.DATA ON SY.FILE,'@M@USER@':USER.NAME:'@':PORT
END
IF MODE.ENT = 'NEXT' & (OPER.MODE < 6 ! USER.DATA<3,1> > 6) & OPER.MODE < 21 THEN MODE.ENT = OPER.MODE + 1
IF NUM(MODE.ENT) THEN
IF MODE.ENT > 0 AND MODE.ENT < 21 & NOT(MODE.ENT > USER.DATA<3,1>) THEN
OPER.MODE = MODE.ENT
USER.DATA<3,3> = OPER.MODE
WRITE USER.DATA ON SY.FILE,'@M@USER@':USER.NAME:'@':PORT
PRINT @(20,23):CLL:BELL:'MODE RESET TO ':MODE.DESC(OPER.MODE):
END
END ELSE PRINT @(20,23):CLL:'MODE NOT RESET!':
RQM
PRINT @(0,23):CLL:
GOTO Input.rsp
END
*
*
IF RSP = 'TOPIC' & MENU(1)<1,2> = 1 THEN USER.DATA<5> = ''; GOTO Input.topic
*
IF RSP = '' THEN
IF OPER.MODE > 3 THEN ROUTING = MENU(1)<1,5> ELSE
READ ILSE.DISPLAY FROM SY.FILE,'@ILSE.DISPLAY' ELSE ILSE.DISPLAY = '/SL'
IF MENU.NAME # ILSE.DISPLAY THEN ROUTING = MENU(1)<1,5>
END
END ELSE
*
IF INDEX('*OFF*off*END*end*STOP*stop*HALT*halt*Off*','*':RSP:'*',1) # 0 & OPER.MODE > 1 THEN ROUTING = 'OFF'
IF INDEX('*TCL*tcl*Tcl*','*':RSP:'*',1) # 0 & OPER.MODE > 5 THEN ROUTING = 'TCL'
IF INDEX('*BYE*bye*LOGOFF*Logoff*','*':RSP:'*',1) # 0 THEN ROUTING = 'OFF'
IF OPER.MODE > 6 & OPER.MODE < 10 THEN
IF RSP = 'MENU' THEN CHAIN 'EI.MENUS.DEV M ':MENU.NAME
IF RSP = 'EDIT.MENU' THEN CHAIN 'EDIT MENUS ':MENU.NAME
END
*
IF RSP[1,1] = '?' THEN
SUB = ''; RSP = TRIM(RSP[2,99]); HELP = 1
IF RSP[1,1] = '?' THEN RSP = RSP [2,99]; HELP =2 
IF RSP[1,1] = '?' THEN RSP = RSP [2,99]; HELP = 3
IF RSP[1,1] = '?' THEN RSP = RSP [2,99]; IF OPER.MODE > 6 & OPER.MODE < 10 THEN HELP = 4
END ELSE SUB = FIELD(RSP,'/',2); RSP = FIELD(RSP,'/',1); HELP = ''
IF SUB # '' THEN
READ DEFAULTS FROM MU.FILE,'DEFAULTS' THEN GOSUB 1000
IF ROUTING # '' THEN READ DEFAULTS FROM MU.FILE,'/':RSP THEN RSP = SUB; GOSUB 1000
END ELSE
FOR NUM = 1 TO 100 UNTIL PRMPT(NUM) = RSP ! PRMPT(NUM) = ''; NEXT NUM
IF NUM <= 100 & PRMPT(NUM) # '' THEN
VALID.ACCTS = VALIDS(NUM); ROUTING = ROUTE(NUM); PRMPTING = PRMPT(NUM)
VALID.USER = VALID.USERS(NUM); TYPING = TYPES(NUM); FILING = FILES(NUM)
STEPED = STEPS(NUM); SUBJCT = SUBJT(NUM)
END ELSE READ DEFAULTS FROM MU.FILE,'DEFAULTS' THEN GOSUB 1000
END
IF ROUTING<1,1,2> # '' THEN
PRINT @(20,23):CLL:'Enter your password: ':
ECHO OFF; INPUT RSP:; ECHO ON
IF RSP = ROUTING<1,1,2> THEN ROUTING = ROUTING<1,1,1> ELSE ROUTING = ''
END
IF HELP & ROUTING # '' THEN
GOSUB 2000
ROUTING = MENU.NAME
END
IF OPER.MODE < 3 ! OPER.MODE = 8 THEN HELP = 3; GOSUB 2000
IF (OPER.MODE > 1 AND OPER.MODE < 5) ! OPER.MODE = 8 THEN HELP = 2; GOSUB 2000; HELP = 1; GOSUB 2000
IF OPER.MODE < 3 THEN ROUTING = MENU.NAME
END
WHILE ROUTING = '' ! ROUTING = ' ' DO PRINT BELL: REPEAT
TYPING.ITEM = ''
IF TYPING[1,1] = 'D' THEN
IF TYPING[2,1] = 'M' ! TYPING[2,1] = 'N' THEN
TYPING.ITEM = '@':MENU.NAME[2,20]:'@':PRMPTING:'@':USER.DATA<1>
IF USER.DATA<5> # '' & MENU(1)<1,2> = 1 THEN
IF TYPING[2,1] = 'M' THEN TYPING.ITEM = TYPING.ITEM:'@':USER.DATA<5> ELSE
IF MENU(1)<1,4> # '' AND MENU(1)<1,4> # ' ' THEN TYPING.ITEM = TYPING.ITEM:'@':MENU(1)<1,4>:USER.DATA<5>
END
END
END ELSE
IF TYPING[2,1] = 'D' THEN TYPING.ITEM = ' 0 (I)' ELSE
IF TYPING[2,1] = 'P' THEN TYPING.ITEM = ' 0 (I,P)' ELSE
IF TYPING[2,1] = 'A' THEN TYPING.ITEM = ' *' ELSE
IF TYPING[2,1] = "T" THEN TYPING.ITEM = '"':MENU(1)<1,4>:USER.DATA<5>:'"' ELSE
IF TYPING[2,1] = "Z" THEN TYPING.ITEM = '"':USER.DATA<5>:'"'
END
END
END
END
END
IF TYPING[3,1] = 'P' THEN TYPING.ITEM = TYPING.ITEM:' (P)'
IF TYPING[3,1] = 'D' THEN TYPING.ITEM = TYPING.ITEM:' (T)'
GOSUB Log.out.of.menu
PRINT FF:
EXECUTE ROUTING:' ':FILING:' ':TYPING.ITEM
PRINT @(0,23):CLL:'Enter <cr> to return to menu    ':
INPUT RSP:
GOSUB Log.in.to.menu
ROUTING = MENU.NAME
END ELSE
IF TYPING[1,1] = 'C' THEN
CN = 1
LOOP CN = CN + 1; TC = TYPING[CN,1] WHILE TC # '' DO
IF TC = 'A' THEN TYPING.ITEM = TYPING.ITEM:' ':MENU(1)<1,7> ELSE
IF TC = 'M' THEN TYPING.ITEM = TYPING.ITEM:' ':MENU.NAME[2,99] ELSE
IF TC = 'N' THEN TYPING.ITEM = TYPING.ITEM:' @NULL' ELSE
IF TC = 'O' THEN TYPING.ITEM = TYPING.ITEM:' ':PRMPTING ELSE
IF TC = 'P' THEN TYPING.ITEM = TYPING.ITEM:' @PRESTORES' ELSE
IF TC = 'S' THEN TYPING.ITEM = TYPING.ITEM:' ':SUBJCT ELSE
IF TC = 'T' THEN TYPING.ITEM = TYPING.ITEM:' ':MENU(1)<1,4>:USER.DATA<5> ELSE
IF TC = 'U' THEN TYPING.ITEM = TYPING.ITEM:' ':USER.NAME ELSE
IF TC = 'Z' THEN TYPING.ITEM = TYPING.ITEM:' ':USER.DATA<5>
END
END
END
END
END
END
END
END
REPEAT
END
END
WHILE ROUTING[1,1] = '/' DO MENU.NAME = ROUTING REPEAT
*
PRINT @(0,3):CLS:
PARAM = FIELD(ROUTING,' ',2)
IF PARAM # '' THEN
PARAM = ' ':PARAM
ROUTING = FIELD(ROUTING,' ',1)
END
GOSUB Log.out.of.menu
OPEN 'CNT' TO CNT.FILE ELSE PRINT 'CNT':; INPUT RSP:; STOP
READ VALID.TABLE FROM CNT.FILE, 'VALID.ACCTS' ELSE VALID.TABLE = ''
VALID.TABLE<PORT+1> = VALID.ACCTS
WRITE VALID.TABLE ON CNT.FILE, 'VALID.ACCTS'
*IF ROUTING = 'OFF' OR ROUTING = 'TCL' THEN
IF ROUTING = 'OFF' THEN
DELETE SY.FILE,'@M@USER@':USER.NAME:'@':PORT
DELETE SY.FILE,'MENU.USER.':PORT
PRINT FF:@(10,10):BELL:'Thank you ':USER.NAME:'. I am now ending.':
RQM; RQM
END
CHAIN 'MENU-RUN ':ROUTING:TYPING.ITEM
!
1000 * DEFAULTS
AC = 3
LOOP DEFAULT = DEFAULTS<AC> UNTIL DEFAULT<1,3> = RSP ! DEFAULT = '' DO AC = AC+1 REPEAT
IF DEFAULT = '' THEN ROUTING = ''; RETURN
VALID = 1; VALID.ACCTS = DEFAULT<1,4>
IF VALID.ACCTS # ' ' & VALID.ACCTS # '' THEN LOCATE ACCT IN VALID.ACCTS<1,1> SETTING VALID ELSE VALID = 0
IF VALID THEN ROUTING = DEFAULT<1,2> ELSE ROUTING = ''
RETURN
!
2000 * HELP MESSAGES
PRINT @(0,2):CLS
IF HELP = 1 THEN DOCUMENT = ROUTING
IF HELP = 2 THEN DOCUMENT = '?':ROUTING
IF HELP = 3 THEN DOCUMENT = '??':ROUTING
IF HELP = 4 THEN DOCUMENT = '???':ROUTING
DEV.ED = 0
READV HLP.1 FROM HLP.FILE, MENU(1)<1,6>:'.':DOCUMENT, 1 THEN
EXECUTE 'RUNOFF HLP ':MENU(1)<1,6>:'.':ROUTING
PRINT @(0,23):CLL:'Enter <cr> to return to menu    ':
INPUT RSP:
END ELSE DEV.ED = 1
IF (DEV.ED = 1 & OPER.MODE > 6 & OPER.MODE < 10) ! OPER.MODE = 8 THEN
PRINT @(0,23):CLL:'Do you want to edit this Document? ':
INPUT A$
IF INDEX('*Y*y*Yes*yes*','*':A$:'*',1) # 0 THEN
EXECUTE 'EDIT HLP ':MENU(1)<1,6>:'.':DOCUMENT
END
END
RETURN
!
3000 * SET MODE ON DEFAULT AND GOTO OFF
WRITEV '6' ON AC.FILE,'OPER.MODES',PORT
CHAIN 'MENU-RUN MENU.ERROR'
RETURN
!
4000 * SET TYPE.AHEAD ON DEFAULT AND GOTO OFF
RSP = 'Y'
IF OPER.MODE = 1 ! OPER.MODE = 5 THEN
PRINT @(0,0):CLS:@(0,10):'Does this system support type-ahead? ':
INPUT @(40,10):RSP
IF LEN(RSP) = 0 THEN RSP = 'Y'
END
IF RSP = 'Y' THEN
WRITEV '1' ON AC.FILE,'TYPE.AHEAD',PORT
END ELSE
WRITEV '0' ON AC.FILE,'TYPE.AHEAD',PORT
END
CHAIN 'MENU-RUN MENU.ERROR'
RETURN
!
Log.out.of.menu: *#* WRITE OUT GOING TRACE RECORD
IF PRMPTING = '' ! PRMPTING = ' ' THEN TIME.VAL = ROUTING ELSE TIME.VAL = PRMPTING
IF USER.DATA<5> # '' & USER.DATA<5> # ' ' THEN TIME.VAL = TIME.VAL:'@':USER.DATA<5>
WRITE AM:TIME.VAL:AM:(DATE()+100000)[2,5]:(TIME()+100000)[2,5]:AM:MENU.NAME:AM:USER.NAME:AM:OPER.MODE ON AC.FILE,CALL.ID
RETURN
!
Log.in.to.menu: *#* WRITE TIME RECORD WITH ELASPED TIME AND FUNCTION
NEW.DATE = DATE()
NEW.TIME = TIME()
READ MENU.DATA FROM AC.FILE,CALL.ID THEN
MENU.NAME = MENU.DATA<4>
OLD.DATE = MENU.DATA<3>[1,5]
OLD.TIME = MENU.DATA<3>[6,5]
IF NEW.DATE # OLD.DATE THEN
ELP.TIME = 86400 - OLD.TIME + NEW.TIME
END ELSE
ELP.TIME = NEW.TIME - OLD.TIME
END
TIME.KEY = '@':MENU.DATA<5>:'@':MENU.DATA<4>:'@':MENU.DATA<2>
READ TIME.REC FROM TM.FILE,TIME.KEY THEN TIME.REC = TIME.REC:AM ELSE TIME.REC = ''
WRITE TIME.REC:OLD.DATE:VM:OLD.TIME:VM:ELP.TIME:VM:MENU.DATA<6> ON TM.FILE,TIME.KEY
END ELSE
PRINT 'No menu record':
INPUT RSP:
CHAIN 'MENU-RUN OFF'
END
RETURN
END
~MENU.CONVERT~
*PROGRAM: MENU.CONVERT
*
* AUTHOR: DAVID HORSMAN
*
IF ROUTING[LEN(ROUTING)-1,2] = ".?" THEN
ROUTING = ROUTING[1,LEN(ROUTING)-2]
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = ""
LOCATE ROUTING IN SPECIAL.ROUTINES<1> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<2,LOC>
ROUTING = ROUTING:".":ROUTINE.SUFFIX
END
@@@
$INCLUDE IBP STANDARD.FUNCTIONS
DIM MENU(100),OUT.MENU(100)
SYS.PROG = "MENU.CONVERT"
SYS.LOCT = ""
SYS.SLOC = ""
RUN.DATE = DATE()
RUN.TIME = TIME()
PRINTER ON
PRINT FF:SYS.PROG
PRINT
PRINT
PRINT OCONV(RUN.DATE,"D2"):"     ":OCONV(RUN.TIME,"MTS"):
PRINT
PRINT
PRINTER OFF
OPEN 'MENUS' TO MU.FILE ELSE STOP
OPEN "SYS" TO SY.FILE ELSE STOP
CONT = 1
MENU.NUM = 0
OLD.DELETE = 0
PRINT
PRINT
PRINT "Enter new prefix for keys: ":; INPUT NEW.PREFIX
IF NEW.PREFIX = "" THEN OLD.DELETE = 0 ELSE
PRINT
PRINT "DELETE OLD?":
INPUT OLD.DELETE:
IF OLD.DELETE = "YES" THEN OLD.DELETE = 1
IF NOT(NUM(OLD.DELETE)) THEN OLD.DELETE = 0
IF OLD.DELETE # 1 THEN OLD.DELETE = 0
END
PRINT
PRINT "OK?":; INPUT RSP:
PRINT
PRINT
IF RSP = "N" THEN STOP
PRINTER ON
PRINT; PRINT "OLD.DELETE: ":OLD.DELETE
PRINT; PRINT "NEW PREFIX: ":NEW.PREFIX
PRINT; PRINT; PRINT; PRINT
LOOP
READNEXT ID ELSE CONT = 0
WHILE CONT DO
IF ID[1,4] = "@AS@" THEN
*
MATREAD MENU FROM MU.FILE,ID THEN
*
*
*
*
MAT OUT.MENU = MAT MENU
CN = 1
LOOP CN = CN + 1 WHILE CN < 50 AND OUT.MENU(CN) # "" DO
*
*TEMP = OUT.MENU(CN)<1,6>
*TEMP1 = ""
*LOOP WHILE LEN(TEMP) # 0 DO
*TC = TEMP[1,1]
*TEMP = TEMP[2,99]
*IF TC = ' ' THEN TC = SVM
*TEMP1 = TEMP1:TC
*REPEAT
*LOOP WHILE LEN(TEMP1) > 0 AND LEN(TEMP1<1,1,1>) = 0 DO DEL TEMP1<1,1,1> REPEAT
*
IF OUT.MENU(CN)<1,2>[1,1] # "/" THEN
TEMP1 = OUT.MENU(CN)<1,6>
TEMP = OUT.MENU(CN)<1,2>
TEMP ='"':TEMP:'"':TEMP1
TEMP2 = TEMP<1,1,1>; DEL TEMP<1,1,1>
LOOP WHILE LEN(TEMP) > 0 AND TEMP<1,1,1> = "" DO
TEMP = DEL TEMP<1,1,1>
TEMP = DEL TEMP<1,2>
TEMP = DEL TEMP<2>
REPEAT
TEMP = TEMP2:SVM:TEMP
*
OUT.MENU(CN)<1,2> = TEMP[1,LEN(TEMP)-1]
OUT.MENU(CN)<1,6> = ''
END
*
REPEAT
*
MATWRITE OUT.MENU ON MU.FILE,NEW.PREFIX:ID
PRINTER ON
PRINT ID "L#15":" CONVERTED TO ":NEW.PREFIX:ID:"<"
PRINTER OFF
PRINT ID "L#15":" CONVERTED TO ":NEW.PREFIX:ID:"<"
END ELSE
PRINT '?':; INPUT CONT
PRINTER ON
PRINT '?????'
PRINTER OFF
END
*
IF NEW.PREFIX # "" THEN
*
IF OLD.DELETE THEN
DELETE MU.FILE,ID
PRINTER ON
PRINT ID "L#15":" DELETED<"
PRINTER OFF
PRINT ID "L#15":" DELETED<"
END
*
END
*
END ELSE
PRINTER ON
PRINT ID "L#15":" IS BYPASSED BECAUSE OF THE KEY<"
PRINTER OFF
PRINT ID "L#15":" IS BYPASSED BECAUSE OF THE KEY<"
END
*
REPEAT
END
~MENU.INSTALL~
*PROGRAM: MENU.INSTALL
*
* AUTHOR: DAVID HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
OPEN 'MENUS' TO MU.FILE ELSE STOP
CONT = 1
LOOP
READNEXT ID ELSE CONT = 0
WHILE CONT DO
IF ID[1,4] = 'NEW.' THEN ID = ID[5,999]
READ MENU FROM MU.FILE,'NEW.':ID THEN
WRITE MENU ON MU.FILE,ID
END
REPEAT
END
~PROGLIST~
*PROGRAM: PROGLIST
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND PRINT BASIC PROGRAMS IN FILE 'BP'
* DATE WRITTEN:      22 OCT 82
* DATE RELEASED:     22 OCT 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
$INCLUDE IBP PKH.STANDARD.FUNCTIONS
!
PRINT
PRINT "ENTER FILE NAME: ":
INPUT FILE.NAME
PRINT
*#
PRINT
PRINT "ENTER 1 TO PRINT INCLUDES: ":
INPUT EQUATES
IF EQUATES # TRUE THEN EQUATES = FALSE
FAST.PRINT = ""
* IF EQUATES[1,1] = "F" THEN EQUATES = EQUATES[2,99]; FAST.PRINT = TRUE
*#
$INCLUDE IBP SYS.INCL.PRINT.INIT
*#
OPEN FILE.NAME TO PRINT.FILE ELSE STOP
FILE.NAME.EQU = "IBP"
OPEN FILE.NAME.EQU TO IBP.FILE ELSE STOP
*#
DIM INCL.LINES(1500); MAX.LINES = 60
FONT.17 = CHAR(27):"[;12m":CHAR(27):"[;44 G"; FONT.12 = CHAR(27):"[;11m":CHAR(27):"[;60 G"
IF EQUATES[1,1] = "X" THEN EQUATES = EQUATES[2,1]; REQD.FONT = FONT.12; MAX.COLS = 98 ELSE REQD.FONT = FONT.17; MAX.COLS = 130
* SET PRINTER TO 8 LPI (DEC PRINTER CODES)
* LINES.8 = CHAR(27):"[":"2":"z"
LINES.6 = CHAR(27):"[":"1":"z"
PAUSE.CN = 0
*#
$INCLUDE IBP SYS.INCL.PRINT.ON
IF PRINTER.FLAG EQ ONE OR PRINTER.FLAG EQ 3 THEN PRINT REQD.FONT:
IF PRINTER.FLAG EQ ONE OR PRINTER.FLAG EQ 3 THEN PRINT LINES.6:
$INCLUDE IBP SYS.INCL.PRINT.OFF
IF PRINTER.FLAG EQ 4 THEN MAX.LINES = 22; MAX.COLS = 80
*#
IF EQUATES # 1 THEN EQUATES = 0
TAB.STRING = "|  "
LOOP UNTIL LEN(TAB.STRING) > MAX.COLS DO TAB.STRING = TAB.STRING:TAB.STRING REPEAT
FIRST.PROG = 1
!
MAIN: * READ EACH PROGRAM SELECTED
READNEXT PROG ELSE
IF NOT(FIRST.PROG) THEN
PRINT
PRINT
PRINT FILE.NAME:" Processing completed."
$INCLUDE IBP SYS.INCL.PRINT.ON
IF PRINTER.FLAG EQ ONE THEN PRINT LINES.6:
$INCLUDE IBP SYS.INCL.PRINT.OFF
STOP
END ELSE
PRINT
PRINT "Enter the program name: ":
INPUT PROG
END
FIRST.PROG = 0
READ LINE FROM PRINT.FILE,PROG ELSE
PRINT
PRINT FILE.NAME:" ":PROG:" program not found...."
PRINT
GOTO MAIN
END
* READNEXT PROG ELSE
* $INCLUDE IBP SYS.INCL.PRINT.ON
* IF PRINTER.FLAG EQ ONE THEN PRINT FONT.17:
* STOP
* END
*
END; *@ of readnext prog
*
PRINT; PRINT PROG
PROG.ID = PROG
PROG = "Program Listing - '":FILE.NAME:" ":PROG:"'"; LINE.NUM = 66; PAGE.NUM = 1; TAB = 0; NUM = 1; CASE.FLAG = 0
CONT.LIST = TRUE
LOOP
READV LINE FROM PRINT.FILE,PROG.ID,NUM ELSE LINE = ""; CONT.LIST = FALSE
UNTIL NOT(CONT.LIST) OR LINE = "" DO
GOSUB PRINTLINE
IF LINE[1,1] = "$" THEN IF EQUATES THEN
LINE = TRIM(LINE)
SAVE.NUM = NUM; NUM = "$   "; INCL.PROG = FIELD(LINE," ",3)
INCL.FILE = FIELD(LINE," ",TWO)
IF INCL.FILE NE FILE.NAME.EQU THEN
FILE.NAME.EQU = INCL.FILE
OPEN FILE.NAME.EQU TO IBP.FILE ELSE 
FILE.NAME.EQU = "IBP"
OPEN FILE.NAME.EQU TO IBP.FILE ELSE STOP
END
END
MATREAD INCL.LINES FROM IBP.FILE,INCL.PROG ELSE MAT INCL.LINES = ""
LINE = "*"; GOSUB PRINTLINE; INCL.NUM = 1
LOOP LINE = INCL.LINES(INCL.NUM) UNTIL LINE = "" DO
NUM = ("$":INCL.NUM) "L#4"
GOSUB PRINTLINE; INCL.NUM = INCL.NUM+1
REPEAT
IF INCL.NUM > 1 THEN LINE = "*"; GOSUB PRINTLINE
NUM = SAVE.NUM
END
NUM = NUM+1
REPEAT
IF PRINTER.FLAG EQ TWO THEN GOSUB CLEAR.PRINTER
IF PRINTER.FLAG EQ 3 THEN PRINT FF:
IF PRINTER.FLAG EQ 4 THEN
PRINT "Enter <cr> . . . ":; INPUT TMP
END
IF PRINTER.FLAG EQ ONE THEN PRINTER CLOSE
GOTO MAIN
!
PRINTLINE: * ANALYSE AND PRINT LINE
TAB.LEFT = 0; TAB.RIGHT = 0; LABEL = ""
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-TAB.LEFT; IF TAB < 0 THEN TAB = 0
INDENT = TAB*3; P.LINE = NUM "R#4":"  "
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6):TAB.STRING[1,INDENT]:STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":TAB.STRING[1,INDENT]:LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE # "" THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
$INCLUDE IBP SYS.INCL.PRINT.ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]:
IF PRINTER.FLAG NE TWO THEN PRINT
P.LINE = SPACE(12+INDENT):P.LINE[POS+1,999]
REPEAT
PRINT P.LINE:
IF PRINTER.FLAG NE TWO THEN PRINT
TAB = TAB+TAB.RIGHT
$INCLUDE IBP SYS.INCL.PRINT.OFF
IF PRINTER.FLAG NE 4 THEN PRINT "*":
IF PRINTER.FLAG EQ TWO THEN
PAUSE.CN = PAUSE.CN + 1
IF PAUSE.CN GT 9 THEN
RQM; RQM; RQM; RQM
PAUSE.CN = 0
END
END
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
FIRST.LINE = LINE
GOSUB FIRSTWORD; * GET FIRST WORD
FIRST = FIRST.RESULT
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
FIRST.LINE = LINE
GOSUB FIRSTWORD
FIRST = FIRST.RESULT
END
*
BEGIN CASE
CASE FIRST[ONE,4] EQ "READ" OR INDEX("*IF*LOCATE*MATREAD*WRITET*WEOF*OPEN*","*":FIRST:"*",ONE)
GOSUB LASTWORD; IF LAST EQ "THEN" OR LAST EQ "ELSE" THEN TAB.RIGHT = 1
*
CASE FIRST EQ "LOOP"
GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST NE "REPEAT;" THEN TAB.RIGHT = 1
*
CASE FIRST EQ "WHILE" OR FIRST EQ "UNTIL"
TAB.LEFT = 1; GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST NE "REPEAT;" THEN TAB.RIGHT = 1
*
CASE FIRST EQ "FOR"
POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN TAB.RIGHT = 1
*
CASE FIRST EQ "BEGIN"
TAB.RIGHT = 1; CASE.FLAG = 1
*
CASE FIRST EQ "CASE"
TAB.RIGHT = 1; IF CASE.FLAG EQ ONE THEN CASE.FLAG = 0 ELSE TAB.LEFT = 1
*
CASE FIRST EQ "END"
IF LINE[POS+1,4] = "CASE" THEN TAB.LEFT = 2; RETURN
TAB.LEFT = 1; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN TAB.RIGHT = 1
*
CASE FIRST EQ "NEXT" OR FIRST EQ "REPEAT"
TAB.LEFT = 1
*
END CASE
*
RETURN
*
!
*
FIRSTWORD: * GET FIRST WORD
*
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" DO POS = POS+1 REPEAT
FIRST.RESULT = LINE[1,POS-1]
FIRST.RESULT = FIELD(FIRST.RESULT,";",ONE)
FIRST.TC = FIRST.RESULT[ONE,ONE]
*
RETURN
*
!
*
LASTWORD: * GET LAST WORD
*
TMP = LINE; SC.CN = ZERO
POS = LEN(TMP)
LOOP
LOOP WHILE TMP[ONE,ONE] = " " DO TMP = TMP[TWO,999] REPEAT
FIRST.LINE = TMP
GOSUB FIRSTWORD
SC.POS = INDEX(TMP,";",ONE)
*
IF FIRST.TC EQ "*" OR FIRST.TC EQ "!" THEN
TMP1 = INDEX(LINE,";",SC.CN)
IF NOT(TMP1) THEN TMP1 = LEN(LINE) + ONE
TMP = LINE[ONE,TMP1 - ONE]
CONT = FALSE
END ELSE IF SC.POS THEN
CONT = TRUE
END ELSE CONT = FALSE
*
WHILE CONT DO
TMP = TMP[SC.POS + ONE,9999]
SC.CN = SC.CN + ONE
REPEAT
*
POS = LEN(TMP)
LOOP WHILE TMP[POS,ONE] EQ " " OR NOT(POS) DO POS = POS - ONE REPEAT
LOOP CHAR = TMP[POS,ONE] UNTIL CHAR EQ ";" OR CHAR EQ " " OR CHAR EQ EMPTY OR NOT(POS) DO POS = POS - ONE REPEAT
*
LAST = TRIM(TMP[POS+1,999])
*
RETURN
*
!
*
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
* IF (FAST.PRINT) AND PAGE.NUM > 1 THEN
* IF PRINTER.FLAG EQ ONE THEN PRINTER CLOSE
* END
* IF PAGE.NUM > 1 THEN
* IF PRINTER.FLAG EQ ONE THEN PRINTER CLOSE
* END
*#
IF PRINTER.FLAG EQ ONE OR PRINTER.FLAG EQ 3 THEN
PRINT FF:
END ELSE IF PRINTER.FLAG EQ 4 THEN
IF PAGE.NUM GT 1 THEN
PRINT "Enter <cr> . . . ":; INPUT TMP
END
END ELSE GOSUB CLEAR.PRINTER
*#
IF PRINTER.FLAG EQ 4 THEN
MSK = "L#":MAX.COLS-40
PRINT (OCONV(TIME(),"MT"):" ":OCONV(DATE(),"D2")) "L#20":(SPACE((MAX.COLS/2-20)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#20":CR:LF
END ELSE
MSK = "L#":MAX.COLS-50
PRINT TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":CR:LF
END
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 3
RETURN
*#
CLEAR.PRINTER: *#
FOR A = LINE.NUM TO 60
PRINT
NEXT A
RETURN
*#
END
~PROGLIST.INPUT~
*PROGRAM:           PROGLIST
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND PRINT BASIC PROGRAMS IN FILE 'BP'
* DATE WRITTEN:      22 OCT 82
* DATE RELEASED:     22 OCT 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
PROGRAM = "PROGLIST.INPUT"
$INCLUDE DH.BP PROGLIST.START
!
$INCLUDE DH.BP PROGLIST.PRINTLINE
!
END
~PROGLIST.LARGE~
*PROGRAM:           PROGLIST.LARGE
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       FORMAT AND PRINT BASIC PROGRAMS IN FILE 'BP'
* DATE WRITTEN:      22 OCT 82
* DATE RELEASED:     22 OCT 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
PROGRAM = "PROGLIST.LARGE"
!
$INCLUDE DH.BP PROGLIST.START
!
$INCLUDE DH.BP PROGLIST.PRINTLINE
!
END
~PROGLIST.PRINTLINE~
*CODE.SEGMENT: PROGLIST.PRINTLINE
*
!
PRINTLINE: * ANALYSE AND PRINT LINE
T.LEFT = 0; T.RIGHT = 0; LABEL = ""
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-T.LEFT; IF TAB < 0 THEN TAB = 0
INDENT = TAB*3; P.LINE = NUM "R#5":" "
INDENT.PR = ""
FOR TEMP = 1 TO TAB; INDENT.PR = INDENT.PR:"!  "; NEXT TEMP
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6):INDENT.PR:STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":INDENT.PR:LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE # "" THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
PRINTER ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]
P.LINE = SPACE(12):INDENT.PR:P.LINE[POS+1,999]
REPEAT
PRINT P.LINE; TAB = TAB+T.RIGHT; PRINTER OFF; PRINT PC:; PC.STORED = PC.STORED:PC
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
BEGIN CASE
CASE FIRST = "IF" OR FIRST = "LOCATE" OR FIRST[1,4] = "READ" OR FIRST[1,7] = "MATREAD" OR FIRST = "WRITET" OR FIRST = "WEOF" OR FIRST = "OPEN"
GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "LOOP"; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "WHILE" OR FIRST = "UNTIL"; T.LEFT = 1; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "FOR"; POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN T.RIGHT = 1
CASE FIRST = "BEGIN"; T.RIGHT = 1; CASE.FLAG = 1
CASE FIRST = "CASE"; T.RIGHT = 1; IF CASE.FLAG = 1 THEN CASE.FLAG = 0 ELSE T.LEFT = 1
CASE FIRST = "END"
IF LINE[POS+1,4] = "CASE" THEN T.LEFT = 2; RETURN
T.LEFT = 1; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "NEXT" OR FIRST = "REPEAT"; T.LEFT = 1
END CASE
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
LASTWORD: * GET LAST WORD
POS = LEN(LINE)
LOOP WHILE LINE[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" OR NOT(POS) DO POS = POS-1 REPEAT
LAST = TRIM(LINE[POS+1,999])
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
MSK = "L#":MAX.COLS-50
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
PRINT FF:TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":LF
RETURN
*
~PURGE.CHANGE.FILES~
*PROGRAM: PURGE.CHANGE.FILES 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       PURGE CHANGES FOR A SPECIFIED MONTH...
* DATE WRITTEN:      04 DEC 86
* DATE RELEASED:     04 DEC 86
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open file CNT"; INPUT RSP; STOP
*
READ CO.DATA FROM CNT.FILE,"CO.DATA" ELSE PRINT "Can't read CNT CO.DATA"; INPUT RSP; STOP
CO.NAME = CO.DATA<1,1,1>
*
PRINT @(0,0):CLS:RVB:OCONV(DATE(),"D2") "L#15":(SPACE(25-LEN(CO.NAME)/2+.5):CO.NAME) "L#50":("Port ":PORT) "R#15":
TITLE = "Purge Changes for a Specified Month"
PRINT @(0,1):(SPACE(40-LEN(TITLE)/2):TITLE) "L#80":RVE:
*
LOOP
PRINT @(20,4):CLL:"Enter month to purge (mmm-yy): ":
INPUT RSP
RSP = "01-":RSP
CALL GET.ICONV(RSP,"D")
WHILE RSP = "" DO
PRINT BELL:
REPEAT
MONTH = OCONV(RSP,"D2")
MONTH = MONTH[4,3]:MONTH[8,2]
*
READ FILE.LIST FROM CNT.FILE,"FILE.LIST" ELSE
PRINT @(0,23):"FILE.LIST not found on CNT -- press <cr> ":CLL:
INPUT RSP:
STOP
END
*
AC = 1
LOOP
FILE.NAME = FILE.LIST<AC>
UNTIL FILE.NAME = "" DO
IF FILE.NAME[1,4] = "ULT." THEN FILE.NAME = FILE.NAME[5,99]
DICT.NAME = ""; IF FILE.NAME[1,5] = "DICT." THEN DICT.NAME = "DICT "; FILE.NAME = FILE.NAME[6,99]
FILE.NAME = FILE.NAME:".CHANGES"
DISP.NAME = DICT.NAME:FILE.NAME
OPEN TRIM(DICT.NAME),FILE.NAME TO CH.FILE THEN
PRINT @(20,6):CLS:DISP.NAME:"......"; PRINT
EXLN = 'SSELECT ':DISP.NAME:' = "$CHANGES.^^':MONTH:']"'
PRINT @(20,8):CLL:EXLN; PRINT
EXECUTE EXLN, //SELECT. > FILE.ID.LIST
LOOP
READNEXT ID FROM FILE.ID.LIST ELSE ID = ""
UNTIL ID = "" DO
PRINT @(20,8):CLL:ID:" deleted.":
DELETE CH.FILE,ID
REPEAT
END
AC = AC+1
REPEAT
STOP
!
END
~QPNT~
PQN
HQPNT.INSTALL
STON
IF #A2 GO 10
A\2
H<
IF #A3 GO 10
A\3
H<
A\4
H<
10 P
X
~QPNT.INSTALL~
*PROGRAM: QPNT.INSTALL
*#
*# Installs a Q Pointer if it does not already exist.
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#
OPEN "MD" TO MDI.FILE ELSE
PRINT BELL:"MD file could not be opened!"
ABORT
END
*#
OPEN "SYSTEM" TO SYSTEM.FILE ELSE
PRINT BELL:"SYSTEM file could not be opened!"
ABORT
END
*#
*# INPUT AUTO.RUNNER
*#
*# INPUT RUN.TYPE
*#
*# INPUT RUN.FUNCTION
*#
PRINT
PRINT "Enter account: ":; INPUT TASK.ACCT
IF NOT(LEN(TASK.ACCT)) THEN STOP
IF TASK.ACCT EQ "KILL" THEN STOP
*
!
*
PRINT
PRINT "Enter file: ":; INPUT TASK.FILE
IF NOT(LEN(TASK.FILE)) THEN STOP
IF TASK.FILE EQ "KILL" THEN STOP
*
!
*
PRINT
PRINT
PRINT "Enter true file name (in the account): ":; INPUT TASK.TRUE.FILE
IF NOT(LEN(TASK.TRUE.FILE)) THEN TASK.TRUE.FILE = TASK.FILE
IF TASK.TRUE.FILE EQ "KILL" THEN STOP
*
!
*
PRINT
PRINT
*
*
READ MD.ITEM FROM MDI.FILE,TASK.FILE THEN
PRINT
PRINT BELL:"MD item alread exists!!!"
PRINT
PRINT "* * * ":TASK.FILE:" * * *"
PRINT
AM.CN.MAX = DCOUNT(MD.ITEM,AM)
*
IF AM.CN.MAX THEN
FOR AM.CN = 1 TO AM.CN.MAX WHILE NOT(SYSTEM(11))
PRINT AM.CN "R#3":") ":MD.ITEM<AM.CN> "L#30"
NEXT AM.CN
PRINT
PRINT
PRINT "Would you like to continue (y/n): ":; INPUT RSP
PRINT
IF NOT(INDEX("*Y*y*YES*yes*OK*ok*","*":RSP:"*",1)) THEN ABORT
END; *# OF AM.CN.MAX
*
CONT = 2
*
END ELSE
*
* MD item does not exist
CONT = 1
*# ELSE FOR READ
END
*
!
*
READ SYSTEM.ITEM FROM SYSTEM.FILE,TASK.ACCT THEN
PRINT
PRINT TASK.ACCT:" is a valid account."
PRINT
*#
END ELSE
PRINT
PRINT BELL:"* * * Warning! * * *"
PRINT "*"
PRINT "* ":TASK.ACCT:" is not a valid account!"
PRINT "*"
PRINT
END; *# OF ACCOUNT ON FILE
*#
MD.ITEM = "Q":AM:TASK.ACCT:AM:TASK.TRUE.FILE:AM:"":AM:"":AM:"":AM:"":AM:"":AM:"L":AM:"20"
WRITE MD.ITEM ON MDI.FILE,TASK.FILE
*END; *# OF ITEM NOT ON FILE
*#
!
*
STOP
*
END
~REVISE.PROGRAM~
*PROGRAM: REVISE.PROGRAM 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       REVISES PROGRAMS IN BP BASED ON BP.CHANGES
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
PRINT
PRINT "Revise............................"
PRINT "  WHICH FILE <BP>? ":; INPUT FL.NAME; IF FL.NAME = '' THEN FL.NAME = "BP"
IN.NAME = FL.NAME
IF IN.NAME[1,4] = "ULT." THEN IN.NAME = IN.NAME[5,99]
DICT.NAME = ""
IF IN.NAME[1,5] = "DICT " OR IN.NAME[1,5] = "DICT." THEN
DICT.NAME = "DICT"; IN.NAME = IN.NAME[6,99]
END
DISP.NAME = TRIM(DICT.NAME:" ":IN.NAME)
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT"; INPUT RSP; STOP
READ CHANGES.LOG FROM CNT.FILE,"CHANGES.LOG" ELSE CHANGES.LOG = ""
LOCATE DISP.NAME IN CHANGES.LOG<1> BY "AL" SETTING LOG.VC ELSE
INS DISP.NAME BEFORE CHANGES.LOG<1,LOG.VC>
INS "" BEFORE CHANGES.LOG<2,LOG.VC>
INS "" BEFORE CHANGES.LOG<3,LOG.VC>
INS "" BEFORE CHANGES.LOG<4,LOG.VC>
INS "" BEFORE CHANGES.LOG<5,LOG.VC>
INS "" BEFORE CHANGES.LOG<6,LOG.VC>
INS "" BEFORE CHANGES.LOG<7,LOG.VC>
INS "" BEFORE CHANGES.LOG<8,LOG.VC>
INS "" BEFORE CHANGES.LOG<9,LOG.VC>
END
OPEN DICT.NAME,IN.NAME TO BP.FILE ELSE PRINT "Can't open ":DISP.NAME; INPUT RSP; STOP
OPEN DICT.NAME,IN.NAME:".CHANGES" TO CHANGE.FILE ELSE PRINT "Can't open ":DISP.NAME:".CHANGES"; INPUT RSP; STOP
BASIC.REQD = ""
IF DICT.NAME = "" AND (IN.NAME = "BP" OR IN.NAME[1,3] = "BP.") THEN
BASIC.REQD = 1
OPEN "DICT",IN.NAME TO OBJ.FILE ELSE PRINT "Can't open DICT ":IN.NAME; INPUT RSP; STOP
END
*
EX.LINE = 'SSELECT ':DISP.NAME:'.CHANGES # "$]"'
PRINT
PRINT "      ":EX.LINE
PRINT
EXECUTE EX.LINE, //SELECT. > FILE.ID.LIST
!
NEXT.ITEM: *
READNEXT PROG.NAME FROM FILE.ID.LIST ELSE WRITE CHANGES.LOG ON CNT.FILE,"CHANGES.LOG"; STOP
READ PROG.CHANGES FROM CHANGE.FILE,PROG.NAME ELSE GOTO NEXT.ITEM
SUCCESS.AC = 5
LOCATE PROG.NAME IN CHANGES.LOG<2,LOG.VC> BY "AL" SETTING LOG.SVC ELSE
INS PROG.NAME BEFORE CHANGES.LOG<2,LOG.VC,LOG.SVC>
INS "" BEFORE CHANGES.LOG<3,LOG.VC,LOG.SVC>
INS "" BEFORE CHANGES.LOG<4,LOG.VC,LOG.SVC>
INS "" BEFORE CHANGES.LOG<5,LOG.VC,LOG.SVC>
INS "" BEFORE CHANGES.LOG<6,LOG.VC,LOG.SVC>
INS "" BEFORE CHANGES.LOG<7,LOG.VC,LOG.SVC>
INS "" BEFORE CHANGES.LOG<8,LOG.VC,LOG.SVC>
INS "" BEFORE CHANGES.LOG<9,LOG.VC,LOG.SVC>
END
FOR TMP = 3 TO 9
CHANGES.LOG<TMP,LOG.VC,LOG.SVC> = ""
NEXT TMP
IF PROG.CHANGES = "\\\DELETED\\\" THEN
PROG.NAME = FIELD(PROG.NAME," ",1)
DELETE BP.FILE,PROG.NAME
DELETE CHANGE.FILE,PROG.NAME
PRINT "          ":DISP.NAME:", ":PROG.NAME:" deleted."
IF BASIC.REQD THEN
EXECUTE "DECATALOG ":IN.NAME:" ":PROG.NAME
END
CHANGES.LOG<7,LOG.VC,LOG.SVC> = 1
PRINT
GOTO INSERT.DATE.TIME
END
CHECK.LINE = PROG.CHANGES<1>
DEL PROG.CHANGES<1>
WRITE PROG.CHANGES ON CHANGE.FILE,PROG.NAME
EX.LINE = 'CHECK-SUM ':DISP.NAME:'.CHANGES "':PROG.NAME:'"'
PRINT "          ":EX.LINE
EXECUTE EX.LINE, //OUT. > RESULT
INS CHECK.LINE BEFORE PROG.CHANGES<1>
WRITE PROG.CHANGES ON CHANGE.FILE,PROG.NAME
RESULT = RESULT<2>
POS = INDEX(RESULT,"Total =",1); TOTAL = RESULT[POS+8,99]; TOTAL = TRIM(FIELD(TOTAL," ",1))
POS = INDEX(RESULT,"Cksum =",1); CKSUM = RESULT[POS+8,99]; CKSUM = TRIM(FIELD(CKSUM," ",1))
RQ.TOTAL = TRIM(FIELD(CHECK.LINE,",",1)); RQ.CKSUM = TRIM(FIELD(CHECK.LINE,",",2))
CKSUM.DIFF = CKSUM - RQ.CKSUM
IF ABS(CKSUM.DIFF) = 9984 THEN CKSUM.DIFF = 0; * ULTIMATE CHANGED THE CALCULATION - 23AUG85
PRINT "             ":"TOTAL = ":TOTAL:"  RQ.TOTAL = ":RQ.TOTAL
PRINT "             ":"CKSUM = ":CKSUM:"  RQ.CKSUM = ":RQ.CKSUM:"      DIFF = ":CKSUM-RQ.CKSUM
*
IF TOTAL # RQ.TOTAL OR (CKSUM.DIFF) THEN
PRINT "             ":"* ":DISP.NAME:".CHANGES ":PROG.NAME:" does not verify *"
PRINT
CHANGES.LOG<3,LOG.VC,LOG.SVC> = 1
GOTO INSERT.DATE.TIME
END
*
READ OLD.PROG FROM BP.FILE,PROG.NAME ELSE OLD.PROG = ""; SUCCESS.AC = 6
PROG = OLD.PROG
*
DELETES = PROG.CHANGES<2>
IF DELETES # "" THEN
MAX.LOC = COUNT(DELETES,",")+1
FOR LOC = MAX.LOC TO 1 STEP -1
DEL.RANGE = FIELD(DELETES,",",LOC)
DEL.FROM = FIELD(DEL.RANGE,"-",1); DEL.TO = FIELD(DEL.RANGE,"-",2); IF DEL.TO = "" THEN DEL.TO = DEL.FROM
FOR AC = DEL.TO TO DEL.FROM STEP -1
DEL PROG<AC>
NEXT AC
NEXT LOC
END
*
MAX.LOC = COUNT(PROG.CHANGES,AM)+1
MAX.AC = 0
FOR LOC = 3 TO MAX.LOC
ADD.LINE = PROG.CHANGES<LOC>
POS = INDEX(ADD.LINE," ",1); AC = ADD.LINE[1,POS-1]; ADD.LINE = ADD.LINE[POS+1,999]
INS ADD.LINE BEFORE PROG<AC>
IF AC > MAX.AC THEN MAX.AC = AC
NEXT LOC
*
WRITE PROG ON BP.FILE,PROG.NAME
READ PROG FROM BP.FILE,PROG.NAME ELSE PROG = ""
IF COUNT(PROG,AM)+1 < MAX.AC THEN
WRITEV "" ON BP.FILE,PROG.NAME,MAX.AC
END
EX.LINE = 'CHECK-SUM ':DISP.NAME:' "':PROG.NAME:'"'
PRINT "          ":EX.LINE
EXECUTE EX.LINE, //OUT. > RESULT
RESULT = RESULT<2>
POS = INDEX(RESULT,"Total =",1); TOTAL = RESULT[POS+8,99]; TOTAL = TRIM(FIELD(TOTAL," ",1))
POS = INDEX(RESULT,"Cksum =",1); CKSUM = RESULT[POS+8,99]; CKSUM = TRIM(FIELD(CKSUM," ",1))
RQ.TOTAL = TRIM(FIELD(CHECK.LINE,",",3)); RQ.CKSUM = TRIM(FIELD(CHECK.LINE,",",4))
IF RQ.TOTAL = -1 THEN RQ.TOTAL = TOTAL
IF RQ.CKSUM = -1 THEN RQ.CKSUM = CKSUM
CKSUM.DIFF = CKSUM - RQ.CKSUM
IF ABS(CKSUM.DIFF) = 9984 THEN CKSUM.DIFF = 0; * ULTIMATE CHANGED THE CALCULATION - 23AUG85
PRINT "             ":"TOTAL = ":TOTAL:"  RQ.TOTAL = ":RQ.TOTAL
PRINT "             ":"CKSUM = ":CKSUM:"  RQ.CKSUM = ":RQ.CKSUM:"      DIFF = ":CKSUM-RQ.CKSUM
*
IF TOTAL # RQ.TOTAL OR (CKSUM.DIFF) THEN
WRITE OLD.PROG ON BP.FILE,PROG.NAME
PRINT "             ":"* ":DISP.NAME:" ":PROG.NAME:" does not verify *"
PRINT
CHANGES.LOG<3,LOG.VC,LOG.SVC> = 1
GOTO INSERT.DATE.TIME
END
*
DELETE CHANGE.FILE,PROG.NAME
PRINT "             ":"* ":DISP.NAME:" ":PROG.NAME:" verifies *"
PRINT
IF BASIC.REQD THEN
READV OLD.COMPILE.DATE FROM OBJ.FILE,PROG.NAME,5 ELSE OLD.COMPILE.DATE = "*NEW*"
EXECUTE "BASIC ":DISP.NAME:" ":PROG.NAME:" (S)"
READV COMPILE.DATE FROM OBJ.FILE,PROG.NAME,5 ELSE COMPILE.DATE = OLD.COMPILE.DATE
IF OLD.COMPILE.DATE = COMPILE.DATE THEN CHANGES.LOG<4,LOG.VC,LOG.SVC> = 1; GOTO INSERT.DATE.TIME
END
CHANGES.LOG<SUCCESS.AC,LOG.VC,LOG.SVC> = 1
INSERT.DATE.TIME: *
CHANGES.LOG<8,LOG.VC,LOG.SVC> = DATE()
CHANGES.LOG<9,LOG.VC,LOG.SVC> = TIME()
GOTO NEXT.ITEM
END
~SCRUTE.PROGLIST~
*PROGRAM: SCRUTE.PROGLIST
*
* AUTHOR:            DAVID HORSMAN - MACROSCOPE DESIGN MATRIX
*
* DESCRIPTION:       FORMAT AND PRINT BASIC PROGRAMS IN FILE 'BP'
* DATE WRITTEN:      22 OCT 82
* DATE RELEASED:     22 OCT 82
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
INPUT EQUATES:
INPUT FILE.NAME:
IF EQUATES = 'N' THEN OLD = "" ELSE OLD = 1
*
OPEN FILE.NAME TO BP.FILE ELSE
PRINT FILE.NAME:" open unsuccessful, hit <CR>.":
INPUT A$
STOP
END
*
*OPEN "OLD.BP" TO OLD.FILE ELSE STOP
OPEN "DH.BP" TO IBP.FILE ELSE
PRINT "IBP open unsuccessful, hit <CR>.":
INPUT A$
STOP
END
*
*DIM LINES(1200),INCL.LINES(600); MAX.LINES = 60
DIM INCL.LINES(600); MAX.LINES = 60
FONT.17 = CHAR(27):"[;12m":CHAR(27):"[;44 G"; FONT.12 = CHAR(27):"[;11m":CHAR(27):"[;60 G"
IF EQUATES[1,1] = "X" THEN EQUATES = EQUATES[2,1]; REQD.FONT = FONT.12; MAX.COLS = 98 ELSE REQD.FONT = FONT.17; MAX.COLS = 130
PRINTER ON; PRINT REQD.FONT:; PRINTER OFF
IF EQUATES # 1 THEN EQUATES = 0
!
MAIN: * READ EACH PROGRAM SELECTED
READNEXT PROG.NAME ELSE
PRINTER ON
PRINT FONT.17
PRINTER OFF
PRINT
PRINT "END OF PRINTING"
STOP
END
IF NOT(OLD) THEN READV LINE FROM BP.FILE,PROG.NAME,1 ELSE 
FILE.NAME = "OLD.BP"
*READV LINE FROM OLD.FILE,PROG.NAME,1 ELSE GOTO MAIN
END
PRINT; PRINT PROG.NAME
PROG = "Program Listing - '":FILE.NAME:" ":PROG.NAME:"'"; LINE.NUM = MAX.LINES; PAGE.NUM = 1; TAB = 0; NUM = 1; CASE.FLAG = 0
*LOOP LINE = LINES(NUM) UNTIL LINE = "" DO
PROG.EOF = ''
LOOP
IF NOT(OLD) THEN
READV LINE FROM BP.FILE,PROG.NAME,NUM ELSE PROG.EOF = 1
END ELSE
READV LINE FROM OLD.FILE,PROG.NAME,NUM ELSE PROG.EOF =1
END
IF LEN(LINE) = 0 THEN PROG.EOF = 1
UNTIL PROG.EOF DO
GOSUB PRINTLINE
IF LINE[1,1] = "$" THEN IF EQUATES THEN
SAVE.NUM = NUM; NUM = "$   "; INCL.PROG = FIELD(LINE," ",3)
MATREAD INCL.LINES FROM IBP.FILE,INCL.PROG ELSE MAT INCL.LINES = ""
LINE = "*"; GOSUB PRINTLINE; INCL.NUM = 1
LOOP LINE = INCL.LINES(INCL.NUM) UNTIL LINE = "" DO GOSUB PRINTLINE; INCL.NUM = INCL.NUM+1 REPEAT
IF INCL.NUM > 1 THEN LINE = "*"; GOSUB PRINTLINE
NUM = SAVE.NUM
END
NUM = NUM+1
REPEAT
GOTO MAIN
!
PRINTLINE: * ANALYSE AND PRINT LINE
T.LEFT = 0; T.RIGHT = 0; LABEL = ""
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-T.LEFT; IF TAB < 0 THEN TAB = 0
INDENT = TAB*3; P.LINE = NUM "R#4":"  "
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6+INDENT):STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":SPACE(INDENT):LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE # "" THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
PRINTER ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]
P.LINE = SPACE(12+INDENT):P.LINE[POS+1,999]
REPEAT
PRINT P.LINE; TAB = TAB+T.RIGHT; PRINTER OFF; PRINT "*":
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
BEGIN CASE
CASE FIRST = "IF" OR FIRST = "LOCATE" OR FIRST[1,4] = "READ" OR FIRST[1,7] = "MATREAD" OR FIRST = "WRITET" OR FIRST = "WEOF" OR FIRST = "OPEN"
GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "LOOP"; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "WHILE" OR FIRST = "UNTIL"; T.LEFT = 1; GOSUB LASTWORD; IF LAST # "REPEAT" THEN T.RIGHT = 1
CASE FIRST = "FOR"; POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN T.RIGHT = 1
CASE FIRST = "BEGIN"; T.RIGHT = 1; CASE.FLAG = 1
CASE FIRST = "CASE"; T.RIGHT = 1; IF CASE.FLAG = 1 THEN CASE.FLAG = 0 ELSE T.LEFT = 1
CASE FIRST = "END"
IF LINE[POS+1,4] = "CASE" THEN T.LEFT = 2; RETURN
T.LEFT = 1; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "NEXT" OR FIRST = "REPEAT"; T.LEFT = 1
END CASE
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
LASTWORD: * GET LAST WORD
POS = LEN(LINE)
LOOP WHILE LINE[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" OR NOT(POS) DO POS = POS-1 REPEAT
LAST = TRIM(LINE[POS+1,999])
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
MSK = "L#":MAX.COLS-50
PRINT FF:TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":LF
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
RETURN
END
~SEARCH.DISPLAY~
*PROGRAM: SEARCH.DISPLAY
*
*AUTHOR:  DAVID HORSMAN
*
*PROGRAM: SEARCH
*AUTHOR:  DAVID HORSMAN
*DATE (THIS VERSION) 09 SEP 87
*
EQU BELL TO CHAR(7), LF TO CHAR(10), FF TO CHAR(12), CR TO CHAR(13)
EQU SVM TO  CHAR(252), VM TO CHAR(253), AM TO CHAR(254)
WHO = ICONV(0,"U50BB")
PORT = (FIELD(WHO," ",1)+100)[2,2]; ACCT = FIELD(WHO," ",2)
CLS = @(-3); CLL = @(-4); PROMPT CHAR(0)
EQU YES TO "*YES*Y*Yes*yes*y*OK*", NO TO "*NO*N*No*no*n*NOT OK*"
EQU TRUE.RSP TO "*T*t*1*TRUE*True*true*NOT FALSE*not false*YES*Y*Yes*yes*y*OK*"
EQU FALSE.RSP TO "*F*f*0*FALSE*False*false*NOT TRUE*not true*NO*N*No*no*n*NOT OK*"
EQU TRUE TO 1
EQU FALSE TO 0
*
TERMINAL = SYSTEM(7); * REVERSE VIDEO BEGIN/END
*RVB = CHAR(14); RVE = CHAR(15)
*PRINT CHAR(27):"0Q":
BEGIN CASE
CASE TERMINAL = "D"; RVB = CHAR(27):"[7m"; RVE = CHAR(27):"[0m"
CASE TERMINAL = "R"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
CASE TERMINAL = "V"; RVB = CHAR(14); RVE = CHAR(15); PRINT CHAR(27):"0Q":
CASE 1; RVB = ""; RVE = ""; PRINT BELL:
END CASE
*
PRINT "FILENAME: ":
INPUT FILENAME
PRINT "RUN.NAME: ":
INPUT SYS.RUN.NAME
PRINT
   EXEC.VERB1 = 'COPY DICT ':FILENAME:' "@LIST@SRCH@LIST@':FILENAME:'@':SYS.RUN.NAME:'"'
   EXEC.VERB1 = EXEC.VERB1:' "@LIST@SRCH@FTXT@':FILENAME:'@':SYS.RUN.NAME:'"'
   EXEC.VERB1 = EXEC.VERB1:' "@LIST@SRCH@FLIN@':FILENAME:'@':SYS.RUN.NAME:'"'
EXEC.PARAM = " (P)"
EXECUTE EXEC.VERB1:EXEC.PARAM
PRINT
EXEC.PARAM = " (T)"
EXECUTE EXEC.VERB1:EXEC.PARAM
SYS.FILE = "DICT SYS"
SYS.ITEM = '@LIST@SRCH@LIST@':FILENAME:'@':SYS.RUN.NAME
SYS.ITEM = '@LIST@SRCH@FTXT@':FILENAME:'@':SYS.RUN.NAME
SYS.ITEM = '@LIST@SRCH@FLIN@':FILENAME:'@':SYS.RUN.NAME
*
*AUTHOR:  DAVID HORSMAN
*
*
EQU EOS TO CHAR(12)
VAL1 = 1
VAL0 = 0
PHANTOM.FLAG=VAL0
PRINTER.FLAG = 1
*
**
*
PRINT "Enter your user name: ":
INPUT USER.NAME
IF USER.NAME EQ "" THEN USER.NAME = "???"
*
**
*
PRINT "Enter the RUN REFERENCE name (to save these parameters): ":
INPUT ANS
SYS.RUN.NAME = ANS
IF SYS.RUN.NAME EQ "" THEN SYS.RUN.NAME = USER.NAME:"#":ACCT:"#":PORT
*
**
*
IF PRINTER.FLAG THEN
   PRINTER ON
   PRINT FF:STR("*",70)
   PRINT "[=| Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILENAME
*   PRINT
 PRINT "[=| "
 PRINT "[=| "
 PRINT "[=| Acct....":ACCT:"   Port....":PORT
 PRINT "[=|"
 PRINT "[=| User.name.....":USER.NAME
 PRINT "[=| Run.reference.":SYS.RUN.NAME
 PRINT "[=| "
 PRINT "[=| "
   PRINTER OFF
END
*PRINT EOS:STR("*",70)
*   PRINT "Date: ":OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT"):"     The file being searched is ":FILENAME
*PRINT
*
**
~SEPARATE.CHANGES~
*PROGRAM: SEPARATE.CHANGES 
* AUTHOR:            DAVID STERN - AXION
* DESCRIPTION:       SEPARATES BP.CHANGES ITEM '$CHANGES.DDMMMYY' TO SEPARATE ITEMS
* DATE WRITTEN:      DD MMM 84
* DATE RELEASED:     DD MMM 84
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
!
PROMPT ""; AM = CHAR(254)
PRINT; PRINT
PRINT "WHICH FILE <BP.CHANGES>? ":; INPUT FL.NAME; IF FL.NAME = '' THEN FL.NAME = "BP.CHANGES"
IF FL.NAME[1,4] = "ULT." THEN FL.NAME = FL.NAME[5,99]
DICT.NAME = ""
IF FL.NAME[1,5] = "DICT " OR FL.NAME[1,5] = "DICT." THEN
DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
END
OPEN DICT.NAME,FL.NAME ELSE STOP
ITEM = ""; ITEM.ID = ""
READ.COUNT = 1
AC = ""
!
LOOP
PRINT; PRINT "        Enter change date (or file name starting with $): ":
INPUT RSP:; IF RSP = "" THEN STOP
IF RSP[1,1] # "$" THEN RSP = ICONV(RSP,"D")
UNTIL RSP # "" DO REPEAT
IF RSP[1,1] = "$" THEN FILE.ID = RSP ELSE
FILE.ID = OCONV(RSP,"D2"); FILE.ID = "$CHANGES.":FILE.ID[1,2]:FILE.ID[4,3]:FILE.ID[8,2]
END
PRINT; PRINT "                 Separating ":FILE.ID:" of ":TRIM(DICT.NAME:" ":FL.NAME)
LOOP
ID = FILE.ID:".":CHAR(READ.COUNT+64)
READ CONSOL.ITEM FROM ID ELSE CONSOL.ITEM = ""
CON.AC = 1
UNTIL CONSOL.ITEM = "" DO
PRINT "                        ":ID
LOOP LINE = CONSOL.ITEM<CON.AC> WHILE LINE = "&&&" DO CON.AC = CON.AC+1 REPEAT
LOOP
LINE = CONSOL.ITEM<CON.AC>; EOI = ''; IF LINE = "" THEN GOSUB CHECK.EOI
UNTIL EOI DO
IF LINE = "%%%" THEN GOSUB WRITE.ITEM
II = 1
LOOP POS = INDEX(LINE,CHAR(125),II) WHILE POS DO
IF POS > LEN(LINE)-3 THEN
CON.AC = CON.AC+1
LINE = LINE:CONSOL.ITEM<CON.AC>[11,999]
END
IF LINE[POS+1,3] = "125" THEN II = II+1
LINE = LINE[1,POS-1]:CHAR(LINE[POS+1,3]):LINE[POS+4,999]
REPEAT
* LOOP POS = INDEX(LINE,CHAR(127),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(248):LINE[POS+1,999] REPEAT; * changed 29JAN85 by Bob C
* LOOP POS = INDEX(LINE,CHAR(125),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(253):LINE[POS+1,999] REPEAT; * changed 29JAN85 by Bob C
* LOOP POS = INDEX(LINE,CHAR(124),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(252):LINE[POS+1,999] REPEAT; * changed 29JAN85 by Bob C
* LOOP POS = INDEX(LINE,CHAR(123),1) WHILE POS DO LINE = LINE[1,POS-1]:CHAR(240):LINE[POS+1,999] REPEAT; * changed 29JAN85 by Bob C
IF LINE[1,10] # "...       " THEN ITEM<AC> = LINE; AC = AC+1 ELSE ITEM<AC-1> = ITEM<AC-1>:LINE[11,999]
CON.AC = CON.AC+1
REPEAT
READ.COUNT = READ.COUNT+1
REPEAT
GOSUB WRITE.ITEM
STOP
!
WRITE.ITEM: *
IF ITEM.ID # "" OR AC > 1 THEN WRITE ITEM ON ITEM.ID
CON.AC = CON.AC+1
ITEM.ID = CONSOL.ITEM<CON.AC>
IF ITEM.ID # "" THEN PRINT "                                       ":ITEM.ID
CON.AC = CON.AC+1
LINE = CONSOL.ITEM<CON.AC>
AC = 1
ITEM = ""
RETURN
!
CHECK.EOI: *
IF AC > 2 THEN
EOI = 1
FOR AC.TST = CON.AC+1 TO CON.AC+20
IF CONSOL.ITEM<AC.TST> # "" THEN EOI = ''
NEXT AC.TST
END
RETURN
!
END
~SYS.APPL.MENU.XREF~
*PROGRAM: SYS.APPL.MENU.XREF
*
* AUTHOR: DAVID G. HORSMAN
*
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
DIM MENU(100),APPL(150)
SYS.PROG.DESC = "Application cross reference of menus"
SYS.PROG = "SYS.APPL.MENU.XREF"
SYS.PROG.TYPE = 9
SYS.LOCT = ""
SYS.SLOC = ""
RUN.DATE = DATE()
RUN.TIME = TIME()
PRINT @(0,5):CLS:@(0,7):SPACE(40-(LEN(SYS.PROG.DESC)/2)):RVB:SYS.PROG.DESC:RVE:
REP.PAGE = 0
REP.LINE = 0
PRINTER ON
GOSUB REP.HEADING
PRINTER OFF
OPEN "MENUS" TO MU.FILE ELSE STOP
OPEN "SYS" TO SY.FILE ELSE STOP
CONT = 1
HIGH.MENU.CONTROL<1,9> = 0
OLD.APPL = ""
MENU.APPL.CODE = ""
APPL.VALID = 0
EXECUTE 'SSELECT MENUS = "@AS@]"'
LOOP
READNEXT ID ELSE CONT = 0
WHILE CONT DO
PRINT "M":
IF ID[1,4] = "@AS@" THEN
*
MATREAD MENU FROM MU.FILE,ID THEN
MENU.CONTROL<1,9> = MENU.CONTROL<1,9>
MENU.APPL.CODE = MENU.CONTROL<1,6,1>
*
LOOP WHILE OLD.APPL # MENU.APPL.CODE ! NOT(APPL.VALID) DO
APPL.VALID = 0
IF OLD.APPL # "" THEN MATWRITE APPL ON SY.FILE,"@APPL@":OLD.APPL
MATREAD APPL FROM SY.FILE,"@APPL@":MENU.APPL.CODE THEN
APPL.VALID = 1
OLD.APPL = MENU.APPL.CODE
END ELSE
MAT APPL = ""
PRINT @(0,23):BELL:"Enter new APPLICATION CODE for ":ID[5,99]:": ":
INPUT MENU.APPL.CODE:
IF MENU.APPL.CODE # "CONTINUE" THEN
MENU.CONTROL<1,9> = 1
MENU.CONTROL<1,9> = 1
MATWRITE MENU ON MU.FILE,ID
APPL.VALID = 1
END ELSE
PRINT @(0,23):BELL:"Enter APPLICATION desc for ":MENU.APPL.CODE:": ":
INPUT MENU.APPL.DESC:
MAT APPL = ""
APPL(1) = MENU.APPL.DESC
END
END
REPEAT
*
*
*
IF NOT(NUM(MENU.CONTROL<1,9>)) THEN MENU.CONTROL<1,9> = 1
HIGH.MENU.CONTROL<1,9> = APPL(3)
MENU.LAST.DATE = APPL(4)
MENU.LAST.TIME = APPL(5)
IF NOT(NUM(HIGH.MENU.CONTROL<1,9>)) THEN HIGH.MENU.CONTROL<1,9> = 0
IF NOT(NUM(MENU.LAST.DATE)) THEN MENU.LAST.DATE = 0
IF NOT(NUM(MENU.LAST.TIME)) THEN MENU.LAST.TIME = 0
IF MENU.CONTROL<1,9> > HIGH.MENU.CONTROL<1,9> THEN HIGH.MENU.CONTROL<1,9> = MENU.CONTROL<1,9>
APPL(3) = HIGH.MENU.CONTROL<1,9>
APPL(4) = RUN.DATE
APPL(5) = RUN.TIME
APPL(MENU.CONTROL<1,9>+20) = ID[5,99]
*
END
END
REPEAT
*
*
PRINT; PRINT
EXECUTE 'SSELECT SYS = "@APPL@]"'
CONT = 1
PRINTER ON
LOOP
READNEXT ID ELSE CONT = 0
WHILE CONT DO
PRINTER OFF; PRINT "A":; PRINTER ON
IF REP.LINE > 45 THEN GOSUB REP.HEADING
MATREAD APPL FROM SY.FILE,ID THEN
GOSUB REP.APPL.DESC
CN = 20
COL.CN = 0
LOOP CN = CN + 1 WHILE LEN(APPL(CN):APPL(CN+1):APPL(CN+2):APPL(CN+3)) # 0 DO
COL.CN =COL.CN + 1
IF COL.CN > 4 THEN
PRINT; PRINT
COL.CN = 1
REP.LINE = REP.LINE + 2
IF REP.LINE > 55 THEN
GOSUB REP.HEADING
GOSUB REP.APPL.DESC
END
END
PRINT (CN:".") "R#3":" ":APPL(CN) "L#16":
REPEAT
PRINT; PRINT; PRINT
REP.LINE = REP.LINE + 3
END
REPEAT
*
*
STOP
!
REP.HEADING: *
REP.PAGE = REP.PAGE + 1
REP.LINE =10
PRINT FF:SPACE(40-(LEN(SYS.PROG.DESC)/2)):SYS.PROG.DESC:
PRINT
PRINT
PRINT ("Date: ":OCONV(RUN.DATE,"D2")) "L#20":("Time: ":OCONV(RUN.TIME,"MTS")) "L#45":"Page ":REP.PAGE
PRINT
PRINT
RETURN
!
REP.APPL.DESC: *
PRINT("Application code: ":ID[7,LEN(ID)-5]) "L#30":APPL(1)
PRINT
PRINT SPACE(30):"Highest menu number: ":APPL(3) "R#3"
PRINT
REP.LINE = REP.LINE + 4
RETURN
*
*
END
~SYS.DEV~
SUBROUTINE SYS.DEV(DEV,RSP)
*SUBROUTINE: SYS.DEV
*
* AUTHOR: DAVID HORSMAN
*
!
$INCLUDE IBP SYS.COMMON
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
DIM MODE.DESC(30), STAT.DESC(15)
*
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*
SYS.PROG = "SYS.DEV":AM:SYS.PROG
SYS.LOCT = "OPEN":AM:SYS.LOCT
SYS.SLOC = "OPEN":AM:SYS.SLOC
!
SYS.FILE = "MENUS"
OPEN SYS.FILE TO MU.FILE ELSE
ERROR.TEXT = "No MENUS file"
ERROR.CODE = 11111
GOSUB ERROR.CONTROL
END
*
SYS.FILE = "DEV"
OPEN SYS.FILE TO DEV.FILE THEN CHECK.DEV = 1 ELSE
CHECK.DEV = 0
ERROR.TEXT = "No DEV file":AM:"sorry but there are no development facilities availalble"
ERROR.CODE = "13110":AM:"13111"
GOSUB ERROR.CONTROL
END
*
IF NOT(CHECK.DEV) THEN RETURN
*
SYS.LOCT<1> = "INIT"
SYS.SLOC<1> = "DIM"
DIM DEV.REC(100)
MAT DEV.REC = ""
SUBR.FUNCTION = ""
*
SYS.SLOC<1> = "READ"
*
SYS.FILE = "SYS"
SYS.ITEM = "@SYS@DEV.LEVEL.DESC"
MATREAD DEV.REC FROM SY.FILE,SYS.ITEM ELSE
MAT DEV.REC = ""
ERROR.TEXT = "descriptions missing":AM:"sorry but there are no development facilities availalble"
ERROR.CODE = "13110":AM:"13111"
GOSUB ERROR.CONTROL
RETURN
END
*
DEV.INP1 = ""
Remove.first: * Take off DEV & ?'S
LOOP WHILE DEV[1,1] = "?" ! DEV[1,1] = " " DO DEV = DEV[2,99] REPEAT
*
IF DEV[1,4] = "DEV" THEN DEV = DEV[5,99]; GOTO Remove.first
*
TEMP = FIELD(DEV," ",1)
IF TEMP = "EDIT" ! TEMP[1,3] = "WP-" THEN
DEV.INP1 = TEMP
DEV = DEV[COL2(),99]
GOTO Remove.first
END
*
DEV.OPT = FIELD(DEV," ",1)
RSP = DEV.OPT
DEV.INP = FIELD(DEV," ",2)
IF NOT(NUM(DEV.INP)) THEN DEV.INP = 0
IF LEN(DEV.INP) = 0 THEN DEV.INP = 0
IF NOT(DEV.INP) THEN CALL.FUNCTION = "MENU" ELSE CALL.FUNCTION = "EXECUTE"
DEV = DEV.INP
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
*
LOOP
IF CALL.FUNCTION = "MENU" THEN GOSUB Development.menu
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
*
IF DEV.INP1[1,3] = "WP-" ! DEV.INP1 = "EDIT" ! CALL.FUNCTION = "EDIT" THEN
IF USER.MODE >= LO.D.M & USER.MODE <= HI.D.M THEN
GOSUB Development.key.format
PRINT @(0,5):CLS:@(0,6):"Ready for edit."
EXECUTE DEV.INP1:" DEV ":SYS.ITEM
SYS.LOCT<1> = "MAIN"; SYS.SLOC<1> = "CALLS"
IF CALL.FUNCTION = "EDIT" THEN DEV.INP = "END"
END
DEV.INP1 = ""
*
END ELSE
IF DEV.INP # "END" ! CALL.FUNCTION = "EXECUTE" THEN GOSUB Development.display
*
END
WHILE CALL.FUNCTION = "MENU" & DEV.INP # "END" DO REPEAT
*
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
RETURN
!
Development.menu: * Main program.
SYS.LOCT<1> = "DEV.MENU"
SYS.SLOC<1> = "DISPLAY"
*
DEV.CONT = 1; DEV.CONT1 = 1
DEV.CN   = 1; DEV.STOP  = 15
*
LOOP
IF DEV.CN = INT(DEV.CN / 15) * 15 + 1 THEN
PRINT @(0,5):CLS:
END ELSE PRINT @(0,6):CLL:
PRINT @(10,6):"User Development Menu for ":USER.NAME:
LOOP WHILE DEV.REC(DEV.CN)<1,4> # "" & DEV.CONT & DEV.CN <= 100 DO
IF DEV.CN < DEV.STOP + 1 THEN
TEMP.LN = DEV.CN - INT((DEV.CN - 1) / 15) * 15 + 6
PRINT @(2,TEMP.LN):CLL:
PRINT (DEV.CN:" -") "R#4":" ":RVB:DEV.REC(DEV.CN)<1,4> "L#40":RVE:
PRINT " ":RVB:DEV.REC(DEV.CN)<1,1>:"-":DEV.REC(DEV.CN)<1,2> "L#15":RVE:
DEV.CN = DEV.CN + 1
END ELSE DEV.CONT = 0
REPEAT
*
IF DEV.REC(DEV.CN)<1,4> # "" THEN PRINT @(0,6):"(MORE)":
PRINT @(0,22):CLS:STRUCT(2):', Enter "B" for back a page, "N" for next page,':
PRINT @(0,23):CLL:SPACE(5):' the development number or <CR>, or "END"  to end . . .':
INPUT DEV.INP:
IF DEV.INP = "END" THEN
DEV.CONT = 0; DEV.CONT1 = 0
*
END ELSE IF DEV.INP = "B" THEN
IF DEV.STOP >15 THEN
DEV.STOP = DEV.STOP - 15
DEV.CN = DEV.STOP - 15 + 1
END ELSE
PRINT BELL:
DEV.STOP = 15
DEV.CN = 1
END
DEV.CONT = 1
*
END ELSE IF DEV.INP = "N" THEN
IF DEV.STOP < 100 & DEV.REC(DEV.STOP + 1)<1,4> # "" THEN
DEV.STOP = DEV.STOP + 15
DEV.CN = DEV.STOP - 15 + 1
END ELSE
PRINT BELL:
DEV.STOP = 15
DEV.CN = 1
END
DEV.CONT = 1
*
END ELSE IF LEN(DEV.INP) = 0 THEN
IF DEV > 0 THEN
DEV.CONT1 = 0
DEV.INP = DEV
END ELSE
DEV.INP = ""
DEV.CN = 1
DEV.STOP = 15
DEV.CONT = 1
END
*
END ELSE
IF INDEX("*EDIT*WP-INPUT*","*":FIELD(DEV.INP," ",1):"*",1) # 0 THEN
DEV.INP1 = FIELD(DEV.INP," ",1)
DEV.INP = FIELD(DEV.INP," ",2)
IF NOT(NUM(DEV.INP)) THEN DEV.INP1 = ""
END
*
IF NUM(DEV.INP) THEN
IF NOT(DEV.INP > 0 & DEV.INP < 100 & LEN(DEV.REC(DEV.INP)<1,4>) > 0) THEN
DEV.INP = ""
END ELSE DEV.CONT1 = 0
*
END ELSE
ERROR.TEXT = "that was an invalid entry"
ERROR.CODE = 14011
GOSUB ERROR.CONTROL
DEV.CONT1 = 0
END
END
*
WHILE DEV.CONT1 DO REPEAT
*
RETURN
!
*
Development.key.format: * Subroutine to format Topic 1#2#3#4...
*
SYS.LOCT<1> = "KEY.FORMAT"
SYS.SLOC<1> = ""
*
IF DEV.INP > 0 & DEV.INP < 101 THEN
DEV.LEVEL = DEV.REC(DEV.INP)<1,1>:"@":DEV.REC(DEV.INP)<1,2>:"@":DEV.REC(DEV.INP)<1,3>
END ELSE DEV.LEVEL = ""
*
SYS.ITEM = "@":MENU.APPL:"@":MENU.CONTROL<1,9>:"@":DEV.OPT:"@":DEV.LEVEL
*
PRINT @(0,5):CLS:
*
PRINT @(0,10):"User Development Facilities"
*
PRINT @(0,12):"Key: ":SYS.ITEM
*
READV DEV.DOC FROM DEV.FILE,SYS.ITEM,1 THEN DEV.DOC.FOUND = 1 ELSE
ERROR.TEXT = "that development document does not exist"
PRINT @(0,15):ERROR.TEXT:
ERROR.TEXT = ERROR.TEXT:AM:"the key was ":SYS.ITEM
ERROR.CODE = "04110":AM:"14110"
GOSUB ERROR.CONTROL
DEV.DOC.FOUND = 0
END
*
*
RETURN
!
Development.display: * Subrouting to display Development.
*
SYS.LOCT<1> = "DISPLAY"
SYS.SLOC<1> = ""
GOSUB Development.key.format
IF DEV.DOC.FOUND THEN
PRINT @(0,5):CLS:
EXECUTE "WP-OUTPUT DEV ":SYS.ITEM
ERROR.TEXT = "Enter <CR> to return to the menu"
ERROR.CODE = 19001
GOSUB ERROR.CONTROL
END
*
RETURN
*
*
$INCLUDE IBP SYS.ERROR.STRUCT
*
END
~SYS.EDIT.PROCESS~
*PROGRAM: SYS.EDIT.PROCESS
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
OPEN "SYS" TO SY.FILE ELSE STOP
READ SYS.INPUT FROM SY.FILE,"EDCOM" ELSE STOP
SYS.FILE = SYS.INPUT<1>
SYS.INPUT = DELETE(SYS.INPUT,1)
LOOP
READNEXT ID ELSE STOP
TEMP = SYS.INPUT
TEMP = TEMP:AM:"FI"
TEMP1 = "ED ":SYS.FILE:" ":ID
EXECUTE TEMP1, //IN. < TEMP
REPEAT
END
~SYS.MENU.CONVERT~
SUBROUTINE SYS.MENU.CONVERT(MAT MENU)
*SUBROUTINE: SYS.MENU.CONVERT
*
* AUTHOR: DAVID G. HORSMAN
*
*#
$INCLUDE IBP SYS.COMMON
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*#
*#
SYS.PROG = "MENU.CONVERT":AM:SYS.PROG
SYS.LOCT = "":AM:SYS.LOCT
SYS.SLOC = "":AM:SYS.SLOC
SYS.PROG.DESC = "Macroscope Menu Conversion Subroutine"
*#
DIM MENU(25)
MAT MENU = ""
DIM IN.MENU(100)
MAT IN.MENU = ""
*#
*#    Elapse init
RUN.DATE = DATE()
RUN.TIME = TIME()
*#
*#    Load functions
IN.MENU.FILE.NAME = SUBR.FUNCTION<1>
*#
*#    Turn on printer
*PRINTER ON
*PRINT FF:SYS.PROG
*PRINT
*PRINT @(40):SYS.PROG.DESC
*PRINT
*PRINT "--DATE---       -TIME-"
*PRINT OCONV(RUN.DATE,"D2"):"     ":OCONV(RUN.TIME,"MTS"):
*PRINT
*PRINT
*PRINTER OFF
*#
*#    Open files
*#
OPEN IN.MENU.FILE.NAME TO IN.MENU.FILE ELSE SYS.ABORT = 1; RETURN; * TO CALLING PROGRAM
OPEN "DH.MENUS" TO MU.FILE ELSE SYS.ABORT = 1; RETURN; * TO CALLING PROGRAM
*OPEN "SYS" TO SY.FILE ELSE SYS.ABORT = 1; RETURN; * TO CALLING PROGRAM
OPEN "AX.PAR" TO PAR.FILE ELSE SYS.ABORT = 1; RETURN; * TO CALLING PROGRAM
CONT = 1
IN.MENU.NUM = 0
OLD.DELETE = 0
*#
*#    Input prefix for keys
*PRINT
*PRINT
*PRINT "Enter new prefix for keys: ":;* INPUT NEW.PREFIX
NEW.PREFIX = "@KBIL@"
IF NEW.PREFIX = "" THEN OLD.DELETE = 0 ELSE
*#
*#    Prompt for deletion on old item
*PRINT
*PRINT "DELETE OLD?":
*INPUT OLD.DELETE:
OLD.DELETE = 0
IF OLD.DELETE = "YES" THEN OLD.DELETE = 1
IF NOT(NUM(OLD.DELETE)) THEN OLD.DELETE = 0
IF OLD.DELETE # 1 THEN OLD.DELETE = 0
END
*#
*#    Start processing prompt
*PRINT
*PRINT "OK?":; INPUT RSP:
*PRINT
*PRINT
*IF RSP = "N" THEN STOP
*PRINTER ON
*PRINT;* PRINT "OLD.DELETE: ":OLD.DELETE
*PRINT;* PRINT "NEW PREFIX: ":NEW.PREFIX
*PRINT;* PRINT;* PRINT;* PRINT
MENU.SPLIT = 0
LOOP
*READNEXT ID ELSE CONT = 0
ID = MENU.NAME
WHILE CONT DO
CONT = 0
IF ID[1,4] NE "@AS@" THEN
*
MATREAD IN.MENU FROM IN.MENU.FILE,ID THEN
*#
*#
MAT MENU = ""
*#
MENU(1) = IN.MENU(1):VM:"":VM:"":VM:"":VM:"/AXION":VM:"KBIL":VM:"KBIL":VM:"P":VM:"0":VM
*#
CN = 1
CN1 = 1
MENU.SPLIT = 0
*#
IF LEN(IN.MENU(1)) NE LEN(IN.MENU(1)<1,1>) THEN
PRINT BELL:
INPUT RSP
PRINT BELL:"** STOP **":
INPUT RSP
IF RSP NE "N" THEN STOP
END
*#
*#
LOOP CN = CN + 1 WHILE CN < 26 AND IN.MENU(CN1+1) # "" DO
LOOP
CN1 = CN1 + 1
CONT = 1
TC = IN.MENU(CN1)<1,1>[1,1]
IF TC NE ">" THEN
IF NOT(TC = "*" AND CN1 < 4) THEN
MENU(CN)<1,1> = MENU(CN)<1,1>:IN.MENU(CN1)<1,1>
IF TC EQ "*" THEN MENU(CN)<1,1> = MENU(CN)<1,1>:SVM
END
END
IF TC EQ "*" OR TC EQ ">" THEN
IF TC EQ ">" THEN
*MENU.SPLIT = CN
END
END ELSE CONT = 0
IF CN1 GE 14 AND NOT(MENU.SPLIT) THEN MENU.SPLIT = CN
WHILE CONT AND CN1 < 50 DO REPEAT
*#
*#
MENU(CN) = MENU(CN)<1,1>:VM:IN.MENU(CN1)<1,2>:VM:IN.MENU(CN1)<1,3>:VM:"":VM:"":VM:"":VM:"":VM:"0":VM
CN2 = 0
LOOP CN2 = CN2 + 1 WHILE MENU(CN)<1,2,CN2> NE "" DO
IF MENU(CN)<1,2,CN2>[1,1] NE '/' THEN
IF MENU(CN)<1,2,CN2>[LEN(MENU(CN)<1,2,CN2>)-1,2] = ".?" THEN
MENU(CN)<1,2,CN2> = MENU(CN)<1,2,CN2>[1,LEN(MENU(CN)<1,2,CN2>)-2]
ROUTINE.SUFFIX = "STANDARD"
READ SPECIAL.ROUTINES FROM PAR.FILE,"SPECIAL.ROUTINES" ELSE SPECIAL.ROUTINES = ""
LOCATE MENU(CN)<1,2,CN2> IN SPECIAL.ROUTINES<1> SETTING LOC THEN ROUTINE.SUFFIX = SPECIAL.ROUTINES<2,LOC>
MENU(CN)<1,2,CN2> = MENU(CN)<1,2,CN2>:".":ROUTINE.SUFFIX
END
MENU(CN)<1,2,CN2> = '"':MENU(CN)<1,2,CN2>:'"'
END
REPEAT
TC = FIELD(MENU(CN)<1,3,1>," ",1)
IF INDEX('*"SELECT*"SSELECT*"GET-LIST*"QSELECT*','*':TC:'*',1) NE 0 THEN
MENU(CN)<1,5> = MENU(CN)<1,3,1>
MENU(CN) = DELETE(MENU(CN),1,3,1)
END
*
*
REPEAT
*
MENU(1)<1,8>=MENU(1)<1,8>:MENU.SPLIT
LOOP WHILE MENU(2)<1,1>[1,8] NE ("*":SVM:"*":SVM:"*":SVM:"*":SVM) DO
MENU(2) = "*":SVM:MENU(2)
REPEAT
IF MENU.SPLIT > 1 THEN
LOOP WHILE MENU(MENU.SPLIT)<1,1>[1,8] NE "*":SVM:"*":SVM:"*":SVM:"*":SVM DO
MENU(MENU.SPLIT) = "*":SVM:MENU(MENU.SPLIT)
REPEAT
END
MATWRITE MENU ON MU.FILE,NEW.PREFIX:ID
*PRINTER ON
*PRINT ID "L#15":" CONVERTED TO ":NEW.PREFIX:ID:"<"
*PRINTER OFF
*PRINT ID "L#15":" CONVERTED TO ":NEW.PREFIX:ID:"<"
END ELSE
PRINT '?':; INPUT CONT
PRINTER ON
PRINT '?????'
PRINTER OFF
END
*
*#IF NEW.PREFIX # "" THEN
*#*
*#IF OLD.DELETE THEN
*#DELETE MENU.FILE,ID
*#PRINTER ON
*#PRINT ID "L#15":" DELETED<"
*#PRINTER OFF
*#PRINT ID "L#15":" DELETED<"
*#END
*#*
*#END
*
END ELSE
PRINTER ON
PRINT ID "L#15":" IS BYPASSED BECAUSE OF THE KEY<"
PRINTER OFF
PRINT ID "L#15":" IS BYPASSED BECAUSE OF THE KEY<"
END
*
REPEAT
*END
*
*#
*#
*#
SYS.PROG = DELETE(SYS.PROG,1)
SYS.LOCT = DELETE(SYS.LOCT,1)
SYS.SLOC = DELETE(SYS.SLOC,1)
*#
RETURN; * TO CALLING PROGRAM
END
~SYS.PROGLIST~
*PROGRAM: SYS.PROGLIST
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP SYS.COMMON
!
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*
*
DIM MODE.DESC(30), STAT.DESC(15)
*
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*
LN = 0
RELOOP = ""
PRINT
PRINT "Enter run type (1 or 2): ":
INPUT SYS.RUN.TYPE
*
*SYS.RUN.TYPE = 1 , INPUT 1 PROGRAM NAME FROM TYPE AHEAD
*SYS.RUN.TYPE = 2 , READ SELECTS THEN INPUT NAME FORM KEYBOARD
*
FONT.17 = CHAR(27):"[;12m":CHAR(27):"[;44 G"; FONT.12 = CHAR(27):"[;11m":CHAR(27):"[;60 G"
REQD.FONT = FONT.17; MAX.COLS = 130
OLD = ""
EQUATES = ""
DIM INCL.LINES(600)
MAX.LINES = 60
PRINT @(0,5):CLS:
*
*
PRINT @(0,5):CLL:"Enter file name: ":
IF SYS.RUN.TYPE = 2 THEN
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
END
IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
INPUT FILE.NAME:
END ELSE FILE.NAME = ""
PRINT @(17,5):CLL:FILE.NAME:
*
*
*
*
LOOP
PRINT @(0,7):CLS:"Enter item name: ":
FILE.ITEM = ""
IF SYS.RUN.TYPE = 2 AND NOT(RELOOP) THEN
READNEXT FILE.ITEM ELSE
FILE.ITEM = ""
RELOOP = SYS.RUN.TYPE
END
END ELSE FILE.ITEM = ""
*
IF FILE.ITEM = "" THEN
IF SYS.RUN.TYPE = 2 THEN
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
END
IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
INPUT FILE.ITEM:
END ELSE FILE.ITEM = ""
END
PRINT @(17,7):CLL:FILE.ITEM:
WHILE FILE.ITEM # "" AND FILE.ITEM # "END" DO
*
*
PRINT @(0,9):CLL:"Enter parameters (O,X,E): ":
IF SYS.RUN.TYPE = 2 THEN
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
END
IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
INPUT PARAMS:
END ELSE PARAMS = "E"
PRINT @(26,9):PARAMS:"     ":
LOOP
IF PARAMS[1,1] = "O" THEN OLD = 1 
IF PARAMS[1,1] = "X" THEN REQD.FONT = FONT.12; MAX.COLS = 98
IF PARAMS[1,1] = "E" THEN EQUATES = 1
PARAMS = PARAMS[2,99]
WHILE PARAMS # "" DO REPEAT
PRINTER ON; PRINT REQD.FONT:; PRINTER OFF
*
*
!
MAIN: * READ EACH PROGRAM SELECTED
BP.FL.DH = ""; BP.FL = ""; BP.FL.UTL = ""; BP.FL.PRJ = ""; BP.FL.OLD = ""
IF FILE.NAME # "" THEN FILE.NAMES = FILE.NAME ELSE
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@DEV@BP@FILES"
READ FILE.NAMES FROM SY.FILE,SYS.ITEM ELSE
FILE.NAMES = "SYSTEM":AM:"MD":AM:"PL":AM:"SYS"
FILE.NAMES = FILE.NAMES:AM:"DH.BP"
END
PRINT @(17,5):CLL:FILE.NAME:
END
PRINT @(0,11):CLS:"> ":FILE.NAME:" - ":FILE.ITEM:" - ":
PROG = "Program Listing - '":FILE.NAME:" ":FILE.ITEM:"'"; LINE.NUM = MAX.LINES; PAGE.NUM = 0; TAB = 0
NUM = 1; CASE.FLAG = 0; LN = 6
TOT.NUM = 1
TOT.INCL = 0
BP.EMPTY = 0; CN = 0
PRINTER ON; GOSUB HEADER; PRINT SPACE(12):"-----FOUND ON---------"; PRINT; PRINTER OFF
PRINT @(50,5):CLL:"-----FOUND ON-------":
F.RSP = "ZZZZZ"
EXEC.STACK = ""
LOOP
CN = CN + 1
TEMP.NAME = FILE.NAMES<CN>
WHILE TEMP.NAME # "" DO
BP.FLAG = 1
OPEN TEMP.NAME TO INP.FILE ELSE BP.FLAG = ""
IF BP.FLAG THEN
READV TEXT FROM INP.FILE,FILE.ITEM,1 THEN
PRINT @(50,LN):TEMP.NAME:
PRINT "  ?":BELL:
IF SYS.RUN.TYPE = 2 THEN
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
IF SYSTEM(11) OR (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
INPUT F.RSP:
END ELSE F.RSP = "Y"; PRINT F.RSP:
IF F.RSP = "Y" THEN EXEC.STACK = EXEC.STACK:CN:AM
END ELSE EXEC.STACK = EXEC.STACK:CN:AM
PRINTER ON; PRINT SPACE(12):TEMP.NAME; PRINTER OFF; LINE.NUM = LINE.NUM+1
LN = LN+1
IF LN > 19 THEN LN = 6
END ELSE BP.FLAG = ""
END
IF NOT(BP.FLAG) THEN PRINT @(0,23):CLL:FILE.ITEM:" is not on ":TEMP.NAME:".":; RQM
REPEAT
PRINTER ON; PRINT; PRINT SPACE(12):STR("-",20); PRINT; PRINTER OFF; LINE.NUM=LINE.NUM+3
*
*
IF EXEC.STACK # "" THEN
LOOP WHILE EXEC.STACK # "" DO
CN = EXEC.STACK<1>
IF CN > 0 THEN
FILE.NAME = FILE.NAMES<CN>
IF FILE.NAME # "" THEN
OPEN FILE.NAME TO INP.FILE ELSE CN = 0
END ELSE CN = 0
IF CN > 0 THEN GOSUB PRINT.PROGRAM
END
EXEC.STACK = DELETE(EXEC.STACK,1)
REPEAT
END
*
*
IF SYS.RUN.TYPE # 2 THEN RELOOP = SYS.RUN.TYPE
REPEAT
PRINTER ON; PRINT FONT.17:; PRINTER OFF; STOP
STOP
*
*
!
PRINT.PROGRAM: * PRINT EACH PROGRAM
PC.STORED = ""
PRINT @(0,11):CLS:"> ":FILE.NAME:" - ":FILE.ITEM
*:" - ":
PC.CN = 1
PROG = "Program Listing - '":FILE.NAME:" ":FILE.ITEM:"'"; TAB = 0; NUM = 1; CASE.FLAG = 0; LN = 0
BP.EMPTY = 0
PC = "*"
LOOP
LN = LN+1
LINE = ""
READV LINE FROM INP.FILE,FILE.ITEM,LN ELSE LINE = ""
IF LINE = "" THEN BP.EMPTY = BP.EMPTY+1 ELSE BP.EMPTY = 0
*
UNTIL BP.EMPTY > 5 DO
GOSUB PRINTLINE
IF LINE[1,1] = "$" AND EQUATES THEN
SAVE.NUM = NUM
NUM = ">>>>I"
INCL.FILE = FIELD(LINE," ",2)
INCL.PROG = FIELD(LINE," ",3)
INCL.FL = 1
OPEN INCL.FILE TO IINP.FILE ELSE INCL.FL = ""
IF INCL.FL THEN
READV TEST FROM IINP.FILE,INCL.PROG,1 ELSE INCL.FL = ""
END
IF INCL.FL THEN
PC = "I"
MATREAD INCL.LINES FROM IINP.FILE,INCL.PROG ELSE MAT INCL.LINES = ""
LINE = "*"; GOSUB PRINTLINE; INCL.NUM = 1
LOOP LINE = INCL.LINES(INCL.NUM) UNTIL LINE = "" DO
NUM = INCL.NUM:"I"
GOSUB PRINTLINE
INCL.NUM = INCL.NUM+1
TOT.INCL = TOT.INCL+1
TOT.NUM = TOT.NUM+1
REPEAT
IF INCL.NUM > 1 THEN LINE = "*"; GOSUB PRINTLINE
PC = "*"
END
NUM = SAVE.NUM
END
NUM = NUM+1
TOT.NUM = TOT.NUM + 1
REPEAT
*
IF PC.STORED # "" THEN
IF DCOUNT(PC.STORED,AM)+LINE.NUM+20 > MAX.LINES THEN LINE.NUM = MAX.LINES; PRINTER ON; GOSUB HEADER; PRINTER OFF
PRINTER ON
PRINT; PRINT
PRINT "TOTALS......  Lines printed: ":TOT.NUM "R#4"
PRINT "              Program lines: ":NUM "R#4"
PRINT "             Included lines: ":TOT.INCL "R#4"
PRINT
LINE.NUM = LINE.NUM+6
CN = 0
LOOP WHILE PC.STORED # "" DO PRINT PC.STORED<1>; LINE.NUM = LINE.NUM+1; PC.STORED = DELETE(PC.STORED,1) REPEAT 
PRINT
LINE.NUM = LINE.NUM + 1
PRINTER OFF
PRINTER CLOSE
END
RETURN
!
!
!
PRINTLINE: * ANALYSE AND PRINT LINE
T.LEFT = 0; T.RIGHT = 0; LABEL = ""
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-T.LEFT; IF TAB < 0 THEN TAB = 0
INDENT = TAB*3; P.LINE = NUM "R#5":" "
INDENT.PR = ""
FOR TEMP = 1 TO TAB; INDENT.PR = INDENT.PR:"!  "; NEXT TEMP
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6):INDENT.PR:STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":INDENT.PR:LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LINE # "" THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
PRINTER ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]
P.LINE = SPACE(12):INDENT.PR:P.LINE[POS+1,999]
REPEAT
PRINT P.LINE; TAB = TAB+T.RIGHT; PRINTER OFF
PRINT PC:; PC.STORED = PC.STORED:PC
PC.CN = PC.CN + 1
IF PC.CN > 50 THEN
PRINT
PC.STORED = PC.STORED:AM
PC.CN = 1
END
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
BEGIN CASE
CASE FIRST = "IF" OR FIRST = "LOCATE" OR FIRST[1,4] = "READ" OR FIRST[1,7] = "MATREAD" OR FIRST = "WRITET" OR FIRST = "WEOF" OR FIRST = "OPEN"
GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "LOOP"; GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST NE "REPEAT;" THEN T.RIGHT = 1
CASE FIRST = "WHILE" OR FIRST = "UNTIL"; T.LEFT = 1; GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST[1,7] NE "REPEAT;" THEN T.RIGHT = 1
CASE FIRST = "FOR"; POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN T.RIGHT = 1
CASE FIRST = "BEGIN"; T.RIGHT = 1; CASE.FLAG = 1
CASE FIRST = "CASE"; T.RIGHT = 1; IF CASE.FLAG = 1 THEN CASE.FLAG = 0 ELSE T.LEFT = 1
CASE FIRST = "END" OR FIRST[1,4] = "END;"
IF LINE[POS+1,4] = "CASE" THEN T.LEFT = 2; RETURN
T.LEFT = 1; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = 1
CASE FIRST = "NEXT" OR FIRST = "REPEAT" OR FIRST[1,7] = "REPEAT;"; T.LEFT = 1
END CASE
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = 1
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
LASTWORD: * GET LAST WORD
POS = LEN(LINE)
LOOP WHILE LINE[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = "" OR NOT(POS) DO POS = POS-1 REPEAT
LAST = TRIM(LINE[POS+1,999])
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
PRINTER CLOSE
MSK = "L#":MAX.COLS-50
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
PRINT FF:TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":LF
RETURN
*
!
END
~SYS.REL.COMPARE~
*PROGRAM: SYS.REL.COMPARE
*
* AUTHOR: DAVID G. HORSMAN
*
* ORIG AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       COMPARES VERSION OF A PROGRAM (OR OTHER ITEM) IN 
*                    <file.name> WITH THE ONE IN OLD.<file.name> AND OUTPUTS THE CHANGES
*                    INTO FILE <file.name>.CHANGES UNDER THE SAME ITEM ID.
*                    FORMAT OF <file.name>.CHANGES ITEM:
*                       ATTR 1: <byte total>,<cksum>,<byte total>,<cksum>
*                                      from CHECK-SUM verb:
*                                           . first are for change item less attr 1
*                                           . second are for item in <file.name>
*                       ATTR 2: <from>[-<to>] [,...]       (deletions from OLD.<file.name>)
*                       ATTR 3- <line#> <space> <line>
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
!
SYS.ABORT = FALSE
USER.ABORT = FALSE
*#
PRINT CLL:"[=| ":"**** COMPARE ****"
PRINT CLL:"[=| "
PRINT CLL:"[=| ":"Enter the item (dict;file;program): ":
INPUT ITEM.NAME
PRINT CLL:"[=| "
*#
PRINT CLL:"[=| ":"Enter the old file: ":
INPUT OLD.NAME
PRINT CLL:"[=| "
IF OLD.NAME EQ "+++" THEN OLD.NAME = ""
*#
PRINT CLL:"[=| ":"Enter the changes file: ":
INPUT CHG.NAME
PRINT CLL:"[=| "
IF CHG.NAME EQ "+++" THEN CHG.NAME = ""
IF CHG.NAME EQ "" THEN CHG.NAME = "COMPARE.CHANGES"
*#
PRINT CLL:"[=| ":"Enter the change file item prefix: ":
INPUT CHG.PREFIX
PRINT CLL:"[=| "
IF CHG.PREFIX EQ "+++" THEN CHG.PREFIX = ""
*#
PRINT CLL:"[=| ":"Enter the change file item suffix: ":
INPUT CHG.SUFFIX
PRINT CLL:"[=| "
IF CHG.SUFFIX EQ "+++" THEN CHG.SUFFIX = ""
*#
PRINT CLL:"[=| ":"Enter the new item bytes,checksum (if known): ":
INPUT CHG.CHECKSUM
PRINT CLL:"[=| "
IF CHG.PREFIX EQ "+++" THEN CHG.PREFIX = ""
*#
*#
NO.OLD = ""
IF ITEM.NAME[1,8] EQ "*NO.OLD*" THEN
NO.OLD = 1
ITEM.NAME = ITEM.NAME[9,99]
END
*#
DICT.NAME = TRIM(FIELD(ITEM.NAME,";",1))
FL.NAME = TRIM(FIELD(ITEM.NAME,";",2))
PGM.NAME = TRIM(FIELD(ITEM.NAME,";",3))
ITEM.NAME1 = TRIM(FIELD(ITEM.NAME,";",4))
IF NOT(LEN(ITEM.NAME1)) THEN ITEM.NAME1 = PGM.NAME
IF FL.NAME[1,5] EQ "DICT " THEN DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
IF FL.NAME[1,5] EQ "DICT." THEN DICT.NAME = "DICT"; FL.NAME = FL.NAME[6,99]
COMBINED.FL = TRIM(DICT.NAME:" ":FL.NAME)
*#
PRINT CLL:"[=| "
PRINT CLL:"[=| "
PRINT CLL:"[=| ":"Enter the item (dict;file;program): ":DICT.NAME:";":FL.NAME:";":PGM.NAME
PRINT CLL:"[=| ":"The old item that will be used here: ":ITEM.NAME1
PRINT CLL:"[=| ":"Enter the old file: ":OLD.NAME
PRINT CLL:"[=| ":"Enter the changes file: ":CHG.NAME
PRINT CLL:"[=| ":"Enter the change file item prefix: ":CHG.PREFIX
PRINT CLL:"[=| ":"Enter the change file item suffix: ":CHG.SUFFIX
PRINT CLL:"[=| ":"Enter the new item bytes,checksum (if known): ":CHG.CHECKSUM
PRINT CLL:"[=| "
*#
OPEN DICT.NAME,FL.NAME TO BP.FILE ELSE PRINT CLL:BELL:"[=| ":"Can't find ":COMBINED.FL:; PRINT BELL:; RQM; STOP
*#
*COMBINED.OLD.FL = TRIM(DICT.NAME:" OLD.":FL.NAME)
COMBINED.OLD.FL = OLD.NAME
TEMP = FIELD(COMBINED.OLD.FL," ",2)
IF TEMP THEN
OLD.DICT.NAME = FIELD(COMBINED.OLD.FL," ",1)
OLD.FL.NAME = TEMP
END ELSE
OLD.DICT.NAME = ""
OLD.FL.NAME = COMBINED.OLD.FL
END
*#
OPEN OLD.DICT.NAME,OLD.FL.NAME TO OLD.FILE ELSE PRINT CLL:BELL:"[=| ":"Can't find ":COMBINED.OLD.FL:; PRINT BELL:; RQM; STOP
*#
*CHG.NAME = FL.NAME:".CHANGES"
COMBINED.CHANGES = TRIM(DICT.NAME:" ":CHG.NAME)
OPEN DICT.NAME,CHG.NAME TO CH.FILE ELSE PRINT CLL:BELL:"[=| ":"Can't find ":COMBINED.CHANGES:; PRINT BELL:; RQM; STOP
*#
IF NO.OLD THEN OLN = "" ELSE
READ OLN FROM OLD.FILE, ITEM.NAME1 ELSE OLN = ""
END
*#
READ NLN FROM BP.FILE, PGM.NAME ELSE PRINT CLL:BELL:"[=| ":PGM.NAME:" not in ":COMBINED.FL:; PRINT BELL:; RQM; STOP
CHANGE.FLAG = FALSE
*#
IF LEN(CHG.CHECKSUM) THEN CH.OUT = CHG.CHECKSUM ELSE
EXLN = 'CHECK-SUM ':COMBINED.FL:' "':PGM.NAME:'"'
EXECUTE EXLN, //OUT. > CH.OUT
CH.OUT = TRIM(CH.OUT<2>)
CH.OUT = FIELD(CH.OUT," ",3):",":FIELD(CH.OUT," ",12)
END
*#
CHG = ""
CHG.DEL = ""
CHC = 1; *CHANGE COUNTER
CHC.DEL = 1; *DELETE COUNTER
NLC = 0; *BP COUNTER
NLCTR = 0; *OVERALL BP COUNTER
OLC = 0; *OLD.BP COUNTER
OLC1 = 0; *OLD.BP DELETE
OLCTR = 0; *OVERALL OLD.BP COUNTER
MAX.NLC = COUNT(NLN,AM)+1
MAX.OLC = COUNT(OLN,AM)+1
LST.DLT = 9999; LST.RNG = ""
OLC1.STOP = 9999
DELIM = "$$$":"%%%":"$$$"
PRINT CLL:"[=| "
PRINT CLL:"[=| "
PRINT CLL:"[=| "
PRINT CLL:"[=| ":PGM.NAME
PRINT CLL:"[=| "
*#
*#
LOOP
PRINT ".":OLCTR:".":
*#
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
*#
IF OLC > 49 AND NOT(OLC1) THEN
OLN<OLC> = DELIM
TMP = INDEX(OLN,DELIM,1)
OLN = OLN[TMP+LEN(DELIM)+1,50000]
MAX.OLC = MAX.OLC-OLC
OLC = 0
END
*#
NLC = NLC+1
NLCTR = NLCTR+1
OLC = OLC+1
OLCTR = OLCTR+1
*PRINT CLL:"[=| ":@(70):RVB:OLCTR "R#4":RVE:
NEWL = NLN<NLC>
OLDL = OLN<OLC>
*#
UNTIL (SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT OR OLC GT MAX.OLC DO
*#
IF NEWL NE OLDL THEN
NLC1 = NLC
*IF NOT(LST.RNG) THEN OLC1 = OLC
*#
NXT.TRY: *#
*#
TCN = 0
LOOP
NLC1 = NLC1+1
NEWL = NLN<NLC1>
UNTIL (SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT OR (NLC1 GT MAX.NLC OR NEWL = OLDL OR NLC1-100 GT NLC) DO
$INCLUDE IBP SYS.INCL.11.ABORT
TCN = TCN + 1
IF TCN GE 10 THEN
PRINT ",":
TCN = 0
END
REPEAT
*#
*FOR EQCTR = 1 TO 9 UNTIL NLN<NLC1+EQCTR> NE OLN<OLC+EQCTR>
*PRINT "s":
*NEXT EQCTR
*IF EQCTR < 9 THEN GOTO NXT.TRY
**#
IF NLC1 GT MAX.NLC OR NEWL NE OLDL THEN
*#
SKIP.FLAG = FALSE
FOR EQCTR = 1 TO 9 UNTIL NLN<NLC1+EQCTR> NE OLN<OLC+EQCTR>
PRINT "s":
NEXT EQCTR
IF EQCTR < 9 THEN SKIP.FLAG = TRUE
*#
IF LST.DLT EQ OLCTR-1 THEN
LST.RNG = OLCTR
IF NOT(OLC1) THEN OLC1 = OLC; OLC2 = OLCTR
*#
END ELSE IF NOT(SKIP.FLAG) THEN
IF LST.RNG THEN
CHG<1> = CHG<1>:"-":LST.RNG; LST.RNG = ""
END
IF OLC1 THEN 
IF CHG<1> NE "" THEN CHG<1> = CHG<1>:","
CHG<1> = CHG<1>:OLC2
GOSUB EXTR.DEL
END
OLC1 = OLC; OLC2 = OLCTR
END
*#
LST.DLT = OLCTR
OLC1.STOP = OLC
NLC = NLC-1
NLCTR = NLCTR-1
END ELSE
*#
FOR EQCTR = 1 TO 9 UNTIL NLN<NLC1+EQCTR> NE OLN<OLC+EQCTR>
PRINT "s":
NEXT EQCTR
IF EQCTR < 9 THEN GOTO NXT.TRY
*#
PRINT " |=]"
PRINT CLL:"[=| ":"* INSERT *"
LOOP UNTIL (SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT OR NLC EQ NLC1 DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NLN<NLC>
TEMP = NLN<NLC>
LOOP UNTIL NOT(LEN(TEMP)) OR TEMP[1,1] NE " " DO TEMP = TEMP[2,9999] REPEAT
IF TEMP[1,1] NE "*" AND TEMP[1,1] NE "!" AND TEMP[1,3] NE "REM" AND LEN(TEMP) THEN CHANGE.FLAG = TRUE
PRINT CLL:"[=| ":CHG<CHC>
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC1 = NLC1 - NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
REPEAT
*#
IF OLC1 THEN
IF CHG<1> NE "" THEN CHG<1> = CHG<1>:","
CHG<1> = CHG<1>:OLC2
NEWL = ""
GOSUB EXTR.DEL
END
*#
END; *# NLC1 GT MAX.NLC
*#
END; *# NEWL NE OLDL
*#
REPEAT
*#
PRINT " |=]"
PRINT CLL:"[=| "
PRINT CLL:"[=| ":"* INSERT *"
LOOP UNTIL (SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT OR NLC > MAX.NLC DO
CHC = CHC+1
CHG<CHC> = NLCTR:" ":NEWL
PRINT CLL:"[=| ":CHG<CHC>
IF NLC > 49 THEN
NLN<NLC> = DELIM
TMP = INDEX(NLN,DELIM,1)
NLN = NLN[TMP+LEN(DELIM)+1,50000]
MAX.NLC = MAX.NLC-NLC
NLC = 0
END
NLC = NLC+1
NLCTR = NLCTR+1
NEWL = NLN<NLC>
REPEAT
*#
IF LST.RNG THEN
CHG<1> = CHG<1>:"-":LST.RNG
END
IF NOT((SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT) AND OLC1 THEN GOSUB EXTR.DEL
*#
IF NOT((SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT) THEN
WRITE CHG ON CH.FILE, CHG.PREFIX:PGM.NAME:CHG.SUFFIX
EXLN = 'CHECK-SUM ':COMBINED.CHANGES:' "':CHG.PREFIX:PGM.NAME:CHG.SUFFIX:'"'
EXECUTE EXLN, //OUT. > CH.OUTC
CH.OUTC = TRIM(CH.OUTC<2>)
CH.OUTC = FIELD(CH.OUTC," ",3):",":FIELD(CH.OUTC," ",12)
OLN = ""; NLN = ""; CHG = ""
READ CHG FROM CH.FILE, CHG.PREFIX:PGM.NAME:CHG.SUFFIX ELSE PRINT CLL:BELL:"[=| ":"Just wrote it, now I can't find it":; PRINT BELL:; RQM; STOP
CH.OUT = CH.OUTC:",":CH.OUT
*# CHG<1,1> =  OLD BYTES, OLD CHECK.SUM, BP BYTES, BP CHECK.SUM
INS CH.OUT BEFORE CHG<1>
CHG<1,2> = CHANGE.FLAG
CHG<1,3> = NLCTR
CHG<1,4> = OLCTR
CHG<1,5> = OLD.NAME:SVM:CHG.NAME:SVM:CHG.PREFIX:SVM:CHG.SUFFIX
CHG<1,6> = "c":SVM:DATE():SVM:TIME():SVM:ACCT:SVM:PORT
CHG<-1> = "****DELETES****"
CHG<-1> = CHG.DEL
WRITE CHG ON CH.FILE, CHG.PREFIX:PGM.NAME:CHG.SUFFIX
END
*#
*#
GOTO END.OF.PROG
*#
EXTR.DEL: *#
$INCLUDE IBP SYS.INCL.11.ABORT
*#
IF NLC1 GT MAX.NLC OR OLDL NE NEWL THEN OLC1.STOP = OLC1.STOP + 1
PRINT " |=]"
PRINT CLL:"[=| "
PRINT CLL:"[=| ":"* DELETE *"
LOOP UNTIL (SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT OR OLC1 GE OLC1.STOP DO
CHG.DEL<CHC.DEL> = "*del* ":OLCTR-OLC+OLC1:" ":OLN<OLC1>
TEMP = OLN<OLC1>
LOOP UNTIL NOT(LEN(TEMP)) OR TEMP[1,1] NE " " DO TEMP = TEMP[2,9999] REPEAT
IF TEMP[1,1] NE "*" AND TEMP[1,1] NE "!" AND TEMP[1,3] NE "REM" THEN CHANGE.FLAG = TRUE
PRINT CLL:"[=| ":CHG.DEL<CHC.DEL>
CHC.DEL = CHC.DEL+1
*IF OLC1 > 49 THEN
*OLN<OLC1> = DELIM
*TMP = INDEX(OLN,DELIM,1)
*OLN = OLN[TMP+LEN(DELIM)+1,50000]
*MAX.OLC = MAX.OLC-OLC1
*OLC = OLC - OLC1
*OLC1 = 0
*END
OLC1 = OLC1+1
*OLCTR = OLCTR+1
REPEAT
*#
OLC1 = 0
OLC1.STOP = 0
*#
RETURN
*#
$INCLUDE IBP SYS.REL.INCL.ERROR
*#
END.OF.PROG: *#
*#
*#
END
~SYS.REL.COMPARE.SUB~
SUBROUTINE SYS.REL.COMPARE.SUB(SY.FILE,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TASK.FILE,TASK.ITEM,TASK.OLD,TASK.XTR,TASK.CHG,XREF.FUNC,XREF.INDEX.ID,TASK.INDEX.DATA,STAT,SYS.RUN.STAT)
*SUBROUTINE: SYS.REL.COMPARE.SUB
*
* AUTHOR: DAVID G. HORSMAN
*
*# DESCRIPTION:       COMPARE ALL PROGRAMS FROM <file.name> TO OLD.<file.name> FOR TRANSMISSION OF CHANGES
*#
*# XREF.FUNC
*# 3 - CALC CHECK.SUMS
*# 4 - RELEASE (CHECK.SUMS & COMPARE TO REL.CHANGES)
*# ANY OTHER - RETRIEVE CHECK.SUM FROM FILES
*#
!
$INCLUDE IBP STANDARD.FUNCTIONS
*#
SYS.PROG = "SYS.REL.COMPARE.SUB"
SYS.PROG.TYPE = 7
EQ.PROG.TYPE = 7
SYS.ABORT = FALSE
USER.ABORT = FALSE
TITLE = "Compare programs (or other files)"
DEL.FLAG = FALSE
STAT = TRUE
*#
TASK.NEW = TASK.FILE
ID = TASK.ITEM
PRINTER ON
*PRINT CLL:"[=| "
PRINT CLL:"[=| "
PRINT CLL:"[=| ":TITLE
*PRINT CLL:"[=| "
*#
FIRST = TRUE
OLD.FLAG = FALSE
XTR.FLAG = FALSE
PRINT.FLAG = FALSE
*PRINT @(0,5):CLL:
*#
*INPUT AUTO.RUN
AUTO.RUN = FALSE
NO.OLD = FALSE; IF AUTO.RUN GT 2 THEN NO.OLD = TRUE; AUTO.RUN = AUTO.RUN - 3
NO.XTR = FALSE
IF NOT(LEN(TASK.OLD)) THEN NO.OLD = TRUE
IF NOT(LEN(TASK.XTR)) THEN NO.XTR = TRUE
SELECT.DONE = FALSE; IF AUTO.RUN EQ 2 THEN SELECT.DONE = TRUE; AUTO.RUN = FALSE
*#
IF AUTO.RUN THEN
READ CURRENT.RUN FROM SY.FILE,"CURRENT.RUN" ELSE 
PRINT CLL:"[=| "
PRINT CLL:"[=| ":BELL:"** NO CURRENT RUN **"
PRINT CLL:"[=| "
CURRENT.RUN = AM:TASK.NEW:AM:TASK.ITEM
END
FL.NAME = CURRENT.RUN<1,2>
FL.ITEM = CURRENT.RUN<1,3>
TASK.NEW = FL.NAME
TASK.ITEM = FL.ITEM
*#
END ELSE
**PRINT CLL:"[=| ":"FILE NAME <BP>: ":; INPUT TASK.NEW
IF TASK.NEW EQ "" THEN TASK.NEW = "BP"
IF TASK.OLD EQ "" THEN TASK.OLD = "OLD.":TASK.NEW
IF TASK.XTR EQ "" THEN TASK.XTR = "PC.":TASK.NEW
IF TASK.CHG EQ "" THEN TASK.CHG = TASK.NEW:".CHANGES"
FL.NAME = TASK.NEW
FL.ITEM = TASK.ITEM
*CALL AUTO.LOADER("COMPARE-PROGS",FL.NAME:AM:FL.ITEM,"Compare ":FL.NAME)
END
*#
DICT.NAME = ""; IF TASK.NEW[1,5] EQ "DICT " THEN DICT.NAME = "DICT"; TASK.NEW = TASK.NEW[6,99]
OPEN DICT.NAME,TASK.NEW TO NEW.CFILE ELSE
SYS.ABORT = 6
ERROR.TEXT = "The file ":DICT.NAME:" ":TASK.NEW:" is missing, ABORT!"
ERROR.CODE = "29000"
PRINTER OFF; GOSUB ERROR.CONTROL; PRINTER ON
END
NEW.SUMS = ""
*DIFFERENCE.FOUND = ""
*#
IF NOT(NO.OLD) THEN
SYS.ITEM = XREF.INDEX.ID:"@":TASK.OLD
READ OLD.SUMS.INDEX FROM SY.FILE,SYS.ITEM ELSE OLD.SUMS.INDEX = ""
SYS.ITEM = XREF.INDEX.ID:"@":TASK.OLD:"@DATA"
READ OLD.SUMS FROM SY.FILE,SYS.ITEM ELSE OLD.SUMS = ""
END ELSE OLD.SUMS.INDEX = ''; OLD.SUMS = ''
*#
SYS.ITEM = XREF.INDEX.ID:"@":TASK.NEW
READ NEW.SUMS.INDEX FROM SY.FILE,SYS.ITEM ELSE NEW.SUMS.INDEX = OLD.SUMS.INDEX 
SYS.ITEM = XREF.INDEX.ID:"@":TASK.NEW:"@DATA"
PRINT BELL:; RQM; RQM; PRINT BELL:RVB:"READ ":TASK.ITEM:" TASK DATA":RVE:BELL; RQM
READ NEW.SUMS FROM SY.FILE,SYS.ITEM ELSE NEW.SUMS = OLD.SUMS
*#
IF NOT(NO.XTR) THEN
SYS.ITEM = XREF.INDEX.ID:"@":TASK.XTR
READ XTR.SUMS.INDEX FROM SY.FILE,SYS.ITEM ELSE XTR.SUMS.INDEX = OLD.SUMS.INDEX
SYS.ITEM = XREF.INDEX.ID:"@":TASK.XTR:"@DATA"
READ XTR.SUMS FROM SY.FILE,SYS.ITEM ELSE XTR.SUMS = ""
END ELSE XTR.SUMS.INDEX = ''; XTR.SUMS = ''
*#
*#IF SELECT.DONE THEN DELETED.ITEMS = "" ELSE DELETED.ITEMS = OLD.SUMS
*DELETED.ITEMS = ID; *# TO FORCE SINGLE ITEM PROCESSING
DELETED.ITEMS = ""
AC = 1
LOOP UNTIL DELETED.ITEMS<AC> = "" DO
DELETED.ITEMS<AC> = DELETED.ITEMS<AC,1>
AC = AC+1
REPEAT
PROCESS.DELETED.ITEMS = ""
*#
*PRINTER ON
*PRINT
*PRINTER OFF
*OLD.NAME = TASK.OLD:TASK.NEW
IF NOT(NO.OLD) THEN
OLD.NAME = TASK.OLD
END ELSE IF NOT(NO.XTR) THEN
OLD.NAME = TASK.XTR
END ELSE SYS.ABORT = 6
*#
*TASK.CHG = TASK.NEW:".CHANGES"
LOOP UNTIL NOT(STAT) DO
OPEN DICT.NAME,TASK.CHG TO CHG.CFILE THEN STAT = FALSE ELSE
IF TASK.CHG EQ "COMPARE.CHANGES" THEN
SYS.ABORT = 6; STAT = FALSE
ERROR.TEXT = "The file ":DICT.NAME:" ":TASK.CHG:" is missing, ABORT!"
ERROR.CODE = "29000"
PRINTER OFF; GOSUB ERROR.CONTROL; PRINTER ON
END ELSE TASK.CHG = "COMPARE.CHANGES"; STAT = 66
END
REPEAT
*#
IF NOT((SYS.ABORT AND SYS.ABORT NE 1) OR USER.ABORT) THEN
IF NOT(NO.OLD AND NO.XTR) THEN
OPEN DICT.NAME,OLD.NAME TO OLD.CFILE ELSE
SYS.ABORT = 6
ERROR.TEXT = "The file ":DICT.NAME:" ":OLD.NAME:" is missing, ABORT!"
ERROR.CODE = "29000"
PRINTER OFF; GOSUB ERROR.CONTROL; PRINTER ON
END
END
*#
END; *# OF NOT ABORT
*#
*TASK.CHG = TASK.NEW:".CHANGES"
**LOOP UNTIL NOT(STAT) DO
**OPEN DICT.NAME,TASK.CHG TO CHG.CFILE THEN STAT = FALSE ELSE
**IF TASK.CHG EQ "COMPARE.CHANGES" THEN
**SYS.ABORT = 6; STAT = FALSE
**ERROR.TEXT = "The file ":DICT.NAME:" ":TASK.CHG:" is missing, ABORT!"
**ERROR.CODE = "29000"
**PRINTER OFF; GOSUB ERROR.CONTROL; PRINTER ON
**END ELSE TASK.CHG = "COMPARE.CHANGES"; STAT = 66
**END
**REPEAT
IF SELECT.DONE THEN
READNEXT ID THEN
TASK.ITEM = ID
END ELSE
SELECT.DONE = FALSE
IF NOT(LEN(TASK.ITEM)) THEN
PRINT BELL:CLL
PRINT CLL
PRINT CLL:"Enter Task Item: ":; INPUT TASK.ITEM
PRINT CLL
IF NOT(LEN(TASK.ITEM)) THEN RETURN; *# TO CALLING PROGRAM
END; *# OF NO TASK
END; *# OF NO ID
END; *# OF SELECT
*#
*#
NXT: *#
PRINT " ":RVB:"NXT":RVE:" ":
*#
IF SYS.ABORT GT 1 OR USER.ABORT THEN GOTO END.OF.PROG
*#
IF PROCESS.DELETED.ITEMS THEN
ID = DELETED.ITEMS<PROCESS.DELETED.ITEMS>
PROCESS.DELETED.ITEMS = PROCESS.DELETED.ITEMS+1
IF ID EQ "" THEN SYS.ABORT = 1
END ELSE
*#
IF FIRST THEN
ID = TASK.ITEM
FIRST = ''
*#
END ELSE
IF SELECT.DONE THEN
READNEXT ID ELSE
PROCESS.DELETED.ITEMS = TRUE
END
END ELSE PROCESS.DELETED.ITEMS = TRUE
*#
IF PROCESS.DELETED.ITEMS = TRUE THEN GOTO NXT
END; *# OF NOT FIRST
*#
IF NOT(SYS.ABORT OR USER.ABORT) THEN
*#
IF TASK.NEW EQ "MD" THEN
READV DCODE FROM NEW.CFILE,TASK.ITEM,1 ELSE DCODE = ""
IF LEN(DCODE) LT 3 AND DCODE[1,1] EQ "D" THEN GOTO NXT
END
*#
*PRINT CLL:"[=| ":@(0,5):CLS:
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":"*** *** *** ":TASK.NEW:" ":TASK.ITEM:" *** *** *** "
*PRINT CLL:"[=| "
*#
$INCLUDE IBP SYS.INCL.11.ABORT
IF NOT(SYS.ABORT GT 1 OR USER.ABORT) THEN
*#
IF XREF.FUNC EQ 3 OR XREF.FUNC EQ 4 THEN
*#
EXLN = 'CHECK-SUM ':TRIM(DICT.NAME:' ':TASK.NEW):' "':TASK.ITEM:'"'
EXECUTE EXLN, //OUT. > BP.OUT
*#
$INCLUDE IBP SYS.INCL.11.ABORT
IF NOT(SYS.ABORT GT 1 OR USER.ABORT) THEN
*#
IF NO.OLD THEN OLD.OUT = "" ELSE
EXLN = 'CHECK-SUM ':TRIM(DICT.NAME:' ':TASK.OLD):' "':TASK.ITEM:'"'
EXECUTE EXLN, //OUT. > OLD.OUT
END
*#
$INCLUDE IBP SYS.INCL.11.ABORT
IF NOT(SYS.ABORT GT 1 OR USER.ABORT) THEN
*#
IF NO.XTR THEN XTR.OUT = "" ELSE
EXLN = 'CHECK-SUM ':TRIM(DICT.NAME:' ':TASK.XTR):' "':TASK.ITEM:'"'
EXECUTE EXLN, //OUT. > XTR.OUT
END
*#
END; *# OF NOT ABORT
END; *# OF NOT ABORT
*#
*#
IF NOT(NO.OLD) THEN
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":"  ":TASK.OLD:" ITEM  "
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":OLD.OUT<1>
PRINT CLL:"[=| ":OLD.OUT<2>
*PRINT CLL:"[=| "
END
*#
IF NOT(NO.XTR) THEN
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":"  ":TASK.XTR:" ITEM "
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":XTR.OUT<1>
PRINT CLL:"[=| ":XTR.OUT<2>
*PRINT CLL:"[=| "
END
*#
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":"  ":TASK.NEW:" ITEM "
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":BP.OUT<1>
PRINT CLL:"[=| ":BP.OUT<2>
TCL.LINE = BP.OUT<2>
*#
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":STR("-",70)
*PRINT CLL:"[=| "
*#
END ELSE
BP.OUT = ""
OLD.OUT = ""
XTR.OUT = ""
END; *# OF FUNC 3 OR 4
*#
PRINTER OFF
IF PROCESS.DELETED.ITEMS THEN
*DELETE OLD.CFILE,TASK.ITEM
*CSUM = "\\\DELETED\\\"
*CBYTES = 0
DEL.FLAG = TRUE
END ELSE
TMP = TCL.LINE
GOSUB PARSE.IT
CSUM = CKSUM
CBYTES = BYTES
LOCATE(TASK.ITEM,DELETED.ITEMS;LOC) THEN DEL DELETED.ITEMS<LOC> ELSE LOC = 0
END
*#
TASK.COMP.ID = TASK.NEW:"@":TASK.ITEM
LOCATE(TASK.COMP.ID,NEW.SUMS.INDEX;SUMS.LOC;"AL") ELSE
NEW.SUMS.INDEX = INSERT(NEW.SUMS.INDEX,SUMS.LOC,0,0;TASK.COMP.ID)
NEW.SUMS       = INSERT(NEW.SUMS,SUMS.LOC,0,0;"")
END
TASK.INDEX.DATA = NEW.SUMS<SUMS.LOC>
TASK.INDEX.DATA<1,1> = TASK.ITEM
TASK.INDEX.DATA<1,2> = CSUM
TASK.INDEX.DATA<1,3> = CBYTES
IF NOT(XREF.FUNC EQ 3 OR XREF.FUNC EQ 4) THEN
BP.OUT<2> = TASK.INDEX.DATA
END
*#
PRINT.FLAG = FALSE
NEW.FLAG = TRUE
OLD.FLAG = FALSE
XTR.FLAG = FALSE
*#
IF NOT(NO.OLD) THEN
*TASK.COMP.ID = TASK.NEW:"@":TASK.ITEM
LOCATE(TASK.COMP.ID,OLD.SUMS.INDEX;LOC;"AL") ELSE
OLD.SUMS.INDEX = INSERT(OLD.SUMS.INDEX,LOC,0,0;TASK.COMP.ID)
OLD.SUMS       = INSERT(OLD.SUMS,LOC,0,0;"")
END
OLD.LOC = LOC
IF XREF.FUNC EQ 3 OR XREF.FUNC EQ 4 THEN
TMP = OLD.OUT<2>
GOSUB PARSE.IT
OLD.SUMS<LOC> = TASK.ITEM:VM:CKSUM:VM:BYTES
END ELSE
OLD.OUT<2> = OLD.SUMS<LOC>
END
*#
IF BP.OUT<1>[1,22] EQ "[10] File name missing" OR BP.OUT<2>[1,12] EQ "[780] Item '" THEN
TASK.INDEX.DATA<1,11> = 2
NEW.FLAG = FALSE
END ELSE IF OLD.OUT<1>[1,22] NE "[10] File name missing" AND OLD.OUT<2> NE BP.OUT<2> THEN
PRINT.FLAG = TRUE
TASK.INDEX.DATA<1,11> = TRUE
END
*#
IF OLD.OUT<1>[1,22] NE "[10] File name missing" AND OLD.OUT NE "[780] Item '" THEN OLD.FLAG = TRUE
END
*#
IF NOT(NO.XTR) THEN
*TASK.COMP.ID = TASK.NEW:"@":TASK.ITEM
LOCATE(TASK.COMP.ID,XTR.SUMS.INDEX;LOC;"AL") ELSE
XTR.SUMS.INDEX = INSERT(XTR.SUMS.INDEX,LOC,0,0;TASK.COMP.ID)
XTR.SUMS       = INSERT(XTR.SUMS,LOC,0,0;"")
END
XTR.LOC = LOC
IF XREF.FUNC EQ 3 OR XREF.FUNC EQ 4 THEN
TMP = XTR.OUT<2>
GOSUB PARSE.IT
XTR.SUMS<LOC> = TASK.ITEM:VM:CKSUM:VM:BYTES
END ELSE
XTR.OUT<2> = XTR.SUMS<LOC>
END
IF XTR.OUT<1>[1,22] EQ "[10] File name missing" OR XTR.OUT<2>[1,12] EQ "[780] Item '" THEN
TASK.INDEX.DATA<1,12> = 2
XTR.FLAG = FALSE
END ELSE IF XTR.OUT<1>[1,22] NE "[10] File name missing" AND XTR.OUT<2> NE BP.OUT<2> THEN
PRINT.FLAG = 2
TASK.INDEX.DATA<1,12> = TRUE
XTR.FLAG = TRUE
END
END
*#
*TASK.INDEX.DATA<1,10> = DEL.FLAG
NEW.SUMS<SUMS.LOC> = TASK.INDEX.DATA
*#
END; *# OF NOT ABORT
*#
*#
IF NOT(SYS.ABORT GT 1 OR USER.ABORT) AND PRINT.FLAG THEN
FOR COMP.CN = 1 TO PRINT.FLAG
*#
IF COMP.CN EQ 2 THEN
TASK.COMP.FILE = TASK.XTR
END ELSE
TASK.COMP.FILE = TASK.NEW
END
*#
PRINTER ON
*#
IF SYS.RUN.STAT EQ 2 THEN
*DIFFERENCE.FOUND = -1
SYS.RUN.STAT = 3
PRINT FF:
PRINT OCONV(DATE(),'D2'):'         Compare of all items in ':TRIM(DICT.NAME:' ':TASK.NEW)
PRINT
PRINT
PRINT "                                             Prior to change:              Current:                    bytes"
PRINT "Item.id....................................  ...bytes ......checksum       ...bytes ......checksum      diff"
PRINT
END
*#
IF COMP.CN EQ 1 THEN
PRINT TASK.COMP.FILE "R#9":" ":TASK.ITEM "L#35":
BYTES = 0
*#
IF NO.OLD THEN PRINT "Not compared           ": ELSE
TMP = OLD.OUT<2>
GOSUB PARSE.IT
IF NOT(BYTES) THEN PRINT "Not on file            ": ELSE
PRINT BYTES "R#8":CKSUM "R#15":
END
END
*#
DIFF = BYTES
TMP = BP.OUT<2>
GOSUB PARSE.IT
IF BYTES EQ "" THEN PRINT "       Not on file            ": ELSE PRINT BYTES "R#15":CKSUM "R#15":
PRINT (BYTES-DIFF) "R#10"
END; *# OF PR.FLAG 1
*#
IF NOT(NO.XTR) AND COMP.CN EQ 2 THEN
TMP = XTR.OUT<2>
GOSUB PARSE.IT
TEMP = TASK.XTR:" ":SPACE(ABS(INT(LEN(TASK.ITEM)/2)-4)):"same item"
PRINT TEMP "L#40":" ":BYTES "R#35":CKSUM "R#15":(BYTES-DIFF) "R#10"
TMP = BP.OUT<2>
GOSUB PARSE.IT
END
*#
PRINTER OFF
*PRINTER CLOSE
*#
IF NOT(SYS.ABORT GT 1 OR USER.ABORT) THEN
*WAS NOT(SYS.ABORT GT 1 OR USER.ABORT) AND BYTES THEN
* XREF.FUNC EQ 4 AND
*#
*WAS (COMP.CN EQ 1 AND NO.OLD) OR (COMP.CN EQ 2 AND NO.XTR) THEN TEMP.OLD = TRUE ELSE TEMP.OLD = FALSE
*#
*WAS COMP.CN NE 2 OR NOT(NO.XTR) THEN
EXLN = DICT.NAME:";":TASK.COMP.FILE:";":TASK.ITEM:";":TASK.ITEM
SYS.ITEM = TASK.ITEM
*END ELSE
*EXLN = DICT.NAME:TASK.NEW:";":TASK.ITEM
*END
*#
IF NO.OLD OR NOT(LEN(TASK.COMP.FILE)) THEN
EXLN = "*NO.OLD*":EXLN
EXLN = EXLN:AM:"+++"
END ELSE
*WAS COMP.CN EQ 2 AND NOT(NO.XTR) THEN
*EXLN = EXLN:AM:TASK.NEW
*END ELSE
EXLN = EXLN:AM:TASK.OLD
*END
END
*#
IF NOT(LEN(TASK.CHG)) THEN
EXLN = EXLN:AM:"+++"
END ELSE
EXLN = EXLN:AM:TASK.CHG
END
*#
EXLN = EXLN:AM:"@":TASK.REL:"@"
SYS.ITEM = "@":TASK.REL:"@":TASK.ITEM:"@":TASK.FILE
*#
***IF COMP.CN EQ 1 THEN
***EXLN = EXLN:AM:"+++"
****NO SYS.ITEM
***END ELSE
EXLN = EXLN:AM:"@":TASK.COMP.FILE
SYS.ITEM = "@":TASK.REL:"@":TASK.ITEM:"@":TASK.COMP.FILE
***END
*#
EXLN = EXLN:AM:TASK.INDEX.DATA<1,2>:",":TASK.INDEX.DATA<1,3>
*#
IF XREF.FUNC EQ 4 AND ((COMP.CN EQ TRUE AND TASK.INDEX.DATA<1,11> EQ TRUE) OR (COMP.CN EQ 2 AND TASK.INDEX.DATA<1,12> EQ TRUE)) THEN
*WAS XREF.FUNC EQ 4 (WAS AND BYTES) THEN
EXECUTE "SYS.REL.COMPARE", //IN. < EXLN
*#
FOR TEMP = 1 TO 5
PRINT BELL:
RQM; RQM
NEXT TEMP
*#
FOR TEMP1 = 1 TO 2
IF TEMP1 EQ 2 THEN PRINTER ON
*PRINT CLL:"[=| ":"TASK.INDEX.DATA: ":TASK.INDEX.DATA
*PRINT CLL:"[=| ":"COMP.CN: ":COMP.CN
PRINT CLL:"[=| ":"SYS.ITEM: ":SYS.ITEM
*PRINT CLL:"[=| ":"CHG.FILE: ":TASK.COMP.FILE:",  PREF: ":"@":TASK.REL:"@":", SUFF: ":TASK.OLD:" |=]"
IF TEMP1 EQ 2 THEN PRINTER OFF
NEXT TEMP1
*#
FOR TEMP1 = 1 TO 5; RQM; NEXT TEMP1
*#
IF (COMP.CN EQ TRUE AND TASK.INDEX.DATA<1,11> EQ TRUE) OR (COMP.CN EQ 2 AND TASK.INDEX.DATA<1,12> EQ TRUE) THEN
READ TEMP FROM CHG.CFILE,SYS.ITEM THEN
FOR A = 1 TO 7
IF COMP.CN EQ 1 THEN TASK.INDEX.DATA<1,A+3> = TEMP<1,A> ELSE
XTR.SUMS<XTR.LOC,A+3> = TEMP<1,A>
END
*PRINTER ON
*PRINT CLL:"[=|":A+3:"| ":TEMP<1,A>
*PRINTER OFF
PRINT CLL:"[=|":A+3:"| ":TEMP<1,A>
NEXT A
TEMP = ""
END ELSE TEMP = ""
END; *# OF TIME TO FINALLY TIME TO SET ME STRAIGHT???
*#
*CHG<1,2> = CHANGE.FLAG
*CHG<1,3> = MAX.NLC
*CHG<1,4> = MAX.OLC
*CHG<1,5> = OLD.NAME:SVM:CHG.NAME:SVM:CHG.PREFIX:SVM:CHG.SUFFIX
*CHG<1,6> = XREF.FUNC:SVM:DATE():SVM:TIME():SVM:ACCT:SVMPORT
*#
IF COMP.CN EQ TRUE THEN
NEW.SUMS<SUMS.LOC> = TASK.INDEX.DATA
END
*#
END; *# OF FUNC EQ 4
*#
END; *# OF NOT ABORT
*#
NEXT COMP.CN
IF NOT(SELECT.DONE) THEN
IF NOT(NO.OLD) THEN
SYS.ITEM = XREF.INDEX.ID:"@":TASK.OLD
WRITE OLD.SUMS.INDEX ON SY.FILE,SYS.ITEM
SYS.ITEM = XREF.INDEX.ID:"@":TASK.OLD:"@DATA"
WRITE OLD.SUMS ON SY.FILE,SYS.ITEM
END
*#
IF NOT(NO.XTR) THEN
SYS.ITEM = XREF.INDEX.ID:"@":TASK.XTR
WRITE XTR.SUMS.INDEX ON SY.FILE,SYS.ITEM
SYS.ITEM = XREF.INDEX.ID:"@":TASK.XTR:"@DATA"
WRITE XTR.SUMS ON SY.FILE,SYS.ITEM
END
*#
SYS.ITEM = XREF.INDEX.ID:"@":TASK.NEW
WRITE NEW.SUMS.INDEX ON SY.FILE,SYS.ITEM
SYS.ITEM = XREF.INDEX.ID:"@":TASK.NEW:"@DATA"
WRITE NEW.SUMS ON SY.FILE,SYS.ITEM
*#
END; *# OF NOT SELECT.DONE
*#
PRINT BELL:
*#
END; *# OF PRINT.FLAG
*#
GOTO NXT
*#
END; *# OF NOT ABORT
*#
END; *# OF NOT PROCESS.DELETED.ITEMS
*#
ITEM = "\\\DELETED\\\"
AC = 1
LOOP UNTIL DELETED.ITEMS<AC> = "" DO
TASK.ITEM = DELETED.ITEMS<AC>
WRITE ITEM ON CHG.CFILE,"@":TASK.REL:"@":TASK.ITEM
AC = AC+1
REPEAT
*#
SYS.ABORT = 2
*#
GOTO NXT
*#
***END; *# OF NOT ABORT
****#
***END; *# ??????
****#*#
***END; *# OF NOT ABORT
****#*#
***END; *# OF NOT ABORT
*#*#
GOTO END.OF.PROG
!
PARSE.IT: *
*#
IF XREF.FUNC EQ 3 OR XREF.FUNC EQ 4 THEN
POS = INDEX(TMP,"Cksum = ",1)
IF NOT(POS) THEN CKSUM = "" ELSE CKSUM = FIELD(TMP[POS+8,99]," ",1)
POS = INDEX(TMP,"Total = ",1)
IF NOT(POS) THEN BYTES = "" ELSE BYTES = FIELD(TMP[POS+8,99]," ",1)
*#
END ELSE
CKSUM = TMP<2>
BYTES = TMP<3>
OLD.FLAG = TMP<4>
XTR.FLAG = TMP<5>
END
*#
RETURN
*#
$INCLUDE IBP SYS.REL.INCL.ERROR
*#
END.OF.PROG: *# End of program
*#
STAT = 1
IF SYS.ABORT GT 2 OR USER.ABORT THEN STAT = SYS.ABORT+USER.ABORT
IF SYS.ABORT LE 2 THEN SYS.ABORT = FALSE
*#
*PRINTER CLOSE
*#
RETURN; *# TO CALLING PROGRAM
*#
END
~SYS.REL.EDIT~
*PROGRAM: SYS.REL.EDIT
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*# Load program control and structure variables.
DIM STRUCT(120)
SYS.PROG = "SYS.REL.EDIT"
SYS.PROG.TYPE = 2
NEW.RUN.TYPE = FALSE
EXEC.PARSE.TEXT = ""
*# 0 or unassigned = FOREIGN ROUTINE
*# 1 = TCL PROGRAM
*# 2 = TCL PROC
*# 3 = SYS MAIN (TCL/PROC) ROUTINE
*# 7 = CALL SUBROUTINE
*# 8 = SYS SUBROUTINE CALL
*# 
SYS.ABORT = FALSE
USER.ABORT = FALSE
START.DATE = DATE()
START.TIME = TIME()
BP.RUNS = ""
OLD.RUN.TYPE = FALSE
EXEC.RESULTS = ""
EXEC.PARSE.TEXT =  ""
STAT = FALSE
LIST.ID.FLAG = FALSE
SYS.UPD = ""; SYS.PREFIX = ""; SYS.SUFFIX = ""
*#
$INCLUDE IBP SYS.REL.INCL.PARAMETER.INDEX
$INCLUDE IBP SYS.REL.INCL.PARAMETER.INPUT
*#
$INCLUDE IBP SYS.REL.INCL.FILE.OPEN
$INCLUDE IBP SYS.REL.INCL.USER.LOAD
*# Read the company record that user is working with.
$INCLUDE IBP SYS.INCL.COMPANY.READ
*# Detect a company data mis-match.
IF CO.DATA<4> NE STRUCT(29)<1,PORT+1> THEN
PRINT BELL:
STOP
END
$INCLUDE IBP SYS.REL.INCL.USER.READ.LAST.ACCESS
$INCLUDE IBP SYS.REL.INCL.USER.DEFAULT
$INCLUDE IBP SYS.REL.INCL.CURR
$INCLUDE IBP SYS.REL.INCL.INPUT.PARAMETERS
STRUCT(29)<1,PORT+1> = PORT.ACCESS<1>
*STRUCT(30)<1,PORT+1> = PORT.ACCESS<2>
*PORT.ACCESS<3> = TASK.REL
STRUCT(61)<1,PORT+1> = PORT.ACCESS<4>
STRUCT(69)<1,PORT+1> = PORT.ACCESS<5>
TASK.TOPIC = PORT.ACCESS<1>:"*":PORT.ACCESS<2>:"*":PORT.ACCESS<7>:"*":PORT.ACCESS<6>
STRUCT(34)<1,PORT+1> = PORT.ACCESS<1>:"#":PORT.ACCESS<2>:"#":PORT.ACCESS<7>:"#":PORT.ACCESS<6>
*PORT.ACCESS<8> = TOPIC.LOC
PORT.ACCESS<9> = TASK.TOPIC
*# Load TASK values.
TASK.CO   = PORT.ACCESS<1>
TASK.APPL = PORT.ACCESS<2>
TASK.REL  = PORT.ACCESS<3>
TASK.NUM  = PORT.ACCESS<4>
TASK.STEP = PORT.ACCESS<5>
*TASK.DESC = STRUCT(62)<1,PORT+1>
*TASK.TOPIC = PORT.ACCESS<9>
TASK.FILE = FIELD(TASK.TOPIC,"*",4)
TASK.ITEM = FIELD(TASK.TOPIC,"*",3)
TASK.LIST = PORT.ACCESS<13>
SYS.ITEM = "@SYS@USER@":USER.NAME
MATWRITE STRUCT ON SY.FILE,SYS.ITEM
*# 
LAST.FILE = "**INIT**"; LAST.ITEM = "**INIT**"; LAST.PRESTORE = "**INIT**"; LAST.TOPIC.RSP = "**INIT**"
*# 
*# Loop to process file/program sets
*#
PRINT CLL:"[=| "
PRINT CLL:"[=| "
LOOP
EXEC.VERB   = SYS.RUN.VERB<SYS.RUN.TYPE>
EXEC.PREFIX = SYS.RUN.PREFIX<SYS.RUN.TYPE>
EXEC.SUFFIX = SYS.RUN.SUFFIX<SYS.RUN.TYPE>
*EXEC.PARAMS = SYS.RUN.PARAMS<SYS.RUN.TYPE>
EXEC.PARAMS = ""
TEMP = SYS.RUN.PARAMS<SYS.RUN.TYPE>
TEMP.MAX = DCOUNT(TEMP,VM)
IF TEMP.MAX THEN
FOR TEMP.CN = 1 TO TEMP.MAX
EXEC.PARAMS<-1> = TEMP<1,TEMP.CN>
NEXT TEMP.CN
END
EXEC.RESLTS = SYS.RUN.RESLTS<SYS.RUN.TYPE>
*$INCLUDE IBP SYS.REL.INCL.11.ABORT
*# 
*# Input File and Item
*# 
$INCLUDE IBP SYS.REL.INCL.FILE.ITEM
*# 
IF NOT(SYS.ABORT OR USER.ABORT) THEN
*# 
$INCLUDE IBP SYS.REL.INCL.11.ABORT
$INCLUDE IBP SYS.REL.INCL.VERIFY.FILE
$INCLUDE IBP SYS.REL.INCL.USER.WRITE.LAST.ACCESS
*# 
$INCLUDE IBP SYS.REL.INCL.FILE.ITEM.OPEN
*# 
START.DATE = DATE()
START.TIME = TIME()
BP.RUNS = ""
EXEC.RESULTS = ""
*#
*#
END; *# OF NOT ABORT
IF NOT(SYS.ABORT OR USER.ABORT) THEN
*# 
SYS.ITEM = "@SYS@DSTAT@":TASK.ITEM 
READ BP.RUNS FROM INP.FILE.DICT,SYS.ITEM ELSE BP.RUNS = "" ; *#
*# 
IF NOT(SYSTEM(11)) THEN
GOSUB DISPLAY.HEADER ; *#
GOSUB DISPLAY.ELP.TIME ; *#
END
*# 
*# 
IF SYS.RUN.TYPE EQ TRUE THEN
*EXEC.PARAMS = ""
EXEC.RESULTS = ""
***RQM; *#
LOOP
PRINT CLL:"[=| ":"Enter the name of the prestore item to use (":DEFAULT.PRESTORE:"): ":
IF SYS.PROC.TYPE LE 4 THEN
IF LAST.PRESTORE EQ "**INIT**" OR LAST.PRESTORE[1,5] EQ "EDIT " OR NOT(LIST.ID.FLAG) THEN
INPUT PRESTORE:
END ELSE PRESTORE = LAST.PRESTORE
END ELSE PRESTORE = DEFAULT.PRESTORE
IF LEN(PRESTORE) AND INDEX("*OFF*KILL*STOP*END*HALT*",PRESTORE,1) THEN
USER.ABORT = TRUE
PRESTORE = ""
END
IF NOT(LEN(PRESTORE)) THEN PRESTORE = DEFAULT.PRESTORE; PRINT PRESTORE
PRINT "[=| Prestore: ":PRESTORE
PRINT CLL:"[=| "
*# 
PRESTORE.EMPTY = TRUE
IF PRESTORE EQ "EDIT" OR PRESTORE EQ "ED" THEN PRESTORE = "EDIT ":DEFAULT.PRESTORE
IF PRESTORE[1,3] EQ "ED." OR PRESTORE[1,3] EQ "ED " THEN PRESTORE = "EDIT ":PRESTORE[4,999]
IF PRESTORE[1,5] EQ "EDIT." OR PRESTORE[1,5] EQ "EDIT " THEN
EXEC1.VERB = "ZEDIT SYS @UTILS@ED@":STRUCT(2):"@PRESTORE@":PRESTORE[6,999]
EXEC.PARAMS = EXEC.PARAMS:AM:"P1":AM:"PD":AM:"?"
EXECUTE EXEC1.VERB, //IN. < EXEC.PARAMS
CONT = TRUE
END ELSE IF NOT(SYS.ABORT OR USER.ABORT) THEN
READ TEMP FROM SY.FILE,"@UTILS@ED@":STRUCT(2):"@PRESTORE@":PRESTORE THEN PRESTORE.ON.FILE = TRUE ELSE PRESTORE.ON.FILE = FALSE; TEMP = "" ; *#
IF LEN(TEMP) THEN PRESTORE.EMPTY = FALSE
IF PRESTORE.ON.FILE THEN
EXEC.PARAMS<-1> = "P1 .U10":SVM:"L20":SVM:".U10":SVM:"?"
EXEC.PARAMS<-1> = "P2 .N20":SVM:"P1"
EXEC.PARAMS<-1> = "P3 .U20":SVM:"P1"
EXEC.PARAMS<-1> = "P4 A":SVM:"P1"
EXEC.PARAMS<-1> = "P5 F":SVM:"L9999/OPEN/":SVM:"L9999/READ/":SVM
EXEC.PARAMS = EXEC.PARAMS:"L9999/WRITE/":SVM:"L9999/DELETE/"
EXEC.PARAMS<-1> = "P6 R/*/*#/"
EXEC.PARAMS<-1> = "P7 R/*#//"
EXEC.PARAMS<-1> = "P8 R//*#/"
EXEC.PARAMS<-1> = "P9 S?"
PRINT "[=| "
PRINT CLL:"[=| "
*PRINT CLL:"[=| ":TEMP<1>
PRINT CLL:"[=| ":STR("*",30)
PRESTORE.EMPTY = TRUE
LOOP WHILE LEN(TEMP) DO
TEMP1 = TEMP<1>
IF NOT(SYSTEM(11)) THEN PRINT CLL:"[=| ":TEMP1
IF TEMP1[1,1] NE "*" THEN
IF TEMP1[1,1] EQ "P" AND TEMP1[3,1] EQ " " AND NUM(TEMP1[2,1]) THEN
TEMP2 = TEMP1[2,1]
IF NUM(TEMP2) THEN
PRESTORE.EMPTY = FALSE
TEMP3 = INDEX(EXEC.PARAMS,TEMP1[1,3],1)
TEMP3 = DCOUNT(EXEC.PARAMS[1,TEMP3+1],AM)
IF TEMP3 THEN
EXEC.PARAMS<TEMP3> = TEMP1
END ELSE EXEC.PARAMS<-1> = TEMP1
END ELSE EXEC.PARAMS<-1> = TEMP1
END ELSE EXEC.PARAMS<-1> = TEMP1
END; *# OF TEMP[1,1] NE "*"
DEL TEMP<1,0,0>
REPEAT
PRINT CLL:"[=| ":STR("*",30)
PRINT CLL:"[=| "
END; *# OF PRESTORE.ON.FILE
IF PRESTORE.EMPTY OR NOT(PRESTORE.ON.FILE) THEN
PRINT CLL:"[=| "
PRINT BELL:CLL:"[=| PRESTORE is ":
IF PRESTORE.EMPTY THEN
PRINT "EMPTY":
IF NOT(PRESTORE.ON.FILE) THEN PRINT " and ":
END
IF NOT(PRESTORE.ON.FILE) THEN PRINT "NOT ON FILE":
PRINT "!!!"
***RQM; RQM
CONT = TRUE
END ELSE CONT = FALSE
*#
END; *# OF EDIT PRESTORE OR LOAD VALUES
LAST.PRESTORE = PRESTORE
*#
$INCLUDE IBP SYS.REL.INCL.11.ABORT
*#
*#
WHILE NOT(SYS.ABORT OR USER.ABORT) AND CONT DO
PRINT CLL:"[=| ":STR("-",30)
PRINT CLL:"[=| "
REPEAT
*#
EXEC.PARAMS<-1> = "L5"
EXEC.PARAMS<-1> = "?"
*# 
END ELSE IF SYS.RUN.TYPE EQ 7 THEN
ERROR.RSP = ""
ERROR.TEXT = "Enter the file to compare to: "
ERROR.CODE = "290010000035"
GOSUB ERROR.CONTROL
IF NOT(LEN(ERROR.RSP)) THEN TASK.FILE1  = "OLD.":TASK.FILE ELSE TASK.FILE1 = ERROR.RSP
*#
ERROR.RSP = ""
ERROR.TEXT = "Enter the item to compare to: "
ERROR.CODE = "290010000035"
GOSUB ERROR.CONTROL
IF NOT(LEN(ERROR.RSP)) THEN TASK.ITEM1  = TASK.ITEM ELSE TASK.ITEM1 = ERROR.RSP
EXEC.PARAMS<-1> = ";":TASK.FILE:";":TASK.ITEM:";":TASK.ITEM1
EXEC.PARAMS<-1> = TASK.FILE1
EXEC.PARAMS<-1> = "COMPARE.CHANGES"
EXEC.PARAMS<-1> = "@":TASK.REL:"@"
EXEC.PARAMS<-1> = "@":TASK.FILE1:"@VER"
EXEC.PARAMS<-1> = "+++"
*#
END; *# OF SYS.RUN.TYPE EQ TRUE 
*#
END; *# OF NOT ABORT
*#
IF NOT(SYS.ABORT OR USER.ABORT) THEN 
*#
IF SYS.OLD.FLAG THEN
PRINT
PRINT "OLD ITEM FUNCTION NOT VALID (ZED)"
PRINT
END
IF SYS.DICT.FLAG THEN
PRINT
PRINT "DICTIONARY FUNCTION ALLOWED"
PRINT
EXEC.LIEN = EXEC.VERB:" DICT ":TASK.FILE:" ":TASK.ITEM:EXEC.SUFFIX
END ELSE
EXEC.LINE = EXEC.VERB:" ":TASK.FILE:" ":TASK.ITEM:EXEC.SUFFIX
END
PRINT CLL:"[=| "
PRINT CLL:"[=| ":EXEC.LINE
PRINT CLL:"[=| Input: ":
TEMP = DCOUNT(EXEC.PARAMS,AM)
IF NOT(TEMP) THEN PRINT "none"
FOR A = TRUE TO TEMP UNTIL SYSTEM(11)
IF A > TRUE THEN PRINT CLL:"[=| ":SPACE(7):
PRINT EXEC.PARAMS<A>
NEXT A
$INCLUDE IBP SYS.REL.INCL.11.ABORT
PRINT CLL:"[=| "
PRINT CLL:"[=| "
*#
IF NOT(SYS.ABORT OR USER.ABORT) THEN
*#
SYS.ITEM = "@SYS@DSTAT@":TASK.ITEM 
READ BP.RUNS FROM INP.FILE.DICT,SYS.ITEM ELSE BP.RUNS = "" ; *#
*#
IF LEN(EXEC.VERB) THEN
*#
IF EXEC.PREFIX = "CALL" THEN
*TEMP.FILE = "ULT.":TASK.FILE
TEMP.FILE = TASK.FILE
TEMP.FILE1 = "OLD.":TASK.FILE
TEMP.FILE2 = "PC.":TASK.FILE
TEMP.FILE3 = "COMPARE.CHANGES"
TASK.XREF.FUNC = 3
TASK.INDEX.ID = "@REL@":TASK.CO:"@":TASK.APPL:"@":TASK.REL:"@":SYS.RUN.CODE<SYS.RUN.TYPE>
TASK.INDEX.DATA = ""
STAT = FALSE
CALL.ID = EXEC.VERB
CALL @CALL.ID(SY.FILE,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TEMP.FILE,TASK.ITEM,TEMP.FILE1,TEMP.FILE2,TEMP.FILE3,TASK.XREF.FUNC,TASK.INDEX.ID,TASK.INDEX.DATA,STAT,SYS.RUN.STAT)
EXEC.RESULTS = TASK.INDEX.DATA
PRINTER OFF
PRINTER CLOSE
*#
*#
END ELSE
EXEC.LINE = EXEC.PREFIX:EXEC.LINE
IF EXEC.RESLTS THEN
EXECUTE EXEC.LINE, //IN. < EXEC.PARAMS, //OUT. > EXEC.RESULTS
PRINT
CALL.ID = "SYS.REL.PARSE.":SYS.RUN.CODE<SYS.RUN.TYPE>
EXEC.PARSE.TEXT = ""
CALL @CALL.ID(EXEC.RESULTS,SYS.RUN.RESLTS.ATTR<SYS.RUN.TYPE>,EXEC.PARSE,SYS.RUN.STAT,EXEC.PARSE.TEXT) ; *#
SYS.RESULTS.ATTR =  SYS.RUN.RESLTS.ATTR<SYS.RUN.TYPE>
TEMP = DCOUNT(EXEC.PARSE,AM)
*PRINT CLL:"[=| "
*HELLO COMPARE
FOR A = TRUE TO TEMP
BP.RUNS<SYS.RESULTS.ATTR+A> = EXEC.PARSE<A>
NEXT A
*#
END ELSE
EXECUTE EXEC.LINE, //IN. < EXEC.PARAMS
PRINT
EXEC.RESULTS = ''
GET (MSG.) EXEC.RESULTS THEN
PRINT CLL:"[=| "
PRINT CLL:"[=| ":EXEC.RESULTS
PRINT CLL:"[=| "
END ELSE
PRINT CLL:"[=| "
END
IF SYS.RUN.TYPE EQ 1 THEN SYS.PROC.STAT = 1
END; *# OF EXEC.RESLTS
*#
END; *# OF NOT A CALL
*# 
END; *# OF LEN(EXEC.VERB)
PRINT CLL:"[=| "
*# GOSUB GET.COMPL ; *#
IF NOT(SYS.ABORT OR USER.ABORT) THEN GOSUB GET.COMPL
PRINT CLL:"[=| "
PRINT CLL:"[=| "
*# 
END; *# OF NOT ABORT
*# 
END; *# OF NOT ABORT
*#
SYS.ITEM = "@SYS@USER@":USER.NAME
MATWRITE STRUCT ON SY.FILE,SYS.ITEM
SYS.ITEM = "@SYS@DEV@":USER.NAME:"@":PORT+1
WRITE PORT.ACCESS ON SY.FILE,SYS.ITEM
*#
IF LEN(TASK.FILE) THEN LAST.FILE = TASK.FILE
IF LEN(TASK.ITEM) THEN LAST.ITEM = TASK.ITEM
*#
WHILE NOT(SYS.ABORT OR USER.ABORT) AND SYS.PROC.TYPE LE 4 DO REPEAT
*# 
GOTO END.OF.PROGRAM
*#
$INCLUDE IBP SYS.REL.INCL.DISPLAY
*#
$INCLUDE IBP SYS.REL.INCL.COMPL
*# 
$INCLUDE IBP SYS.REL.INCL.ERROR
*# 
END.OF.PROGRAM: *# Normal End
*# 
*# 
END
~SYS.REL.PARSE.COMPILE~
SUBROUTINE SYS.REL.PARSE.COMPILE(EXEC.RESULTS,BP.RUNS.ATTR,EXEC.PARSE,SYS.RUN.STAT,EXEC.PARSE.TEXT)
*SUBROUTINE: SYS.REL.PARSE.COMPILE
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
VAR.FLAG = 1
FRAME.FLAG = 0
FRAME.TOT.FLAG = 0
EXEC.WORK = EXEC.RESULTS:AM:"***"
EXEC.PARSE = ''
PRINT CLL:"[=| "
PRINT CLL:"[=| "
PRINT CLL:"[=| PARSE RESULTS"
PRINT CLL:"[=| ":
LAST.TEMP = ''
LOOP WHILE LEN(EXEC.WORK) DO
TEMP = EXEC.WORK<1>
IF TEMP[1,1] EQ "[" THEN
PRINT " |=]"
PRINT CLL:"[=| "
IF LEN(LAST.TEMP) THEN PRINT CLL:"[=| ":LAST.TEMP
PRINT CLL:"[=| ":TEMP
EXEX.PARSE.TEXT = EXEC.PARSE.TEXT:AM:TEMP
IF LEN(EXEC.WORK<2>) THEN
PRINT CLL:"[=| ":EXEC.WORK<2>
EXEC.PARSE.TEXT = EXEC.PARSE.TEXT:AM:EXEC.WORK<2>
END
PRINT CLL:"[=| "
PRINT CLL:"[=| ":
END
LAST.TEMP = TEMP
PRINT "p":
TEMP = TRIM(TEMP)
BEGIN CASE
CASE NOT(LEN(TEMP))
CASE TEMP = "FRAMES LINES"
PRINT " |=]"
PRINT CLL:"[=| "
PRINT CLL:"[=| ":TEMP
PRINT CLL:"[=| ":
VAR.FLAG = 0
FRAME.FLAG = 1
CASE VAR.FLAG OR FRAME.FLAG AND LEN(TEMP)
LOOP WHILE LEN(TEMP) AND NOT(FRAME.TOT.FLAG) DO
PRINT ".":
TEMP1 = FIELD(TEMP," ",1)
IF LEN(TEMP1) THEN
TEMP2 = FIELD(TEMP," ",2)
END ELSE TEMP2 = ''
TEMP3 = COL2()+1
IF LEN(TEMP1) THEN
BEGIN CASE
CASE INDEX(TEMP,"; ",1) AND INDEX(TEMP," frames used.",1)
PRINT " |=]"
PRINT CLL:"[=| "
PRINT CLL:"[=| ":TEMP
EXEC.PARSE.TEXT = EXEC.PARSE.TEXT:AM:TEMP
IF LEN(EXEC.WORK<2>) THEN
PRINT CLL:"[=| ":EXEC.WORK<2>
EXEC.PARSE.TEXT = EXEC.PARSE.TEXT:AM:EXEC.WORK<2>
END
PRINT CLL:"[=| "
PRINT CLL:"[=| ":
TEMP1 = FIELD(TEMP,";",2)
TEMP1 = TEMP1[2,999]
TEMP1 = FIELD(TEMP1," ",1)
EXEC.PARSE<5> = TEMP1
FRAME.TOT.FLAG = 1
FRAME.FLAG = 0
SYS.RUN.STAT = 1
CASE VAR.FLAG OR FRAME.FLAG AND NOT(NUM(TEMP1))
*#PRINT
*#PRINT CLL:EXEC.WORK<1>
CASE VAR.FLAG
EXEC.PARSE<1,-1> = TEMP1
EXEC.PARSE<2,-1> = TEMP2
CASE FRAME.FLAG
EXEC.PARSE<3,-1> = TEMP1
EXEC.PARSE<4,-1> = TEMP2
CASE 1
*#PRINT
*#PRINT CLL:TEMP:
*#PRINT BELL:" <<] "; RQM; RQM
END CASE
END
IF TEMP3 LE 1 THEN TEMP = '' ELSE
TEMP = TEMP[TEMP3,9999]
END
REPEAT
CASE FRAME.FLAG
FRAME.FLAG = 0
FRAME.TOT.FLAG = 1
CASE FRAME.TOT.FLAG
FRAME.TOT.FLAG = 0
CASE 1
*#PRINT
*#PRINT EXEC.WORK<1>:
*#PRINT BELL:" <<] "; RQM; RQM; RQM; RQM
END CASE
EXEC.WORK = DELETE(EXEC.WORK,1)
REPEAT
IF VAR.FLAG OR FRAME.FLAG OR FRAME.TOT.FLAG THEN
PRINT BELL:" ! ":; RQM; RQM; RQM; RQM
END
PRINT " |=]"
PRINT CLL:"[=| "
PRINT CLL:"[=| "
RETURN; *# TO CALLING PROGRAM
END
~SYS.REL.PROGLIST~
SUBROUTINE SYS.REL.PROGLIST(SY.FILE,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TASK.FILE,TASK.ITEM,TASK.OLD,TASK.XTR,TASK.CHG,XREF.FUNC,XREF.INDEX.ID,TASK.INDEX.DATA,STAT,SYS.RUN.STAT)
*SUBROUTINE: SYS.REL.PROGLIST
*
* AUTHOR: DAVID G. HORSMAN
*
*$INCLUDE IBP SYS.COMMON
*
!
$INCLUDE IBP STANDARD.FUNCTIONS
$INCLUDE IBP SYS.INCL.OFF.RSP
$INCLUDE IBP SYS.INCL.END.RSP
$INCLUDE IBP SYS.INCL.TCL.RSP
*# 
*# 
DIM MODE.DESC(30), STAT.DESC(15)
*# 
$INCLUDE IBP SYS.INCL.USER.MODE.DESC
$INCLUDE IBP SYS.INCL.STATUS.CHECK
$INCLUDE IBP SYS.INCL.STATUS.DESC
$INCLUDE IBP SYS.INCL.LO.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.DEV.MODE
$INCLUDE IBP SYS.INCL.HI.SALES.MODE
$INCLUDE IBP SYS.INCL.LO.TCL.MODE
$INCLUDE IBP SYS.INCL.LO.TRAIN.MODE
$INCLUDE IBP SYS.INCL.HI.TRAIN.MODE
*# 
LN = F
RELOOP = F
PRINT
PRINT "Enter run type (1 or 2): ":
SYS.RUN.TYPE = T
*# 
*SYS.RUN.TYPE = T , INPUT 1 PROGRAM NAME FROM TYPE AHEAD
*SYS.RUN.TYPE = 2 , READ SELECTS THEN INPUT NAME FORM KEYBOARD
*# 
FONT.17 = CHAR(27):"[;12m":CHAR(27):"[;44 G"; FONT.12 = CHAR(27):"[;11m":CHAR(27):"[;60 G"
REQD.FONT = FONT.17; MAX.COLS = 130
OLD = F
EQUATES = F
DIM INCL.LINES(600)
MAX.LINES = 60
PRINT @(0,5):CLS:
*# 
PRINT @(0,5):CLL:"Enter file name: ":
FILE.NAME = TASK.FILE
PRINT @(17,5):CLL:FILE.NAME:
*# 
CONT = T
LOOP
*#
IF CONT THEN
*#
PRINT @(0,7):CLS:"Enter item name: ":
FILE.ITEM = F
*#
IF SYS.RUN.TYPE = 2 AND NOT(RELOOP) THEN
READNEXT FILE.ITEM ELSE
FILE.ITEM = F
CONT = F
RELOOP = SYS.RUN.TYPE
END
END ELSE FILE.ITEM = F
*# 
FILE.ITEM = TASK.ITEM
*#
PRINT @(17,7):CLL:FILE.ITEM:
*#
END; *# OF CONT
*#
WHILE CONT AND LEN(FILE.ITEM) AND FILE.ITEM # "END" DO
*# 
*# 
PRINT @(0,9):CLL:"Enter parameters (O,X,E): ":
IF SYS.RUN.TYPE = 2 THEN
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
END
IF SYSTEM(11) AND (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
INPUT PARAMS:
END ELSE PARAMS = "E"
PRINT @(26,9):PARAMS:"     ":
LOOP
IF PARAMS[1,1] = "O" THEN OLD = T 
IF PARAMS[1,1] = "X" THEN REQD.FONT = FONT.12; MAX.COLS = 98
IF PARAMS[1,1] = "E" THEN EQUATES = T
PARAMS = PARAMS[2,99]
WHILE LEN(PARAMS) DO REPEAT
PRINTER ON; PRINT REQD.FONT:; PRINTER OFF
*# 
*# 
!
MAIN: * READ EACH PROGRAM SELECTED
BP.FL.DH = F; BP.FL = F; BP.FL.UTL = F; BP.FL.PRJ = F; BP.FL.OLD = F
IF LEN(FILE.NAME) THEN FILE.NAMES = FILE.NAME ELSE
SYS.FILE = "SYS"; SYS.ITEM = "@SYS@DEV@BP@FILES"
READ FILE.NAMES FROM SY.FILE,SYS.ITEM ELSE
FILE.NAMES = "SYSTEM":AM:"MD":AM:"PL":AM:"SYS"
FILE.NAMES = FILE.NAMES:AM:"DH.BP"
END
PRINT @(17,5):CLL:FILE.NAME:
END
PRINT @(0,11):CLS:"> ":FILE.NAME:" - ":FILE.ITEM:" - ":
PROG = "Program Listing - '":FILE.NAME:" ":FILE.ITEM:"'"; LINE.NUM = MAX.LINES; PAGE.NUM = F; TAB = F
NUM = T; CASE.FLAG = F; LN = 6
TOT.NUM = T
TOT.INCL = F
BP.EMPTY = F; CN = F
PRINTER ON; GOSUB HEADER; PRINT SPACE(12):"-----FOUND ON---------"; PRINT; PRINTER OFF
PRINT @(50,5):CLL:"-----FOUND ON-------":
F.RSP = "ZZZZZ"
EXEC.STACK = F
BP.FLAG = T
LOOP
CN = CN + 1
TEMP.NAME = FILE.NAMES<CN>
WHILE LEN(TEMP.NAME) AND BP.FLAG DO
OPEN TEMP.NAME TO INP.FILE ELSE 
IF TEMP.NAME[1,4] EQ "ULT." THEN
TEMP.NAME = TEMP.NAME[5,999]
OPEN TEMP.NAME TO INP.FILE ELSE BP.FLAG = F
END
END
IF BP.FLAG THEN
READV TEXT FROM INP.FILE,FILE.ITEM,1 THEN
PRINT @(50,LN):TEMP.NAME:
PRINT "  ?":BELL:
IF SYS.RUN.TYPE = 2 THEN
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
IF NOT(SYSTEM(11)) THEN RQM
IF SYSTEM(11) AND (SYS.RUN.TYPE # 2 AND NOT(RELOOP)) THEN
INPUT F.RSP:
END ELSE F.RSP = "Y"; PRINT F.RSP:
IF F.RSP = "Y" THEN EXEC.STACK = EXEC.STACK:CN:AM
END ELSE EXEC.STACK = EXEC.STACK:CN:AM
PRINTER ON; PRINT SPACE(12):TEMP.NAME; PRINTER OFF; LINE.NUM = LINE.NUM+1
LN = LN+1
IF LN > 19 THEN LN = 6
END ELSE BP.FLAG = F
END
IF NOT(BP.FLAG) THEN PRINT @(0,23):CLL:FILE.ITEM:" is not on ":TEMP.NAME:".":; RQM
REPEAT
PRINTER ON; PRINT; PRINT SPACE(12):STR("-",20); PRINT; PRINTER OFF; LINE.NUM=LINE.NUM+3
*# 
*# 
IF LEN(EXEC.STACK) THEN
*#
LOOP WHILE LEN(EXEC.STACK) DO
CN1 = EXEC.STACK<1>
*#
IF CN1 > 0 THEN
FILE.NAME = FILE.NAMES<CN1>
*#
IF LEN(FILE.NAME) THEN
OPEN FILE.NAME TO INP.FILE THEN
GOSUB PRINT.PROGRAM
END ELSE
IF FILE.NAME[1,4] EQ "ULT." THEN
FILE.NAME=FILE.NAME[5,99]
OPEN FILE.NAME TO INP.FILE THEN
GOSUB PRINT.PROGRAM
END ELSE PRINT BELL:; RQM; PRINT BELL:; RQM
END; *# OF FILE ULT.
END; *# OF NOT ON FILE
END; *# IF FILE.NAME NE F
END; *# OF CN1 > 0
EXEC.STACK = DELETE(EXEC.STACK,1)
*#
REPEAT
*#
END; *# OF EXEC.STACK
*#
IF SYS.RUN.TYPE # 2 THEN RELOOP = SYS.RUN.TYPE
*#
CONT = F
*#
REPEAT
*#
*#
PRINTER ON
PRINT FONT.17:
PRINTER OFF
PRINTER CLOSE
*STOP
*# 
RETURN; *# TO CALLING PROGRAM
*# 
*# 
!
PRINT.PROGRAM: * PRINT EACH PROGRAM
PC.STORED = F
PRINT @(0,11):CLS:"> ":FILE.NAME:" - ":FILE.ITEM
*:" - ":
PC.CN1 = T
PROG = "Program Listing - '":FILE.NAME:" ":FILE.ITEM:"'"; TAB = F; NUM = T; CASE.FLAG = F; LN = F
BP.EMPTY = F
PC = "*"
LOOP
LN = LN+1
LINE = F
READV LINE FROM INP.FILE,FILE.ITEM,LN ELSE LINE = F
IF LINE = F THEN BP.EMPTY = BP.EMPTY+1 ELSE BP.EMPTY = F
*# 
UNTIL BP.EMPTY > 5 DO
GOSUB PRINTLINE
IF LINE[1,1] = "$" AND EQUATES THEN
SAVE.NUM = NUM
NUM = ">>>>I"
INCL.FILE = FIELD(LINE," ",2)
INCL.PROG = FIELD(LINE," ",3)
INCL.FL = T
OPEN INCL.FILE TO IINP.FILE ELSE INCL.FL = F
IF INCL.FL THEN
READV TEST FROM IINP.FILE,INCL.PROG,1 ELSE INCL.FL = F
END
IF INCL.FL THEN
PC = "I"
MATREAD INCL.LINES FROM IINP.FILE,INCL.PROG ELSE MAT INCL.LINES = F
LINE = "*"; GOSUB PRINTLINE; INCL.NUM = T
LOOP LINE = INCL.LINES(INCL.NUM) UNTIL LINE = F DO
NUM = INCL.NUM:"I"
GOSUB PRINTLINE
INCL.NUM = INCL.NUM+1
TOT.INCL = TOT.INCL+1
TOT.NUM = TOT.NUM+1
REPEAT
IF INCL.NUM > 1 THEN LINE = "*"; GOSUB PRINTLINE
PC = "*"
END
NUM = SAVE.NUM
END
NUM = NUM+1
TOT.NUM = TOT.NUM + 1
REPEAT
*# 
IF LEN(PC.STORED) THEN
IF DCOUNT(PC.STORED,AM)+LINE.NUM+20 > MAX.LINES THEN LINE.NUM = MAX.LINES; PRINTER ON; GOSUB HEADER; PRINTER OFF
PRINTER ON
PRINT; PRINT
PRINT "TOTALS......  Lines printed: ":TOT.NUM "R#4"
PRINT "              Program lines: ":NUM "R#4"
PRINT "             Included lines: ":TOT.INCL "R#4"
PRINT
LINE.NUM = LINE.NUM+6
CN1 = F
LOOP WHILE LEN(PC.STORED) DO PRINT PC.STORED<1>; LINE.NUM = LINE.NUM+1; PC.STORED = DELETE(PC.STORED,1) REPEAT 
PRINT
LINE.NUM = LINE.NUM + 1
PRINTER OFF
PRINTER CLOSE
END
RETURN
!
!
!
PRINTLINE: * ANALYSE AND PRINT LINE
T.LEFT = F; T.RIGHT = F; LABEL = F
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
IF NOT(LINE = "!" OR LINE[1,1] = "*") THEN GOSUB KEYWORD; * ESTABLISH TABBING AND LABELS
TAB = TAB-T.LEFT; IF TAB < 0 THEN TAB = F
INDENT = TAB*3; P.LINE = NUM "R#5":" "
INDENT.PR = F
FOR TEMP = T TO TAB; INDENT.PR = INDENT.PR:"!  "; NEXT TEMP
IF LINE = "!" THEN P.LINE = P.LINE:SPACE(6):INDENT.PR:STR("*",MAX.COLS-13-INDENT) ELSE
IF LEN(LABEL) < 6 THEN P.LINE = P.LINE:LABEL "L#6":INDENT.PR:LINE ELSE
P.LINE = P.LINE:LABEL
IF LINE = "*" THEN P.LINE = P.LINE:" *" ELSE IF LEN(LINE) THEN P.LINE = P.LINE:SPACE(MAX.COLS-6-LEN(LABEL)):LINE
END
END
PRINTER ON
LOOP GOSUB HEADER WHILE LEN(P.LINE) > MAX.COLS DO
POS = MAX.COLS
LOOP UNTIL P.LINE[POS,1] = " " OR POS = MAX.COLS-30 DO POS = POS-1 REPEAT
IF POS = MAX.COLS-30 THEN POS = MAX.COLS
PRINT P.LINE[1,POS]
P.LINE = SPACE(12):INDENT.PR:P.LINE[POS+1,999]
REPEAT
PRINT P.LINE; TAB = TAB+T.RIGHT; PRINTER OFF
PRINT PC:; PC.STORED = PC.STORED:PC
PC.CN1 = PC.CN1 + 1
IF PC.CN1 > 50 THEN
PRINT
PC.STORED = PC.STORED:AM
PC.CN1 = T
END
RETURN
!
KEYWORD: * IDENTIFY KEY WORDS
GOSUB FIRSTWORD; * GET FIRST WORD
IF FIRST MATCHES "0N" OR FIRST[LEN(FIRST),1] = ":" THEN
LABEL = FIRST; LINE = LINE[LEN(FIRST)+2,999]
LOOP WHILE LINE[1,1] = " " DO LINE = LINE[2,999] REPEAT
GOSUB FIRSTWORD
END
BEGIN CASE
CASE FIRST = "IF" OR FIRST = "LOCATE" OR FIRST[1,4] = "READ" OR FIRST[1,7] = "MATREAD" OR FIRST = "WRITET" OR FIRST = "WEOF" OR FIRST = "OPEN"
GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = T
CASE FIRST = "LOOP"; GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST NE "REPEAT;" THEN T.RIGHT = T
CASE FIRST = "WHILE" OR FIRST = "UNTIL"; T.LEFT = T; GOSUB LASTWORD; IF LAST NE "REPEAT" AND LAST[1,7] NE "REPEAT;" THEN T.RIGHT = T
CASE FIRST = "FOR"; POS = INDEX(LINE," NEXT ",1); IF NOT(POS) THEN T.RIGHT = T
CASE FIRST = "BEGIN"; T.RIGHT = T; CASE.FLAG = T
CASE FIRST = "CASE"; T.RIGHT = T; IF CASE.FLAG = T THEN CASE.FLAG = F ELSE T.LEFT = T
CASE FIRST = "END" OR FIRST[1,4] = "END;"
IF LINE[POS+1,4] = "CASE" THEN T.LEFT = 2; RETURN
T.LEFT = T; GOSUB LASTWORD; IF LAST = "THEN" OR LAST = "ELSE" THEN T.RIGHT = T
CASE FIRST = "NEXT" OR FIRST = "REPEAT" OR FIRST[1,7] = "REPEAT;"; T.LEFT = T
END CASE
RETURN
!
FIRSTWORD: * GET FIRST WORD
POS = T
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = F DO POS = POS+1 REPEAT
FIRST = LINE[1,POS-1]
RETURN
!
LASTWORD: * GET LAST WORD
POS = LEN(LINE)
LOOP WHILE LINE[POS,1] = " " OR NOT(POS) DO POS = POS-1 REPEAT
LOOP CHAR = LINE[POS,1] UNTIL CHAR = " " OR CHAR = F OR NOT(POS) DO POS = POS-1 REPEAT
LAST = TRIM(LINE[POS+1,999])
RETURN
!
HEADER: * HEADER
LINE.NUM = LINE.NUM+1; IF LINE.NUM < MAX.LINES THEN RETURN
PRINTER CLOSE
MSK = "L#":MAX.COLS-50
PAGE.NUM = PAGE.NUM+1; LINE.NUM = 5
PRINT FF:TIMEDATE() "L#25":(SPACE((MAX.COLS/2-25)-LEN(PROG)/2):PROG) MSK:("PAGE ":PAGE.NUM) "R#25":LF
RETURN
*# 
!
END
~SYS.REL.RELEASE~
*PROGRAM: SYS.REL.RELEASE
*
* AUTHOR: DAVID G. HORSMAN
*
$INCLUDE IBP STANDARD.FUNCTIONS
*
*# Load program control and structure variables.
DIM STRUCT(120)
SYS.PROG = "SYS.REL.RELEASE"
SYS.PROG.TYPE = 2
EQ.PROG.TYPE = 2
*#
NEW.RUN.TYPE = FALSE
OLD.RUN.TYPE = FALSE
SYS.ABORT = FALSE
USER.ABORT = FALSE
*# 
START.DATE = DATE()
START.TIME = TIME()
ELP.TIME = 0
BP.RUNS = ""
EXEC.RESULTS = ""
EXEC.PARSE.TEXT = ""
SYS.UPD = ""; SYS.PREFIX = ""; SYS.SUFFIX = ""
STAT = FALSE
LIST.ID.FLAG = FALSE
SYS.ITEM.FLAG = FALSE
*#
*# PROGRAM TYPE ARE
*# 0 or unassigned = FOREIGN ROUTINE
*# 1 = TCL PROGRAM
*# 2 = TCL PROC
*# 3 = SYS MAIN (TCL/PROC) ROUTINE
*# 7 = CALL SUBROUTINE
*# 8 = SYS SUBROUTINE CALL
*# 
INPUT TEST.FLAG
IF NOT(LEN(TEST.FLAG)) THEN TEST.FLAG = 4
*# TEST.FLAG IS 3 - RELEASE LIST WITHOUT COMPARES (FROM LIST)
*# TEST.FLAG IS 4 -    "     "   WITH COMPARE     (FROM LIST)
*# TEST.FLAG IS 5 - REBUILD RELEASE LIST ONLY
*# TEST.FLAG IS 6 -   "       "      "   AND CHANGE TO STAT 3
*# TEST.FLAG IS 7 -    "      "      "   AND CHANGE TO STAT 4
*# TEST.FLAG IS 8 - GENERATE SUMMARY REPORT ONLY
*# TEST.FLAG IS GT 10 - USE ALL FILES (OLD.SUMS) AND TEST-FLAG - 10
*#
*# SYS.RUN.TYPE IS 9 - RELEASE
*# SYS.RUN.TYPE IS 7 - CHECK.SUM
*#
IF NOT(NUM(TEST.FLAG)) THEN TEST.FLAG = 4
*#
$INCLUDE IBP SYS.REL.INCL.PARAMETER.INDEX
$INCLUDE IBP SYS.REL.INCL.PARAMETER.INPUT
*#
$INCLUDE IBP SYS.REL.INCL.FILE.OPEN
$INCLUDE IBP SYS.REL.INCL.USER.LOAD
*# Read the company record that user is working with.
$INCLUDE IBP SYS.INCL.COMPANY.READ
*# Detect a company data mis-match.
IF CO.DATA<4> NE STRUCT(29)<1,PORT+1> THEN
PRINT BELL:
STOP
END
$INCLUDE IBP SYS.REL.INCL.USER.READ.LAST.ACCESS
$INCLUDE IBP SYS.REL.INCL.USER.DEFAULT
$INCLUDE IBP SYS.REL.INCL.INPUT.PARAMETERS
$INCLUDE IBP SYS.REL.INCL.CURR
STRUCT(29)<1,PORT+1> = PORT.ACCESS<1>
*STRUCT(30)<1,PORT+1> = PORT.ACCESS<2>
STRUCT(61)<1,PORT+1> = PORT.ACCESS<4>
STRUCT(69)<1,PORT+1> = PORT.ACCESS<5>
TASK.TOPIC = PORT.ACCESS<1>:"#":PORT.ACCESS<2>:"#":PORT.ACCESS<7>:"#":PORT.ACCESS<6>
STRUCT(34)<1,PORT+1> = TASK.TOPIC
*PORT.ACCESS<8> = TOPIC.LOC
PORT.ACCESS<9> = TASK.TOPIC
*# Load TASK values.
TASK.CO   = PORT.ACCESS<1>
TASK.APPL = PORT.ACCESS<2>
TASK.REL  = PORT.ACCESS<3>
TASK.NUM  = PORT.ACCESS<4>
TASK.STEP = PORT.ACCESS<5>
*TASK.DESC = STRUCT(62)<1,PORT+1>
*TASK.TOPIC = PORT.ACCESS<9>
TASK.FILE = FIELD(TASK.TOPIC,"#",4)
TASK.ITEM = FIELD(TASK.TOPIC,"#",3)
TASK.LIST = PORT.ACCESS<13>
SYS.ITEM = "@SYS@USER@":USER.NAME
MATWRITE STRUCT ON SY.FILE,SYS.ITEM
*# 
LAST.FILE = "**INIT**"; LAST.ITEM = "**INIT**"
*# 
*# Loop to process file/program sets
PRINT CLL:"[=| "
PRINT CLL:"[=| "
EXEC.VERB   = SYS.RUN.VERB<SYS.RUN.TYPE>
EXEC.PREFIX = SYS.RUN.PREFIX<SYS.RUN.TYPE>
EXEC.SUFFIX = SYS.RUN.SUFFIX<SYS.RUN.TYPE>
EXEC.PARAMS = SYS.RUN.PARAMS<SYS.RUN.TYPE>
EXEC.RESLTS = SYS.RUN.RESLTS<SYS.RUN.TYPE>
*#
$INCLUDE IBP SYS.REL.INCL.FILE.ITEM.OPEN
*#
!
*# 
IF NOT(USER.ABORT OR SYS.ABORT) THEN 
*###
*###
REL.ITEM.CN = 0
REL.ITEM.ID = "@REL@":TASK.CO:"@":TASK.APPL:"@":NEXT.REL:"@TASK"
SYS.ITEM = REL.ITEM.ID
TOPIC.ON.FILE = FALSE
*#
READ REL.ITEM FROM SY.FILE,SYS.ITEM ELSE
REL.ITEM = ""
IF TEST.FLAG LT 10 THEN SYS.ABORT = 6
ERROR.TEXT = "Release (":NEXT.REL:") record is missing, ABORT!"
ERROR.CODE = "16001"
GOSUB ERROR.CONTROL
END
REL.ITEM.MAX = DCOUNT(REL.ITEM,AM)
*#
IF (SYS.ABORT EQ 6 OR NOT(REL.ITEM.MAX)) AND NOT(USER.ABORT) THEN
IF NOT(REL.ITEM.MAX) THEN REL.ITEM = "00000@0"; REL.ITEM.MAX = 1
EXEC.LINE1 = "QSELECT DICT ":TASK.FILE:" @LIST@":TASK.FILE
EXECUTE EXEC.LINE1, //SELECT. > TOPIC.ITEM
TOPIC.ITEM.MAX = DCOUNT(TOPIC.ITEM,AM)
*#
IF NOT(TOPIC.ITEM.MAX) THEN
EXEC.LINE1 = "SSELECT ":TASK.FILE:" ":TASK.FILE
EXECUTE EXEC.LINE1, //SELECT. > TOPIC.ITEM
TOPIC.ITEM.MAX = DCOUNT(TOPIC.ITEM,AM)
END
*#
IF TOPIC.ITEM.MAX THEN
WRITE REL.ITEM ON SY.FILE,SYS.ITEM
TOPIC.ID = "@T@":TASK.CO:"@":TASK.APPL:"@":"00000"
READ TEMP1 FROM PS.FILE,TOPIC.ID ELSE TEMP1 = ""
FOR TEMP = 1 TO TOPIC.ITEM.MAX
TEMP1<1,-1> = TOPIC.ITEM<TEMP>
NEXT TEMP
TOPIC.ITEM = TEMP1; TEMP1 = ""
TOPIC.ID = "@T@":TASK.CO:"@":TASK.APPL:"@":"00000"
WRITE TOPIC.ITEM ON PS.FILE,TOPIC.ID
TOPIC.ON.FILE = TRUE
SYS.ABORT = FALSE
END
*#
END
*#
*#
IF NOT(REL.ITEM.MAX) THEN
IF TEST.FLAG LT 10 THEN SYS.ABORT = 6
ERROR.TEXT = "Release (":NEXT.REL:") record is empty, ABORT!"
ERROR.CODE = "16001"
GOSUB ERROR.CONTROL
END
*# 
TASK.VAR = "*INIT*"
TASK.USER = STRUCT(2)
TASK.INDEX.ID = "@SYS@DEV@XREF@INDEX@":SYS.RUN.XREF.IDS<SYS.RUN.TYPE>
*#
*# Process each task
*#
IF SYS.RUN.TYPE EQ 9 AND TEST.FLAG LT 10 AND NOT(SYS.ABORT AND USER.ABORT) THEN
*#
LOOP
*#
REL.ITEM.CN = REL.ITEM.CN + 1
*#
$INCLUDE IBP SYS.INCL.11.ABORT
*#
WHILE NOT(USER.ABORT OR USER.ABORT) AND REL.ITEM.CN LE REL.ITEM.MAX DO
*#
REL.ITEM.KEY = FIELD(REL.ITEM<REL.ITEM.CN>,"@",1)
TASK.NUM = REL.ITEM.KEY
TASK.STEP = 1
TOPIC.ID = "@T@":TASK.CO:"@":TASK.APPL:"@":REL.ITEM.KEY
TOPIC.ON.FILE = TRUE
READ TOPIC.ITEM FROM PS.FILE,TOPIC.ID ELSE TOPIC.ON.FILE = FALSE
*#
IF TOPIC.ON.FILE THEN
TOPIC.ITEM.MAX = DCOUNT(TOPIC.ITEM<1>,VM)
TOPIC.CN = 0
*#
IF TEST.FLAG GE 5 AND TEST.FLAG LE 7 THEN
LOOP
TOPIC.CN = TOPIC.CN + 1
$INCLUDE IBP SYS.INCL.11.ABORT
*#
WHILE NOT(SYS.ABORT OR USER.ABORT) AND TOPIC.CN LE TOPIC.ITEM.MAX DO
TOPIC.KEY = TOPIC.ITEM<1,TOPIC.CN>
TASK.FILE = FIELD(TOPIC.KEY,"*",4)
TASK.ITEM = FIELD(TOPIC.KEY,"*",3)
IF LEN(TASK.FILE) AND LEN(TASK.ITEM) THEN
$INCLUDE IBP SYS.REL.INCL.VERIFY.FILE
IF SYS.UPD THEN
TASK.INDEX.DATA = ""
TASK.XREF.FUNC = 3
STAT = SYS.ABORT+USER.ABORT
TEMP.FILE = TASK.FILE
IF TEMP.FILE[1,5] EQ "DICT " THEN TEMP.FILE = "DICT.":TEMP.FILE
TEMP.FILE = SYS.PREFIX:TEMP.FILE:SYS.SUFFIX
CALL SYS.REL.XREF(SY.FILE,TASK.USER,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TASK.TOPIC,TASK.TOPIC.CN,TEMP.FILE,TASK.ITEM,TASK.VAR,XREF.FUNC,TASK.INDEX.ID,TASK.INDEX.DATA,STAT,SYS.RUN.STAT)
IF STAT NE 1 THEN SYS.ABORT = STAT
END; *# OF SYS.UPD
END; *# OF LEN(TASK AND ITEM)
*#
PRINT CLL:"[=| ":TASK.APPL:"  ":TASK.NUM:"  ":TASK.FILE:"  ":TASK.ITEM
PRINT CLL:"[=| "
REPEAT; *# NEXT TOPIC
END; *# of TEST.FLAG GE 5
*#
END; *# OF TOPIC.ON.FILE
*#
REPEAT; *# For loop thru tasks
*#
REL.COMP.ID = "@REL@":TASK.CO:"@":TASK.APPL:"@":NEXT.REL:"@COMPARE"
END ELSE
PRINT
PRINT "ENTER THE LIST TO USE: ":; INPUT REL.COMP.ID
PRINT
IF REL.COMP.ID EQ "" THEN
REL.COMP.ID = "@LIST@":TASK.FILE
END
END; *# OF TEST.FLAG LT 10 AND NOT ABORT
*#
IF TEST.FLAG EQ 5 THEN RETURN; *# TO CALLING PROGRAM
IF TEST.FLAG EQ 6 THEN TEST.FLAG = 3
IF TEST.FLAG EQ 7 THEN TEST.FLAG = 4
*#
REL.COMP.CN = 0
SYS.ITEM = REL.COMP.ID
READ REL.COMP.INDEX FROM SY.FILE,SYS.ITEM ELSE
REL.COMP.INDEX = ""
SYS.ABORT = 6
ERROR.TEXT = "Release (":NEXT.REL:") Compare record is missing, ABORT!"
ERROR.CODE = "16001"
GOSUB ERROR.CONTROL
END
*#
READ REL.COMP FROM SY.FILE,SYS.ITEM:"@DATA" ELSE
REL.COMP = ""
*SYS.ABORT = 6
ERROR.TEXT = "Release (":NEXT.REL:") Compare DATA record is empty, ABORT!"
ERROR.CODE = "16001"
GOSUB ERROR.CONTROL
END
REL.COMP.MAX = DCOUNT(REL.COMP.INDEX,AM)
IF NOT(REL.COMP.MAX) THEN
SYS.ABORT = 6
ERROR.TEXT = "Release (":NEXT.REL:") Compare record is empty, ABORT!"
ERROR.CODE = "16001"
GOSUB ERROR.CONTROL
END
XREF.INDEX.ID = REL.COMP.ID
SYS.RUN.STAT = 2
*# 
IF TEST.FLAG LE 4 THEN
*# 
LOOP
*#
REL.COMP.CN = REL.COMP.CN + 1
*#
$INCLUDE IBP SYS.INCL.11.ABORT
*#
WHILE NOT(USER.ABORT OR USER.ABORT) AND REL.COMP.CN LE REL.COMP.MAX DO
*#
REL.COMP.KEY = REL.COMP.INDEX<REL.COMP.CN>
*#
IF SYS.RUN.TYPE EQ 9 THEN
TASK.FILE = FIELD(REL.COMP.KEY,"@",1)
END; *# ELSE TASK.FILE DOES NOT CHANGE
TEMP.FILE = TASK.FILE
IF TEMP.FILE[1,LEN(SYS.PREFIX)] EQ SYS.PREFIX THEN TEMP.FILE = TEMP.FILE[LEN(SYS.PREFIX)+1,99]
TEMP = LEN(SYS.SUFFIX)
IF TEMP THEN
TEMP1 = LEN(TEMP.FILE)
IF TEMP.FILE[TEMP1-TEMP+1,TEMP] EQ SYS.SUFFIX THEN
TEMP.FILE = TEMP.FILE[1,TEMP1-TEMP]
END
END
IF TEMP.FILE[1,5] EQ "DICT." THEN TEMP.FILE = "DICT ":TEMP.FILE
IF SYS.RUN.TYPE EQ 9 OR COUNT(REL.COMP.KEY,"@") THEN
*TASK.ITEM = FIELD(REL.COMP.KEY,"@",2)
TEMP = FIELD(REL.COMP.KEY,"@",1)
TASK.ITEM = REL.COMP.KEY[COL2()+1,50]
END ELSE TASK.ITEM = FIELD(REL.COMP.KEY,"@",1)
*#
**INCLUDE IBP SYS.REL.INCL.VERIFY.FILE
*# CODE.SEGMENT: SYS.ALL.INCL.VERIFY.FILE
*#
TEMP.FILE = TASK.FILE
*#
TEMP = FIELD(TEMP.FILE,".",1)
*#
LOCATE(TEMP,SYSTEM.ALL;SYS.SYSTEM.FLAG) THEN
PRINT
PRINT "SYSTEM LOCATED":SYS.SYSTEM.FLAG
PRINT
TEMP1 = TRUE
END ELSE
TEMP1 = FALSE
PRINT
PRINT "SYSTEM NOT PRESENT"
PRINT
SYS.SYSTEM.FLAG = 1
TEMP = "ULT"
END
LOCATE(TEMP,SYSTEM.REL;SYS.SYSTEM.REL) ELSE SYS.SYSTEM.REL = FALSE
IF TEMP1 THEN
TEMP9 = FIELD(TEMP.FILE,".",1)
TEMP.FILE = TEMP.FILE[COL2()+1,50]
TEMP = FIELD(TEMP.FILE,".",1)
END
PRINT TEMP.FILE
*#
LOCATE(TEMP,ACCT.ALL;SYS.ACCT.FLAG) THEN
PRINT
PRINT "ACCT LOCATED":SYS.ACCT.FLAG
PRINT
TEMP1 = TRUE
END ELSE
TEMP1 = FALSE
SYS.ACCT.FLAG = 1
PRINT
PRINT "ACCT NOT PRESENT"
PRINT
TEMP = "AX"
END
LOCATE(TEMP,ACCT.REL;SYS.ACCT.REL) ELSE SYS.ACCT.REL = FALSE
IF TEMP1 THEN
TEMP.FILE = TEMP.FILE[COL2()+1,50]
TEMP = FIELD(TEMP.FILE,".",1)
END
PRINT TEMP.FILE
*#
IF TEMP.FILE[1,5] EQ "DICT " THEN TEMP.FILE = "DICT.":TEMP.FILE[6,99]
IF TEMP.FILE[1,4] EQ "OLD " THEN TEMP.FILE = "OLD.":TEMP.FILE[5,99]
*#
TEMP = FIELD(TEMP.FILE,".",1)
*#
IF TEMP = "OLD" THEN
PRINT
PRINT "THIS IS AN OLD FILE"
PRINT
TEMP.FILE = TEMP.FILE[5,99]
SYS.OLD.FLAG = TRUE
END ELSE
SYS.OLD.FLAG = FALSE
END
*#
IF TEMP = "DICT" THEN
PRINT
PRINT "THIS IS AN DICTIONARY FILE"
PRINT
TEMP.FILE = TEMP.FILE[6,99]
SYS.DICT.FLAG = TRUE
END ELSE
SYS.DICT.FLAG = FALSE
END
*#
*#
TEMP.FILE = SYS.PREFIX:TEMP.FILE:SYS.SUFFIX
*#
LOCATE(TEMP.FILE,FILE.ALL;SYS.FILE.FLAG) ELSE SYS.FILE.FLAG = FALSE
LOCATE(TEMP.FILE,FILE.REL;SYS.FILE.REL) ELSE SYS.FILE.REL = FALSE
*#
SYS.UPD = TRUE
IF NOT(SYS.SYSTEM.REL) OR NOT(SYS.ACCT.REL) OR NOT(SYS.FILE.REL) THEN SYS.UPD = FALSE
*#
PRINT
PRINT
PRINT "The file ":TEMP.FILE:" has a validation of ":SYS.UPD
PRINT
PRINT
*@@@^
*#
IF LEN(TEMP.FILE) AND LEN(TASK.ITEM) AND SYS.UPD THEN
TASK.INDEX.DATA = ""
*XREF.INDEX.DATA = REL.COMP<REL.COMP.CN>
*TASK.XREF.FUNC = TEST.FLAG
IF SYS.RUN.TYPE EQ 9 THEN
TASK.XREF.FUNC = 4
END ELSE IF SYS.RUN.TYPE EQ 7 THEN
TASK.XREF.FUNC = 3
END ELSE TASK.XREF.FUNC = 2
STAT = SYS.ABORT+USER.ABORT
*#
PRINTER ON
PRINT FF:
PRINT STR("*",70)
*PRINT STR("*",70)
*PRINT STR("*",70)
*PRINT
*PRINT SPACE(25):"RELEASE COMPARE RUN FOR:"
*PRINT
*PRINT SPACE(35):"Company: ":TASK.CO
*PRINT SPACE(35):"   Appl: ":TASK.APPL
*PRINT SPACE(35):"Release: ":TASK.REL
*PRINT
PRINT SPACE(10):TASK.FILE:"  ":TASK.ITEM
*PRINT
PRINT SPACE(10):OCONV(DATE(),"D2"):" ":OCONV(TIME(),"MT")
PRINT
*PRINT
*PRINT STR("*",70)
*PRINT STR("*",70)
*PRINT
PRINTER OFF
*#
TASK.FILE1 = "OLD.":TEMP.FILE
TASK.FILE2 = "PC.":TEMP.FILE
IF TASK.XREF.FUNC EQ 4 THEN
TASK.FILE3 = "REL.CHANGES"
END ELSE TASK.FILE3 = "COMPARE.CHANGES"
*#
*GOSUB DISPLAY.ELP
*#
CALL SYS.REL.COMPARE.SUB(SY.FILE,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TEMP.FILE,TASK.ITEM,TASK.FILE1,TASK.FILE2,TASK.FILE3,TASK.XREF.FUNC,TASK.INDEX.ID,TASK.INDEX.DATA,STAT,SYS.RUN.STAT)
IF STAT NE 1 THEN
IF STAT EQ 6 THEN
PRINT.TEXT = "A fatal error occured in the Compare processor! This item skipped!"
PRINT BELL:
PRINT CLL:"[=| ":PRINT.TEXT
PRINTER OFF
PRINT CLL:"[=| ":PRINT.TEXT
PRINTER ON
PRINT CLL:"[=| "
RQM
END ELSE
SYS.ABORT = STAT
END
END
EXEC.RESULTS = TASK.INDEX.DATA
*#
REL.COMP<REL.COMP.CN> = TASK.INDEX.DATA
PRINTER ON
*PRINT CLL:"[=| "
*PRINT CLL:"[=| "
*#
IF TASK.INDEX.DATA<1,11> THEN
IF TASK.INDEX.DATA<1,11> = 1 THEN
PRINT.TEXT = TASK.ITEM:" has been changed this release."
END ELSE
PRINT.TEXT = TASK.ITEM:" is a new item."
END
PRINT BELL:
PRINT CLL:"[=| ":PRINT.TEXT
PRINTER OFF
PRINT CLL:"[=| ":PRINT.TEXT
PRINTER ON
*PRINT CLL:"[=| "
RQM
END
*#
IF TASK.INDEX.DATA<1,12> THEN
IF TASK.INDEX.DATA<1,12> EQ 1 THEN
PRINT.TEXT = TASK.ITEM:" has been changed in file ":TASK.FILE2:"."
END ELSE
PRINT.TEXT = TASK.ITEM:" was not present in the ":TASK.FILE2:" import file."
END
*PRINT CLL:"[=| "
PRINTER OFF
PRINT CLL:"[=| ":PRINT.TEXT
PRINTER ON
*PRINT CLL:"[=| "
PRINT CLL:"[=| ":PRINT.TEXT
PRINT BELL:; RQM
*#
IF TASK.INDEX.DATA<1,11> EQ 1 AND TASK.INDEX.DATA<1,12> EQ 1 THEN
*PRINT CLL:"[=| "
*PRINT CLL:"[=| "
FOR TEMP = 1 TO 2
IF NOT(SYSTEM(11)) THEN PRINT BELL:; RQM
PRINT CLL:"[=| ":RVB:BELL:"* * * * ITEM CHANGED IN BOTH FILES * * * *":RVE
PRINTER OFF
PRINT CLL:"[=| ":RVB:BELL:"* * * * ITEM CHANGED IN BOTH FILES * * * *":RVE
PRINTER ON
NEXT TEMP
PRINT CLL:"[=| "
END
*#
END
*#
*@SYS@DEV@XREF@INDEX@SRR
*@SYS@DEV@XREF@INDEX@SRC
*#
SYS.ITEM = "@SYS@DSTAT@":TASK.ITEM 
READ BP.RUNS FROM INP.FILE.DICT,SYS.ITEM ELSE BP.RUNS = "" ; *#
*TEMP = BP.RUNS<10>
*IF LEN(TEMP) LT 20 THEN TEMP = TEMP:STR("0",20-LEN(TEMP))
*TEMP.VAL = TEMP[SYS.RUN.ATTR<SYS.RUN.TYPE>,1]
*BP.RUNS<SYS.RUN.ATTR<SYS.RUN.TYPE>> = START.DATE:SVM:START.TIME:SVM:ELP.TIME:SVM:USER.NAME:VM:BP.RUNS<SYS.RUN.ATTR<SYS.RUN.TYPE>>
**#
*EXEC.RESULTS = "COMP: ":TASK.CO:"  APPL: ":TASK.APPL:"  REL: ":TASK.REL:AM:"TASK: ":TASK.NUM:"  STEP: ":TASK.STEP:AM:"STAT: ":SYS.RUN.STAT:"  TYPE: ":SYS.RUN.TYPE:" PROCESS TYPE: ":SYS.PROC.TYPE:AM:"VERB: ":EXEC.VERB:"     FILE: ":TASK.FILE:"    ITEM: ":TASK.ITEM:AM:EXEC.RESULTS:AM:AM:OCONV(DATE(),"D2"):"    ":OCONV(TIME(),"MT"):" ":USER.NAME:" ":WHO:" ":OCONV(ELP.TIME,"MTS"):AM:SYS.RUN.MESSAGE<SYS.RUN.TYPE>:" completed":AM:AM
**# 
*SYS.ITEM = "@SYS@ESTAT@":SYS.RUN.CODE<SYS.RUN.TYPE>:"@":TASK.ITEM
*WRITE EXEC.RESULTS ON INP.FILE.DICT,SYS.ITEM
*# 
*# 
PRINT CLL:"[=| "
PRINT CLL:"[=| "
EXEC.PARAMS = ""
IF EXEC.RESLTS THEN
EXEC.PARSE.TEXT = ""
CALL.ID = "SYS.REL.PARSE.":SYS.RUN.CODE<SYS.RUN.TYPE>
CALL @CALL.ID(EXEC.RESULTS,SYS.RUN.RESLTS.ATTR<SYS.RUN.TYPE>,EXEC.PARSE,SYS.RUN.STAT,EXEC.PARSE.TEXT) ; *#
SYS.RESULTS.ATTR =  SYS.RUN.RESLTS.ATTR<SYS.RUN.TYPE>
TEMP = DCOUNT(EXEC.PARSE,AM)
*PRINT CLL:"[=| "
FOR A = TRUE TO TEMP
BP.RUNS<SYS.RESULTS.ATTR+A> = EXEC.PARSE<A>
NEXT A
END ELSE
*IF SYS.RUN.TYPE EQ 1 THEN SYS.PROC.STAT = 1
END
*# 
GOSUB GET.COMPL ; *#
*# 
PRINTER OFF
PRINTER CLOSE
*#
END ELSE
IF NOT(SYS.UPD) THEN
PRINTER ON
PRINT "THE FILE LOCATE FAILDED!"
PRINTER OFF
PRINT "THE FILE LOCATE FAILDED!"
END
PRINTER ON
PRINT "THE ITEM WAS REJECTED!!!"
PRINTER OFF
PRINT "THE ITEM WAS REJECTED!!!"
END; *# OF LEN(TASK AND ITEM) AND SYS.UPD
*#
REPEAT; *# For item processing
*#
END ELSE
PRINTER ON
PRINT "TEST FLAG SET TO 7, RELEASE SEARCH SKIPPED"
PRINTER OFF
PRINTER CLOSE
END; *# OF TEST.FLAG LE 7
*#
*###
*###
SYS.ITEM = REL.COMP.ID
PRINTER ON
PRINT "REL.COMP.ID IS ":REL.COMP.ID
PRINTER OFF
WRITE REL.COMP.INDEX ON SY.FILE,SYS.ITEM
WRITE REL.COMP ON SY.FILE,SYS.ITEM:"@DATA"
SYS.ITEM = "@SYS@USER@":USER.NAME
MATWRITE STRUCT ON SY.FILE,SYS.ITEM
SYS.ITEM = "@SYS@DEV@":USER.NAME:"@":PORT+1
WRITE PORT.ACCESS ON SY.FILE,SYS.ITEM
*#
*#
PRINTER OFF
PRINTER CLOSE
PRINTER ON
LN = 999
PG = 0
CN = 0
CN.MAX = DCOUNT(REL.COMP.INDEX,AM)
LOOP
CN = CN + 1
WHILE CN LE CN.MAX DO
*NEXT.ID = REL.COMP.INDEX<CN>
NEXT.DATA = REL.COMP<CN>
NEXT.ID = NEXT.DATA<1,1>
IF LN GT 50 THEN
PG = PG + 1
PRINT FF
PRINT STR(".",75)
PRINT
PRINT SPACE(10):OCONV(DATE(),"D2"):" ":SPACE(15):"RESULTS OF COMPARE":@(60):OCONV(TIME(),"MT")
PRINT
PRINT SPACE(60):"PAGE: ":PG
PRINT SPACE(60):"CURR: ":NEXT.ID "L#15"
PRINT
PRINT STR(".",75)
PRINT
LN = 1
END
*#
*#
TEMP = NEXT.ID:" ":STR(".",30)
PRINT TEMP "L#35":" ":
PRINT "BY-":NEXT.DATA<1,3> "L#6":" ":
PRINT "CK-":NEXT.DATA<1,2> "L#14":" ":
PRINT "UL-":NEXT.DATA<1,11> "L#1":" ":
PRINT "PC-":NEXT.DATA<1,12> "L#1":" ":
PRINT "DE-":NEXT.DATA<1,10> "L#1":" ":
PRINT "OB-":NEXT.DATA<1,5> "L#1":" ":
PRINT "NL-":NEXT.DATA<1,6> "L#7":" ":
PRINT "OL-":NEXT.DATA<1,7> "L#7":" ":
PRINT
*#
REPEAT
LN = LN + 1
PRINTER OFF
PRINTER CLOSE
*#
LAST.FILE = TASK.FILE
LAST.ITEM = TASK.ITEM
*#
END; *# OF ABORT
$INCLUDE IBP SYS.INCL.11.ABORT
*#
*GOSUB GET.COMPL
*#
*#WHILE NOT(SYS.ABORT OR USER.ABORT) AND SYS.PROC.TYPE LE 4 DO REPEAT
*# 
GOTO END.OF.PROGRAM
*#
$INCLUDE IBP SYS.REL.INCL.DISPLAY
*#
$INCLUDE IBP SYS.REL.INCL.COMPL
*# 
$INCLUDE IBP SYS.REL.INCL.ERROR
*# 
END.OF.PROGRAM: *# Normal End
*# 
*# 
END
~SYS.REL.XREF~
SUBROUTINE SYS.REL.XREF(SY.FILE,TASK.USER,TASK.CO,TASK.APPL,TASK.REL,TASK.NUM,TASK.STEP,TASK.TOPIC,TASK.TOPIC.CN,TASK.FILE,TASK.ITEM,TASK.VAR,XREF.FUNC,XREF.INDEX.ID,XREF.INDEX.DATA,STAT,SYS.RUN.STAT)
*SUBROUTINE: SYS.REL.XREF
*
* AUTHOR: DAVID G. HORSMAN
*
*# XREF.FUNC
*# 1 - VERIFY TASK IN RELEASE
*# 2 -   "     "    "    "   ,ADD IF NOT
*# 3 - ADD TASK TO RELASE
*# 9 - DELETE TASK FROM RELEASE
*#
*#
$INCLUDE IBP STANDARD.FUNCTIONS
*# Load program control variables.
DIM XREF.INDEX(50)
SYS.ITEM = XREF.INDEX.ID
SYS.PROG.TYPE= 7
SYS.ABORT = FALSE
USER.ABORT = FALSE
*
MATREAD XREF.INDEX FROM SY.FILE,SYS.ITEM ELSE RETURN
SYS.PROG = "SYS.REL.EDIT"
SYS.PROG.TYPE = 2
DISP.FLAG = 1
*# 0 or unassigned = FOREIGN ROUTINE
*# 1 = TCL PROGRAM
*# 2 = TCL PROC
*# 3 = SYS MAIN (TCL/PROC) ROUTINE
*# 7 = CALL SUBROUTINE
*# 8 = SYS SUBROUTINE CALL
*# 
SYS.ABORT = FALSE
USER.ABORT = FALSE
*#   - for rel's @REL@xxCOxx@xxAPPLxx@xxRELxx (control record)
*#   - for files @REL@xxCOxx@xxAPPLxx@xxRELxx@FILE
*#   - for item  @REL@xxCOxx@xxAPPLxx@xxRELxx@xxFILExx@ITEM
*#   - for tasks @REL@xxCOxx@xxAPPLxx@xxRELxx@TASK
*#   - note xrefs are formed by backing off the xx?xx's and substituting
*#          the capitals letter codes.
*#   - note additional xrefs are
*#     @SYS@DEV@VAR@xxCOxx         for company level variables
*#     @SYS@DEV@VAR@xxCOxx@xxAPPLxx        for appl level vars
*#     @SYS@DEV@VAR@xxCOxx@xxAPPLxx@xxPROGxx for program/funct vars
*# 
*#   - note the above addt. xrefs can have FILE substituted for VAR
*#   - note  "    "     "     "    "    "  PROG      "       "   "
*# 
IF DISP.FLAG THEN
PRINT CLL:"[=| "
PRINT CLL:"[=| ":"Xref ":
END
*# 
CN = 1
LOOP
CN = CN + 1
IF XREF.INDEX(CN)[1,1] NE "*" THEN
XREF.PARM.KEY = XREF.INDEX(CN)<1,1,1>
XREF.INSR.KEY = XREF.INDEX(CN)<1,2,1>
XREF.PARM.KEY.LEN = LEN(XREF.PARM.KEY)
XREF.STR = ''
END
WHILE NOT(SYS.ABORT OR USER.ABORT) AND CN LE 50 AND XREF.PARM.KEY.LEN DO
IF XREF.INDEX(CN)[1,1] NE "*" THEN
CN1 = 0
CN1.MAX = COUNT(XREF.PARM.KEY,"@")+1
LOOP
CN1 = CN1 + 1
XREF.PARM = FIELD(XREF.PARM.KEY,"@",CN1)
WHILE NOT(SYS.ABORT OR USER.ABORT) AND CN1 LE CN1.MAX DO
XREF.STR = XREF.STR:"@"
GOSUB PARSE.XREF.PARM
$INCLUDE IBP SYS.INCL.11.ABORT
REPEAT
XREF.STR = XREF.STR[2,999]
*#
XREF.ID = XREF.STR
XREF.STR = ''
XREF.PARM.KEY = XREF.INSR.KEY
XREF.PARM.KEY.LEN = LEN(XREF.INSR.KEY)
CN1 = 0
CN1.MAX = COUNT(XREF.PARM.KEY,"@")+1
LOOP
CN1 = CN1 + 1
XREF.PARM = FIELD(XREF.PARM.KEY,"@",CN1)
$INCLUDE IBP SYS.INCL.11.ABORT
WHILE NOT(SYS.ABORT OR USER.ABORT) AND CN1 LE CN1.MAX DO
XREF.STR = XREF.STR:"@"
GOSUB PARSE.XREF.PARM
REPEAT
*#
XREF.STR = XREF.STR[3,999]
IF NOT(SYSTEM(11)) THEN
*IF DISP.FLAG THEN PRINT 
*IF DISP.FLAG THEN PRINT XREF.ID
*IF DISP.FLAG THEN PRINT XREF.STR
*IF DISP.FLAG THEN PRINT 
END
*# READ XREF.ITEM
SYS.ITEM = XREF.ID
READ XREF.ITEM FROM SY.FILE,SYS.ITEM ELSE XREF.ITEM = ""
IF XREF.INDEX(CN)<1,3,1> THEN
SYS.ITEM = XREF.ID:"@DATA"
READ XREF.DATA.ITEM FROM SY.FILE,SYS.ITEM ELSE XREF.DATA.ITEM = ""
END
*#
*# LOAD XREF.ATTRIBUTE
*XREF.ATTR = XREF.INDEX(CN)<1,1,3>
*#
*# LOCATE XREF.STR LOC
XREF.ON.FILE = 1
LOCATE(XREF.STR,XREF.ITEM;XREF.LOC;"AL") ELSE XREF.ON.FILE = 0
*#
IF NOT(XREF.ON.FILE) THEN
IF DISP.FLAG THEN PRINT "u":
XREF.ITEM = INSERT(XREF.ITEM,XREF.LOC,0,0;XREF.STR)
IF XREF.INDEX(CN)<1,3,1> THEN
XREF.DATA.ITEM = INSERT(XREF.DATA.ITEM,XREF.LOC,0,0;XREF.INDEX.DATA)
END
*#
*# UPDATE ATTRIBUTE
*#.....N/A
*#
*# WRITE XREF.ITEM
SYS.ITEM = XREF.ID
WRITE XREF.ITEM ON SY.FILE,SYS.ITEM
IF XREF.INDEX(CN)<1,3,1> THEN
SYS.ITEM = XREF.ID:"@DATA"
WRITE XREF.DATA.ITEM ON SY.FILE,SYS.ITEM
END
*#
END ELSE
IF DISP.FLAG THEN PRINT "x":
END; *# OF NOT(XREF.ON.FILE)
*#
END; *# OF NOT [1,1] EQ "*"
*#
$INCLUDE IBP SYS.INCL.11.ABORT
*#
TEMP = RND(201)
IF TEMP EQ 30 THEN
TC2 = 17 - RND(5)
TC1 = FALSE
FOR A = 1 TO TC2
TC = CHAR(RND(95)+31)
PRINT TC:
IF RND(7) EQ 4 THEN PRINT BELL:
IF RND(5) EQ 4 THEN RQM
IF RND(9) EQ 7 THEN PRINT RVB:; TC1 = TRUE
IF RND(4) EQ 3 AND TC1 THEN PRINT RVE:; TC1 = FALSE
NEXT A
IF TC1 THEN PRINT RVE:; TC1 = FALSE
PRINT " Buurrrrppppp!!! ":BELL
PRINT
END
*#
REPEAT
IF DISP.FLAG THEN PRINT " |=]"
*#
STAT = 0
*#
IF DISP.FLAG THEN PRINT CLL:"[=| "
*#
IF SYS.ABORT OR USER.ABORT THEN STAT = SYS.ABORT+USER.ABORT
*#
RETURN; *# TO CALLING PROGRAM
*#
PARSE.XREF.PARM: *#
*#
BEGIN CASE
CASE XREF.PARM = "u"
XREF.STR = XREF.STR:TASK.USER
CASE XREF.PARM = "c"
XREF.STR = XREF.STR:TASK.CO
CASE XREF.PARM = "a"
XREF.STR = XREF.STR:TASK.APPL
CASE XREF.PARM = "r"
XREF.STR = XREF.STR:TASK.REL
CASE XREF.PARM = "n"
XREF.STR = XREF.STR:TASK.NUM
CASE XREF.PARM = "s"
XREF.STR = XREF.STR:TASK.STEP
CASE XREF.PARM = "f"
XREF.STR = XREF.STR:TASK.FILE
CASE XREF.PARM = "i"
XREF.STR = XREF.STR:TASK.ITEM
CASE XREF.PARM = "t"
XREF.STR = XREF.STR:SYS.RUN.TYPE
CASE XREF.PARM = "v"
XREF.STR = XREF.STR:TASK.VAR
CASE XREF.PARM[1,1] = "b"
IF XREF.PARM EQ "b" THEN
XREF.STR = XREF.STR:XREF.INDEX.DATA
END ELSE
TEMP = FIELD(XREF.PARM,"<",2)
TEMP = FIELD(TEMP,">",1)
IF LEN(TEMP) THEN
TEMP1 = FIELD(TEMP,",",1)
IF NOT(NUM(TEMP1)) THEN TEMP1 = 1
IF NOT(TEMP1) THEN TEMP1 = 1
IF TEMP1 LT 0 THEN TEMP1 = 1
TEMP2 = FIELD(TEMP,",",2)
IF NOT(NUM(TEMP2)) THEN TEMP2 = 0
IF TEMP2 LT 0 THEN TEMP2 = 0
TEMP3 = FIELD(TEMP,",",3)
IF NOT(NUM(TEMP3)) THEN TEMP3 = 0
IF TEMP3 AND NOT(TEMP2) THEN TEMP2 = 1
IF TEMP3 LT 0 THEN TEMP3 = 0
TEMP4 = FIELD(TEMP,",",4)
IF NOT(NUM(TEMP4)) THEN TEMP4 = 1
IF TEMP4 LT 0 THEN TEMP4 = 1
TEMP5 = FIELD(TEMP,",",5)
IF NOT(NUM(TEMP5)) THEN TEMP5 = 1
IF TEMP5 LT 0 THEN TEMP5 = 1
TEMP = XREF.INDEX.DATA<TEMP1,TEMP2,TEMP3>
IF TEMP4 THEN TEMP = FIELD(TEMP,"*",TEMP4)
IF TEMP5 THEN TEMP = FIELD(TEMP,"#",TEMP5)
XREF.STR = XREF.STR:TEMP
END
END
CASE TRUE
XREF.STR = XREF.STR:XREF.PARM
*#
CASE XREF.PARM[1,1] = "l"
TC2 = XREF.PARM[2,1]
TC3 = XREF.PARM[3,1]
BEGIN CASE
CASE TC2 EQ "A"
XREF.STR = XREF.STR:ACCT
CASE TC2 EQ "P"
XREF.STR = XREF.STR:PORT
CASE TC2 EQ "D"
XREF.STR = XREF.STR:DATE()
CASE TC2 EQ "T"
XREF.STR = XREF.STR:TIME()
CASE TC2 EQ "l"
XREF.STR = XREF.STR:"@"
CASE TC2 EQ "<"
LOOP WHILE XREF.STR[LEN(XREF.STR),1] EQ TC3 DO XREF.STR = XREF.STR[1,LEN(XREF.STR)-1] REPEAT
END CASE
*#
END CASE
*
RETURN
*
END
~XTALK.ALL.TO.REV~
*PROGRAM: XTALK.ALL.TO.REV 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       TRANSMITS ALL CHANGES FROM ULTIMATE TO REVELATION USING XTALK
* DATE WRITTEN:      07 FEB 86
* DATE RELEASED:     07 FEB 86
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
$INCLUDE IBP STANDARD.FUNCTIONS
*
PRINT "XTALK.ALL.TO.REV - Dumps data to a Crosstalk XVI personal"
*
!
*
OPEN "CNT" TO CNT.FILE ELSE PRINT "Can't open CNT":; INPUT RSP; STOP
READ FILE.LIST FROM CNT.FILE,"FILE.LIST" ELSE PRINT "Can't find FILE.LIST in CNT":; INPUT RSP; STOP
PRINT "\\\":"\\\"
FILE.NUM = 0
LOOP
FILE.NUM = FILE.NUM+1
FILE.NAME = FILE.LIST<FILE.NUM>
IN.NAME = FILE.NAME
IF IN.NAME[1,4] = "ULT." THEN IN.NAME = IN.NAME[5,99]
DICT.NAME = ""; IF IN.NAME[1,5] = "DICT." THEN IN.NAME = IN.NAME[6,99]; DICT.NAME = "DICT"
UNTIL FILE.NAME = "" DO
OPEN DICT.NAME,IN.NAME TO IN.FILE ELSE PRINT "Can't open ":TRIM(DICT.NAME:" ":IN.NAME); INPUT RSP; STOP
READ NEW.CKSUMS FROM IN.FILE,"CHECKSUMS.LIST" ELSE NEW.CKSUMS = ""
READ OLD.CKSUMS FROM IN.FILE,"CHECKSUMS.LIST1" ELSE OLD.CKSUMS = ""
IF NEW.CKSUMS # OLD.CKSUMS THEN
LIST.NUM = 0
LOOP
LIST.NUM = LIST.NUM+1
ID = NEW.CKSUMS<LIST.NUM,1>
NEW.SUM = NEW.CKSUMS<LIST.NUM,2>
UNTIL ID = "" DO
OLD.SUM = ""
IF NEW.SUM # "\\\DELETED\\\" THEN
LOCATE ID IN OLD.CKSUMS BY "AL" SETTING LOC ELSE LOC = LOC-1
IF ID = OLD.CKSUMS<LOC,1> THEN
OLD.SUM = OLD.CKSUMS<LOC,2>
DEL OLD.CKSUMS<LOC>
END
END
IF OLD.SUM # NEW.SUM THEN
READ ITEM FROM IN.FILE,ID ELSE ITEM = "\\\DELETED\\\"
PRINT FILE.NAME:" ":ID
*
MAX.AC = COUNT(ITEM,AM)+1
FOR AC = 1 TO MAX.AC
PRINT "+":ITEM<AC>
NEXT AC
END
REPEAT
*
LIST.NUM = 0
LOOP
LIST.NUM = LIST.NUM+1
ID = OLD.CKSUMS<LIST.NUM,1>
UNTIL ID = "" DO
PRINT FILE.NAME:" ":ID
PRINT "+\\\DELETED\\\"
*
REPEAT
*
END
*
REPEAT
*
!
*
STOP
*
*
END
~XTALK.TO.REV~
*PROGRAM: XTALK.TO.REV 
* AUTHOR:            BOB CONARROE - AXION
* DESCRIPTION:       TRANSMITS DATA FROM ULTIMATE TO REVELATION USING XTALK.
* DATE WRITTEN:      05 MAR 85
* DATE RELEASED:     05 MAR 85
* MODIFICATIONS:     DATE       NAME        DESCRIPTION
*                    DD MMM YY
$INCLUDE IBP STANDARD.FUNCTIONS
*
!
*
PRINT "XTALK.TO.REV - Dumps data to a Crosstalk XVI personal"
*
PRINT "Enter file name: ":
INPUT FILE.NAME; IF FILE.NAME = "" THEN STOP
IN.NAME = FILE.NAME
IF IN.NAME[1,4] = "ULT." THEN IN.NAME = IN.NAME[5,99]
DICT.NAME = ""; IF IN.NAME[1,5] = "DICT." THEN DICT.NAME = "DICT"; IN.NAME = IN.NAME[6,99]
DISP.NAME = TRIM(DICT.NAME:" ":IN.NAME)
PREFIX = FIELD(FILE.NAME,",",2); IF PREFIX # "" THEN PREFIX = PREFIX:"."
OPEN DICT.NAME,IN.NAME ELSE PRINT "Can't open ":DISP.NAME; STOP
PRINT "Enter list name: ":
INPUT LIST.NAME
IF LIST.NAME = "" THEN
EXECUTE "SSELECT ":DISP.NAME, //SELECT. > FILE.ID.LIST
END ELSE
EXECUTE "GET-LIST ":LIST.NAME, //SELECT. > FILE.ID.LIST
END
OUT.FILE = 64
*
!
*
NEW.FILE: *
*
PRINT "\\\":"\\\"
OUT.FILE = OUT.FILE+1
PRINT "The letter of the next file is ":CHAR(OUT.FILE):"  ..."; INPUT RSP
EXECUTE "SLEEP 2"
PRINT CHAR(OUT.FILE)
OUT.LENGTH = 10
*
!
*
READ.NEXT: *
*
READNEXT ID FROM FILE.ID.LIST ELSE PRINT "%%%"; STOP
READ ITEM FROM ID ELSE GOTO READ.NEXT
PRINT PREFIX:ID
*
MAX.AC = COUNT(ITEM,AM)+1
FOR AC = 1 TO MAX.AC
PRINT "+":ITEM<AC>
OUT.LENGTH = OUT.LENGTH+3
NEXT AC
OUT.LENGTH = OUT.LENGTH+LEN(ITEM)
IF OUT.LENGTH > 30000 THEN GOTO NEW.FILE
GOTO READ.NEXT
*
*
END
